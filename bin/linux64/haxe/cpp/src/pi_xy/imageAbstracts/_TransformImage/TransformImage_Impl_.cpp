// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericCell_Int
#include <haxe/ds/GenericCell_Int.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericStack_Int
#include <haxe/ds/GenericStack_Int.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_iterMagic_ArrIntImg
#include <iterMagic/ArrIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_BytesImg
#include <iterMagic/BytesImg.h>
#endif
#ifndef INCLUDED_iterMagic_Iimg
#include <iterMagic/Iimg.h>
#endif
#ifndef INCLUDED_iterMagic_StackIntImg
#include <iterMagic/StackIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_U32ArrImg
#include <iterMagic/U32ArrImg.h>
#endif
#ifndef INCLUDED_iterMagic_VecIntImg
#include <iterMagic/VecIntImg.h>
#endif
#ifndef INCLUDED_pi_xy_ImageStruct
#include <pi_xy/ImageStruct.h>
#endif
#ifndef INCLUDED_pi_xy__Endian_Endian_Fields_
#include <pi_xy/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitQuad
#include <pi_xy/algo/HitQuad.h>
#endif
#ifndef INCLUDED_pi_xy_algo_IhitObj
#include <pi_xy/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pi_xy_algo_QuadPoints_
#include <pi_xy/algo/QuadPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_imageAbstracts__TransformImage_TransformImage_Impl_
#include <pi_xy/imageAbstracts/_TransformImage/TransformImage_Impl_.h>
#endif
#ifndef INCLUDED_pi_xy_iter_IntIterStart
#include <pi_xy/iter/IntIterStart.h>
#endif
#ifndef INCLUDED_pi_xy_transformation__FlipImage_FlipImage_Fields_
#include <pi_xy/transformation/_FlipImage/FlipImage_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_transformation__ScaleImage_ScaleImage_Fields_
#include <pi_xy/transformation/_ScaleImage/ScaleImage_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_transformation__SpinImage_SpinImage_Fields_
#include <pi_xy/transformation/_SpinImage/SpinImage_Fields_.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_68d25436a32dba6f_10__new,"pi_xy.imageAbstracts._TransformImage.TransformImage_Impl_","_new",0xc2ef810f,"pi_xy.imageAbstracts._TransformImage.TransformImage_Impl_._new","pi_xy/imageAbstracts/TransformImage.hx",10,0xf08c461e)
HX_LOCAL_STACK_FRAME(_hx_pos_68d25436a32dba6f_23_flippedX,"pi_xy.imageAbstracts._TransformImage.TransformImage_Impl_","flippedX",0xd3712884,"pi_xy.imageAbstracts._TransformImage.TransformImage_Impl_.flippedX","pi_xy/imageAbstracts/TransformImage.hx",23,0xf08c461e)
HX_LOCAL_STACK_FRAME(_hx_pos_68d25436a32dba6f_34_flippedY,"pi_xy.imageAbstracts._TransformImage.TransformImage_Impl_","flippedY",0xd3712885,"pi_xy.imageAbstracts._TransformImage.TransformImage_Impl_.flippedY","pi_xy/imageAbstracts/TransformImage.hx",34,0xf08c461e)
HX_LOCAL_STACK_FRAME(_hx_pos_68d25436a32dba6f_43_spunClock90,"pi_xy.imageAbstracts._TransformImage.TransformImage_Impl_","spunClock90",0xc8921fa1,"pi_xy.imageAbstracts._TransformImage.TransformImage_Impl_.spunClock90","pi_xy/imageAbstracts/TransformImage.hx",43,0xf08c461e)
HX_LOCAL_STACK_FRAME(_hx_pos_68d25436a32dba6f_49_spunAntiClock90,"pi_xy.imageAbstracts._TransformImage.TransformImage_Impl_","spunAntiClock90",0xfaa7be1f,"pi_xy.imageAbstracts._TransformImage.TransformImage_Impl_.spunAntiClock90","pi_xy/imageAbstracts/TransformImage.hx",49,0xf08c461e)
HX_LOCAL_STACK_FRAME(_hx_pos_68d25436a32dba6f_55_spun180,"pi_xy.imageAbstracts._TransformImage.TransformImage_Impl_","spun180",0x07e10e05,"pi_xy.imageAbstracts._TransformImage.TransformImage_Impl_.spun180","pi_xy/imageAbstracts/TransformImage.hx",55,0xf08c461e)
HX_LOCAL_STACK_FRAME(_hx_pos_68d25436a32dba6f_60_scaleMatch,"pi_xy.imageAbstracts._TransformImage.TransformImage_Impl_","scaleMatch",0x20605889,"pi_xy.imageAbstracts._TransformImage.TransformImage_Impl_.scaleMatch","pi_xy/imageAbstracts/TransformImage.hx",60,0xf08c461e)
HX_LOCAL_STACK_FRAME(_hx_pos_68d25436a32dba6f_71_scaleXY,"pi_xy.imageAbstracts._TransformImage.TransformImage_Impl_","scaleXY",0x500ee71d,"pi_xy.imageAbstracts._TransformImage.TransformImage_Impl_.scaleXY","pi_xy/imageAbstracts/TransformImage.hx",71,0xf08c461e)
HX_LOCAL_STACK_FRAME(_hx_pos_68d25436a32dba6f_78_rotateClockwiseDegrees,"pi_xy.imageAbstracts._TransformImage.TransformImage_Impl_","rotateClockwiseDegrees",0xdbb3c77e,"pi_xy.imageAbstracts._TransformImage.TransformImage_Impl_.rotateClockwiseDegrees","pi_xy/imageAbstracts/TransformImage.hx",78,0xf08c461e)
HX_LOCAL_STACK_FRAME(_hx_pos_68d25436a32dba6f_85_rotateClockwiseRadians,"pi_xy.imageAbstracts._TransformImage.TransformImage_Impl_","rotateClockwiseRadians",0xc8492a49,"pi_xy.imageAbstracts._TransformImage.TransformImage_Impl_.rotateClockwiseRadians","pi_xy/imageAbstracts/TransformImage.hx",85,0xf08c461e)
HX_LOCAL_STACK_FRAME(_hx_pos_68d25436a32dba6f_93_rotate,"pi_xy.imageAbstracts._TransformImage.TransformImage_Impl_","rotate",0x34a57989,"pi_xy.imageAbstracts._TransformImage.TransformImage_Impl_.rotate","pi_xy/imageAbstracts/TransformImage.hx",93,0xf08c461e)
HX_LOCAL_STACK_FRAME(_hx_pos_68d25436a32dba6f_100_scaleUpInt,"pi_xy.imageAbstracts._TransformImage.TransformImage_Impl_","scaleUpInt",0xc55e9898,"pi_xy.imageAbstracts._TransformImage.TransformImage_Impl_.scaleUpInt","pi_xy/imageAbstracts/TransformImage.hx",100,0xf08c461e)
namespace pi_xy{
namespace imageAbstracts{
namespace _TransformImage{

void TransformImage_Impl__obj::__construct() { }

Dynamic TransformImage_Impl__obj::__CreateEmpty() { return new TransformImage_Impl__obj; }

void *TransformImage_Impl__obj::_hx_vtable = 0;

Dynamic TransformImage_Impl__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< TransformImage_Impl__obj > _hx_result = new TransformImage_Impl__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool TransformImage_Impl__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x0e424840;
}

 ::pi_xy::ImageStruct TransformImage_Impl__obj::_new(int w,int h){
            	HX_GC_STACKFRAME(&_hx_pos_68d25436a32dba6f_10__new)
HXLINE(  12)		 ::Dynamic imageType = null();
HXDLIN(  12)		 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  12)		if (::hx::IsNull( imageType )) {
HXLINE(  12)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXDLIN(  12)		::Dynamic this2;
HXDLIN(  12)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE(  12)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  12)				 ::iterMagic::BytesImg b = byt;
HXDLIN(  12)				{
HXLINE(  12)					b->width = w;
HXDLIN(  12)					b->height = h;
HXDLIN(  12)					b->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  12)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  12)					{
HXLINE(  12)						int len = b->length;
HXDLIN(  12)						int w1 = 0;
HXDLIN(  12)						{
HXLINE(  12)							int _g = 0;
HXDLIN(  12)							int _g1 = b->height;
HXDLIN(  12)							while((_g < _g1)){
HXLINE(  12)								_g = (_g + 1);
HXDLIN(  12)								int y = (_g - 1);
HXDLIN(  12)								{
HXLINE(  12)									int _g2 = 0;
HXDLIN(  12)									int _g3 = b->width;
HXDLIN(  12)									while((_g2 < _g3)){
HXLINE(  12)										_g2 = (_g2 + 1);
HXDLIN(  12)										int x = (_g2 - 1);
HXDLIN(  12)										{
HXLINE(  12)											w1 = (w1 + 1);
HXDLIN(  12)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  12)										{
HXLINE(  12)											w1 = (w1 + 1);
HXDLIN(  12)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  12)										{
HXLINE(  12)											w1 = (w1 + 1);
HXDLIN(  12)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  12)										{
HXLINE(  12)											w1 = (w1 + 1);
HXDLIN(  12)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  12)				this2 = b;
            			}
            			break;
            			case (int)1: {
HXLINE(  12)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  12)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  12)				{
HXLINE(  12)					a->width = w;
HXDLIN(  12)					a->height = h;
HXDLIN(  12)					a->data = ::Array_obj< int >::__new(0);
HXDLIN(  12)					a->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  12)					{
HXLINE(  12)						int _g4 = 0;
HXDLIN(  12)						int _g5 = a->length;
HXDLIN(  12)						while((_g4 < _g5)){
HXLINE(  12)							_g4 = (_g4 + 1);
HXDLIN(  12)							int i = (_g4 - 1);
HXDLIN(  12)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN(  12)				this2 = a;
            			}
            			break;
            			case (int)2: {
HXLINE(  12)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  12)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  12)				{
HXLINE(  12)					b1->width = w;
HXDLIN(  12)					b1->height = h;
HXDLIN(  12)					b1->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  12)					int size = (b1->length * 4);
HXDLIN(  12)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  12)					{
HXLINE(  12)						int _g6 = 0;
HXDLIN(  12)						int _g7 = b1->length;
HXDLIN(  12)						while((_g6 < _g7)){
HXLINE(  12)							_g6 = (_g6 + 1);
HXDLIN(  12)							int i1 = (_g6 - 1);
HXDLIN(  12)							{
HXLINE(  12)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  12)								bool this4;
HXDLIN(  12)								if ((i1 >= 0)) {
HXLINE(  12)									this4 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXLINE(  12)									this4 = false;
            								}
HXDLIN(  12)								if (this4) {
HXLINE(  12)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  12)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  12)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  12)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  12)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  12)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(  12)				this2 = b1;
            			}
            			break;
            			case (int)3: {
HXLINE(  12)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  12)				 ::iterMagic::VecIntImg v = vec;
HXDLIN(  12)				{
HXLINE(  12)					v->width = w;
HXDLIN(  12)					v->height = h;
HXDLIN(  12)					v->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  12)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  12)					{
HXLINE(  12)						int _g8 = 0;
HXDLIN(  12)						int _g9 = v->length;
HXDLIN(  12)						while((_g8 < _g9)){
HXLINE(  12)							_g8 = (_g8 + 1);
HXDLIN(  12)							int i2 = (_g8 - 1);
HXDLIN(  12)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN(  12)				this2 = v;
            			}
            			break;
            			case (int)4: {
HXLINE(  12)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  12)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  12)				{
HXLINE(  12)					b2->width = w;
HXDLIN(  12)					b2->height = h;
HXDLIN(  12)					b2->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  12)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  12)					{
HXLINE(  12)						int len1 = b2->length;
HXDLIN(  12)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  12)						if (::hx::IsNull( d->head )) {
HXLINE(  12)							int _g10 = 0;
HXDLIN(  12)							int _g11 = len1;
HXDLIN(  12)							while((_g10 < _g11)){
HXLINE(  12)								_g10 = (_g10 + 1);
HXDLIN(  12)								int i3 = (_g10 - 1);
HXDLIN(  12)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE(  12)							int _g12 = 0;
HXDLIN(  12)							int _g13 = len1;
HXDLIN(  12)							while((_g12 < _g13)){
HXLINE(  12)								_g12 = (_g12 + 1);
HXDLIN(  12)								int i4 = (_g12 - 1);
HXDLIN(  12)								{
HXLINE(  12)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  12)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  12)									{
HXLINE(  12)										int _g14 = 0;
HXDLIN(  12)										int _g15 = i4;
HXDLIN(  12)										while((_g14 < _g15)){
HXLINE(  12)											_g14 = (_g14 + 1);
HXDLIN(  12)											int i5 = (_g14 - 1);
HXDLIN(  12)											prev = l;
HXDLIN(  12)											l = l->next;
            										}
            									}
HXDLIN(  12)									if (::hx::IsNull( prev )) {
HXLINE(  12)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  12)										l = null();
            									}
            									else {
HXLINE(  12)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  12)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  12)				this2 = b2;
            			}
            			break;
            		}
HXDLIN(  12)		this1->image = this2;
HXDLIN(  12)		this1->width = w;
HXDLIN(  12)		this1->height = h;
HXDLIN(  12)		this1->imageType = ( (int)(imageType) );
HXLINE(  10)		return this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(TransformImage_Impl__obj,_new,return )

 ::pi_xy::ImageStruct TransformImage_Impl__obj::flippedX( ::pi_xy::ImageStruct this1,Float x,Float y,Float w,Float h,::hx::Null< bool >  __o_transparent,::hx::Null< bool >  __o_inPlace,::hx::Null< bool >  __o_includeMask){
            		bool transparent = __o_transparent.Default(false);
            		bool inPlace = __o_inPlace.Default(false);
            		bool includeMask = __o_includeMask.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_68d25436a32dba6f_23_flippedX)
HXDLIN(  23)		Float r_x = x;
HXDLIN(  23)		Float r_y = y;
HXDLIN(  23)		Float r_w = w;
HXDLIN(  23)		Float r_h = h;
HXDLIN(  23)		int xmax = ::Std_obj::_hx_int(((r_x + r_w) + 1));
HXDLIN(  23)		int ymax = ::Std_obj::_hx_int(((r_y + r_h) + 1));
HXDLIN(  23)		int ii_min = ::Std_obj::_hx_int(r_x);
HXDLIN(  23)		int ii_max = xmax;
HXDLIN(  23)		int xRange__start = ii_min;
HXDLIN(  23)		int xRange__max = ii_max;
HXDLIN(  23)		int ii_min1 = ::Std_obj::_hx_int(r_y);
HXDLIN(  23)		int ii_max1 = ymax;
HXDLIN(  23)		int yRange__start = ii_min1;
HXDLIN(  23)		int yRange__max = ii_max1;
HXDLIN(  23)		int range_x = xRange__start;
HXDLIN(  23)		int range_y = (yRange__start - 1);
HXDLIN(  23)		int range_xReset = range_x;
HXDLIN(  23)		int range_yReset = range_y;
HXDLIN(  23)		int range_xMax = (xRange__max - 2);
HXDLIN(  23)		int range_yMax = (yRange__max - 2);
HXDLIN(  23)		int _this_min = 0;
HXDLIN(  23)		int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXDLIN(  23)		int width = ::Std_obj::_hx_int(w);
HXDLIN(  23)		int height = ::Std_obj::_hx_int(h);
HXDLIN(  23)		 ::Dynamic imageType = null();
HXDLIN(  23)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  23)		if (::hx::IsNull( imageType )) {
HXLINE(  54)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXLINE(  23)		::Dynamic _hx_tmp;
HXDLIN(  23)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXDLIN(  23)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  23)				 ::iterMagic::BytesImg b = byt;
HXDLIN(  23)				{
HXDLIN(  23)					b->width = width;
HXDLIN(  23)					b->height = height;
HXDLIN(  23)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  23)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  23)					{
HXDLIN(  23)						int len = b->length;
HXDLIN(  23)						int w1 = 0;
HXDLIN(  23)						{
HXDLIN(  23)							int _g = 0;
HXDLIN(  23)							int _g1 = b->height;
HXDLIN(  23)							while((_g < _g1)){
HXDLIN(  23)								_g = (_g + 1);
HXDLIN(  23)								int y1 = (_g - 1);
HXDLIN(  23)								{
HXDLIN(  23)									int _g2 = 0;
HXDLIN(  23)									int _g3 = b->width;
HXDLIN(  23)									while((_g2 < _g3)){
HXDLIN(  23)										_g2 = (_g2 + 1);
HXDLIN(  23)										int x1 = (_g2 - 1);
HXDLIN(  23)										{
HXDLIN(  23)											w1 = (w1 + 1);
HXDLIN(  23)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  23)										{
HXDLIN(  23)											w1 = (w1 + 1);
HXDLIN(  23)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  23)										{
HXDLIN(  23)											w1 = (w1 + 1);
HXDLIN(  23)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  23)										{
HXDLIN(  23)											w1 = (w1 + 1);
HXDLIN(  23)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  23)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXDLIN(  23)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  23)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  23)				{
HXDLIN(  23)					a->width = width;
HXDLIN(  23)					a->height = height;
HXDLIN(  23)					a->data = ::Array_obj< int >::__new(0);
HXDLIN(  23)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  23)					{
HXDLIN(  23)						int _g4 = 0;
HXDLIN(  23)						int _g5 = a->length;
HXDLIN(  23)						while((_g4 < _g5)){
HXDLIN(  23)							_g4 = (_g4 + 1);
HXDLIN(  23)							int i = (_g4 - 1);
HXDLIN(  23)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN(  23)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXDLIN(  23)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  23)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  23)				{
HXDLIN(  23)					b1->width = width;
HXDLIN(  23)					b1->height = height;
HXDLIN(  23)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  23)					int size = (b1->length * 4);
HXDLIN(  23)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  23)					{
HXDLIN(  23)						int _g6 = 0;
HXDLIN(  23)						int _g7 = b1->length;
HXDLIN(  23)						while((_g6 < _g7)){
HXDLIN(  23)							_g6 = (_g6 + 1);
HXDLIN(  23)							int i1 = (_g6 - 1);
HXDLIN(  23)							{
HXDLIN(  23)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  23)								bool _hx_tmp1;
HXDLIN(  23)								if ((i1 >= 0)) {
HXDLIN(  23)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXDLIN(  23)									_hx_tmp1 = false;
            								}
HXDLIN(  23)								if (_hx_tmp1) {
HXDLIN(  23)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  23)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  23)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  23)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  23)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  23)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(  23)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXDLIN(  23)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  23)				 ::iterMagic::VecIntImg v = vec;
HXDLIN(  23)				{
HXDLIN(  23)					v->width = width;
HXDLIN(  23)					v->height = height;
HXDLIN(  23)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  23)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  23)					{
HXDLIN(  23)						int _g8 = 0;
HXDLIN(  23)						int _g9 = v->length;
HXDLIN(  23)						while((_g8 < _g9)){
HXDLIN(  23)							_g8 = (_g8 + 1);
HXDLIN(  23)							int i2 = (_g8 - 1);
HXDLIN(  23)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN(  23)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXDLIN(  23)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  23)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  23)				{
HXDLIN(  23)					b2->width = width;
HXDLIN(  23)					b2->height = height;
HXDLIN(  23)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  23)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  23)					{
HXDLIN(  23)						int len1 = b2->length;
HXDLIN(  23)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  23)						if (::hx::IsNull( d->head )) {
HXDLIN(  23)							int _g10 = 0;
HXDLIN(  23)							int _g11 = len1;
HXDLIN(  23)							while((_g10 < _g11)){
HXDLIN(  23)								_g10 = (_g10 + 1);
HXDLIN(  23)								int i3 = (_g10 - 1);
HXDLIN(  23)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXDLIN(  23)							int _g12 = 0;
HXDLIN(  23)							int _g13 = len1;
HXDLIN(  23)							while((_g12 < _g13)){
HXDLIN(  23)								_g12 = (_g12 + 1);
HXDLIN(  23)								int i4 = (_g12 - 1);
HXDLIN(  23)								{
HXDLIN(  23)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  23)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  23)									{
HXDLIN(  23)										int _g14 = 0;
HXDLIN(  23)										int _g15 = i4;
HXDLIN(  23)										while((_g14 < _g15)){
HXDLIN(  23)											_g14 = (_g14 + 1);
HXDLIN(  23)											int i5 = (_g14 - 1);
HXLINE( 345)											prev = l;
HXLINE( 346)											l = l->next;
            										}
            									}
HXLINE(  23)									if (::hx::IsNull( prev )) {
HXDLIN(  23)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  23)										l = null();
            									}
            									else {
HXDLIN(  23)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  23)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  23)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN(  23)		this2->image = _hx_tmp;
HXDLIN(  23)		this2->width = width;
HXDLIN(  23)		this2->height = height;
HXDLIN(  23)		this2->imageType = ( (int)(imageType) );
HXDLIN(  23)		 ::pi_xy::ImageStruct nextImage = this2;
HXDLIN(  23)		nextImage->transparent = transparent;
HXDLIN(  23)		while((_this_min < _this_max)){
HXDLIN(  23)			_this_min = (_this_min + 1);
HXDLIN(  23)			int i6 = (_this_min - 1);
HXDLIN(  23)			if ((range_y > range_yMax)) {
HXDLIN(  23)				range_y = range_yReset;
HXDLIN(  23)				range_x = (range_x + 1);
            			}
HXDLIN(  23)			range_y = (range_y + 1);
HXDLIN(  23)			int i7 = i6;
HXDLIN(  23)			{
HXDLIN(  23)				int x2 = range_x;
HXDLIN(  23)				int y2 = range_y;
HXDLIN(  23)				int x3 = (range_xMax - range_x);
HXDLIN(  23)				int y3 = range_y;
HXDLIN(  23)				::Dynamic this4 = this1->image;
HXDLIN(  23)				int index;
HXDLIN(  23)				if (this1->useVirtualPos) {
HXDLIN(  23)					index = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            				}
            				else {
HXDLIN(  23)					index = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            				}
HXDLIN(  23)				int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN(  23)				int color;
HXDLIN(  23)				if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)					color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            				}
            				else {
HXDLIN(  23)					color = c;
            				}
HXDLIN(  23)				int c1 = color;
HXDLIN(  23)				bool _hx_tmp2;
HXDLIN(  23)				if ((((c1 >> 24) & 255) < 254)) {
HXDLIN(  23)					_hx_tmp2 = nextImage->transparent;
            				}
            				else {
HXDLIN(  23)					_hx_tmp2 = false;
            				}
HXDLIN(  23)				if (_hx_tmp2) {
HXDLIN(  23)					int location;
HXDLIN(  23)					if (nextImage->useVirtualPos) {
HXDLIN(  23)						location = ::Std_obj::_hx_int(((((( (Float)(y2) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x2) - nextImage->virtualX));
            					}
            					else {
HXDLIN(  23)						location = ::Std_obj::_hx_int(( (Float)(((y2 * nextImage->width) + x2)) ));
            					}
HXDLIN(  23)					int this5 = ::iterMagic::Iimg_obj::get(nextImage->image,location);
HXDLIN(  23)					int this6;
HXDLIN(  23)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)						this6 = ((((((this5 >> 24) & 255) << 24) | ((this5 & 255) << 16)) | (((this5 >> 8) & 255) << 8)) | ((this5 >> 16) & 255));
            					}
            					else {
HXDLIN(  23)						this6 = this5;
            					}
HXDLIN(  23)					Float a1;
HXDLIN(  23)					int this7 = ((this6 >> 24) & 255);
HXDLIN(  23)					if ((this7 == 0)) {
HXDLIN(  23)						a1 = ((Float)0.);
            					}
            					else {
HXDLIN(  23)						a1 = (( (Float)(this7) ) / ( (Float)(255) ));
            					}
HXDLIN(  23)					Float r1;
HXDLIN(  23)					int this8 = ((this6 >> 16) & 255);
HXDLIN(  23)					if ((this8 == 0)) {
HXDLIN(  23)						r1 = ((Float)0.);
            					}
            					else {
HXDLIN(  23)						r1 = (( (Float)(this8) ) / ( (Float)(255) ));
            					}
HXDLIN(  23)					Float g1;
HXDLIN(  23)					int this9 = ((this6 >> 8) & 255);
HXDLIN(  23)					if ((this9 == 0)) {
HXDLIN(  23)						g1 = ((Float)0.);
            					}
            					else {
HXDLIN(  23)						g1 = (( (Float)(this9) ) / ( (Float)(255) ));
            					}
HXDLIN(  23)					Float b11;
HXDLIN(  23)					int this10 = (this6 & 255);
HXDLIN(  23)					if ((this10 == 0)) {
HXDLIN(  23)						b11 = ((Float)0.);
            					}
            					else {
HXDLIN(  23)						b11 = (( (Float)(this10) ) / ( (Float)(255) ));
            					}
HXDLIN(  23)					Float a2;
HXDLIN(  23)					int this11 = ((color >> 24) & 255);
HXDLIN(  23)					if ((this11 == 0)) {
HXDLIN(  23)						a2 = ((Float)0.);
            					}
            					else {
HXDLIN(  23)						a2 = (( (Float)(this11) ) / ( (Float)(255) ));
            					}
HXDLIN(  23)					Float r2;
HXDLIN(  23)					int this12 = ((color >> 16) & 255);
HXDLIN(  23)					if ((this12 == 0)) {
HXDLIN(  23)						r2 = ((Float)0.);
            					}
            					else {
HXDLIN(  23)						r2 = (( (Float)(this12) ) / ( (Float)(255) ));
            					}
HXDLIN(  23)					Float g2;
HXDLIN(  23)					int this13 = ((color >> 8) & 255);
HXDLIN(  23)					if ((this13 == 0)) {
HXDLIN(  23)						g2 = ((Float)0.);
            					}
            					else {
HXDLIN(  23)						g2 = (( (Float)(this13) ) / ( (Float)(255) ));
            					}
HXDLIN(  23)					Float b21;
HXDLIN(  23)					int this14 = (color & 255);
HXDLIN(  23)					if ((this14 == 0)) {
HXDLIN(  23)						b21 = ((Float)0.);
            					}
            					else {
HXDLIN(  23)						b21 = (( (Float)(this14) ) / ( (Float)(255) ));
            					}
HXDLIN(  23)					Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  23)					int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  23)					int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  23)					int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  23)					int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  23)					int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  23)					{
HXDLIN(  23)						int _hx_tmp3;
HXDLIN(  23)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)							_hx_tmp3 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            						}
            						else {
HXDLIN(  23)							_hx_tmp3 = blended;
            						}
HXDLIN(  23)						::iterMagic::Iimg_obj::set(nextImage->image,location,_hx_tmp3);
            					}
            				}
            				else {
HXDLIN(  23)					::Dynamic this15 = nextImage->image;
HXDLIN(  23)					int index1;
HXDLIN(  23)					if (nextImage->useVirtualPos) {
HXDLIN(  23)						index1 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x2) - nextImage->virtualX));
            					}
            					else {
HXDLIN(  23)						index1 = ::Std_obj::_hx_int(( (Float)(((y2 * nextImage->width) + x2)) ));
            					}
HXDLIN(  23)					int _hx_tmp4;
HXDLIN(  23)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)						_hx_tmp4 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            					}
            					else {
HXDLIN(  23)						_hx_tmp4 = c1;
            					}
HXDLIN(  23)					::iterMagic::Iimg_obj::set(this15,index1,_hx_tmp4);
            				}
            			}
            		}
HXDLIN(  23)		if (inPlace) {
HXDLIN(  23)			{
HXDLIN(  23)				int x4 = ::Std_obj::_hx_int(x);
HXDLIN(  23)				int y4 = ::Std_obj::_hx_int(y);
HXDLIN(  23)				bool forceClear = false;
HXDLIN(  23)				{
HXDLIN(  23)					int _g16 = 0;
HXDLIN(  23)					int _g17 = nextImage->height;
HXDLIN(  23)					while((_g16 < _g17)){
HXDLIN(  23)						_g16 = (_g16 + 1);
HXDLIN(  23)						int dy = (_g16 - 1);
HXDLIN(  23)						{
HXDLIN(  23)							int _g18 = 0;
HXDLIN(  23)							int _g19 = nextImage->width;
HXDLIN(  23)							while((_g18 < _g19)){
HXDLIN(  23)								_g18 = (_g18 + 1);
HXDLIN(  23)								int dx = (_g18 - 1);
HXDLIN(  23)								::Dynamic this16 = nextImage->image;
HXDLIN(  23)								int index2;
HXDLIN(  23)								if (nextImage->useVirtualPos) {
HXDLIN(  23)									index2 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + dx) - nextImage->virtualX));
            								}
            								else {
HXDLIN(  23)									index2 = ::Std_obj::_hx_int(( (Float)(((dy * nextImage->width) + dx)) ));
            								}
HXDLIN(  23)								int c2 = ::iterMagic::Iimg_obj::get(this16,index2);
HXDLIN(  23)								int col;
HXDLIN(  23)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)									col = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            								}
            								else {
HXDLIN(  23)									col = c2;
            								}
HXDLIN(  23)								bool _hx_tmp5;
HXDLIN(  23)								if (nextImage->useMask) {
HXDLIN(  23)									_hx_tmp5 = ::hx::IsNotNull( nextImage->mask );
            								}
            								else {
HXDLIN(  23)									_hx_tmp5 = false;
            								}
HXDLIN(  23)								if (_hx_tmp5) {
HXDLIN(  23)									 ::pi_xy::ImageStruct this17 = nextImage->mask;
HXDLIN(  23)									::Dynamic this18 = this17->image;
HXDLIN(  23)									int index3;
HXDLIN(  23)									if (this17->useVirtualPos) {
HXDLIN(  23)										index3 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this17->virtualY) * ( (Float)(this17->width) )) + dx) - this17->virtualX));
            									}
            									else {
HXDLIN(  23)										index3 = ::Std_obj::_hx_int(( (Float)(((dy * this17->width) + dx)) ));
            									}
HXDLIN(  23)									int c3 = ::iterMagic::Iimg_obj::get(this18,index3);
HXDLIN(  23)									int v1;
HXDLIN(  23)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)										v1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            									}
            									else {
HXDLIN(  23)										v1 = c3;
            									}
HXDLIN(  23)									int maskPixel = v1;
HXDLIN(  23)									int this19 = col;
HXDLIN(  23)									if ((maskPixel == 0)) {
HXDLIN(  23)										col = this19;
            									}
            									else {
HXDLIN(  23)										Float m0;
HXDLIN(  23)										int this20 = ((maskPixel >> 24) & 255);
HXDLIN(  23)										if ((this20 == 0)) {
HXDLIN(  23)											m0 = ((Float)0.);
            										}
            										else {
HXDLIN(  23)											m0 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN(  23)										Float m1;
HXDLIN(  23)										int this21 = ((maskPixel >> 16) & 255);
HXDLIN(  23)										if ((this21 == 0)) {
HXDLIN(  23)											m1 = ((Float)0.);
            										}
            										else {
HXDLIN(  23)											m1 = (( (Float)(this21) ) / ( (Float)(255) ));
            										}
HXDLIN(  23)										Float m2;
HXDLIN(  23)										int this22 = ((maskPixel >> 8) & 255);
HXDLIN(  23)										if ((this22 == 0)) {
HXDLIN(  23)											m2 = ((Float)0.);
            										}
            										else {
HXDLIN(  23)											m2 = (( (Float)(this22) ) / ( (Float)(255) ));
            										}
HXDLIN(  23)										Float m3;
HXDLIN(  23)										int this23 = (maskPixel & 255);
HXDLIN(  23)										if ((this23 == 0)) {
HXDLIN(  23)											m3 = ((Float)0.);
            										}
            										else {
HXDLIN(  23)											m3 = (( (Float)(this23) ) / ( (Float)(255) ));
            										}
HXDLIN(  23)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this19 >> 24) & 255)) )));
HXDLIN(  23)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this19 >> 16) & 255)) )));
HXDLIN(  23)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this19 >> 8) & 255)) )));
HXDLIN(  23)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this19 & 255)) )));
HXDLIN(  23)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN(  23)								if ((col != 0)) {
HXDLIN(  23)									int x5 = (x4 + dx);
HXDLIN(  23)									int y5 = (y4 + dy);
HXDLIN(  23)									int c4 = col;
HXDLIN(  23)									bool _hx_tmp6;
HXDLIN(  23)									if ((((c4 >> 24) & 255) < 254)) {
HXDLIN(  23)										_hx_tmp6 = this1->transparent;
            									}
            									else {
HXDLIN(  23)										_hx_tmp6 = false;
            									}
HXDLIN(  23)									if (_hx_tmp6) {
HXDLIN(  23)										int location1;
HXDLIN(  23)										if (this1->useVirtualPos) {
HXDLIN(  23)											location1 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - this1->virtualY) * ( (Float)(this1->width) )) + x5) - this1->virtualX));
            										}
            										else {
HXDLIN(  23)											location1 = ::Std_obj::_hx_int(( (Float)(((y5 * this1->width) + x5)) ));
            										}
HXDLIN(  23)										int this24 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN(  23)										int this25;
HXDLIN(  23)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)											this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            										}
            										else {
HXDLIN(  23)											this25 = this24;
            										}
HXDLIN(  23)										Float a11;
HXDLIN(  23)										int this26 = ((this25 >> 24) & 255);
HXDLIN(  23)										if ((this26 == 0)) {
HXDLIN(  23)											a11 = ((Float)0.);
            										}
            										else {
HXDLIN(  23)											a11 = (( (Float)(this26) ) / ( (Float)(255) ));
            										}
HXDLIN(  23)										Float r11;
HXDLIN(  23)										int this27 = ((this25 >> 16) & 255);
HXDLIN(  23)										if ((this27 == 0)) {
HXDLIN(  23)											r11 = ((Float)0.);
            										}
            										else {
HXDLIN(  23)											r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            										}
HXDLIN(  23)										Float g11;
HXDLIN(  23)										int this28 = ((this25 >> 8) & 255);
HXDLIN(  23)										if ((this28 == 0)) {
HXDLIN(  23)											g11 = ((Float)0.);
            										}
            										else {
HXDLIN(  23)											g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            										}
HXDLIN(  23)										Float b12;
HXDLIN(  23)										int this29 = (this25 & 255);
HXDLIN(  23)										if ((this29 == 0)) {
HXDLIN(  23)											b12 = ((Float)0.);
            										}
            										else {
HXDLIN(  23)											b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            										}
HXDLIN(  23)										Float a21;
HXDLIN(  23)										int this30 = ((col >> 24) & 255);
HXDLIN(  23)										if ((this30 == 0)) {
HXDLIN(  23)											a21 = ((Float)0.);
            										}
            										else {
HXDLIN(  23)											a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN(  23)										Float r21;
HXDLIN(  23)										int this31 = ((col >> 16) & 255);
HXDLIN(  23)										if ((this31 == 0)) {
HXDLIN(  23)											r21 = ((Float)0.);
            										}
            										else {
HXDLIN(  23)											r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN(  23)										Float g21;
HXDLIN(  23)										int this32 = ((col >> 8) & 255);
HXDLIN(  23)										if ((this32 == 0)) {
HXDLIN(  23)											g21 = ((Float)0.);
            										}
            										else {
HXDLIN(  23)											g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            										}
HXDLIN(  23)										Float b22;
HXDLIN(  23)										int this33 = (col & 255);
HXDLIN(  23)										if ((this33 == 0)) {
HXDLIN(  23)											b22 = ((Float)0.);
            										}
            										else {
HXDLIN(  23)											b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            										}
HXDLIN(  23)										Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  23)										int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  23)										int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  23)										int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  23)										int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  23)										int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  23)										{
HXDLIN(  23)											int _hx_tmp7;
HXDLIN(  23)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)												_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXDLIN(  23)												_hx_tmp7 = blended1;
            											}
HXDLIN(  23)											::iterMagic::Iimg_obj::set(this1->image,location1,_hx_tmp7);
            										}
            									}
            									else {
HXDLIN(  23)										::Dynamic this34 = this1->image;
HXDLIN(  23)										int index4;
HXDLIN(  23)										if (this1->useVirtualPos) {
HXDLIN(  23)											index4 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - this1->virtualY) * ( (Float)(this1->width) )) + x5) - this1->virtualX));
            										}
            										else {
HXDLIN(  23)											index4 = ::Std_obj::_hx_int(( (Float)(((y5 * this1->width) + x5)) ));
            										}
HXDLIN(  23)										int _hx_tmp8;
HXDLIN(  23)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)											_hx_tmp8 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            										}
            										else {
HXDLIN(  23)											_hx_tmp8 = c4;
            										}
HXDLIN(  23)										::iterMagic::Iimg_obj::set(this34,index4,_hx_tmp8);
            									}
            								}
            								else {
HXDLIN(  23)									if (forceClear) {
HXDLIN(  23)										::Dynamic this35 = this1->image;
HXDLIN(  23)										int x6 = (x4 + dx);
HXDLIN(  23)										int y6 = (y4 + dy);
HXDLIN(  23)										int index5;
HXDLIN(  23)										if (this1->useVirtualPos) {
HXDLIN(  23)											index5 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - this1->virtualY) * ( (Float)(this1->width) )) + x6) - this1->virtualX));
            										}
            										else {
HXDLIN(  23)											index5 = ::Std_obj::_hx_int(( (Float)(((y6 * this1->width) + x6)) ));
            										}
HXDLIN(  23)										::iterMagic::Iimg_obj::set(this35,index5,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN(  23)			bool _hx_tmp9;
HXDLIN(  23)			if (::hx::IsNotNull( this1->mask )) {
HXDLIN(  23)				_hx_tmp9 = includeMask;
            			}
            			else {
HXDLIN(  23)				_hx_tmp9 = false;
            			}
HXDLIN(  23)			if (_hx_tmp9) {
HXDLIN(  23)				 ::pi_xy::ImageStruct v2 = ::pi_xy::transformation::_FlipImage::FlipImage_Fields__obj::imageflipX(this1->mask,x,y,( (Float)(this1->width) ),( (Float)(this1->height) ),this1->mask->transparent,inPlace,includeMask);
HXDLIN(  23)				this1->useMask = true;
HXDLIN(  23)				this1->mask = v2;
            			}
HXLINE(  44)			nextImage = null();
HXLINE(  23)			return this1;
            		}
            		else {
HXDLIN(  23)			bool _hx_tmp10;
HXDLIN(  23)			if (::hx::IsNotNull( this1->mask )) {
HXDLIN(  23)				_hx_tmp10 = includeMask;
            			}
            			else {
HXDLIN(  23)				_hx_tmp10 = false;
            			}
HXDLIN(  23)			if (_hx_tmp10) {
HXDLIN(  23)				 ::pi_xy::ImageStruct this36 = this1->mask;
HXDLIN(  23)				Float w2 = ( (Float)(this1->width) );
HXDLIN(  23)				Float h1 = ( (Float)(this1->height) );
HXDLIN(  23)				bool transparent1 = this1->mask->transparent;
HXDLIN(  23)				Float r_x1 = x;
HXDLIN(  23)				Float r_y1 = y;
HXDLIN(  23)				Float r_w1 = w2;
HXDLIN(  23)				Float r_h1 = h1;
HXDLIN(  23)				int xmax1 = ::Std_obj::_hx_int(((r_x1 + r_w1) + 1));
HXDLIN(  23)				int ymax1 = ::Std_obj::_hx_int(((r_y1 + r_h1) + 1));
HXDLIN(  23)				int ii_min2 = ::Std_obj::_hx_int(r_x1);
HXDLIN(  23)				int ii_max2 = xmax1;
HXDLIN(  23)				int xRange__start1 = ii_min2;
HXDLIN(  23)				int xRange__max1 = ii_max2;
HXDLIN(  23)				int ii_min3 = ::Std_obj::_hx_int(r_y1);
HXDLIN(  23)				int ii_max3 = ymax1;
HXDLIN(  23)				int yRange__start1 = ii_min3;
HXDLIN(  23)				int yRange__max1 = ii_max3;
HXDLIN(  23)				int range_x1 = xRange__start1;
HXDLIN(  23)				int range_y1 = (yRange__start1 - 1);
HXDLIN(  23)				int range_xReset1 = range_x1;
HXDLIN(  23)				int range_yReset1 = range_y1;
HXDLIN(  23)				int range_xMax1 = (xRange__max1 - 2);
HXDLIN(  23)				int range_yMax1 = (yRange__max1 - 2);
HXDLIN(  23)				int _this_min1 = 0;
HXDLIN(  23)				int _this_max1 = ::Std_obj::_hx_int(( (Float)(((xRange__max1 - xRange__start1) * (yRange__max1 - yRange__start1))) ));
HXDLIN(  23)				int width1 = ::Std_obj::_hx_int(w2);
HXDLIN(  23)				int height1 = ::Std_obj::_hx_int(h1);
HXDLIN(  23)				 ::Dynamic imageType1 = null();
HXDLIN(  23)				 ::pi_xy::ImageStruct this37 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  23)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE(  23)				::Dynamic _hx_tmp11;
HXDLIN(  23)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXDLIN(  23)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  23)						 ::iterMagic::BytesImg b5 = byt1;
HXDLIN(  23)						{
HXDLIN(  23)							b5->width = width1;
HXDLIN(  23)							b5->height = height1;
HXDLIN(  23)							b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  23)							b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN(  23)							{
HXDLIN(  23)								int len2 = b5->length;
HXDLIN(  23)								int w3 = 0;
HXDLIN(  23)								{
HXDLIN(  23)									int _g20 = 0;
HXDLIN(  23)									int _g21 = b5->height;
HXDLIN(  23)									while((_g20 < _g21)){
HXDLIN(  23)										_g20 = (_g20 + 1);
HXDLIN(  23)										int y7 = (_g20 - 1);
HXDLIN(  23)										{
HXDLIN(  23)											int _g22 = 0;
HXDLIN(  23)											int _g23 = b5->width;
HXDLIN(  23)											while((_g22 < _g23)){
HXDLIN(  23)												_g22 = (_g22 + 1);
HXDLIN(  23)												int x7 = (_g22 - 1);
HXDLIN(  23)												{
HXDLIN(  23)													w3 = (w3 + 1);
HXDLIN(  23)													b5->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  23)												{
HXDLIN(  23)													w3 = (w3 + 1);
HXDLIN(  23)													b5->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  23)												{
HXDLIN(  23)													w3 = (w3 + 1);
HXDLIN(  23)													b5->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  23)												{
HXDLIN(  23)													w3 = (w3 + 1);
HXDLIN(  23)													b5->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  23)						_hx_tmp11 = b5;
            					}
            					break;
            					case (int)1: {
HXDLIN(  23)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  23)						 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN(  23)						{
HXDLIN(  23)							a6->width = width1;
HXDLIN(  23)							a6->height = height1;
HXDLIN(  23)							a6->data = ::Array_obj< int >::__new(0);
HXDLIN(  23)							a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  23)							{
HXDLIN(  23)								int _g24 = 0;
HXDLIN(  23)								int _g25 = a6->length;
HXDLIN(  23)								while((_g24 < _g25)){
HXDLIN(  23)									_g24 = (_g24 + 1);
HXDLIN(  23)									int i8 = (_g24 - 1);
HXDLIN(  23)									a6->data[i8] = 0;
            								}
            							}
            						}
HXDLIN(  23)						_hx_tmp11 = a6;
            					}
            					break;
            					case (int)2: {
HXDLIN(  23)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  23)						 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN(  23)						{
HXDLIN(  23)							b6->width = width1;
HXDLIN(  23)							b6->height = height1;
HXDLIN(  23)							b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  23)							int size1 = (b6->length * 4);
HXDLIN(  23)							b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  23)							{
HXDLIN(  23)								int _g26 = 0;
HXDLIN(  23)								int _g27 = b6->length;
HXDLIN(  23)								while((_g26 < _g27)){
HXDLIN(  23)									_g26 = (_g26 + 1);
HXDLIN(  23)									int i9 = (_g26 - 1);
HXDLIN(  23)									{
HXDLIN(  23)										 ::haxe::io::ArrayBufferViewImpl this38 = b6->data;
HXDLIN(  23)										bool _hx_tmp12;
HXDLIN(  23)										if ((i9 >= 0)) {
HXDLIN(  23)											_hx_tmp12 = (i9 < (this38->byteLength >> 2));
            										}
            										else {
HXDLIN(  23)											_hx_tmp12 = false;
            										}
HXDLIN(  23)										if (_hx_tmp12) {
HXDLIN(  23)											 ::haxe::io::Bytes _this1 = this38->bytes;
HXDLIN(  23)											int pos1 = ((i9 << 2) + this38->byteOffset);
HXDLIN(  23)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  23)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  23)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  23)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN(  23)						_hx_tmp11 = b6;
            					}
            					break;
            					case (int)3: {
HXDLIN(  23)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  23)						 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN(  23)						{
HXDLIN(  23)							v3->width = width1;
HXDLIN(  23)							v3->height = height1;
HXDLIN(  23)							v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  23)							v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN(  23)							{
HXDLIN(  23)								int _g28 = 0;
HXDLIN(  23)								int _g29 = v3->length;
HXDLIN(  23)								while((_g28 < _g29)){
HXDLIN(  23)									_g28 = (_g28 + 1);
HXDLIN(  23)									int i10 = (_g28 - 1);
HXDLIN(  23)									v3->data->__unsafe_set(i10,0);
            								}
            							}
            						}
HXDLIN(  23)						_hx_tmp11 = v3;
            					}
            					break;
            					case (int)4: {
HXDLIN(  23)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  23)						 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN(  23)						{
HXDLIN(  23)							b7->width = width1;
HXDLIN(  23)							b7->height = height1;
HXDLIN(  23)							b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  23)							b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  23)							{
HXDLIN(  23)								int len3 = b7->length;
HXDLIN(  23)								 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN(  23)								if (::hx::IsNull( d1->head )) {
HXDLIN(  23)									int _g30 = 0;
HXDLIN(  23)									int _g31 = len3;
HXDLIN(  23)									while((_g30 < _g31)){
HXDLIN(  23)										_g30 = (_g30 + 1);
HXDLIN(  23)										int i11 = (_g30 - 1);
HXDLIN(  23)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXDLIN(  23)									int _g32 = 0;
HXDLIN(  23)									int _g33 = len3;
HXDLIN(  23)									while((_g32 < _g33)){
HXDLIN(  23)										_g32 = (_g32 + 1);
HXDLIN(  23)										int i12 = (_g32 - 1);
HXDLIN(  23)										{
HXDLIN(  23)											 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN(  23)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  23)											{
HXDLIN(  23)												int _g34 = 0;
HXDLIN(  23)												int _g35 = i12;
HXDLIN(  23)												while((_g34 < _g35)){
HXDLIN(  23)													_g34 = (_g34 + 1);
HXDLIN(  23)													int i13 = (_g34 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE(  23)											if (::hx::IsNull( prev1 )) {
HXDLIN(  23)												b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  23)												l1 = null();
            											}
            											else {
HXDLIN(  23)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  23)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  23)						_hx_tmp11 = b7;
            					}
            					break;
            				}
HXDLIN(  23)				this37->image = _hx_tmp11;
HXDLIN(  23)				this37->width = width1;
HXDLIN(  23)				this37->height = height1;
HXDLIN(  23)				this37->imageType = ( (int)(imageType1) );
HXDLIN(  23)				 ::pi_xy::ImageStruct nextImage1 = this37;
HXDLIN(  23)				nextImage1->transparent = transparent1;
HXDLIN(  23)				while((_this_min1 < _this_max1)){
HXDLIN(  23)					_this_min1 = (_this_min1 + 1);
HXDLIN(  23)					int i14 = (_this_min1 - 1);
HXDLIN(  23)					if ((range_y1 > range_yMax1)) {
HXDLIN(  23)						range_y1 = range_yReset1;
HXDLIN(  23)						range_x1 = (range_x1 + 1);
            					}
HXDLIN(  23)					range_y1 = (range_y1 + 1);
HXDLIN(  23)					int i15 = i14;
HXDLIN(  23)					{
HXDLIN(  23)						int x8 = range_x1;
HXDLIN(  23)						int y8 = range_y1;
HXDLIN(  23)						int x9 = range_x1;
HXDLIN(  23)						int y9 = (range_yMax1 - range_y1);
HXDLIN(  23)						::Dynamic this39 = this36->image;
HXDLIN(  23)						int index6;
HXDLIN(  23)						if (this36->useVirtualPos) {
HXDLIN(  23)							index6 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - this36->virtualY) * ( (Float)(this36->width) )) + x9) - this36->virtualX));
            						}
            						else {
HXDLIN(  23)							index6 = ::Std_obj::_hx_int(( (Float)(((y9 * this36->width) + x9)) ));
            						}
HXDLIN(  23)						int c5 = ::iterMagic::Iimg_obj::get(this39,index6);
HXDLIN(  23)						int color1;
HXDLIN(  23)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)							color1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            						}
            						else {
HXDLIN(  23)							color1 = c5;
            						}
HXDLIN(  23)						int c6 = color1;
HXDLIN(  23)						bool _hx_tmp13;
HXDLIN(  23)						if ((((c6 >> 24) & 255) < 254)) {
HXDLIN(  23)							_hx_tmp13 = nextImage1->transparent;
            						}
            						else {
HXDLIN(  23)							_hx_tmp13 = false;
            						}
HXDLIN(  23)						if (_hx_tmp13) {
HXDLIN(  23)							int location2;
HXDLIN(  23)							if (nextImage1->useVirtualPos) {
HXDLIN(  23)								location2 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - nextImage1->virtualY) * ( (Float)(nextImage1->width) )) + x8) - nextImage1->virtualX));
            							}
            							else {
HXDLIN(  23)								location2 = ::Std_obj::_hx_int(( (Float)(((y8 * nextImage1->width) + x8)) ));
            							}
HXDLIN(  23)							int this40 = ::iterMagic::Iimg_obj::get(nextImage1->image,location2);
HXDLIN(  23)							int this41;
HXDLIN(  23)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)								this41 = ((((((this40 >> 24) & 255) << 24) | ((this40 & 255) << 16)) | (((this40 >> 8) & 255) << 8)) | ((this40 >> 16) & 255));
            							}
            							else {
HXDLIN(  23)								this41 = this40;
            							}
HXDLIN(  23)							Float a12;
HXDLIN(  23)							int this42 = ((this41 >> 24) & 255);
HXDLIN(  23)							if ((this42 == 0)) {
HXDLIN(  23)								a12 = ((Float)0.);
            							}
            							else {
HXDLIN(  23)								a12 = (( (Float)(this42) ) / ( (Float)(255) ));
            							}
HXDLIN(  23)							Float r12;
HXDLIN(  23)							int this43 = ((this41 >> 16) & 255);
HXDLIN(  23)							if ((this43 == 0)) {
HXDLIN(  23)								r12 = ((Float)0.);
            							}
            							else {
HXDLIN(  23)								r12 = (( (Float)(this43) ) / ( (Float)(255) ));
            							}
HXDLIN(  23)							Float g12;
HXDLIN(  23)							int this44 = ((this41 >> 8) & 255);
HXDLIN(  23)							if ((this44 == 0)) {
HXDLIN(  23)								g12 = ((Float)0.);
            							}
            							else {
HXDLIN(  23)								g12 = (( (Float)(this44) ) / ( (Float)(255) ));
            							}
HXDLIN(  23)							Float b13;
HXDLIN(  23)							int this45 = (this41 & 255);
HXDLIN(  23)							if ((this45 == 0)) {
HXDLIN(  23)								b13 = ((Float)0.);
            							}
            							else {
HXDLIN(  23)								b13 = (( (Float)(this45) ) / ( (Float)(255) ));
            							}
HXDLIN(  23)							Float a22;
HXDLIN(  23)							int this46 = ((color1 >> 24) & 255);
HXDLIN(  23)							if ((this46 == 0)) {
HXDLIN(  23)								a22 = ((Float)0.);
            							}
            							else {
HXDLIN(  23)								a22 = (( (Float)(this46) ) / ( (Float)(255) ));
            							}
HXDLIN(  23)							Float r22;
HXDLIN(  23)							int this47 = ((color1 >> 16) & 255);
HXDLIN(  23)							if ((this47 == 0)) {
HXDLIN(  23)								r22 = ((Float)0.);
            							}
            							else {
HXDLIN(  23)								r22 = (( (Float)(this47) ) / ( (Float)(255) ));
            							}
HXDLIN(  23)							Float g22;
HXDLIN(  23)							int this48 = ((color1 >> 8) & 255);
HXDLIN(  23)							if ((this48 == 0)) {
HXDLIN(  23)								g22 = ((Float)0.);
            							}
            							else {
HXDLIN(  23)								g22 = (( (Float)(this48) ) / ( (Float)(255) ));
            							}
HXDLIN(  23)							Float b23;
HXDLIN(  23)							int this49 = (color1 & 255);
HXDLIN(  23)							if ((this49 == 0)) {
HXDLIN(  23)								b23 = ((Float)0.);
            							}
            							else {
HXDLIN(  23)								b23 = (( (Float)(this49) ) / ( (Float)(255) ));
            							}
HXDLIN(  23)							Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  23)							int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  23)							int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  23)							int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  23)							int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  23)							int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN(  23)							{
HXDLIN(  23)								int _hx_tmp14;
HXDLIN(  23)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)									_hx_tmp14 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            								}
            								else {
HXDLIN(  23)									_hx_tmp14 = blended2;
            								}
HXDLIN(  23)								::iterMagic::Iimg_obj::set(nextImage1->image,location2,_hx_tmp14);
            							}
            						}
            						else {
HXDLIN(  23)							::Dynamic this50 = nextImage1->image;
HXDLIN(  23)							int index7;
HXDLIN(  23)							if (nextImage1->useVirtualPos) {
HXDLIN(  23)								index7 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - nextImage1->virtualY) * ( (Float)(nextImage1->width) )) + x8) - nextImage1->virtualX));
            							}
            							else {
HXDLIN(  23)								index7 = ::Std_obj::_hx_int(( (Float)(((y8 * nextImage1->width) + x8)) ));
            							}
HXDLIN(  23)							int _hx_tmp15;
HXDLIN(  23)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)								_hx_tmp15 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            							}
            							else {
HXDLIN(  23)								_hx_tmp15 = c6;
            							}
HXDLIN(  23)							::iterMagic::Iimg_obj::set(this50,index7,_hx_tmp15);
            						}
            					}
            				}
HXDLIN(  23)				 ::pi_xy::ImageStruct v4;
HXDLIN(  23)				if (inPlace) {
HXDLIN(  23)					{
HXDLIN(  23)						int x10 = ::Std_obj::_hx_int(x);
HXDLIN(  23)						int y10 = ::Std_obj::_hx_int(y);
HXDLIN(  23)						bool forceClear1 = false;
HXDLIN(  23)						{
HXDLIN(  23)							int _g36 = 0;
HXDLIN(  23)							int _g37 = nextImage1->height;
HXDLIN(  23)							while((_g36 < _g37)){
HXDLIN(  23)								_g36 = (_g36 + 1);
HXDLIN(  23)								int dy1 = (_g36 - 1);
HXDLIN(  23)								{
HXDLIN(  23)									int _g38 = 0;
HXDLIN(  23)									int _g39 = nextImage1->width;
HXDLIN(  23)									while((_g38 < _g39)){
HXDLIN(  23)										_g38 = (_g38 + 1);
HXDLIN(  23)										int dx1 = (_g38 - 1);
HXDLIN(  23)										::Dynamic this51 = nextImage1->image;
HXDLIN(  23)										int index8;
HXDLIN(  23)										if (nextImage1->useVirtualPos) {
HXDLIN(  23)											index8 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - nextImage1->virtualY) * ( (Float)(nextImage1->width) )) + dx1) - nextImage1->virtualX));
            										}
            										else {
HXDLIN(  23)											index8 = ::Std_obj::_hx_int(( (Float)(((dy1 * nextImage1->width) + dx1)) ));
            										}
HXDLIN(  23)										int c7 = ::iterMagic::Iimg_obj::get(this51,index8);
HXDLIN(  23)										int col1;
HXDLIN(  23)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)											col1 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            										}
            										else {
HXDLIN(  23)											col1 = c7;
            										}
HXDLIN(  23)										bool v5;
HXDLIN(  23)										if (nextImage1->useMask) {
HXDLIN(  23)											v5 = ::hx::IsNotNull( nextImage1->mask );
            										}
            										else {
HXDLIN(  23)											v5 = false;
            										}
HXDLIN(  23)										if (v5) {
HXDLIN(  23)											 ::pi_xy::ImageStruct this52 = nextImage1->mask;
HXDLIN(  23)											::Dynamic this53 = this52->image;
HXDLIN(  23)											int index9;
HXDLIN(  23)											if (this52->useVirtualPos) {
HXDLIN(  23)												index9 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this52->virtualY) * ( (Float)(this52->width) )) + dx1) - this52->virtualX));
            											}
            											else {
HXDLIN(  23)												index9 = ::Std_obj::_hx_int(( (Float)(((dy1 * this52->width) + dx1)) ));
            											}
HXDLIN(  23)											int c8 = ::iterMagic::Iimg_obj::get(this53,index9);
HXDLIN(  23)											int v6;
HXDLIN(  23)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)												v6 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            											}
            											else {
HXDLIN(  23)												v6 = c8;
            											}
HXDLIN(  23)											int maskPixel1 = v6;
HXDLIN(  23)											int this54 = col1;
HXDLIN(  23)											if ((maskPixel1 == 0)) {
HXDLIN(  23)												col1 = this54;
            											}
            											else {
HXDLIN(  23)												Float m01;
HXDLIN(  23)												int this55 = ((maskPixel1 >> 24) & 255);
HXDLIN(  23)												if ((this55 == 0)) {
HXDLIN(  23)													m01 = ((Float)0.);
            												}
            												else {
HXDLIN(  23)													m01 = (( (Float)(this55) ) / ( (Float)(255) ));
            												}
HXDLIN(  23)												Float m11;
HXDLIN(  23)												int this56 = ((maskPixel1 >> 16) & 255);
HXDLIN(  23)												if ((this56 == 0)) {
HXDLIN(  23)													m11 = ((Float)0.);
            												}
            												else {
HXDLIN(  23)													m11 = (( (Float)(this56) ) / ( (Float)(255) ));
            												}
HXDLIN(  23)												Float m21;
HXDLIN(  23)												int this57 = ((maskPixel1 >> 8) & 255);
HXDLIN(  23)												if ((this57 == 0)) {
HXDLIN(  23)													m21 = ((Float)0.);
            												}
            												else {
HXDLIN(  23)													m21 = (( (Float)(this57) ) / ( (Float)(255) ));
            												}
HXDLIN(  23)												Float m31;
HXDLIN(  23)												int this58 = (maskPixel1 & 255);
HXDLIN(  23)												if ((this58 == 0)) {
HXDLIN(  23)													m31 = ((Float)0.);
            												}
            												else {
HXDLIN(  23)													m31 = (( (Float)(this58) ) / ( (Float)(255) ));
            												}
HXDLIN(  23)												int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this54 >> 24) & 255)) )));
HXDLIN(  23)												int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this54 >> 16) & 255)) )));
HXDLIN(  23)												int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this54 >> 8) & 255)) )));
HXDLIN(  23)												int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this54 & 255)) )));
HXDLIN(  23)												col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN(  23)										if ((col1 != 0)) {
HXDLIN(  23)											int x11 = (x10 + dx1);
HXDLIN(  23)											int y11 = (y10 + dy1);
HXDLIN(  23)											int c9 = col1;
HXDLIN(  23)											bool v7;
HXDLIN(  23)											if ((((c9 >> 24) & 255) < 254)) {
HXDLIN(  23)												v7 = this36->transparent;
            											}
            											else {
HXDLIN(  23)												v7 = false;
            											}
HXDLIN(  23)											if (v7) {
HXDLIN(  23)												int location3;
HXDLIN(  23)												if (this36->useVirtualPos) {
HXDLIN(  23)													location3 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - this36->virtualY) * ( (Float)(this36->width) )) + x11) - this36->virtualX));
            												}
            												else {
HXDLIN(  23)													location3 = ::Std_obj::_hx_int(( (Float)(((y11 * this36->width) + x11)) ));
            												}
HXDLIN(  23)												int this59 = ::iterMagic::Iimg_obj::get(this36->image,location3);
HXDLIN(  23)												int this60;
HXDLIN(  23)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)													this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            												}
            												else {
HXDLIN(  23)													this60 = this59;
            												}
HXDLIN(  23)												Float a13;
HXDLIN(  23)												int this61 = ((this60 >> 24) & 255);
HXDLIN(  23)												if ((this61 == 0)) {
HXDLIN(  23)													a13 = ((Float)0.);
            												}
            												else {
HXDLIN(  23)													a13 = (( (Float)(this61) ) / ( (Float)(255) ));
            												}
HXDLIN(  23)												Float r13;
HXDLIN(  23)												int this62 = ((this60 >> 16) & 255);
HXDLIN(  23)												if ((this62 == 0)) {
HXDLIN(  23)													r13 = ((Float)0.);
            												}
            												else {
HXDLIN(  23)													r13 = (( (Float)(this62) ) / ( (Float)(255) ));
            												}
HXDLIN(  23)												Float g13;
HXDLIN(  23)												int this63 = ((this60 >> 8) & 255);
HXDLIN(  23)												if ((this63 == 0)) {
HXDLIN(  23)													g13 = ((Float)0.);
            												}
            												else {
HXDLIN(  23)													g13 = (( (Float)(this63) ) / ( (Float)(255) ));
            												}
HXDLIN(  23)												Float b14;
HXDLIN(  23)												int this64 = (this60 & 255);
HXDLIN(  23)												if ((this64 == 0)) {
HXDLIN(  23)													b14 = ((Float)0.);
            												}
            												else {
HXDLIN(  23)													b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            												}
HXDLIN(  23)												Float a23;
HXDLIN(  23)												int this65 = ((col1 >> 24) & 255);
HXDLIN(  23)												if ((this65 == 0)) {
HXDLIN(  23)													a23 = ((Float)0.);
            												}
            												else {
HXDLIN(  23)													a23 = (( (Float)(this65) ) / ( (Float)(255) ));
            												}
HXDLIN(  23)												Float r23;
HXDLIN(  23)												int this66 = ((col1 >> 16) & 255);
HXDLIN(  23)												if ((this66 == 0)) {
HXDLIN(  23)													r23 = ((Float)0.);
            												}
            												else {
HXDLIN(  23)													r23 = (( (Float)(this66) ) / ( (Float)(255) ));
            												}
HXDLIN(  23)												Float g23;
HXDLIN(  23)												int this67 = ((col1 >> 8) & 255);
HXDLIN(  23)												if ((this67 == 0)) {
HXDLIN(  23)													g23 = ((Float)0.);
            												}
            												else {
HXDLIN(  23)													g23 = (( (Float)(this67) ) / ( (Float)(255) ));
            												}
HXDLIN(  23)												Float b24;
HXDLIN(  23)												int this68 = (col1 & 255);
HXDLIN(  23)												if ((this68 == 0)) {
HXDLIN(  23)													b24 = ((Float)0.);
            												}
            												else {
HXDLIN(  23)													b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            												}
HXDLIN(  23)												Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  23)												int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  23)												int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  23)												int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN(  23)												int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  23)												int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN(  23)												{
HXDLIN(  23)													int v8;
HXDLIN(  23)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)														v8 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            													}
            													else {
HXDLIN(  23)														v8 = blended3;
            													}
HXDLIN(  23)													::iterMagic::Iimg_obj::set(this36->image,location3,v8);
            												}
            											}
            											else {
HXDLIN(  23)												::Dynamic this69 = this36->image;
HXDLIN(  23)												int index10;
HXDLIN(  23)												if (this36->useVirtualPos) {
HXDLIN(  23)													index10 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - this36->virtualY) * ( (Float)(this36->width) )) + x11) - this36->virtualX));
            												}
            												else {
HXDLIN(  23)													index10 = ::Std_obj::_hx_int(( (Float)(((y11 * this36->width) + x11)) ));
            												}
HXDLIN(  23)												int v9;
HXDLIN(  23)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)													v9 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            												}
            												else {
HXDLIN(  23)													v9 = c9;
            												}
HXDLIN(  23)												::iterMagic::Iimg_obj::set(this69,index10,v9);
            											}
            										}
            										else {
HXDLIN(  23)											if (forceClear1) {
HXDLIN(  23)												::Dynamic this70 = this36->image;
HXDLIN(  23)												int x12 = (x10 + dx1);
HXDLIN(  23)												int y12 = (y10 + dy1);
HXDLIN(  23)												int index11;
HXDLIN(  23)												if (this36->useVirtualPos) {
HXDLIN(  23)													index11 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - this36->virtualY) * ( (Float)(this36->width) )) + x12) - this36->virtualX));
            												}
            												else {
HXDLIN(  23)													index11 = ::Std_obj::_hx_int(( (Float)(((y12 * this36->width) + x12)) ));
            												}
HXDLIN(  23)												::iterMagic::Iimg_obj::set(this70,index11,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  23)					bool v10;
HXDLIN(  23)					if (::hx::IsNotNull( this36->mask )) {
HXDLIN(  23)						v10 = includeMask;
            					}
            					else {
HXDLIN(  23)						v10 = false;
            					}
HXDLIN(  23)					if (v10) {
HXDLIN(  23)						 ::pi_xy::ImageStruct this71 = this36->mask;
HXDLIN(  23)						Float w4 = ( (Float)(this36->width) );
HXDLIN(  23)						Float h2 = ( (Float)(this36->height) );
HXDLIN(  23)						bool transparent2 = this36->mask->transparent;
HXDLIN(  23)						Float r_x2 = x;
HXDLIN(  23)						Float r_y2 = y;
HXDLIN(  23)						Float r_w2 = w4;
HXDLIN(  23)						Float r_h2 = h2;
HXDLIN(  23)						int xmax2 = ::Std_obj::_hx_int(((r_x2 + r_w2) + 1));
HXDLIN(  23)						int ymax2 = ::Std_obj::_hx_int(((r_y2 + r_h2) + 1));
HXDLIN(  23)						int ii_min4 = ::Std_obj::_hx_int(r_x2);
HXDLIN(  23)						int ii_max4 = xmax2;
HXDLIN(  23)						int xRange__start2 = ii_min4;
HXDLIN(  23)						int xRange__max2 = ii_max4;
HXDLIN(  23)						int ii_min5 = ::Std_obj::_hx_int(r_y2);
HXDLIN(  23)						int ii_max5 = ymax2;
HXDLIN(  23)						int yRange__start2 = ii_min5;
HXDLIN(  23)						int yRange__max2 = ii_max5;
HXDLIN(  23)						int range_x2 = xRange__start2;
HXDLIN(  23)						int range_y2 = (yRange__start2 - 1);
HXDLIN(  23)						int range_xReset2 = range_x2;
HXDLIN(  23)						int range_yReset2 = range_y2;
HXDLIN(  23)						int range_xMax2 = (xRange__max2 - 2);
HXDLIN(  23)						int range_yMax2 = (yRange__max2 - 2);
HXDLIN(  23)						int _this_min2 = 0;
HXDLIN(  23)						int _this_max2 = ::Std_obj::_hx_int(( (Float)(((xRange__max2 - xRange__start2) * (yRange__max2 - yRange__start2))) ));
HXDLIN(  23)						int width2 = ::Std_obj::_hx_int(w4);
HXDLIN(  23)						int height2 = ::Std_obj::_hx_int(h2);
HXDLIN(  23)						 ::Dynamic imageType2 = null();
HXDLIN(  23)						 ::pi_xy::ImageStruct this72 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  23)						if (::hx::IsNull( imageType2 )) {
HXLINE(  54)							imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE(  23)						::Dynamic v11;
HXDLIN(  23)						switch((int)(( (int)(imageType2) ))){
            							case (int)0: {
HXDLIN(  23)								 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  23)								 ::iterMagic::BytesImg b10 = byt2;
HXDLIN(  23)								{
HXDLIN(  23)									b10->width = width2;
HXDLIN(  23)									b10->height = height2;
HXDLIN(  23)									b10->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  23)									b10->data = ::haxe::io::Bytes_obj::alloc((b10->length * 4));
HXDLIN(  23)									{
HXDLIN(  23)										int len4 = b10->length;
HXDLIN(  23)										int w5 = 0;
HXDLIN(  23)										{
HXDLIN(  23)											int _g40 = 0;
HXDLIN(  23)											int _g41 = b10->height;
HXDLIN(  23)											while((_g40 < _g41)){
HXDLIN(  23)												_g40 = (_g40 + 1);
HXDLIN(  23)												int y13 = (_g40 - 1);
HXDLIN(  23)												{
HXDLIN(  23)													int _g42 = 0;
HXDLIN(  23)													int _g43 = b10->width;
HXDLIN(  23)													while((_g42 < _g43)){
HXDLIN(  23)														_g42 = (_g42 + 1);
HXDLIN(  23)														int x13 = (_g42 - 1);
HXDLIN(  23)														{
HXDLIN(  23)															w5 = (w5 + 1);
HXDLIN(  23)															b10->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  23)														{
HXDLIN(  23)															w5 = (w5 + 1);
HXDLIN(  23)															b10->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  23)														{
HXDLIN(  23)															w5 = (w5 + 1);
HXDLIN(  23)															b10->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  23)														{
HXDLIN(  23)															w5 = (w5 + 1);
HXDLIN(  23)															b10->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  23)								v11 = b10;
            							}
            							break;
            							case (int)1: {
HXDLIN(  23)								 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  23)								 ::iterMagic::ArrIntImg a9 = arrI2;
HXDLIN(  23)								{
HXDLIN(  23)									a9->width = width2;
HXDLIN(  23)									a9->height = height2;
HXDLIN(  23)									a9->data = ::Array_obj< int >::__new(0);
HXDLIN(  23)									a9->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  23)									{
HXDLIN(  23)										int _g44 = 0;
HXDLIN(  23)										int _g45 = a9->length;
HXDLIN(  23)										while((_g44 < _g45)){
HXDLIN(  23)											_g44 = (_g44 + 1);
HXDLIN(  23)											int i16 = (_g44 - 1);
HXDLIN(  23)											a9->data[i16] = 0;
            										}
            									}
            								}
HXDLIN(  23)								v11 = a9;
            							}
            							break;
            							case (int)2: {
HXDLIN(  23)								 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  23)								 ::iterMagic::U32ArrImg b15 = u32a2;
HXDLIN(  23)								{
HXDLIN(  23)									b15->width = width2;
HXDLIN(  23)									b15->height = height2;
HXDLIN(  23)									b15->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  23)									int size2 = (b15->length * 4);
HXDLIN(  23)									b15->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN(  23)									{
HXDLIN(  23)										int _g46 = 0;
HXDLIN(  23)										int _g47 = b15->length;
HXDLIN(  23)										while((_g46 < _g47)){
HXDLIN(  23)											_g46 = (_g46 + 1);
HXDLIN(  23)											int i17 = (_g46 - 1);
HXDLIN(  23)											{
HXDLIN(  23)												 ::haxe::io::ArrayBufferViewImpl this73 = b15->data;
HXDLIN(  23)												bool v12;
HXDLIN(  23)												if ((i17 >= 0)) {
HXDLIN(  23)													v12 = (i17 < (this73->byteLength >> 2));
            												}
            												else {
HXDLIN(  23)													v12 = false;
            												}
HXDLIN(  23)												if (v12) {
HXDLIN(  23)													 ::haxe::io::Bytes _this2 = this73->bytes;
HXDLIN(  23)													int pos2 = ((i17 << 2) + this73->byteOffset);
HXDLIN(  23)													_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN(  23)													_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN(  23)													_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN(  23)													_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN(  23)								v11 = b15;
            							}
            							break;
            							case (int)3: {
HXDLIN(  23)								 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  23)								 ::iterMagic::VecIntImg v13 = vec2;
HXDLIN(  23)								{
HXDLIN(  23)									v13->width = width2;
HXDLIN(  23)									v13->height = height2;
HXDLIN(  23)									v13->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  23)									v13->data = ::Array_obj< int >::__new(v13->length);
HXDLIN(  23)									{
HXDLIN(  23)										int _g48 = 0;
HXDLIN(  23)										int _g49 = v13->length;
HXDLIN(  23)										while((_g48 < _g49)){
HXDLIN(  23)											_g48 = (_g48 + 1);
HXDLIN(  23)											int i18 = (_g48 - 1);
HXDLIN(  23)											v13->data->__unsafe_set(i18,0);
            										}
            									}
            								}
HXDLIN(  23)								v11 = v13;
            							}
            							break;
            							case (int)4: {
HXDLIN(  23)								 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  23)								 ::iterMagic::StackIntImg b16 = sInt2;
HXDLIN(  23)								{
HXDLIN(  23)									b16->width = width2;
HXDLIN(  23)									b16->height = height2;
HXDLIN(  23)									b16->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  23)									b16->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  23)									{
HXDLIN(  23)										int len5 = b16->length;
HXDLIN(  23)										 ::haxe::ds::GenericStack_Int d2 = b16->data;
HXDLIN(  23)										if (::hx::IsNull( d2->head )) {
HXDLIN(  23)											int _g50 = 0;
HXDLIN(  23)											int _g51 = len5;
HXDLIN(  23)											while((_g50 < _g51)){
HXDLIN(  23)												_g50 = (_g50 + 1);
HXDLIN(  23)												int i19 = (_g50 - 1);
HXDLIN(  23)												d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            											}
            										}
            										else {
HXDLIN(  23)											int _g52 = 0;
HXDLIN(  23)											int _g53 = len5;
HXDLIN(  23)											while((_g52 < _g53)){
HXDLIN(  23)												_g52 = (_g52 + 1);
HXDLIN(  23)												int i20 = (_g52 - 1);
HXDLIN(  23)												{
HXDLIN(  23)													 ::haxe::ds::GenericCell_Int l2 = b16->data->head;
HXDLIN(  23)													 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN(  23)													{
HXDLIN(  23)														int _g54 = 0;
HXDLIN(  23)														int _g55 = i20;
HXDLIN(  23)														while((_g54 < _g55)){
HXDLIN(  23)															_g54 = (_g54 + 1);
HXDLIN(  23)															int i21 = (_g54 - 1);
HXLINE( 345)															prev2 = l2;
HXLINE( 346)															l2 = l2->next;
            														}
            													}
HXLINE(  23)													if (::hx::IsNull( prev2 )) {
HXDLIN(  23)														b16->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  23)														l2 = null();
            													}
            													else {
HXDLIN(  23)														prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  23)														l2 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  23)								v11 = b16;
            							}
            							break;
            						}
HXDLIN(  23)						this72->image = v11;
HXDLIN(  23)						this72->width = width2;
HXDLIN(  23)						this72->height = height2;
HXDLIN(  23)						this72->imageType = ( (int)(imageType2) );
HXDLIN(  23)						 ::pi_xy::ImageStruct nextImage2 = this72;
HXDLIN(  23)						nextImage2->transparent = transparent2;
HXDLIN(  23)						while((_this_min2 < _this_max2)){
HXDLIN(  23)							_this_min2 = (_this_min2 + 1);
HXDLIN(  23)							int i22 = (_this_min2 - 1);
HXDLIN(  23)							if ((range_y2 > range_yMax2)) {
HXDLIN(  23)								range_y2 = range_yReset2;
HXDLIN(  23)								range_x2 = (range_x2 + 1);
            							}
HXDLIN(  23)							range_y2 = (range_y2 + 1);
HXDLIN(  23)							int i23 = i22;
HXDLIN(  23)							{
HXDLIN(  23)								int x14 = range_x2;
HXDLIN(  23)								int y14 = range_y2;
HXDLIN(  23)								int x15 = range_x2;
HXDLIN(  23)								int y15 = (range_yMax2 - range_y2);
HXDLIN(  23)								::Dynamic this74 = this71->image;
HXDLIN(  23)								int index12;
HXDLIN(  23)								if (this71->useVirtualPos) {
HXDLIN(  23)									index12 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - this71->virtualY) * ( (Float)(this71->width) )) + x15) - this71->virtualX));
            								}
            								else {
HXDLIN(  23)									index12 = ::Std_obj::_hx_int(( (Float)(((y15 * this71->width) + x15)) ));
            								}
HXDLIN(  23)								int c10 = ::iterMagic::Iimg_obj::get(this74,index12);
HXDLIN(  23)								int color2;
HXDLIN(  23)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)									color2 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            								}
            								else {
HXDLIN(  23)									color2 = c10;
            								}
HXDLIN(  23)								int c11 = color2;
HXDLIN(  23)								bool v14;
HXDLIN(  23)								if ((((c11 >> 24) & 255) < 254)) {
HXDLIN(  23)									v14 = nextImage2->transparent;
            								}
            								else {
HXDLIN(  23)									v14 = false;
            								}
HXDLIN(  23)								if (v14) {
HXDLIN(  23)									int location4;
HXDLIN(  23)									if (nextImage2->useVirtualPos) {
HXDLIN(  23)										location4 = ::Std_obj::_hx_int(((((( (Float)(y14) ) - nextImage2->virtualY) * ( (Float)(nextImage2->width) )) + x14) - nextImage2->virtualX));
            									}
            									else {
HXDLIN(  23)										location4 = ::Std_obj::_hx_int(( (Float)(((y14 * nextImage2->width) + x14)) ));
            									}
HXDLIN(  23)									int this75 = ::iterMagic::Iimg_obj::get(nextImage2->image,location4);
HXDLIN(  23)									int this76;
HXDLIN(  23)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)										this76 = ((((((this75 >> 24) & 255) << 24) | ((this75 & 255) << 16)) | (((this75 >> 8) & 255) << 8)) | ((this75 >> 16) & 255));
            									}
            									else {
HXDLIN(  23)										this76 = this75;
            									}
HXDLIN(  23)									Float a14;
HXDLIN(  23)									int this77 = ((this76 >> 24) & 255);
HXDLIN(  23)									if ((this77 == 0)) {
HXDLIN(  23)										a14 = ((Float)0.);
            									}
            									else {
HXDLIN(  23)										a14 = (( (Float)(this77) ) / ( (Float)(255) ));
            									}
HXDLIN(  23)									Float r14;
HXDLIN(  23)									int this78 = ((this76 >> 16) & 255);
HXDLIN(  23)									if ((this78 == 0)) {
HXDLIN(  23)										r14 = ((Float)0.);
            									}
            									else {
HXDLIN(  23)										r14 = (( (Float)(this78) ) / ( (Float)(255) ));
            									}
HXDLIN(  23)									Float g14;
HXDLIN(  23)									int this79 = ((this76 >> 8) & 255);
HXDLIN(  23)									if ((this79 == 0)) {
HXDLIN(  23)										g14 = ((Float)0.);
            									}
            									else {
HXDLIN(  23)										g14 = (( (Float)(this79) ) / ( (Float)(255) ));
            									}
HXDLIN(  23)									Float b17;
HXDLIN(  23)									int this80 = (this76 & 255);
HXDLIN(  23)									if ((this80 == 0)) {
HXDLIN(  23)										b17 = ((Float)0.);
            									}
            									else {
HXDLIN(  23)										b17 = (( (Float)(this80) ) / ( (Float)(255) ));
            									}
HXDLIN(  23)									Float a24;
HXDLIN(  23)									int this81 = ((color2 >> 24) & 255);
HXDLIN(  23)									if ((this81 == 0)) {
HXDLIN(  23)										a24 = ((Float)0.);
            									}
            									else {
HXDLIN(  23)										a24 = (( (Float)(this81) ) / ( (Float)(255) ));
            									}
HXDLIN(  23)									Float r24;
HXDLIN(  23)									int this82 = ((color2 >> 16) & 255);
HXDLIN(  23)									if ((this82 == 0)) {
HXDLIN(  23)										r24 = ((Float)0.);
            									}
            									else {
HXDLIN(  23)										r24 = (( (Float)(this82) ) / ( (Float)(255) ));
            									}
HXDLIN(  23)									Float g24;
HXDLIN(  23)									int this83 = ((color2 >> 8) & 255);
HXDLIN(  23)									if ((this83 == 0)) {
HXDLIN(  23)										g24 = ((Float)0.);
            									}
            									else {
HXDLIN(  23)										g24 = (( (Float)(this83) ) / ( (Float)(255) ));
            									}
HXDLIN(  23)									Float b25;
HXDLIN(  23)									int this84 = (color2 & 255);
HXDLIN(  23)									if ((this84 == 0)) {
HXDLIN(  23)										b25 = ((Float)0.);
            									}
            									else {
HXDLIN(  23)										b25 = (( (Float)(this84) ) / ( (Float)(255) ));
            									}
HXDLIN(  23)									Float a34 = (a14 * (( (Float)(1) ) - a24));
HXDLIN(  23)									int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN(  23)									int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN(  23)									int b18 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b17 * a34) + (b25 * a24))));
HXDLIN(  23)									int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN(  23)									int blended4 = ((((a10 << 24) | (r6 << 16)) | (g6 << 8)) | b18);
HXDLIN(  23)									{
HXDLIN(  23)										int v15;
HXDLIN(  23)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)											v15 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            										}
            										else {
HXDLIN(  23)											v15 = blended4;
            										}
HXDLIN(  23)										::iterMagic::Iimg_obj::set(nextImage2->image,location4,v15);
            									}
            								}
            								else {
HXDLIN(  23)									::Dynamic this85 = nextImage2->image;
HXDLIN(  23)									int index13;
HXDLIN(  23)									if (nextImage2->useVirtualPos) {
HXDLIN(  23)										index13 = ::Std_obj::_hx_int(((((( (Float)(y14) ) - nextImage2->virtualY) * ( (Float)(nextImage2->width) )) + x14) - nextImage2->virtualX));
            									}
            									else {
HXDLIN(  23)										index13 = ::Std_obj::_hx_int(( (Float)(((y14 * nextImage2->width) + x14)) ));
            									}
HXDLIN(  23)									int v16;
HXDLIN(  23)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)										v16 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            									}
            									else {
HXDLIN(  23)										v16 = c11;
            									}
HXDLIN(  23)									::iterMagic::Iimg_obj::set(this85,index13,v16);
            								}
            							}
            						}
HXDLIN(  23)						 ::pi_xy::ImageStruct v17;
HXDLIN(  23)						if (inPlace) {
HXDLIN(  23)							{
HXDLIN(  23)								int x16 = ::Std_obj::_hx_int(x);
HXDLIN(  23)								int y16 = ::Std_obj::_hx_int(y);
HXDLIN(  23)								bool forceClear2 = false;
HXDLIN(  23)								{
HXDLIN(  23)									int _g56 = 0;
HXDLIN(  23)									int _g57 = nextImage2->height;
HXDLIN(  23)									while((_g56 < _g57)){
HXDLIN(  23)										_g56 = (_g56 + 1);
HXDLIN(  23)										int dy2 = (_g56 - 1);
HXDLIN(  23)										{
HXDLIN(  23)											int _g58 = 0;
HXDLIN(  23)											int _g59 = nextImage2->width;
HXDLIN(  23)											while((_g58 < _g59)){
HXDLIN(  23)												_g58 = (_g58 + 1);
HXDLIN(  23)												int dx2 = (_g58 - 1);
HXDLIN(  23)												::Dynamic this86 = nextImage2->image;
HXDLIN(  23)												int index14;
HXDLIN(  23)												if (nextImage2->useVirtualPos) {
HXDLIN(  23)													index14 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - nextImage2->virtualY) * ( (Float)(nextImage2->width) )) + dx2) - nextImage2->virtualX));
            												}
            												else {
HXDLIN(  23)													index14 = ::Std_obj::_hx_int(( (Float)(((dy2 * nextImage2->width) + dx2)) ));
            												}
HXDLIN(  23)												int c12 = ::iterMagic::Iimg_obj::get(this86,index14);
HXDLIN(  23)												int col2;
HXDLIN(  23)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)													col2 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            												}
            												else {
HXDLIN(  23)													col2 = c12;
            												}
HXDLIN(  23)												bool v18;
HXDLIN(  23)												if (nextImage2->useMask) {
HXDLIN(  23)													v18 = ::hx::IsNotNull( nextImage2->mask );
            												}
            												else {
HXDLIN(  23)													v18 = false;
            												}
HXDLIN(  23)												if (v18) {
HXDLIN(  23)													 ::pi_xy::ImageStruct this87 = nextImage2->mask;
HXDLIN(  23)													::Dynamic this88 = this87->image;
HXDLIN(  23)													int index15;
HXDLIN(  23)													if (this87->useVirtualPos) {
HXDLIN(  23)														index15 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this87->virtualY) * ( (Float)(this87->width) )) + dx2) - this87->virtualX));
            													}
            													else {
HXDLIN(  23)														index15 = ::Std_obj::_hx_int(( (Float)(((dy2 * this87->width) + dx2)) ));
            													}
HXDLIN(  23)													int c13 = ::iterMagic::Iimg_obj::get(this88,index15);
HXDLIN(  23)													int v19;
HXDLIN(  23)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)														v19 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            													}
            													else {
HXDLIN(  23)														v19 = c13;
            													}
HXDLIN(  23)													int maskPixel2 = v19;
HXDLIN(  23)													int this89 = col2;
HXDLIN(  23)													if ((maskPixel2 == 0)) {
HXDLIN(  23)														col2 = this89;
            													}
            													else {
HXDLIN(  23)														Float m02;
HXDLIN(  23)														int this90 = ((maskPixel2 >> 24) & 255);
HXDLIN(  23)														if ((this90 == 0)) {
HXDLIN(  23)															m02 = ((Float)0.);
            														}
            														else {
HXDLIN(  23)															m02 = (( (Float)(this90) ) / ( (Float)(255) ));
            														}
HXDLIN(  23)														Float m12;
HXDLIN(  23)														int this91 = ((maskPixel2 >> 16) & 255);
HXDLIN(  23)														if ((this91 == 0)) {
HXDLIN(  23)															m12 = ((Float)0.);
            														}
            														else {
HXDLIN(  23)															m12 = (( (Float)(this91) ) / ( (Float)(255) ));
            														}
HXDLIN(  23)														Float m22;
HXDLIN(  23)														int this92 = ((maskPixel2 >> 8) & 255);
HXDLIN(  23)														if ((this92 == 0)) {
HXDLIN(  23)															m22 = ((Float)0.);
            														}
            														else {
HXDLIN(  23)															m22 = (( (Float)(this92) ) / ( (Float)(255) ));
            														}
HXDLIN(  23)														Float m32;
HXDLIN(  23)														int this93 = (maskPixel2 & 255);
HXDLIN(  23)														if ((this93 == 0)) {
HXDLIN(  23)															m32 = ((Float)0.);
            														}
            														else {
HXDLIN(  23)															m32 = (( (Float)(this93) ) / ( (Float)(255) ));
            														}
HXDLIN(  23)														int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this89 >> 24) & 255)) )));
HXDLIN(  23)														int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this89 >> 16) & 255)) )));
HXDLIN(  23)														int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this89 >> 8) & 255)) )));
HXDLIN(  23)														int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this89 & 255)) )));
HXDLIN(  23)														col2 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  23)												if ((col2 != 0)) {
HXDLIN(  23)													int x17 = (x16 + dx2);
HXDLIN(  23)													int y17 = (y16 + dy2);
HXDLIN(  23)													int c14 = col2;
HXDLIN(  23)													bool v20;
HXDLIN(  23)													if ((((c14 >> 24) & 255) < 254)) {
HXDLIN(  23)														v20 = this71->transparent;
            													}
            													else {
HXDLIN(  23)														v20 = false;
            													}
HXDLIN(  23)													if (v20) {
HXDLIN(  23)														int location5;
HXDLIN(  23)														if (this71->useVirtualPos) {
HXDLIN(  23)															location5 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - this71->virtualY) * ( (Float)(this71->width) )) + x17) - this71->virtualX));
            														}
            														else {
HXDLIN(  23)															location5 = ::Std_obj::_hx_int(( (Float)(((y17 * this71->width) + x17)) ));
            														}
HXDLIN(  23)														int this94 = ::iterMagic::Iimg_obj::get(this71->image,location5);
HXDLIN(  23)														int this95;
HXDLIN(  23)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)															this95 = ((((((this94 >> 24) & 255) << 24) | ((this94 & 255) << 16)) | (((this94 >> 8) & 255) << 8)) | ((this94 >> 16) & 255));
            														}
            														else {
HXDLIN(  23)															this95 = this94;
            														}
HXDLIN(  23)														Float a15;
HXDLIN(  23)														int this96 = ((this95 >> 24) & 255);
HXDLIN(  23)														if ((this96 == 0)) {
HXDLIN(  23)															a15 = ((Float)0.);
            														}
            														else {
HXDLIN(  23)															a15 = (( (Float)(this96) ) / ( (Float)(255) ));
            														}
HXDLIN(  23)														Float r15;
HXDLIN(  23)														int this97 = ((this95 >> 16) & 255);
HXDLIN(  23)														if ((this97 == 0)) {
HXDLIN(  23)															r15 = ((Float)0.);
            														}
            														else {
HXDLIN(  23)															r15 = (( (Float)(this97) ) / ( (Float)(255) ));
            														}
HXDLIN(  23)														Float g15;
HXDLIN(  23)														int this98 = ((this95 >> 8) & 255);
HXDLIN(  23)														if ((this98 == 0)) {
HXDLIN(  23)															g15 = ((Float)0.);
            														}
            														else {
HXDLIN(  23)															g15 = (( (Float)(this98) ) / ( (Float)(255) ));
            														}
HXDLIN(  23)														Float b19;
HXDLIN(  23)														int this99 = (this95 & 255);
HXDLIN(  23)														if ((this99 == 0)) {
HXDLIN(  23)															b19 = ((Float)0.);
            														}
            														else {
HXDLIN(  23)															b19 = (( (Float)(this99) ) / ( (Float)(255) ));
            														}
HXDLIN(  23)														Float a25;
HXDLIN(  23)														int this100 = ((col2 >> 24) & 255);
HXDLIN(  23)														if ((this100 == 0)) {
HXDLIN(  23)															a25 = ((Float)0.);
            														}
            														else {
HXDLIN(  23)															a25 = (( (Float)(this100) ) / ( (Float)(255) ));
            														}
HXDLIN(  23)														Float r25;
HXDLIN(  23)														int this101 = ((col2 >> 16) & 255);
HXDLIN(  23)														if ((this101 == 0)) {
HXDLIN(  23)															r25 = ((Float)0.);
            														}
            														else {
HXDLIN(  23)															r25 = (( (Float)(this101) ) / ( (Float)(255) ));
            														}
HXDLIN(  23)														Float g25;
HXDLIN(  23)														int this102 = ((col2 >> 8) & 255);
HXDLIN(  23)														if ((this102 == 0)) {
HXDLIN(  23)															g25 = ((Float)0.);
            														}
            														else {
HXDLIN(  23)															g25 = (( (Float)(this102) ) / ( (Float)(255) ));
            														}
HXDLIN(  23)														Float b26;
HXDLIN(  23)														int this103 = (col2 & 255);
HXDLIN(  23)														if ((this103 == 0)) {
HXDLIN(  23)															b26 = ((Float)0.);
            														}
            														else {
HXDLIN(  23)															b26 = (( (Float)(this103) ) / ( (Float)(255) ));
            														}
HXDLIN(  23)														Float a35 = (a15 * (( (Float)(1) ) - a25));
HXDLIN(  23)														int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN(  23)														int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN(  23)														int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b19 * a35) + (b26 * a25))));
HXDLIN(  23)														int a16 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN(  23)														int blended5 = ((((a16 << 24) | (r7 << 16)) | (g7 << 8)) | b20);
HXDLIN(  23)														{
HXDLIN(  23)															int v21;
HXDLIN(  23)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)																v21 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            															}
            															else {
HXDLIN(  23)																v21 = blended5;
            															}
HXDLIN(  23)															::iterMagic::Iimg_obj::set(this71->image,location5,v21);
            														}
            													}
            													else {
HXDLIN(  23)														::Dynamic this104 = this71->image;
HXDLIN(  23)														int index16;
HXDLIN(  23)														if (this71->useVirtualPos) {
HXDLIN(  23)															index16 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - this71->virtualY) * ( (Float)(this71->width) )) + x17) - this71->virtualX));
            														}
            														else {
HXDLIN(  23)															index16 = ::Std_obj::_hx_int(( (Float)(((y17 * this71->width) + x17)) ));
            														}
HXDLIN(  23)														int v22;
HXDLIN(  23)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)															v22 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            														}
            														else {
HXDLIN(  23)															v22 = c14;
            														}
HXDLIN(  23)														::iterMagic::Iimg_obj::set(this104,index16,v22);
            													}
            												}
            												else {
HXDLIN(  23)													if (forceClear2) {
HXDLIN(  23)														::Dynamic this105 = this71->image;
HXDLIN(  23)														int x18 = (x16 + dx2);
HXDLIN(  23)														int y18 = (y16 + dy2);
HXDLIN(  23)														int index17;
HXDLIN(  23)														if (this71->useVirtualPos) {
HXDLIN(  23)															index17 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - this71->virtualY) * ( (Float)(this71->width) )) + x18) - this71->virtualX));
            														}
            														else {
HXDLIN(  23)															index17 = ::Std_obj::_hx_int(( (Float)(((y18 * this71->width) + x18)) ));
            														}
HXDLIN(  23)														::iterMagic::Iimg_obj::set(this105,index17,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  23)							bool v23;
HXDLIN(  23)							if (::hx::IsNotNull( this71->mask )) {
HXDLIN(  23)								v23 = includeMask;
            							}
            							else {
HXDLIN(  23)								v23 = false;
            							}
HXDLIN(  23)							if (v23) {
HXDLIN(  23)								 ::pi_xy::ImageStruct this106 = this71->mask;
HXDLIN(  23)								Float w6 = ( (Float)(this71->width) );
HXDLIN(  23)								Float h3 = ( (Float)(this71->height) );
HXDLIN(  23)								bool transparent3 = this71->mask->transparent;
HXDLIN(  23)								Float r_x3 = x;
HXDLIN(  23)								Float r_y3 = y;
HXDLIN(  23)								Float r_w3 = w6;
HXDLIN(  23)								Float r_h3 = h3;
HXDLIN(  23)								int xmax3 = ::Std_obj::_hx_int(((r_x3 + r_w3) + 1));
HXDLIN(  23)								int ymax3 = ::Std_obj::_hx_int(((r_y3 + r_h3) + 1));
HXDLIN(  23)								int ii_min6 = ::Std_obj::_hx_int(r_x3);
HXDLIN(  23)								int ii_max6 = xmax3;
HXDLIN(  23)								int xRange__start3 = ii_min6;
HXDLIN(  23)								int xRange__max3 = ii_max6;
HXDLIN(  23)								int ii_min7 = ::Std_obj::_hx_int(r_y3);
HXDLIN(  23)								int ii_max7 = ymax3;
HXDLIN(  23)								int yRange__start3 = ii_min7;
HXDLIN(  23)								int yRange__max3 = ii_max7;
HXDLIN(  23)								int range_x3 = xRange__start3;
HXDLIN(  23)								int range_y3 = (yRange__start3 - 1);
HXDLIN(  23)								int range_xReset3 = range_x3;
HXDLIN(  23)								int range_yReset3 = range_y3;
HXDLIN(  23)								int range_xMax3 = (xRange__max3 - 2);
HXDLIN(  23)								int range_yMax3 = (yRange__max3 - 2);
HXDLIN(  23)								int _this_min3 = 0;
HXDLIN(  23)								int _this_max3 = ::Std_obj::_hx_int(( (Float)(((xRange__max3 - xRange__start3) * (yRange__max3 - yRange__start3))) ));
HXDLIN(  23)								int width3 = ::Std_obj::_hx_int(w6);
HXDLIN(  23)								int height3 = ::Std_obj::_hx_int(h3);
HXDLIN(  23)								 ::Dynamic imageType3 = null();
HXDLIN(  23)								 ::pi_xy::ImageStruct this107 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  23)								if (::hx::IsNull( imageType3 )) {
HXLINE(  54)									imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE(  23)								::Dynamic v24;
HXDLIN(  23)								switch((int)(( (int)(imageType3) ))){
            									case (int)0: {
HXDLIN(  23)										 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  23)										 ::iterMagic::BytesImg b27 = byt3;
HXDLIN(  23)										{
HXDLIN(  23)											b27->width = width3;
HXDLIN(  23)											b27->height = height3;
HXDLIN(  23)											b27->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  23)											b27->data = ::haxe::io::Bytes_obj::alloc((b27->length * 4));
HXDLIN(  23)											{
HXDLIN(  23)												int len6 = b27->length;
HXDLIN(  23)												int w7 = 0;
HXDLIN(  23)												{
HXDLIN(  23)													int _g60 = 0;
HXDLIN(  23)													int _g61 = b27->height;
HXDLIN(  23)													while((_g60 < _g61)){
HXDLIN(  23)														_g60 = (_g60 + 1);
HXDLIN(  23)														int y19 = (_g60 - 1);
HXDLIN(  23)														{
HXDLIN(  23)															int _g62 = 0;
HXDLIN(  23)															int _g63 = b27->width;
HXDLIN(  23)															while((_g62 < _g63)){
HXDLIN(  23)																_g62 = (_g62 + 1);
HXDLIN(  23)																int x19 = (_g62 - 1);
HXDLIN(  23)																{
HXDLIN(  23)																	w7 = (w7 + 1);
HXDLIN(  23)																	b27->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  23)																{
HXDLIN(  23)																	w7 = (w7 + 1);
HXDLIN(  23)																	b27->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  23)																{
HXDLIN(  23)																	w7 = (w7 + 1);
HXDLIN(  23)																	b27->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  23)																{
HXDLIN(  23)																	w7 = (w7 + 1);
HXDLIN(  23)																	b27->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  23)										v24 = b27;
            									}
            									break;
            									case (int)1: {
HXDLIN(  23)										 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  23)										 ::iterMagic::ArrIntImg a17 = arrI3;
HXDLIN(  23)										{
HXDLIN(  23)											a17->width = width3;
HXDLIN(  23)											a17->height = height3;
HXDLIN(  23)											a17->data = ::Array_obj< int >::__new(0);
HXDLIN(  23)											a17->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  23)											{
HXDLIN(  23)												int _g64 = 0;
HXDLIN(  23)												int _g65 = a17->length;
HXDLIN(  23)												while((_g64 < _g65)){
HXDLIN(  23)													_g64 = (_g64 + 1);
HXDLIN(  23)													int i24 = (_g64 - 1);
HXDLIN(  23)													a17->data[i24] = 0;
            												}
            											}
            										}
HXDLIN(  23)										v24 = a17;
            									}
            									break;
            									case (int)2: {
HXDLIN(  23)										 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  23)										 ::iterMagic::U32ArrImg b28 = u32a3;
HXDLIN(  23)										{
HXDLIN(  23)											b28->width = width3;
HXDLIN(  23)											b28->height = height3;
HXDLIN(  23)											b28->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  23)											int size3 = (b28->length * 4);
HXDLIN(  23)											b28->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN(  23)											{
HXDLIN(  23)												int _g66 = 0;
HXDLIN(  23)												int _g67 = b28->length;
HXDLIN(  23)												while((_g66 < _g67)){
HXDLIN(  23)													_g66 = (_g66 + 1);
HXDLIN(  23)													int i25 = (_g66 - 1);
HXDLIN(  23)													{
HXDLIN(  23)														 ::haxe::io::ArrayBufferViewImpl this108 = b28->data;
HXDLIN(  23)														bool v25;
HXDLIN(  23)														if ((i25 >= 0)) {
HXDLIN(  23)															v25 = (i25 < (this108->byteLength >> 2));
            														}
            														else {
HXDLIN(  23)															v25 = false;
            														}
HXDLIN(  23)														if (v25) {
HXDLIN(  23)															 ::haxe::io::Bytes _this3 = this108->bytes;
HXDLIN(  23)															int pos3 = ((i25 << 2) + this108->byteOffset);
HXDLIN(  23)															_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN(  23)															_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN(  23)															_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN(  23)															_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN(  23)										v24 = b28;
            									}
            									break;
            									case (int)3: {
HXDLIN(  23)										 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  23)										 ::iterMagic::VecIntImg v26 = vec3;
HXDLIN(  23)										{
HXDLIN(  23)											v26->width = width3;
HXDLIN(  23)											v26->height = height3;
HXDLIN(  23)											v26->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  23)											v26->data = ::Array_obj< int >::__new(v26->length);
HXDLIN(  23)											{
HXDLIN(  23)												int _g68 = 0;
HXDLIN(  23)												int _g69 = v26->length;
HXDLIN(  23)												while((_g68 < _g69)){
HXDLIN(  23)													_g68 = (_g68 + 1);
HXDLIN(  23)													int i26 = (_g68 - 1);
HXDLIN(  23)													v26->data->__unsafe_set(i26,0);
            												}
            											}
            										}
HXDLIN(  23)										v24 = v26;
            									}
            									break;
            									case (int)4: {
HXDLIN(  23)										 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  23)										 ::iterMagic::StackIntImg b29 = sInt3;
HXDLIN(  23)										{
HXDLIN(  23)											b29->width = width3;
HXDLIN(  23)											b29->height = height3;
HXDLIN(  23)											b29->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  23)											b29->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  23)											{
HXDLIN(  23)												int len7 = b29->length;
HXDLIN(  23)												 ::haxe::ds::GenericStack_Int d3 = b29->data;
HXDLIN(  23)												if (::hx::IsNull( d3->head )) {
HXDLIN(  23)													int _g70 = 0;
HXDLIN(  23)													int _g71 = len7;
HXDLIN(  23)													while((_g70 < _g71)){
HXDLIN(  23)														_g70 = (_g70 + 1);
HXDLIN(  23)														int i27 = (_g70 - 1);
HXDLIN(  23)														d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            													}
            												}
            												else {
HXDLIN(  23)													int _g72 = 0;
HXDLIN(  23)													int _g73 = len7;
HXDLIN(  23)													while((_g72 < _g73)){
HXDLIN(  23)														_g72 = (_g72 + 1);
HXDLIN(  23)														int i28 = (_g72 - 1);
HXDLIN(  23)														{
HXDLIN(  23)															 ::haxe::ds::GenericCell_Int l3 = b29->data->head;
HXDLIN(  23)															 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN(  23)															{
HXDLIN(  23)																int _g74 = 0;
HXDLIN(  23)																int _g75 = i28;
HXDLIN(  23)																while((_g74 < _g75)){
HXDLIN(  23)																	_g74 = (_g74 + 1);
HXDLIN(  23)																	int i29 = (_g74 - 1);
HXLINE( 345)																	prev3 = l3;
HXLINE( 346)																	l3 = l3->next;
            																}
            															}
HXLINE(  23)															if (::hx::IsNull( prev3 )) {
HXDLIN(  23)																b29->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  23)																l3 = null();
            															}
            															else {
HXDLIN(  23)																prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  23)																l3 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  23)										v24 = b29;
            									}
            									break;
            								}
HXDLIN(  23)								this107->image = v24;
HXDLIN(  23)								this107->width = width3;
HXDLIN(  23)								this107->height = height3;
HXDLIN(  23)								this107->imageType = ( (int)(imageType3) );
HXDLIN(  23)								 ::pi_xy::ImageStruct nextImage3 = this107;
HXDLIN(  23)								nextImage3->transparent = transparent3;
HXDLIN(  23)								while((_this_min3 < _this_max3)){
HXDLIN(  23)									_this_min3 = (_this_min3 + 1);
HXDLIN(  23)									int i30 = (_this_min3 - 1);
HXDLIN(  23)									if ((range_y3 > range_yMax3)) {
HXDLIN(  23)										range_y3 = range_yReset3;
HXDLIN(  23)										range_x3 = (range_x3 + 1);
            									}
HXDLIN(  23)									range_y3 = (range_y3 + 1);
HXDLIN(  23)									int i31 = i30;
HXDLIN(  23)									{
HXDLIN(  23)										int x20 = range_x3;
HXDLIN(  23)										int y20 = range_y3;
HXDLIN(  23)										int x21 = range_x3;
HXDLIN(  23)										int y21 = (range_yMax3 - range_y3);
HXDLIN(  23)										::Dynamic this109 = this106->image;
HXDLIN(  23)										int index18;
HXDLIN(  23)										if (this106->useVirtualPos) {
HXDLIN(  23)											index18 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - this106->virtualY) * ( (Float)(this106->width) )) + x21) - this106->virtualX));
            										}
            										else {
HXDLIN(  23)											index18 = ::Std_obj::_hx_int(( (Float)(((y21 * this106->width) + x21)) ));
            										}
HXDLIN(  23)										int c15 = ::iterMagic::Iimg_obj::get(this109,index18);
HXDLIN(  23)										int color3;
HXDLIN(  23)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)											color3 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            										}
            										else {
HXDLIN(  23)											color3 = c15;
            										}
HXDLIN(  23)										int c16 = color3;
HXDLIN(  23)										bool v27;
HXDLIN(  23)										if ((((c16 >> 24) & 255) < 254)) {
HXDLIN(  23)											v27 = nextImage3->transparent;
            										}
            										else {
HXDLIN(  23)											v27 = false;
            										}
HXDLIN(  23)										if (v27) {
HXDLIN(  23)											int location6;
HXDLIN(  23)											if (nextImage3->useVirtualPos) {
HXDLIN(  23)												location6 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - nextImage3->virtualY) * ( (Float)(nextImage3->width) )) + x20) - nextImage3->virtualX));
            											}
            											else {
HXDLIN(  23)												location6 = ::Std_obj::_hx_int(( (Float)(((y20 * nextImage3->width) + x20)) ));
            											}
HXDLIN(  23)											int this110 = ::iterMagic::Iimg_obj::get(nextImage3->image,location6);
HXDLIN(  23)											int this111;
HXDLIN(  23)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)												this111 = ((((((this110 >> 24) & 255) << 24) | ((this110 & 255) << 16)) | (((this110 >> 8) & 255) << 8)) | ((this110 >> 16) & 255));
            											}
            											else {
HXDLIN(  23)												this111 = this110;
            											}
HXDLIN(  23)											Float a18;
HXDLIN(  23)											int this112 = ((this111 >> 24) & 255);
HXDLIN(  23)											if ((this112 == 0)) {
HXDLIN(  23)												a18 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												a18 = (( (Float)(this112) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float r16;
HXDLIN(  23)											int this113 = ((this111 >> 16) & 255);
HXDLIN(  23)											if ((this113 == 0)) {
HXDLIN(  23)												r16 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												r16 = (( (Float)(this113) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float g16;
HXDLIN(  23)											int this114 = ((this111 >> 8) & 255);
HXDLIN(  23)											if ((this114 == 0)) {
HXDLIN(  23)												g16 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												g16 = (( (Float)(this114) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float b110;
HXDLIN(  23)											int this115 = (this111 & 255);
HXDLIN(  23)											if ((this115 == 0)) {
HXDLIN(  23)												b110 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												b110 = (( (Float)(this115) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float a26;
HXDLIN(  23)											int this116 = ((color3 >> 24) & 255);
HXDLIN(  23)											if ((this116 == 0)) {
HXDLIN(  23)												a26 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												a26 = (( (Float)(this116) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float r26;
HXDLIN(  23)											int this117 = ((color3 >> 16) & 255);
HXDLIN(  23)											if ((this117 == 0)) {
HXDLIN(  23)												r26 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												r26 = (( (Float)(this117) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float g26;
HXDLIN(  23)											int this118 = ((color3 >> 8) & 255);
HXDLIN(  23)											if ((this118 == 0)) {
HXDLIN(  23)												g26 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												g26 = (( (Float)(this118) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float b210;
HXDLIN(  23)											int this119 = (color3 & 255);
HXDLIN(  23)											if ((this119 == 0)) {
HXDLIN(  23)												b210 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												b210 = (( (Float)(this119) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float a36 = (a18 * (( (Float)(1) ) - a26));
HXDLIN(  23)											int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN(  23)											int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN(  23)											int b30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a36) + (b210 * a26))));
HXDLIN(  23)											int a19 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN(  23)											int blended6 = ((((a19 << 24) | (r8 << 16)) | (g8 << 8)) | b30);
HXDLIN(  23)											{
HXDLIN(  23)												int v28;
HXDLIN(  23)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)													v28 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            												}
            												else {
HXDLIN(  23)													v28 = blended6;
            												}
HXDLIN(  23)												::iterMagic::Iimg_obj::set(nextImage3->image,location6,v28);
            											}
            										}
            										else {
HXDLIN(  23)											::Dynamic this120 = nextImage3->image;
HXDLIN(  23)											int index19;
HXDLIN(  23)											if (nextImage3->useVirtualPos) {
HXDLIN(  23)												index19 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - nextImage3->virtualY) * ( (Float)(nextImage3->width) )) + x20) - nextImage3->virtualX));
            											}
            											else {
HXDLIN(  23)												index19 = ::Std_obj::_hx_int(( (Float)(((y20 * nextImage3->width) + x20)) ));
            											}
HXDLIN(  23)											int v29;
HXDLIN(  23)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)												v29 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            											}
            											else {
HXDLIN(  23)												v29 = c16;
            											}
HXDLIN(  23)											::iterMagic::Iimg_obj::set(this120,index19,v29);
            										}
            									}
            								}
HXDLIN(  23)								 ::pi_xy::ImageStruct v30;
HXDLIN(  23)								if (inPlace) {
HXDLIN(  23)									{
HXDLIN(  23)										int x22 = ::Std_obj::_hx_int(x);
HXDLIN(  23)										int y22 = ::Std_obj::_hx_int(y);
HXDLIN(  23)										bool forceClear3 = false;
HXDLIN(  23)										{
HXDLIN(  23)											int _g76 = 0;
HXDLIN(  23)											int _g77 = nextImage3->height;
HXDLIN(  23)											while((_g76 < _g77)){
HXDLIN(  23)												_g76 = (_g76 + 1);
HXDLIN(  23)												int dy3 = (_g76 - 1);
HXDLIN(  23)												{
HXDLIN(  23)													int _g78 = 0;
HXDLIN(  23)													int _g79 = nextImage3->width;
HXDLIN(  23)													while((_g78 < _g79)){
HXDLIN(  23)														_g78 = (_g78 + 1);
HXDLIN(  23)														int dx3 = (_g78 - 1);
HXDLIN(  23)														::Dynamic this121 = nextImage3->image;
HXDLIN(  23)														int index20;
HXDLIN(  23)														if (nextImage3->useVirtualPos) {
HXDLIN(  23)															index20 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - nextImage3->virtualY) * ( (Float)(nextImage3->width) )) + dx3) - nextImage3->virtualX));
            														}
            														else {
HXDLIN(  23)															index20 = ::Std_obj::_hx_int(( (Float)(((dy3 * nextImage3->width) + dx3)) ));
            														}
HXDLIN(  23)														int c17 = ::iterMagic::Iimg_obj::get(this121,index20);
HXDLIN(  23)														int col3;
HXDLIN(  23)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)															col3 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            														}
            														else {
HXDLIN(  23)															col3 = c17;
            														}
HXDLIN(  23)														bool v31;
HXDLIN(  23)														if (nextImage3->useMask) {
HXDLIN(  23)															v31 = ::hx::IsNotNull( nextImage3->mask );
            														}
            														else {
HXDLIN(  23)															v31 = false;
            														}
HXDLIN(  23)														if (v31) {
HXDLIN(  23)															 ::pi_xy::ImageStruct this122 = nextImage3->mask;
HXDLIN(  23)															::Dynamic this123 = this122->image;
HXDLIN(  23)															int index21;
HXDLIN(  23)															if (this122->useVirtualPos) {
HXDLIN(  23)																index21 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - this122->virtualY) * ( (Float)(this122->width) )) + dx3) - this122->virtualX));
            															}
            															else {
HXDLIN(  23)																index21 = ::Std_obj::_hx_int(( (Float)(((dy3 * this122->width) + dx3)) ));
            															}
HXDLIN(  23)															int c18 = ::iterMagic::Iimg_obj::get(this123,index21);
HXDLIN(  23)															int v32;
HXDLIN(  23)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)																v32 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            															}
            															else {
HXDLIN(  23)																v32 = c18;
            															}
HXDLIN(  23)															int maskPixel3 = v32;
HXDLIN(  23)															int this124 = col3;
HXDLIN(  23)															if ((maskPixel3 == 0)) {
HXDLIN(  23)																col3 = this124;
            															}
            															else {
HXDLIN(  23)																Float m03;
HXDLIN(  23)																int this125 = ((maskPixel3 >> 24) & 255);
HXDLIN(  23)																if ((this125 == 0)) {
HXDLIN(  23)																	m03 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	m03 = (( (Float)(this125) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float m13;
HXDLIN(  23)																int this126 = ((maskPixel3 >> 16) & 255);
HXDLIN(  23)																if ((this126 == 0)) {
HXDLIN(  23)																	m13 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	m13 = (( (Float)(this126) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float m23;
HXDLIN(  23)																int this127 = ((maskPixel3 >> 8) & 255);
HXDLIN(  23)																if ((this127 == 0)) {
HXDLIN(  23)																	m23 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	m23 = (( (Float)(this127) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float m33;
HXDLIN(  23)																int this128 = (maskPixel3 & 255);
HXDLIN(  23)																if ((this128 == 0)) {
HXDLIN(  23)																	m33 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	m33 = (( (Float)(this128) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																int ch03 = ::Std_obj::_hx_int(((((Float)1.) - m03) * ( (Float)(((this124 >> 24) & 255)) )));
HXDLIN(  23)																int ch13 = ::Std_obj::_hx_int(((((Float)1.) - m13) * ( (Float)(((this124 >> 16) & 255)) )));
HXDLIN(  23)																int ch23 = ::Std_obj::_hx_int(((((Float)1.) - m23) * ( (Float)(((this124 >> 8) & 255)) )));
HXDLIN(  23)																int ch33 = ::Std_obj::_hx_int(((((Float)1.) - m33) * ( (Float)((this124 & 255)) )));
HXDLIN(  23)																col3 = ((((::Math_obj::round((( (Float)(ch03) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch13) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch23) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch33) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  23)														if ((col3 != 0)) {
HXDLIN(  23)															int x23 = (x22 + dx3);
HXDLIN(  23)															int y23 = (y22 + dy3);
HXDLIN(  23)															int c19 = col3;
HXDLIN(  23)															bool v33;
HXDLIN(  23)															if ((((c19 >> 24) & 255) < 254)) {
HXDLIN(  23)																v33 = this106->transparent;
            															}
            															else {
HXDLIN(  23)																v33 = false;
            															}
HXDLIN(  23)															if (v33) {
HXDLIN(  23)																int location7;
HXDLIN(  23)																if (this106->useVirtualPos) {
HXDLIN(  23)																	location7 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - this106->virtualY) * ( (Float)(this106->width) )) + x23) - this106->virtualX));
            																}
            																else {
HXDLIN(  23)																	location7 = ::Std_obj::_hx_int(( (Float)(((y23 * this106->width) + x23)) ));
            																}
HXDLIN(  23)																int this129 = ::iterMagic::Iimg_obj::get(this106->image,location7);
HXDLIN(  23)																int this130;
HXDLIN(  23)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)																	this130 = ((((((this129 >> 24) & 255) << 24) | ((this129 & 255) << 16)) | (((this129 >> 8) & 255) << 8)) | ((this129 >> 16) & 255));
            																}
            																else {
HXDLIN(  23)																	this130 = this129;
            																}
HXDLIN(  23)																Float a110;
HXDLIN(  23)																int this131 = ((this130 >> 24) & 255);
HXDLIN(  23)																if ((this131 == 0)) {
HXDLIN(  23)																	a110 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	a110 = (( (Float)(this131) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float r17;
HXDLIN(  23)																int this132 = ((this130 >> 16) & 255);
HXDLIN(  23)																if ((this132 == 0)) {
HXDLIN(  23)																	r17 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	r17 = (( (Float)(this132) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float g17;
HXDLIN(  23)																int this133 = ((this130 >> 8) & 255);
HXDLIN(  23)																if ((this133 == 0)) {
HXDLIN(  23)																	g17 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	g17 = (( (Float)(this133) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float b111;
HXDLIN(  23)																int this134 = (this130 & 255);
HXDLIN(  23)																if ((this134 == 0)) {
HXDLIN(  23)																	b111 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	b111 = (( (Float)(this134) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float a27;
HXDLIN(  23)																int this135 = ((col3 >> 24) & 255);
HXDLIN(  23)																if ((this135 == 0)) {
HXDLIN(  23)																	a27 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	a27 = (( (Float)(this135) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float r27;
HXDLIN(  23)																int this136 = ((col3 >> 16) & 255);
HXDLIN(  23)																if ((this136 == 0)) {
HXDLIN(  23)																	r27 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	r27 = (( (Float)(this136) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float g27;
HXDLIN(  23)																int this137 = ((col3 >> 8) & 255);
HXDLIN(  23)																if ((this137 == 0)) {
HXDLIN(  23)																	g27 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	g27 = (( (Float)(this137) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float b211;
HXDLIN(  23)																int this138 = (col3 & 255);
HXDLIN(  23)																if ((this138 == 0)) {
HXDLIN(  23)																	b211 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	b211 = (( (Float)(this138) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float a37 = (a110 * (( (Float)(1) ) - a27));
HXDLIN(  23)																int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN(  23)																int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN(  23)																int b31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a37) + (b211 * a27))));
HXDLIN(  23)																int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN(  23)																int blended7 = ((((a20 << 24) | (r9 << 16)) | (g9 << 8)) | b31);
HXDLIN(  23)																{
HXDLIN(  23)																	int v34;
HXDLIN(  23)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)																		v34 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            																	}
            																	else {
HXDLIN(  23)																		v34 = blended7;
            																	}
HXDLIN(  23)																	::iterMagic::Iimg_obj::set(this106->image,location7,v34);
            																}
            															}
            															else {
HXDLIN(  23)																::Dynamic this139 = this106->image;
HXDLIN(  23)																int index22;
HXDLIN(  23)																if (this106->useVirtualPos) {
HXDLIN(  23)																	index22 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - this106->virtualY) * ( (Float)(this106->width) )) + x23) - this106->virtualX));
            																}
            																else {
HXDLIN(  23)																	index22 = ::Std_obj::_hx_int(( (Float)(((y23 * this106->width) + x23)) ));
            																}
HXDLIN(  23)																int v35;
HXDLIN(  23)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)																	v35 = ((((((c19 >> 24) & 255) << 24) | ((c19 & 255) << 16)) | (((c19 >> 8) & 255) << 8)) | ((c19 >> 16) & 255));
            																}
            																else {
HXDLIN(  23)																	v35 = c19;
            																}
HXDLIN(  23)																::iterMagic::Iimg_obj::set(this139,index22,v35);
            															}
            														}
            														else {
HXDLIN(  23)															if (forceClear3) {
HXDLIN(  23)																::Dynamic this140 = this106->image;
HXDLIN(  23)																int x24 = (x22 + dx3);
HXDLIN(  23)																int y24 = (y22 + dy3);
HXDLIN(  23)																int index23;
HXDLIN(  23)																if (this106->useVirtualPos) {
HXDLIN(  23)																	index23 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - this106->virtualY) * ( (Float)(this106->width) )) + x24) - this106->virtualX));
            																}
            																else {
HXDLIN(  23)																	index23 = ::Std_obj::_hx_int(( (Float)(((y24 * this106->width) + x24)) ));
            																}
HXDLIN(  23)																::iterMagic::Iimg_obj::set(this140,index23,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  23)									bool v36;
HXDLIN(  23)									if (::hx::IsNotNull( this106->mask )) {
HXDLIN(  23)										v36 = includeMask;
            									}
            									else {
HXDLIN(  23)										v36 = false;
            									}
HXDLIN(  23)									if (v36) {
HXDLIN(  23)										 ::pi_xy::ImageStruct v37 = ::pi_xy::imageAbstracts::_TransformImage::TransformImage_Impl__obj::flippedY(this106->mask,x,y,( (Float)(this106->width) ),( (Float)(this106->height) ),this106->mask->transparent,inPlace,includeMask);
HXDLIN(  23)										this106->useMask = true;
HXDLIN(  23)										this106->mask = v37;
            									}
HXLINE(  91)									nextImage3 = null();
HXLINE(  23)									v30 = this106;
            								}
            								else {
HXDLIN(  23)									bool v38;
HXDLIN(  23)									if (::hx::IsNotNull( this106->mask )) {
HXDLIN(  23)										v38 = includeMask;
            									}
            									else {
HXDLIN(  23)										v38 = false;
            									}
HXDLIN(  23)									if (v38) {
HXDLIN(  23)										 ::pi_xy::ImageStruct v39 = ::pi_xy::imageAbstracts::_TransformImage::TransformImage_Impl__obj::flippedY(this106->mask,x,y,( (Float)(this106->width) ),( (Float)(this106->height) ),this106->mask->transparent,inPlace,includeMask);
HXDLIN(  23)										nextImage3->useMask = true;
HXDLIN(  23)										nextImage3->mask = v39;
            									}
HXDLIN(  23)									v30 = nextImage3;
            								}
HXDLIN(  23)								this71->useMask = true;
HXDLIN(  23)								this71->mask = v30;
            							}
HXLINE(  91)							nextImage2 = null();
HXLINE(  23)							v17 = this71;
            						}
            						else {
HXDLIN(  23)							bool v40;
HXDLIN(  23)							if (::hx::IsNotNull( this71->mask )) {
HXDLIN(  23)								v40 = includeMask;
            							}
            							else {
HXDLIN(  23)								v40 = false;
            							}
HXDLIN(  23)							if (v40) {
HXDLIN(  23)								 ::pi_xy::ImageStruct this141 = this71->mask;
HXDLIN(  23)								Float w8 = ( (Float)(this71->width) );
HXDLIN(  23)								Float h4 = ( (Float)(this71->height) );
HXDLIN(  23)								bool transparent4 = this71->mask->transparent;
HXDLIN(  23)								Float r_x4 = x;
HXDLIN(  23)								Float r_y4 = y;
HXDLIN(  23)								Float r_w4 = w8;
HXDLIN(  23)								Float r_h4 = h4;
HXDLIN(  23)								int xmax4 = ::Std_obj::_hx_int(((r_x4 + r_w4) + 1));
HXDLIN(  23)								int ymax4 = ::Std_obj::_hx_int(((r_y4 + r_h4) + 1));
HXDLIN(  23)								int ii_min8 = ::Std_obj::_hx_int(r_x4);
HXDLIN(  23)								int ii_max8 = xmax4;
HXDLIN(  23)								int xRange__start4 = ii_min8;
HXDLIN(  23)								int xRange__max4 = ii_max8;
HXDLIN(  23)								int ii_min9 = ::Std_obj::_hx_int(r_y4);
HXDLIN(  23)								int ii_max9 = ymax4;
HXDLIN(  23)								int yRange__start4 = ii_min9;
HXDLIN(  23)								int yRange__max4 = ii_max9;
HXDLIN(  23)								int range_x4 = xRange__start4;
HXDLIN(  23)								int range_y4 = (yRange__start4 - 1);
HXDLIN(  23)								int range_xReset4 = range_x4;
HXDLIN(  23)								int range_yReset4 = range_y4;
HXDLIN(  23)								int range_xMax4 = (xRange__max4 - 2);
HXDLIN(  23)								int range_yMax4 = (yRange__max4 - 2);
HXDLIN(  23)								int _this_min4 = 0;
HXDLIN(  23)								int _this_max4 = ::Std_obj::_hx_int(( (Float)(((xRange__max4 - xRange__start4) * (yRange__max4 - yRange__start4))) ));
HXDLIN(  23)								int width4 = ::Std_obj::_hx_int(w8);
HXDLIN(  23)								int height4 = ::Std_obj::_hx_int(h4);
HXDLIN(  23)								 ::Dynamic imageType4 = null();
HXDLIN(  23)								 ::pi_xy::ImageStruct this142 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  23)								if (::hx::IsNull( imageType4 )) {
HXLINE(  54)									imageType4 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE(  23)								::Dynamic v41;
HXDLIN(  23)								switch((int)(( (int)(imageType4) ))){
            									case (int)0: {
HXDLIN(  23)										 ::iterMagic::BytesImg byt4 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  23)										 ::iterMagic::BytesImg b32 = byt4;
HXDLIN(  23)										{
HXDLIN(  23)											b32->width = width4;
HXDLIN(  23)											b32->height = height4;
HXDLIN(  23)											b32->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN(  23)											b32->data = ::haxe::io::Bytes_obj::alloc((b32->length * 4));
HXDLIN(  23)											{
HXDLIN(  23)												int len8 = b32->length;
HXDLIN(  23)												int w9 = 0;
HXDLIN(  23)												{
HXDLIN(  23)													int _g80 = 0;
HXDLIN(  23)													int _g81 = b32->height;
HXDLIN(  23)													while((_g80 < _g81)){
HXDLIN(  23)														_g80 = (_g80 + 1);
HXDLIN(  23)														int y25 = (_g80 - 1);
HXDLIN(  23)														{
HXDLIN(  23)															int _g82 = 0;
HXDLIN(  23)															int _g83 = b32->width;
HXDLIN(  23)															while((_g82 < _g83)){
HXDLIN(  23)																_g82 = (_g82 + 1);
HXDLIN(  23)																int x25 = (_g82 - 1);
HXDLIN(  23)																{
HXDLIN(  23)																	w9 = (w9 + 1);
HXDLIN(  23)																	b32->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  23)																{
HXDLIN(  23)																	w9 = (w9 + 1);
HXDLIN(  23)																	b32->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  23)																{
HXDLIN(  23)																	w9 = (w9 + 1);
HXDLIN(  23)																	b32->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  23)																{
HXDLIN(  23)																	w9 = (w9 + 1);
HXDLIN(  23)																	b32->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  23)										v41 = b32;
            									}
            									break;
            									case (int)1: {
HXDLIN(  23)										 ::iterMagic::ArrIntImg arrI4 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  23)										 ::iterMagic::ArrIntImg a28 = arrI4;
HXDLIN(  23)										{
HXDLIN(  23)											a28->width = width4;
HXDLIN(  23)											a28->height = height4;
HXDLIN(  23)											a28->data = ::Array_obj< int >::__new(0);
HXDLIN(  23)											a28->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN(  23)											{
HXDLIN(  23)												int _g84 = 0;
HXDLIN(  23)												int _g85 = a28->length;
HXDLIN(  23)												while((_g84 < _g85)){
HXDLIN(  23)													_g84 = (_g84 + 1);
HXDLIN(  23)													int i32 = (_g84 - 1);
HXDLIN(  23)													a28->data[i32] = 0;
            												}
            											}
            										}
HXDLIN(  23)										v41 = a28;
            									}
            									break;
            									case (int)2: {
HXDLIN(  23)										 ::iterMagic::U32ArrImg u32a4 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  23)										 ::iterMagic::U32ArrImg b33 = u32a4;
HXDLIN(  23)										{
HXDLIN(  23)											b33->width = width4;
HXDLIN(  23)											b33->height = height4;
HXDLIN(  23)											b33->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN(  23)											int size4 = (b33->length * 4);
HXDLIN(  23)											b33->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size4),0,size4);
HXDLIN(  23)											{
HXDLIN(  23)												int _g86 = 0;
HXDLIN(  23)												int _g87 = b33->length;
HXDLIN(  23)												while((_g86 < _g87)){
HXDLIN(  23)													_g86 = (_g86 + 1);
HXDLIN(  23)													int i33 = (_g86 - 1);
HXDLIN(  23)													{
HXDLIN(  23)														 ::haxe::io::ArrayBufferViewImpl this143 = b33->data;
HXDLIN(  23)														bool v42;
HXDLIN(  23)														if ((i33 >= 0)) {
HXDLIN(  23)															v42 = (i33 < (this143->byteLength >> 2));
            														}
            														else {
HXDLIN(  23)															v42 = false;
            														}
HXDLIN(  23)														if (v42) {
HXDLIN(  23)															 ::haxe::io::Bytes _this4 = this143->bytes;
HXDLIN(  23)															int pos4 = ((i33 << 2) + this143->byteOffset);
HXDLIN(  23)															_this4->b[pos4] = ( (unsigned char)(0) );
HXDLIN(  23)															_this4->b[(pos4 + 1)] = ( (unsigned char)(0) );
HXDLIN(  23)															_this4->b[(pos4 + 2)] = ( (unsigned char)(0) );
HXDLIN(  23)															_this4->b[(pos4 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN(  23)										v41 = b33;
            									}
            									break;
            									case (int)3: {
HXDLIN(  23)										 ::iterMagic::VecIntImg vec4 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  23)										 ::iterMagic::VecIntImg v43 = vec4;
HXDLIN(  23)										{
HXDLIN(  23)											v43->width = width4;
HXDLIN(  23)											v43->height = height4;
HXDLIN(  23)											v43->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN(  23)											v43->data = ::Array_obj< int >::__new(v43->length);
HXDLIN(  23)											{
HXDLIN(  23)												int _g88 = 0;
HXDLIN(  23)												int _g89 = v43->length;
HXDLIN(  23)												while((_g88 < _g89)){
HXDLIN(  23)													_g88 = (_g88 + 1);
HXDLIN(  23)													int i34 = (_g88 - 1);
HXDLIN(  23)													v43->data->__unsafe_set(i34,0);
            												}
            											}
            										}
HXDLIN(  23)										v41 = v43;
            									}
            									break;
            									case (int)4: {
HXDLIN(  23)										 ::iterMagic::StackIntImg sInt4 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  23)										 ::iterMagic::StackIntImg b34 = sInt4;
HXDLIN(  23)										{
HXDLIN(  23)											b34->width = width4;
HXDLIN(  23)											b34->height = height4;
HXDLIN(  23)											b34->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN(  23)											b34->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  23)											{
HXDLIN(  23)												int len9 = b34->length;
HXDLIN(  23)												 ::haxe::ds::GenericStack_Int d4 = b34->data;
HXDLIN(  23)												if (::hx::IsNull( d4->head )) {
HXDLIN(  23)													int _g90 = 0;
HXDLIN(  23)													int _g91 = len9;
HXDLIN(  23)													while((_g90 < _g91)){
HXDLIN(  23)														_g90 = (_g90 + 1);
HXDLIN(  23)														int i35 = (_g90 - 1);
HXDLIN(  23)														d4->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d4->head);
            													}
            												}
            												else {
HXDLIN(  23)													int _g92 = 0;
HXDLIN(  23)													int _g93 = len9;
HXDLIN(  23)													while((_g92 < _g93)){
HXDLIN(  23)														_g92 = (_g92 + 1);
HXDLIN(  23)														int i36 = (_g92 - 1);
HXDLIN(  23)														{
HXDLIN(  23)															 ::haxe::ds::GenericCell_Int l4 = b34->data->head;
HXDLIN(  23)															 ::haxe::ds::GenericCell_Int prev4 = null();
HXDLIN(  23)															{
HXDLIN(  23)																int _g94 = 0;
HXDLIN(  23)																int _g95 = i36;
HXDLIN(  23)																while((_g94 < _g95)){
HXDLIN(  23)																	_g94 = (_g94 + 1);
HXDLIN(  23)																	int i37 = (_g94 - 1);
HXLINE( 345)																	prev4 = l4;
HXLINE( 346)																	l4 = l4->next;
            																}
            															}
HXLINE(  23)															if (::hx::IsNull( prev4 )) {
HXDLIN(  23)																b34->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN(  23)																l4 = null();
            															}
            															else {
HXDLIN(  23)																prev4->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN(  23)																l4 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  23)										v41 = b34;
            									}
            									break;
            								}
HXDLIN(  23)								this142->image = v41;
HXDLIN(  23)								this142->width = width4;
HXDLIN(  23)								this142->height = height4;
HXDLIN(  23)								this142->imageType = ( (int)(imageType4) );
HXDLIN(  23)								 ::pi_xy::ImageStruct nextImage4 = this142;
HXDLIN(  23)								nextImage4->transparent = transparent4;
HXDLIN(  23)								while((_this_min4 < _this_max4)){
HXDLIN(  23)									_this_min4 = (_this_min4 + 1);
HXDLIN(  23)									int i38 = (_this_min4 - 1);
HXDLIN(  23)									if ((range_y4 > range_yMax4)) {
HXDLIN(  23)										range_y4 = range_yReset4;
HXDLIN(  23)										range_x4 = (range_x4 + 1);
            									}
HXDLIN(  23)									range_y4 = (range_y4 + 1);
HXDLIN(  23)									int i39 = i38;
HXDLIN(  23)									{
HXDLIN(  23)										int x26 = range_x4;
HXDLIN(  23)										int y26 = range_y4;
HXDLIN(  23)										int x27 = range_x4;
HXDLIN(  23)										int y27 = (range_yMax4 - range_y4);
HXDLIN(  23)										::Dynamic this144 = this141->image;
HXDLIN(  23)										int index24;
HXDLIN(  23)										if (this141->useVirtualPos) {
HXDLIN(  23)											index24 = ::Std_obj::_hx_int(((((( (Float)(y27) ) - this141->virtualY) * ( (Float)(this141->width) )) + x27) - this141->virtualX));
            										}
            										else {
HXDLIN(  23)											index24 = ::Std_obj::_hx_int(( (Float)(((y27 * this141->width) + x27)) ));
            										}
HXDLIN(  23)										int c20 = ::iterMagic::Iimg_obj::get(this144,index24);
HXDLIN(  23)										int color4;
HXDLIN(  23)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)											color4 = ((((((c20 >> 24) & 255) << 24) | ((c20 & 255) << 16)) | (((c20 >> 8) & 255) << 8)) | ((c20 >> 16) & 255));
            										}
            										else {
HXDLIN(  23)											color4 = c20;
            										}
HXDLIN(  23)										int c21 = color4;
HXDLIN(  23)										bool v44;
HXDLIN(  23)										if ((((c21 >> 24) & 255) < 254)) {
HXDLIN(  23)											v44 = nextImage4->transparent;
            										}
            										else {
HXDLIN(  23)											v44 = false;
            										}
HXDLIN(  23)										if (v44) {
HXDLIN(  23)											int location8;
HXDLIN(  23)											if (nextImage4->useVirtualPos) {
HXDLIN(  23)												location8 = ::Std_obj::_hx_int(((((( (Float)(y26) ) - nextImage4->virtualY) * ( (Float)(nextImage4->width) )) + x26) - nextImage4->virtualX));
            											}
            											else {
HXDLIN(  23)												location8 = ::Std_obj::_hx_int(( (Float)(((y26 * nextImage4->width) + x26)) ));
            											}
HXDLIN(  23)											int this145 = ::iterMagic::Iimg_obj::get(nextImage4->image,location8);
HXDLIN(  23)											int this146;
HXDLIN(  23)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)												this146 = ((((((this145 >> 24) & 255) << 24) | ((this145 & 255) << 16)) | (((this145 >> 8) & 255) << 8)) | ((this145 >> 16) & 255));
            											}
            											else {
HXDLIN(  23)												this146 = this145;
            											}
HXDLIN(  23)											Float a111;
HXDLIN(  23)											int this147 = ((this146 >> 24) & 255);
HXDLIN(  23)											if ((this147 == 0)) {
HXDLIN(  23)												a111 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												a111 = (( (Float)(this147) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float r18;
HXDLIN(  23)											int this148 = ((this146 >> 16) & 255);
HXDLIN(  23)											if ((this148 == 0)) {
HXDLIN(  23)												r18 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												r18 = (( (Float)(this148) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float g18;
HXDLIN(  23)											int this149 = ((this146 >> 8) & 255);
HXDLIN(  23)											if ((this149 == 0)) {
HXDLIN(  23)												g18 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												g18 = (( (Float)(this149) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float b112;
HXDLIN(  23)											int this150 = (this146 & 255);
HXDLIN(  23)											if ((this150 == 0)) {
HXDLIN(  23)												b112 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												b112 = (( (Float)(this150) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float a29;
HXDLIN(  23)											int this151 = ((color4 >> 24) & 255);
HXDLIN(  23)											if ((this151 == 0)) {
HXDLIN(  23)												a29 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												a29 = (( (Float)(this151) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float r28;
HXDLIN(  23)											int this152 = ((color4 >> 16) & 255);
HXDLIN(  23)											if ((this152 == 0)) {
HXDLIN(  23)												r28 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												r28 = (( (Float)(this152) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float g28;
HXDLIN(  23)											int this153 = ((color4 >> 8) & 255);
HXDLIN(  23)											if ((this153 == 0)) {
HXDLIN(  23)												g28 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												g28 = (( (Float)(this153) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float b212;
HXDLIN(  23)											int this154 = (color4 & 255);
HXDLIN(  23)											if ((this154 == 0)) {
HXDLIN(  23)												b212 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												b212 = (( (Float)(this154) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float a38 = (a111 * (( (Float)(1) ) - a29));
HXDLIN(  23)											int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a38) + (r28 * a29))));
HXDLIN(  23)											int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a38) + (g28 * a29))));
HXDLIN(  23)											int b35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a38) + (b212 * a29))));
HXDLIN(  23)											int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a29)));
HXDLIN(  23)											int blended8 = ((((a30 << 24) | (r10 << 16)) | (g10 << 8)) | b35);
HXDLIN(  23)											{
HXDLIN(  23)												int v45;
HXDLIN(  23)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)													v45 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            												}
            												else {
HXDLIN(  23)													v45 = blended8;
            												}
HXDLIN(  23)												::iterMagic::Iimg_obj::set(nextImage4->image,location8,v45);
            											}
            										}
            										else {
HXDLIN(  23)											::Dynamic this155 = nextImage4->image;
HXDLIN(  23)											int index25;
HXDLIN(  23)											if (nextImage4->useVirtualPos) {
HXDLIN(  23)												index25 = ::Std_obj::_hx_int(((((( (Float)(y26) ) - nextImage4->virtualY) * ( (Float)(nextImage4->width) )) + x26) - nextImage4->virtualX));
            											}
            											else {
HXDLIN(  23)												index25 = ::Std_obj::_hx_int(( (Float)(((y26 * nextImage4->width) + x26)) ));
            											}
HXDLIN(  23)											int v46;
HXDLIN(  23)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)												v46 = ((((((c21 >> 24) & 255) << 24) | ((c21 & 255) << 16)) | (((c21 >> 8) & 255) << 8)) | ((c21 >> 16) & 255));
            											}
            											else {
HXDLIN(  23)												v46 = c21;
            											}
HXDLIN(  23)											::iterMagic::Iimg_obj::set(this155,index25,v46);
            										}
            									}
            								}
HXDLIN(  23)								 ::pi_xy::ImageStruct v47;
HXDLIN(  23)								if (inPlace) {
HXDLIN(  23)									{
HXDLIN(  23)										int x28 = ::Std_obj::_hx_int(x);
HXDLIN(  23)										int y28 = ::Std_obj::_hx_int(y);
HXDLIN(  23)										bool forceClear4 = false;
HXDLIN(  23)										{
HXDLIN(  23)											int _g96 = 0;
HXDLIN(  23)											int _g97 = nextImage4->height;
HXDLIN(  23)											while((_g96 < _g97)){
HXDLIN(  23)												_g96 = (_g96 + 1);
HXDLIN(  23)												int dy4 = (_g96 - 1);
HXDLIN(  23)												{
HXDLIN(  23)													int _g98 = 0;
HXDLIN(  23)													int _g99 = nextImage4->width;
HXDLIN(  23)													while((_g98 < _g99)){
HXDLIN(  23)														_g98 = (_g98 + 1);
HXDLIN(  23)														int dx4 = (_g98 - 1);
HXDLIN(  23)														::Dynamic this156 = nextImage4->image;
HXDLIN(  23)														int index26;
HXDLIN(  23)														if (nextImage4->useVirtualPos) {
HXDLIN(  23)															index26 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - nextImage4->virtualY) * ( (Float)(nextImage4->width) )) + dx4) - nextImage4->virtualX));
            														}
            														else {
HXDLIN(  23)															index26 = ::Std_obj::_hx_int(( (Float)(((dy4 * nextImage4->width) + dx4)) ));
            														}
HXDLIN(  23)														int c22 = ::iterMagic::Iimg_obj::get(this156,index26);
HXDLIN(  23)														int col4;
HXDLIN(  23)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)															col4 = ((((((c22 >> 24) & 255) << 24) | ((c22 & 255) << 16)) | (((c22 >> 8) & 255) << 8)) | ((c22 >> 16) & 255));
            														}
            														else {
HXDLIN(  23)															col4 = c22;
            														}
HXDLIN(  23)														bool v48;
HXDLIN(  23)														if (nextImage4->useMask) {
HXDLIN(  23)															v48 = ::hx::IsNotNull( nextImage4->mask );
            														}
            														else {
HXDLIN(  23)															v48 = false;
            														}
HXDLIN(  23)														if (v48) {
HXDLIN(  23)															 ::pi_xy::ImageStruct this157 = nextImage4->mask;
HXDLIN(  23)															::Dynamic this158 = this157->image;
HXDLIN(  23)															int index27;
HXDLIN(  23)															if (this157->useVirtualPos) {
HXDLIN(  23)																index27 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this157->virtualY) * ( (Float)(this157->width) )) + dx4) - this157->virtualX));
            															}
            															else {
HXDLIN(  23)																index27 = ::Std_obj::_hx_int(( (Float)(((dy4 * this157->width) + dx4)) ));
            															}
HXDLIN(  23)															int c23 = ::iterMagic::Iimg_obj::get(this158,index27);
HXDLIN(  23)															int v49;
HXDLIN(  23)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)																v49 = ((((((c23 >> 24) & 255) << 24) | ((c23 & 255) << 16)) | (((c23 >> 8) & 255) << 8)) | ((c23 >> 16) & 255));
            															}
            															else {
HXDLIN(  23)																v49 = c23;
            															}
HXDLIN(  23)															int maskPixel4 = v49;
HXDLIN(  23)															int this159 = col4;
HXDLIN(  23)															if ((maskPixel4 == 0)) {
HXDLIN(  23)																col4 = this159;
            															}
            															else {
HXDLIN(  23)																Float m04;
HXDLIN(  23)																int this160 = ((maskPixel4 >> 24) & 255);
HXDLIN(  23)																if ((this160 == 0)) {
HXDLIN(  23)																	m04 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	m04 = (( (Float)(this160) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float m14;
HXDLIN(  23)																int this161 = ((maskPixel4 >> 16) & 255);
HXDLIN(  23)																if ((this161 == 0)) {
HXDLIN(  23)																	m14 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	m14 = (( (Float)(this161) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float m24;
HXDLIN(  23)																int this162 = ((maskPixel4 >> 8) & 255);
HXDLIN(  23)																if ((this162 == 0)) {
HXDLIN(  23)																	m24 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	m24 = (( (Float)(this162) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float m34;
HXDLIN(  23)																int this163 = (maskPixel4 & 255);
HXDLIN(  23)																if ((this163 == 0)) {
HXDLIN(  23)																	m34 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	m34 = (( (Float)(this163) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																int ch04 = ::Std_obj::_hx_int(((((Float)1.) - m04) * ( (Float)(((this159 >> 24) & 255)) )));
HXDLIN(  23)																int ch14 = ::Std_obj::_hx_int(((((Float)1.) - m14) * ( (Float)(((this159 >> 16) & 255)) )));
HXDLIN(  23)																int ch24 = ::Std_obj::_hx_int(((((Float)1.) - m24) * ( (Float)(((this159 >> 8) & 255)) )));
HXDLIN(  23)																int ch34 = ::Std_obj::_hx_int(((((Float)1.) - m34) * ( (Float)((this159 & 255)) )));
HXDLIN(  23)																col4 = ((((::Math_obj::round((( (Float)(ch04) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch14) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch24) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch34) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  23)														if ((col4 != 0)) {
HXDLIN(  23)															int x29 = (x28 + dx4);
HXDLIN(  23)															int y29 = (y28 + dy4);
HXDLIN(  23)															int c24 = col4;
HXDLIN(  23)															bool v50;
HXDLIN(  23)															if ((((c24 >> 24) & 255) < 254)) {
HXDLIN(  23)																v50 = this141->transparent;
            															}
            															else {
HXDLIN(  23)																v50 = false;
            															}
HXDLIN(  23)															if (v50) {
HXDLIN(  23)																int location9;
HXDLIN(  23)																if (this141->useVirtualPos) {
HXDLIN(  23)																	location9 = ::Std_obj::_hx_int(((((( (Float)(y29) ) - this141->virtualY) * ( (Float)(this141->width) )) + x29) - this141->virtualX));
            																}
            																else {
HXDLIN(  23)																	location9 = ::Std_obj::_hx_int(( (Float)(((y29 * this141->width) + x29)) ));
            																}
HXDLIN(  23)																int this164 = ::iterMagic::Iimg_obj::get(this141->image,location9);
HXDLIN(  23)																int this165;
HXDLIN(  23)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)																	this165 = ((((((this164 >> 24) & 255) << 24) | ((this164 & 255) << 16)) | (((this164 >> 8) & 255) << 8)) | ((this164 >> 16) & 255));
            																}
            																else {
HXDLIN(  23)																	this165 = this164;
            																}
HXDLIN(  23)																Float a112;
HXDLIN(  23)																int this166 = ((this165 >> 24) & 255);
HXDLIN(  23)																if ((this166 == 0)) {
HXDLIN(  23)																	a112 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	a112 = (( (Float)(this166) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float r19;
HXDLIN(  23)																int this167 = ((this165 >> 16) & 255);
HXDLIN(  23)																if ((this167 == 0)) {
HXDLIN(  23)																	r19 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	r19 = (( (Float)(this167) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float g19;
HXDLIN(  23)																int this168 = ((this165 >> 8) & 255);
HXDLIN(  23)																if ((this168 == 0)) {
HXDLIN(  23)																	g19 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	g19 = (( (Float)(this168) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float b113;
HXDLIN(  23)																int this169 = (this165 & 255);
HXDLIN(  23)																if ((this169 == 0)) {
HXDLIN(  23)																	b113 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	b113 = (( (Float)(this169) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float a210;
HXDLIN(  23)																int this170 = ((col4 >> 24) & 255);
HXDLIN(  23)																if ((this170 == 0)) {
HXDLIN(  23)																	a210 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	a210 = (( (Float)(this170) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float r29;
HXDLIN(  23)																int this171 = ((col4 >> 16) & 255);
HXDLIN(  23)																if ((this171 == 0)) {
HXDLIN(  23)																	r29 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	r29 = (( (Float)(this171) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float g29;
HXDLIN(  23)																int this172 = ((col4 >> 8) & 255);
HXDLIN(  23)																if ((this172 == 0)) {
HXDLIN(  23)																	g29 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	g29 = (( (Float)(this172) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float b213;
HXDLIN(  23)																int this173 = (col4 & 255);
HXDLIN(  23)																if ((this173 == 0)) {
HXDLIN(  23)																	b213 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	b213 = (( (Float)(this173) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float a39 = (a112 * (( (Float)(1) ) - a210));
HXDLIN(  23)																int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a39) + (r29 * a210))));
HXDLIN(  23)																int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a39) + (g29 * a210))));
HXDLIN(  23)																int b36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a39) + (b213 * a210))));
HXDLIN(  23)																int a40 = ::Std_obj::_hx_int((( (Float)(255) ) * (a39 + a210)));
HXDLIN(  23)																int blended9 = ((((a40 << 24) | (r20 << 16)) | (g20 << 8)) | b36);
HXDLIN(  23)																{
HXDLIN(  23)																	int v51;
HXDLIN(  23)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)																		v51 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            																	}
            																	else {
HXDLIN(  23)																		v51 = blended9;
            																	}
HXDLIN(  23)																	::iterMagic::Iimg_obj::set(this141->image,location9,v51);
            																}
            															}
            															else {
HXDLIN(  23)																::Dynamic this174 = this141->image;
HXDLIN(  23)																int index28;
HXDLIN(  23)																if (this141->useVirtualPos) {
HXDLIN(  23)																	index28 = ::Std_obj::_hx_int(((((( (Float)(y29) ) - this141->virtualY) * ( (Float)(this141->width) )) + x29) - this141->virtualX));
            																}
            																else {
HXDLIN(  23)																	index28 = ::Std_obj::_hx_int(( (Float)(((y29 * this141->width) + x29)) ));
            																}
HXDLIN(  23)																int v52;
HXDLIN(  23)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)																	v52 = ((((((c24 >> 24) & 255) << 24) | ((c24 & 255) << 16)) | (((c24 >> 8) & 255) << 8)) | ((c24 >> 16) & 255));
            																}
            																else {
HXDLIN(  23)																	v52 = c24;
            																}
HXDLIN(  23)																::iterMagic::Iimg_obj::set(this174,index28,v52);
            															}
            														}
            														else {
HXDLIN(  23)															if (forceClear4) {
HXDLIN(  23)																::Dynamic this175 = this141->image;
HXDLIN(  23)																int x30 = (x28 + dx4);
HXDLIN(  23)																int y30 = (y28 + dy4);
HXDLIN(  23)																int index29;
HXDLIN(  23)																if (this141->useVirtualPos) {
HXDLIN(  23)																	index29 = ::Std_obj::_hx_int(((((( (Float)(y30) ) - this141->virtualY) * ( (Float)(this141->width) )) + x30) - this141->virtualX));
            																}
            																else {
HXDLIN(  23)																	index29 = ::Std_obj::_hx_int(( (Float)(((y30 * this141->width) + x30)) ));
            																}
HXDLIN(  23)																::iterMagic::Iimg_obj::set(this175,index29,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  23)									bool v53;
HXDLIN(  23)									if (::hx::IsNotNull( this141->mask )) {
HXDLIN(  23)										v53 = includeMask;
            									}
            									else {
HXDLIN(  23)										v53 = false;
            									}
HXDLIN(  23)									if (v53) {
HXDLIN(  23)										 ::pi_xy::ImageStruct v54 = ::pi_xy::imageAbstracts::_TransformImage::TransformImage_Impl__obj::flippedY(this141->mask,x,y,( (Float)(this141->width) ),( (Float)(this141->height) ),this141->mask->transparent,inPlace,includeMask);
HXDLIN(  23)										this141->useMask = true;
HXDLIN(  23)										this141->mask = v54;
            									}
HXLINE(  91)									nextImage4 = null();
HXLINE(  23)									v47 = this141;
            								}
            								else {
HXDLIN(  23)									bool v55;
HXDLIN(  23)									if (::hx::IsNotNull( this141->mask )) {
HXDLIN(  23)										v55 = includeMask;
            									}
            									else {
HXDLIN(  23)										v55 = false;
            									}
HXDLIN(  23)									if (v55) {
HXDLIN(  23)										 ::pi_xy::ImageStruct v56 = ::pi_xy::imageAbstracts::_TransformImage::TransformImage_Impl__obj::flippedY(this141->mask,x,y,( (Float)(this141->width) ),( (Float)(this141->height) ),this141->mask->transparent,inPlace,includeMask);
HXDLIN(  23)										nextImage4->useMask = true;
HXDLIN(  23)										nextImage4->mask = v56;
            									}
HXDLIN(  23)									v47 = nextImage4;
            								}
HXDLIN(  23)								nextImage2->useMask = true;
HXDLIN(  23)								nextImage2->mask = v47;
            							}
HXDLIN(  23)							v17 = nextImage2;
            						}
HXDLIN(  23)						this36->useMask = true;
HXDLIN(  23)						this36->mask = v17;
            					}
HXLINE(  91)					nextImage1 = null();
HXLINE(  23)					v4 = this36;
            				}
            				else {
HXDLIN(  23)					bool v57;
HXDLIN(  23)					if (::hx::IsNotNull( this36->mask )) {
HXDLIN(  23)						v57 = includeMask;
            					}
            					else {
HXDLIN(  23)						v57 = false;
            					}
HXDLIN(  23)					if (v57) {
HXDLIN(  23)						 ::pi_xy::ImageStruct this176 = this36->mask;
HXDLIN(  23)						Float w10 = ( (Float)(this36->width) );
HXDLIN(  23)						Float h5 = ( (Float)(this36->height) );
HXDLIN(  23)						bool transparent5 = this36->mask->transparent;
HXDLIN(  23)						Float r_x5 = x;
HXDLIN(  23)						Float r_y5 = y;
HXDLIN(  23)						Float r_w5 = w10;
HXDLIN(  23)						Float r_h5 = h5;
HXDLIN(  23)						int xmax5 = ::Std_obj::_hx_int(((r_x5 + r_w5) + 1));
HXDLIN(  23)						int ymax5 = ::Std_obj::_hx_int(((r_y5 + r_h5) + 1));
HXDLIN(  23)						int ii_min10 = ::Std_obj::_hx_int(r_x5);
HXDLIN(  23)						int ii_max10 = xmax5;
HXDLIN(  23)						int xRange__start5 = ii_min10;
HXDLIN(  23)						int xRange__max5 = ii_max10;
HXDLIN(  23)						int ii_min11 = ::Std_obj::_hx_int(r_y5);
HXDLIN(  23)						int ii_max11 = ymax5;
HXDLIN(  23)						int yRange__start5 = ii_min11;
HXDLIN(  23)						int yRange__max5 = ii_max11;
HXDLIN(  23)						int range_x5 = xRange__start5;
HXDLIN(  23)						int range_y5 = (yRange__start5 - 1);
HXDLIN(  23)						int range_xReset5 = range_x5;
HXDLIN(  23)						int range_yReset5 = range_y5;
HXDLIN(  23)						int range_xMax5 = (xRange__max5 - 2);
HXDLIN(  23)						int range_yMax5 = (yRange__max5 - 2);
HXDLIN(  23)						int _this_min5 = 0;
HXDLIN(  23)						int _this_max5 = ::Std_obj::_hx_int(( (Float)(((xRange__max5 - xRange__start5) * (yRange__max5 - yRange__start5))) ));
HXDLIN(  23)						int width5 = ::Std_obj::_hx_int(w10);
HXDLIN(  23)						int height5 = ::Std_obj::_hx_int(h5);
HXDLIN(  23)						 ::Dynamic imageType5 = null();
HXDLIN(  23)						 ::pi_xy::ImageStruct this177 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  23)						if (::hx::IsNull( imageType5 )) {
HXLINE(  54)							imageType5 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE(  23)						::Dynamic v58;
HXDLIN(  23)						switch((int)(( (int)(imageType5) ))){
            							case (int)0: {
HXDLIN(  23)								 ::iterMagic::BytesImg byt5 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  23)								 ::iterMagic::BytesImg b37 = byt5;
HXDLIN(  23)								{
HXDLIN(  23)									b37->width = width5;
HXDLIN(  23)									b37->height = height5;
HXDLIN(  23)									b37->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN(  23)									b37->data = ::haxe::io::Bytes_obj::alloc((b37->length * 4));
HXDLIN(  23)									{
HXDLIN(  23)										int len10 = b37->length;
HXDLIN(  23)										int w11 = 0;
HXDLIN(  23)										{
HXDLIN(  23)											int _g100 = 0;
HXDLIN(  23)											int _g101 = b37->height;
HXDLIN(  23)											while((_g100 < _g101)){
HXDLIN(  23)												_g100 = (_g100 + 1);
HXDLIN(  23)												int y31 = (_g100 - 1);
HXDLIN(  23)												{
HXDLIN(  23)													int _g102 = 0;
HXDLIN(  23)													int _g103 = b37->width;
HXDLIN(  23)													while((_g102 < _g103)){
HXDLIN(  23)														_g102 = (_g102 + 1);
HXDLIN(  23)														int x31 = (_g102 - 1);
HXDLIN(  23)														{
HXDLIN(  23)															w11 = (w11 + 1);
HXDLIN(  23)															b37->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  23)														{
HXDLIN(  23)															w11 = (w11 + 1);
HXDLIN(  23)															b37->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  23)														{
HXDLIN(  23)															w11 = (w11 + 1);
HXDLIN(  23)															b37->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  23)														{
HXDLIN(  23)															w11 = (w11 + 1);
HXDLIN(  23)															b37->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  23)								v58 = b37;
            							}
            							break;
            							case (int)1: {
HXDLIN(  23)								 ::iterMagic::ArrIntImg arrI5 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  23)								 ::iterMagic::ArrIntImg a41 = arrI5;
HXDLIN(  23)								{
HXDLIN(  23)									a41->width = width5;
HXDLIN(  23)									a41->height = height5;
HXDLIN(  23)									a41->data = ::Array_obj< int >::__new(0);
HXDLIN(  23)									a41->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN(  23)									{
HXDLIN(  23)										int _g104 = 0;
HXDLIN(  23)										int _g105 = a41->length;
HXDLIN(  23)										while((_g104 < _g105)){
HXDLIN(  23)											_g104 = (_g104 + 1);
HXDLIN(  23)											int i40 = (_g104 - 1);
HXDLIN(  23)											a41->data[i40] = 0;
            										}
            									}
            								}
HXDLIN(  23)								v58 = a41;
            							}
            							break;
            							case (int)2: {
HXDLIN(  23)								 ::iterMagic::U32ArrImg u32a5 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  23)								 ::iterMagic::U32ArrImg b38 = u32a5;
HXDLIN(  23)								{
HXDLIN(  23)									b38->width = width5;
HXDLIN(  23)									b38->height = height5;
HXDLIN(  23)									b38->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN(  23)									int size5 = (b38->length * 4);
HXDLIN(  23)									b38->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size5),0,size5);
HXDLIN(  23)									{
HXDLIN(  23)										int _g106 = 0;
HXDLIN(  23)										int _g107 = b38->length;
HXDLIN(  23)										while((_g106 < _g107)){
HXDLIN(  23)											_g106 = (_g106 + 1);
HXDLIN(  23)											int i41 = (_g106 - 1);
HXDLIN(  23)											{
HXDLIN(  23)												 ::haxe::io::ArrayBufferViewImpl this178 = b38->data;
HXDLIN(  23)												bool v59;
HXDLIN(  23)												if ((i41 >= 0)) {
HXDLIN(  23)													v59 = (i41 < (this178->byteLength >> 2));
            												}
            												else {
HXDLIN(  23)													v59 = false;
            												}
HXDLIN(  23)												if (v59) {
HXDLIN(  23)													 ::haxe::io::Bytes _this5 = this178->bytes;
HXDLIN(  23)													int pos5 = ((i41 << 2) + this178->byteOffset);
HXDLIN(  23)													_this5->b[pos5] = ( (unsigned char)(0) );
HXDLIN(  23)													_this5->b[(pos5 + 1)] = ( (unsigned char)(0) );
HXDLIN(  23)													_this5->b[(pos5 + 2)] = ( (unsigned char)(0) );
HXDLIN(  23)													_this5->b[(pos5 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN(  23)								v58 = b38;
            							}
            							break;
            							case (int)3: {
HXDLIN(  23)								 ::iterMagic::VecIntImg vec5 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  23)								 ::iterMagic::VecIntImg v60 = vec5;
HXDLIN(  23)								{
HXDLIN(  23)									v60->width = width5;
HXDLIN(  23)									v60->height = height5;
HXDLIN(  23)									v60->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN(  23)									v60->data = ::Array_obj< int >::__new(v60->length);
HXDLIN(  23)									{
HXDLIN(  23)										int _g108 = 0;
HXDLIN(  23)										int _g109 = v60->length;
HXDLIN(  23)										while((_g108 < _g109)){
HXDLIN(  23)											_g108 = (_g108 + 1);
HXDLIN(  23)											int i42 = (_g108 - 1);
HXDLIN(  23)											v60->data->__unsafe_set(i42,0);
            										}
            									}
            								}
HXDLIN(  23)								v58 = v60;
            							}
            							break;
            							case (int)4: {
HXDLIN(  23)								 ::iterMagic::StackIntImg sInt5 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  23)								 ::iterMagic::StackIntImg b39 = sInt5;
HXDLIN(  23)								{
HXDLIN(  23)									b39->width = width5;
HXDLIN(  23)									b39->height = height5;
HXDLIN(  23)									b39->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN(  23)									b39->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  23)									{
HXDLIN(  23)										int len11 = b39->length;
HXDLIN(  23)										 ::haxe::ds::GenericStack_Int d5 = b39->data;
HXDLIN(  23)										if (::hx::IsNull( d5->head )) {
HXDLIN(  23)											int _g110 = 0;
HXDLIN(  23)											int _g111 = len11;
HXDLIN(  23)											while((_g110 < _g111)){
HXDLIN(  23)												_g110 = (_g110 + 1);
HXDLIN(  23)												int i43 = (_g110 - 1);
HXDLIN(  23)												d5->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d5->head);
            											}
            										}
            										else {
HXDLIN(  23)											int _g112 = 0;
HXDLIN(  23)											int _g113 = len11;
HXDLIN(  23)											while((_g112 < _g113)){
HXDLIN(  23)												_g112 = (_g112 + 1);
HXDLIN(  23)												int i44 = (_g112 - 1);
HXDLIN(  23)												{
HXDLIN(  23)													 ::haxe::ds::GenericCell_Int l5 = b39->data->head;
HXDLIN(  23)													 ::haxe::ds::GenericCell_Int prev5 = null();
HXDLIN(  23)													{
HXDLIN(  23)														int _g114 = 0;
HXDLIN(  23)														int _g115 = i44;
HXDLIN(  23)														while((_g114 < _g115)){
HXDLIN(  23)															_g114 = (_g114 + 1);
HXDLIN(  23)															int i45 = (_g114 - 1);
HXLINE( 345)															prev5 = l5;
HXLINE( 346)															l5 = l5->next;
            														}
            													}
HXLINE(  23)													if (::hx::IsNull( prev5 )) {
HXDLIN(  23)														b39->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN(  23)														l5 = null();
            													}
            													else {
HXDLIN(  23)														prev5->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN(  23)														l5 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  23)								v58 = b39;
            							}
            							break;
            						}
HXDLIN(  23)						this177->image = v58;
HXDLIN(  23)						this177->width = width5;
HXDLIN(  23)						this177->height = height5;
HXDLIN(  23)						this177->imageType = ( (int)(imageType5) );
HXDLIN(  23)						 ::pi_xy::ImageStruct nextImage5 = this177;
HXDLIN(  23)						nextImage5->transparent = transparent5;
HXDLIN(  23)						while((_this_min5 < _this_max5)){
HXDLIN(  23)							_this_min5 = (_this_min5 + 1);
HXDLIN(  23)							int i46 = (_this_min5 - 1);
HXDLIN(  23)							if ((range_y5 > range_yMax5)) {
HXDLIN(  23)								range_y5 = range_yReset5;
HXDLIN(  23)								range_x5 = (range_x5 + 1);
            							}
HXDLIN(  23)							range_y5 = (range_y5 + 1);
HXDLIN(  23)							int i47 = i46;
HXDLIN(  23)							{
HXDLIN(  23)								int x32 = range_x5;
HXDLIN(  23)								int y32 = range_y5;
HXDLIN(  23)								int x33 = range_x5;
HXDLIN(  23)								int y33 = (range_yMax5 - range_y5);
HXDLIN(  23)								::Dynamic this179 = this176->image;
HXDLIN(  23)								int index30;
HXDLIN(  23)								if (this176->useVirtualPos) {
HXDLIN(  23)									index30 = ::Std_obj::_hx_int(((((( (Float)(y33) ) - this176->virtualY) * ( (Float)(this176->width) )) + x33) - this176->virtualX));
            								}
            								else {
HXDLIN(  23)									index30 = ::Std_obj::_hx_int(( (Float)(((y33 * this176->width) + x33)) ));
            								}
HXDLIN(  23)								int c25 = ::iterMagic::Iimg_obj::get(this179,index30);
HXDLIN(  23)								int color5;
HXDLIN(  23)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)									color5 = ((((((c25 >> 24) & 255) << 24) | ((c25 & 255) << 16)) | (((c25 >> 8) & 255) << 8)) | ((c25 >> 16) & 255));
            								}
            								else {
HXDLIN(  23)									color5 = c25;
            								}
HXDLIN(  23)								int c26 = color5;
HXDLIN(  23)								bool v61;
HXDLIN(  23)								if ((((c26 >> 24) & 255) < 254)) {
HXDLIN(  23)									v61 = nextImage5->transparent;
            								}
            								else {
HXDLIN(  23)									v61 = false;
            								}
HXDLIN(  23)								if (v61) {
HXDLIN(  23)									int location10;
HXDLIN(  23)									if (nextImage5->useVirtualPos) {
HXDLIN(  23)										location10 = ::Std_obj::_hx_int(((((( (Float)(y32) ) - nextImage5->virtualY) * ( (Float)(nextImage5->width) )) + x32) - nextImage5->virtualX));
            									}
            									else {
HXDLIN(  23)										location10 = ::Std_obj::_hx_int(( (Float)(((y32 * nextImage5->width) + x32)) ));
            									}
HXDLIN(  23)									int this180 = ::iterMagic::Iimg_obj::get(nextImage5->image,location10);
HXDLIN(  23)									int this181;
HXDLIN(  23)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)										this181 = ((((((this180 >> 24) & 255) << 24) | ((this180 & 255) << 16)) | (((this180 >> 8) & 255) << 8)) | ((this180 >> 16) & 255));
            									}
            									else {
HXDLIN(  23)										this181 = this180;
            									}
HXDLIN(  23)									Float a113;
HXDLIN(  23)									int this182 = ((this181 >> 24) & 255);
HXDLIN(  23)									if ((this182 == 0)) {
HXDLIN(  23)										a113 = ((Float)0.);
            									}
            									else {
HXDLIN(  23)										a113 = (( (Float)(this182) ) / ( (Float)(255) ));
            									}
HXDLIN(  23)									Float r110;
HXDLIN(  23)									int this183 = ((this181 >> 16) & 255);
HXDLIN(  23)									if ((this183 == 0)) {
HXDLIN(  23)										r110 = ((Float)0.);
            									}
            									else {
HXDLIN(  23)										r110 = (( (Float)(this183) ) / ( (Float)(255) ));
            									}
HXDLIN(  23)									Float g110;
HXDLIN(  23)									int this184 = ((this181 >> 8) & 255);
HXDLIN(  23)									if ((this184 == 0)) {
HXDLIN(  23)										g110 = ((Float)0.);
            									}
            									else {
HXDLIN(  23)										g110 = (( (Float)(this184) ) / ( (Float)(255) ));
            									}
HXDLIN(  23)									Float b114;
HXDLIN(  23)									int this185 = (this181 & 255);
HXDLIN(  23)									if ((this185 == 0)) {
HXDLIN(  23)										b114 = ((Float)0.);
            									}
            									else {
HXDLIN(  23)										b114 = (( (Float)(this185) ) / ( (Float)(255) ));
            									}
HXDLIN(  23)									Float a211;
HXDLIN(  23)									int this186 = ((color5 >> 24) & 255);
HXDLIN(  23)									if ((this186 == 0)) {
HXDLIN(  23)										a211 = ((Float)0.);
            									}
            									else {
HXDLIN(  23)										a211 = (( (Float)(this186) ) / ( (Float)(255) ));
            									}
HXDLIN(  23)									Float r210;
HXDLIN(  23)									int this187 = ((color5 >> 16) & 255);
HXDLIN(  23)									if ((this187 == 0)) {
HXDLIN(  23)										r210 = ((Float)0.);
            									}
            									else {
HXDLIN(  23)										r210 = (( (Float)(this187) ) / ( (Float)(255) ));
            									}
HXDLIN(  23)									Float g210;
HXDLIN(  23)									int this188 = ((color5 >> 8) & 255);
HXDLIN(  23)									if ((this188 == 0)) {
HXDLIN(  23)										g210 = ((Float)0.);
            									}
            									else {
HXDLIN(  23)										g210 = (( (Float)(this188) ) / ( (Float)(255) ));
            									}
HXDLIN(  23)									Float b214;
HXDLIN(  23)									int this189 = (color5 & 255);
HXDLIN(  23)									if ((this189 == 0)) {
HXDLIN(  23)										b214 = ((Float)0.);
            									}
            									else {
HXDLIN(  23)										b214 = (( (Float)(this189) ) / ( (Float)(255) ));
            									}
HXDLIN(  23)									Float a310 = (a113 * (( (Float)(1) ) - a211));
HXDLIN(  23)									int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a310) + (r210 * a211))));
HXDLIN(  23)									int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a310) + (g210 * a211))));
HXDLIN(  23)									int b40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a310) + (b214 * a211))));
HXDLIN(  23)									int a42 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a211)));
HXDLIN(  23)									int blended10 = ((((a42 << 24) | (r30 << 16)) | (g30 << 8)) | b40);
HXDLIN(  23)									{
HXDLIN(  23)										int v62;
HXDLIN(  23)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)											v62 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            										}
            										else {
HXDLIN(  23)											v62 = blended10;
            										}
HXDLIN(  23)										::iterMagic::Iimg_obj::set(nextImage5->image,location10,v62);
            									}
            								}
            								else {
HXDLIN(  23)									::Dynamic this190 = nextImage5->image;
HXDLIN(  23)									int index31;
HXDLIN(  23)									if (nextImage5->useVirtualPos) {
HXDLIN(  23)										index31 = ::Std_obj::_hx_int(((((( (Float)(y32) ) - nextImage5->virtualY) * ( (Float)(nextImage5->width) )) + x32) - nextImage5->virtualX));
            									}
            									else {
HXDLIN(  23)										index31 = ::Std_obj::_hx_int(( (Float)(((y32 * nextImage5->width) + x32)) ));
            									}
HXDLIN(  23)									int v63;
HXDLIN(  23)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)										v63 = ((((((c26 >> 24) & 255) << 24) | ((c26 & 255) << 16)) | (((c26 >> 8) & 255) << 8)) | ((c26 >> 16) & 255));
            									}
            									else {
HXDLIN(  23)										v63 = c26;
            									}
HXDLIN(  23)									::iterMagic::Iimg_obj::set(this190,index31,v63);
            								}
            							}
            						}
HXDLIN(  23)						 ::pi_xy::ImageStruct v64;
HXDLIN(  23)						if (inPlace) {
HXDLIN(  23)							{
HXDLIN(  23)								int x34 = ::Std_obj::_hx_int(x);
HXDLIN(  23)								int y34 = ::Std_obj::_hx_int(y);
HXDLIN(  23)								bool forceClear5 = false;
HXDLIN(  23)								{
HXDLIN(  23)									int _g116 = 0;
HXDLIN(  23)									int _g117 = nextImage5->height;
HXDLIN(  23)									while((_g116 < _g117)){
HXDLIN(  23)										_g116 = (_g116 + 1);
HXDLIN(  23)										int dy5 = (_g116 - 1);
HXDLIN(  23)										{
HXDLIN(  23)											int _g118 = 0;
HXDLIN(  23)											int _g119 = nextImage5->width;
HXDLIN(  23)											while((_g118 < _g119)){
HXDLIN(  23)												_g118 = (_g118 + 1);
HXDLIN(  23)												int dx5 = (_g118 - 1);
HXDLIN(  23)												::Dynamic this191 = nextImage5->image;
HXDLIN(  23)												int index32;
HXDLIN(  23)												if (nextImage5->useVirtualPos) {
HXDLIN(  23)													index32 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - nextImage5->virtualY) * ( (Float)(nextImage5->width) )) + dx5) - nextImage5->virtualX));
            												}
            												else {
HXDLIN(  23)													index32 = ::Std_obj::_hx_int(( (Float)(((dy5 * nextImage5->width) + dx5)) ));
            												}
HXDLIN(  23)												int c27 = ::iterMagic::Iimg_obj::get(this191,index32);
HXDLIN(  23)												int col5;
HXDLIN(  23)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)													col5 = ((((((c27 >> 24) & 255) << 24) | ((c27 & 255) << 16)) | (((c27 >> 8) & 255) << 8)) | ((c27 >> 16) & 255));
            												}
            												else {
HXDLIN(  23)													col5 = c27;
            												}
HXDLIN(  23)												bool v65;
HXDLIN(  23)												if (nextImage5->useMask) {
HXDLIN(  23)													v65 = ::hx::IsNotNull( nextImage5->mask );
            												}
            												else {
HXDLIN(  23)													v65 = false;
            												}
HXDLIN(  23)												if (v65) {
HXDLIN(  23)													 ::pi_xy::ImageStruct this192 = nextImage5->mask;
HXDLIN(  23)													::Dynamic this193 = this192->image;
HXDLIN(  23)													int index33;
HXDLIN(  23)													if (this192->useVirtualPos) {
HXDLIN(  23)														index33 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this192->virtualY) * ( (Float)(this192->width) )) + dx5) - this192->virtualX));
            													}
            													else {
HXDLIN(  23)														index33 = ::Std_obj::_hx_int(( (Float)(((dy5 * this192->width) + dx5)) ));
            													}
HXDLIN(  23)													int c28 = ::iterMagic::Iimg_obj::get(this193,index33);
HXDLIN(  23)													int v66;
HXDLIN(  23)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)														v66 = ((((((c28 >> 24) & 255) << 24) | ((c28 & 255) << 16)) | (((c28 >> 8) & 255) << 8)) | ((c28 >> 16) & 255));
            													}
            													else {
HXDLIN(  23)														v66 = c28;
            													}
HXDLIN(  23)													int maskPixel5 = v66;
HXDLIN(  23)													int this194 = col5;
HXDLIN(  23)													if ((maskPixel5 == 0)) {
HXDLIN(  23)														col5 = this194;
            													}
            													else {
HXDLIN(  23)														Float m05;
HXDLIN(  23)														int this195 = ((maskPixel5 >> 24) & 255);
HXDLIN(  23)														if ((this195 == 0)) {
HXDLIN(  23)															m05 = ((Float)0.);
            														}
            														else {
HXDLIN(  23)															m05 = (( (Float)(this195) ) / ( (Float)(255) ));
            														}
HXDLIN(  23)														Float m15;
HXDLIN(  23)														int this196 = ((maskPixel5 >> 16) & 255);
HXDLIN(  23)														if ((this196 == 0)) {
HXDLIN(  23)															m15 = ((Float)0.);
            														}
            														else {
HXDLIN(  23)															m15 = (( (Float)(this196) ) / ( (Float)(255) ));
            														}
HXDLIN(  23)														Float m25;
HXDLIN(  23)														int this197 = ((maskPixel5 >> 8) & 255);
HXDLIN(  23)														if ((this197 == 0)) {
HXDLIN(  23)															m25 = ((Float)0.);
            														}
            														else {
HXDLIN(  23)															m25 = (( (Float)(this197) ) / ( (Float)(255) ));
            														}
HXDLIN(  23)														Float m35;
HXDLIN(  23)														int this198 = (maskPixel5 & 255);
HXDLIN(  23)														if ((this198 == 0)) {
HXDLIN(  23)															m35 = ((Float)0.);
            														}
            														else {
HXDLIN(  23)															m35 = (( (Float)(this198) ) / ( (Float)(255) ));
            														}
HXDLIN(  23)														int ch05 = ::Std_obj::_hx_int(((((Float)1.) - m05) * ( (Float)(((this194 >> 24) & 255)) )));
HXDLIN(  23)														int ch15 = ::Std_obj::_hx_int(((((Float)1.) - m15) * ( (Float)(((this194 >> 16) & 255)) )));
HXDLIN(  23)														int ch25 = ::Std_obj::_hx_int(((((Float)1.) - m25) * ( (Float)(((this194 >> 8) & 255)) )));
HXDLIN(  23)														int ch35 = ::Std_obj::_hx_int(((((Float)1.) - m35) * ( (Float)((this194 & 255)) )));
HXDLIN(  23)														col5 = ((((::Math_obj::round((( (Float)(ch05) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch15) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch25) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch35) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  23)												if ((col5 != 0)) {
HXDLIN(  23)													int x35 = (x34 + dx5);
HXDLIN(  23)													int y35 = (y34 + dy5);
HXDLIN(  23)													int c29 = col5;
HXDLIN(  23)													bool v67;
HXDLIN(  23)													if ((((c29 >> 24) & 255) < 254)) {
HXDLIN(  23)														v67 = this176->transparent;
            													}
            													else {
HXDLIN(  23)														v67 = false;
            													}
HXDLIN(  23)													if (v67) {
HXDLIN(  23)														int location11;
HXDLIN(  23)														if (this176->useVirtualPos) {
HXDLIN(  23)															location11 = ::Std_obj::_hx_int(((((( (Float)(y35) ) - this176->virtualY) * ( (Float)(this176->width) )) + x35) - this176->virtualX));
            														}
            														else {
HXDLIN(  23)															location11 = ::Std_obj::_hx_int(( (Float)(((y35 * this176->width) + x35)) ));
            														}
HXDLIN(  23)														int this199 = ::iterMagic::Iimg_obj::get(this176->image,location11);
HXDLIN(  23)														int this200;
HXDLIN(  23)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)															this200 = ((((((this199 >> 24) & 255) << 24) | ((this199 & 255) << 16)) | (((this199 >> 8) & 255) << 8)) | ((this199 >> 16) & 255));
            														}
            														else {
HXDLIN(  23)															this200 = this199;
            														}
HXDLIN(  23)														Float a114;
HXDLIN(  23)														int this201 = ((this200 >> 24) & 255);
HXDLIN(  23)														if ((this201 == 0)) {
HXDLIN(  23)															a114 = ((Float)0.);
            														}
            														else {
HXDLIN(  23)															a114 = (( (Float)(this201) ) / ( (Float)(255) ));
            														}
HXDLIN(  23)														Float r111;
HXDLIN(  23)														int this202 = ((this200 >> 16) & 255);
HXDLIN(  23)														if ((this202 == 0)) {
HXDLIN(  23)															r111 = ((Float)0.);
            														}
            														else {
HXDLIN(  23)															r111 = (( (Float)(this202) ) / ( (Float)(255) ));
            														}
HXDLIN(  23)														Float g111;
HXDLIN(  23)														int this203 = ((this200 >> 8) & 255);
HXDLIN(  23)														if ((this203 == 0)) {
HXDLIN(  23)															g111 = ((Float)0.);
            														}
            														else {
HXDLIN(  23)															g111 = (( (Float)(this203) ) / ( (Float)(255) ));
            														}
HXDLIN(  23)														Float b115;
HXDLIN(  23)														int this204 = (this200 & 255);
HXDLIN(  23)														if ((this204 == 0)) {
HXDLIN(  23)															b115 = ((Float)0.);
            														}
            														else {
HXDLIN(  23)															b115 = (( (Float)(this204) ) / ( (Float)(255) ));
            														}
HXDLIN(  23)														Float a212;
HXDLIN(  23)														int this205 = ((col5 >> 24) & 255);
HXDLIN(  23)														if ((this205 == 0)) {
HXDLIN(  23)															a212 = ((Float)0.);
            														}
            														else {
HXDLIN(  23)															a212 = (( (Float)(this205) ) / ( (Float)(255) ));
            														}
HXDLIN(  23)														Float r211;
HXDLIN(  23)														int this206 = ((col5 >> 16) & 255);
HXDLIN(  23)														if ((this206 == 0)) {
HXDLIN(  23)															r211 = ((Float)0.);
            														}
            														else {
HXDLIN(  23)															r211 = (( (Float)(this206) ) / ( (Float)(255) ));
            														}
HXDLIN(  23)														Float g211;
HXDLIN(  23)														int this207 = ((col5 >> 8) & 255);
HXDLIN(  23)														if ((this207 == 0)) {
HXDLIN(  23)															g211 = ((Float)0.);
            														}
            														else {
HXDLIN(  23)															g211 = (( (Float)(this207) ) / ( (Float)(255) ));
            														}
HXDLIN(  23)														Float b215;
HXDLIN(  23)														int this208 = (col5 & 255);
HXDLIN(  23)														if ((this208 == 0)) {
HXDLIN(  23)															b215 = ((Float)0.);
            														}
            														else {
HXDLIN(  23)															b215 = (( (Float)(this208) ) / ( (Float)(255) ));
            														}
HXDLIN(  23)														Float a311 = (a114 * (( (Float)(1) ) - a212));
HXDLIN(  23)														int r31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r111 * a311) + (r211 * a212))));
HXDLIN(  23)														int g31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g111 * a311) + (g211 * a212))));
HXDLIN(  23)														int b41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a311) + (b215 * a212))));
HXDLIN(  23)														int a43 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a212)));
HXDLIN(  23)														int blended11 = ((((a43 << 24) | (r31 << 16)) | (g31 << 8)) | b41);
HXDLIN(  23)														{
HXDLIN(  23)															int v68;
HXDLIN(  23)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)																v68 = ((((((blended11 >> 24) & 255) << 24) | ((blended11 & 255) << 16)) | (((blended11 >> 8) & 255) << 8)) | ((blended11 >> 16) & 255));
            															}
            															else {
HXDLIN(  23)																v68 = blended11;
            															}
HXDLIN(  23)															::iterMagic::Iimg_obj::set(this176->image,location11,v68);
            														}
            													}
            													else {
HXDLIN(  23)														::Dynamic this209 = this176->image;
HXDLIN(  23)														int index34;
HXDLIN(  23)														if (this176->useVirtualPos) {
HXDLIN(  23)															index34 = ::Std_obj::_hx_int(((((( (Float)(y35) ) - this176->virtualY) * ( (Float)(this176->width) )) + x35) - this176->virtualX));
            														}
            														else {
HXDLIN(  23)															index34 = ::Std_obj::_hx_int(( (Float)(((y35 * this176->width) + x35)) ));
            														}
HXDLIN(  23)														int v69;
HXDLIN(  23)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)															v69 = ((((((c29 >> 24) & 255) << 24) | ((c29 & 255) << 16)) | (((c29 >> 8) & 255) << 8)) | ((c29 >> 16) & 255));
            														}
            														else {
HXDLIN(  23)															v69 = c29;
            														}
HXDLIN(  23)														::iterMagic::Iimg_obj::set(this209,index34,v69);
            													}
            												}
            												else {
HXDLIN(  23)													if (forceClear5) {
HXDLIN(  23)														::Dynamic this210 = this176->image;
HXDLIN(  23)														int x36 = (x34 + dx5);
HXDLIN(  23)														int y36 = (y34 + dy5);
HXDLIN(  23)														int index35;
HXDLIN(  23)														if (this176->useVirtualPos) {
HXDLIN(  23)															index35 = ::Std_obj::_hx_int(((((( (Float)(y36) ) - this176->virtualY) * ( (Float)(this176->width) )) + x36) - this176->virtualX));
            														}
            														else {
HXDLIN(  23)															index35 = ::Std_obj::_hx_int(( (Float)(((y36 * this176->width) + x36)) ));
            														}
HXDLIN(  23)														::iterMagic::Iimg_obj::set(this210,index35,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  23)							bool v70;
HXDLIN(  23)							if (::hx::IsNotNull( this176->mask )) {
HXDLIN(  23)								v70 = includeMask;
            							}
            							else {
HXDLIN(  23)								v70 = false;
            							}
HXDLIN(  23)							if (v70) {
HXDLIN(  23)								 ::pi_xy::ImageStruct this211 = this176->mask;
HXDLIN(  23)								Float w12 = ( (Float)(this176->width) );
HXDLIN(  23)								Float h6 = ( (Float)(this176->height) );
HXDLIN(  23)								bool transparent6 = this176->mask->transparent;
HXDLIN(  23)								Float r_x6 = x;
HXDLIN(  23)								Float r_y6 = y;
HXDLIN(  23)								Float r_w6 = w12;
HXDLIN(  23)								Float r_h6 = h6;
HXDLIN(  23)								int xmax6 = ::Std_obj::_hx_int(((r_x6 + r_w6) + 1));
HXDLIN(  23)								int ymax6 = ::Std_obj::_hx_int(((r_y6 + r_h6) + 1));
HXDLIN(  23)								int ii_min12 = ::Std_obj::_hx_int(r_x6);
HXDLIN(  23)								int ii_max12 = xmax6;
HXDLIN(  23)								int xRange__start6 = ii_min12;
HXDLIN(  23)								int xRange__max6 = ii_max12;
HXDLIN(  23)								int ii_min13 = ::Std_obj::_hx_int(r_y6);
HXDLIN(  23)								int ii_max13 = ymax6;
HXDLIN(  23)								int yRange__start6 = ii_min13;
HXDLIN(  23)								int yRange__max6 = ii_max13;
HXDLIN(  23)								int range_x6 = xRange__start6;
HXDLIN(  23)								int range_y6 = (yRange__start6 - 1);
HXDLIN(  23)								int range_xReset6 = range_x6;
HXDLIN(  23)								int range_yReset6 = range_y6;
HXDLIN(  23)								int range_xMax6 = (xRange__max6 - 2);
HXDLIN(  23)								int range_yMax6 = (yRange__max6 - 2);
HXDLIN(  23)								int _this_min6 = 0;
HXDLIN(  23)								int _this_max6 = ::Std_obj::_hx_int(( (Float)(((xRange__max6 - xRange__start6) * (yRange__max6 - yRange__start6))) ));
HXDLIN(  23)								int width6 = ::Std_obj::_hx_int(w12);
HXDLIN(  23)								int height6 = ::Std_obj::_hx_int(h6);
HXDLIN(  23)								 ::Dynamic imageType6 = null();
HXDLIN(  23)								 ::pi_xy::ImageStruct this212 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  23)								if (::hx::IsNull( imageType6 )) {
HXLINE(  54)									imageType6 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE(  23)								::Dynamic v71;
HXDLIN(  23)								switch((int)(( (int)(imageType6) ))){
            									case (int)0: {
HXDLIN(  23)										 ::iterMagic::BytesImg byt6 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  23)										 ::iterMagic::BytesImg b42 = byt6;
HXDLIN(  23)										{
HXDLIN(  23)											b42->width = width6;
HXDLIN(  23)											b42->height = height6;
HXDLIN(  23)											b42->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN(  23)											b42->data = ::haxe::io::Bytes_obj::alloc((b42->length * 4));
HXDLIN(  23)											{
HXDLIN(  23)												int len12 = b42->length;
HXDLIN(  23)												int w13 = 0;
HXDLIN(  23)												{
HXDLIN(  23)													int _g120 = 0;
HXDLIN(  23)													int _g121 = b42->height;
HXDLIN(  23)													while((_g120 < _g121)){
HXDLIN(  23)														_g120 = (_g120 + 1);
HXDLIN(  23)														int y37 = (_g120 - 1);
HXDLIN(  23)														{
HXDLIN(  23)															int _g122 = 0;
HXDLIN(  23)															int _g123 = b42->width;
HXDLIN(  23)															while((_g122 < _g123)){
HXDLIN(  23)																_g122 = (_g122 + 1);
HXDLIN(  23)																int x37 = (_g122 - 1);
HXDLIN(  23)																{
HXDLIN(  23)																	w13 = (w13 + 1);
HXDLIN(  23)																	b42->data->b[(w13 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  23)																{
HXDLIN(  23)																	w13 = (w13 + 1);
HXDLIN(  23)																	b42->data->b[(w13 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  23)																{
HXDLIN(  23)																	w13 = (w13 + 1);
HXDLIN(  23)																	b42->data->b[(w13 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  23)																{
HXDLIN(  23)																	w13 = (w13 + 1);
HXDLIN(  23)																	b42->data->b[(w13 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  23)										v71 = b42;
            									}
            									break;
            									case (int)1: {
HXDLIN(  23)										 ::iterMagic::ArrIntImg arrI6 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  23)										 ::iterMagic::ArrIntImg a44 = arrI6;
HXDLIN(  23)										{
HXDLIN(  23)											a44->width = width6;
HXDLIN(  23)											a44->height = height6;
HXDLIN(  23)											a44->data = ::Array_obj< int >::__new(0);
HXDLIN(  23)											a44->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN(  23)											{
HXDLIN(  23)												int _g124 = 0;
HXDLIN(  23)												int _g125 = a44->length;
HXDLIN(  23)												while((_g124 < _g125)){
HXDLIN(  23)													_g124 = (_g124 + 1);
HXDLIN(  23)													int i48 = (_g124 - 1);
HXDLIN(  23)													a44->data[i48] = 0;
            												}
            											}
            										}
HXDLIN(  23)										v71 = a44;
            									}
            									break;
            									case (int)2: {
HXDLIN(  23)										 ::iterMagic::U32ArrImg u32a6 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  23)										 ::iterMagic::U32ArrImg b43 = u32a6;
HXDLIN(  23)										{
HXDLIN(  23)											b43->width = width6;
HXDLIN(  23)											b43->height = height6;
HXDLIN(  23)											b43->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN(  23)											int size6 = (b43->length * 4);
HXDLIN(  23)											b43->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size6),0,size6);
HXDLIN(  23)											{
HXDLIN(  23)												int _g126 = 0;
HXDLIN(  23)												int _g127 = b43->length;
HXDLIN(  23)												while((_g126 < _g127)){
HXDLIN(  23)													_g126 = (_g126 + 1);
HXDLIN(  23)													int i49 = (_g126 - 1);
HXDLIN(  23)													{
HXDLIN(  23)														 ::haxe::io::ArrayBufferViewImpl this213 = b43->data;
HXDLIN(  23)														bool v72;
HXDLIN(  23)														if ((i49 >= 0)) {
HXDLIN(  23)															v72 = (i49 < (this213->byteLength >> 2));
            														}
            														else {
HXDLIN(  23)															v72 = false;
            														}
HXDLIN(  23)														if (v72) {
HXDLIN(  23)															 ::haxe::io::Bytes _this6 = this213->bytes;
HXDLIN(  23)															int pos6 = ((i49 << 2) + this213->byteOffset);
HXDLIN(  23)															_this6->b[pos6] = ( (unsigned char)(0) );
HXDLIN(  23)															_this6->b[(pos6 + 1)] = ( (unsigned char)(0) );
HXDLIN(  23)															_this6->b[(pos6 + 2)] = ( (unsigned char)(0) );
HXDLIN(  23)															_this6->b[(pos6 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN(  23)										v71 = b43;
            									}
            									break;
            									case (int)3: {
HXDLIN(  23)										 ::iterMagic::VecIntImg vec6 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  23)										 ::iterMagic::VecIntImg v73 = vec6;
HXDLIN(  23)										{
HXDLIN(  23)											v73->width = width6;
HXDLIN(  23)											v73->height = height6;
HXDLIN(  23)											v73->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN(  23)											v73->data = ::Array_obj< int >::__new(v73->length);
HXDLIN(  23)											{
HXDLIN(  23)												int _g128 = 0;
HXDLIN(  23)												int _g129 = v73->length;
HXDLIN(  23)												while((_g128 < _g129)){
HXDLIN(  23)													_g128 = (_g128 + 1);
HXDLIN(  23)													int i50 = (_g128 - 1);
HXDLIN(  23)													v73->data->__unsafe_set(i50,0);
            												}
            											}
            										}
HXDLIN(  23)										v71 = v73;
            									}
            									break;
            									case (int)4: {
HXDLIN(  23)										 ::iterMagic::StackIntImg sInt6 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  23)										 ::iterMagic::StackIntImg b44 = sInt6;
HXDLIN(  23)										{
HXDLIN(  23)											b44->width = width6;
HXDLIN(  23)											b44->height = height6;
HXDLIN(  23)											b44->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN(  23)											b44->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  23)											{
HXDLIN(  23)												int len13 = b44->length;
HXDLIN(  23)												 ::haxe::ds::GenericStack_Int d6 = b44->data;
HXDLIN(  23)												if (::hx::IsNull( d6->head )) {
HXDLIN(  23)													int _g130 = 0;
HXDLIN(  23)													int _g131 = len13;
HXDLIN(  23)													while((_g130 < _g131)){
HXDLIN(  23)														_g130 = (_g130 + 1);
HXDLIN(  23)														int i51 = (_g130 - 1);
HXDLIN(  23)														d6->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d6->head);
            													}
            												}
            												else {
HXDLIN(  23)													int _g132 = 0;
HXDLIN(  23)													int _g133 = len13;
HXDLIN(  23)													while((_g132 < _g133)){
HXDLIN(  23)														_g132 = (_g132 + 1);
HXDLIN(  23)														int i52 = (_g132 - 1);
HXDLIN(  23)														{
HXDLIN(  23)															 ::haxe::ds::GenericCell_Int l6 = b44->data->head;
HXDLIN(  23)															 ::haxe::ds::GenericCell_Int prev6 = null();
HXDLIN(  23)															{
HXDLIN(  23)																int _g134 = 0;
HXDLIN(  23)																int _g135 = i52;
HXDLIN(  23)																while((_g134 < _g135)){
HXDLIN(  23)																	_g134 = (_g134 + 1);
HXDLIN(  23)																	int i53 = (_g134 - 1);
HXLINE( 345)																	prev6 = l6;
HXLINE( 346)																	l6 = l6->next;
            																}
            															}
HXLINE(  23)															if (::hx::IsNull( prev6 )) {
HXDLIN(  23)																b44->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN(  23)																l6 = null();
            															}
            															else {
HXDLIN(  23)																prev6->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN(  23)																l6 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  23)										v71 = b44;
            									}
            									break;
            								}
HXDLIN(  23)								this212->image = v71;
HXDLIN(  23)								this212->width = width6;
HXDLIN(  23)								this212->height = height6;
HXDLIN(  23)								this212->imageType = ( (int)(imageType6) );
HXDLIN(  23)								 ::pi_xy::ImageStruct nextImage6 = this212;
HXDLIN(  23)								nextImage6->transparent = transparent6;
HXDLIN(  23)								while((_this_min6 < _this_max6)){
HXDLIN(  23)									_this_min6 = (_this_min6 + 1);
HXDLIN(  23)									int i54 = (_this_min6 - 1);
HXDLIN(  23)									if ((range_y6 > range_yMax6)) {
HXDLIN(  23)										range_y6 = range_yReset6;
HXDLIN(  23)										range_x6 = (range_x6 + 1);
            									}
HXDLIN(  23)									range_y6 = (range_y6 + 1);
HXDLIN(  23)									int i55 = i54;
HXDLIN(  23)									{
HXDLIN(  23)										int x38 = range_x6;
HXDLIN(  23)										int y38 = range_y6;
HXDLIN(  23)										int x39 = range_x6;
HXDLIN(  23)										int y39 = (range_yMax6 - range_y6);
HXDLIN(  23)										::Dynamic this214 = this211->image;
HXDLIN(  23)										int index36;
HXDLIN(  23)										if (this211->useVirtualPos) {
HXDLIN(  23)											index36 = ::Std_obj::_hx_int(((((( (Float)(y39) ) - this211->virtualY) * ( (Float)(this211->width) )) + x39) - this211->virtualX));
            										}
            										else {
HXDLIN(  23)											index36 = ::Std_obj::_hx_int(( (Float)(((y39 * this211->width) + x39)) ));
            										}
HXDLIN(  23)										int c30 = ::iterMagic::Iimg_obj::get(this214,index36);
HXDLIN(  23)										int color6;
HXDLIN(  23)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)											color6 = ((((((c30 >> 24) & 255) << 24) | ((c30 & 255) << 16)) | (((c30 >> 8) & 255) << 8)) | ((c30 >> 16) & 255));
            										}
            										else {
HXDLIN(  23)											color6 = c30;
            										}
HXDLIN(  23)										int c31 = color6;
HXDLIN(  23)										bool v74;
HXDLIN(  23)										if ((((c31 >> 24) & 255) < 254)) {
HXDLIN(  23)											v74 = nextImage6->transparent;
            										}
            										else {
HXDLIN(  23)											v74 = false;
            										}
HXDLIN(  23)										if (v74) {
HXDLIN(  23)											int location12;
HXDLIN(  23)											if (nextImage6->useVirtualPos) {
HXDLIN(  23)												location12 = ::Std_obj::_hx_int(((((( (Float)(y38) ) - nextImage6->virtualY) * ( (Float)(nextImage6->width) )) + x38) - nextImage6->virtualX));
            											}
            											else {
HXDLIN(  23)												location12 = ::Std_obj::_hx_int(( (Float)(((y38 * nextImage6->width) + x38)) ));
            											}
HXDLIN(  23)											int this215 = ::iterMagic::Iimg_obj::get(nextImage6->image,location12);
HXDLIN(  23)											int this216;
HXDLIN(  23)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)												this216 = ((((((this215 >> 24) & 255) << 24) | ((this215 & 255) << 16)) | (((this215 >> 8) & 255) << 8)) | ((this215 >> 16) & 255));
            											}
            											else {
HXDLIN(  23)												this216 = this215;
            											}
HXDLIN(  23)											Float a115;
HXDLIN(  23)											int this217 = ((this216 >> 24) & 255);
HXDLIN(  23)											if ((this217 == 0)) {
HXDLIN(  23)												a115 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												a115 = (( (Float)(this217) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float r112;
HXDLIN(  23)											int this218 = ((this216 >> 16) & 255);
HXDLIN(  23)											if ((this218 == 0)) {
HXDLIN(  23)												r112 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												r112 = (( (Float)(this218) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float g112;
HXDLIN(  23)											int this219 = ((this216 >> 8) & 255);
HXDLIN(  23)											if ((this219 == 0)) {
HXDLIN(  23)												g112 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												g112 = (( (Float)(this219) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float b116;
HXDLIN(  23)											int this220 = (this216 & 255);
HXDLIN(  23)											if ((this220 == 0)) {
HXDLIN(  23)												b116 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												b116 = (( (Float)(this220) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float a213;
HXDLIN(  23)											int this221 = ((color6 >> 24) & 255);
HXDLIN(  23)											if ((this221 == 0)) {
HXDLIN(  23)												a213 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												a213 = (( (Float)(this221) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float r212;
HXDLIN(  23)											int this222 = ((color6 >> 16) & 255);
HXDLIN(  23)											if ((this222 == 0)) {
HXDLIN(  23)												r212 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												r212 = (( (Float)(this222) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float g212;
HXDLIN(  23)											int this223 = ((color6 >> 8) & 255);
HXDLIN(  23)											if ((this223 == 0)) {
HXDLIN(  23)												g212 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												g212 = (( (Float)(this223) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float b216;
HXDLIN(  23)											int this224 = (color6 & 255);
HXDLIN(  23)											if ((this224 == 0)) {
HXDLIN(  23)												b216 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												b216 = (( (Float)(this224) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float a312 = (a115 * (( (Float)(1) ) - a213));
HXDLIN(  23)											int r32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r112 * a312) + (r212 * a213))));
HXDLIN(  23)											int g32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g112 * a312) + (g212 * a213))));
HXDLIN(  23)											int b45 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a312) + (b216 * a213))));
HXDLIN(  23)											int a45 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a213)));
HXDLIN(  23)											int blended12 = ((((a45 << 24) | (r32 << 16)) | (g32 << 8)) | b45);
HXDLIN(  23)											{
HXDLIN(  23)												int v75;
HXDLIN(  23)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)													v75 = ((((((blended12 >> 24) & 255) << 24) | ((blended12 & 255) << 16)) | (((blended12 >> 8) & 255) << 8)) | ((blended12 >> 16) & 255));
            												}
            												else {
HXDLIN(  23)													v75 = blended12;
            												}
HXDLIN(  23)												::iterMagic::Iimg_obj::set(nextImage6->image,location12,v75);
            											}
            										}
            										else {
HXDLIN(  23)											::Dynamic this225 = nextImage6->image;
HXDLIN(  23)											int index37;
HXDLIN(  23)											if (nextImage6->useVirtualPos) {
HXDLIN(  23)												index37 = ::Std_obj::_hx_int(((((( (Float)(y38) ) - nextImage6->virtualY) * ( (Float)(nextImage6->width) )) + x38) - nextImage6->virtualX));
            											}
            											else {
HXDLIN(  23)												index37 = ::Std_obj::_hx_int(( (Float)(((y38 * nextImage6->width) + x38)) ));
            											}
HXDLIN(  23)											int v76;
HXDLIN(  23)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)												v76 = ((((((c31 >> 24) & 255) << 24) | ((c31 & 255) << 16)) | (((c31 >> 8) & 255) << 8)) | ((c31 >> 16) & 255));
            											}
            											else {
HXDLIN(  23)												v76 = c31;
            											}
HXDLIN(  23)											::iterMagic::Iimg_obj::set(this225,index37,v76);
            										}
            									}
            								}
HXDLIN(  23)								 ::pi_xy::ImageStruct v77;
HXDLIN(  23)								if (inPlace) {
HXDLIN(  23)									{
HXDLIN(  23)										int x40 = ::Std_obj::_hx_int(x);
HXDLIN(  23)										int y40 = ::Std_obj::_hx_int(y);
HXDLIN(  23)										bool forceClear6 = false;
HXDLIN(  23)										{
HXDLIN(  23)											int _g136 = 0;
HXDLIN(  23)											int _g137 = nextImage6->height;
HXDLIN(  23)											while((_g136 < _g137)){
HXDLIN(  23)												_g136 = (_g136 + 1);
HXDLIN(  23)												int dy6 = (_g136 - 1);
HXDLIN(  23)												{
HXDLIN(  23)													int _g138 = 0;
HXDLIN(  23)													int _g139 = nextImage6->width;
HXDLIN(  23)													while((_g138 < _g139)){
HXDLIN(  23)														_g138 = (_g138 + 1);
HXDLIN(  23)														int dx6 = (_g138 - 1);
HXDLIN(  23)														::Dynamic this226 = nextImage6->image;
HXDLIN(  23)														int index38;
HXDLIN(  23)														if (nextImage6->useVirtualPos) {
HXDLIN(  23)															index38 = ::Std_obj::_hx_int(((((( (Float)(dy6) ) - nextImage6->virtualY) * ( (Float)(nextImage6->width) )) + dx6) - nextImage6->virtualX));
            														}
            														else {
HXDLIN(  23)															index38 = ::Std_obj::_hx_int(( (Float)(((dy6 * nextImage6->width) + dx6)) ));
            														}
HXDLIN(  23)														int c32 = ::iterMagic::Iimg_obj::get(this226,index38);
HXDLIN(  23)														int col6;
HXDLIN(  23)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)															col6 = ((((((c32 >> 24) & 255) << 24) | ((c32 & 255) << 16)) | (((c32 >> 8) & 255) << 8)) | ((c32 >> 16) & 255));
            														}
            														else {
HXDLIN(  23)															col6 = c32;
            														}
HXDLIN(  23)														bool v78;
HXDLIN(  23)														if (nextImage6->useMask) {
HXDLIN(  23)															v78 = ::hx::IsNotNull( nextImage6->mask );
            														}
            														else {
HXDLIN(  23)															v78 = false;
            														}
HXDLIN(  23)														if (v78) {
HXDLIN(  23)															 ::pi_xy::ImageStruct this227 = nextImage6->mask;
HXDLIN(  23)															::Dynamic this228 = this227->image;
HXDLIN(  23)															int index39;
HXDLIN(  23)															if (this227->useVirtualPos) {
HXDLIN(  23)																index39 = ::Std_obj::_hx_int(((((( (Float)(dy6) ) - this227->virtualY) * ( (Float)(this227->width) )) + dx6) - this227->virtualX));
            															}
            															else {
HXDLIN(  23)																index39 = ::Std_obj::_hx_int(( (Float)(((dy6 * this227->width) + dx6)) ));
            															}
HXDLIN(  23)															int c33 = ::iterMagic::Iimg_obj::get(this228,index39);
HXDLIN(  23)															int v79;
HXDLIN(  23)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)																v79 = ((((((c33 >> 24) & 255) << 24) | ((c33 & 255) << 16)) | (((c33 >> 8) & 255) << 8)) | ((c33 >> 16) & 255));
            															}
            															else {
HXDLIN(  23)																v79 = c33;
            															}
HXDLIN(  23)															int maskPixel6 = v79;
HXDLIN(  23)															int this229 = col6;
HXDLIN(  23)															if ((maskPixel6 == 0)) {
HXDLIN(  23)																col6 = this229;
            															}
            															else {
HXDLIN(  23)																Float m06;
HXDLIN(  23)																int this230 = ((maskPixel6 >> 24) & 255);
HXDLIN(  23)																if ((this230 == 0)) {
HXDLIN(  23)																	m06 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	m06 = (( (Float)(this230) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float m16;
HXDLIN(  23)																int this231 = ((maskPixel6 >> 16) & 255);
HXDLIN(  23)																if ((this231 == 0)) {
HXDLIN(  23)																	m16 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	m16 = (( (Float)(this231) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float m26;
HXDLIN(  23)																int this232 = ((maskPixel6 >> 8) & 255);
HXDLIN(  23)																if ((this232 == 0)) {
HXDLIN(  23)																	m26 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	m26 = (( (Float)(this232) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float m36;
HXDLIN(  23)																int this233 = (maskPixel6 & 255);
HXDLIN(  23)																if ((this233 == 0)) {
HXDLIN(  23)																	m36 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	m36 = (( (Float)(this233) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																int ch06 = ::Std_obj::_hx_int(((((Float)1.) - m06) * ( (Float)(((this229 >> 24) & 255)) )));
HXDLIN(  23)																int ch16 = ::Std_obj::_hx_int(((((Float)1.) - m16) * ( (Float)(((this229 >> 16) & 255)) )));
HXDLIN(  23)																int ch26 = ::Std_obj::_hx_int(((((Float)1.) - m26) * ( (Float)(((this229 >> 8) & 255)) )));
HXDLIN(  23)																int ch36 = ::Std_obj::_hx_int(((((Float)1.) - m36) * ( (Float)((this229 & 255)) )));
HXDLIN(  23)																col6 = ((((::Math_obj::round((( (Float)(ch06) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch16) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch26) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch36) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  23)														if ((col6 != 0)) {
HXDLIN(  23)															int x41 = (x40 + dx6);
HXDLIN(  23)															int y41 = (y40 + dy6);
HXDLIN(  23)															int c34 = col6;
HXDLIN(  23)															bool v80;
HXDLIN(  23)															if ((((c34 >> 24) & 255) < 254)) {
HXDLIN(  23)																v80 = this211->transparent;
            															}
            															else {
HXDLIN(  23)																v80 = false;
            															}
HXDLIN(  23)															if (v80) {
HXDLIN(  23)																int location13;
HXDLIN(  23)																if (this211->useVirtualPos) {
HXDLIN(  23)																	location13 = ::Std_obj::_hx_int(((((( (Float)(y41) ) - this211->virtualY) * ( (Float)(this211->width) )) + x41) - this211->virtualX));
            																}
            																else {
HXDLIN(  23)																	location13 = ::Std_obj::_hx_int(( (Float)(((y41 * this211->width) + x41)) ));
            																}
HXDLIN(  23)																int this234 = ::iterMagic::Iimg_obj::get(this211->image,location13);
HXDLIN(  23)																int this235;
HXDLIN(  23)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)																	this235 = ((((((this234 >> 24) & 255) << 24) | ((this234 & 255) << 16)) | (((this234 >> 8) & 255) << 8)) | ((this234 >> 16) & 255));
            																}
            																else {
HXDLIN(  23)																	this235 = this234;
            																}
HXDLIN(  23)																Float a116;
HXDLIN(  23)																int this236 = ((this235 >> 24) & 255);
HXDLIN(  23)																if ((this236 == 0)) {
HXDLIN(  23)																	a116 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	a116 = (( (Float)(this236) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float r113;
HXDLIN(  23)																int this237 = ((this235 >> 16) & 255);
HXDLIN(  23)																if ((this237 == 0)) {
HXDLIN(  23)																	r113 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	r113 = (( (Float)(this237) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float g113;
HXDLIN(  23)																int this238 = ((this235 >> 8) & 255);
HXDLIN(  23)																if ((this238 == 0)) {
HXDLIN(  23)																	g113 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	g113 = (( (Float)(this238) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float b117;
HXDLIN(  23)																int this239 = (this235 & 255);
HXDLIN(  23)																if ((this239 == 0)) {
HXDLIN(  23)																	b117 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	b117 = (( (Float)(this239) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float a214;
HXDLIN(  23)																int this240 = ((col6 >> 24) & 255);
HXDLIN(  23)																if ((this240 == 0)) {
HXDLIN(  23)																	a214 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	a214 = (( (Float)(this240) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float r213;
HXDLIN(  23)																int this241 = ((col6 >> 16) & 255);
HXDLIN(  23)																if ((this241 == 0)) {
HXDLIN(  23)																	r213 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	r213 = (( (Float)(this241) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float g213;
HXDLIN(  23)																int this242 = ((col6 >> 8) & 255);
HXDLIN(  23)																if ((this242 == 0)) {
HXDLIN(  23)																	g213 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	g213 = (( (Float)(this242) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float b217;
HXDLIN(  23)																int this243 = (col6 & 255);
HXDLIN(  23)																if ((this243 == 0)) {
HXDLIN(  23)																	b217 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	b217 = (( (Float)(this243) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float a313 = (a116 * (( (Float)(1) ) - a214));
HXDLIN(  23)																int r33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r113 * a313) + (r213 * a214))));
HXDLIN(  23)																int g33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g113 * a313) + (g213 * a214))));
HXDLIN(  23)																int b46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b117 * a313) + (b217 * a214))));
HXDLIN(  23)																int a46 = ::Std_obj::_hx_int((( (Float)(255) ) * (a313 + a214)));
HXDLIN(  23)																int blended13 = ((((a46 << 24) | (r33 << 16)) | (g33 << 8)) | b46);
HXDLIN(  23)																{
HXDLIN(  23)																	int v81;
HXDLIN(  23)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)																		v81 = ((((((blended13 >> 24) & 255) << 24) | ((blended13 & 255) << 16)) | (((blended13 >> 8) & 255) << 8)) | ((blended13 >> 16) & 255));
            																	}
            																	else {
HXDLIN(  23)																		v81 = blended13;
            																	}
HXDLIN(  23)																	::iterMagic::Iimg_obj::set(this211->image,location13,v81);
            																}
            															}
            															else {
HXDLIN(  23)																::Dynamic this244 = this211->image;
HXDLIN(  23)																int index40;
HXDLIN(  23)																if (this211->useVirtualPos) {
HXDLIN(  23)																	index40 = ::Std_obj::_hx_int(((((( (Float)(y41) ) - this211->virtualY) * ( (Float)(this211->width) )) + x41) - this211->virtualX));
            																}
            																else {
HXDLIN(  23)																	index40 = ::Std_obj::_hx_int(( (Float)(((y41 * this211->width) + x41)) ));
            																}
HXDLIN(  23)																int v82;
HXDLIN(  23)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)																	v82 = ((((((c34 >> 24) & 255) << 24) | ((c34 & 255) << 16)) | (((c34 >> 8) & 255) << 8)) | ((c34 >> 16) & 255));
            																}
            																else {
HXDLIN(  23)																	v82 = c34;
            																}
HXDLIN(  23)																::iterMagic::Iimg_obj::set(this244,index40,v82);
            															}
            														}
            														else {
HXDLIN(  23)															if (forceClear6) {
HXDLIN(  23)																::Dynamic this245 = this211->image;
HXDLIN(  23)																int x42 = (x40 + dx6);
HXDLIN(  23)																int y42 = (y40 + dy6);
HXDLIN(  23)																int index41;
HXDLIN(  23)																if (this211->useVirtualPos) {
HXDLIN(  23)																	index41 = ::Std_obj::_hx_int(((((( (Float)(y42) ) - this211->virtualY) * ( (Float)(this211->width) )) + x42) - this211->virtualX));
            																}
            																else {
HXDLIN(  23)																	index41 = ::Std_obj::_hx_int(( (Float)(((y42 * this211->width) + x42)) ));
            																}
HXDLIN(  23)																::iterMagic::Iimg_obj::set(this245,index41,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  23)									bool v83;
HXDLIN(  23)									if (::hx::IsNotNull( this211->mask )) {
HXDLIN(  23)										v83 = includeMask;
            									}
            									else {
HXDLIN(  23)										v83 = false;
            									}
HXDLIN(  23)									if (v83) {
HXDLIN(  23)										 ::pi_xy::ImageStruct v84 = ::pi_xy::imageAbstracts::_TransformImage::TransformImage_Impl__obj::flippedY(this211->mask,x,y,( (Float)(this211->width) ),( (Float)(this211->height) ),this211->mask->transparent,inPlace,includeMask);
HXDLIN(  23)										this211->useMask = true;
HXDLIN(  23)										this211->mask = v84;
            									}
HXLINE(  91)									nextImage6 = null();
HXLINE(  23)									v77 = this211;
            								}
            								else {
HXDLIN(  23)									bool v85;
HXDLIN(  23)									if (::hx::IsNotNull( this211->mask )) {
HXDLIN(  23)										v85 = includeMask;
            									}
            									else {
HXDLIN(  23)										v85 = false;
            									}
HXDLIN(  23)									if (v85) {
HXDLIN(  23)										 ::pi_xy::ImageStruct v86 = ::pi_xy::imageAbstracts::_TransformImage::TransformImage_Impl__obj::flippedY(this211->mask,x,y,( (Float)(this211->width) ),( (Float)(this211->height) ),this211->mask->transparent,inPlace,includeMask);
HXDLIN(  23)										nextImage6->useMask = true;
HXDLIN(  23)										nextImage6->mask = v86;
            									}
HXDLIN(  23)									v77 = nextImage6;
            								}
HXDLIN(  23)								this176->useMask = true;
HXDLIN(  23)								this176->mask = v77;
            							}
HXLINE(  91)							nextImage5 = null();
HXLINE(  23)							v64 = this176;
            						}
            						else {
HXDLIN(  23)							bool v87;
HXDLIN(  23)							if (::hx::IsNotNull( this176->mask )) {
HXDLIN(  23)								v87 = includeMask;
            							}
            							else {
HXDLIN(  23)								v87 = false;
            							}
HXDLIN(  23)							if (v87) {
HXDLIN(  23)								 ::pi_xy::ImageStruct this246 = this176->mask;
HXDLIN(  23)								Float w14 = ( (Float)(this176->width) );
HXDLIN(  23)								Float h7 = ( (Float)(this176->height) );
HXDLIN(  23)								bool transparent7 = this176->mask->transparent;
HXDLIN(  23)								Float r_x7 = x;
HXDLIN(  23)								Float r_y7 = y;
HXDLIN(  23)								Float r_w7 = w14;
HXDLIN(  23)								Float r_h7 = h7;
HXDLIN(  23)								int xmax7 = ::Std_obj::_hx_int(((r_x7 + r_w7) + 1));
HXDLIN(  23)								int ymax7 = ::Std_obj::_hx_int(((r_y7 + r_h7) + 1));
HXDLIN(  23)								int ii_min14 = ::Std_obj::_hx_int(r_x7);
HXDLIN(  23)								int ii_max14 = xmax7;
HXDLIN(  23)								int xRange__start7 = ii_min14;
HXDLIN(  23)								int xRange__max7 = ii_max14;
HXDLIN(  23)								int ii_min15 = ::Std_obj::_hx_int(r_y7);
HXDLIN(  23)								int ii_max15 = ymax7;
HXDLIN(  23)								int yRange__start7 = ii_min15;
HXDLIN(  23)								int yRange__max7 = ii_max15;
HXDLIN(  23)								int range_x7 = xRange__start7;
HXDLIN(  23)								int range_y7 = (yRange__start7 - 1);
HXDLIN(  23)								int range_xReset7 = range_x7;
HXDLIN(  23)								int range_yReset7 = range_y7;
HXDLIN(  23)								int range_xMax7 = (xRange__max7 - 2);
HXDLIN(  23)								int range_yMax7 = (yRange__max7 - 2);
HXDLIN(  23)								int _this_min7 = 0;
HXDLIN(  23)								int _this_max7 = ::Std_obj::_hx_int(( (Float)(((xRange__max7 - xRange__start7) * (yRange__max7 - yRange__start7))) ));
HXDLIN(  23)								int width7 = ::Std_obj::_hx_int(w14);
HXDLIN(  23)								int height7 = ::Std_obj::_hx_int(h7);
HXDLIN(  23)								 ::Dynamic imageType7 = null();
HXDLIN(  23)								 ::pi_xy::ImageStruct this247 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  23)								if (::hx::IsNull( imageType7 )) {
HXLINE(  54)									imageType7 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE(  23)								::Dynamic v88;
HXDLIN(  23)								switch((int)(( (int)(imageType7) ))){
            									case (int)0: {
HXDLIN(  23)										 ::iterMagic::BytesImg byt7 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  23)										 ::iterMagic::BytesImg b47 = byt7;
HXDLIN(  23)										{
HXDLIN(  23)											b47->width = width7;
HXDLIN(  23)											b47->height = height7;
HXDLIN(  23)											b47->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN(  23)											b47->data = ::haxe::io::Bytes_obj::alloc((b47->length * 4));
HXDLIN(  23)											{
HXDLIN(  23)												int len14 = b47->length;
HXDLIN(  23)												int w15 = 0;
HXDLIN(  23)												{
HXDLIN(  23)													int _g140 = 0;
HXDLIN(  23)													int _g141 = b47->height;
HXDLIN(  23)													while((_g140 < _g141)){
HXDLIN(  23)														_g140 = (_g140 + 1);
HXDLIN(  23)														int y43 = (_g140 - 1);
HXDLIN(  23)														{
HXDLIN(  23)															int _g142 = 0;
HXDLIN(  23)															int _g143 = b47->width;
HXDLIN(  23)															while((_g142 < _g143)){
HXDLIN(  23)																_g142 = (_g142 + 1);
HXDLIN(  23)																int x43 = (_g142 - 1);
HXDLIN(  23)																{
HXDLIN(  23)																	w15 = (w15 + 1);
HXDLIN(  23)																	b47->data->b[(w15 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  23)																{
HXDLIN(  23)																	w15 = (w15 + 1);
HXDLIN(  23)																	b47->data->b[(w15 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  23)																{
HXDLIN(  23)																	w15 = (w15 + 1);
HXDLIN(  23)																	b47->data->b[(w15 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  23)																{
HXDLIN(  23)																	w15 = (w15 + 1);
HXDLIN(  23)																	b47->data->b[(w15 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  23)										v88 = b47;
            									}
            									break;
            									case (int)1: {
HXDLIN(  23)										 ::iterMagic::ArrIntImg arrI7 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  23)										 ::iterMagic::ArrIntImg a47 = arrI7;
HXDLIN(  23)										{
HXDLIN(  23)											a47->width = width7;
HXDLIN(  23)											a47->height = height7;
HXDLIN(  23)											a47->data = ::Array_obj< int >::__new(0);
HXDLIN(  23)											a47->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN(  23)											{
HXDLIN(  23)												int _g144 = 0;
HXDLIN(  23)												int _g145 = a47->length;
HXDLIN(  23)												while((_g144 < _g145)){
HXDLIN(  23)													_g144 = (_g144 + 1);
HXDLIN(  23)													int i56 = (_g144 - 1);
HXDLIN(  23)													a47->data[i56] = 0;
            												}
            											}
            										}
HXDLIN(  23)										v88 = a47;
            									}
            									break;
            									case (int)2: {
HXDLIN(  23)										 ::iterMagic::U32ArrImg u32a7 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  23)										 ::iterMagic::U32ArrImg b48 = u32a7;
HXDLIN(  23)										{
HXDLIN(  23)											b48->width = width7;
HXDLIN(  23)											b48->height = height7;
HXDLIN(  23)											b48->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN(  23)											int size7 = (b48->length * 4);
HXDLIN(  23)											b48->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size7),0,size7);
HXDLIN(  23)											{
HXDLIN(  23)												int _g146 = 0;
HXDLIN(  23)												int _g147 = b48->length;
HXDLIN(  23)												while((_g146 < _g147)){
HXDLIN(  23)													_g146 = (_g146 + 1);
HXDLIN(  23)													int i57 = (_g146 - 1);
HXDLIN(  23)													{
HXDLIN(  23)														 ::haxe::io::ArrayBufferViewImpl this248 = b48->data;
HXDLIN(  23)														bool v89;
HXDLIN(  23)														if ((i57 >= 0)) {
HXDLIN(  23)															v89 = (i57 < (this248->byteLength >> 2));
            														}
            														else {
HXDLIN(  23)															v89 = false;
            														}
HXDLIN(  23)														if (v89) {
HXDLIN(  23)															 ::haxe::io::Bytes _this7 = this248->bytes;
HXDLIN(  23)															int pos7 = ((i57 << 2) + this248->byteOffset);
HXDLIN(  23)															_this7->b[pos7] = ( (unsigned char)(0) );
HXDLIN(  23)															_this7->b[(pos7 + 1)] = ( (unsigned char)(0) );
HXDLIN(  23)															_this7->b[(pos7 + 2)] = ( (unsigned char)(0) );
HXDLIN(  23)															_this7->b[(pos7 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN(  23)										v88 = b48;
            									}
            									break;
            									case (int)3: {
HXDLIN(  23)										 ::iterMagic::VecIntImg vec7 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  23)										 ::iterMagic::VecIntImg v90 = vec7;
HXDLIN(  23)										{
HXDLIN(  23)											v90->width = width7;
HXDLIN(  23)											v90->height = height7;
HXDLIN(  23)											v90->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN(  23)											v90->data = ::Array_obj< int >::__new(v90->length);
HXDLIN(  23)											{
HXDLIN(  23)												int _g148 = 0;
HXDLIN(  23)												int _g149 = v90->length;
HXDLIN(  23)												while((_g148 < _g149)){
HXDLIN(  23)													_g148 = (_g148 + 1);
HXDLIN(  23)													int i58 = (_g148 - 1);
HXDLIN(  23)													v90->data->__unsafe_set(i58,0);
            												}
            											}
            										}
HXDLIN(  23)										v88 = v90;
            									}
            									break;
            									case (int)4: {
HXDLIN(  23)										 ::iterMagic::StackIntImg sInt7 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  23)										 ::iterMagic::StackIntImg b49 = sInt7;
HXDLIN(  23)										{
HXDLIN(  23)											b49->width = width7;
HXDLIN(  23)											b49->height = height7;
HXDLIN(  23)											b49->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN(  23)											b49->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  23)											{
HXDLIN(  23)												int len15 = b49->length;
HXDLIN(  23)												 ::haxe::ds::GenericStack_Int d7 = b49->data;
HXDLIN(  23)												if (::hx::IsNull( d7->head )) {
HXDLIN(  23)													int _g150 = 0;
HXDLIN(  23)													int _g151 = len15;
HXDLIN(  23)													while((_g150 < _g151)){
HXDLIN(  23)														_g150 = (_g150 + 1);
HXDLIN(  23)														int i59 = (_g150 - 1);
HXDLIN(  23)														d7->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d7->head);
            													}
            												}
            												else {
HXDLIN(  23)													int _g152 = 0;
HXDLIN(  23)													int _g153 = len15;
HXDLIN(  23)													while((_g152 < _g153)){
HXDLIN(  23)														_g152 = (_g152 + 1);
HXDLIN(  23)														int i60 = (_g152 - 1);
HXDLIN(  23)														{
HXDLIN(  23)															 ::haxe::ds::GenericCell_Int l7 = b49->data->head;
HXDLIN(  23)															 ::haxe::ds::GenericCell_Int prev7 = null();
HXDLIN(  23)															{
HXDLIN(  23)																int _g154 = 0;
HXDLIN(  23)																int _g155 = i60;
HXDLIN(  23)																while((_g154 < _g155)){
HXDLIN(  23)																	_g154 = (_g154 + 1);
HXDLIN(  23)																	int i61 = (_g154 - 1);
HXLINE( 345)																	prev7 = l7;
HXLINE( 346)																	l7 = l7->next;
            																}
            															}
HXLINE(  23)															if (::hx::IsNull( prev7 )) {
HXDLIN(  23)																b49->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l7->next);
HXDLIN(  23)																l7 = null();
            															}
            															else {
HXDLIN(  23)																prev7->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l7->next);
HXDLIN(  23)																l7 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  23)										v88 = b49;
            									}
            									break;
            								}
HXDLIN(  23)								this247->image = v88;
HXDLIN(  23)								this247->width = width7;
HXDLIN(  23)								this247->height = height7;
HXDLIN(  23)								this247->imageType = ( (int)(imageType7) );
HXDLIN(  23)								 ::pi_xy::ImageStruct nextImage7 = this247;
HXDLIN(  23)								nextImage7->transparent = transparent7;
HXDLIN(  23)								while((_this_min7 < _this_max7)){
HXDLIN(  23)									_this_min7 = (_this_min7 + 1);
HXDLIN(  23)									int i62 = (_this_min7 - 1);
HXDLIN(  23)									if ((range_y7 > range_yMax7)) {
HXDLIN(  23)										range_y7 = range_yReset7;
HXDLIN(  23)										range_x7 = (range_x7 + 1);
            									}
HXDLIN(  23)									range_y7 = (range_y7 + 1);
HXDLIN(  23)									int i63 = i62;
HXDLIN(  23)									{
HXDLIN(  23)										int x44 = range_x7;
HXDLIN(  23)										int y44 = range_y7;
HXDLIN(  23)										int x45 = range_x7;
HXDLIN(  23)										int y45 = (range_yMax7 - range_y7);
HXDLIN(  23)										::Dynamic this249 = this246->image;
HXDLIN(  23)										int index42;
HXDLIN(  23)										if (this246->useVirtualPos) {
HXDLIN(  23)											index42 = ::Std_obj::_hx_int(((((( (Float)(y45) ) - this246->virtualY) * ( (Float)(this246->width) )) + x45) - this246->virtualX));
            										}
            										else {
HXDLIN(  23)											index42 = ::Std_obj::_hx_int(( (Float)(((y45 * this246->width) + x45)) ));
            										}
HXDLIN(  23)										int c35 = ::iterMagic::Iimg_obj::get(this249,index42);
HXDLIN(  23)										int color7;
HXDLIN(  23)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)											color7 = ((((((c35 >> 24) & 255) << 24) | ((c35 & 255) << 16)) | (((c35 >> 8) & 255) << 8)) | ((c35 >> 16) & 255));
            										}
            										else {
HXDLIN(  23)											color7 = c35;
            										}
HXDLIN(  23)										int c36 = color7;
HXDLIN(  23)										bool v91;
HXDLIN(  23)										if ((((c36 >> 24) & 255) < 254)) {
HXDLIN(  23)											v91 = nextImage7->transparent;
            										}
            										else {
HXDLIN(  23)											v91 = false;
            										}
HXDLIN(  23)										if (v91) {
HXDLIN(  23)											int location14;
HXDLIN(  23)											if (nextImage7->useVirtualPos) {
HXDLIN(  23)												location14 = ::Std_obj::_hx_int(((((( (Float)(y44) ) - nextImage7->virtualY) * ( (Float)(nextImage7->width) )) + x44) - nextImage7->virtualX));
            											}
            											else {
HXDLIN(  23)												location14 = ::Std_obj::_hx_int(( (Float)(((y44 * nextImage7->width) + x44)) ));
            											}
HXDLIN(  23)											int this250 = ::iterMagic::Iimg_obj::get(nextImage7->image,location14);
HXDLIN(  23)											int this251;
HXDLIN(  23)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)												this251 = ((((((this250 >> 24) & 255) << 24) | ((this250 & 255) << 16)) | (((this250 >> 8) & 255) << 8)) | ((this250 >> 16) & 255));
            											}
            											else {
HXDLIN(  23)												this251 = this250;
            											}
HXDLIN(  23)											Float a117;
HXDLIN(  23)											int this252 = ((this251 >> 24) & 255);
HXDLIN(  23)											if ((this252 == 0)) {
HXDLIN(  23)												a117 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												a117 = (( (Float)(this252) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float r114;
HXDLIN(  23)											int this253 = ((this251 >> 16) & 255);
HXDLIN(  23)											if ((this253 == 0)) {
HXDLIN(  23)												r114 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												r114 = (( (Float)(this253) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float g114;
HXDLIN(  23)											int this254 = ((this251 >> 8) & 255);
HXDLIN(  23)											if ((this254 == 0)) {
HXDLIN(  23)												g114 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												g114 = (( (Float)(this254) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float b118;
HXDLIN(  23)											int this255 = (this251 & 255);
HXDLIN(  23)											if ((this255 == 0)) {
HXDLIN(  23)												b118 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												b118 = (( (Float)(this255) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float a215;
HXDLIN(  23)											int this256 = ((color7 >> 24) & 255);
HXDLIN(  23)											if ((this256 == 0)) {
HXDLIN(  23)												a215 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												a215 = (( (Float)(this256) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float r214;
HXDLIN(  23)											int this257 = ((color7 >> 16) & 255);
HXDLIN(  23)											if ((this257 == 0)) {
HXDLIN(  23)												r214 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												r214 = (( (Float)(this257) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float g214;
HXDLIN(  23)											int this258 = ((color7 >> 8) & 255);
HXDLIN(  23)											if ((this258 == 0)) {
HXDLIN(  23)												g214 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												g214 = (( (Float)(this258) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float b218;
HXDLIN(  23)											int this259 = (color7 & 255);
HXDLIN(  23)											if ((this259 == 0)) {
HXDLIN(  23)												b218 = ((Float)0.);
            											}
            											else {
HXDLIN(  23)												b218 = (( (Float)(this259) ) / ( (Float)(255) ));
            											}
HXDLIN(  23)											Float a314 = (a117 * (( (Float)(1) ) - a215));
HXDLIN(  23)											int r34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r114 * a314) + (r214 * a215))));
HXDLIN(  23)											int g34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g114 * a314) + (g214 * a215))));
HXDLIN(  23)											int b50 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b118 * a314) + (b218 * a215))));
HXDLIN(  23)											int a48 = ::Std_obj::_hx_int((( (Float)(255) ) * (a314 + a215)));
HXDLIN(  23)											int blended14 = ((((a48 << 24) | (r34 << 16)) | (g34 << 8)) | b50);
HXDLIN(  23)											{
HXDLIN(  23)												int v92;
HXDLIN(  23)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)													v92 = ((((((blended14 >> 24) & 255) << 24) | ((blended14 & 255) << 16)) | (((blended14 >> 8) & 255) << 8)) | ((blended14 >> 16) & 255));
            												}
            												else {
HXDLIN(  23)													v92 = blended14;
            												}
HXDLIN(  23)												::iterMagic::Iimg_obj::set(nextImage7->image,location14,v92);
            											}
            										}
            										else {
HXDLIN(  23)											::Dynamic this260 = nextImage7->image;
HXDLIN(  23)											int index43;
HXDLIN(  23)											if (nextImage7->useVirtualPos) {
HXDLIN(  23)												index43 = ::Std_obj::_hx_int(((((( (Float)(y44) ) - nextImage7->virtualY) * ( (Float)(nextImage7->width) )) + x44) - nextImage7->virtualX));
            											}
            											else {
HXDLIN(  23)												index43 = ::Std_obj::_hx_int(( (Float)(((y44 * nextImage7->width) + x44)) ));
            											}
HXDLIN(  23)											int v93;
HXDLIN(  23)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)												v93 = ((((((c36 >> 24) & 255) << 24) | ((c36 & 255) << 16)) | (((c36 >> 8) & 255) << 8)) | ((c36 >> 16) & 255));
            											}
            											else {
HXDLIN(  23)												v93 = c36;
            											}
HXDLIN(  23)											::iterMagic::Iimg_obj::set(this260,index43,v93);
            										}
            									}
            								}
HXDLIN(  23)								 ::pi_xy::ImageStruct v94;
HXDLIN(  23)								if (inPlace) {
HXDLIN(  23)									{
HXDLIN(  23)										int x46 = ::Std_obj::_hx_int(x);
HXDLIN(  23)										int y46 = ::Std_obj::_hx_int(y);
HXDLIN(  23)										bool forceClear7 = false;
HXDLIN(  23)										{
HXDLIN(  23)											int _g156 = 0;
HXDLIN(  23)											int _g157 = nextImage7->height;
HXDLIN(  23)											while((_g156 < _g157)){
HXDLIN(  23)												_g156 = (_g156 + 1);
HXDLIN(  23)												int dy7 = (_g156 - 1);
HXDLIN(  23)												{
HXDLIN(  23)													int _g158 = 0;
HXDLIN(  23)													int _g159 = nextImage7->width;
HXDLIN(  23)													while((_g158 < _g159)){
HXDLIN(  23)														_g158 = (_g158 + 1);
HXDLIN(  23)														int dx7 = (_g158 - 1);
HXDLIN(  23)														::Dynamic this261 = nextImage7->image;
HXDLIN(  23)														int index44;
HXDLIN(  23)														if (nextImage7->useVirtualPos) {
HXDLIN(  23)															index44 = ::Std_obj::_hx_int(((((( (Float)(dy7) ) - nextImage7->virtualY) * ( (Float)(nextImage7->width) )) + dx7) - nextImage7->virtualX));
            														}
            														else {
HXDLIN(  23)															index44 = ::Std_obj::_hx_int(( (Float)(((dy7 * nextImage7->width) + dx7)) ));
            														}
HXDLIN(  23)														int c37 = ::iterMagic::Iimg_obj::get(this261,index44);
HXDLIN(  23)														int col7;
HXDLIN(  23)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)															col7 = ((((((c37 >> 24) & 255) << 24) | ((c37 & 255) << 16)) | (((c37 >> 8) & 255) << 8)) | ((c37 >> 16) & 255));
            														}
            														else {
HXDLIN(  23)															col7 = c37;
            														}
HXDLIN(  23)														bool v95;
HXDLIN(  23)														if (nextImage7->useMask) {
HXDLIN(  23)															v95 = ::hx::IsNotNull( nextImage7->mask );
            														}
            														else {
HXDLIN(  23)															v95 = false;
            														}
HXDLIN(  23)														if (v95) {
HXDLIN(  23)															 ::pi_xy::ImageStruct this262 = nextImage7->mask;
HXDLIN(  23)															::Dynamic this263 = this262->image;
HXDLIN(  23)															int index45;
HXDLIN(  23)															if (this262->useVirtualPos) {
HXDLIN(  23)																index45 = ::Std_obj::_hx_int(((((( (Float)(dy7) ) - this262->virtualY) * ( (Float)(this262->width) )) + dx7) - this262->virtualX));
            															}
            															else {
HXDLIN(  23)																index45 = ::Std_obj::_hx_int(( (Float)(((dy7 * this262->width) + dx7)) ));
            															}
HXDLIN(  23)															int c38 = ::iterMagic::Iimg_obj::get(this263,index45);
HXDLIN(  23)															int v96;
HXDLIN(  23)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)																v96 = ((((((c38 >> 24) & 255) << 24) | ((c38 & 255) << 16)) | (((c38 >> 8) & 255) << 8)) | ((c38 >> 16) & 255));
            															}
            															else {
HXDLIN(  23)																v96 = c38;
            															}
HXDLIN(  23)															int maskPixel7 = v96;
HXDLIN(  23)															int this264 = col7;
HXDLIN(  23)															if ((maskPixel7 == 0)) {
HXDLIN(  23)																col7 = this264;
            															}
            															else {
HXDLIN(  23)																Float m07;
HXDLIN(  23)																int this265 = ((maskPixel7 >> 24) & 255);
HXDLIN(  23)																if ((this265 == 0)) {
HXDLIN(  23)																	m07 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	m07 = (( (Float)(this265) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float m17;
HXDLIN(  23)																int this266 = ((maskPixel7 >> 16) & 255);
HXDLIN(  23)																if ((this266 == 0)) {
HXDLIN(  23)																	m17 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	m17 = (( (Float)(this266) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float m27;
HXDLIN(  23)																int this267 = ((maskPixel7 >> 8) & 255);
HXDLIN(  23)																if ((this267 == 0)) {
HXDLIN(  23)																	m27 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	m27 = (( (Float)(this267) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float m37;
HXDLIN(  23)																int this268 = (maskPixel7 & 255);
HXDLIN(  23)																if ((this268 == 0)) {
HXDLIN(  23)																	m37 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	m37 = (( (Float)(this268) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																int ch07 = ::Std_obj::_hx_int(((((Float)1.) - m07) * ( (Float)(((this264 >> 24) & 255)) )));
HXDLIN(  23)																int ch17 = ::Std_obj::_hx_int(((((Float)1.) - m17) * ( (Float)(((this264 >> 16) & 255)) )));
HXDLIN(  23)																int ch27 = ::Std_obj::_hx_int(((((Float)1.) - m27) * ( (Float)(((this264 >> 8) & 255)) )));
HXDLIN(  23)																int ch37 = ::Std_obj::_hx_int(((((Float)1.) - m37) * ( (Float)((this264 & 255)) )));
HXDLIN(  23)																col7 = ((((::Math_obj::round((( (Float)(ch07) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch17) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch27) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch37) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  23)														if ((col7 != 0)) {
HXDLIN(  23)															int x47 = (x46 + dx7);
HXDLIN(  23)															int y47 = (y46 + dy7);
HXDLIN(  23)															int c39 = col7;
HXDLIN(  23)															bool v97;
HXDLIN(  23)															if ((((c39 >> 24) & 255) < 254)) {
HXDLIN(  23)																v97 = this246->transparent;
            															}
            															else {
HXDLIN(  23)																v97 = false;
            															}
HXDLIN(  23)															if (v97) {
HXDLIN(  23)																int location15;
HXDLIN(  23)																if (this246->useVirtualPos) {
HXDLIN(  23)																	location15 = ::Std_obj::_hx_int(((((( (Float)(y47) ) - this246->virtualY) * ( (Float)(this246->width) )) + x47) - this246->virtualX));
            																}
            																else {
HXDLIN(  23)																	location15 = ::Std_obj::_hx_int(( (Float)(((y47 * this246->width) + x47)) ));
            																}
HXDLIN(  23)																int this269 = ::iterMagic::Iimg_obj::get(this246->image,location15);
HXDLIN(  23)																int this270;
HXDLIN(  23)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)																	this270 = ((((((this269 >> 24) & 255) << 24) | ((this269 & 255) << 16)) | (((this269 >> 8) & 255) << 8)) | ((this269 >> 16) & 255));
            																}
            																else {
HXDLIN(  23)																	this270 = this269;
            																}
HXDLIN(  23)																Float a118;
HXDLIN(  23)																int this271 = ((this270 >> 24) & 255);
HXDLIN(  23)																if ((this271 == 0)) {
HXDLIN(  23)																	a118 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	a118 = (( (Float)(this271) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float r115;
HXDLIN(  23)																int this272 = ((this270 >> 16) & 255);
HXDLIN(  23)																if ((this272 == 0)) {
HXDLIN(  23)																	r115 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	r115 = (( (Float)(this272) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float g115;
HXDLIN(  23)																int this273 = ((this270 >> 8) & 255);
HXDLIN(  23)																if ((this273 == 0)) {
HXDLIN(  23)																	g115 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	g115 = (( (Float)(this273) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float b119;
HXDLIN(  23)																int this274 = (this270 & 255);
HXDLIN(  23)																if ((this274 == 0)) {
HXDLIN(  23)																	b119 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	b119 = (( (Float)(this274) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float a216;
HXDLIN(  23)																int this275 = ((col7 >> 24) & 255);
HXDLIN(  23)																if ((this275 == 0)) {
HXDLIN(  23)																	a216 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	a216 = (( (Float)(this275) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float r215;
HXDLIN(  23)																int this276 = ((col7 >> 16) & 255);
HXDLIN(  23)																if ((this276 == 0)) {
HXDLIN(  23)																	r215 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	r215 = (( (Float)(this276) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float g215;
HXDLIN(  23)																int this277 = ((col7 >> 8) & 255);
HXDLIN(  23)																if ((this277 == 0)) {
HXDLIN(  23)																	g215 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	g215 = (( (Float)(this277) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float b219;
HXDLIN(  23)																int this278 = (col7 & 255);
HXDLIN(  23)																if ((this278 == 0)) {
HXDLIN(  23)																	b219 = ((Float)0.);
            																}
            																else {
HXDLIN(  23)																	b219 = (( (Float)(this278) ) / ( (Float)(255) ));
            																}
HXDLIN(  23)																Float a315 = (a118 * (( (Float)(1) ) - a216));
HXDLIN(  23)																int r35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r115 * a315) + (r215 * a216))));
HXDLIN(  23)																int g35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g115 * a315) + (g215 * a216))));
HXDLIN(  23)																int b51 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b119 * a315) + (b219 * a216))));
HXDLIN(  23)																int a49 = ::Std_obj::_hx_int((( (Float)(255) ) * (a315 + a216)));
HXDLIN(  23)																int blended15 = ((((a49 << 24) | (r35 << 16)) | (g35 << 8)) | b51);
HXDLIN(  23)																{
HXDLIN(  23)																	int v98;
HXDLIN(  23)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)																		v98 = ((((((blended15 >> 24) & 255) << 24) | ((blended15 & 255) << 16)) | (((blended15 >> 8) & 255) << 8)) | ((blended15 >> 16) & 255));
            																	}
            																	else {
HXDLIN(  23)																		v98 = blended15;
            																	}
HXDLIN(  23)																	::iterMagic::Iimg_obj::set(this246->image,location15,v98);
            																}
            															}
            															else {
HXDLIN(  23)																::Dynamic this279 = this246->image;
HXDLIN(  23)																int index46;
HXDLIN(  23)																if (this246->useVirtualPos) {
HXDLIN(  23)																	index46 = ::Std_obj::_hx_int(((((( (Float)(y47) ) - this246->virtualY) * ( (Float)(this246->width) )) + x47) - this246->virtualX));
            																}
            																else {
HXDLIN(  23)																	index46 = ::Std_obj::_hx_int(( (Float)(((y47 * this246->width) + x47)) ));
            																}
HXDLIN(  23)																int v99;
HXDLIN(  23)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  23)																	v99 = ((((((c39 >> 24) & 255) << 24) | ((c39 & 255) << 16)) | (((c39 >> 8) & 255) << 8)) | ((c39 >> 16) & 255));
            																}
            																else {
HXDLIN(  23)																	v99 = c39;
            																}
HXDLIN(  23)																::iterMagic::Iimg_obj::set(this279,index46,v99);
            															}
            														}
            														else {
HXDLIN(  23)															if (forceClear7) {
HXDLIN(  23)																::Dynamic this280 = this246->image;
HXDLIN(  23)																int x48 = (x46 + dx7);
HXDLIN(  23)																int y48 = (y46 + dy7);
HXDLIN(  23)																int index47;
HXDLIN(  23)																if (this246->useVirtualPos) {
HXDLIN(  23)																	index47 = ::Std_obj::_hx_int(((((( (Float)(y48) ) - this246->virtualY) * ( (Float)(this246->width) )) + x48) - this246->virtualX));
            																}
            																else {
HXDLIN(  23)																	index47 = ::Std_obj::_hx_int(( (Float)(((y48 * this246->width) + x48)) ));
            																}
HXDLIN(  23)																::iterMagic::Iimg_obj::set(this280,index47,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  23)									bool v100;
HXDLIN(  23)									if (::hx::IsNotNull( this246->mask )) {
HXDLIN(  23)										v100 = includeMask;
            									}
            									else {
HXDLIN(  23)										v100 = false;
            									}
HXDLIN(  23)									if (v100) {
HXDLIN(  23)										 ::pi_xy::ImageStruct v101 = ::pi_xy::imageAbstracts::_TransformImage::TransformImage_Impl__obj::flippedY(this246->mask,x,y,( (Float)(this246->width) ),( (Float)(this246->height) ),this246->mask->transparent,inPlace,includeMask);
HXDLIN(  23)										this246->useMask = true;
HXDLIN(  23)										this246->mask = v101;
            									}
HXLINE(  91)									nextImage7 = null();
HXLINE(  23)									v94 = this246;
            								}
            								else {
HXDLIN(  23)									bool v102;
HXDLIN(  23)									if (::hx::IsNotNull( this246->mask )) {
HXDLIN(  23)										v102 = includeMask;
            									}
            									else {
HXDLIN(  23)										v102 = false;
            									}
HXDLIN(  23)									if (v102) {
HXDLIN(  23)										 ::pi_xy::ImageStruct v103 = ::pi_xy::imageAbstracts::_TransformImage::TransformImage_Impl__obj::flippedY(this246->mask,x,y,( (Float)(this246->width) ),( (Float)(this246->height) ),this246->mask->transparent,inPlace,includeMask);
HXDLIN(  23)										nextImage7->useMask = true;
HXDLIN(  23)										nextImage7->mask = v103;
            									}
HXDLIN(  23)									v94 = nextImage7;
            								}
HXDLIN(  23)								nextImage5->useMask = true;
HXDLIN(  23)								nextImage5->mask = v94;
            							}
HXDLIN(  23)							v64 = nextImage5;
            						}
HXDLIN(  23)						nextImage1->useMask = true;
HXDLIN(  23)						nextImage1->mask = v64;
            					}
HXDLIN(  23)					v4 = nextImage1;
            				}
HXDLIN(  23)				nextImage->useMask = true;
HXDLIN(  23)				nextImage->mask = v4;
            			}
HXDLIN(  23)			return nextImage;
            		}
HXDLIN(  23)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC8(TransformImage_Impl__obj,flippedX,return )

 ::pi_xy::ImageStruct TransformImage_Impl__obj::flippedY( ::pi_xy::ImageStruct this1,Float x,Float y,Float w,Float h,::hx::Null< bool >  __o_transparent,::hx::Null< bool >  __o_inPlace,::hx::Null< bool >  __o_includeMask){
            		bool transparent = __o_transparent.Default(false);
            		bool inPlace = __o_inPlace.Default(false);
            		bool includeMask = __o_includeMask.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_68d25436a32dba6f_34_flippedY)
HXDLIN(  34)		Float r_x = x;
HXDLIN(  34)		Float r_y = y;
HXDLIN(  34)		Float r_w = w;
HXDLIN(  34)		Float r_h = h;
HXDLIN(  34)		int xmax = ::Std_obj::_hx_int(((r_x + r_w) + 1));
HXDLIN(  34)		int ymax = ::Std_obj::_hx_int(((r_y + r_h) + 1));
HXDLIN(  34)		int ii_min = ::Std_obj::_hx_int(r_x);
HXDLIN(  34)		int ii_max = xmax;
HXDLIN(  34)		int xRange__start = ii_min;
HXDLIN(  34)		int xRange__max = ii_max;
HXDLIN(  34)		int ii_min1 = ::Std_obj::_hx_int(r_y);
HXDLIN(  34)		int ii_max1 = ymax;
HXDLIN(  34)		int yRange__start = ii_min1;
HXDLIN(  34)		int yRange__max = ii_max1;
HXDLIN(  34)		int range_x = xRange__start;
HXDLIN(  34)		int range_y = (yRange__start - 1);
HXDLIN(  34)		int range_xReset = range_x;
HXDLIN(  34)		int range_yReset = range_y;
HXDLIN(  34)		int range_xMax = (xRange__max - 2);
HXDLIN(  34)		int range_yMax = (yRange__max - 2);
HXDLIN(  34)		int _this_min = 0;
HXDLIN(  34)		int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXDLIN(  34)		int width = ::Std_obj::_hx_int(w);
HXDLIN(  34)		int height = ::Std_obj::_hx_int(h);
HXDLIN(  34)		 ::Dynamic imageType = null();
HXDLIN(  34)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  34)		if (::hx::IsNull( imageType )) {
HXLINE(  54)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXLINE(  34)		::Dynamic _hx_tmp;
HXDLIN(  34)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXDLIN(  34)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  34)				 ::iterMagic::BytesImg b = byt;
HXDLIN(  34)				{
HXDLIN(  34)					b->width = width;
HXDLIN(  34)					b->height = height;
HXDLIN(  34)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  34)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  34)					{
HXDLIN(  34)						int len = b->length;
HXDLIN(  34)						int w1 = 0;
HXDLIN(  34)						{
HXDLIN(  34)							int _g = 0;
HXDLIN(  34)							int _g1 = b->height;
HXDLIN(  34)							while((_g < _g1)){
HXDLIN(  34)								_g = (_g + 1);
HXDLIN(  34)								int y1 = (_g - 1);
HXDLIN(  34)								{
HXDLIN(  34)									int _g2 = 0;
HXDLIN(  34)									int _g3 = b->width;
HXDLIN(  34)									while((_g2 < _g3)){
HXDLIN(  34)										_g2 = (_g2 + 1);
HXDLIN(  34)										int x1 = (_g2 - 1);
HXDLIN(  34)										{
HXDLIN(  34)											w1 = (w1 + 1);
HXDLIN(  34)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  34)										{
HXDLIN(  34)											w1 = (w1 + 1);
HXDLIN(  34)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  34)										{
HXDLIN(  34)											w1 = (w1 + 1);
HXDLIN(  34)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  34)										{
HXDLIN(  34)											w1 = (w1 + 1);
HXDLIN(  34)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  34)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXDLIN(  34)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  34)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  34)				{
HXDLIN(  34)					a->width = width;
HXDLIN(  34)					a->height = height;
HXDLIN(  34)					a->data = ::Array_obj< int >::__new(0);
HXDLIN(  34)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  34)					{
HXDLIN(  34)						int _g4 = 0;
HXDLIN(  34)						int _g5 = a->length;
HXDLIN(  34)						while((_g4 < _g5)){
HXDLIN(  34)							_g4 = (_g4 + 1);
HXDLIN(  34)							int i = (_g4 - 1);
HXDLIN(  34)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN(  34)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXDLIN(  34)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  34)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  34)				{
HXDLIN(  34)					b1->width = width;
HXDLIN(  34)					b1->height = height;
HXDLIN(  34)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  34)					int size = (b1->length * 4);
HXDLIN(  34)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  34)					{
HXDLIN(  34)						int _g6 = 0;
HXDLIN(  34)						int _g7 = b1->length;
HXDLIN(  34)						while((_g6 < _g7)){
HXDLIN(  34)							_g6 = (_g6 + 1);
HXDLIN(  34)							int i1 = (_g6 - 1);
HXDLIN(  34)							{
HXDLIN(  34)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  34)								bool _hx_tmp1;
HXDLIN(  34)								if ((i1 >= 0)) {
HXDLIN(  34)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXDLIN(  34)									_hx_tmp1 = false;
            								}
HXDLIN(  34)								if (_hx_tmp1) {
HXDLIN(  34)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  34)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  34)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  34)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  34)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  34)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(  34)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXDLIN(  34)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  34)				 ::iterMagic::VecIntImg v = vec;
HXDLIN(  34)				{
HXDLIN(  34)					v->width = width;
HXDLIN(  34)					v->height = height;
HXDLIN(  34)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  34)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  34)					{
HXDLIN(  34)						int _g8 = 0;
HXDLIN(  34)						int _g9 = v->length;
HXDLIN(  34)						while((_g8 < _g9)){
HXDLIN(  34)							_g8 = (_g8 + 1);
HXDLIN(  34)							int i2 = (_g8 - 1);
HXDLIN(  34)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN(  34)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXDLIN(  34)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  34)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  34)				{
HXDLIN(  34)					b2->width = width;
HXDLIN(  34)					b2->height = height;
HXDLIN(  34)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  34)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  34)					{
HXDLIN(  34)						int len1 = b2->length;
HXDLIN(  34)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  34)						if (::hx::IsNull( d->head )) {
HXDLIN(  34)							int _g10 = 0;
HXDLIN(  34)							int _g11 = len1;
HXDLIN(  34)							while((_g10 < _g11)){
HXDLIN(  34)								_g10 = (_g10 + 1);
HXDLIN(  34)								int i3 = (_g10 - 1);
HXDLIN(  34)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXDLIN(  34)							int _g12 = 0;
HXDLIN(  34)							int _g13 = len1;
HXDLIN(  34)							while((_g12 < _g13)){
HXDLIN(  34)								_g12 = (_g12 + 1);
HXDLIN(  34)								int i4 = (_g12 - 1);
HXDLIN(  34)								{
HXDLIN(  34)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  34)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  34)									{
HXDLIN(  34)										int _g14 = 0;
HXDLIN(  34)										int _g15 = i4;
HXDLIN(  34)										while((_g14 < _g15)){
HXDLIN(  34)											_g14 = (_g14 + 1);
HXDLIN(  34)											int i5 = (_g14 - 1);
HXLINE( 345)											prev = l;
HXLINE( 346)											l = l->next;
            										}
            									}
HXLINE(  34)									if (::hx::IsNull( prev )) {
HXDLIN(  34)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  34)										l = null();
            									}
            									else {
HXDLIN(  34)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  34)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  34)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN(  34)		this2->image = _hx_tmp;
HXDLIN(  34)		this2->width = width;
HXDLIN(  34)		this2->height = height;
HXDLIN(  34)		this2->imageType = ( (int)(imageType) );
HXDLIN(  34)		 ::pi_xy::ImageStruct nextImage = this2;
HXDLIN(  34)		nextImage->transparent = transparent;
HXDLIN(  34)		while((_this_min < _this_max)){
HXDLIN(  34)			_this_min = (_this_min + 1);
HXDLIN(  34)			int i6 = (_this_min - 1);
HXDLIN(  34)			if ((range_y > range_yMax)) {
HXDLIN(  34)				range_y = range_yReset;
HXDLIN(  34)				range_x = (range_x + 1);
            			}
HXDLIN(  34)			range_y = (range_y + 1);
HXDLIN(  34)			int i7 = i6;
HXDLIN(  34)			{
HXDLIN(  34)				int x2 = range_x;
HXDLIN(  34)				int y2 = range_y;
HXDLIN(  34)				int x3 = range_x;
HXDLIN(  34)				int y3 = (range_yMax - range_y);
HXDLIN(  34)				::Dynamic this4 = this1->image;
HXDLIN(  34)				int index;
HXDLIN(  34)				if (this1->useVirtualPos) {
HXDLIN(  34)					index = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            				}
            				else {
HXDLIN(  34)					index = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            				}
HXDLIN(  34)				int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN(  34)				int color;
HXDLIN(  34)				if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  34)					color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            				}
            				else {
HXDLIN(  34)					color = c;
            				}
HXDLIN(  34)				int c1 = color;
HXDLIN(  34)				bool _hx_tmp2;
HXDLIN(  34)				if ((((c1 >> 24) & 255) < 254)) {
HXDLIN(  34)					_hx_tmp2 = nextImage->transparent;
            				}
            				else {
HXDLIN(  34)					_hx_tmp2 = false;
            				}
HXDLIN(  34)				if (_hx_tmp2) {
HXDLIN(  34)					int location;
HXDLIN(  34)					if (nextImage->useVirtualPos) {
HXDLIN(  34)						location = ::Std_obj::_hx_int(((((( (Float)(y2) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x2) - nextImage->virtualX));
            					}
            					else {
HXDLIN(  34)						location = ::Std_obj::_hx_int(( (Float)(((y2 * nextImage->width) + x2)) ));
            					}
HXDLIN(  34)					int this5 = ::iterMagic::Iimg_obj::get(nextImage->image,location);
HXDLIN(  34)					int this6;
HXDLIN(  34)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  34)						this6 = ((((((this5 >> 24) & 255) << 24) | ((this5 & 255) << 16)) | (((this5 >> 8) & 255) << 8)) | ((this5 >> 16) & 255));
            					}
            					else {
HXDLIN(  34)						this6 = this5;
            					}
HXDLIN(  34)					Float a1;
HXDLIN(  34)					int this7 = ((this6 >> 24) & 255);
HXDLIN(  34)					if ((this7 == 0)) {
HXDLIN(  34)						a1 = ((Float)0.);
            					}
            					else {
HXDLIN(  34)						a1 = (( (Float)(this7) ) / ( (Float)(255) ));
            					}
HXDLIN(  34)					Float r1;
HXDLIN(  34)					int this8 = ((this6 >> 16) & 255);
HXDLIN(  34)					if ((this8 == 0)) {
HXDLIN(  34)						r1 = ((Float)0.);
            					}
            					else {
HXDLIN(  34)						r1 = (( (Float)(this8) ) / ( (Float)(255) ));
            					}
HXDLIN(  34)					Float g1;
HXDLIN(  34)					int this9 = ((this6 >> 8) & 255);
HXDLIN(  34)					if ((this9 == 0)) {
HXDLIN(  34)						g1 = ((Float)0.);
            					}
            					else {
HXDLIN(  34)						g1 = (( (Float)(this9) ) / ( (Float)(255) ));
            					}
HXDLIN(  34)					Float b11;
HXDLIN(  34)					int this10 = (this6 & 255);
HXDLIN(  34)					if ((this10 == 0)) {
HXDLIN(  34)						b11 = ((Float)0.);
            					}
            					else {
HXDLIN(  34)						b11 = (( (Float)(this10) ) / ( (Float)(255) ));
            					}
HXDLIN(  34)					Float a2;
HXDLIN(  34)					int this11 = ((color >> 24) & 255);
HXDLIN(  34)					if ((this11 == 0)) {
HXDLIN(  34)						a2 = ((Float)0.);
            					}
            					else {
HXDLIN(  34)						a2 = (( (Float)(this11) ) / ( (Float)(255) ));
            					}
HXDLIN(  34)					Float r2;
HXDLIN(  34)					int this12 = ((color >> 16) & 255);
HXDLIN(  34)					if ((this12 == 0)) {
HXDLIN(  34)						r2 = ((Float)0.);
            					}
            					else {
HXDLIN(  34)						r2 = (( (Float)(this12) ) / ( (Float)(255) ));
            					}
HXDLIN(  34)					Float g2;
HXDLIN(  34)					int this13 = ((color >> 8) & 255);
HXDLIN(  34)					if ((this13 == 0)) {
HXDLIN(  34)						g2 = ((Float)0.);
            					}
            					else {
HXDLIN(  34)						g2 = (( (Float)(this13) ) / ( (Float)(255) ));
            					}
HXDLIN(  34)					Float b21;
HXDLIN(  34)					int this14 = (color & 255);
HXDLIN(  34)					if ((this14 == 0)) {
HXDLIN(  34)						b21 = ((Float)0.);
            					}
            					else {
HXDLIN(  34)						b21 = (( (Float)(this14) ) / ( (Float)(255) ));
            					}
HXDLIN(  34)					Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  34)					int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  34)					int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  34)					int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  34)					int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  34)					int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  34)					{
HXDLIN(  34)						int _hx_tmp3;
HXDLIN(  34)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  34)							_hx_tmp3 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            						}
            						else {
HXDLIN(  34)							_hx_tmp3 = blended;
            						}
HXDLIN(  34)						::iterMagic::Iimg_obj::set(nextImage->image,location,_hx_tmp3);
            					}
            				}
            				else {
HXDLIN(  34)					::Dynamic this15 = nextImage->image;
HXDLIN(  34)					int index1;
HXDLIN(  34)					if (nextImage->useVirtualPos) {
HXDLIN(  34)						index1 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x2) - nextImage->virtualX));
            					}
            					else {
HXDLIN(  34)						index1 = ::Std_obj::_hx_int(( (Float)(((y2 * nextImage->width) + x2)) ));
            					}
HXDLIN(  34)					int _hx_tmp4;
HXDLIN(  34)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  34)						_hx_tmp4 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            					}
            					else {
HXDLIN(  34)						_hx_tmp4 = c1;
            					}
HXDLIN(  34)					::iterMagic::Iimg_obj::set(this15,index1,_hx_tmp4);
            				}
            			}
            		}
HXDLIN(  34)		if (inPlace) {
HXDLIN(  34)			{
HXDLIN(  34)				int x4 = ::Std_obj::_hx_int(x);
HXDLIN(  34)				int y4 = ::Std_obj::_hx_int(y);
HXDLIN(  34)				bool forceClear = false;
HXDLIN(  34)				{
HXDLIN(  34)					int _g16 = 0;
HXDLIN(  34)					int _g17 = nextImage->height;
HXDLIN(  34)					while((_g16 < _g17)){
HXDLIN(  34)						_g16 = (_g16 + 1);
HXDLIN(  34)						int dy = (_g16 - 1);
HXDLIN(  34)						{
HXDLIN(  34)							int _g18 = 0;
HXDLIN(  34)							int _g19 = nextImage->width;
HXDLIN(  34)							while((_g18 < _g19)){
HXDLIN(  34)								_g18 = (_g18 + 1);
HXDLIN(  34)								int dx = (_g18 - 1);
HXDLIN(  34)								::Dynamic this16 = nextImage->image;
HXDLIN(  34)								int index2;
HXDLIN(  34)								if (nextImage->useVirtualPos) {
HXDLIN(  34)									index2 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + dx) - nextImage->virtualX));
            								}
            								else {
HXDLIN(  34)									index2 = ::Std_obj::_hx_int(( (Float)(((dy * nextImage->width) + dx)) ));
            								}
HXDLIN(  34)								int c2 = ::iterMagic::Iimg_obj::get(this16,index2);
HXDLIN(  34)								int col;
HXDLIN(  34)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  34)									col = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            								}
            								else {
HXDLIN(  34)									col = c2;
            								}
HXDLIN(  34)								bool _hx_tmp5;
HXDLIN(  34)								if (nextImage->useMask) {
HXDLIN(  34)									_hx_tmp5 = ::hx::IsNotNull( nextImage->mask );
            								}
            								else {
HXDLIN(  34)									_hx_tmp5 = false;
            								}
HXDLIN(  34)								if (_hx_tmp5) {
HXDLIN(  34)									 ::pi_xy::ImageStruct this17 = nextImage->mask;
HXDLIN(  34)									::Dynamic this18 = this17->image;
HXDLIN(  34)									int index3;
HXDLIN(  34)									if (this17->useVirtualPos) {
HXDLIN(  34)										index3 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this17->virtualY) * ( (Float)(this17->width) )) + dx) - this17->virtualX));
            									}
            									else {
HXDLIN(  34)										index3 = ::Std_obj::_hx_int(( (Float)(((dy * this17->width) + dx)) ));
            									}
HXDLIN(  34)									int c3 = ::iterMagic::Iimg_obj::get(this18,index3);
HXDLIN(  34)									int v1;
HXDLIN(  34)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  34)										v1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            									}
            									else {
HXDLIN(  34)										v1 = c3;
            									}
HXDLIN(  34)									int maskPixel = v1;
HXDLIN(  34)									int this19 = col;
HXDLIN(  34)									if ((maskPixel == 0)) {
HXDLIN(  34)										col = this19;
            									}
            									else {
HXDLIN(  34)										Float m0;
HXDLIN(  34)										int this20 = ((maskPixel >> 24) & 255);
HXDLIN(  34)										if ((this20 == 0)) {
HXDLIN(  34)											m0 = ((Float)0.);
            										}
            										else {
HXDLIN(  34)											m0 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN(  34)										Float m1;
HXDLIN(  34)										int this21 = ((maskPixel >> 16) & 255);
HXDLIN(  34)										if ((this21 == 0)) {
HXDLIN(  34)											m1 = ((Float)0.);
            										}
            										else {
HXDLIN(  34)											m1 = (( (Float)(this21) ) / ( (Float)(255) ));
            										}
HXDLIN(  34)										Float m2;
HXDLIN(  34)										int this22 = ((maskPixel >> 8) & 255);
HXDLIN(  34)										if ((this22 == 0)) {
HXDLIN(  34)											m2 = ((Float)0.);
            										}
            										else {
HXDLIN(  34)											m2 = (( (Float)(this22) ) / ( (Float)(255) ));
            										}
HXDLIN(  34)										Float m3;
HXDLIN(  34)										int this23 = (maskPixel & 255);
HXDLIN(  34)										if ((this23 == 0)) {
HXDLIN(  34)											m3 = ((Float)0.);
            										}
            										else {
HXDLIN(  34)											m3 = (( (Float)(this23) ) / ( (Float)(255) ));
            										}
HXDLIN(  34)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this19 >> 24) & 255)) )));
HXDLIN(  34)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this19 >> 16) & 255)) )));
HXDLIN(  34)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this19 >> 8) & 255)) )));
HXDLIN(  34)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this19 & 255)) )));
HXDLIN(  34)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN(  34)								if ((col != 0)) {
HXDLIN(  34)									int x5 = (x4 + dx);
HXDLIN(  34)									int y5 = (y4 + dy);
HXDLIN(  34)									int c4 = col;
HXDLIN(  34)									bool _hx_tmp6;
HXDLIN(  34)									if ((((c4 >> 24) & 255) < 254)) {
HXDLIN(  34)										_hx_tmp6 = this1->transparent;
            									}
            									else {
HXDLIN(  34)										_hx_tmp6 = false;
            									}
HXDLIN(  34)									if (_hx_tmp6) {
HXDLIN(  34)										int location1;
HXDLIN(  34)										if (this1->useVirtualPos) {
HXDLIN(  34)											location1 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - this1->virtualY) * ( (Float)(this1->width) )) + x5) - this1->virtualX));
            										}
            										else {
HXDLIN(  34)											location1 = ::Std_obj::_hx_int(( (Float)(((y5 * this1->width) + x5)) ));
            										}
HXDLIN(  34)										int this24 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN(  34)										int this25;
HXDLIN(  34)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  34)											this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            										}
            										else {
HXDLIN(  34)											this25 = this24;
            										}
HXDLIN(  34)										Float a11;
HXDLIN(  34)										int this26 = ((this25 >> 24) & 255);
HXDLIN(  34)										if ((this26 == 0)) {
HXDLIN(  34)											a11 = ((Float)0.);
            										}
            										else {
HXDLIN(  34)											a11 = (( (Float)(this26) ) / ( (Float)(255) ));
            										}
HXDLIN(  34)										Float r11;
HXDLIN(  34)										int this27 = ((this25 >> 16) & 255);
HXDLIN(  34)										if ((this27 == 0)) {
HXDLIN(  34)											r11 = ((Float)0.);
            										}
            										else {
HXDLIN(  34)											r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            										}
HXDLIN(  34)										Float g11;
HXDLIN(  34)										int this28 = ((this25 >> 8) & 255);
HXDLIN(  34)										if ((this28 == 0)) {
HXDLIN(  34)											g11 = ((Float)0.);
            										}
            										else {
HXDLIN(  34)											g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            										}
HXDLIN(  34)										Float b12;
HXDLIN(  34)										int this29 = (this25 & 255);
HXDLIN(  34)										if ((this29 == 0)) {
HXDLIN(  34)											b12 = ((Float)0.);
            										}
            										else {
HXDLIN(  34)											b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            										}
HXDLIN(  34)										Float a21;
HXDLIN(  34)										int this30 = ((col >> 24) & 255);
HXDLIN(  34)										if ((this30 == 0)) {
HXDLIN(  34)											a21 = ((Float)0.);
            										}
            										else {
HXDLIN(  34)											a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN(  34)										Float r21;
HXDLIN(  34)										int this31 = ((col >> 16) & 255);
HXDLIN(  34)										if ((this31 == 0)) {
HXDLIN(  34)											r21 = ((Float)0.);
            										}
            										else {
HXDLIN(  34)											r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN(  34)										Float g21;
HXDLIN(  34)										int this32 = ((col >> 8) & 255);
HXDLIN(  34)										if ((this32 == 0)) {
HXDLIN(  34)											g21 = ((Float)0.);
            										}
            										else {
HXDLIN(  34)											g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            										}
HXDLIN(  34)										Float b22;
HXDLIN(  34)										int this33 = (col & 255);
HXDLIN(  34)										if ((this33 == 0)) {
HXDLIN(  34)											b22 = ((Float)0.);
            										}
            										else {
HXDLIN(  34)											b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            										}
HXDLIN(  34)										Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  34)										int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  34)										int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  34)										int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  34)										int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  34)										int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  34)										{
HXDLIN(  34)											int _hx_tmp7;
HXDLIN(  34)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  34)												_hx_tmp7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXDLIN(  34)												_hx_tmp7 = blended1;
            											}
HXDLIN(  34)											::iterMagic::Iimg_obj::set(this1->image,location1,_hx_tmp7);
            										}
            									}
            									else {
HXDLIN(  34)										::Dynamic this34 = this1->image;
HXDLIN(  34)										int index4;
HXDLIN(  34)										if (this1->useVirtualPos) {
HXDLIN(  34)											index4 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - this1->virtualY) * ( (Float)(this1->width) )) + x5) - this1->virtualX));
            										}
            										else {
HXDLIN(  34)											index4 = ::Std_obj::_hx_int(( (Float)(((y5 * this1->width) + x5)) ));
            										}
HXDLIN(  34)										int _hx_tmp8;
HXDLIN(  34)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  34)											_hx_tmp8 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            										}
            										else {
HXDLIN(  34)											_hx_tmp8 = c4;
            										}
HXDLIN(  34)										::iterMagic::Iimg_obj::set(this34,index4,_hx_tmp8);
            									}
            								}
            								else {
HXDLIN(  34)									if (forceClear) {
HXDLIN(  34)										::Dynamic this35 = this1->image;
HXDLIN(  34)										int x6 = (x4 + dx);
HXDLIN(  34)										int y6 = (y4 + dy);
HXDLIN(  34)										int index5;
HXDLIN(  34)										if (this1->useVirtualPos) {
HXDLIN(  34)											index5 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - this1->virtualY) * ( (Float)(this1->width) )) + x6) - this1->virtualX));
            										}
            										else {
HXDLIN(  34)											index5 = ::Std_obj::_hx_int(( (Float)(((y6 * this1->width) + x6)) ));
            										}
HXDLIN(  34)										::iterMagic::Iimg_obj::set(this35,index5,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN(  34)			bool _hx_tmp9;
HXDLIN(  34)			if (::hx::IsNotNull( this1->mask )) {
HXDLIN(  34)				_hx_tmp9 = includeMask;
            			}
            			else {
HXDLIN(  34)				_hx_tmp9 = false;
            			}
HXDLIN(  34)			if (_hx_tmp9) {
HXDLIN(  34)				 ::pi_xy::ImageStruct v2 = ::pi_xy::imageAbstracts::_TransformImage::TransformImage_Impl__obj::flippedY(this1->mask,x,y,( (Float)(this1->width) ),( (Float)(this1->height) ),this1->mask->transparent,inPlace,includeMask);
HXDLIN(  34)				this1->useMask = true;
HXDLIN(  34)				this1->mask = v2;
            			}
HXLINE(  91)			nextImage = null();
HXLINE(  34)			return this1;
            		}
            		else {
HXDLIN(  34)			bool _hx_tmp10;
HXDLIN(  34)			if (::hx::IsNotNull( this1->mask )) {
HXDLIN(  34)				_hx_tmp10 = includeMask;
            			}
            			else {
HXDLIN(  34)				_hx_tmp10 = false;
            			}
HXDLIN(  34)			if (_hx_tmp10) {
HXDLIN(  34)				 ::pi_xy::ImageStruct v3 = ::pi_xy::imageAbstracts::_TransformImage::TransformImage_Impl__obj::flippedY(this1->mask,x,y,( (Float)(this1->width) ),( (Float)(this1->height) ),this1->mask->transparent,inPlace,includeMask);
HXDLIN(  34)				nextImage->useMask = true;
HXDLIN(  34)				nextImage->mask = v3;
            			}
HXDLIN(  34)			return nextImage;
            		}
HXDLIN(  34)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC8(TransformImage_Impl__obj,flippedY,return )

 ::pi_xy::ImageStruct TransformImage_Impl__obj::spunClock90( ::pi_xy::ImageStruct this1,Float x,Float y,Float w,Float h,::hx::Null< bool >  __o_transparent,::hx::Null< bool >  __o_includeMask){
            		bool transparent = __o_transparent.Default(false);
            		bool includeMask = __o_includeMask.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_68d25436a32dba6f_43_spunClock90)
HXDLIN(  43)		Float r_x = x;
HXDLIN(  43)		Float r_y = y;
HXDLIN(  43)		Float r_w = w;
HXDLIN(  43)		Float r_h = h;
HXDLIN(  43)		int xmax = ::Std_obj::_hx_int(((r_x + r_w) + 1));
HXDLIN(  43)		int ymax = ::Std_obj::_hx_int(((r_y + r_h) + 1));
HXDLIN(  43)		int ii_min = ::Std_obj::_hx_int(r_x);
HXDLIN(  43)		int ii_max = xmax;
HXDLIN(  43)		int xRange__start = ii_min;
HXDLIN(  43)		int xRange__max = ii_max;
HXDLIN(  43)		int ii_min1 = ::Std_obj::_hx_int(r_y);
HXDLIN(  43)		int ii_max1 = ymax;
HXDLIN(  43)		int yRange__start = ii_min1;
HXDLIN(  43)		int yRange__max = ii_max1;
HXDLIN(  43)		int range_x = xRange__start;
HXDLIN(  43)		int range_y = (yRange__start - 1);
HXDLIN(  43)		int range_xReset = range_x;
HXDLIN(  43)		int range_yReset = range_y;
HXDLIN(  43)		int range_xMax = (xRange__max - 2);
HXDLIN(  43)		int range_yMax = (yRange__max - 2);
HXDLIN(  43)		int _this_min = 0;
HXDLIN(  43)		int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXDLIN(  43)		int width = ::Std_obj::_hx_int(w);
HXDLIN(  43)		int height = ::Std_obj::_hx_int(h);
HXDLIN(  43)		 ::Dynamic imageType = null();
HXDLIN(  43)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  43)		if (::hx::IsNull( imageType )) {
HXLINE(  54)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXLINE(  43)		::Dynamic _hx_tmp;
HXDLIN(  43)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXDLIN(  43)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  43)				 ::iterMagic::BytesImg b = byt;
HXDLIN(  43)				{
HXDLIN(  43)					b->width = width;
HXDLIN(  43)					b->height = height;
HXDLIN(  43)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  43)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  43)					{
HXDLIN(  43)						int len = b->length;
HXDLIN(  43)						int w1 = 0;
HXDLIN(  43)						{
HXDLIN(  43)							int _g = 0;
HXDLIN(  43)							int _g1 = b->height;
HXDLIN(  43)							while((_g < _g1)){
HXDLIN(  43)								_g = (_g + 1);
HXDLIN(  43)								int y1 = (_g - 1);
HXDLIN(  43)								{
HXDLIN(  43)									int _g2 = 0;
HXDLIN(  43)									int _g3 = b->width;
HXDLIN(  43)									while((_g2 < _g3)){
HXDLIN(  43)										_g2 = (_g2 + 1);
HXDLIN(  43)										int x1 = (_g2 - 1);
HXDLIN(  43)										{
HXDLIN(  43)											w1 = (w1 + 1);
HXDLIN(  43)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  43)										{
HXDLIN(  43)											w1 = (w1 + 1);
HXDLIN(  43)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  43)										{
HXDLIN(  43)											w1 = (w1 + 1);
HXDLIN(  43)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  43)										{
HXDLIN(  43)											w1 = (w1 + 1);
HXDLIN(  43)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  43)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXDLIN(  43)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  43)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  43)				{
HXDLIN(  43)					a->width = width;
HXDLIN(  43)					a->height = height;
HXDLIN(  43)					a->data = ::Array_obj< int >::__new(0);
HXDLIN(  43)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  43)					{
HXDLIN(  43)						int _g4 = 0;
HXDLIN(  43)						int _g5 = a->length;
HXDLIN(  43)						while((_g4 < _g5)){
HXDLIN(  43)							_g4 = (_g4 + 1);
HXDLIN(  43)							int i = (_g4 - 1);
HXDLIN(  43)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN(  43)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXDLIN(  43)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  43)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  43)				{
HXDLIN(  43)					b1->width = width;
HXDLIN(  43)					b1->height = height;
HXDLIN(  43)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  43)					int size = (b1->length * 4);
HXDLIN(  43)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  43)					{
HXDLIN(  43)						int _g6 = 0;
HXDLIN(  43)						int _g7 = b1->length;
HXDLIN(  43)						while((_g6 < _g7)){
HXDLIN(  43)							_g6 = (_g6 + 1);
HXDLIN(  43)							int i1 = (_g6 - 1);
HXDLIN(  43)							{
HXDLIN(  43)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  43)								bool _hx_tmp1;
HXDLIN(  43)								if ((i1 >= 0)) {
HXDLIN(  43)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXDLIN(  43)									_hx_tmp1 = false;
            								}
HXDLIN(  43)								if (_hx_tmp1) {
HXDLIN(  43)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  43)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  43)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  43)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  43)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  43)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(  43)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXDLIN(  43)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  43)				 ::iterMagic::VecIntImg v = vec;
HXDLIN(  43)				{
HXDLIN(  43)					v->width = width;
HXDLIN(  43)					v->height = height;
HXDLIN(  43)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  43)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  43)					{
HXDLIN(  43)						int _g8 = 0;
HXDLIN(  43)						int _g9 = v->length;
HXDLIN(  43)						while((_g8 < _g9)){
HXDLIN(  43)							_g8 = (_g8 + 1);
HXDLIN(  43)							int i2 = (_g8 - 1);
HXDLIN(  43)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN(  43)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXDLIN(  43)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  43)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  43)				{
HXDLIN(  43)					b2->width = width;
HXDLIN(  43)					b2->height = height;
HXDLIN(  43)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  43)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  43)					{
HXDLIN(  43)						int len1 = b2->length;
HXDLIN(  43)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  43)						if (::hx::IsNull( d->head )) {
HXDLIN(  43)							int _g10 = 0;
HXDLIN(  43)							int _g11 = len1;
HXDLIN(  43)							while((_g10 < _g11)){
HXDLIN(  43)								_g10 = (_g10 + 1);
HXDLIN(  43)								int i3 = (_g10 - 1);
HXDLIN(  43)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXDLIN(  43)							int _g12 = 0;
HXDLIN(  43)							int _g13 = len1;
HXDLIN(  43)							while((_g12 < _g13)){
HXDLIN(  43)								_g12 = (_g12 + 1);
HXDLIN(  43)								int i4 = (_g12 - 1);
HXDLIN(  43)								{
HXDLIN(  43)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  43)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  43)									{
HXDLIN(  43)										int _g14 = 0;
HXDLIN(  43)										int _g15 = i4;
HXDLIN(  43)										while((_g14 < _g15)){
HXDLIN(  43)											_g14 = (_g14 + 1);
HXDLIN(  43)											int i5 = (_g14 - 1);
HXLINE( 345)											prev = l;
HXLINE( 346)											l = l->next;
            										}
            									}
HXLINE(  43)									if (::hx::IsNull( prev )) {
HXDLIN(  43)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  43)										l = null();
            									}
            									else {
HXDLIN(  43)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  43)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  43)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN(  43)		this2->image = _hx_tmp;
HXDLIN(  43)		this2->width = width;
HXDLIN(  43)		this2->height = height;
HXDLIN(  43)		this2->imageType = ( (int)(imageType) );
HXDLIN(  43)		 ::pi_xy::ImageStruct nextImage = this2;
HXDLIN(  43)		nextImage->transparent = transparent;
HXDLIN(  43)		while((_this_min < _this_max)){
HXDLIN(  43)			_this_min = (_this_min + 1);
HXDLIN(  43)			int i6 = (_this_min - 1);
HXDLIN(  43)			if ((range_y > range_yMax)) {
HXDLIN(  43)				range_y = range_yReset;
HXDLIN(  43)				range_x = (range_x + 1);
            			}
HXDLIN(  43)			range_y = (range_y + 1);
HXDLIN(  43)			int i7 = i6;
HXDLIN(  43)			{
HXDLIN(  43)				int x2 = (range_yMax - range_y);
HXDLIN(  43)				int y2 = range_x;
HXDLIN(  43)				int x3 = range_x;
HXDLIN(  43)				int y3 = range_y;
HXDLIN(  43)				::Dynamic this4 = this1->image;
HXDLIN(  43)				int index;
HXDLIN(  43)				if (this1->useVirtualPos) {
HXDLIN(  43)					index = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            				}
            				else {
HXDLIN(  43)					index = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            				}
HXDLIN(  43)				int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN(  43)				int color;
HXDLIN(  43)				if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  43)					color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            				}
            				else {
HXDLIN(  43)					color = c;
            				}
HXDLIN(  43)				int c1 = color;
HXDLIN(  43)				bool _hx_tmp2;
HXDLIN(  43)				if ((((c1 >> 24) & 255) < 254)) {
HXDLIN(  43)					_hx_tmp2 = nextImage->transparent;
            				}
            				else {
HXDLIN(  43)					_hx_tmp2 = false;
            				}
HXDLIN(  43)				if (_hx_tmp2) {
HXDLIN(  43)					int location;
HXDLIN(  43)					if (nextImage->useVirtualPos) {
HXDLIN(  43)						location = ::Std_obj::_hx_int(((((( (Float)(y2) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x2) - nextImage->virtualX));
            					}
            					else {
HXDLIN(  43)						location = ::Std_obj::_hx_int(( (Float)(((y2 * nextImage->width) + x2)) ));
            					}
HXDLIN(  43)					int this5 = ::iterMagic::Iimg_obj::get(nextImage->image,location);
HXDLIN(  43)					int this6;
HXDLIN(  43)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  43)						this6 = ((((((this5 >> 24) & 255) << 24) | ((this5 & 255) << 16)) | (((this5 >> 8) & 255) << 8)) | ((this5 >> 16) & 255));
            					}
            					else {
HXDLIN(  43)						this6 = this5;
            					}
HXDLIN(  43)					Float a1;
HXDLIN(  43)					int this7 = ((this6 >> 24) & 255);
HXDLIN(  43)					if ((this7 == 0)) {
HXDLIN(  43)						a1 = ((Float)0.);
            					}
            					else {
HXDLIN(  43)						a1 = (( (Float)(this7) ) / ( (Float)(255) ));
            					}
HXDLIN(  43)					Float r1;
HXDLIN(  43)					int this8 = ((this6 >> 16) & 255);
HXDLIN(  43)					if ((this8 == 0)) {
HXDLIN(  43)						r1 = ((Float)0.);
            					}
            					else {
HXDLIN(  43)						r1 = (( (Float)(this8) ) / ( (Float)(255) ));
            					}
HXDLIN(  43)					Float g1;
HXDLIN(  43)					int this9 = ((this6 >> 8) & 255);
HXDLIN(  43)					if ((this9 == 0)) {
HXDLIN(  43)						g1 = ((Float)0.);
            					}
            					else {
HXDLIN(  43)						g1 = (( (Float)(this9) ) / ( (Float)(255) ));
            					}
HXDLIN(  43)					Float b11;
HXDLIN(  43)					int this10 = (this6 & 255);
HXDLIN(  43)					if ((this10 == 0)) {
HXDLIN(  43)						b11 = ((Float)0.);
            					}
            					else {
HXDLIN(  43)						b11 = (( (Float)(this10) ) / ( (Float)(255) ));
            					}
HXDLIN(  43)					Float a2;
HXDLIN(  43)					int this11 = ((color >> 24) & 255);
HXDLIN(  43)					if ((this11 == 0)) {
HXDLIN(  43)						a2 = ((Float)0.);
            					}
            					else {
HXDLIN(  43)						a2 = (( (Float)(this11) ) / ( (Float)(255) ));
            					}
HXDLIN(  43)					Float r2;
HXDLIN(  43)					int this12 = ((color >> 16) & 255);
HXDLIN(  43)					if ((this12 == 0)) {
HXDLIN(  43)						r2 = ((Float)0.);
            					}
            					else {
HXDLIN(  43)						r2 = (( (Float)(this12) ) / ( (Float)(255) ));
            					}
HXDLIN(  43)					Float g2;
HXDLIN(  43)					int this13 = ((color >> 8) & 255);
HXDLIN(  43)					if ((this13 == 0)) {
HXDLIN(  43)						g2 = ((Float)0.);
            					}
            					else {
HXDLIN(  43)						g2 = (( (Float)(this13) ) / ( (Float)(255) ));
            					}
HXDLIN(  43)					Float b21;
HXDLIN(  43)					int this14 = (color & 255);
HXDLIN(  43)					if ((this14 == 0)) {
HXDLIN(  43)						b21 = ((Float)0.);
            					}
            					else {
HXDLIN(  43)						b21 = (( (Float)(this14) ) / ( (Float)(255) ));
            					}
HXDLIN(  43)					Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  43)					int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  43)					int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  43)					int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  43)					int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  43)					int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  43)					{
HXDLIN(  43)						int _hx_tmp3;
HXDLIN(  43)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  43)							_hx_tmp3 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            						}
            						else {
HXDLIN(  43)							_hx_tmp3 = blended;
            						}
HXDLIN(  43)						::iterMagic::Iimg_obj::set(nextImage->image,location,_hx_tmp3);
            					}
            				}
            				else {
HXDLIN(  43)					::Dynamic this15 = nextImage->image;
HXDLIN(  43)					int index1;
HXDLIN(  43)					if (nextImage->useVirtualPos) {
HXDLIN(  43)						index1 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x2) - nextImage->virtualX));
            					}
            					else {
HXDLIN(  43)						index1 = ::Std_obj::_hx_int(( (Float)(((y2 * nextImage->width) + x2)) ));
            					}
HXDLIN(  43)					int _hx_tmp4;
HXDLIN(  43)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  43)						_hx_tmp4 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            					}
            					else {
HXDLIN(  43)						_hx_tmp4 = c1;
            					}
HXDLIN(  43)					::iterMagic::Iimg_obj::set(this15,index1,_hx_tmp4);
            				}
            			}
            		}
HXDLIN(  43)		bool _hx_tmp5;
HXDLIN(  43)		if (::hx::IsNotNull( this1->mask )) {
HXDLIN(  43)			_hx_tmp5 = includeMask;
            		}
            		else {
HXDLIN(  43)			_hx_tmp5 = false;
            		}
HXDLIN(  43)		if (_hx_tmp5) {
HXDLIN(  43)			 ::pi_xy::ImageStruct v1 = ::pi_xy::transformation::_SpinImage::SpinImage_Fields__obj::spinClock90(this1->mask,x,y,w,h,this1->mask->transparent,includeMask);
HXDLIN(  43)			nextImage->useMask = true;
HXDLIN(  43)			nextImage->mask = v1;
            		}
HXDLIN(  43)		return nextImage;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(TransformImage_Impl__obj,spunClock90,return )

 ::pi_xy::ImageStruct TransformImage_Impl__obj::spunAntiClock90( ::pi_xy::ImageStruct this1,Float x,Float y,Float w,Float h,::hx::Null< bool >  __o_transparent,::hx::Null< bool >  __o_includeMask){
            		bool transparent = __o_transparent.Default(false);
            		bool includeMask = __o_includeMask.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_68d25436a32dba6f_49_spunAntiClock90)
HXDLIN(  49)		Float r_x = x;
HXDLIN(  49)		Float r_y = y;
HXDLIN(  49)		Float r_w = w;
HXDLIN(  49)		Float r_h = h;
HXDLIN(  49)		int xmax = ::Std_obj::_hx_int(((r_x + r_w) + 1));
HXDLIN(  49)		int ymax = ::Std_obj::_hx_int(((r_y + r_h) + 1));
HXDLIN(  49)		int ii_min = ::Std_obj::_hx_int(r_x);
HXDLIN(  49)		int ii_max = xmax;
HXDLIN(  49)		int xRange__start = ii_min;
HXDLIN(  49)		int xRange__max = ii_max;
HXDLIN(  49)		int ii_min1 = ::Std_obj::_hx_int(r_y);
HXDLIN(  49)		int ii_max1 = ymax;
HXDLIN(  49)		int yRange__start = ii_min1;
HXDLIN(  49)		int yRange__max = ii_max1;
HXDLIN(  49)		int range_x = xRange__start;
HXDLIN(  49)		int range_y = (yRange__start - 1);
HXDLIN(  49)		int range_xReset = range_x;
HXDLIN(  49)		int range_yReset = range_y;
HXDLIN(  49)		int range_xMax = (xRange__max - 2);
HXDLIN(  49)		int range_yMax = (yRange__max - 2);
HXDLIN(  49)		int _this_min = 0;
HXDLIN(  49)		int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXDLIN(  49)		int width = ::Std_obj::_hx_int(w);
HXDLIN(  49)		int height = ::Std_obj::_hx_int(h);
HXDLIN(  49)		 ::Dynamic imageType = null();
HXDLIN(  49)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  49)		if (::hx::IsNull( imageType )) {
HXLINE(  54)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXLINE(  49)		::Dynamic _hx_tmp;
HXDLIN(  49)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXDLIN(  49)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  49)				 ::iterMagic::BytesImg b = byt;
HXDLIN(  49)				{
HXDLIN(  49)					b->width = width;
HXDLIN(  49)					b->height = height;
HXDLIN(  49)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  49)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  49)					{
HXDLIN(  49)						int len = b->length;
HXDLIN(  49)						int w1 = 0;
HXDLIN(  49)						{
HXDLIN(  49)							int _g = 0;
HXDLIN(  49)							int _g1 = b->height;
HXDLIN(  49)							while((_g < _g1)){
HXDLIN(  49)								_g = (_g + 1);
HXDLIN(  49)								int y1 = (_g - 1);
HXDLIN(  49)								{
HXDLIN(  49)									int _g2 = 0;
HXDLIN(  49)									int _g3 = b->width;
HXDLIN(  49)									while((_g2 < _g3)){
HXDLIN(  49)										_g2 = (_g2 + 1);
HXDLIN(  49)										int x1 = (_g2 - 1);
HXDLIN(  49)										{
HXDLIN(  49)											w1 = (w1 + 1);
HXDLIN(  49)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  49)										{
HXDLIN(  49)											w1 = (w1 + 1);
HXDLIN(  49)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  49)										{
HXDLIN(  49)											w1 = (w1 + 1);
HXDLIN(  49)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  49)										{
HXDLIN(  49)											w1 = (w1 + 1);
HXDLIN(  49)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  49)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXDLIN(  49)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  49)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  49)				{
HXDLIN(  49)					a->width = width;
HXDLIN(  49)					a->height = height;
HXDLIN(  49)					a->data = ::Array_obj< int >::__new(0);
HXDLIN(  49)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  49)					{
HXDLIN(  49)						int _g4 = 0;
HXDLIN(  49)						int _g5 = a->length;
HXDLIN(  49)						while((_g4 < _g5)){
HXDLIN(  49)							_g4 = (_g4 + 1);
HXDLIN(  49)							int i = (_g4 - 1);
HXDLIN(  49)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN(  49)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXDLIN(  49)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  49)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  49)				{
HXDLIN(  49)					b1->width = width;
HXDLIN(  49)					b1->height = height;
HXDLIN(  49)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  49)					int size = (b1->length * 4);
HXDLIN(  49)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  49)					{
HXDLIN(  49)						int _g6 = 0;
HXDLIN(  49)						int _g7 = b1->length;
HXDLIN(  49)						while((_g6 < _g7)){
HXDLIN(  49)							_g6 = (_g6 + 1);
HXDLIN(  49)							int i1 = (_g6 - 1);
HXDLIN(  49)							{
HXDLIN(  49)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  49)								bool _hx_tmp1;
HXDLIN(  49)								if ((i1 >= 0)) {
HXDLIN(  49)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXDLIN(  49)									_hx_tmp1 = false;
            								}
HXDLIN(  49)								if (_hx_tmp1) {
HXDLIN(  49)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  49)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  49)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  49)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  49)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  49)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(  49)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXDLIN(  49)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  49)				 ::iterMagic::VecIntImg v = vec;
HXDLIN(  49)				{
HXDLIN(  49)					v->width = width;
HXDLIN(  49)					v->height = height;
HXDLIN(  49)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  49)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  49)					{
HXDLIN(  49)						int _g8 = 0;
HXDLIN(  49)						int _g9 = v->length;
HXDLIN(  49)						while((_g8 < _g9)){
HXDLIN(  49)							_g8 = (_g8 + 1);
HXDLIN(  49)							int i2 = (_g8 - 1);
HXDLIN(  49)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN(  49)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXDLIN(  49)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  49)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  49)				{
HXDLIN(  49)					b2->width = width;
HXDLIN(  49)					b2->height = height;
HXDLIN(  49)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  49)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  49)					{
HXDLIN(  49)						int len1 = b2->length;
HXDLIN(  49)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  49)						if (::hx::IsNull( d->head )) {
HXDLIN(  49)							int _g10 = 0;
HXDLIN(  49)							int _g11 = len1;
HXDLIN(  49)							while((_g10 < _g11)){
HXDLIN(  49)								_g10 = (_g10 + 1);
HXDLIN(  49)								int i3 = (_g10 - 1);
HXDLIN(  49)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXDLIN(  49)							int _g12 = 0;
HXDLIN(  49)							int _g13 = len1;
HXDLIN(  49)							while((_g12 < _g13)){
HXDLIN(  49)								_g12 = (_g12 + 1);
HXDLIN(  49)								int i4 = (_g12 - 1);
HXDLIN(  49)								{
HXDLIN(  49)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  49)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  49)									{
HXDLIN(  49)										int _g14 = 0;
HXDLIN(  49)										int _g15 = i4;
HXDLIN(  49)										while((_g14 < _g15)){
HXDLIN(  49)											_g14 = (_g14 + 1);
HXDLIN(  49)											int i5 = (_g14 - 1);
HXLINE( 345)											prev = l;
HXLINE( 346)											l = l->next;
            										}
            									}
HXLINE(  49)									if (::hx::IsNull( prev )) {
HXDLIN(  49)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  49)										l = null();
            									}
            									else {
HXDLIN(  49)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  49)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  49)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN(  49)		this2->image = _hx_tmp;
HXDLIN(  49)		this2->width = width;
HXDLIN(  49)		this2->height = height;
HXDLIN(  49)		this2->imageType = ( (int)(imageType) );
HXDLIN(  49)		 ::pi_xy::ImageStruct nextImage = this2;
HXDLIN(  49)		nextImage->transparent = transparent;
HXDLIN(  49)		while((_this_min < _this_max)){
HXDLIN(  49)			_this_min = (_this_min + 1);
HXDLIN(  49)			int i6 = (_this_min - 1);
HXDLIN(  49)			if ((range_y > range_yMax)) {
HXDLIN(  49)				range_y = range_yReset;
HXDLIN(  49)				range_x = (range_x + 1);
            			}
HXDLIN(  49)			range_y = (range_y + 1);
HXDLIN(  49)			int i7 = i6;
HXDLIN(  49)			{
HXDLIN(  49)				int x2 = range_y;
HXDLIN(  49)				int y2 = (range_xMax - range_x);
HXDLIN(  49)				int x3 = range_y;
HXDLIN(  49)				int y3 = range_x;
HXDLIN(  49)				::Dynamic this4 = this1->image;
HXDLIN(  49)				int index;
HXDLIN(  49)				if (this1->useVirtualPos) {
HXDLIN(  49)					index = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            				}
            				else {
HXDLIN(  49)					index = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            				}
HXDLIN(  49)				int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN(  49)				int color;
HXDLIN(  49)				if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)					color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            				}
            				else {
HXDLIN(  49)					color = c;
            				}
HXDLIN(  49)				int c1 = color;
HXDLIN(  49)				bool _hx_tmp2;
HXDLIN(  49)				if ((((c1 >> 24) & 255) < 254)) {
HXDLIN(  49)					_hx_tmp2 = nextImage->transparent;
            				}
            				else {
HXDLIN(  49)					_hx_tmp2 = false;
            				}
HXDLIN(  49)				if (_hx_tmp2) {
HXDLIN(  49)					int location;
HXDLIN(  49)					if (nextImage->useVirtualPos) {
HXDLIN(  49)						location = ::Std_obj::_hx_int(((((( (Float)(y2) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x2) - nextImage->virtualX));
            					}
            					else {
HXDLIN(  49)						location = ::Std_obj::_hx_int(( (Float)(((y2 * nextImage->width) + x2)) ));
            					}
HXDLIN(  49)					int this5 = ::iterMagic::Iimg_obj::get(nextImage->image,location);
HXDLIN(  49)					int this6;
HXDLIN(  49)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)						this6 = ((((((this5 >> 24) & 255) << 24) | ((this5 & 255) << 16)) | (((this5 >> 8) & 255) << 8)) | ((this5 >> 16) & 255));
            					}
            					else {
HXDLIN(  49)						this6 = this5;
            					}
HXDLIN(  49)					Float a1;
HXDLIN(  49)					int this7 = ((this6 >> 24) & 255);
HXDLIN(  49)					if ((this7 == 0)) {
HXDLIN(  49)						a1 = ((Float)0.);
            					}
            					else {
HXDLIN(  49)						a1 = (( (Float)(this7) ) / ( (Float)(255) ));
            					}
HXDLIN(  49)					Float r1;
HXDLIN(  49)					int this8 = ((this6 >> 16) & 255);
HXDLIN(  49)					if ((this8 == 0)) {
HXDLIN(  49)						r1 = ((Float)0.);
            					}
            					else {
HXDLIN(  49)						r1 = (( (Float)(this8) ) / ( (Float)(255) ));
            					}
HXDLIN(  49)					Float g1;
HXDLIN(  49)					int this9 = ((this6 >> 8) & 255);
HXDLIN(  49)					if ((this9 == 0)) {
HXDLIN(  49)						g1 = ((Float)0.);
            					}
            					else {
HXDLIN(  49)						g1 = (( (Float)(this9) ) / ( (Float)(255) ));
            					}
HXDLIN(  49)					Float b11;
HXDLIN(  49)					int this10 = (this6 & 255);
HXDLIN(  49)					if ((this10 == 0)) {
HXDLIN(  49)						b11 = ((Float)0.);
            					}
            					else {
HXDLIN(  49)						b11 = (( (Float)(this10) ) / ( (Float)(255) ));
            					}
HXDLIN(  49)					Float a2;
HXDLIN(  49)					int this11 = ((color >> 24) & 255);
HXDLIN(  49)					if ((this11 == 0)) {
HXDLIN(  49)						a2 = ((Float)0.);
            					}
            					else {
HXDLIN(  49)						a2 = (( (Float)(this11) ) / ( (Float)(255) ));
            					}
HXDLIN(  49)					Float r2;
HXDLIN(  49)					int this12 = ((color >> 16) & 255);
HXDLIN(  49)					if ((this12 == 0)) {
HXDLIN(  49)						r2 = ((Float)0.);
            					}
            					else {
HXDLIN(  49)						r2 = (( (Float)(this12) ) / ( (Float)(255) ));
            					}
HXDLIN(  49)					Float g2;
HXDLIN(  49)					int this13 = ((color >> 8) & 255);
HXDLIN(  49)					if ((this13 == 0)) {
HXDLIN(  49)						g2 = ((Float)0.);
            					}
            					else {
HXDLIN(  49)						g2 = (( (Float)(this13) ) / ( (Float)(255) ));
            					}
HXDLIN(  49)					Float b21;
HXDLIN(  49)					int this14 = (color & 255);
HXDLIN(  49)					if ((this14 == 0)) {
HXDLIN(  49)						b21 = ((Float)0.);
            					}
            					else {
HXDLIN(  49)						b21 = (( (Float)(this14) ) / ( (Float)(255) ));
            					}
HXDLIN(  49)					Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  49)					int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  49)					int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  49)					int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  49)					int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  49)					int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  49)					{
HXDLIN(  49)						int _hx_tmp3;
HXDLIN(  49)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)							_hx_tmp3 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            						}
            						else {
HXDLIN(  49)							_hx_tmp3 = blended;
            						}
HXDLIN(  49)						::iterMagic::Iimg_obj::set(nextImage->image,location,_hx_tmp3);
            					}
            				}
            				else {
HXDLIN(  49)					::Dynamic this15 = nextImage->image;
HXDLIN(  49)					int index1;
HXDLIN(  49)					if (nextImage->useVirtualPos) {
HXDLIN(  49)						index1 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x2) - nextImage->virtualX));
            					}
            					else {
HXDLIN(  49)						index1 = ::Std_obj::_hx_int(( (Float)(((y2 * nextImage->width) + x2)) ));
            					}
HXDLIN(  49)					int _hx_tmp4;
HXDLIN(  49)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  49)						_hx_tmp4 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            					}
            					else {
HXDLIN(  49)						_hx_tmp4 = c1;
            					}
HXDLIN(  49)					::iterMagic::Iimg_obj::set(this15,index1,_hx_tmp4);
            				}
            			}
            		}
HXDLIN(  49)		bool _hx_tmp5;
HXDLIN(  49)		if (::hx::IsNotNull( this1->mask )) {
HXDLIN(  49)			_hx_tmp5 = includeMask;
            		}
            		else {
HXDLIN(  49)			_hx_tmp5 = false;
            		}
HXDLIN(  49)		if (_hx_tmp5) {
HXDLIN(  49)			 ::pi_xy::ImageStruct v1 = ::pi_xy::transformation::_SpinImage::SpinImage_Fields__obj::spinAntiClock90(this1->mask,x,y,w,h,this1->mask->transparent,includeMask);
HXDLIN(  49)			nextImage->useMask = true;
HXDLIN(  49)			nextImage->mask = v1;
            		}
HXDLIN(  49)		return nextImage;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(TransformImage_Impl__obj,spunAntiClock90,return )

 ::pi_xy::ImageStruct TransformImage_Impl__obj::spun180( ::pi_xy::ImageStruct this1,Float x,Float y,Float w,Float h,::hx::Null< bool >  __o_transparent,::hx::Null< bool >  __o_includeMask){
            		bool transparent = __o_transparent.Default(false);
            		bool includeMask = __o_includeMask.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_68d25436a32dba6f_55_spun180)
HXDLIN(  55)		Float r_x = x;
HXDLIN(  55)		Float r_y = y;
HXDLIN(  55)		Float r_w = w;
HXDLIN(  55)		Float r_h = h;
HXDLIN(  55)		int xmax = ::Std_obj::_hx_int(((r_x + r_w) + 1));
HXDLIN(  55)		int ymax = ::Std_obj::_hx_int(((r_y + r_h) + 1));
HXDLIN(  55)		int ii_min = ::Std_obj::_hx_int(r_x);
HXDLIN(  55)		int ii_max = xmax;
HXDLIN(  55)		int xRange__start = ii_min;
HXDLIN(  55)		int xRange__max = ii_max;
HXDLIN(  55)		int ii_min1 = ::Std_obj::_hx_int(r_y);
HXDLIN(  55)		int ii_max1 = ymax;
HXDLIN(  55)		int yRange__start = ii_min1;
HXDLIN(  55)		int yRange__max = ii_max1;
HXDLIN(  55)		int range_x = xRange__start;
HXDLIN(  55)		int range_y = (yRange__start - 1);
HXDLIN(  55)		int range_xReset = range_x;
HXDLIN(  55)		int range_yReset = range_y;
HXDLIN(  55)		int range_xMax = (xRange__max - 2);
HXDLIN(  55)		int range_yMax = (yRange__max - 2);
HXDLIN(  55)		int _this_min = 0;
HXDLIN(  55)		int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXDLIN(  55)		int width = ::Std_obj::_hx_int(w);
HXDLIN(  55)		int height = ::Std_obj::_hx_int(h);
HXDLIN(  55)		 ::Dynamic imageType = null();
HXDLIN(  55)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  55)		if (::hx::IsNull( imageType )) {
HXLINE(  54)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXLINE(  55)		::Dynamic _hx_tmp;
HXDLIN(  55)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXDLIN(  55)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  55)				 ::iterMagic::BytesImg b = byt;
HXDLIN(  55)				{
HXDLIN(  55)					b->width = width;
HXDLIN(  55)					b->height = height;
HXDLIN(  55)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  55)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  55)					{
HXDLIN(  55)						int len = b->length;
HXDLIN(  55)						int w1 = 0;
HXDLIN(  55)						{
HXDLIN(  55)							int _g = 0;
HXDLIN(  55)							int _g1 = b->height;
HXDLIN(  55)							while((_g < _g1)){
HXDLIN(  55)								_g = (_g + 1);
HXDLIN(  55)								int y1 = (_g - 1);
HXDLIN(  55)								{
HXDLIN(  55)									int _g2 = 0;
HXDLIN(  55)									int _g3 = b->width;
HXDLIN(  55)									while((_g2 < _g3)){
HXDLIN(  55)										_g2 = (_g2 + 1);
HXDLIN(  55)										int x1 = (_g2 - 1);
HXDLIN(  55)										{
HXDLIN(  55)											w1 = (w1 + 1);
HXDLIN(  55)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  55)										{
HXDLIN(  55)											w1 = (w1 + 1);
HXDLIN(  55)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  55)										{
HXDLIN(  55)											w1 = (w1 + 1);
HXDLIN(  55)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  55)										{
HXDLIN(  55)											w1 = (w1 + 1);
HXDLIN(  55)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  55)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXDLIN(  55)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  55)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  55)				{
HXDLIN(  55)					a->width = width;
HXDLIN(  55)					a->height = height;
HXDLIN(  55)					a->data = ::Array_obj< int >::__new(0);
HXDLIN(  55)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  55)					{
HXDLIN(  55)						int _g4 = 0;
HXDLIN(  55)						int _g5 = a->length;
HXDLIN(  55)						while((_g4 < _g5)){
HXDLIN(  55)							_g4 = (_g4 + 1);
HXDLIN(  55)							int i = (_g4 - 1);
HXDLIN(  55)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN(  55)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXDLIN(  55)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  55)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  55)				{
HXDLIN(  55)					b1->width = width;
HXDLIN(  55)					b1->height = height;
HXDLIN(  55)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  55)					int size = (b1->length * 4);
HXDLIN(  55)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  55)					{
HXDLIN(  55)						int _g6 = 0;
HXDLIN(  55)						int _g7 = b1->length;
HXDLIN(  55)						while((_g6 < _g7)){
HXDLIN(  55)							_g6 = (_g6 + 1);
HXDLIN(  55)							int i1 = (_g6 - 1);
HXDLIN(  55)							{
HXDLIN(  55)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  55)								bool _hx_tmp1;
HXDLIN(  55)								if ((i1 >= 0)) {
HXDLIN(  55)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXDLIN(  55)									_hx_tmp1 = false;
            								}
HXDLIN(  55)								if (_hx_tmp1) {
HXDLIN(  55)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  55)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  55)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  55)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  55)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  55)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(  55)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXDLIN(  55)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  55)				 ::iterMagic::VecIntImg v = vec;
HXDLIN(  55)				{
HXDLIN(  55)					v->width = width;
HXDLIN(  55)					v->height = height;
HXDLIN(  55)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  55)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  55)					{
HXDLIN(  55)						int _g8 = 0;
HXDLIN(  55)						int _g9 = v->length;
HXDLIN(  55)						while((_g8 < _g9)){
HXDLIN(  55)							_g8 = (_g8 + 1);
HXDLIN(  55)							int i2 = (_g8 - 1);
HXDLIN(  55)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN(  55)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXDLIN(  55)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  55)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  55)				{
HXDLIN(  55)					b2->width = width;
HXDLIN(  55)					b2->height = height;
HXDLIN(  55)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  55)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  55)					{
HXDLIN(  55)						int len1 = b2->length;
HXDLIN(  55)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  55)						if (::hx::IsNull( d->head )) {
HXDLIN(  55)							int _g10 = 0;
HXDLIN(  55)							int _g11 = len1;
HXDLIN(  55)							while((_g10 < _g11)){
HXDLIN(  55)								_g10 = (_g10 + 1);
HXDLIN(  55)								int i3 = (_g10 - 1);
HXDLIN(  55)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXDLIN(  55)							int _g12 = 0;
HXDLIN(  55)							int _g13 = len1;
HXDLIN(  55)							while((_g12 < _g13)){
HXDLIN(  55)								_g12 = (_g12 + 1);
HXDLIN(  55)								int i4 = (_g12 - 1);
HXDLIN(  55)								{
HXDLIN(  55)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  55)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  55)									{
HXDLIN(  55)										int _g14 = 0;
HXDLIN(  55)										int _g15 = i4;
HXDLIN(  55)										while((_g14 < _g15)){
HXDLIN(  55)											_g14 = (_g14 + 1);
HXDLIN(  55)											int i5 = (_g14 - 1);
HXLINE( 345)											prev = l;
HXLINE( 346)											l = l->next;
            										}
            									}
HXLINE(  55)									if (::hx::IsNull( prev )) {
HXDLIN(  55)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  55)										l = null();
            									}
            									else {
HXDLIN(  55)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  55)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  55)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN(  55)		this2->image = _hx_tmp;
HXDLIN(  55)		this2->width = width;
HXDLIN(  55)		this2->height = height;
HXDLIN(  55)		this2->imageType = ( (int)(imageType) );
HXDLIN(  55)		 ::pi_xy::ImageStruct nextImage = this2;
HXDLIN(  55)		nextImage->transparent = transparent;
HXDLIN(  55)		while((_this_min < _this_max)){
HXDLIN(  55)			_this_min = (_this_min + 1);
HXDLIN(  55)			int i6 = (_this_min - 1);
HXDLIN(  55)			if ((range_y > range_yMax)) {
HXDLIN(  55)				range_y = range_yReset;
HXDLIN(  55)				range_x = (range_x + 1);
            			}
HXDLIN(  55)			range_y = (range_y + 1);
HXDLIN(  55)			int i7 = i6;
HXDLIN(  55)			{
HXDLIN(  55)				int x2 = (range_xMax - range_x);
HXDLIN(  55)				int y2 = (range_yMax - range_y);
HXDLIN(  55)				int x3 = range_x;
HXDLIN(  55)				int y3 = range_y;
HXDLIN(  55)				::Dynamic this4 = this1->image;
HXDLIN(  55)				int index;
HXDLIN(  55)				if (this1->useVirtualPos) {
HXDLIN(  55)					index = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            				}
            				else {
HXDLIN(  55)					index = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            				}
HXDLIN(  55)				int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN(  55)				int color;
HXDLIN(  55)				if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  55)					color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            				}
            				else {
HXDLIN(  55)					color = c;
            				}
HXDLIN(  55)				int c1 = color;
HXDLIN(  55)				bool _hx_tmp2;
HXDLIN(  55)				if ((((c1 >> 24) & 255) < 254)) {
HXDLIN(  55)					_hx_tmp2 = nextImage->transparent;
            				}
            				else {
HXDLIN(  55)					_hx_tmp2 = false;
            				}
HXDLIN(  55)				if (_hx_tmp2) {
HXDLIN(  55)					int location;
HXDLIN(  55)					if (nextImage->useVirtualPos) {
HXDLIN(  55)						location = ::Std_obj::_hx_int(((((( (Float)(y2) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x2) - nextImage->virtualX));
            					}
            					else {
HXDLIN(  55)						location = ::Std_obj::_hx_int(( (Float)(((y2 * nextImage->width) + x2)) ));
            					}
HXDLIN(  55)					int this5 = ::iterMagic::Iimg_obj::get(nextImage->image,location);
HXDLIN(  55)					int this6;
HXDLIN(  55)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  55)						this6 = ((((((this5 >> 24) & 255) << 24) | ((this5 & 255) << 16)) | (((this5 >> 8) & 255) << 8)) | ((this5 >> 16) & 255));
            					}
            					else {
HXDLIN(  55)						this6 = this5;
            					}
HXDLIN(  55)					Float a1;
HXDLIN(  55)					int this7 = ((this6 >> 24) & 255);
HXDLIN(  55)					if ((this7 == 0)) {
HXDLIN(  55)						a1 = ((Float)0.);
            					}
            					else {
HXDLIN(  55)						a1 = (( (Float)(this7) ) / ( (Float)(255) ));
            					}
HXDLIN(  55)					Float r1;
HXDLIN(  55)					int this8 = ((this6 >> 16) & 255);
HXDLIN(  55)					if ((this8 == 0)) {
HXDLIN(  55)						r1 = ((Float)0.);
            					}
            					else {
HXDLIN(  55)						r1 = (( (Float)(this8) ) / ( (Float)(255) ));
            					}
HXDLIN(  55)					Float g1;
HXDLIN(  55)					int this9 = ((this6 >> 8) & 255);
HXDLIN(  55)					if ((this9 == 0)) {
HXDLIN(  55)						g1 = ((Float)0.);
            					}
            					else {
HXDLIN(  55)						g1 = (( (Float)(this9) ) / ( (Float)(255) ));
            					}
HXDLIN(  55)					Float b11;
HXDLIN(  55)					int this10 = (this6 & 255);
HXDLIN(  55)					if ((this10 == 0)) {
HXDLIN(  55)						b11 = ((Float)0.);
            					}
            					else {
HXDLIN(  55)						b11 = (( (Float)(this10) ) / ( (Float)(255) ));
            					}
HXDLIN(  55)					Float a2;
HXDLIN(  55)					int this11 = ((color >> 24) & 255);
HXDLIN(  55)					if ((this11 == 0)) {
HXDLIN(  55)						a2 = ((Float)0.);
            					}
            					else {
HXDLIN(  55)						a2 = (( (Float)(this11) ) / ( (Float)(255) ));
            					}
HXDLIN(  55)					Float r2;
HXDLIN(  55)					int this12 = ((color >> 16) & 255);
HXDLIN(  55)					if ((this12 == 0)) {
HXDLIN(  55)						r2 = ((Float)0.);
            					}
            					else {
HXDLIN(  55)						r2 = (( (Float)(this12) ) / ( (Float)(255) ));
            					}
HXDLIN(  55)					Float g2;
HXDLIN(  55)					int this13 = ((color >> 8) & 255);
HXDLIN(  55)					if ((this13 == 0)) {
HXDLIN(  55)						g2 = ((Float)0.);
            					}
            					else {
HXDLIN(  55)						g2 = (( (Float)(this13) ) / ( (Float)(255) ));
            					}
HXDLIN(  55)					Float b21;
HXDLIN(  55)					int this14 = (color & 255);
HXDLIN(  55)					if ((this14 == 0)) {
HXDLIN(  55)						b21 = ((Float)0.);
            					}
            					else {
HXDLIN(  55)						b21 = (( (Float)(this14) ) / ( (Float)(255) ));
            					}
HXDLIN(  55)					Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  55)					int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  55)					int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  55)					int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  55)					int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  55)					int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  55)					{
HXDLIN(  55)						int _hx_tmp3;
HXDLIN(  55)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  55)							_hx_tmp3 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            						}
            						else {
HXDLIN(  55)							_hx_tmp3 = blended;
            						}
HXDLIN(  55)						::iterMagic::Iimg_obj::set(nextImage->image,location,_hx_tmp3);
            					}
            				}
            				else {
HXDLIN(  55)					::Dynamic this15 = nextImage->image;
HXDLIN(  55)					int index1;
HXDLIN(  55)					if (nextImage->useVirtualPos) {
HXDLIN(  55)						index1 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x2) - nextImage->virtualX));
            					}
            					else {
HXDLIN(  55)						index1 = ::Std_obj::_hx_int(( (Float)(((y2 * nextImage->width) + x2)) ));
            					}
HXDLIN(  55)					int _hx_tmp4;
HXDLIN(  55)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  55)						_hx_tmp4 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            					}
            					else {
HXDLIN(  55)						_hx_tmp4 = c1;
            					}
HXDLIN(  55)					::iterMagic::Iimg_obj::set(this15,index1,_hx_tmp4);
            				}
            			}
            		}
HXDLIN(  55)		bool _hx_tmp5;
HXDLIN(  55)		if (::hx::IsNotNull( this1->mask )) {
HXDLIN(  55)			_hx_tmp5 = includeMask;
            		}
            		else {
HXDLIN(  55)			_hx_tmp5 = false;
            		}
HXDLIN(  55)		if (_hx_tmp5) {
HXDLIN(  55)			 ::pi_xy::ImageStruct v1 = ::pi_xy::transformation::_SpinImage::SpinImage_Fields__obj::spin180(this1->mask,x,y,w,h,this1->mask->transparent,includeMask);
HXDLIN(  55)			nextImage->useMask = true;
HXDLIN(  55)			nextImage->mask = v1;
            		}
HXDLIN(  55)		return nextImage;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(TransformImage_Impl__obj,spun180,return )

 ::pi_xy::ImageStruct TransformImage_Impl__obj::scaleMatch( ::pi_xy::ImageStruct this1, ::pi_xy::ImageStruct img,::hx::Null< bool >  __o_transparent,::hx::Null< bool >  __o_includeMask){
            		bool transparent = __o_transparent.Default(false);
            		bool includeMask = __o_includeMask.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_68d25436a32dba6f_60_scaleMatch)
HXLINE(  61)		 ::pi_xy::ImageStruct here = this1;
HXLINE(  62)		bool _hx_tmp;
HXDLIN(  62)		if ((img->width == here->width)) {
HXLINE(  62)			_hx_tmp = (img->height != here->height);
            		}
            		else {
HXLINE(  62)			_hx_tmp = true;
            		}
HXDLIN(  62)		if (_hx_tmp) {
HXLINE(  63)			Float sx = (( (Float)(here->width) ) / ( (Float)(img->width) ));
HXDLIN(  63)			Float sy = (( (Float)(here->height) ) / ( (Float)(img->height) ));
HXDLIN(  63)			bool transparent1 = false;
HXDLIN(  63)			bool includeMask1 = false;
HXDLIN(  63)			 ::pi_xy::ImageStruct thisImage = img;
HXDLIN(  63)			int scaleW = ::Std_obj::_hx_int(sx);
HXDLIN(  63)			int scaleH = ::Std_obj::_hx_int(sy);
HXDLIN(  63)			bool ifScaleUpInt;
HXDLIN(  63)			bool ifScaleUpInt1;
HXDLIN(  63)			bool ifScaleUpInt2;
HXDLIN(  63)			if ((scaleW == sx)) {
HXLINE(  63)				ifScaleUpInt2 = (sx > ((Float)0.));
            			}
            			else {
HXLINE(  63)				ifScaleUpInt2 = false;
            			}
HXDLIN(  63)			if (ifScaleUpInt2) {
HXLINE(  63)				ifScaleUpInt1 = (scaleH == sy);
            			}
            			else {
HXLINE(  63)				ifScaleUpInt1 = false;
            			}
HXDLIN(  63)			if (ifScaleUpInt1) {
HXLINE(  63)				ifScaleUpInt = (sy > ((Float)0.));
            			}
            			else {
HXLINE(  63)				ifScaleUpInt = false;
            			}
HXDLIN(  63)			if (ifScaleUpInt) {
HXLINE(  63)				bool includeMask2 = false;
HXDLIN(  63)				 ::pi_xy::ImageStruct thisImage1 = thisImage;
HXDLIN(  63)				int p = 0;
HXDLIN(  63)				int xx = p;
HXDLIN(  63)				int q = 0;
HXDLIN(  63)				int wNew = ::Std_obj::_hx_int(( (Float)((thisImage1->width * scaleW)) ));
HXDLIN(  63)				int hNew = ::Std_obj::_hx_int(( (Float)((thisImage1->height * scaleH)) ));
HXDLIN(  63)				 ::Dynamic imageType = null();
HXDLIN(  63)				 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  63)				if (::hx::IsNull( imageType )) {
HXLINE(  54)					imageType = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE(  63)				::Dynamic _hx_tmp1;
HXDLIN(  63)				switch((int)(( (int)(imageType) ))){
            					case (int)0: {
HXLINE(  63)						 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  63)						 ::iterMagic::BytesImg b = byt;
HXDLIN(  63)						{
HXLINE(  63)							b->width = wNew;
HXDLIN(  63)							b->height = hNew;
HXDLIN(  63)							b->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN(  63)							b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  63)							{
HXLINE(  63)								int len = b->length;
HXDLIN(  63)								int w = 0;
HXDLIN(  63)								{
HXLINE(  63)									int _g = 0;
HXDLIN(  63)									int _g1 = b->height;
HXDLIN(  63)									while((_g < _g1)){
HXLINE(  63)										_g = (_g + 1);
HXDLIN(  63)										int y = (_g - 1);
HXDLIN(  63)										{
HXLINE(  63)											int _g2 = 0;
HXDLIN(  63)											int _g3 = b->width;
HXDLIN(  63)											while((_g2 < _g3)){
HXLINE(  63)												_g2 = (_g2 + 1);
HXDLIN(  63)												int x = (_g2 - 1);
HXDLIN(  63)												{
HXLINE(  63)													w = (w + 1);
HXDLIN(  63)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  63)												{
HXLINE(  63)													w = (w + 1);
HXDLIN(  63)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  63)												{
HXLINE(  63)													w = (w + 1);
HXDLIN(  63)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  63)												{
HXLINE(  63)													w = (w + 1);
HXDLIN(  63)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  63)						_hx_tmp1 = b;
            					}
            					break;
            					case (int)1: {
HXLINE(  63)						 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  63)						 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  63)						{
HXLINE(  63)							a->width = wNew;
HXDLIN(  63)							a->height = hNew;
HXDLIN(  63)							a->data = ::Array_obj< int >::__new(0);
HXDLIN(  63)							a->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN(  63)							{
HXLINE(  63)								int _g4 = 0;
HXDLIN(  63)								int _g5 = a->length;
HXDLIN(  63)								while((_g4 < _g5)){
HXLINE(  63)									_g4 = (_g4 + 1);
HXDLIN(  63)									int i = (_g4 - 1);
HXDLIN(  63)									a->data[i] = 0;
            								}
            							}
            						}
HXDLIN(  63)						_hx_tmp1 = a;
            					}
            					break;
            					case (int)2: {
HXLINE(  63)						 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  63)						 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  63)						{
HXLINE(  63)							b1->width = wNew;
HXDLIN(  63)							b1->height = hNew;
HXDLIN(  63)							b1->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN(  63)							int size = (b1->length * 4);
HXDLIN(  63)							b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  63)							{
HXLINE(  63)								int _g6 = 0;
HXDLIN(  63)								int _g7 = b1->length;
HXDLIN(  63)								while((_g6 < _g7)){
HXLINE(  63)									_g6 = (_g6 + 1);
HXDLIN(  63)									int i1 = (_g6 - 1);
HXDLIN(  63)									{
HXLINE(  63)										 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  63)										bool _hx_tmp2;
HXDLIN(  63)										if ((i1 >= 0)) {
HXLINE(  63)											_hx_tmp2 = (i1 < (this3->byteLength >> 2));
            										}
            										else {
HXLINE(  63)											_hx_tmp2 = false;
            										}
HXDLIN(  63)										if (_hx_tmp2) {
HXLINE(  63)											 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  63)											int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  63)											_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  63)											_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  63)											_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  63)											_this->b[(pos + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN(  63)						_hx_tmp1 = b1;
            					}
            					break;
            					case (int)3: {
HXLINE(  63)						 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  63)						 ::iterMagic::VecIntImg v = vec;
HXDLIN(  63)						{
HXLINE(  63)							v->width = wNew;
HXDLIN(  63)							v->height = hNew;
HXDLIN(  63)							v->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN(  63)							v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  63)							{
HXLINE(  63)								int _g8 = 0;
HXDLIN(  63)								int _g9 = v->length;
HXDLIN(  63)								while((_g8 < _g9)){
HXLINE(  63)									_g8 = (_g8 + 1);
HXDLIN(  63)									int i2 = (_g8 - 1);
HXDLIN(  63)									v->data->__unsafe_set(i2,0);
            								}
            							}
            						}
HXDLIN(  63)						_hx_tmp1 = v;
            					}
            					break;
            					case (int)4: {
HXLINE(  63)						 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  63)						 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  63)						{
HXLINE(  63)							b2->width = wNew;
HXDLIN(  63)							b2->height = hNew;
HXDLIN(  63)							b2->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN(  63)							b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  63)							{
HXLINE(  63)								int len1 = b2->length;
HXDLIN(  63)								 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  63)								if (::hx::IsNull( d->head )) {
HXLINE(  63)									int _g10 = 0;
HXDLIN(  63)									int _g11 = len1;
HXDLIN(  63)									while((_g10 < _g11)){
HXLINE(  63)										_g10 = (_g10 + 1);
HXDLIN(  63)										int i3 = (_g10 - 1);
HXDLIN(  63)										d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            									}
            								}
            								else {
HXLINE(  63)									int _g12 = 0;
HXDLIN(  63)									int _g13 = len1;
HXDLIN(  63)									while((_g12 < _g13)){
HXLINE(  63)										_g12 = (_g12 + 1);
HXDLIN(  63)										int i4 = (_g12 - 1);
HXDLIN(  63)										{
HXLINE(  63)											 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  63)											 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  63)											{
HXLINE(  63)												int _g14 = 0;
HXDLIN(  63)												int _g15 = i4;
HXDLIN(  63)												while((_g14 < _g15)){
HXLINE(  63)													_g14 = (_g14 + 1);
HXDLIN(  63)													int i5 = (_g14 - 1);
HXLINE( 345)													prev = l;
HXLINE( 346)													l = l->next;
            												}
            											}
HXLINE(  63)											if (::hx::IsNull( prev )) {
HXLINE(  63)												b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  63)												l = null();
            											}
            											else {
HXLINE(  63)												prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  63)												l = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  63)						_hx_tmp1 = b2;
            					}
            					break;
            				}
HXDLIN(  63)				this2->image = _hx_tmp1;
HXDLIN(  63)				this2->width = wNew;
HXDLIN(  63)				this2->height = hNew;
HXDLIN(  63)				this2->imageType = ( (int)(imageType) );
HXDLIN(  63)				 ::pi_xy::ImageStruct nextImage = this2;
HXDLIN(  63)				int maxX = wNew;
HXDLIN(  63)				int maxY = hNew;
HXDLIN(  63)				do {
HXLINE(  63)					int x1 = ::Std_obj::_hx_int((( (Float)(p) ) / ( (Float)(scaleW) )));
HXDLIN(  63)					int y1 = ::Std_obj::_hx_int((( (Float)(q) ) / ( (Float)(scaleH) )));
HXDLIN(  63)					::Dynamic this4 = thisImage1->image;
HXDLIN(  63)					int index;
HXDLIN(  63)					if (thisImage1->useVirtualPos) {
HXLINE(  63)						index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - thisImage1->virtualY) * ( (Float)(thisImage1->width) )) + x1) - thisImage1->virtualX));
            					}
            					else {
HXLINE(  63)						index = ::Std_obj::_hx_int(( (Float)(((y1 * thisImage1->width) + x1)) ));
            					}
HXDLIN(  63)					int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN(  63)					int color;
HXDLIN(  63)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)						color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            					}
            					else {
HXLINE(  63)						color = c;
            					}
HXDLIN(  63)					{
HXLINE(  63)						p = (p + 1);
HXDLIN(  63)						int x2 = (p - 1);
HXDLIN(  63)						int c1 = color;
HXDLIN(  63)						bool _hx_tmp3;
HXDLIN(  63)						if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  63)							_hx_tmp3 = nextImage->transparent;
            						}
            						else {
HXLINE(  63)							_hx_tmp3 = false;
            						}
HXDLIN(  63)						if (_hx_tmp3) {
HXLINE(  63)							int location;
HXDLIN(  63)							if (nextImage->useVirtualPos) {
HXLINE(  63)								location = ::Std_obj::_hx_int(((((( (Float)(q) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x2) - nextImage->virtualX));
            							}
            							else {
HXLINE(  63)								location = ::Std_obj::_hx_int(( (Float)(((q * nextImage->width) + x2)) ));
            							}
HXDLIN(  63)							int this5 = ::iterMagic::Iimg_obj::get(nextImage->image,location);
HXDLIN(  63)							int this6;
HXDLIN(  63)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)								this6 = ((((((this5 >> 24) & 255) << 24) | ((this5 & 255) << 16)) | (((this5 >> 8) & 255) << 8)) | ((this5 >> 16) & 255));
            							}
            							else {
HXLINE(  63)								this6 = this5;
            							}
HXDLIN(  63)							Float a1;
HXDLIN(  63)							int this7 = ((this6 >> 24) & 255);
HXDLIN(  63)							if ((this7 == 0)) {
HXLINE(  63)								a1 = ((Float)0.);
            							}
            							else {
HXLINE(  63)								a1 = (( (Float)(this7) ) / ( (Float)(255) ));
            							}
HXDLIN(  63)							Float r1;
HXDLIN(  63)							int this8 = ((this6 >> 16) & 255);
HXDLIN(  63)							if ((this8 == 0)) {
HXLINE(  63)								r1 = ((Float)0.);
            							}
            							else {
HXLINE(  63)								r1 = (( (Float)(this8) ) / ( (Float)(255) ));
            							}
HXDLIN(  63)							Float g1;
HXDLIN(  63)							int this9 = ((this6 >> 8) & 255);
HXDLIN(  63)							if ((this9 == 0)) {
HXLINE(  63)								g1 = ((Float)0.);
            							}
            							else {
HXLINE(  63)								g1 = (( (Float)(this9) ) / ( (Float)(255) ));
            							}
HXDLIN(  63)							Float b11;
HXDLIN(  63)							int this10 = (this6 & 255);
HXDLIN(  63)							if ((this10 == 0)) {
HXLINE(  63)								b11 = ((Float)0.);
            							}
            							else {
HXLINE(  63)								b11 = (( (Float)(this10) ) / ( (Float)(255) ));
            							}
HXDLIN(  63)							Float a2;
HXDLIN(  63)							int this11 = ((color >> 24) & 255);
HXDLIN(  63)							if ((this11 == 0)) {
HXLINE(  63)								a2 = ((Float)0.);
            							}
            							else {
HXLINE(  63)								a2 = (( (Float)(this11) ) / ( (Float)(255) ));
            							}
HXDLIN(  63)							Float r2;
HXDLIN(  63)							int this12 = ((color >> 16) & 255);
HXDLIN(  63)							if ((this12 == 0)) {
HXLINE(  63)								r2 = ((Float)0.);
            							}
            							else {
HXLINE(  63)								r2 = (( (Float)(this12) ) / ( (Float)(255) ));
            							}
HXDLIN(  63)							Float g2;
HXDLIN(  63)							int this13 = ((color >> 8) & 255);
HXDLIN(  63)							if ((this13 == 0)) {
HXLINE(  63)								g2 = ((Float)0.);
            							}
            							else {
HXLINE(  63)								g2 = (( (Float)(this13) ) / ( (Float)(255) ));
            							}
HXDLIN(  63)							Float b21;
HXDLIN(  63)							int this14 = (color & 255);
HXDLIN(  63)							if ((this14 == 0)) {
HXLINE(  63)								b21 = ((Float)0.);
            							}
            							else {
HXLINE(  63)								b21 = (( (Float)(this14) ) / ( (Float)(255) ));
            							}
HXDLIN(  63)							Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  63)							int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  63)							int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  63)							int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  63)							int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  63)							int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  63)							{
HXLINE(  63)								int _hx_tmp4;
HXDLIN(  63)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)									_hx_tmp4 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            								}
            								else {
HXLINE(  63)									_hx_tmp4 = blended;
            								}
HXDLIN(  63)								::iterMagic::Iimg_obj::set(nextImage->image,location,_hx_tmp4);
            							}
            						}
            						else {
HXLINE(  63)							::Dynamic this15 = nextImage->image;
HXDLIN(  63)							int index1;
HXDLIN(  63)							if (nextImage->useVirtualPos) {
HXLINE(  63)								index1 = ::Std_obj::_hx_int(((((( (Float)(q) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x2) - nextImage->virtualX));
            							}
            							else {
HXLINE(  63)								index1 = ::Std_obj::_hx_int(( (Float)(((q * nextImage->width) + x2)) ));
            							}
HXDLIN(  63)							int _hx_tmp5;
HXDLIN(  63)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)								_hx_tmp5 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            							}
            							else {
HXLINE(  63)								_hx_tmp5 = c1;
            							}
HXDLIN(  63)							::iterMagic::Iimg_obj::set(this15,index1,_hx_tmp5);
            						}
            					}
HXDLIN(  63)					if ((p > maxX)) {
HXLINE(  22)						p = xx;
HXLINE(  63)						q = (q + 1);
            					}
            				} while((q <= maxY));
;
HXDLIN(  63)				bool _hx_tmp6;
HXDLIN(  63)				if (::hx::IsNotNull( thisImage1->mask )) {
HXLINE(  63)					_hx_tmp6 = includeMask2;
            				}
            				else {
HXLINE(  63)					_hx_tmp6 = false;
            				}
HXDLIN(  63)				if (_hx_tmp6) {
HXLINE(  63)					 ::pi_xy::ImageStruct v1 = ::pi_xy::transformation::_ScaleImage::ScaleImage_Fields__obj::scaleUpInteger(thisImage1->mask,scaleW,scaleH,thisImage1->mask->transparent,includeMask2);
HXDLIN(  63)					nextImage->useMask = true;
HXDLIN(  63)					nextImage->mask = v1;
            				}
HXDLIN(  63)				return nextImage;
            			}
            			else {
HXLINE(  63)				Float w1 = (( (Float)(thisImage->width) ) * sx);
HXDLIN(  63)				Float h = (( (Float)(thisImage->height) ) * sy);
HXDLIN(  63)				int wid = ::Math_obj::ceil(w1);
HXDLIN(  63)				int hi = ::Math_obj::ceil(h);
HXDLIN(  63)				 ::Dynamic imageType1 = null();
HXDLIN(  63)				 ::pi_xy::ImageStruct this16 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  63)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE(  63)				::Dynamic _hx_tmp7;
HXDLIN(  63)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXLINE(  63)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  63)						 ::iterMagic::BytesImg b4 = byt1;
HXDLIN(  63)						{
HXLINE(  63)							b4->width = wid;
HXDLIN(  63)							b4->height = hi;
HXDLIN(  63)							b4->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  63)							b4->data = ::haxe::io::Bytes_obj::alloc((b4->length * 4));
HXDLIN(  63)							{
HXLINE(  63)								int len2 = b4->length;
HXDLIN(  63)								int w2 = 0;
HXDLIN(  63)								{
HXLINE(  63)									int _g16 = 0;
HXDLIN(  63)									int _g17 = b4->height;
HXDLIN(  63)									while((_g16 < _g17)){
HXLINE(  63)										_g16 = (_g16 + 1);
HXDLIN(  63)										int y2 = (_g16 - 1);
HXDLIN(  63)										{
HXLINE(  63)											int _g18 = 0;
HXDLIN(  63)											int _g19 = b4->width;
HXDLIN(  63)											while((_g18 < _g19)){
HXLINE(  63)												_g18 = (_g18 + 1);
HXDLIN(  63)												int x3 = (_g18 - 1);
HXDLIN(  63)												{
HXLINE(  63)													w2 = (w2 + 1);
HXDLIN(  63)													b4->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  63)												{
HXLINE(  63)													w2 = (w2 + 1);
HXDLIN(  63)													b4->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  63)												{
HXLINE(  63)													w2 = (w2 + 1);
HXDLIN(  63)													b4->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  63)												{
HXLINE(  63)													w2 = (w2 + 1);
HXDLIN(  63)													b4->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  63)						_hx_tmp7 = b4;
            					}
            					break;
            					case (int)1: {
HXLINE(  63)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  63)						 ::iterMagic::ArrIntImg a5 = arrI1;
HXDLIN(  63)						{
HXLINE(  63)							a5->width = wid;
HXDLIN(  63)							a5->height = hi;
HXDLIN(  63)							a5->data = ::Array_obj< int >::__new(0);
HXDLIN(  63)							a5->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  63)							{
HXLINE(  63)								int _g20 = 0;
HXDLIN(  63)								int _g21 = a5->length;
HXDLIN(  63)								while((_g20 < _g21)){
HXLINE(  63)									_g20 = (_g20 + 1);
HXDLIN(  63)									int i6 = (_g20 - 1);
HXDLIN(  63)									a5->data[i6] = 0;
            								}
            							}
            						}
HXDLIN(  63)						_hx_tmp7 = a5;
            					}
            					break;
            					case (int)2: {
HXLINE(  63)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  63)						 ::iterMagic::U32ArrImg b5 = u32a1;
HXDLIN(  63)						{
HXLINE(  63)							b5->width = wid;
HXDLIN(  63)							b5->height = hi;
HXDLIN(  63)							b5->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  63)							int size1 = (b5->length * 4);
HXDLIN(  63)							b5->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  63)							{
HXLINE(  63)								int _g22 = 0;
HXDLIN(  63)								int _g23 = b5->length;
HXDLIN(  63)								while((_g22 < _g23)){
HXLINE(  63)									_g22 = (_g22 + 1);
HXDLIN(  63)									int i7 = (_g22 - 1);
HXDLIN(  63)									{
HXLINE(  63)										 ::haxe::io::ArrayBufferViewImpl this17 = b5->data;
HXDLIN(  63)										bool _hx_tmp8;
HXDLIN(  63)										if ((i7 >= 0)) {
HXLINE(  63)											_hx_tmp8 = (i7 < (this17->byteLength >> 2));
            										}
            										else {
HXLINE(  63)											_hx_tmp8 = false;
            										}
HXDLIN(  63)										if (_hx_tmp8) {
HXLINE(  63)											 ::haxe::io::Bytes _this1 = this17->bytes;
HXDLIN(  63)											int pos1 = ((i7 << 2) + this17->byteOffset);
HXDLIN(  63)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  63)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  63)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  63)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN(  63)						_hx_tmp7 = b5;
            					}
            					break;
            					case (int)3: {
HXLINE(  63)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  63)						 ::iterMagic::VecIntImg v2 = vec1;
HXDLIN(  63)						{
HXLINE(  63)							v2->width = wid;
HXDLIN(  63)							v2->height = hi;
HXDLIN(  63)							v2->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  63)							v2->data = ::Array_obj< int >::__new(v2->length);
HXDLIN(  63)							{
HXLINE(  63)								int _g24 = 0;
HXDLIN(  63)								int _g25 = v2->length;
HXDLIN(  63)								while((_g24 < _g25)){
HXLINE(  63)									_g24 = (_g24 + 1);
HXDLIN(  63)									int i8 = (_g24 - 1);
HXDLIN(  63)									v2->data->__unsafe_set(i8,0);
            								}
            							}
            						}
HXDLIN(  63)						_hx_tmp7 = v2;
            					}
            					break;
            					case (int)4: {
HXLINE(  63)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  63)						 ::iterMagic::StackIntImg b6 = sInt1;
HXDLIN(  63)						{
HXLINE(  63)							b6->width = wid;
HXDLIN(  63)							b6->height = hi;
HXDLIN(  63)							b6->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  63)							b6->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  63)							{
HXLINE(  63)								int len3 = b6->length;
HXDLIN(  63)								 ::haxe::ds::GenericStack_Int d1 = b6->data;
HXDLIN(  63)								if (::hx::IsNull( d1->head )) {
HXLINE(  63)									int _g26 = 0;
HXDLIN(  63)									int _g27 = len3;
HXDLIN(  63)									while((_g26 < _g27)){
HXLINE(  63)										_g26 = (_g26 + 1);
HXDLIN(  63)										int i9 = (_g26 - 1);
HXDLIN(  63)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXLINE(  63)									int _g28 = 0;
HXDLIN(  63)									int _g29 = len3;
HXDLIN(  63)									while((_g28 < _g29)){
HXLINE(  63)										_g28 = (_g28 + 1);
HXDLIN(  63)										int i10 = (_g28 - 1);
HXDLIN(  63)										{
HXLINE(  63)											 ::haxe::ds::GenericCell_Int l1 = b6->data->head;
HXDLIN(  63)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  63)											{
HXLINE(  63)												int _g30 = 0;
HXDLIN(  63)												int _g31 = i10;
HXDLIN(  63)												while((_g30 < _g31)){
HXLINE(  63)													_g30 = (_g30 + 1);
HXDLIN(  63)													int i11 = (_g30 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE(  63)											if (::hx::IsNull( prev1 )) {
HXLINE(  63)												b6->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  63)												l1 = null();
            											}
            											else {
HXLINE(  63)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  63)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  63)						_hx_tmp7 = b6;
            					}
            					break;
            				}
HXDLIN(  63)				this16->image = _hx_tmp7;
HXDLIN(  63)				this16->width = wid;
HXDLIN(  63)				this16->height = hi;
HXDLIN(  63)				this16->imageType = ( (int)(imageType1) );
HXDLIN(  63)				 ::pi_xy::ImageStruct nextImage1 = this16;
HXDLIN(  63)				{
HXLINE(  63)					bool v3 = thisImage->transparent;
HXDLIN(  63)					nextImage1->transparent = v3;
            				}
HXDLIN(  63)				{
HXLINE(  63)					 ::pi_xy::ImageStruct this18 = nextImage1;
HXDLIN(  63)					Float win_x = ( (Float)(0) );
HXDLIN(  63)					Float win_y = ( (Float)(0) );
HXDLIN(  63)					Float win_width = ( (Float)(thisImage->width) );
HXDLIN(  63)					Float win_height = ( (Float)(thisImage->height) );
HXDLIN(  63)					{
HXLINE(  63)						Float bu = ((Float)1.);
HXDLIN(  63)						Float bv = ((Float)0.);
HXDLIN(  63)						Float cu = ((Float)1.);
HXDLIN(  63)						Float cv = ((Float)1.);
HXDLIN(  63)						Float du = ((Float)0.);
HXDLIN(  63)						Float dv = ((Float)1.);
HXDLIN(  63)						Float au = ((Float)0.);
HXDLIN(  63)						Float av = ((Float)0.);
HXDLIN(  63)						Float bu1 = bu;
HXDLIN(  63)						Float bv1 = bv;
HXDLIN(  63)						bool hasUndo = false;
HXDLIN(  63)						Float temp = au;
HXLINE( 422)						au = bu1;
HXLINE( 423)						bu1 = temp;
HXLINE( 424)						temp = av;
HXLINE( 425)						av = bv1;
HXLINE( 426)						bv1 = temp;
HXLINE(  63)						Float bcx = w1;
HXDLIN(  63)						Float bcy = (( (Float)(0) ) - h);
HXDLIN(  63)						Float acx = ( (Float)(0) );
HXDLIN(  63)						Float acy = (( (Float)(0) ) - h);
HXDLIN(  63)						Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  63)						Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  63)						Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  63)						Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  63)						 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  63)						if ((0 > w1)) {
HXLINE(  63)							int ii_min = ::Math_obj::floor(w1);
HXDLIN(  63)							int ii_max = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  63)							xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            						}
            						else {
HXLINE(  63)							if ((w1 > 0)) {
HXLINE(  63)								int ii_min1 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  63)								int ii_max1 = ::Math_obj::ceil(w1);
HXDLIN(  63)								xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            							}
            							else {
HXLINE(  63)								int ii_min2 = ::Math_obj::floor(( (Float)(0) ));
HXDLIN(  63)								int ii_max2 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  63)								xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            							}
            						}
HXDLIN(  63)						 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  63)						if ((0 > h)) {
HXLINE(  63)							int min;
HXDLIN(  63)							if ((0 > h)) {
HXLINE(  63)								min = ::Math_obj::floor(h);
            							}
            							else {
HXLINE(  63)								min = ::Math_obj::ceil(( (Float)(0) ));
            							}
HXDLIN(  63)							int ii_min3 = min;
HXDLIN(  63)							int ii_max3 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  63)							yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            						}
            						else {
HXLINE(  63)							int ii_min4 = ::Math_obj::floor(( (Float)(0) ));
HXDLIN(  63)							int ii_max4 = ::Math_obj::ceil(h);
HXDLIN(  63)							yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            						}
HXDLIN(  63)						 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  63)						if (hasUndo) {
HXLINE(  63)							int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  63)							int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  63)							 ::Dynamic imageType2 = null();
HXDLIN(  63)							 ::pi_xy::ImageStruct this19 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  63)							if (::hx::IsNull( imageType2 )) {
HXLINE(  54)								imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE(  63)							::Dynamic undoImage1;
HXDLIN(  63)							switch((int)(( (int)(imageType2) ))){
            								case (int)0: {
HXLINE(  63)									 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  63)									 ::iterMagic::BytesImg b7 = byt2;
HXDLIN(  63)									{
HXLINE(  63)										b7->width = width;
HXDLIN(  63)										b7->height = height;
HXDLIN(  63)										b7->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  63)										b7->data = ::haxe::io::Bytes_obj::alloc((b7->length * 4));
HXDLIN(  63)										{
HXLINE(  63)											int len4 = b7->length;
HXDLIN(  63)											int w3 = 0;
HXDLIN(  63)											{
HXLINE(  63)												int _g32 = 0;
HXDLIN(  63)												int _g33 = b7->height;
HXDLIN(  63)												while((_g32 < _g33)){
HXLINE(  63)													_g32 = (_g32 + 1);
HXDLIN(  63)													int y3 = (_g32 - 1);
HXDLIN(  63)													{
HXLINE(  63)														int _g34 = 0;
HXDLIN(  63)														int _g35 = b7->width;
HXDLIN(  63)														while((_g34 < _g35)){
HXLINE(  63)															_g34 = (_g34 + 1);
HXDLIN(  63)															int x4 = (_g34 - 1);
HXDLIN(  63)															{
HXLINE(  63)																w3 = (w3 + 1);
HXDLIN(  63)																b7->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  63)															{
HXLINE(  63)																w3 = (w3 + 1);
HXDLIN(  63)																b7->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  63)															{
HXLINE(  63)																w3 = (w3 + 1);
HXDLIN(  63)																b7->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  63)															{
HXLINE(  63)																w3 = (w3 + 1);
HXDLIN(  63)																b7->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  63)									undoImage1 = b7;
            								}
            								break;
            								case (int)1: {
HXLINE(  63)									 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  63)									 ::iterMagic::ArrIntImg a6 = arrI2;
HXDLIN(  63)									{
HXLINE(  63)										a6->width = width;
HXDLIN(  63)										a6->height = height;
HXDLIN(  63)										a6->data = ::Array_obj< int >::__new(0);
HXDLIN(  63)										a6->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  63)										{
HXLINE(  63)											int _g36 = 0;
HXDLIN(  63)											int _g37 = a6->length;
HXDLIN(  63)											while((_g36 < _g37)){
HXLINE(  63)												_g36 = (_g36 + 1);
HXDLIN(  63)												int i12 = (_g36 - 1);
HXDLIN(  63)												a6->data[i12] = 0;
            											}
            										}
            									}
HXDLIN(  63)									undoImage1 = a6;
            								}
            								break;
            								case (int)2: {
HXLINE(  63)									 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  63)									 ::iterMagic::U32ArrImg b8 = u32a2;
HXDLIN(  63)									{
HXLINE(  63)										b8->width = width;
HXDLIN(  63)										b8->height = height;
HXDLIN(  63)										b8->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  63)										int size2 = (b8->length * 4);
HXDLIN(  63)										b8->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN(  63)										{
HXLINE(  63)											int _g38 = 0;
HXDLIN(  63)											int _g39 = b8->length;
HXDLIN(  63)											while((_g38 < _g39)){
HXLINE(  63)												_g38 = (_g38 + 1);
HXDLIN(  63)												int i13 = (_g38 - 1);
HXDLIN(  63)												{
HXLINE(  63)													 ::haxe::io::ArrayBufferViewImpl this20 = b8->data;
HXDLIN(  63)													bool undoImage2;
HXDLIN(  63)													if ((i13 >= 0)) {
HXLINE(  63)														undoImage2 = (i13 < (this20->byteLength >> 2));
            													}
            													else {
HXLINE(  63)														undoImage2 = false;
            													}
HXDLIN(  63)													if (undoImage2) {
HXLINE(  63)														 ::haxe::io::Bytes _this2 = this20->bytes;
HXDLIN(  63)														int pos2 = ((i13 << 2) + this20->byteOffset);
HXDLIN(  63)														_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN(  63)														_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN(  63)														_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN(  63)														_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN(  63)									undoImage1 = b8;
            								}
            								break;
            								case (int)3: {
HXLINE(  63)									 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  63)									 ::iterMagic::VecIntImg v4 = vec2;
HXDLIN(  63)									{
HXLINE(  63)										v4->width = width;
HXDLIN(  63)										v4->height = height;
HXDLIN(  63)										v4->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  63)										v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN(  63)										{
HXLINE(  63)											int _g40 = 0;
HXDLIN(  63)											int _g41 = v4->length;
HXDLIN(  63)											while((_g40 < _g41)){
HXLINE(  63)												_g40 = (_g40 + 1);
HXDLIN(  63)												int i14 = (_g40 - 1);
HXDLIN(  63)												v4->data->__unsafe_set(i14,0);
            											}
            										}
            									}
HXDLIN(  63)									undoImage1 = v4;
            								}
            								break;
            								case (int)4: {
HXLINE(  63)									 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  63)									 ::iterMagic::StackIntImg b9 = sInt2;
HXDLIN(  63)									{
HXLINE(  63)										b9->width = width;
HXDLIN(  63)										b9->height = height;
HXDLIN(  63)										b9->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  63)										b9->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  63)										{
HXLINE(  63)											int len5 = b9->length;
HXDLIN(  63)											 ::haxe::ds::GenericStack_Int d2 = b9->data;
HXDLIN(  63)											if (::hx::IsNull( d2->head )) {
HXLINE(  63)												int _g42 = 0;
HXDLIN(  63)												int _g43 = len5;
HXDLIN(  63)												while((_g42 < _g43)){
HXLINE(  63)													_g42 = (_g42 + 1);
HXDLIN(  63)													int i15 = (_g42 - 1);
HXDLIN(  63)													d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            												}
            											}
            											else {
HXLINE(  63)												int _g44 = 0;
HXDLIN(  63)												int _g45 = len5;
HXDLIN(  63)												while((_g44 < _g45)){
HXLINE(  63)													_g44 = (_g44 + 1);
HXDLIN(  63)													int i16 = (_g44 - 1);
HXDLIN(  63)													{
HXLINE(  63)														 ::haxe::ds::GenericCell_Int l2 = b9->data->head;
HXDLIN(  63)														 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN(  63)														{
HXLINE(  63)															int _g46 = 0;
HXDLIN(  63)															int _g47 = i16;
HXDLIN(  63)															while((_g46 < _g47)){
HXLINE(  63)																_g46 = (_g46 + 1);
HXDLIN(  63)																int i17 = (_g46 - 1);
HXLINE( 345)																prev2 = l2;
HXLINE( 346)																l2 = l2->next;
            															}
            														}
HXLINE(  63)														if (::hx::IsNull( prev2 )) {
HXLINE(  63)															b9->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  63)															l2 = null();
            														}
            														else {
HXLINE(  63)															prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  63)															l2 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  63)									undoImage1 = b9;
            								}
            								break;
            							}
HXDLIN(  63)							this19->image = undoImage1;
HXDLIN(  63)							this19->width = width;
HXDLIN(  63)							this19->height = height;
HXDLIN(  63)							this19->imageType = ( (int)(imageType2) );
HXDLIN(  63)							undoImage = this19;
HXDLIN(  63)							{
HXLINE(  63)								int rectLeft = xIter3->start;
HXDLIN(  63)								int rectTop = yIter3->start;
HXDLIN(  63)								int rectRight = xIter3->max;
HXDLIN(  63)								bool forceClear = false;
HXDLIN(  63)								{
HXLINE(  63)									int _g48 = rectTop;
HXDLIN(  63)									int _g49 = yIter3->max;
HXDLIN(  63)									while((_g48 < _g49)){
HXLINE(  63)										_g48 = (_g48 + 1);
HXDLIN(  63)										int dy = (_g48 - 1);
HXDLIN(  63)										{
HXLINE(  63)											int _g50 = rectLeft;
HXDLIN(  63)											int _g51 = rectRight;
HXDLIN(  63)											while((_g50 < _g51)){
HXLINE(  63)												_g50 = (_g50 + 1);
HXDLIN(  63)												int dx = (_g50 - 1);
HXDLIN(  63)												::Dynamic this21 = this18->image;
HXDLIN(  63)												int index2;
HXDLIN(  63)												if (this18->useVirtualPos) {
HXLINE(  63)													index2 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this18->virtualY) * ( (Float)(this18->width) )) + dx) - this18->virtualX));
            												}
            												else {
HXLINE(  63)													index2 = ::Std_obj::_hx_int(( (Float)(((dy * this18->width) + dx)) ));
            												}
HXDLIN(  63)												int c2 = ::iterMagic::Iimg_obj::get(this21,index2);
HXDLIN(  63)												int col;
HXDLIN(  63)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)													col = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            												}
            												else {
HXLINE(  63)													col = c2;
            												}
HXDLIN(  63)												bool _hx_tmp9;
HXDLIN(  63)												if (this18->useMask) {
HXLINE(  63)													_hx_tmp9 = ::hx::IsNotNull( this18->mask );
            												}
            												else {
HXLINE(  63)													_hx_tmp9 = false;
            												}
HXDLIN(  63)												if (_hx_tmp9) {
HXLINE(  63)													 ::pi_xy::ImageStruct this22 = this18->mask;
HXDLIN(  63)													::Dynamic this23 = this22->image;
HXDLIN(  63)													int index3;
HXDLIN(  63)													if (this22->useVirtualPos) {
HXLINE(  63)														index3 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this22->virtualY) * ( (Float)(this22->width) )) + dx) - this22->virtualX));
            													}
            													else {
HXLINE(  63)														index3 = ::Std_obj::_hx_int(( (Float)(((dy * this22->width) + dx)) ));
            													}
HXDLIN(  63)													int c3 = ::iterMagic::Iimg_obj::get(this23,index3);
HXDLIN(  63)													int v5;
HXDLIN(  63)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)														v5 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            													}
            													else {
HXLINE(  63)														v5 = c3;
            													}
HXDLIN(  63)													int maskPixel = v5;
HXDLIN(  63)													int this24 = col;
HXDLIN(  63)													if ((maskPixel == 0)) {
HXLINE(  63)														col = this24;
            													}
            													else {
HXLINE(  63)														Float m0;
HXDLIN(  63)														int this25 = ((maskPixel >> 24) & 255);
HXDLIN(  63)														if ((this25 == 0)) {
HXLINE(  63)															m0 = ((Float)0.);
            														}
            														else {
HXLINE(  63)															m0 = (( (Float)(this25) ) / ( (Float)(255) ));
            														}
HXDLIN(  63)														Float m1;
HXDLIN(  63)														int this26 = ((maskPixel >> 16) & 255);
HXDLIN(  63)														if ((this26 == 0)) {
HXLINE(  63)															m1 = ((Float)0.);
            														}
            														else {
HXLINE(  63)															m1 = (( (Float)(this26) ) / ( (Float)(255) ));
            														}
HXDLIN(  63)														Float m2;
HXDLIN(  63)														int this27 = ((maskPixel >> 8) & 255);
HXDLIN(  63)														if ((this27 == 0)) {
HXLINE(  63)															m2 = ((Float)0.);
            														}
            														else {
HXLINE(  63)															m2 = (( (Float)(this27) ) / ( (Float)(255) ));
            														}
HXDLIN(  63)														Float m3;
HXDLIN(  63)														int this28 = (maskPixel & 255);
HXDLIN(  63)														if ((this28 == 0)) {
HXLINE(  63)															m3 = ((Float)0.);
            														}
            														else {
HXLINE(  63)															m3 = (( (Float)(this28) ) / ( (Float)(255) ));
            														}
HXDLIN(  63)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this24 >> 24) & 255)) )));
HXDLIN(  63)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this24 >> 16) & 255)) )));
HXDLIN(  63)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this24 >> 8) & 255)) )));
HXDLIN(  63)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this24 & 255)) )));
HXDLIN(  63)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  63)												if ((col != 0)) {
HXLINE(  63)													int x5 = (dx - rectLeft);
HXDLIN(  63)													int y4 = (dy - rectTop);
HXDLIN(  63)													int c4 = col;
HXDLIN(  63)													bool _hx_tmp10;
HXDLIN(  63)													if ((((c4 >> 24) & 255) < 254)) {
HXLINE(  63)														_hx_tmp10 = undoImage->transparent;
            													}
            													else {
HXLINE(  63)														_hx_tmp10 = false;
            													}
HXDLIN(  63)													if (_hx_tmp10) {
HXLINE(  63)														int location1;
HXDLIN(  63)														if (undoImage->useVirtualPos) {
HXLINE(  63)															location1 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            														}
            														else {
HXLINE(  63)															location1 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage->width) + x5)) ));
            														}
HXDLIN(  63)														int this29 = ::iterMagic::Iimg_obj::get(undoImage->image,location1);
HXDLIN(  63)														int this30;
HXDLIN(  63)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)															this30 = ((((((this29 >> 24) & 255) << 24) | ((this29 & 255) << 16)) | (((this29 >> 8) & 255) << 8)) | ((this29 >> 16) & 255));
            														}
            														else {
HXLINE(  63)															this30 = this29;
            														}
HXDLIN(  63)														Float a11;
HXDLIN(  63)														int this31 = ((this30 >> 24) & 255);
HXDLIN(  63)														if ((this31 == 0)) {
HXLINE(  63)															a11 = ((Float)0.);
            														}
            														else {
HXLINE(  63)															a11 = (( (Float)(this31) ) / ( (Float)(255) ));
            														}
HXDLIN(  63)														Float r11;
HXDLIN(  63)														int this32 = ((this30 >> 16) & 255);
HXDLIN(  63)														if ((this32 == 0)) {
HXLINE(  63)															r11 = ((Float)0.);
            														}
            														else {
HXLINE(  63)															r11 = (( (Float)(this32) ) / ( (Float)(255) ));
            														}
HXDLIN(  63)														Float g11;
HXDLIN(  63)														int this33 = ((this30 >> 8) & 255);
HXDLIN(  63)														if ((this33 == 0)) {
HXLINE(  63)															g11 = ((Float)0.);
            														}
            														else {
HXLINE(  63)															g11 = (( (Float)(this33) ) / ( (Float)(255) ));
            														}
HXDLIN(  63)														Float b12;
HXDLIN(  63)														int this34 = (this30 & 255);
HXDLIN(  63)														if ((this34 == 0)) {
HXLINE(  63)															b12 = ((Float)0.);
            														}
            														else {
HXLINE(  63)															b12 = (( (Float)(this34) ) / ( (Float)(255) ));
            														}
HXDLIN(  63)														Float a21;
HXDLIN(  63)														int this35 = ((col >> 24) & 255);
HXDLIN(  63)														if ((this35 == 0)) {
HXLINE(  63)															a21 = ((Float)0.);
            														}
            														else {
HXLINE(  63)															a21 = (( (Float)(this35) ) / ( (Float)(255) ));
            														}
HXDLIN(  63)														Float r21;
HXDLIN(  63)														int this36 = ((col >> 16) & 255);
HXDLIN(  63)														if ((this36 == 0)) {
HXLINE(  63)															r21 = ((Float)0.);
            														}
            														else {
HXLINE(  63)															r21 = (( (Float)(this36) ) / ( (Float)(255) ));
            														}
HXDLIN(  63)														Float g21;
HXDLIN(  63)														int this37 = ((col >> 8) & 255);
HXDLIN(  63)														if ((this37 == 0)) {
HXLINE(  63)															g21 = ((Float)0.);
            														}
            														else {
HXLINE(  63)															g21 = (( (Float)(this37) ) / ( (Float)(255) ));
            														}
HXDLIN(  63)														Float b22;
HXDLIN(  63)														int this38 = (col & 255);
HXDLIN(  63)														if ((this38 == 0)) {
HXLINE(  63)															b22 = ((Float)0.);
            														}
            														else {
HXLINE(  63)															b22 = (( (Float)(this38) ) / ( (Float)(255) ));
            														}
HXDLIN(  63)														Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  63)														int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  63)														int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  63)														int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  63)														int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  63)														int blended1 = ((((a7 << 24) | (r3 << 16)) | (g3 << 8)) | b10);
HXDLIN(  63)														{
HXLINE(  63)															int _hx_tmp11;
HXDLIN(  63)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																_hx_tmp11 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            															}
            															else {
HXLINE(  63)																_hx_tmp11 = blended1;
            															}
HXDLIN(  63)															::iterMagic::Iimg_obj::set(undoImage->image,location1,_hx_tmp11);
            														}
            													}
            													else {
HXLINE(  63)														::Dynamic this39 = undoImage->image;
HXDLIN(  63)														int index4;
HXDLIN(  63)														if (undoImage->useVirtualPos) {
HXLINE(  63)															index4 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            														}
            														else {
HXLINE(  63)															index4 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage->width) + x5)) ));
            														}
HXDLIN(  63)														int _hx_tmp12;
HXDLIN(  63)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)															_hx_tmp12 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            														}
            														else {
HXLINE(  63)															_hx_tmp12 = c4;
            														}
HXDLIN(  63)														::iterMagic::Iimg_obj::set(this39,index4,_hx_tmp12);
            													}
            												}
            												else {
HXLINE(  63)													if (forceClear) {
HXLINE(  63)														::Dynamic this40 = undoImage->image;
HXDLIN(  63)														int x6 = (dx - rectLeft);
HXDLIN(  63)														int y5 = (dy - rectTop);
HXDLIN(  63)														int index5;
HXDLIN(  63)														if (undoImage->useVirtualPos) {
HXLINE(  63)															index5 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x6) - undoImage->virtualX));
            														}
            														else {
HXLINE(  63)															index5 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage->width) + x6)) ));
            														}
HXDLIN(  63)														::iterMagic::Iimg_obj::set(this40,index5,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  63)						{
HXLINE(  63)							int _g_min = xIter3->start;
HXDLIN(  63)							int _g_max = xIter3->max;
HXDLIN(  63)							while((_g_min < _g_max)){
HXLINE(  63)								_g_min = (_g_min + 1);
HXDLIN(  63)								int px = (_g_min - 1);
HXDLIN(  63)								Float pcx = ( (Float)(px) );
HXDLIN(  63)								{
HXLINE(  63)									int _g_min1 = yIter3->start;
HXDLIN(  63)									int _g_max1 = yIter3->max;
HXDLIN(  63)									while((_g_min1 < _g_max1)){
HXLINE(  63)										_g_min1 = (_g_min1 + 1);
HXDLIN(  63)										int py = (_g_min1 - 1);
HXDLIN(  63)										Float pcy = (( (Float)(py) ) - h);
HXDLIN(  63)										Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  63)										Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  63)										Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  63)										Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  63)										Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  63)										bool _hx_tmp13;
HXDLIN(  63)										bool _hx_tmp14;
HXDLIN(  63)										if ((ratioA >= 0)) {
HXLINE(  63)											_hx_tmp14 = (ratioB >= 0);
            										}
            										else {
HXLINE(  63)											_hx_tmp14 = false;
            										}
HXDLIN(  63)										if (_hx_tmp14) {
HXLINE(  63)											_hx_tmp13 = (ratioC >= 0);
            										}
            										else {
HXLINE(  63)											_hx_tmp13 = false;
            										}
HXDLIN(  63)										if (_hx_tmp13) {
HXLINE(  63)											Float u = (((au * ratioA) + (bu1 * ratioB)) + (du * ratioC));
HXDLIN(  63)											Float v6 = (((av * ratioA) + (bv1 * ratioB)) + (dv * ratioC));
HXDLIN(  63)											int x7 = ::Std_obj::_hx_int(((u * win_width) + win_x));
HXDLIN(  63)											int y6 = ::Std_obj::_hx_int(((v6 * win_height) + win_y));
HXDLIN(  63)											::Dynamic this41 = thisImage->image;
HXDLIN(  63)											int index6;
HXDLIN(  63)											if (thisImage->useVirtualPos) {
HXLINE(  63)												index6 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - thisImage->virtualY) * ( (Float)(thisImage->width) )) + x7) - thisImage->virtualX));
            											}
            											else {
HXLINE(  63)												index6 = ::Std_obj::_hx_int(( (Float)(((y6 * thisImage->width) + x7)) ));
            											}
HXDLIN(  63)											int c5 = ::iterMagic::Iimg_obj::get(this41,index6);
HXDLIN(  63)											int col1;
HXDLIN(  63)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)												col1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            											}
            											else {
HXLINE(  63)												col1 = c5;
            											}
HXDLIN(  63)											{
HXLINE(  63)												int c6 = col1;
HXDLIN(  63)												bool _hx_tmp15;
HXDLIN(  63)												if ((((c6 >> 24) & 255) < 254)) {
HXLINE(  63)													_hx_tmp15 = this18->transparent;
            												}
            												else {
HXLINE(  63)													_hx_tmp15 = false;
            												}
HXDLIN(  63)												if (_hx_tmp15) {
HXLINE(  63)													int location2;
HXDLIN(  63)													if (this18->useVirtualPos) {
HXLINE(  63)														location2 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this18->virtualY) * ( (Float)(this18->width) )) + px) - this18->virtualX));
            													}
            													else {
HXLINE(  63)														location2 = ::Std_obj::_hx_int(( (Float)(((py * this18->width) + px)) ));
            													}
HXDLIN(  63)													int this42 = ::iterMagic::Iimg_obj::get(this18->image,location2);
HXDLIN(  63)													int this43;
HXDLIN(  63)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)														this43 = ((((((this42 >> 24) & 255) << 24) | ((this42 & 255) << 16)) | (((this42 >> 8) & 255) << 8)) | ((this42 >> 16) & 255));
            													}
            													else {
HXLINE(  63)														this43 = this42;
            													}
HXDLIN(  63)													Float a12;
HXDLIN(  63)													int this44 = ((this43 >> 24) & 255);
HXDLIN(  63)													if ((this44 == 0)) {
HXLINE(  63)														a12 = ((Float)0.);
            													}
            													else {
HXLINE(  63)														a12 = (( (Float)(this44) ) / ( (Float)(255) ));
            													}
HXDLIN(  63)													Float r12;
HXDLIN(  63)													int this45 = ((this43 >> 16) & 255);
HXDLIN(  63)													if ((this45 == 0)) {
HXLINE(  63)														r12 = ((Float)0.);
            													}
            													else {
HXLINE(  63)														r12 = (( (Float)(this45) ) / ( (Float)(255) ));
            													}
HXDLIN(  63)													Float g12;
HXDLIN(  63)													int this46 = ((this43 >> 8) & 255);
HXDLIN(  63)													if ((this46 == 0)) {
HXLINE(  63)														g12 = ((Float)0.);
            													}
            													else {
HXLINE(  63)														g12 = (( (Float)(this46) ) / ( (Float)(255) ));
            													}
HXDLIN(  63)													Float b13;
HXDLIN(  63)													int this47 = (this43 & 255);
HXDLIN(  63)													if ((this47 == 0)) {
HXLINE(  63)														b13 = ((Float)0.);
            													}
            													else {
HXLINE(  63)														b13 = (( (Float)(this47) ) / ( (Float)(255) ));
            													}
HXDLIN(  63)													Float a22;
HXDLIN(  63)													int this48 = ((col1 >> 24) & 255);
HXDLIN(  63)													if ((this48 == 0)) {
HXLINE(  63)														a22 = ((Float)0.);
            													}
            													else {
HXLINE(  63)														a22 = (( (Float)(this48) ) / ( (Float)(255) ));
            													}
HXDLIN(  63)													Float r22;
HXDLIN(  63)													int this49 = ((col1 >> 16) & 255);
HXDLIN(  63)													if ((this49 == 0)) {
HXLINE(  63)														r22 = ((Float)0.);
            													}
            													else {
HXLINE(  63)														r22 = (( (Float)(this49) ) / ( (Float)(255) ));
            													}
HXDLIN(  63)													Float g22;
HXDLIN(  63)													int this50 = ((col1 >> 8) & 255);
HXDLIN(  63)													if ((this50 == 0)) {
HXLINE(  63)														g22 = ((Float)0.);
            													}
            													else {
HXLINE(  63)														g22 = (( (Float)(this50) ) / ( (Float)(255) ));
            													}
HXDLIN(  63)													Float b23;
HXDLIN(  63)													int this51 = (col1 & 255);
HXDLIN(  63)													if ((this51 == 0)) {
HXLINE(  63)														b23 = ((Float)0.);
            													}
            													else {
HXLINE(  63)														b23 = (( (Float)(this51) ) / ( (Float)(255) ));
            													}
HXDLIN(  63)													Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  63)													int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  63)													int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  63)													int b14 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  63)													int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  63)													int blended2 = ((((a8 << 24) | (r4 << 16)) | (g4 << 8)) | b14);
HXDLIN(  63)													{
HXLINE(  63)														int _hx_tmp16;
HXDLIN(  63)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)															_hx_tmp16 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            														}
            														else {
HXLINE(  63)															_hx_tmp16 = blended2;
            														}
HXDLIN(  63)														::iterMagic::Iimg_obj::set(this18->image,location2,_hx_tmp16);
            													}
            												}
            												else {
HXLINE(  63)													::Dynamic this52 = this18->image;
HXDLIN(  63)													int index7;
HXDLIN(  63)													if (this18->useVirtualPos) {
HXLINE(  63)														index7 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this18->virtualY) * ( (Float)(this18->width) )) + px) - this18->virtualX));
            													}
            													else {
HXLINE(  63)														index7 = ::Std_obj::_hx_int(( (Float)(((py * this18->width) + px)) ));
            													}
HXDLIN(  63)													int _hx_tmp17;
HXDLIN(  63)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)														_hx_tmp17 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            													}
            													else {
HXLINE(  63)														_hx_tmp17 = c6;
            													}
HXDLIN(  63)													::iterMagic::Iimg_obj::set(this52,index7,_hx_tmp17);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  63)						 ::pi_xy::iter::IntIterStart v_yIter3;
HXDLIN(  63)						 ::pi_xy::iter::IntIterStart v_xIter3;
HXDLIN(  63)						int v_undoY;
HXDLIN(  63)						int v_undoX;
HXDLIN(  63)						Float v_ty;
HXDLIN(  63)						Float v_tx;
HXDLIN(  63)						Float v_t0;
HXDLIN(  63)						Float v_sy;
HXDLIN(  63)						Float v_sx;
HXDLIN(  63)						Float v_s0;
HXDLIN(  63)						Float v_A;
HXDLIN(  63)						 ::pi_xy::ImageStruct v_undoImage = null();
HXDLIN(  63)						Float bx = w1;
HXDLIN(  63)						Float by = ( (Float)(0) );
HXDLIN(  63)						Float cx = ( (Float)(0) );
HXDLIN(  63)						Float cy = h;
HXDLIN(  63)						bool adjustWinding = (((((( (Float)(0) ) * by) - (bx * ( (Float)(0) ))) + ((bx * cy) - (cx * by))) + ((cx * ( (Float)(0) )) - (( (Float)(0) ) * cy))) > 0);
HXDLIN(  63)						if (!(adjustWinding)) {
HXLINE(  63)							Float bx_ = bx;
HXDLIN(  63)							Float by_ = by;
HXLINE(  24)							bx = cx;
HXLINE(  25)							by = cy;
HXLINE(  26)							cx = bx_;
HXLINE(  27)							cy = by_;
            						}
HXLINE(  63)						Float v_ax = ( (Float)(0) );
HXDLIN(  63)						Float v_ay = ( (Float)(0) );
HXDLIN(  63)						Float v_bx = bx;
HXDLIN(  63)						Float v_by = by;
HXDLIN(  63)						Float v_cx = cx;
HXDLIN(  63)						Float v_cy = cy;
HXDLIN(  63)						bool v_preCalculated = true;
HXDLIN(  63)						{
HXLINE(  63)							v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN(  63)							v_sx = (v_cy - v_ay);
HXDLIN(  63)							v_sy = (v_ax - v_cx);
HXDLIN(  63)							v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN(  63)							v_tx = (v_ay - v_by);
HXDLIN(  63)							v_ty = (v_bx - v_ax);
HXDLIN(  63)							v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN(  63)							Float a9 = v_ax;
HXDLIN(  63)							Float b15 = v_bx;
HXDLIN(  63)							Float c7 = v_cx;
HXDLIN(  63)							if ((a9 > b15)) {
HXLINE(  63)								if ((a9 > c7)) {
HXLINE(  63)									int min1;
HXDLIN(  63)									if ((b15 > c7)) {
HXLINE(  63)										min1 = ::Math_obj::floor(c7);
            									}
            									else {
HXLINE(  63)										min1 = ::Math_obj::floor(b15);
            									}
HXDLIN(  63)									int ii_min5 = min1;
HXDLIN(  63)									int ii_max5 = ::Math_obj::ceil(a9);
HXDLIN(  63)									v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            								}
            								else {
HXLINE(  63)									int ii_min6 = ::Math_obj::floor(b15);
HXDLIN(  63)									int ii_max6 = ::Math_obj::ceil(c7);
HXDLIN(  63)									v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            								}
            							}
            							else {
HXLINE(  63)								if ((b15 > c7)) {
HXLINE(  63)									int min2;
HXDLIN(  63)									if ((a9 > c7)) {
HXLINE(  63)										min2 = ::Math_obj::floor(c7);
            									}
            									else {
HXLINE(  63)										min2 = ::Math_obj::ceil(a9);
            									}
HXDLIN(  63)									int ii_min7 = min2;
HXDLIN(  63)									int ii_max7 = ::Math_obj::ceil(b15);
HXDLIN(  63)									v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            								}
            								else {
HXLINE(  63)									int ii_min8 = ::Math_obj::floor(a9);
HXDLIN(  63)									int ii_max8 = ::Math_obj::ceil(c7);
HXDLIN(  63)									v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            								}
            							}
HXDLIN(  63)							Float a10 = v_ay;
HXDLIN(  63)							Float b16 = v_by;
HXDLIN(  63)							Float c8 = v_cy;
HXDLIN(  63)							if ((a10 > b16)) {
HXLINE(  63)								if ((a10 > c8)) {
HXLINE(  63)									int min3;
HXDLIN(  63)									if ((b16 > c8)) {
HXLINE(  63)										min3 = ::Math_obj::floor(c8);
            									}
            									else {
HXLINE(  63)										min3 = ::Math_obj::floor(b16);
            									}
HXDLIN(  63)									int ii_min9 = min3;
HXDLIN(  63)									int ii_max9 = ::Math_obj::ceil(a10);
HXDLIN(  63)									v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            								}
            								else {
HXLINE(  63)									int ii_min10 = ::Math_obj::floor(b16);
HXDLIN(  63)									int ii_max10 = ::Math_obj::ceil(c8);
HXDLIN(  63)									v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            								}
            							}
            							else {
HXLINE(  63)								if ((b16 > c8)) {
HXLINE(  63)									int min4;
HXDLIN(  63)									if ((a10 > c8)) {
HXLINE(  63)										min4 = ::Math_obj::floor(c8);
            									}
            									else {
HXLINE(  63)										min4 = ::Math_obj::ceil(a10);
            									}
HXDLIN(  63)									int ii_min11 = min4;
HXDLIN(  63)									int ii_max11 = ::Math_obj::ceil(b16);
HXDLIN(  63)									v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            								}
            								else {
HXLINE(  63)									int ii_min12 = ::Math_obj::floor(a10);
HXDLIN(  63)									int ii_max12 = ::Math_obj::ceil(c8);
HXDLIN(  63)									v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            								}
            							}
            						}
HXDLIN(  63)						if (hasUndo) {
HXLINE(  63)							v_undoImage = undoImage;
HXDLIN(  63)							v_undoX = xIter3->start;
HXDLIN(  63)							v_undoY = yIter3->start;
            						}
HXDLIN(  63)						Float au1 = bu;
HXDLIN(  63)						Float av1 = bv;
HXDLIN(  63)						Float bu2 = cu;
HXDLIN(  63)						Float bv2 = cv;
HXDLIN(  63)						bool hasUndo1 = false;
HXDLIN(  63)						Float temp1 = au1;
HXLINE( 422)						au1 = bu2;
HXLINE( 423)						bu2 = temp1;
HXLINE( 424)						temp1 = av1;
HXLINE( 425)						av1 = bv2;
HXLINE( 426)						bv2 = temp1;
HXLINE(  63)						Float bcx1 = w1;
HXDLIN(  63)						Float bcy1 = (h - h);
HXDLIN(  63)						Float acx1 = w1;
HXDLIN(  63)						Float acy1 = (( (Float)(0) ) - h);
HXDLIN(  63)						Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  63)						Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  63)						Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  63)						Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  63)						 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  63)						if ((w1 > w1)) {
HXLINE(  63)							if ((w1 > 0)) {
HXLINE(  63)								int min5;
HXDLIN(  63)								if ((w1 > 0)) {
HXLINE(  63)									min5 = ::Math_obj::floor(( (Float)(0) ));
            								}
            								else {
HXLINE(  63)									min5 = ::Math_obj::floor(w1);
            								}
HXDLIN(  63)								int ii_min13 = min5;
HXDLIN(  63)								int ii_max13 = ::Math_obj::ceil(w1);
HXDLIN(  63)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            							}
            							else {
HXLINE(  63)								int ii_min14 = ::Math_obj::floor(w1);
HXDLIN(  63)								int ii_max14 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  63)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            							}
            						}
            						else {
HXLINE(  63)							if ((w1 > 0)) {
HXLINE(  63)								int min6;
HXDLIN(  63)								if ((w1 > 0)) {
HXLINE(  63)									min6 = ::Math_obj::floor(( (Float)(0) ));
            								}
            								else {
HXLINE(  63)									min6 = ::Math_obj::ceil(w1);
            								}
HXDLIN(  63)								int ii_min15 = min6;
HXDLIN(  63)								int ii_max15 = ::Math_obj::ceil(w1);
HXDLIN(  63)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            							}
            							else {
HXLINE(  63)								int ii_min16 = ::Math_obj::floor(w1);
HXDLIN(  63)								int ii_max16 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  63)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            							}
            						}
HXDLIN(  63)						 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  63)						if ((0 > h)) {
HXLINE(  63)							if ((0 > h)) {
HXLINE(  63)								int min7;
HXDLIN(  63)								if ((h > h)) {
HXLINE(  63)									min7 = ::Math_obj::floor(h);
            								}
            								else {
HXLINE(  63)									min7 = ::Math_obj::floor(h);
            								}
HXDLIN(  63)								int ii_min17 = min7;
HXDLIN(  63)								int ii_max17 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  63)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            							}
            							else {
HXLINE(  63)								int ii_min18 = ::Math_obj::floor(h);
HXDLIN(  63)								int ii_max18 = ::Math_obj::ceil(h);
HXDLIN(  63)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            							}
            						}
            						else {
HXLINE(  63)							if ((h > h)) {
HXLINE(  63)								int min8;
HXDLIN(  63)								if ((0 > h)) {
HXLINE(  63)									min8 = ::Math_obj::floor(h);
            								}
            								else {
HXLINE(  63)									min8 = ::Math_obj::ceil(( (Float)(0) ));
            								}
HXDLIN(  63)								int ii_min19 = min8;
HXDLIN(  63)								int ii_max19 = ::Math_obj::ceil(h);
HXDLIN(  63)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            							}
            							else {
HXLINE(  63)								int ii_min20 = ::Math_obj::floor(( (Float)(0) ));
HXDLIN(  63)								int ii_max20 = ::Math_obj::ceil(h);
HXDLIN(  63)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            							}
            						}
HXDLIN(  63)						 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  63)						if (hasUndo1) {
HXLINE(  63)							int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  63)							int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  63)							 ::Dynamic imageType3 = null();
HXDLIN(  63)							 ::pi_xy::ImageStruct this53 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  63)							if (::hx::IsNull( imageType3 )) {
HXLINE(  54)								imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE(  63)							::Dynamic undoImage4;
HXDLIN(  63)							switch((int)(( (int)(imageType3) ))){
            								case (int)0: {
HXLINE(  63)									 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  63)									 ::iterMagic::BytesImg b17 = byt3;
HXDLIN(  63)									{
HXLINE(  63)										b17->width = width1;
HXDLIN(  63)										b17->height = height1;
HXDLIN(  63)										b17->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  63)										b17->data = ::haxe::io::Bytes_obj::alloc((b17->length * 4));
HXDLIN(  63)										{
HXLINE(  63)											int len6 = b17->length;
HXDLIN(  63)											int w4 = 0;
HXDLIN(  63)											{
HXLINE(  63)												int _g52 = 0;
HXDLIN(  63)												int _g53 = b17->height;
HXDLIN(  63)												while((_g52 < _g53)){
HXLINE(  63)													_g52 = (_g52 + 1);
HXDLIN(  63)													int y7 = (_g52 - 1);
HXDLIN(  63)													{
HXLINE(  63)														int _g54 = 0;
HXDLIN(  63)														int _g55 = b17->width;
HXDLIN(  63)														while((_g54 < _g55)){
HXLINE(  63)															_g54 = (_g54 + 1);
HXDLIN(  63)															int x8 = (_g54 - 1);
HXDLIN(  63)															{
HXLINE(  63)																w4 = (w4 + 1);
HXDLIN(  63)																b17->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  63)															{
HXLINE(  63)																w4 = (w4 + 1);
HXDLIN(  63)																b17->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  63)															{
HXLINE(  63)																w4 = (w4 + 1);
HXDLIN(  63)																b17->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  63)															{
HXLINE(  63)																w4 = (w4 + 1);
HXDLIN(  63)																b17->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  63)									undoImage4 = b17;
            								}
            								break;
            								case (int)1: {
HXLINE(  63)									 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  63)									 ::iterMagic::ArrIntImg a13 = arrI3;
HXDLIN(  63)									{
HXLINE(  63)										a13->width = width1;
HXDLIN(  63)										a13->height = height1;
HXDLIN(  63)										a13->data = ::Array_obj< int >::__new(0);
HXDLIN(  63)										a13->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  63)										{
HXLINE(  63)											int _g56 = 0;
HXDLIN(  63)											int _g57 = a13->length;
HXDLIN(  63)											while((_g56 < _g57)){
HXLINE(  63)												_g56 = (_g56 + 1);
HXDLIN(  63)												int i18 = (_g56 - 1);
HXDLIN(  63)												a13->data[i18] = 0;
            											}
            										}
            									}
HXDLIN(  63)									undoImage4 = a13;
            								}
            								break;
            								case (int)2: {
HXLINE(  63)									 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  63)									 ::iterMagic::U32ArrImg b18 = u32a3;
HXDLIN(  63)									{
HXLINE(  63)										b18->width = width1;
HXDLIN(  63)										b18->height = height1;
HXDLIN(  63)										b18->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  63)										int size3 = (b18->length * 4);
HXDLIN(  63)										b18->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN(  63)										{
HXLINE(  63)											int _g58 = 0;
HXDLIN(  63)											int _g59 = b18->length;
HXDLIN(  63)											while((_g58 < _g59)){
HXLINE(  63)												_g58 = (_g58 + 1);
HXDLIN(  63)												int i19 = (_g58 - 1);
HXDLIN(  63)												{
HXLINE(  63)													 ::haxe::io::ArrayBufferViewImpl this54 = b18->data;
HXDLIN(  63)													bool undoImage5;
HXDLIN(  63)													if ((i19 >= 0)) {
HXLINE(  63)														undoImage5 = (i19 < (this54->byteLength >> 2));
            													}
            													else {
HXLINE(  63)														undoImage5 = false;
            													}
HXDLIN(  63)													if (undoImage5) {
HXLINE(  63)														 ::haxe::io::Bytes _this3 = this54->bytes;
HXDLIN(  63)														int pos3 = ((i19 << 2) + this54->byteOffset);
HXDLIN(  63)														_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN(  63)														_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN(  63)														_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN(  63)														_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN(  63)									undoImage4 = b18;
            								}
            								break;
            								case (int)3: {
HXLINE(  63)									 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  63)									 ::iterMagic::VecIntImg v7 = vec3;
HXDLIN(  63)									{
HXLINE(  63)										v7->width = width1;
HXDLIN(  63)										v7->height = height1;
HXDLIN(  63)										v7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  63)										v7->data = ::Array_obj< int >::__new(v7->length);
HXDLIN(  63)										{
HXLINE(  63)											int _g60 = 0;
HXDLIN(  63)											int _g61 = v7->length;
HXDLIN(  63)											while((_g60 < _g61)){
HXLINE(  63)												_g60 = (_g60 + 1);
HXDLIN(  63)												int i20 = (_g60 - 1);
HXDLIN(  63)												v7->data->__unsafe_set(i20,0);
            											}
            										}
            									}
HXDLIN(  63)									undoImage4 = v7;
            								}
            								break;
            								case (int)4: {
HXLINE(  63)									 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  63)									 ::iterMagic::StackIntImg b19 = sInt3;
HXDLIN(  63)									{
HXLINE(  63)										b19->width = width1;
HXDLIN(  63)										b19->height = height1;
HXDLIN(  63)										b19->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  63)										b19->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  63)										{
HXLINE(  63)											int len7 = b19->length;
HXDLIN(  63)											 ::haxe::ds::GenericStack_Int d3 = b19->data;
HXDLIN(  63)											if (::hx::IsNull( d3->head )) {
HXLINE(  63)												int _g62 = 0;
HXDLIN(  63)												int _g63 = len7;
HXDLIN(  63)												while((_g62 < _g63)){
HXLINE(  63)													_g62 = (_g62 + 1);
HXDLIN(  63)													int i21 = (_g62 - 1);
HXDLIN(  63)													d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            												}
            											}
            											else {
HXLINE(  63)												int _g64 = 0;
HXDLIN(  63)												int _g65 = len7;
HXDLIN(  63)												while((_g64 < _g65)){
HXLINE(  63)													_g64 = (_g64 + 1);
HXDLIN(  63)													int i22 = (_g64 - 1);
HXDLIN(  63)													{
HXLINE(  63)														 ::haxe::ds::GenericCell_Int l3 = b19->data->head;
HXDLIN(  63)														 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN(  63)														{
HXLINE(  63)															int _g66 = 0;
HXDLIN(  63)															int _g67 = i22;
HXDLIN(  63)															while((_g66 < _g67)){
HXLINE(  63)																_g66 = (_g66 + 1);
HXDLIN(  63)																int i23 = (_g66 - 1);
HXLINE( 345)																prev3 = l3;
HXLINE( 346)																l3 = l3->next;
            															}
            														}
HXLINE(  63)														if (::hx::IsNull( prev3 )) {
HXLINE(  63)															b19->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  63)															l3 = null();
            														}
            														else {
HXLINE(  63)															prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  63)															l3 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  63)									undoImage4 = b19;
            								}
            								break;
            							}
HXDLIN(  63)							this53->image = undoImage4;
HXDLIN(  63)							this53->width = width1;
HXDLIN(  63)							this53->height = height1;
HXDLIN(  63)							this53->imageType = ( (int)(imageType3) );
HXDLIN(  63)							undoImage3 = this53;
HXDLIN(  63)							{
HXLINE(  63)								int rectLeft1 = xIter31->start;
HXDLIN(  63)								int rectTop1 = yIter31->start;
HXDLIN(  63)								int rectRight1 = xIter31->max;
HXDLIN(  63)								bool forceClear1 = false;
HXDLIN(  63)								{
HXLINE(  63)									int _g68 = rectTop1;
HXDLIN(  63)									int _g69 = yIter31->max;
HXDLIN(  63)									while((_g68 < _g69)){
HXLINE(  63)										_g68 = (_g68 + 1);
HXDLIN(  63)										int dy1 = (_g68 - 1);
HXDLIN(  63)										{
HXLINE(  63)											int _g70 = rectLeft1;
HXDLIN(  63)											int _g71 = rectRight1;
HXDLIN(  63)											while((_g70 < _g71)){
HXLINE(  63)												_g70 = (_g70 + 1);
HXDLIN(  63)												int dx1 = (_g70 - 1);
HXDLIN(  63)												::Dynamic this55 = this18->image;
HXDLIN(  63)												int index8;
HXDLIN(  63)												if (this18->useVirtualPos) {
HXLINE(  63)													index8 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this18->virtualY) * ( (Float)(this18->width) )) + dx1) - this18->virtualX));
            												}
            												else {
HXLINE(  63)													index8 = ::Std_obj::_hx_int(( (Float)(((dy1 * this18->width) + dx1)) ));
            												}
HXDLIN(  63)												int c9 = ::iterMagic::Iimg_obj::get(this55,index8);
HXDLIN(  63)												int col2;
HXDLIN(  63)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)													col2 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            												}
            												else {
HXLINE(  63)													col2 = c9;
            												}
HXDLIN(  63)												bool _hx_tmp18;
HXDLIN(  63)												if (this18->useMask) {
HXLINE(  63)													_hx_tmp18 = ::hx::IsNotNull( this18->mask );
            												}
            												else {
HXLINE(  63)													_hx_tmp18 = false;
            												}
HXDLIN(  63)												if (_hx_tmp18) {
HXLINE(  63)													 ::pi_xy::ImageStruct this56 = this18->mask;
HXDLIN(  63)													::Dynamic this57 = this56->image;
HXDLIN(  63)													int index9;
HXDLIN(  63)													if (this56->useVirtualPos) {
HXLINE(  63)														index9 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this56->virtualY) * ( (Float)(this56->width) )) + dx1) - this56->virtualX));
            													}
            													else {
HXLINE(  63)														index9 = ::Std_obj::_hx_int(( (Float)(((dy1 * this56->width) + dx1)) ));
            													}
HXDLIN(  63)													int c10 = ::iterMagic::Iimg_obj::get(this57,index9);
HXDLIN(  63)													int v8;
HXDLIN(  63)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)														v8 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            													}
            													else {
HXLINE(  63)														v8 = c10;
            													}
HXDLIN(  63)													int maskPixel1 = v8;
HXDLIN(  63)													int this58 = col2;
HXDLIN(  63)													if ((maskPixel1 == 0)) {
HXLINE(  63)														col2 = this58;
            													}
            													else {
HXLINE(  63)														Float m01;
HXDLIN(  63)														int this59 = ((maskPixel1 >> 24) & 255);
HXDLIN(  63)														if ((this59 == 0)) {
HXLINE(  63)															m01 = ((Float)0.);
            														}
            														else {
HXLINE(  63)															m01 = (( (Float)(this59) ) / ( (Float)(255) ));
            														}
HXDLIN(  63)														Float m11;
HXDLIN(  63)														int this60 = ((maskPixel1 >> 16) & 255);
HXDLIN(  63)														if ((this60 == 0)) {
HXLINE(  63)															m11 = ((Float)0.);
            														}
            														else {
HXLINE(  63)															m11 = (( (Float)(this60) ) / ( (Float)(255) ));
            														}
HXDLIN(  63)														Float m21;
HXDLIN(  63)														int this61 = ((maskPixel1 >> 8) & 255);
HXDLIN(  63)														if ((this61 == 0)) {
HXLINE(  63)															m21 = ((Float)0.);
            														}
            														else {
HXLINE(  63)															m21 = (( (Float)(this61) ) / ( (Float)(255) ));
            														}
HXDLIN(  63)														Float m31;
HXDLIN(  63)														int this62 = (maskPixel1 & 255);
HXDLIN(  63)														if ((this62 == 0)) {
HXLINE(  63)															m31 = ((Float)0.);
            														}
            														else {
HXLINE(  63)															m31 = (( (Float)(this62) ) / ( (Float)(255) ));
            														}
HXDLIN(  63)														int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this58 >> 24) & 255)) )));
HXDLIN(  63)														int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this58 >> 16) & 255)) )));
HXDLIN(  63)														int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this58 >> 8) & 255)) )));
HXDLIN(  63)														int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this58 & 255)) )));
HXDLIN(  63)														col2 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  63)												if ((col2 != 0)) {
HXLINE(  63)													int x9 = (dx1 - rectLeft1);
HXDLIN(  63)													int y8 = (dy1 - rectTop1);
HXDLIN(  63)													int c11 = col2;
HXDLIN(  63)													bool _hx_tmp19;
HXDLIN(  63)													if ((((c11 >> 24) & 255) < 254)) {
HXLINE(  63)														_hx_tmp19 = undoImage3->transparent;
            													}
            													else {
HXLINE(  63)														_hx_tmp19 = false;
            													}
HXDLIN(  63)													if (_hx_tmp19) {
HXLINE(  63)														int location3;
HXDLIN(  63)														if (undoImage3->useVirtualPos) {
HXLINE(  63)															location3 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x9) - undoImage3->virtualX));
            														}
            														else {
HXLINE(  63)															location3 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage3->width) + x9)) ));
            														}
HXDLIN(  63)														int this63 = ::iterMagic::Iimg_obj::get(undoImage3->image,location3);
HXDLIN(  63)														int this64;
HXDLIN(  63)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)															this64 = ((((((this63 >> 24) & 255) << 24) | ((this63 & 255) << 16)) | (((this63 >> 8) & 255) << 8)) | ((this63 >> 16) & 255));
            														}
            														else {
HXLINE(  63)															this64 = this63;
            														}
HXDLIN(  63)														Float a14;
HXDLIN(  63)														int this65 = ((this64 >> 24) & 255);
HXDLIN(  63)														if ((this65 == 0)) {
HXLINE(  63)															a14 = ((Float)0.);
            														}
            														else {
HXLINE(  63)															a14 = (( (Float)(this65) ) / ( (Float)(255) ));
            														}
HXDLIN(  63)														Float r13;
HXDLIN(  63)														int this66 = ((this64 >> 16) & 255);
HXDLIN(  63)														if ((this66 == 0)) {
HXLINE(  63)															r13 = ((Float)0.);
            														}
            														else {
HXLINE(  63)															r13 = (( (Float)(this66) ) / ( (Float)(255) ));
            														}
HXDLIN(  63)														Float g13;
HXDLIN(  63)														int this67 = ((this64 >> 8) & 255);
HXDLIN(  63)														if ((this67 == 0)) {
HXLINE(  63)															g13 = ((Float)0.);
            														}
            														else {
HXLINE(  63)															g13 = (( (Float)(this67) ) / ( (Float)(255) ));
            														}
HXDLIN(  63)														Float b110;
HXDLIN(  63)														int this68 = (this64 & 255);
HXDLIN(  63)														if ((this68 == 0)) {
HXLINE(  63)															b110 = ((Float)0.);
            														}
            														else {
HXLINE(  63)															b110 = (( (Float)(this68) ) / ( (Float)(255) ));
            														}
HXDLIN(  63)														Float a23;
HXDLIN(  63)														int this69 = ((col2 >> 24) & 255);
HXDLIN(  63)														if ((this69 == 0)) {
HXLINE(  63)															a23 = ((Float)0.);
            														}
            														else {
HXLINE(  63)															a23 = (( (Float)(this69) ) / ( (Float)(255) ));
            														}
HXDLIN(  63)														Float r23;
HXDLIN(  63)														int this70 = ((col2 >> 16) & 255);
HXDLIN(  63)														if ((this70 == 0)) {
HXLINE(  63)															r23 = ((Float)0.);
            														}
            														else {
HXLINE(  63)															r23 = (( (Float)(this70) ) / ( (Float)(255) ));
            														}
HXDLIN(  63)														Float g23;
HXDLIN(  63)														int this71 = ((col2 >> 8) & 255);
HXDLIN(  63)														if ((this71 == 0)) {
HXLINE(  63)															g23 = ((Float)0.);
            														}
            														else {
HXLINE(  63)															g23 = (( (Float)(this71) ) / ( (Float)(255) ));
            														}
HXDLIN(  63)														Float b24;
HXDLIN(  63)														int this72 = (col2 & 255);
HXDLIN(  63)														if ((this72 == 0)) {
HXLINE(  63)															b24 = ((Float)0.);
            														}
            														else {
HXLINE(  63)															b24 = (( (Float)(this72) ) / ( (Float)(255) ));
            														}
HXDLIN(  63)														Float a33 = (a14 * (( (Float)(1) ) - a23));
HXDLIN(  63)														int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  63)														int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  63)														int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a33) + (b24 * a23))));
HXDLIN(  63)														int a15 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  63)														int blended3 = ((((a15 << 24) | (r5 << 16)) | (g5 << 8)) | b20);
HXDLIN(  63)														{
HXLINE(  63)															int _hx_tmp20;
HXDLIN(  63)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)																_hx_tmp20 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            															}
            															else {
HXLINE(  63)																_hx_tmp20 = blended3;
            															}
HXDLIN(  63)															::iterMagic::Iimg_obj::set(undoImage3->image,location3,_hx_tmp20);
            														}
            													}
            													else {
HXLINE(  63)														::Dynamic this73 = undoImage3->image;
HXDLIN(  63)														int index10;
HXDLIN(  63)														if (undoImage3->useVirtualPos) {
HXLINE(  63)															index10 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x9) - undoImage3->virtualX));
            														}
            														else {
HXLINE(  63)															index10 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage3->width) + x9)) ));
            														}
HXDLIN(  63)														int _hx_tmp21;
HXDLIN(  63)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)															_hx_tmp21 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            														}
            														else {
HXLINE(  63)															_hx_tmp21 = c11;
            														}
HXDLIN(  63)														::iterMagic::Iimg_obj::set(this73,index10,_hx_tmp21);
            													}
            												}
            												else {
HXLINE(  63)													if (forceClear1) {
HXLINE(  63)														::Dynamic this74 = undoImage3->image;
HXDLIN(  63)														int x10 = (dx1 - rectLeft1);
HXDLIN(  63)														int y9 = (dy1 - rectTop1);
HXDLIN(  63)														int index11;
HXDLIN(  63)														if (undoImage3->useVirtualPos) {
HXLINE(  63)															index11 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x10) - undoImage3->virtualX));
            														}
            														else {
HXLINE(  63)															index11 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage3->width) + x10)) ));
            														}
HXDLIN(  63)														::iterMagic::Iimg_obj::set(this74,index11,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  63)						{
HXLINE(  63)							int _g_min2 = xIter31->start;
HXDLIN(  63)							int _g_max2 = xIter31->max;
HXDLIN(  63)							while((_g_min2 < _g_max2)){
HXLINE(  63)								_g_min2 = (_g_min2 + 1);
HXDLIN(  63)								int px1 = (_g_min2 - 1);
HXDLIN(  63)								Float pcx1 = ( (Float)(px1) );
HXDLIN(  63)								{
HXLINE(  63)									int _g_min3 = yIter31->start;
HXDLIN(  63)									int _g_max3 = yIter31->max;
HXDLIN(  63)									while((_g_min3 < _g_max3)){
HXLINE(  63)										_g_min3 = (_g_min3 + 1);
HXDLIN(  63)										int py1 = (_g_min3 - 1);
HXDLIN(  63)										Float pcy1 = (( (Float)(py1) ) - h);
HXDLIN(  63)										Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN(  63)										Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN(  63)										Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN(  63)										Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN(  63)										Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN(  63)										bool _hx_tmp22;
HXDLIN(  63)										bool _hx_tmp23;
HXDLIN(  63)										if ((ratioA1 >= 0)) {
HXLINE(  63)											_hx_tmp23 = (ratioB1 >= 0);
            										}
            										else {
HXLINE(  63)											_hx_tmp23 = false;
            										}
HXDLIN(  63)										if (_hx_tmp23) {
HXLINE(  63)											_hx_tmp22 = (ratioC1 >= 0);
            										}
            										else {
HXLINE(  63)											_hx_tmp22 = false;
            										}
HXDLIN(  63)										if (_hx_tmp22) {
HXLINE(  63)											Float u1 = (((au1 * ratioA1) + (bu2 * ratioB1)) + (du * ratioC1));
HXDLIN(  63)											Float v9 = (((av1 * ratioA1) + (bv2 * ratioB1)) + (dv * ratioC1));
HXDLIN(  63)											int x11 = ::Std_obj::_hx_int(((u1 * win_width) + win_x));
HXDLIN(  63)											int y10 = ::Std_obj::_hx_int(((v9 * win_height) + win_y));
HXDLIN(  63)											::Dynamic this75 = thisImage->image;
HXDLIN(  63)											int index12;
HXDLIN(  63)											if (thisImage->useVirtualPos) {
HXLINE(  63)												index12 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - thisImage->virtualY) * ( (Float)(thisImage->width) )) + x11) - thisImage->virtualX));
            											}
            											else {
HXLINE(  63)												index12 = ::Std_obj::_hx_int(( (Float)(((y10 * thisImage->width) + x11)) ));
            											}
HXDLIN(  63)											int c12 = ::iterMagic::Iimg_obj::get(this75,index12);
HXDLIN(  63)											int col3;
HXDLIN(  63)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)												col3 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            											}
            											else {
HXLINE(  63)												col3 = c12;
            											}
HXDLIN(  63)											{
HXLINE(  63)												int c13 = col3;
HXDLIN(  63)												bool _hx_tmp24;
HXDLIN(  63)												if ((((c13 >> 24) & 255) < 254)) {
HXLINE(  63)													_hx_tmp24 = this18->transparent;
            												}
            												else {
HXLINE(  63)													_hx_tmp24 = false;
            												}
HXDLIN(  63)												if (_hx_tmp24) {
HXLINE(  63)													int location4;
HXDLIN(  63)													if (this18->useVirtualPos) {
HXLINE(  63)														location4 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this18->virtualY) * ( (Float)(this18->width) )) + px1) - this18->virtualX));
            													}
            													else {
HXLINE(  63)														location4 = ::Std_obj::_hx_int(( (Float)(((py1 * this18->width) + px1)) ));
            													}
HXDLIN(  63)													int this76 = ::iterMagic::Iimg_obj::get(this18->image,location4);
HXDLIN(  63)													int this77;
HXDLIN(  63)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)														this77 = ((((((this76 >> 24) & 255) << 24) | ((this76 & 255) << 16)) | (((this76 >> 8) & 255) << 8)) | ((this76 >> 16) & 255));
            													}
            													else {
HXLINE(  63)														this77 = this76;
            													}
HXDLIN(  63)													Float a16;
HXDLIN(  63)													int this78 = ((this77 >> 24) & 255);
HXDLIN(  63)													if ((this78 == 0)) {
HXLINE(  63)														a16 = ((Float)0.);
            													}
            													else {
HXLINE(  63)														a16 = (( (Float)(this78) ) / ( (Float)(255) ));
            													}
HXDLIN(  63)													Float r14;
HXDLIN(  63)													int this79 = ((this77 >> 16) & 255);
HXDLIN(  63)													if ((this79 == 0)) {
HXLINE(  63)														r14 = ((Float)0.);
            													}
            													else {
HXLINE(  63)														r14 = (( (Float)(this79) ) / ( (Float)(255) ));
            													}
HXDLIN(  63)													Float g14;
HXDLIN(  63)													int this80 = ((this77 >> 8) & 255);
HXDLIN(  63)													if ((this80 == 0)) {
HXLINE(  63)														g14 = ((Float)0.);
            													}
            													else {
HXLINE(  63)														g14 = (( (Float)(this80) ) / ( (Float)(255) ));
            													}
HXDLIN(  63)													Float b111;
HXDLIN(  63)													int this81 = (this77 & 255);
HXDLIN(  63)													if ((this81 == 0)) {
HXLINE(  63)														b111 = ((Float)0.);
            													}
            													else {
HXLINE(  63)														b111 = (( (Float)(this81) ) / ( (Float)(255) ));
            													}
HXDLIN(  63)													Float a24;
HXDLIN(  63)													int this82 = ((col3 >> 24) & 255);
HXDLIN(  63)													if ((this82 == 0)) {
HXLINE(  63)														a24 = ((Float)0.);
            													}
            													else {
HXLINE(  63)														a24 = (( (Float)(this82) ) / ( (Float)(255) ));
            													}
HXDLIN(  63)													Float r24;
HXDLIN(  63)													int this83 = ((col3 >> 16) & 255);
HXDLIN(  63)													if ((this83 == 0)) {
HXLINE(  63)														r24 = ((Float)0.);
            													}
            													else {
HXLINE(  63)														r24 = (( (Float)(this83) ) / ( (Float)(255) ));
            													}
HXDLIN(  63)													Float g24;
HXDLIN(  63)													int this84 = ((col3 >> 8) & 255);
HXDLIN(  63)													if ((this84 == 0)) {
HXLINE(  63)														g24 = ((Float)0.);
            													}
            													else {
HXLINE(  63)														g24 = (( (Float)(this84) ) / ( (Float)(255) ));
            													}
HXDLIN(  63)													Float b25;
HXDLIN(  63)													int this85 = (col3 & 255);
HXDLIN(  63)													if ((this85 == 0)) {
HXLINE(  63)														b25 = ((Float)0.);
            													}
            													else {
HXLINE(  63)														b25 = (( (Float)(this85) ) / ( (Float)(255) ));
            													}
HXDLIN(  63)													Float a34 = (a16 * (( (Float)(1) ) - a24));
HXDLIN(  63)													int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN(  63)													int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN(  63)													int b26 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a34) + (b25 * a24))));
HXDLIN(  63)													int a17 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN(  63)													int blended4 = ((((a17 << 24) | (r6 << 16)) | (g6 << 8)) | b26);
HXDLIN(  63)													{
HXLINE(  63)														int _hx_tmp25;
HXDLIN(  63)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)															_hx_tmp25 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            														}
            														else {
HXLINE(  63)															_hx_tmp25 = blended4;
            														}
HXDLIN(  63)														::iterMagic::Iimg_obj::set(this18->image,location4,_hx_tmp25);
            													}
            												}
            												else {
HXLINE(  63)													::Dynamic this86 = this18->image;
HXDLIN(  63)													int index13;
HXDLIN(  63)													if (this18->useVirtualPos) {
HXLINE(  63)														index13 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this18->virtualY) * ( (Float)(this18->width) )) + px1) - this18->virtualX));
            													}
            													else {
HXLINE(  63)														index13 = ::Std_obj::_hx_int(( (Float)(((py1 * this18->width) + px1)) ));
            													}
HXDLIN(  63)													int _hx_tmp26;
HXDLIN(  63)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  63)														_hx_tmp26 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            													}
            													else {
HXLINE(  63)														_hx_tmp26 = c13;
            													}
HXDLIN(  63)													::iterMagic::Iimg_obj::set(this86,index13,_hx_tmp26);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  63)						 ::pi_xy::iter::IntIterStart v_yIter31;
HXDLIN(  63)						 ::pi_xy::iter::IntIterStart v_xIter31;
HXDLIN(  63)						int v_undoY1;
HXDLIN(  63)						int v_undoX1;
HXDLIN(  63)						Float v_ty1;
HXDLIN(  63)						Float v_tx1;
HXDLIN(  63)						Float v_t01;
HXDLIN(  63)						Float v_sy1;
HXDLIN(  63)						Float v_sx1;
HXDLIN(  63)						Float v_s01;
HXDLIN(  63)						Float v_A1;
HXDLIN(  63)						Float ax = w1;
HXDLIN(  63)						 ::pi_xy::ImageStruct v_undoImage1 = null();
HXDLIN(  63)						Float bx1 = w1;
HXDLIN(  63)						Float by1 = h;
HXDLIN(  63)						Float cx1 = ( (Float)(0) );
HXDLIN(  63)						Float cy1 = h;
HXDLIN(  63)						bool adjustWinding1 = (((((ax * by1) - (bx1 * ( (Float)(0) ))) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ( (Float)(0) )) - (ax * cy1))) > 0);
HXDLIN(  63)						if (!(adjustWinding1)) {
HXLINE(  63)							Float bx_1 = bx1;
HXDLIN(  63)							Float by_1 = by1;
HXLINE(  24)							bx1 = cx1;
HXLINE(  25)							by1 = cy1;
HXLINE(  26)							cx1 = bx_1;
HXLINE(  27)							cy1 = by_1;
            						}
HXLINE(  63)						Float v_ax1 = ax;
HXDLIN(  63)						Float v_ay1 = ( (Float)(0) );
HXDLIN(  63)						Float v_bx1 = bx1;
HXDLIN(  63)						Float v_by1 = by1;
HXDLIN(  63)						Float v_cx1 = cx1;
HXDLIN(  63)						Float v_cy1 = cy1;
HXDLIN(  63)						bool v_preCalculated1 = true;
HXDLIN(  63)						{
HXLINE(  63)							v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN(  63)							v_sx1 = (v_cy1 - v_ay1);
HXDLIN(  63)							v_sy1 = (v_ax1 - v_cx1);
HXDLIN(  63)							v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN(  63)							v_tx1 = (v_ay1 - v_by1);
HXDLIN(  63)							v_ty1 = (v_bx1 - v_ax1);
HXDLIN(  63)							v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN(  63)							Float a18 = v_ax1;
HXDLIN(  63)							Float b27 = v_bx1;
HXDLIN(  63)							Float c14 = v_cx1;
HXDLIN(  63)							if ((a18 > b27)) {
HXLINE(  63)								if ((a18 > c14)) {
HXLINE(  63)									int min9;
HXDLIN(  63)									if ((b27 > c14)) {
HXLINE(  63)										min9 = ::Math_obj::floor(c14);
            									}
            									else {
HXLINE(  63)										min9 = ::Math_obj::floor(b27);
            									}
HXDLIN(  63)									int ii_min21 = min9;
HXDLIN(  63)									int ii_max21 = ::Math_obj::ceil(a18);
HXDLIN(  63)									v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            								}
            								else {
HXLINE(  63)									int ii_min22 = ::Math_obj::floor(b27);
HXDLIN(  63)									int ii_max22 = ::Math_obj::ceil(c14);
HXDLIN(  63)									v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            								}
            							}
            							else {
HXLINE(  63)								if ((b27 > c14)) {
HXLINE(  63)									int min10;
HXDLIN(  63)									if ((a18 > c14)) {
HXLINE(  63)										min10 = ::Math_obj::floor(c14);
            									}
            									else {
HXLINE(  63)										min10 = ::Math_obj::ceil(a18);
            									}
HXDLIN(  63)									int ii_min23 = min10;
HXDLIN(  63)									int ii_max23 = ::Math_obj::ceil(b27);
HXDLIN(  63)									v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            								}
            								else {
HXLINE(  63)									int ii_min24 = ::Math_obj::floor(a18);
HXDLIN(  63)									int ii_max24 = ::Math_obj::ceil(c14);
HXDLIN(  63)									v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            								}
            							}
HXDLIN(  63)							Float a19 = v_ay1;
HXDLIN(  63)							Float b28 = v_by1;
HXDLIN(  63)							Float c15 = v_cy1;
HXDLIN(  63)							if ((a19 > b28)) {
HXLINE(  63)								if ((a19 > c15)) {
HXLINE(  63)									int min11;
HXDLIN(  63)									if ((b28 > c15)) {
HXLINE(  63)										min11 = ::Math_obj::floor(c15);
            									}
            									else {
HXLINE(  63)										min11 = ::Math_obj::floor(b28);
            									}
HXDLIN(  63)									int ii_min25 = min11;
HXDLIN(  63)									int ii_max25 = ::Math_obj::ceil(a19);
HXDLIN(  63)									v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            								}
            								else {
HXLINE(  63)									int ii_min26 = ::Math_obj::floor(b28);
HXDLIN(  63)									int ii_max26 = ::Math_obj::ceil(c15);
HXDLIN(  63)									v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            								}
            							}
            							else {
HXLINE(  63)								if ((b28 > c15)) {
HXLINE(  63)									int min12;
HXDLIN(  63)									if ((a19 > c15)) {
HXLINE(  63)										min12 = ::Math_obj::floor(c15);
            									}
            									else {
HXLINE(  63)										min12 = ::Math_obj::ceil(a19);
            									}
HXDLIN(  63)									int ii_min27 = min12;
HXDLIN(  63)									int ii_max27 = ::Math_obj::ceil(b28);
HXDLIN(  63)									v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            								}
            								else {
HXLINE(  63)									int ii_min28 = ::Math_obj::floor(a19);
HXDLIN(  63)									int ii_max28 = ::Math_obj::ceil(c15);
HXDLIN(  63)									v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            								}
            							}
            						}
HXDLIN(  63)						if (hasUndo1) {
HXLINE(  63)							v_undoImage1 = undoImage3;
HXDLIN(  63)							v_undoX1 = xIter31->start;
HXDLIN(  63)							v_undoY1 = yIter31->start;
            						}
            					}
            				}
HXDLIN(  63)				bool _hx_tmp27;
HXDLIN(  63)				if (::hx::IsNotNull( thisImage->mask )) {
HXLINE(  63)					_hx_tmp27 = includeMask1;
            				}
            				else {
HXLINE(  63)					_hx_tmp27 = false;
            				}
HXDLIN(  63)				if (_hx_tmp27) {
HXLINE(  63)					 ::pi_xy::ImageStruct v10 = ::pi_xy::transformation::_ScaleImage::ScaleImage_Fields__obj::scalingXY(thisImage->mask,sx,sy,thisImage->mask->transparent,includeMask1);
HXDLIN(  63)					nextImage1->useMask = true;
HXDLIN(  63)					nextImage1->mask = v10;
            				}
HXDLIN(  63)				return nextImage1;
            			}
            		}
            		else {
HXLINE(  65)			return img;
            		}
HXLINE(  62)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(TransformImage_Impl__obj,scaleMatch,return )

 ::pi_xy::ImageStruct TransformImage_Impl__obj::scaleXY( ::pi_xy::ImageStruct this1,Float sx,Float sy,::hx::Null< bool >  __o_transparent,::hx::Null< bool >  __o_includeMask){
            		bool transparent = __o_transparent.Default(false);
            		bool includeMask = __o_includeMask.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_68d25436a32dba6f_71_scaleXY)
HXDLIN(  71)		int scaleW = ::Std_obj::_hx_int(sx);
HXDLIN(  71)		int scaleH = ::Std_obj::_hx_int(sy);
HXDLIN(  71)		bool ifScaleUpInt;
HXDLIN(  71)		bool ifScaleUpInt1;
HXDLIN(  71)		bool ifScaleUpInt2;
HXDLIN(  71)		if ((scaleW == sx)) {
HXDLIN(  71)			ifScaleUpInt2 = (sx > ((Float)0.));
            		}
            		else {
HXDLIN(  71)			ifScaleUpInt2 = false;
            		}
HXDLIN(  71)		if (ifScaleUpInt2) {
HXDLIN(  71)			ifScaleUpInt1 = (scaleH == sy);
            		}
            		else {
HXDLIN(  71)			ifScaleUpInt1 = false;
            		}
HXDLIN(  71)		if (ifScaleUpInt1) {
HXDLIN(  71)			ifScaleUpInt = (sy > ((Float)0.));
            		}
            		else {
HXDLIN(  71)			ifScaleUpInt = false;
            		}
HXDLIN(  71)		if (ifScaleUpInt) {
HXDLIN(  71)			bool includeMask1 = false;
HXDLIN(  71)			 ::pi_xy::ImageStruct thisImage = this1;
HXDLIN(  71)			int p = 0;
HXDLIN(  71)			int xx = p;
HXDLIN(  71)			int q = 0;
HXDLIN(  71)			int wNew = ::Std_obj::_hx_int(( (Float)((thisImage->width * scaleW)) ));
HXDLIN(  71)			int hNew = ::Std_obj::_hx_int(( (Float)((thisImage->height * scaleH)) ));
HXDLIN(  71)			 ::Dynamic imageType = null();
HXDLIN(  71)			 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  71)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE(  71)			::Dynamic _hx_tmp;
HXDLIN(  71)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXDLIN(  71)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  71)					 ::iterMagic::BytesImg b = byt;
HXDLIN(  71)					{
HXDLIN(  71)						b->width = wNew;
HXDLIN(  71)						b->height = hNew;
HXDLIN(  71)						b->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN(  71)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  71)						{
HXDLIN(  71)							int len = b->length;
HXDLIN(  71)							int w = 0;
HXDLIN(  71)							{
HXDLIN(  71)								int _g = 0;
HXDLIN(  71)								int _g1 = b->height;
HXDLIN(  71)								while((_g < _g1)){
HXDLIN(  71)									_g = (_g + 1);
HXDLIN(  71)									int y = (_g - 1);
HXDLIN(  71)									{
HXDLIN(  71)										int _g2 = 0;
HXDLIN(  71)										int _g3 = b->width;
HXDLIN(  71)										while((_g2 < _g3)){
HXDLIN(  71)											_g2 = (_g2 + 1);
HXDLIN(  71)											int x = (_g2 - 1);
HXDLIN(  71)											{
HXDLIN(  71)												w = (w + 1);
HXDLIN(  71)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  71)											{
HXDLIN(  71)												w = (w + 1);
HXDLIN(  71)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  71)											{
HXDLIN(  71)												w = (w + 1);
HXDLIN(  71)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  71)											{
HXDLIN(  71)												w = (w + 1);
HXDLIN(  71)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  71)					_hx_tmp = b;
            				}
            				break;
            				case (int)1: {
HXDLIN(  71)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  71)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  71)					{
HXDLIN(  71)						a->width = wNew;
HXDLIN(  71)						a->height = hNew;
HXDLIN(  71)						a->data = ::Array_obj< int >::__new(0);
HXDLIN(  71)						a->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN(  71)						{
HXDLIN(  71)							int _g4 = 0;
HXDLIN(  71)							int _g5 = a->length;
HXDLIN(  71)							while((_g4 < _g5)){
HXDLIN(  71)								_g4 = (_g4 + 1);
HXDLIN(  71)								int i = (_g4 - 1);
HXDLIN(  71)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN(  71)					_hx_tmp = a;
            				}
            				break;
            				case (int)2: {
HXDLIN(  71)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  71)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  71)					{
HXDLIN(  71)						b1->width = wNew;
HXDLIN(  71)						b1->height = hNew;
HXDLIN(  71)						b1->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN(  71)						int size = (b1->length * 4);
HXDLIN(  71)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  71)						{
HXDLIN(  71)							int _g6 = 0;
HXDLIN(  71)							int _g7 = b1->length;
HXDLIN(  71)							while((_g6 < _g7)){
HXDLIN(  71)								_g6 = (_g6 + 1);
HXDLIN(  71)								int i1 = (_g6 - 1);
HXDLIN(  71)								{
HXDLIN(  71)									 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  71)									bool _hx_tmp1;
HXDLIN(  71)									if ((i1 >= 0)) {
HXDLIN(  71)										_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            									}
            									else {
HXDLIN(  71)										_hx_tmp1 = false;
            									}
HXDLIN(  71)									if (_hx_tmp1) {
HXDLIN(  71)										 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  71)										int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  71)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  71)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  71)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  71)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN(  71)					_hx_tmp = b1;
            				}
            				break;
            				case (int)3: {
HXDLIN(  71)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  71)					 ::iterMagic::VecIntImg v = vec;
HXDLIN(  71)					{
HXDLIN(  71)						v->width = wNew;
HXDLIN(  71)						v->height = hNew;
HXDLIN(  71)						v->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN(  71)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  71)						{
HXDLIN(  71)							int _g8 = 0;
HXDLIN(  71)							int _g9 = v->length;
HXDLIN(  71)							while((_g8 < _g9)){
HXDLIN(  71)								_g8 = (_g8 + 1);
HXDLIN(  71)								int i2 = (_g8 - 1);
HXDLIN(  71)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN(  71)					_hx_tmp = v;
            				}
            				break;
            				case (int)4: {
HXDLIN(  71)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  71)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  71)					{
HXDLIN(  71)						b2->width = wNew;
HXDLIN(  71)						b2->height = hNew;
HXDLIN(  71)						b2->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN(  71)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  71)						{
HXDLIN(  71)							int len1 = b2->length;
HXDLIN(  71)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  71)							if (::hx::IsNull( d->head )) {
HXDLIN(  71)								int _g10 = 0;
HXDLIN(  71)								int _g11 = len1;
HXDLIN(  71)								while((_g10 < _g11)){
HXDLIN(  71)									_g10 = (_g10 + 1);
HXDLIN(  71)									int i3 = (_g10 - 1);
HXDLIN(  71)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXDLIN(  71)								int _g12 = 0;
HXDLIN(  71)								int _g13 = len1;
HXDLIN(  71)								while((_g12 < _g13)){
HXDLIN(  71)									_g12 = (_g12 + 1);
HXDLIN(  71)									int i4 = (_g12 - 1);
HXDLIN(  71)									{
HXDLIN(  71)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  71)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  71)										{
HXDLIN(  71)											int _g14 = 0;
HXDLIN(  71)											int _g15 = i4;
HXDLIN(  71)											while((_g14 < _g15)){
HXDLIN(  71)												_g14 = (_g14 + 1);
HXDLIN(  71)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE(  71)										if (::hx::IsNull( prev )) {
HXDLIN(  71)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  71)											l = null();
            										}
            										else {
HXDLIN(  71)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  71)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  71)					_hx_tmp = b2;
            				}
            				break;
            			}
HXDLIN(  71)			this2->image = _hx_tmp;
HXDLIN(  71)			this2->width = wNew;
HXDLIN(  71)			this2->height = hNew;
HXDLIN(  71)			this2->imageType = ( (int)(imageType) );
HXDLIN(  71)			 ::pi_xy::ImageStruct nextImage = this2;
HXDLIN(  71)			int maxX = wNew;
HXDLIN(  71)			int maxY = hNew;
HXDLIN(  71)			do {
HXDLIN(  71)				int x1 = ::Std_obj::_hx_int((( (Float)(p) ) / ( (Float)(scaleW) )));
HXDLIN(  71)				int y1 = ::Std_obj::_hx_int((( (Float)(q) ) / ( (Float)(scaleH) )));
HXDLIN(  71)				::Dynamic this4 = thisImage->image;
HXDLIN(  71)				int index;
HXDLIN(  71)				if (thisImage->useVirtualPos) {
HXDLIN(  71)					index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - thisImage->virtualY) * ( (Float)(thisImage->width) )) + x1) - thisImage->virtualX));
            				}
            				else {
HXDLIN(  71)					index = ::Std_obj::_hx_int(( (Float)(((y1 * thisImage->width) + x1)) ));
            				}
HXDLIN(  71)				int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN(  71)				int color;
HXDLIN(  71)				if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  71)					color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            				}
            				else {
HXDLIN(  71)					color = c;
            				}
HXDLIN(  71)				{
HXDLIN(  71)					p = (p + 1);
HXDLIN(  71)					int x2 = (p - 1);
HXDLIN(  71)					int c1 = color;
HXDLIN(  71)					bool _hx_tmp2;
HXDLIN(  71)					if ((((c1 >> 24) & 255) < 254)) {
HXDLIN(  71)						_hx_tmp2 = nextImage->transparent;
            					}
            					else {
HXDLIN(  71)						_hx_tmp2 = false;
            					}
HXDLIN(  71)					if (_hx_tmp2) {
HXDLIN(  71)						int location;
HXDLIN(  71)						if (nextImage->useVirtualPos) {
HXDLIN(  71)							location = ::Std_obj::_hx_int(((((( (Float)(q) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x2) - nextImage->virtualX));
            						}
            						else {
HXDLIN(  71)							location = ::Std_obj::_hx_int(( (Float)(((q * nextImage->width) + x2)) ));
            						}
HXDLIN(  71)						int this5 = ::iterMagic::Iimg_obj::get(nextImage->image,location);
HXDLIN(  71)						int this6;
HXDLIN(  71)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  71)							this6 = ((((((this5 >> 24) & 255) << 24) | ((this5 & 255) << 16)) | (((this5 >> 8) & 255) << 8)) | ((this5 >> 16) & 255));
            						}
            						else {
HXDLIN(  71)							this6 = this5;
            						}
HXDLIN(  71)						Float a1;
HXDLIN(  71)						int this7 = ((this6 >> 24) & 255);
HXDLIN(  71)						if ((this7 == 0)) {
HXDLIN(  71)							a1 = ((Float)0.);
            						}
            						else {
HXDLIN(  71)							a1 = (( (Float)(this7) ) / ( (Float)(255) ));
            						}
HXDLIN(  71)						Float r1;
HXDLIN(  71)						int this8 = ((this6 >> 16) & 255);
HXDLIN(  71)						if ((this8 == 0)) {
HXDLIN(  71)							r1 = ((Float)0.);
            						}
            						else {
HXDLIN(  71)							r1 = (( (Float)(this8) ) / ( (Float)(255) ));
            						}
HXDLIN(  71)						Float g1;
HXDLIN(  71)						int this9 = ((this6 >> 8) & 255);
HXDLIN(  71)						if ((this9 == 0)) {
HXDLIN(  71)							g1 = ((Float)0.);
            						}
            						else {
HXDLIN(  71)							g1 = (( (Float)(this9) ) / ( (Float)(255) ));
            						}
HXDLIN(  71)						Float b11;
HXDLIN(  71)						int this10 = (this6 & 255);
HXDLIN(  71)						if ((this10 == 0)) {
HXDLIN(  71)							b11 = ((Float)0.);
            						}
            						else {
HXDLIN(  71)							b11 = (( (Float)(this10) ) / ( (Float)(255) ));
            						}
HXDLIN(  71)						Float a2;
HXDLIN(  71)						int this11 = ((color >> 24) & 255);
HXDLIN(  71)						if ((this11 == 0)) {
HXDLIN(  71)							a2 = ((Float)0.);
            						}
            						else {
HXDLIN(  71)							a2 = (( (Float)(this11) ) / ( (Float)(255) ));
            						}
HXDLIN(  71)						Float r2;
HXDLIN(  71)						int this12 = ((color >> 16) & 255);
HXDLIN(  71)						if ((this12 == 0)) {
HXDLIN(  71)							r2 = ((Float)0.);
            						}
            						else {
HXDLIN(  71)							r2 = (( (Float)(this12) ) / ( (Float)(255) ));
            						}
HXDLIN(  71)						Float g2;
HXDLIN(  71)						int this13 = ((color >> 8) & 255);
HXDLIN(  71)						if ((this13 == 0)) {
HXDLIN(  71)							g2 = ((Float)0.);
            						}
            						else {
HXDLIN(  71)							g2 = (( (Float)(this13) ) / ( (Float)(255) ));
            						}
HXDLIN(  71)						Float b21;
HXDLIN(  71)						int this14 = (color & 255);
HXDLIN(  71)						if ((this14 == 0)) {
HXDLIN(  71)							b21 = ((Float)0.);
            						}
            						else {
HXDLIN(  71)							b21 = (( (Float)(this14) ) / ( (Float)(255) ));
            						}
HXDLIN(  71)						Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  71)						int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  71)						int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  71)						int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  71)						int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  71)						int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  71)						{
HXDLIN(  71)							int _hx_tmp3;
HXDLIN(  71)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  71)								_hx_tmp3 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            							}
            							else {
HXDLIN(  71)								_hx_tmp3 = blended;
            							}
HXDLIN(  71)							::iterMagic::Iimg_obj::set(nextImage->image,location,_hx_tmp3);
            						}
            					}
            					else {
HXDLIN(  71)						::Dynamic this15 = nextImage->image;
HXDLIN(  71)						int index1;
HXDLIN(  71)						if (nextImage->useVirtualPos) {
HXDLIN(  71)							index1 = ::Std_obj::_hx_int(((((( (Float)(q) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x2) - nextImage->virtualX));
            						}
            						else {
HXDLIN(  71)							index1 = ::Std_obj::_hx_int(( (Float)(((q * nextImage->width) + x2)) ));
            						}
HXDLIN(  71)						int _hx_tmp4;
HXDLIN(  71)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  71)							_hx_tmp4 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            						}
            						else {
HXDLIN(  71)							_hx_tmp4 = c1;
            						}
HXDLIN(  71)						::iterMagic::Iimg_obj::set(this15,index1,_hx_tmp4);
            					}
            				}
HXDLIN(  71)				if ((p > maxX)) {
HXLINE(  22)					p = xx;
HXLINE(  71)					q = (q + 1);
            				}
            			} while((q <= maxY));
;
HXDLIN(  71)			bool _hx_tmp5;
HXDLIN(  71)			if (::hx::IsNotNull( thisImage->mask )) {
HXDLIN(  71)				_hx_tmp5 = includeMask1;
            			}
            			else {
HXDLIN(  71)				_hx_tmp5 = false;
            			}
HXDLIN(  71)			if (_hx_tmp5) {
HXDLIN(  71)				 ::pi_xy::ImageStruct v1 = ::pi_xy::transformation::_ScaleImage::ScaleImage_Fields__obj::scaleUpInteger(thisImage->mask,scaleW,scaleH,thisImage->mask->transparent,includeMask1);
HXDLIN(  71)				nextImage->useMask = true;
HXDLIN(  71)				nextImage->mask = v1;
            			}
HXDLIN(  71)			return nextImage;
            		}
            		else {
HXDLIN(  71)			Float w1 = (( (Float)(this1->width) ) * sx);
HXDLIN(  71)			Float h = (( (Float)(this1->height) ) * sy);
HXDLIN(  71)			int wid = ::Math_obj::ceil(w1);
HXDLIN(  71)			int hi = ::Math_obj::ceil(h);
HXDLIN(  71)			 ::Dynamic imageType1 = null();
HXDLIN(  71)			 ::pi_xy::ImageStruct this16 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  71)			if (::hx::IsNull( imageType1 )) {
HXLINE(  54)				imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE(  71)			::Dynamic _hx_tmp6;
HXDLIN(  71)			switch((int)(( (int)(imageType1) ))){
            				case (int)0: {
HXDLIN(  71)					 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  71)					 ::iterMagic::BytesImg b4 = byt1;
HXDLIN(  71)					{
HXDLIN(  71)						b4->width = wid;
HXDLIN(  71)						b4->height = hi;
HXDLIN(  71)						b4->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  71)						b4->data = ::haxe::io::Bytes_obj::alloc((b4->length * 4));
HXDLIN(  71)						{
HXDLIN(  71)							int len2 = b4->length;
HXDLIN(  71)							int w2 = 0;
HXDLIN(  71)							{
HXDLIN(  71)								int _g16 = 0;
HXDLIN(  71)								int _g17 = b4->height;
HXDLIN(  71)								while((_g16 < _g17)){
HXDLIN(  71)									_g16 = (_g16 + 1);
HXDLIN(  71)									int y2 = (_g16 - 1);
HXDLIN(  71)									{
HXDLIN(  71)										int _g18 = 0;
HXDLIN(  71)										int _g19 = b4->width;
HXDLIN(  71)										while((_g18 < _g19)){
HXDLIN(  71)											_g18 = (_g18 + 1);
HXDLIN(  71)											int x3 = (_g18 - 1);
HXDLIN(  71)											{
HXDLIN(  71)												w2 = (w2 + 1);
HXDLIN(  71)												b4->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  71)											{
HXDLIN(  71)												w2 = (w2 + 1);
HXDLIN(  71)												b4->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  71)											{
HXDLIN(  71)												w2 = (w2 + 1);
HXDLIN(  71)												b4->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  71)											{
HXDLIN(  71)												w2 = (w2 + 1);
HXDLIN(  71)												b4->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  71)					_hx_tmp6 = b4;
            				}
            				break;
            				case (int)1: {
HXDLIN(  71)					 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  71)					 ::iterMagic::ArrIntImg a5 = arrI1;
HXDLIN(  71)					{
HXDLIN(  71)						a5->width = wid;
HXDLIN(  71)						a5->height = hi;
HXDLIN(  71)						a5->data = ::Array_obj< int >::__new(0);
HXDLIN(  71)						a5->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  71)						{
HXDLIN(  71)							int _g20 = 0;
HXDLIN(  71)							int _g21 = a5->length;
HXDLIN(  71)							while((_g20 < _g21)){
HXDLIN(  71)								_g20 = (_g20 + 1);
HXDLIN(  71)								int i6 = (_g20 - 1);
HXDLIN(  71)								a5->data[i6] = 0;
            							}
            						}
            					}
HXDLIN(  71)					_hx_tmp6 = a5;
            				}
            				break;
            				case (int)2: {
HXDLIN(  71)					 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  71)					 ::iterMagic::U32ArrImg b5 = u32a1;
HXDLIN(  71)					{
HXDLIN(  71)						b5->width = wid;
HXDLIN(  71)						b5->height = hi;
HXDLIN(  71)						b5->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  71)						int size1 = (b5->length * 4);
HXDLIN(  71)						b5->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  71)						{
HXDLIN(  71)							int _g22 = 0;
HXDLIN(  71)							int _g23 = b5->length;
HXDLIN(  71)							while((_g22 < _g23)){
HXDLIN(  71)								_g22 = (_g22 + 1);
HXDLIN(  71)								int i7 = (_g22 - 1);
HXDLIN(  71)								{
HXDLIN(  71)									 ::haxe::io::ArrayBufferViewImpl this17 = b5->data;
HXDLIN(  71)									bool _hx_tmp7;
HXDLIN(  71)									if ((i7 >= 0)) {
HXDLIN(  71)										_hx_tmp7 = (i7 < (this17->byteLength >> 2));
            									}
            									else {
HXDLIN(  71)										_hx_tmp7 = false;
            									}
HXDLIN(  71)									if (_hx_tmp7) {
HXDLIN(  71)										 ::haxe::io::Bytes _this1 = this17->bytes;
HXDLIN(  71)										int pos1 = ((i7 << 2) + this17->byteOffset);
HXDLIN(  71)										_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  71)										_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  71)										_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  71)										_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN(  71)					_hx_tmp6 = b5;
            				}
            				break;
            				case (int)3: {
HXDLIN(  71)					 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  71)					 ::iterMagic::VecIntImg v2 = vec1;
HXDLIN(  71)					{
HXDLIN(  71)						v2->width = wid;
HXDLIN(  71)						v2->height = hi;
HXDLIN(  71)						v2->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  71)						v2->data = ::Array_obj< int >::__new(v2->length);
HXDLIN(  71)						{
HXDLIN(  71)							int _g24 = 0;
HXDLIN(  71)							int _g25 = v2->length;
HXDLIN(  71)							while((_g24 < _g25)){
HXDLIN(  71)								_g24 = (_g24 + 1);
HXDLIN(  71)								int i8 = (_g24 - 1);
HXDLIN(  71)								v2->data->__unsafe_set(i8,0);
            							}
            						}
            					}
HXDLIN(  71)					_hx_tmp6 = v2;
            				}
            				break;
            				case (int)4: {
HXDLIN(  71)					 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  71)					 ::iterMagic::StackIntImg b6 = sInt1;
HXDLIN(  71)					{
HXDLIN(  71)						b6->width = wid;
HXDLIN(  71)						b6->height = hi;
HXDLIN(  71)						b6->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  71)						b6->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  71)						{
HXDLIN(  71)							int len3 = b6->length;
HXDLIN(  71)							 ::haxe::ds::GenericStack_Int d1 = b6->data;
HXDLIN(  71)							if (::hx::IsNull( d1->head )) {
HXDLIN(  71)								int _g26 = 0;
HXDLIN(  71)								int _g27 = len3;
HXDLIN(  71)								while((_g26 < _g27)){
HXDLIN(  71)									_g26 = (_g26 + 1);
HXDLIN(  71)									int i9 = (_g26 - 1);
HXDLIN(  71)									d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            								}
            							}
            							else {
HXDLIN(  71)								int _g28 = 0;
HXDLIN(  71)								int _g29 = len3;
HXDLIN(  71)								while((_g28 < _g29)){
HXDLIN(  71)									_g28 = (_g28 + 1);
HXDLIN(  71)									int i10 = (_g28 - 1);
HXDLIN(  71)									{
HXDLIN(  71)										 ::haxe::ds::GenericCell_Int l1 = b6->data->head;
HXDLIN(  71)										 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  71)										{
HXDLIN(  71)											int _g30 = 0;
HXDLIN(  71)											int _g31 = i10;
HXDLIN(  71)											while((_g30 < _g31)){
HXDLIN(  71)												_g30 = (_g30 + 1);
HXDLIN(  71)												int i11 = (_g30 - 1);
HXLINE( 345)												prev1 = l1;
HXLINE( 346)												l1 = l1->next;
            											}
            										}
HXLINE(  71)										if (::hx::IsNull( prev1 )) {
HXDLIN(  71)											b6->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  71)											l1 = null();
            										}
            										else {
HXDLIN(  71)											prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  71)											l1 = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  71)					_hx_tmp6 = b6;
            				}
            				break;
            			}
HXDLIN(  71)			this16->image = _hx_tmp6;
HXDLIN(  71)			this16->width = wid;
HXDLIN(  71)			this16->height = hi;
HXDLIN(  71)			this16->imageType = ( (int)(imageType1) );
HXDLIN(  71)			 ::pi_xy::ImageStruct nextImage1 = this16;
HXDLIN(  71)			{
HXDLIN(  71)				bool v3 = this1->transparent;
HXDLIN(  71)				nextImage1->transparent = v3;
            			}
HXDLIN(  71)			{
HXDLIN(  71)				 ::pi_xy::ImageStruct this18 = nextImage1;
HXDLIN(  71)				Float win_x = ( (Float)(0) );
HXDLIN(  71)				Float win_y = ( (Float)(0) );
HXDLIN(  71)				Float win_width = ( (Float)(this1->width) );
HXDLIN(  71)				Float win_height = ( (Float)(this1->height) );
HXDLIN(  71)				{
HXDLIN(  71)					Float bu = ((Float)1.);
HXDLIN(  71)					Float bv = ((Float)0.);
HXDLIN(  71)					Float cu = ((Float)1.);
HXDLIN(  71)					Float cv = ((Float)1.);
HXDLIN(  71)					Float du = ((Float)0.);
HXDLIN(  71)					Float dv = ((Float)1.);
HXDLIN(  71)					Float au = ((Float)0.);
HXDLIN(  71)					Float av = ((Float)0.);
HXDLIN(  71)					Float bu1 = bu;
HXDLIN(  71)					Float bv1 = bv;
HXDLIN(  71)					bool hasUndo = false;
HXDLIN(  71)					Float temp = au;
HXLINE( 422)					au = bu1;
HXLINE( 423)					bu1 = temp;
HXLINE( 424)					temp = av;
HXLINE( 425)					av = bv1;
HXLINE( 426)					bv1 = temp;
HXLINE(  71)					Float bcx = w1;
HXDLIN(  71)					Float bcy = (( (Float)(0) ) - h);
HXDLIN(  71)					Float acx = ( (Float)(0) );
HXDLIN(  71)					Float acy = (( (Float)(0) ) - h);
HXDLIN(  71)					Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  71)					Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  71)					Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  71)					Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  71)					 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  71)					if ((0 > w1)) {
HXDLIN(  71)						int ii_min = ::Math_obj::floor(w1);
HXDLIN(  71)						int ii_max = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  71)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            					}
            					else {
HXDLIN(  71)						if ((w1 > 0)) {
HXDLIN(  71)							int ii_min1 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  71)							int ii_max1 = ::Math_obj::ceil(w1);
HXDLIN(  71)							xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            						}
            						else {
HXDLIN(  71)							int ii_min2 = ::Math_obj::floor(( (Float)(0) ));
HXDLIN(  71)							int ii_max2 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  71)							xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            						}
            					}
HXDLIN(  71)					 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  71)					if ((0 > h)) {
HXDLIN(  71)						int min;
HXDLIN(  71)						if ((0 > h)) {
HXDLIN(  71)							min = ::Math_obj::floor(h);
            						}
            						else {
HXDLIN(  71)							min = ::Math_obj::ceil(( (Float)(0) ));
            						}
HXDLIN(  71)						int ii_min3 = min;
HXDLIN(  71)						int ii_max3 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  71)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            					}
            					else {
HXDLIN(  71)						int ii_min4 = ::Math_obj::floor(( (Float)(0) ));
HXDLIN(  71)						int ii_max4 = ::Math_obj::ceil(h);
HXDLIN(  71)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            					}
HXDLIN(  71)					 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  71)					if (hasUndo) {
HXDLIN(  71)						int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  71)						int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  71)						 ::Dynamic imageType2 = null();
HXDLIN(  71)						 ::pi_xy::ImageStruct this19 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  71)						if (::hx::IsNull( imageType2 )) {
HXLINE(  54)							imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE(  71)						::Dynamic undoImage1;
HXDLIN(  71)						switch((int)(( (int)(imageType2) ))){
            							case (int)0: {
HXDLIN(  71)								 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  71)								 ::iterMagic::BytesImg b7 = byt2;
HXDLIN(  71)								{
HXDLIN(  71)									b7->width = width;
HXDLIN(  71)									b7->height = height;
HXDLIN(  71)									b7->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  71)									b7->data = ::haxe::io::Bytes_obj::alloc((b7->length * 4));
HXDLIN(  71)									{
HXDLIN(  71)										int len4 = b7->length;
HXDLIN(  71)										int w3 = 0;
HXDLIN(  71)										{
HXDLIN(  71)											int _g32 = 0;
HXDLIN(  71)											int _g33 = b7->height;
HXDLIN(  71)											while((_g32 < _g33)){
HXDLIN(  71)												_g32 = (_g32 + 1);
HXDLIN(  71)												int y3 = (_g32 - 1);
HXDLIN(  71)												{
HXDLIN(  71)													int _g34 = 0;
HXDLIN(  71)													int _g35 = b7->width;
HXDLIN(  71)													while((_g34 < _g35)){
HXDLIN(  71)														_g34 = (_g34 + 1);
HXDLIN(  71)														int x4 = (_g34 - 1);
HXDLIN(  71)														{
HXDLIN(  71)															w3 = (w3 + 1);
HXDLIN(  71)															b7->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  71)														{
HXDLIN(  71)															w3 = (w3 + 1);
HXDLIN(  71)															b7->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  71)														{
HXDLIN(  71)															w3 = (w3 + 1);
HXDLIN(  71)															b7->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  71)														{
HXDLIN(  71)															w3 = (w3 + 1);
HXDLIN(  71)															b7->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  71)								undoImage1 = b7;
            							}
            							break;
            							case (int)1: {
HXDLIN(  71)								 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  71)								 ::iterMagic::ArrIntImg a6 = arrI2;
HXDLIN(  71)								{
HXDLIN(  71)									a6->width = width;
HXDLIN(  71)									a6->height = height;
HXDLIN(  71)									a6->data = ::Array_obj< int >::__new(0);
HXDLIN(  71)									a6->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  71)									{
HXDLIN(  71)										int _g36 = 0;
HXDLIN(  71)										int _g37 = a6->length;
HXDLIN(  71)										while((_g36 < _g37)){
HXDLIN(  71)											_g36 = (_g36 + 1);
HXDLIN(  71)											int i12 = (_g36 - 1);
HXDLIN(  71)											a6->data[i12] = 0;
            										}
            									}
            								}
HXDLIN(  71)								undoImage1 = a6;
            							}
            							break;
            							case (int)2: {
HXDLIN(  71)								 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  71)								 ::iterMagic::U32ArrImg b8 = u32a2;
HXDLIN(  71)								{
HXDLIN(  71)									b8->width = width;
HXDLIN(  71)									b8->height = height;
HXDLIN(  71)									b8->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  71)									int size2 = (b8->length * 4);
HXDLIN(  71)									b8->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN(  71)									{
HXDLIN(  71)										int _g38 = 0;
HXDLIN(  71)										int _g39 = b8->length;
HXDLIN(  71)										while((_g38 < _g39)){
HXDLIN(  71)											_g38 = (_g38 + 1);
HXDLIN(  71)											int i13 = (_g38 - 1);
HXDLIN(  71)											{
HXDLIN(  71)												 ::haxe::io::ArrayBufferViewImpl this20 = b8->data;
HXDLIN(  71)												bool undoImage2;
HXDLIN(  71)												if ((i13 >= 0)) {
HXDLIN(  71)													undoImage2 = (i13 < (this20->byteLength >> 2));
            												}
            												else {
HXDLIN(  71)													undoImage2 = false;
            												}
HXDLIN(  71)												if (undoImage2) {
HXDLIN(  71)													 ::haxe::io::Bytes _this2 = this20->bytes;
HXDLIN(  71)													int pos2 = ((i13 << 2) + this20->byteOffset);
HXDLIN(  71)													_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN(  71)													_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN(  71)													_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN(  71)													_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN(  71)								undoImage1 = b8;
            							}
            							break;
            							case (int)3: {
HXDLIN(  71)								 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  71)								 ::iterMagic::VecIntImg v4 = vec2;
HXDLIN(  71)								{
HXDLIN(  71)									v4->width = width;
HXDLIN(  71)									v4->height = height;
HXDLIN(  71)									v4->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  71)									v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN(  71)									{
HXDLIN(  71)										int _g40 = 0;
HXDLIN(  71)										int _g41 = v4->length;
HXDLIN(  71)										while((_g40 < _g41)){
HXDLIN(  71)											_g40 = (_g40 + 1);
HXDLIN(  71)											int i14 = (_g40 - 1);
HXDLIN(  71)											v4->data->__unsafe_set(i14,0);
            										}
            									}
            								}
HXDLIN(  71)								undoImage1 = v4;
            							}
            							break;
            							case (int)4: {
HXDLIN(  71)								 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  71)								 ::iterMagic::StackIntImg b9 = sInt2;
HXDLIN(  71)								{
HXDLIN(  71)									b9->width = width;
HXDLIN(  71)									b9->height = height;
HXDLIN(  71)									b9->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  71)									b9->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  71)									{
HXDLIN(  71)										int len5 = b9->length;
HXDLIN(  71)										 ::haxe::ds::GenericStack_Int d2 = b9->data;
HXDLIN(  71)										if (::hx::IsNull( d2->head )) {
HXDLIN(  71)											int _g42 = 0;
HXDLIN(  71)											int _g43 = len5;
HXDLIN(  71)											while((_g42 < _g43)){
HXDLIN(  71)												_g42 = (_g42 + 1);
HXDLIN(  71)												int i15 = (_g42 - 1);
HXDLIN(  71)												d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            											}
            										}
            										else {
HXDLIN(  71)											int _g44 = 0;
HXDLIN(  71)											int _g45 = len5;
HXDLIN(  71)											while((_g44 < _g45)){
HXDLIN(  71)												_g44 = (_g44 + 1);
HXDLIN(  71)												int i16 = (_g44 - 1);
HXDLIN(  71)												{
HXDLIN(  71)													 ::haxe::ds::GenericCell_Int l2 = b9->data->head;
HXDLIN(  71)													 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN(  71)													{
HXDLIN(  71)														int _g46 = 0;
HXDLIN(  71)														int _g47 = i16;
HXDLIN(  71)														while((_g46 < _g47)){
HXDLIN(  71)															_g46 = (_g46 + 1);
HXDLIN(  71)															int i17 = (_g46 - 1);
HXLINE( 345)															prev2 = l2;
HXLINE( 346)															l2 = l2->next;
            														}
            													}
HXLINE(  71)													if (::hx::IsNull( prev2 )) {
HXDLIN(  71)														b9->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  71)														l2 = null();
            													}
            													else {
HXDLIN(  71)														prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  71)														l2 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  71)								undoImage1 = b9;
            							}
            							break;
            						}
HXDLIN(  71)						this19->image = undoImage1;
HXDLIN(  71)						this19->width = width;
HXDLIN(  71)						this19->height = height;
HXDLIN(  71)						this19->imageType = ( (int)(imageType2) );
HXDLIN(  71)						undoImage = this19;
HXDLIN(  71)						{
HXDLIN(  71)							int rectLeft = xIter3->start;
HXDLIN(  71)							int rectTop = yIter3->start;
HXDLIN(  71)							int rectRight = xIter3->max;
HXDLIN(  71)							bool forceClear = false;
HXDLIN(  71)							{
HXDLIN(  71)								int _g48 = rectTop;
HXDLIN(  71)								int _g49 = yIter3->max;
HXDLIN(  71)								while((_g48 < _g49)){
HXDLIN(  71)									_g48 = (_g48 + 1);
HXDLIN(  71)									int dy = (_g48 - 1);
HXDLIN(  71)									{
HXDLIN(  71)										int _g50 = rectLeft;
HXDLIN(  71)										int _g51 = rectRight;
HXDLIN(  71)										while((_g50 < _g51)){
HXDLIN(  71)											_g50 = (_g50 + 1);
HXDLIN(  71)											int dx = (_g50 - 1);
HXDLIN(  71)											::Dynamic this21 = this18->image;
HXDLIN(  71)											int index2;
HXDLIN(  71)											if (this18->useVirtualPos) {
HXDLIN(  71)												index2 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this18->virtualY) * ( (Float)(this18->width) )) + dx) - this18->virtualX));
            											}
            											else {
HXDLIN(  71)												index2 = ::Std_obj::_hx_int(( (Float)(((dy * this18->width) + dx)) ));
            											}
HXDLIN(  71)											int c2 = ::iterMagic::Iimg_obj::get(this21,index2);
HXDLIN(  71)											int col;
HXDLIN(  71)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  71)												col = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            											}
            											else {
HXDLIN(  71)												col = c2;
            											}
HXDLIN(  71)											bool _hx_tmp8;
HXDLIN(  71)											if (this18->useMask) {
HXDLIN(  71)												_hx_tmp8 = ::hx::IsNotNull( this18->mask );
            											}
            											else {
HXDLIN(  71)												_hx_tmp8 = false;
            											}
HXDLIN(  71)											if (_hx_tmp8) {
HXDLIN(  71)												 ::pi_xy::ImageStruct this22 = this18->mask;
HXDLIN(  71)												::Dynamic this23 = this22->image;
HXDLIN(  71)												int index3;
HXDLIN(  71)												if (this22->useVirtualPos) {
HXDLIN(  71)													index3 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this22->virtualY) * ( (Float)(this22->width) )) + dx) - this22->virtualX));
            												}
            												else {
HXDLIN(  71)													index3 = ::Std_obj::_hx_int(( (Float)(((dy * this22->width) + dx)) ));
            												}
HXDLIN(  71)												int c3 = ::iterMagic::Iimg_obj::get(this23,index3);
HXDLIN(  71)												int v5;
HXDLIN(  71)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  71)													v5 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            												}
            												else {
HXDLIN(  71)													v5 = c3;
            												}
HXDLIN(  71)												int maskPixel = v5;
HXDLIN(  71)												int this24 = col;
HXDLIN(  71)												if ((maskPixel == 0)) {
HXDLIN(  71)													col = this24;
            												}
            												else {
HXDLIN(  71)													Float m0;
HXDLIN(  71)													int this25 = ((maskPixel >> 24) & 255);
HXDLIN(  71)													if ((this25 == 0)) {
HXDLIN(  71)														m0 = ((Float)0.);
            													}
            													else {
HXDLIN(  71)														m0 = (( (Float)(this25) ) / ( (Float)(255) ));
            													}
HXDLIN(  71)													Float m1;
HXDLIN(  71)													int this26 = ((maskPixel >> 16) & 255);
HXDLIN(  71)													if ((this26 == 0)) {
HXDLIN(  71)														m1 = ((Float)0.);
            													}
            													else {
HXDLIN(  71)														m1 = (( (Float)(this26) ) / ( (Float)(255) ));
            													}
HXDLIN(  71)													Float m2;
HXDLIN(  71)													int this27 = ((maskPixel >> 8) & 255);
HXDLIN(  71)													if ((this27 == 0)) {
HXDLIN(  71)														m2 = ((Float)0.);
            													}
            													else {
HXDLIN(  71)														m2 = (( (Float)(this27) ) / ( (Float)(255) ));
            													}
HXDLIN(  71)													Float m3;
HXDLIN(  71)													int this28 = (maskPixel & 255);
HXDLIN(  71)													if ((this28 == 0)) {
HXDLIN(  71)														m3 = ((Float)0.);
            													}
            													else {
HXDLIN(  71)														m3 = (( (Float)(this28) ) / ( (Float)(255) ));
            													}
HXDLIN(  71)													int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this24 >> 24) & 255)) )));
HXDLIN(  71)													int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this24 >> 16) & 255)) )));
HXDLIN(  71)													int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this24 >> 8) & 255)) )));
HXDLIN(  71)													int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this24 & 255)) )));
HXDLIN(  71)													col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  71)											if ((col != 0)) {
HXDLIN(  71)												int x5 = (dx - rectLeft);
HXDLIN(  71)												int y4 = (dy - rectTop);
HXDLIN(  71)												int c4 = col;
HXDLIN(  71)												bool _hx_tmp9;
HXDLIN(  71)												if ((((c4 >> 24) & 255) < 254)) {
HXDLIN(  71)													_hx_tmp9 = undoImage->transparent;
            												}
            												else {
HXDLIN(  71)													_hx_tmp9 = false;
            												}
HXDLIN(  71)												if (_hx_tmp9) {
HXDLIN(  71)													int location1;
HXDLIN(  71)													if (undoImage->useVirtualPos) {
HXDLIN(  71)														location1 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            													}
            													else {
HXDLIN(  71)														location1 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage->width) + x5)) ));
            													}
HXDLIN(  71)													int this29 = ::iterMagic::Iimg_obj::get(undoImage->image,location1);
HXDLIN(  71)													int this30;
HXDLIN(  71)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  71)														this30 = ((((((this29 >> 24) & 255) << 24) | ((this29 & 255) << 16)) | (((this29 >> 8) & 255) << 8)) | ((this29 >> 16) & 255));
            													}
            													else {
HXDLIN(  71)														this30 = this29;
            													}
HXDLIN(  71)													Float a11;
HXDLIN(  71)													int this31 = ((this30 >> 24) & 255);
HXDLIN(  71)													if ((this31 == 0)) {
HXDLIN(  71)														a11 = ((Float)0.);
            													}
            													else {
HXDLIN(  71)														a11 = (( (Float)(this31) ) / ( (Float)(255) ));
            													}
HXDLIN(  71)													Float r11;
HXDLIN(  71)													int this32 = ((this30 >> 16) & 255);
HXDLIN(  71)													if ((this32 == 0)) {
HXDLIN(  71)														r11 = ((Float)0.);
            													}
            													else {
HXDLIN(  71)														r11 = (( (Float)(this32) ) / ( (Float)(255) ));
            													}
HXDLIN(  71)													Float g11;
HXDLIN(  71)													int this33 = ((this30 >> 8) & 255);
HXDLIN(  71)													if ((this33 == 0)) {
HXDLIN(  71)														g11 = ((Float)0.);
            													}
            													else {
HXDLIN(  71)														g11 = (( (Float)(this33) ) / ( (Float)(255) ));
            													}
HXDLIN(  71)													Float b12;
HXDLIN(  71)													int this34 = (this30 & 255);
HXDLIN(  71)													if ((this34 == 0)) {
HXDLIN(  71)														b12 = ((Float)0.);
            													}
            													else {
HXDLIN(  71)														b12 = (( (Float)(this34) ) / ( (Float)(255) ));
            													}
HXDLIN(  71)													Float a21;
HXDLIN(  71)													int this35 = ((col >> 24) & 255);
HXDLIN(  71)													if ((this35 == 0)) {
HXDLIN(  71)														a21 = ((Float)0.);
            													}
            													else {
HXDLIN(  71)														a21 = (( (Float)(this35) ) / ( (Float)(255) ));
            													}
HXDLIN(  71)													Float r21;
HXDLIN(  71)													int this36 = ((col >> 16) & 255);
HXDLIN(  71)													if ((this36 == 0)) {
HXDLIN(  71)														r21 = ((Float)0.);
            													}
            													else {
HXDLIN(  71)														r21 = (( (Float)(this36) ) / ( (Float)(255) ));
            													}
HXDLIN(  71)													Float g21;
HXDLIN(  71)													int this37 = ((col >> 8) & 255);
HXDLIN(  71)													if ((this37 == 0)) {
HXDLIN(  71)														g21 = ((Float)0.);
            													}
            													else {
HXDLIN(  71)														g21 = (( (Float)(this37) ) / ( (Float)(255) ));
            													}
HXDLIN(  71)													Float b22;
HXDLIN(  71)													int this38 = (col & 255);
HXDLIN(  71)													if ((this38 == 0)) {
HXDLIN(  71)														b22 = ((Float)0.);
            													}
            													else {
HXDLIN(  71)														b22 = (( (Float)(this38) ) / ( (Float)(255) ));
            													}
HXDLIN(  71)													Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  71)													int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  71)													int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  71)													int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  71)													int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  71)													int blended1 = ((((a7 << 24) | (r3 << 16)) | (g3 << 8)) | b10);
HXDLIN(  71)													{
HXDLIN(  71)														int _hx_tmp10;
HXDLIN(  71)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  71)															_hx_tmp10 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            														}
            														else {
HXDLIN(  71)															_hx_tmp10 = blended1;
            														}
HXDLIN(  71)														::iterMagic::Iimg_obj::set(undoImage->image,location1,_hx_tmp10);
            													}
            												}
            												else {
HXDLIN(  71)													::Dynamic this39 = undoImage->image;
HXDLIN(  71)													int index4;
HXDLIN(  71)													if (undoImage->useVirtualPos) {
HXDLIN(  71)														index4 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            													}
            													else {
HXDLIN(  71)														index4 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage->width) + x5)) ));
            													}
HXDLIN(  71)													int _hx_tmp11;
HXDLIN(  71)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  71)														_hx_tmp11 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            													}
            													else {
HXDLIN(  71)														_hx_tmp11 = c4;
            													}
HXDLIN(  71)													::iterMagic::Iimg_obj::set(this39,index4,_hx_tmp11);
            												}
            											}
            											else {
HXDLIN(  71)												if (forceClear) {
HXDLIN(  71)													::Dynamic this40 = undoImage->image;
HXDLIN(  71)													int x6 = (dx - rectLeft);
HXDLIN(  71)													int y5 = (dy - rectTop);
HXDLIN(  71)													int index5;
HXDLIN(  71)													if (undoImage->useVirtualPos) {
HXDLIN(  71)														index5 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x6) - undoImage->virtualX));
            													}
            													else {
HXDLIN(  71)														index5 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage->width) + x6)) ));
            													}
HXDLIN(  71)													::iterMagic::Iimg_obj::set(this40,index5,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  71)					{
HXDLIN(  71)						int _g_min = xIter3->start;
HXDLIN(  71)						int _g_max = xIter3->max;
HXDLIN(  71)						while((_g_min < _g_max)){
HXDLIN(  71)							_g_min = (_g_min + 1);
HXDLIN(  71)							int px = (_g_min - 1);
HXDLIN(  71)							Float pcx = ( (Float)(px) );
HXDLIN(  71)							{
HXDLIN(  71)								int _g_min1 = yIter3->start;
HXDLIN(  71)								int _g_max1 = yIter3->max;
HXDLIN(  71)								while((_g_min1 < _g_max1)){
HXDLIN(  71)									_g_min1 = (_g_min1 + 1);
HXDLIN(  71)									int py = (_g_min1 - 1);
HXDLIN(  71)									Float pcy = (( (Float)(py) ) - h);
HXDLIN(  71)									Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  71)									Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  71)									Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  71)									Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  71)									Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  71)									bool _hx_tmp12;
HXDLIN(  71)									bool _hx_tmp13;
HXDLIN(  71)									if ((ratioA >= 0)) {
HXDLIN(  71)										_hx_tmp13 = (ratioB >= 0);
            									}
            									else {
HXDLIN(  71)										_hx_tmp13 = false;
            									}
HXDLIN(  71)									if (_hx_tmp13) {
HXDLIN(  71)										_hx_tmp12 = (ratioC >= 0);
            									}
            									else {
HXDLIN(  71)										_hx_tmp12 = false;
            									}
HXDLIN(  71)									if (_hx_tmp12) {
HXDLIN(  71)										Float u = (((au * ratioA) + (bu1 * ratioB)) + (du * ratioC));
HXDLIN(  71)										Float v6 = (((av * ratioA) + (bv1 * ratioB)) + (dv * ratioC));
HXDLIN(  71)										int x7 = ::Std_obj::_hx_int(((u * win_width) + win_x));
HXDLIN(  71)										int y6 = ::Std_obj::_hx_int(((v6 * win_height) + win_y));
HXDLIN(  71)										::Dynamic this41 = this1->image;
HXDLIN(  71)										int index6;
HXDLIN(  71)										if (this1->useVirtualPos) {
HXDLIN(  71)											index6 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - this1->virtualY) * ( (Float)(this1->width) )) + x7) - this1->virtualX));
            										}
            										else {
HXDLIN(  71)											index6 = ::Std_obj::_hx_int(( (Float)(((y6 * this1->width) + x7)) ));
            										}
HXDLIN(  71)										int c5 = ::iterMagic::Iimg_obj::get(this41,index6);
HXDLIN(  71)										int col1;
HXDLIN(  71)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  71)											col1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            										}
            										else {
HXDLIN(  71)											col1 = c5;
            										}
HXDLIN(  71)										{
HXDLIN(  71)											int c6 = col1;
HXDLIN(  71)											bool _hx_tmp14;
HXDLIN(  71)											if ((((c6 >> 24) & 255) < 254)) {
HXDLIN(  71)												_hx_tmp14 = this18->transparent;
            											}
            											else {
HXDLIN(  71)												_hx_tmp14 = false;
            											}
HXDLIN(  71)											if (_hx_tmp14) {
HXDLIN(  71)												int location2;
HXDLIN(  71)												if (this18->useVirtualPos) {
HXDLIN(  71)													location2 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this18->virtualY) * ( (Float)(this18->width) )) + px) - this18->virtualX));
            												}
            												else {
HXDLIN(  71)													location2 = ::Std_obj::_hx_int(( (Float)(((py * this18->width) + px)) ));
            												}
HXDLIN(  71)												int this42 = ::iterMagic::Iimg_obj::get(this18->image,location2);
HXDLIN(  71)												int this43;
HXDLIN(  71)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  71)													this43 = ((((((this42 >> 24) & 255) << 24) | ((this42 & 255) << 16)) | (((this42 >> 8) & 255) << 8)) | ((this42 >> 16) & 255));
            												}
            												else {
HXDLIN(  71)													this43 = this42;
            												}
HXDLIN(  71)												Float a12;
HXDLIN(  71)												int this44 = ((this43 >> 24) & 255);
HXDLIN(  71)												if ((this44 == 0)) {
HXDLIN(  71)													a12 = ((Float)0.);
            												}
            												else {
HXDLIN(  71)													a12 = (( (Float)(this44) ) / ( (Float)(255) ));
            												}
HXDLIN(  71)												Float r12;
HXDLIN(  71)												int this45 = ((this43 >> 16) & 255);
HXDLIN(  71)												if ((this45 == 0)) {
HXDLIN(  71)													r12 = ((Float)0.);
            												}
            												else {
HXDLIN(  71)													r12 = (( (Float)(this45) ) / ( (Float)(255) ));
            												}
HXDLIN(  71)												Float g12;
HXDLIN(  71)												int this46 = ((this43 >> 8) & 255);
HXDLIN(  71)												if ((this46 == 0)) {
HXDLIN(  71)													g12 = ((Float)0.);
            												}
            												else {
HXDLIN(  71)													g12 = (( (Float)(this46) ) / ( (Float)(255) ));
            												}
HXDLIN(  71)												Float b13;
HXDLIN(  71)												int this47 = (this43 & 255);
HXDLIN(  71)												if ((this47 == 0)) {
HXDLIN(  71)													b13 = ((Float)0.);
            												}
            												else {
HXDLIN(  71)													b13 = (( (Float)(this47) ) / ( (Float)(255) ));
            												}
HXDLIN(  71)												Float a22;
HXDLIN(  71)												int this48 = ((col1 >> 24) & 255);
HXDLIN(  71)												if ((this48 == 0)) {
HXDLIN(  71)													a22 = ((Float)0.);
            												}
            												else {
HXDLIN(  71)													a22 = (( (Float)(this48) ) / ( (Float)(255) ));
            												}
HXDLIN(  71)												Float r22;
HXDLIN(  71)												int this49 = ((col1 >> 16) & 255);
HXDLIN(  71)												if ((this49 == 0)) {
HXDLIN(  71)													r22 = ((Float)0.);
            												}
            												else {
HXDLIN(  71)													r22 = (( (Float)(this49) ) / ( (Float)(255) ));
            												}
HXDLIN(  71)												Float g22;
HXDLIN(  71)												int this50 = ((col1 >> 8) & 255);
HXDLIN(  71)												if ((this50 == 0)) {
HXDLIN(  71)													g22 = ((Float)0.);
            												}
            												else {
HXDLIN(  71)													g22 = (( (Float)(this50) ) / ( (Float)(255) ));
            												}
HXDLIN(  71)												Float b23;
HXDLIN(  71)												int this51 = (col1 & 255);
HXDLIN(  71)												if ((this51 == 0)) {
HXDLIN(  71)													b23 = ((Float)0.);
            												}
            												else {
HXDLIN(  71)													b23 = (( (Float)(this51) ) / ( (Float)(255) ));
            												}
HXDLIN(  71)												Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  71)												int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  71)												int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  71)												int b14 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  71)												int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  71)												int blended2 = ((((a8 << 24) | (r4 << 16)) | (g4 << 8)) | b14);
HXDLIN(  71)												{
HXDLIN(  71)													int _hx_tmp15;
HXDLIN(  71)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  71)														_hx_tmp15 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            													}
            													else {
HXDLIN(  71)														_hx_tmp15 = blended2;
            													}
HXDLIN(  71)													::iterMagic::Iimg_obj::set(this18->image,location2,_hx_tmp15);
            												}
            											}
            											else {
HXDLIN(  71)												::Dynamic this52 = this18->image;
HXDLIN(  71)												int index7;
HXDLIN(  71)												if (this18->useVirtualPos) {
HXDLIN(  71)													index7 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this18->virtualY) * ( (Float)(this18->width) )) + px) - this18->virtualX));
            												}
            												else {
HXDLIN(  71)													index7 = ::Std_obj::_hx_int(( (Float)(((py * this18->width) + px)) ));
            												}
HXDLIN(  71)												int _hx_tmp16;
HXDLIN(  71)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  71)													_hx_tmp16 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            												}
            												else {
HXDLIN(  71)													_hx_tmp16 = c6;
            												}
HXDLIN(  71)												::iterMagic::Iimg_obj::set(this52,index7,_hx_tmp16);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  71)					 ::pi_xy::iter::IntIterStart v_yIter3;
HXDLIN(  71)					 ::pi_xy::iter::IntIterStart v_xIter3;
HXDLIN(  71)					int v_undoY;
HXDLIN(  71)					int v_undoX;
HXDLIN(  71)					Float v_ty;
HXDLIN(  71)					Float v_tx;
HXDLIN(  71)					Float v_t0;
HXDLIN(  71)					Float v_sy;
HXDLIN(  71)					Float v_sx;
HXDLIN(  71)					Float v_s0;
HXDLIN(  71)					Float v_A;
HXDLIN(  71)					 ::pi_xy::ImageStruct v_undoImage = null();
HXDLIN(  71)					Float bx = w1;
HXDLIN(  71)					Float by = ( (Float)(0) );
HXDLIN(  71)					Float cx = ( (Float)(0) );
HXDLIN(  71)					Float cy = h;
HXDLIN(  71)					bool adjustWinding = (((((( (Float)(0) ) * by) - (bx * ( (Float)(0) ))) + ((bx * cy) - (cx * by))) + ((cx * ( (Float)(0) )) - (( (Float)(0) ) * cy))) > 0);
HXDLIN(  71)					if (!(adjustWinding)) {
HXDLIN(  71)						Float bx_ = bx;
HXDLIN(  71)						Float by_ = by;
HXLINE(  24)						bx = cx;
HXLINE(  25)						by = cy;
HXLINE(  26)						cx = bx_;
HXLINE(  27)						cy = by_;
            					}
HXLINE(  71)					Float v_ax = ( (Float)(0) );
HXDLIN(  71)					Float v_ay = ( (Float)(0) );
HXDLIN(  71)					Float v_bx = bx;
HXDLIN(  71)					Float v_by = by;
HXDLIN(  71)					Float v_cx = cx;
HXDLIN(  71)					Float v_cy = cy;
HXDLIN(  71)					bool v_preCalculated = true;
HXDLIN(  71)					{
HXDLIN(  71)						v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN(  71)						v_sx = (v_cy - v_ay);
HXDLIN(  71)						v_sy = (v_ax - v_cx);
HXDLIN(  71)						v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN(  71)						v_tx = (v_ay - v_by);
HXDLIN(  71)						v_ty = (v_bx - v_ax);
HXDLIN(  71)						v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN(  71)						Float a9 = v_ax;
HXDLIN(  71)						Float b15 = v_bx;
HXDLIN(  71)						Float c7 = v_cx;
HXDLIN(  71)						if ((a9 > b15)) {
HXDLIN(  71)							if ((a9 > c7)) {
HXDLIN(  71)								int min1;
HXDLIN(  71)								if ((b15 > c7)) {
HXDLIN(  71)									min1 = ::Math_obj::floor(c7);
            								}
            								else {
HXDLIN(  71)									min1 = ::Math_obj::floor(b15);
            								}
HXDLIN(  71)								int ii_min5 = min1;
HXDLIN(  71)								int ii_max5 = ::Math_obj::ceil(a9);
HXDLIN(  71)								v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            							}
            							else {
HXDLIN(  71)								int ii_min6 = ::Math_obj::floor(b15);
HXDLIN(  71)								int ii_max6 = ::Math_obj::ceil(c7);
HXDLIN(  71)								v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            							}
            						}
            						else {
HXDLIN(  71)							if ((b15 > c7)) {
HXDLIN(  71)								int min2;
HXDLIN(  71)								if ((a9 > c7)) {
HXDLIN(  71)									min2 = ::Math_obj::floor(c7);
            								}
            								else {
HXDLIN(  71)									min2 = ::Math_obj::ceil(a9);
            								}
HXDLIN(  71)								int ii_min7 = min2;
HXDLIN(  71)								int ii_max7 = ::Math_obj::ceil(b15);
HXDLIN(  71)								v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            							}
            							else {
HXDLIN(  71)								int ii_min8 = ::Math_obj::floor(a9);
HXDLIN(  71)								int ii_max8 = ::Math_obj::ceil(c7);
HXDLIN(  71)								v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            							}
            						}
HXDLIN(  71)						Float a10 = v_ay;
HXDLIN(  71)						Float b16 = v_by;
HXDLIN(  71)						Float c8 = v_cy;
HXDLIN(  71)						if ((a10 > b16)) {
HXDLIN(  71)							if ((a10 > c8)) {
HXDLIN(  71)								int min3;
HXDLIN(  71)								if ((b16 > c8)) {
HXDLIN(  71)									min3 = ::Math_obj::floor(c8);
            								}
            								else {
HXDLIN(  71)									min3 = ::Math_obj::floor(b16);
            								}
HXDLIN(  71)								int ii_min9 = min3;
HXDLIN(  71)								int ii_max9 = ::Math_obj::ceil(a10);
HXDLIN(  71)								v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            							}
            							else {
HXDLIN(  71)								int ii_min10 = ::Math_obj::floor(b16);
HXDLIN(  71)								int ii_max10 = ::Math_obj::ceil(c8);
HXDLIN(  71)								v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            							}
            						}
            						else {
HXDLIN(  71)							if ((b16 > c8)) {
HXDLIN(  71)								int min4;
HXDLIN(  71)								if ((a10 > c8)) {
HXDLIN(  71)									min4 = ::Math_obj::floor(c8);
            								}
            								else {
HXDLIN(  71)									min4 = ::Math_obj::ceil(a10);
            								}
HXDLIN(  71)								int ii_min11 = min4;
HXDLIN(  71)								int ii_max11 = ::Math_obj::ceil(b16);
HXDLIN(  71)								v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            							}
            							else {
HXDLIN(  71)								int ii_min12 = ::Math_obj::floor(a10);
HXDLIN(  71)								int ii_max12 = ::Math_obj::ceil(c8);
HXDLIN(  71)								v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            							}
            						}
            					}
HXDLIN(  71)					if (hasUndo) {
HXDLIN(  71)						v_undoImage = undoImage;
HXDLIN(  71)						v_undoX = xIter3->start;
HXDLIN(  71)						v_undoY = yIter3->start;
            					}
HXDLIN(  71)					Float au1 = bu;
HXDLIN(  71)					Float av1 = bv;
HXDLIN(  71)					Float bu2 = cu;
HXDLIN(  71)					Float bv2 = cv;
HXDLIN(  71)					bool hasUndo1 = false;
HXDLIN(  71)					Float temp1 = au1;
HXLINE( 422)					au1 = bu2;
HXLINE( 423)					bu2 = temp1;
HXLINE( 424)					temp1 = av1;
HXLINE( 425)					av1 = bv2;
HXLINE( 426)					bv2 = temp1;
HXLINE(  71)					Float bcx1 = w1;
HXDLIN(  71)					Float bcy1 = (h - h);
HXDLIN(  71)					Float acx1 = w1;
HXDLIN(  71)					Float acy1 = (( (Float)(0) ) - h);
HXDLIN(  71)					Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  71)					Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  71)					Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  71)					Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  71)					 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  71)					if ((w1 > w1)) {
HXDLIN(  71)						if ((w1 > 0)) {
HXDLIN(  71)							int min5;
HXDLIN(  71)							if ((w1 > 0)) {
HXDLIN(  71)								min5 = ::Math_obj::floor(( (Float)(0) ));
            							}
            							else {
HXDLIN(  71)								min5 = ::Math_obj::floor(w1);
            							}
HXDLIN(  71)							int ii_min13 = min5;
HXDLIN(  71)							int ii_max13 = ::Math_obj::ceil(w1);
HXDLIN(  71)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            						}
            						else {
HXDLIN(  71)							int ii_min14 = ::Math_obj::floor(w1);
HXDLIN(  71)							int ii_max14 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  71)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            						}
            					}
            					else {
HXDLIN(  71)						if ((w1 > 0)) {
HXDLIN(  71)							int min6;
HXDLIN(  71)							if ((w1 > 0)) {
HXDLIN(  71)								min6 = ::Math_obj::floor(( (Float)(0) ));
            							}
            							else {
HXDLIN(  71)								min6 = ::Math_obj::ceil(w1);
            							}
HXDLIN(  71)							int ii_min15 = min6;
HXDLIN(  71)							int ii_max15 = ::Math_obj::ceil(w1);
HXDLIN(  71)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            						}
            						else {
HXDLIN(  71)							int ii_min16 = ::Math_obj::floor(w1);
HXDLIN(  71)							int ii_max16 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  71)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            						}
            					}
HXDLIN(  71)					 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  71)					if ((0 > h)) {
HXDLIN(  71)						if ((0 > h)) {
HXDLIN(  71)							int min7;
HXDLIN(  71)							if ((h > h)) {
HXDLIN(  71)								min7 = ::Math_obj::floor(h);
            							}
            							else {
HXDLIN(  71)								min7 = ::Math_obj::floor(h);
            							}
HXDLIN(  71)							int ii_min17 = min7;
HXDLIN(  71)							int ii_max17 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  71)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            						}
            						else {
HXDLIN(  71)							int ii_min18 = ::Math_obj::floor(h);
HXDLIN(  71)							int ii_max18 = ::Math_obj::ceil(h);
HXDLIN(  71)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            						}
            					}
            					else {
HXDLIN(  71)						if ((h > h)) {
HXDLIN(  71)							int min8;
HXDLIN(  71)							if ((0 > h)) {
HXDLIN(  71)								min8 = ::Math_obj::floor(h);
            							}
            							else {
HXDLIN(  71)								min8 = ::Math_obj::ceil(( (Float)(0) ));
            							}
HXDLIN(  71)							int ii_min19 = min8;
HXDLIN(  71)							int ii_max19 = ::Math_obj::ceil(h);
HXDLIN(  71)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            						}
            						else {
HXDLIN(  71)							int ii_min20 = ::Math_obj::floor(( (Float)(0) ));
HXDLIN(  71)							int ii_max20 = ::Math_obj::ceil(h);
HXDLIN(  71)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            						}
            					}
HXDLIN(  71)					 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  71)					if (hasUndo1) {
HXDLIN(  71)						int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  71)						int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  71)						 ::Dynamic imageType3 = null();
HXDLIN(  71)						 ::pi_xy::ImageStruct this53 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  71)						if (::hx::IsNull( imageType3 )) {
HXLINE(  54)							imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE(  71)						::Dynamic undoImage4;
HXDLIN(  71)						switch((int)(( (int)(imageType3) ))){
            							case (int)0: {
HXDLIN(  71)								 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  71)								 ::iterMagic::BytesImg b17 = byt3;
HXDLIN(  71)								{
HXDLIN(  71)									b17->width = width1;
HXDLIN(  71)									b17->height = height1;
HXDLIN(  71)									b17->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  71)									b17->data = ::haxe::io::Bytes_obj::alloc((b17->length * 4));
HXDLIN(  71)									{
HXDLIN(  71)										int len6 = b17->length;
HXDLIN(  71)										int w4 = 0;
HXDLIN(  71)										{
HXDLIN(  71)											int _g52 = 0;
HXDLIN(  71)											int _g53 = b17->height;
HXDLIN(  71)											while((_g52 < _g53)){
HXDLIN(  71)												_g52 = (_g52 + 1);
HXDLIN(  71)												int y7 = (_g52 - 1);
HXDLIN(  71)												{
HXDLIN(  71)													int _g54 = 0;
HXDLIN(  71)													int _g55 = b17->width;
HXDLIN(  71)													while((_g54 < _g55)){
HXDLIN(  71)														_g54 = (_g54 + 1);
HXDLIN(  71)														int x8 = (_g54 - 1);
HXDLIN(  71)														{
HXDLIN(  71)															w4 = (w4 + 1);
HXDLIN(  71)															b17->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  71)														{
HXDLIN(  71)															w4 = (w4 + 1);
HXDLIN(  71)															b17->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  71)														{
HXDLIN(  71)															w4 = (w4 + 1);
HXDLIN(  71)															b17->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  71)														{
HXDLIN(  71)															w4 = (w4 + 1);
HXDLIN(  71)															b17->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  71)								undoImage4 = b17;
            							}
            							break;
            							case (int)1: {
HXDLIN(  71)								 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  71)								 ::iterMagic::ArrIntImg a13 = arrI3;
HXDLIN(  71)								{
HXDLIN(  71)									a13->width = width1;
HXDLIN(  71)									a13->height = height1;
HXDLIN(  71)									a13->data = ::Array_obj< int >::__new(0);
HXDLIN(  71)									a13->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  71)									{
HXDLIN(  71)										int _g56 = 0;
HXDLIN(  71)										int _g57 = a13->length;
HXDLIN(  71)										while((_g56 < _g57)){
HXDLIN(  71)											_g56 = (_g56 + 1);
HXDLIN(  71)											int i18 = (_g56 - 1);
HXDLIN(  71)											a13->data[i18] = 0;
            										}
            									}
            								}
HXDLIN(  71)								undoImage4 = a13;
            							}
            							break;
            							case (int)2: {
HXDLIN(  71)								 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  71)								 ::iterMagic::U32ArrImg b18 = u32a3;
HXDLIN(  71)								{
HXDLIN(  71)									b18->width = width1;
HXDLIN(  71)									b18->height = height1;
HXDLIN(  71)									b18->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  71)									int size3 = (b18->length * 4);
HXDLIN(  71)									b18->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN(  71)									{
HXDLIN(  71)										int _g58 = 0;
HXDLIN(  71)										int _g59 = b18->length;
HXDLIN(  71)										while((_g58 < _g59)){
HXDLIN(  71)											_g58 = (_g58 + 1);
HXDLIN(  71)											int i19 = (_g58 - 1);
HXDLIN(  71)											{
HXDLIN(  71)												 ::haxe::io::ArrayBufferViewImpl this54 = b18->data;
HXDLIN(  71)												bool undoImage5;
HXDLIN(  71)												if ((i19 >= 0)) {
HXDLIN(  71)													undoImage5 = (i19 < (this54->byteLength >> 2));
            												}
            												else {
HXDLIN(  71)													undoImage5 = false;
            												}
HXDLIN(  71)												if (undoImage5) {
HXDLIN(  71)													 ::haxe::io::Bytes _this3 = this54->bytes;
HXDLIN(  71)													int pos3 = ((i19 << 2) + this54->byteOffset);
HXDLIN(  71)													_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN(  71)													_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN(  71)													_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN(  71)													_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN(  71)								undoImage4 = b18;
            							}
            							break;
            							case (int)3: {
HXDLIN(  71)								 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  71)								 ::iterMagic::VecIntImg v7 = vec3;
HXDLIN(  71)								{
HXDLIN(  71)									v7->width = width1;
HXDLIN(  71)									v7->height = height1;
HXDLIN(  71)									v7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  71)									v7->data = ::Array_obj< int >::__new(v7->length);
HXDLIN(  71)									{
HXDLIN(  71)										int _g60 = 0;
HXDLIN(  71)										int _g61 = v7->length;
HXDLIN(  71)										while((_g60 < _g61)){
HXDLIN(  71)											_g60 = (_g60 + 1);
HXDLIN(  71)											int i20 = (_g60 - 1);
HXDLIN(  71)											v7->data->__unsafe_set(i20,0);
            										}
            									}
            								}
HXDLIN(  71)								undoImage4 = v7;
            							}
            							break;
            							case (int)4: {
HXDLIN(  71)								 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  71)								 ::iterMagic::StackIntImg b19 = sInt3;
HXDLIN(  71)								{
HXDLIN(  71)									b19->width = width1;
HXDLIN(  71)									b19->height = height1;
HXDLIN(  71)									b19->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  71)									b19->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  71)									{
HXDLIN(  71)										int len7 = b19->length;
HXDLIN(  71)										 ::haxe::ds::GenericStack_Int d3 = b19->data;
HXDLIN(  71)										if (::hx::IsNull( d3->head )) {
HXDLIN(  71)											int _g62 = 0;
HXDLIN(  71)											int _g63 = len7;
HXDLIN(  71)											while((_g62 < _g63)){
HXDLIN(  71)												_g62 = (_g62 + 1);
HXDLIN(  71)												int i21 = (_g62 - 1);
HXDLIN(  71)												d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            											}
            										}
            										else {
HXDLIN(  71)											int _g64 = 0;
HXDLIN(  71)											int _g65 = len7;
HXDLIN(  71)											while((_g64 < _g65)){
HXDLIN(  71)												_g64 = (_g64 + 1);
HXDLIN(  71)												int i22 = (_g64 - 1);
HXDLIN(  71)												{
HXDLIN(  71)													 ::haxe::ds::GenericCell_Int l3 = b19->data->head;
HXDLIN(  71)													 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN(  71)													{
HXDLIN(  71)														int _g66 = 0;
HXDLIN(  71)														int _g67 = i22;
HXDLIN(  71)														while((_g66 < _g67)){
HXDLIN(  71)															_g66 = (_g66 + 1);
HXDLIN(  71)															int i23 = (_g66 - 1);
HXLINE( 345)															prev3 = l3;
HXLINE( 346)															l3 = l3->next;
            														}
            													}
HXLINE(  71)													if (::hx::IsNull( prev3 )) {
HXDLIN(  71)														b19->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  71)														l3 = null();
            													}
            													else {
HXDLIN(  71)														prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  71)														l3 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  71)								undoImage4 = b19;
            							}
            							break;
            						}
HXDLIN(  71)						this53->image = undoImage4;
HXDLIN(  71)						this53->width = width1;
HXDLIN(  71)						this53->height = height1;
HXDLIN(  71)						this53->imageType = ( (int)(imageType3) );
HXDLIN(  71)						undoImage3 = this53;
HXDLIN(  71)						{
HXDLIN(  71)							int rectLeft1 = xIter31->start;
HXDLIN(  71)							int rectTop1 = yIter31->start;
HXDLIN(  71)							int rectRight1 = xIter31->max;
HXDLIN(  71)							bool forceClear1 = false;
HXDLIN(  71)							{
HXDLIN(  71)								int _g68 = rectTop1;
HXDLIN(  71)								int _g69 = yIter31->max;
HXDLIN(  71)								while((_g68 < _g69)){
HXDLIN(  71)									_g68 = (_g68 + 1);
HXDLIN(  71)									int dy1 = (_g68 - 1);
HXDLIN(  71)									{
HXDLIN(  71)										int _g70 = rectLeft1;
HXDLIN(  71)										int _g71 = rectRight1;
HXDLIN(  71)										while((_g70 < _g71)){
HXDLIN(  71)											_g70 = (_g70 + 1);
HXDLIN(  71)											int dx1 = (_g70 - 1);
HXDLIN(  71)											::Dynamic this55 = this18->image;
HXDLIN(  71)											int index8;
HXDLIN(  71)											if (this18->useVirtualPos) {
HXDLIN(  71)												index8 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this18->virtualY) * ( (Float)(this18->width) )) + dx1) - this18->virtualX));
            											}
            											else {
HXDLIN(  71)												index8 = ::Std_obj::_hx_int(( (Float)(((dy1 * this18->width) + dx1)) ));
            											}
HXDLIN(  71)											int c9 = ::iterMagic::Iimg_obj::get(this55,index8);
HXDLIN(  71)											int col2;
HXDLIN(  71)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  71)												col2 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            											}
            											else {
HXDLIN(  71)												col2 = c9;
            											}
HXDLIN(  71)											bool _hx_tmp17;
HXDLIN(  71)											if (this18->useMask) {
HXDLIN(  71)												_hx_tmp17 = ::hx::IsNotNull( this18->mask );
            											}
            											else {
HXDLIN(  71)												_hx_tmp17 = false;
            											}
HXDLIN(  71)											if (_hx_tmp17) {
HXDLIN(  71)												 ::pi_xy::ImageStruct this56 = this18->mask;
HXDLIN(  71)												::Dynamic this57 = this56->image;
HXDLIN(  71)												int index9;
HXDLIN(  71)												if (this56->useVirtualPos) {
HXDLIN(  71)													index9 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this56->virtualY) * ( (Float)(this56->width) )) + dx1) - this56->virtualX));
            												}
            												else {
HXDLIN(  71)													index9 = ::Std_obj::_hx_int(( (Float)(((dy1 * this56->width) + dx1)) ));
            												}
HXDLIN(  71)												int c10 = ::iterMagic::Iimg_obj::get(this57,index9);
HXDLIN(  71)												int v8;
HXDLIN(  71)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  71)													v8 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            												}
            												else {
HXDLIN(  71)													v8 = c10;
            												}
HXDLIN(  71)												int maskPixel1 = v8;
HXDLIN(  71)												int this58 = col2;
HXDLIN(  71)												if ((maskPixel1 == 0)) {
HXDLIN(  71)													col2 = this58;
            												}
            												else {
HXDLIN(  71)													Float m01;
HXDLIN(  71)													int this59 = ((maskPixel1 >> 24) & 255);
HXDLIN(  71)													if ((this59 == 0)) {
HXDLIN(  71)														m01 = ((Float)0.);
            													}
            													else {
HXDLIN(  71)														m01 = (( (Float)(this59) ) / ( (Float)(255) ));
            													}
HXDLIN(  71)													Float m11;
HXDLIN(  71)													int this60 = ((maskPixel1 >> 16) & 255);
HXDLIN(  71)													if ((this60 == 0)) {
HXDLIN(  71)														m11 = ((Float)0.);
            													}
            													else {
HXDLIN(  71)														m11 = (( (Float)(this60) ) / ( (Float)(255) ));
            													}
HXDLIN(  71)													Float m21;
HXDLIN(  71)													int this61 = ((maskPixel1 >> 8) & 255);
HXDLIN(  71)													if ((this61 == 0)) {
HXDLIN(  71)														m21 = ((Float)0.);
            													}
            													else {
HXDLIN(  71)														m21 = (( (Float)(this61) ) / ( (Float)(255) ));
            													}
HXDLIN(  71)													Float m31;
HXDLIN(  71)													int this62 = (maskPixel1 & 255);
HXDLIN(  71)													if ((this62 == 0)) {
HXDLIN(  71)														m31 = ((Float)0.);
            													}
            													else {
HXDLIN(  71)														m31 = (( (Float)(this62) ) / ( (Float)(255) ));
            													}
HXDLIN(  71)													int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this58 >> 24) & 255)) )));
HXDLIN(  71)													int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this58 >> 16) & 255)) )));
HXDLIN(  71)													int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this58 >> 8) & 255)) )));
HXDLIN(  71)													int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this58 & 255)) )));
HXDLIN(  71)													col2 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  71)											if ((col2 != 0)) {
HXDLIN(  71)												int x9 = (dx1 - rectLeft1);
HXDLIN(  71)												int y8 = (dy1 - rectTop1);
HXDLIN(  71)												int c11 = col2;
HXDLIN(  71)												bool _hx_tmp18;
HXDLIN(  71)												if ((((c11 >> 24) & 255) < 254)) {
HXDLIN(  71)													_hx_tmp18 = undoImage3->transparent;
            												}
            												else {
HXDLIN(  71)													_hx_tmp18 = false;
            												}
HXDLIN(  71)												if (_hx_tmp18) {
HXDLIN(  71)													int location3;
HXDLIN(  71)													if (undoImage3->useVirtualPos) {
HXDLIN(  71)														location3 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x9) - undoImage3->virtualX));
            													}
            													else {
HXDLIN(  71)														location3 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage3->width) + x9)) ));
            													}
HXDLIN(  71)													int this63 = ::iterMagic::Iimg_obj::get(undoImage3->image,location3);
HXDLIN(  71)													int this64;
HXDLIN(  71)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  71)														this64 = ((((((this63 >> 24) & 255) << 24) | ((this63 & 255) << 16)) | (((this63 >> 8) & 255) << 8)) | ((this63 >> 16) & 255));
            													}
            													else {
HXDLIN(  71)														this64 = this63;
            													}
HXDLIN(  71)													Float a14;
HXDLIN(  71)													int this65 = ((this64 >> 24) & 255);
HXDLIN(  71)													if ((this65 == 0)) {
HXDLIN(  71)														a14 = ((Float)0.);
            													}
            													else {
HXDLIN(  71)														a14 = (( (Float)(this65) ) / ( (Float)(255) ));
            													}
HXDLIN(  71)													Float r13;
HXDLIN(  71)													int this66 = ((this64 >> 16) & 255);
HXDLIN(  71)													if ((this66 == 0)) {
HXDLIN(  71)														r13 = ((Float)0.);
            													}
            													else {
HXDLIN(  71)														r13 = (( (Float)(this66) ) / ( (Float)(255) ));
            													}
HXDLIN(  71)													Float g13;
HXDLIN(  71)													int this67 = ((this64 >> 8) & 255);
HXDLIN(  71)													if ((this67 == 0)) {
HXDLIN(  71)														g13 = ((Float)0.);
            													}
            													else {
HXDLIN(  71)														g13 = (( (Float)(this67) ) / ( (Float)(255) ));
            													}
HXDLIN(  71)													Float b110;
HXDLIN(  71)													int this68 = (this64 & 255);
HXDLIN(  71)													if ((this68 == 0)) {
HXDLIN(  71)														b110 = ((Float)0.);
            													}
            													else {
HXDLIN(  71)														b110 = (( (Float)(this68) ) / ( (Float)(255) ));
            													}
HXDLIN(  71)													Float a23;
HXDLIN(  71)													int this69 = ((col2 >> 24) & 255);
HXDLIN(  71)													if ((this69 == 0)) {
HXDLIN(  71)														a23 = ((Float)0.);
            													}
            													else {
HXDLIN(  71)														a23 = (( (Float)(this69) ) / ( (Float)(255) ));
            													}
HXDLIN(  71)													Float r23;
HXDLIN(  71)													int this70 = ((col2 >> 16) & 255);
HXDLIN(  71)													if ((this70 == 0)) {
HXDLIN(  71)														r23 = ((Float)0.);
            													}
            													else {
HXDLIN(  71)														r23 = (( (Float)(this70) ) / ( (Float)(255) ));
            													}
HXDLIN(  71)													Float g23;
HXDLIN(  71)													int this71 = ((col2 >> 8) & 255);
HXDLIN(  71)													if ((this71 == 0)) {
HXDLIN(  71)														g23 = ((Float)0.);
            													}
            													else {
HXDLIN(  71)														g23 = (( (Float)(this71) ) / ( (Float)(255) ));
            													}
HXDLIN(  71)													Float b24;
HXDLIN(  71)													int this72 = (col2 & 255);
HXDLIN(  71)													if ((this72 == 0)) {
HXDLIN(  71)														b24 = ((Float)0.);
            													}
            													else {
HXDLIN(  71)														b24 = (( (Float)(this72) ) / ( (Float)(255) ));
            													}
HXDLIN(  71)													Float a33 = (a14 * (( (Float)(1) ) - a23));
HXDLIN(  71)													int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  71)													int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  71)													int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a33) + (b24 * a23))));
HXDLIN(  71)													int a15 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  71)													int blended3 = ((((a15 << 24) | (r5 << 16)) | (g5 << 8)) | b20);
HXDLIN(  71)													{
HXDLIN(  71)														int _hx_tmp19;
HXDLIN(  71)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  71)															_hx_tmp19 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            														}
            														else {
HXDLIN(  71)															_hx_tmp19 = blended3;
            														}
HXDLIN(  71)														::iterMagic::Iimg_obj::set(undoImage3->image,location3,_hx_tmp19);
            													}
            												}
            												else {
HXDLIN(  71)													::Dynamic this73 = undoImage3->image;
HXDLIN(  71)													int index10;
HXDLIN(  71)													if (undoImage3->useVirtualPos) {
HXDLIN(  71)														index10 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x9) - undoImage3->virtualX));
            													}
            													else {
HXDLIN(  71)														index10 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage3->width) + x9)) ));
            													}
HXDLIN(  71)													int _hx_tmp20;
HXDLIN(  71)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  71)														_hx_tmp20 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            													}
            													else {
HXDLIN(  71)														_hx_tmp20 = c11;
            													}
HXDLIN(  71)													::iterMagic::Iimg_obj::set(this73,index10,_hx_tmp20);
            												}
            											}
            											else {
HXDLIN(  71)												if (forceClear1) {
HXDLIN(  71)													::Dynamic this74 = undoImage3->image;
HXDLIN(  71)													int x10 = (dx1 - rectLeft1);
HXDLIN(  71)													int y9 = (dy1 - rectTop1);
HXDLIN(  71)													int index11;
HXDLIN(  71)													if (undoImage3->useVirtualPos) {
HXDLIN(  71)														index11 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x10) - undoImage3->virtualX));
            													}
            													else {
HXDLIN(  71)														index11 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage3->width) + x10)) ));
            													}
HXDLIN(  71)													::iterMagic::Iimg_obj::set(this74,index11,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  71)					{
HXDLIN(  71)						int _g_min2 = xIter31->start;
HXDLIN(  71)						int _g_max2 = xIter31->max;
HXDLIN(  71)						while((_g_min2 < _g_max2)){
HXDLIN(  71)							_g_min2 = (_g_min2 + 1);
HXDLIN(  71)							int px1 = (_g_min2 - 1);
HXDLIN(  71)							Float pcx1 = ( (Float)(px1) );
HXDLIN(  71)							{
HXDLIN(  71)								int _g_min3 = yIter31->start;
HXDLIN(  71)								int _g_max3 = yIter31->max;
HXDLIN(  71)								while((_g_min3 < _g_max3)){
HXDLIN(  71)									_g_min3 = (_g_min3 + 1);
HXDLIN(  71)									int py1 = (_g_min3 - 1);
HXDLIN(  71)									Float pcy1 = (( (Float)(py1) ) - h);
HXDLIN(  71)									Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN(  71)									Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN(  71)									Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN(  71)									Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN(  71)									Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN(  71)									bool _hx_tmp21;
HXDLIN(  71)									bool _hx_tmp22;
HXDLIN(  71)									if ((ratioA1 >= 0)) {
HXDLIN(  71)										_hx_tmp22 = (ratioB1 >= 0);
            									}
            									else {
HXDLIN(  71)										_hx_tmp22 = false;
            									}
HXDLIN(  71)									if (_hx_tmp22) {
HXDLIN(  71)										_hx_tmp21 = (ratioC1 >= 0);
            									}
            									else {
HXDLIN(  71)										_hx_tmp21 = false;
            									}
HXDLIN(  71)									if (_hx_tmp21) {
HXDLIN(  71)										Float u1 = (((au1 * ratioA1) + (bu2 * ratioB1)) + (du * ratioC1));
HXDLIN(  71)										Float v9 = (((av1 * ratioA1) + (bv2 * ratioB1)) + (dv * ratioC1));
HXDLIN(  71)										int x11 = ::Std_obj::_hx_int(((u1 * win_width) + win_x));
HXDLIN(  71)										int y10 = ::Std_obj::_hx_int(((v9 * win_height) + win_y));
HXDLIN(  71)										::Dynamic this75 = this1->image;
HXDLIN(  71)										int index12;
HXDLIN(  71)										if (this1->useVirtualPos) {
HXDLIN(  71)											index12 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - this1->virtualY) * ( (Float)(this1->width) )) + x11) - this1->virtualX));
            										}
            										else {
HXDLIN(  71)											index12 = ::Std_obj::_hx_int(( (Float)(((y10 * this1->width) + x11)) ));
            										}
HXDLIN(  71)										int c12 = ::iterMagic::Iimg_obj::get(this75,index12);
HXDLIN(  71)										int col3;
HXDLIN(  71)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  71)											col3 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            										}
            										else {
HXDLIN(  71)											col3 = c12;
            										}
HXDLIN(  71)										{
HXDLIN(  71)											int c13 = col3;
HXDLIN(  71)											bool _hx_tmp23;
HXDLIN(  71)											if ((((c13 >> 24) & 255) < 254)) {
HXDLIN(  71)												_hx_tmp23 = this18->transparent;
            											}
            											else {
HXDLIN(  71)												_hx_tmp23 = false;
            											}
HXDLIN(  71)											if (_hx_tmp23) {
HXDLIN(  71)												int location4;
HXDLIN(  71)												if (this18->useVirtualPos) {
HXDLIN(  71)													location4 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this18->virtualY) * ( (Float)(this18->width) )) + px1) - this18->virtualX));
            												}
            												else {
HXDLIN(  71)													location4 = ::Std_obj::_hx_int(( (Float)(((py1 * this18->width) + px1)) ));
            												}
HXDLIN(  71)												int this76 = ::iterMagic::Iimg_obj::get(this18->image,location4);
HXDLIN(  71)												int this77;
HXDLIN(  71)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  71)													this77 = ((((((this76 >> 24) & 255) << 24) | ((this76 & 255) << 16)) | (((this76 >> 8) & 255) << 8)) | ((this76 >> 16) & 255));
            												}
            												else {
HXDLIN(  71)													this77 = this76;
            												}
HXDLIN(  71)												Float a16;
HXDLIN(  71)												int this78 = ((this77 >> 24) & 255);
HXDLIN(  71)												if ((this78 == 0)) {
HXDLIN(  71)													a16 = ((Float)0.);
            												}
            												else {
HXDLIN(  71)													a16 = (( (Float)(this78) ) / ( (Float)(255) ));
            												}
HXDLIN(  71)												Float r14;
HXDLIN(  71)												int this79 = ((this77 >> 16) & 255);
HXDLIN(  71)												if ((this79 == 0)) {
HXDLIN(  71)													r14 = ((Float)0.);
            												}
            												else {
HXDLIN(  71)													r14 = (( (Float)(this79) ) / ( (Float)(255) ));
            												}
HXDLIN(  71)												Float g14;
HXDLIN(  71)												int this80 = ((this77 >> 8) & 255);
HXDLIN(  71)												if ((this80 == 0)) {
HXDLIN(  71)													g14 = ((Float)0.);
            												}
            												else {
HXDLIN(  71)													g14 = (( (Float)(this80) ) / ( (Float)(255) ));
            												}
HXDLIN(  71)												Float b111;
HXDLIN(  71)												int this81 = (this77 & 255);
HXDLIN(  71)												if ((this81 == 0)) {
HXDLIN(  71)													b111 = ((Float)0.);
            												}
            												else {
HXDLIN(  71)													b111 = (( (Float)(this81) ) / ( (Float)(255) ));
            												}
HXDLIN(  71)												Float a24;
HXDLIN(  71)												int this82 = ((col3 >> 24) & 255);
HXDLIN(  71)												if ((this82 == 0)) {
HXDLIN(  71)													a24 = ((Float)0.);
            												}
            												else {
HXDLIN(  71)													a24 = (( (Float)(this82) ) / ( (Float)(255) ));
            												}
HXDLIN(  71)												Float r24;
HXDLIN(  71)												int this83 = ((col3 >> 16) & 255);
HXDLIN(  71)												if ((this83 == 0)) {
HXDLIN(  71)													r24 = ((Float)0.);
            												}
            												else {
HXDLIN(  71)													r24 = (( (Float)(this83) ) / ( (Float)(255) ));
            												}
HXDLIN(  71)												Float g24;
HXDLIN(  71)												int this84 = ((col3 >> 8) & 255);
HXDLIN(  71)												if ((this84 == 0)) {
HXDLIN(  71)													g24 = ((Float)0.);
            												}
            												else {
HXDLIN(  71)													g24 = (( (Float)(this84) ) / ( (Float)(255) ));
            												}
HXDLIN(  71)												Float b25;
HXDLIN(  71)												int this85 = (col3 & 255);
HXDLIN(  71)												if ((this85 == 0)) {
HXDLIN(  71)													b25 = ((Float)0.);
            												}
            												else {
HXDLIN(  71)													b25 = (( (Float)(this85) ) / ( (Float)(255) ));
            												}
HXDLIN(  71)												Float a34 = (a16 * (( (Float)(1) ) - a24));
HXDLIN(  71)												int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN(  71)												int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN(  71)												int b26 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a34) + (b25 * a24))));
HXDLIN(  71)												int a17 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN(  71)												int blended4 = ((((a17 << 24) | (r6 << 16)) | (g6 << 8)) | b26);
HXDLIN(  71)												{
HXDLIN(  71)													int _hx_tmp24;
HXDLIN(  71)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  71)														_hx_tmp24 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            													}
            													else {
HXDLIN(  71)														_hx_tmp24 = blended4;
            													}
HXDLIN(  71)													::iterMagic::Iimg_obj::set(this18->image,location4,_hx_tmp24);
            												}
            											}
            											else {
HXDLIN(  71)												::Dynamic this86 = this18->image;
HXDLIN(  71)												int index13;
HXDLIN(  71)												if (this18->useVirtualPos) {
HXDLIN(  71)													index13 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this18->virtualY) * ( (Float)(this18->width) )) + px1) - this18->virtualX));
            												}
            												else {
HXDLIN(  71)													index13 = ::Std_obj::_hx_int(( (Float)(((py1 * this18->width) + px1)) ));
            												}
HXDLIN(  71)												int _hx_tmp25;
HXDLIN(  71)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  71)													_hx_tmp25 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            												}
            												else {
HXDLIN(  71)													_hx_tmp25 = c13;
            												}
HXDLIN(  71)												::iterMagic::Iimg_obj::set(this86,index13,_hx_tmp25);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  71)					 ::pi_xy::iter::IntIterStart v_yIter31;
HXDLIN(  71)					 ::pi_xy::iter::IntIterStart v_xIter31;
HXDLIN(  71)					int v_undoY1;
HXDLIN(  71)					int v_undoX1;
HXDLIN(  71)					Float v_ty1;
HXDLIN(  71)					Float v_tx1;
HXDLIN(  71)					Float v_t01;
HXDLIN(  71)					Float v_sy1;
HXDLIN(  71)					Float v_sx1;
HXDLIN(  71)					Float v_s01;
HXDLIN(  71)					Float v_A1;
HXDLIN(  71)					Float ax = w1;
HXDLIN(  71)					 ::pi_xy::ImageStruct v_undoImage1 = null();
HXDLIN(  71)					Float bx1 = w1;
HXDLIN(  71)					Float by1 = h;
HXDLIN(  71)					Float cx1 = ( (Float)(0) );
HXDLIN(  71)					Float cy1 = h;
HXDLIN(  71)					bool adjustWinding1 = (((((ax * by1) - (bx1 * ( (Float)(0) ))) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ( (Float)(0) )) - (ax * cy1))) > 0);
HXDLIN(  71)					if (!(adjustWinding1)) {
HXDLIN(  71)						Float bx_1 = bx1;
HXDLIN(  71)						Float by_1 = by1;
HXLINE(  24)						bx1 = cx1;
HXLINE(  25)						by1 = cy1;
HXLINE(  26)						cx1 = bx_1;
HXLINE(  27)						cy1 = by_1;
            					}
HXLINE(  71)					Float v_ax1 = ax;
HXDLIN(  71)					Float v_ay1 = ( (Float)(0) );
HXDLIN(  71)					Float v_bx1 = bx1;
HXDLIN(  71)					Float v_by1 = by1;
HXDLIN(  71)					Float v_cx1 = cx1;
HXDLIN(  71)					Float v_cy1 = cy1;
HXDLIN(  71)					bool v_preCalculated1 = true;
HXDLIN(  71)					{
HXDLIN(  71)						v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN(  71)						v_sx1 = (v_cy1 - v_ay1);
HXDLIN(  71)						v_sy1 = (v_ax1 - v_cx1);
HXDLIN(  71)						v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN(  71)						v_tx1 = (v_ay1 - v_by1);
HXDLIN(  71)						v_ty1 = (v_bx1 - v_ax1);
HXDLIN(  71)						v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN(  71)						Float a18 = v_ax1;
HXDLIN(  71)						Float b27 = v_bx1;
HXDLIN(  71)						Float c14 = v_cx1;
HXDLIN(  71)						if ((a18 > b27)) {
HXDLIN(  71)							if ((a18 > c14)) {
HXDLIN(  71)								int min9;
HXDLIN(  71)								if ((b27 > c14)) {
HXDLIN(  71)									min9 = ::Math_obj::floor(c14);
            								}
            								else {
HXDLIN(  71)									min9 = ::Math_obj::floor(b27);
            								}
HXDLIN(  71)								int ii_min21 = min9;
HXDLIN(  71)								int ii_max21 = ::Math_obj::ceil(a18);
HXDLIN(  71)								v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            							}
            							else {
HXDLIN(  71)								int ii_min22 = ::Math_obj::floor(b27);
HXDLIN(  71)								int ii_max22 = ::Math_obj::ceil(c14);
HXDLIN(  71)								v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            							}
            						}
            						else {
HXDLIN(  71)							if ((b27 > c14)) {
HXDLIN(  71)								int min10;
HXDLIN(  71)								if ((a18 > c14)) {
HXDLIN(  71)									min10 = ::Math_obj::floor(c14);
            								}
            								else {
HXDLIN(  71)									min10 = ::Math_obj::ceil(a18);
            								}
HXDLIN(  71)								int ii_min23 = min10;
HXDLIN(  71)								int ii_max23 = ::Math_obj::ceil(b27);
HXDLIN(  71)								v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            							}
            							else {
HXDLIN(  71)								int ii_min24 = ::Math_obj::floor(a18);
HXDLIN(  71)								int ii_max24 = ::Math_obj::ceil(c14);
HXDLIN(  71)								v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            							}
            						}
HXDLIN(  71)						Float a19 = v_ay1;
HXDLIN(  71)						Float b28 = v_by1;
HXDLIN(  71)						Float c15 = v_cy1;
HXDLIN(  71)						if ((a19 > b28)) {
HXDLIN(  71)							if ((a19 > c15)) {
HXDLIN(  71)								int min11;
HXDLIN(  71)								if ((b28 > c15)) {
HXDLIN(  71)									min11 = ::Math_obj::floor(c15);
            								}
            								else {
HXDLIN(  71)									min11 = ::Math_obj::floor(b28);
            								}
HXDLIN(  71)								int ii_min25 = min11;
HXDLIN(  71)								int ii_max25 = ::Math_obj::ceil(a19);
HXDLIN(  71)								v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            							}
            							else {
HXDLIN(  71)								int ii_min26 = ::Math_obj::floor(b28);
HXDLIN(  71)								int ii_max26 = ::Math_obj::ceil(c15);
HXDLIN(  71)								v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            							}
            						}
            						else {
HXDLIN(  71)							if ((b28 > c15)) {
HXDLIN(  71)								int min12;
HXDLIN(  71)								if ((a19 > c15)) {
HXDLIN(  71)									min12 = ::Math_obj::floor(c15);
            								}
            								else {
HXDLIN(  71)									min12 = ::Math_obj::ceil(a19);
            								}
HXDLIN(  71)								int ii_min27 = min12;
HXDLIN(  71)								int ii_max27 = ::Math_obj::ceil(b28);
HXDLIN(  71)								v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            							}
            							else {
HXDLIN(  71)								int ii_min28 = ::Math_obj::floor(a19);
HXDLIN(  71)								int ii_max28 = ::Math_obj::ceil(c15);
HXDLIN(  71)								v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            							}
            						}
            					}
HXDLIN(  71)					if (hasUndo1) {
HXDLIN(  71)						v_undoImage1 = undoImage3;
HXDLIN(  71)						v_undoX1 = xIter31->start;
HXDLIN(  71)						v_undoY1 = yIter31->start;
            					}
            				}
            			}
HXDLIN(  71)			bool _hx_tmp26;
HXDLIN(  71)			if (::hx::IsNotNull( this1->mask )) {
HXDLIN(  71)				_hx_tmp26 = includeMask;
            			}
            			else {
HXDLIN(  71)				_hx_tmp26 = false;
            			}
HXDLIN(  71)			if (_hx_tmp26) {
HXDLIN(  71)				 ::pi_xy::ImageStruct v10 = ::pi_xy::transformation::_ScaleImage::ScaleImage_Fields__obj::scalingXY(this1->mask,sx,sy,this1->mask->transparent,includeMask);
HXDLIN(  71)				nextImage1->useMask = true;
HXDLIN(  71)				nextImage1->mask = v10;
            			}
HXDLIN(  71)			return nextImage1;
            		}
HXDLIN(  71)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(TransformImage_Impl__obj,scaleXY,return )

 ::pi_xy::ImageStruct TransformImage_Impl__obj::rotateClockwiseDegrees( ::pi_xy::ImageStruct this1,Float angle,::hx::Null< Float >  __o_centreX,::hx::Null< Float >  __o_centreY,::hx::Null< bool >  __o_transparent,::hx::Null< bool >  __o_includeMask){
            		Float centreX = __o_centreX.Default(((Float)0.));
            		Float centreY = __o_centreY.Default(((Float)0.));
            		bool transparent = __o_transparent.Default(false);
            		bool includeMask = __o_includeMask.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_68d25436a32dba6f_78_rotateClockwiseDegrees)
HXDLIN(  78)		Float angle1 = angle;
HXDLIN(  78)		while((angle1 >= 360)){
HXDLIN(  78)			angle1 = (angle1 - ( (Float)(360) ));
            		}
HXDLIN(  78)		while((angle1 <= -360)){
HXDLIN(  78)			angle1 = (angle1 + 360);
            		}
HXDLIN(  78)		bool _hx_tmp;
HXDLIN(  78)		if ((angle1 != ((Float)90.))) {
HXDLIN(  78)			_hx_tmp = (angle1 == -270);
            		}
            		else {
HXDLIN(  78)			_hx_tmp = true;
            		}
HXDLIN(  78)		if (_hx_tmp) {
HXDLIN(  78)			Float w = ( (Float)(this1->width) );
HXDLIN(  78)			Float h = ( (Float)(this1->height) );
HXDLIN(  78)			 ::pi_xy::ImageStruct thisImage = this1;
HXDLIN(  78)			 ::Dynamic r =  ::Dynamic(::hx::Anon_obj::Create(4)
            				->setFixed(0,HX_("h",68,00,00,00),h)
            				->setFixed(1,HX_("w",77,00,00,00),w)
            				->setFixed(2,HX_("x",78,00,00,00),0)
            				->setFixed(3,HX_("y",79,00,00,00),0));
HXDLIN(  78)			int xmax = ::Std_obj::_hx_int(( (Float)(((r->__Field(HX_("x",78,00,00,00),::hx::paccDynamic) + r->__Field(HX_("w",77,00,00,00),::hx::paccDynamic)) + 1)) ));
HXDLIN(  78)			int ymax = ::Std_obj::_hx_int(( (Float)(((r->__Field(HX_("y",79,00,00,00),::hx::paccDynamic) + r->__Field(HX_("h",68,00,00,00),::hx::paccDynamic)) + 1)) ));
HXDLIN(  78)			int ii_min = ::Std_obj::_hx_int(( (Float)(r->__Field(HX_("x",78,00,00,00),::hx::paccDynamic)) ));
HXDLIN(  78)			int ii_max = xmax;
HXDLIN(  78)			int xRange__start = ii_min;
HXDLIN(  78)			int xRange__max = ii_max;
HXDLIN(  78)			int ii_min1 = ::Std_obj::_hx_int(( (Float)(r->__Field(HX_("y",79,00,00,00),::hx::paccDynamic)) ));
HXDLIN(  78)			int ii_max1 = ymax;
HXDLIN(  78)			int yRange__start = ii_min1;
HXDLIN(  78)			int yRange__max = ii_max1;
HXDLIN(  78)			int range_x = xRange__start;
HXDLIN(  78)			int range_y = (yRange__start - 1);
HXDLIN(  78)			int range_xReset = range_x;
HXDLIN(  78)			int range_yReset = range_y;
HXDLIN(  78)			int range_xMax = (xRange__max - 2);
HXDLIN(  78)			int range_yMax = (yRange__max - 2);
HXDLIN(  78)			int _this_min = 0;
HXDLIN(  78)			int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXDLIN(  78)			int width = ::Std_obj::_hx_int(w);
HXDLIN(  78)			int height = ::Std_obj::_hx_int(h);
HXDLIN(  78)			 ::Dynamic imageType = null();
HXDLIN(  78)			 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  78)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE(  78)			::Dynamic _hx_tmp1;
HXDLIN(  78)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXDLIN(  78)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  78)					 ::iterMagic::BytesImg b = byt;
HXDLIN(  78)					{
HXDLIN(  78)						b->width = width;
HXDLIN(  78)						b->height = height;
HXDLIN(  78)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  78)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  78)						{
HXDLIN(  78)							int len = b->length;
HXDLIN(  78)							int w1 = 0;
HXDLIN(  78)							{
HXDLIN(  78)								int _g = 0;
HXDLIN(  78)								int _g1 = b->height;
HXDLIN(  78)								while((_g < _g1)){
HXDLIN(  78)									_g = (_g + 1);
HXDLIN(  78)									int y = (_g - 1);
HXDLIN(  78)									{
HXDLIN(  78)										int _g2 = 0;
HXDLIN(  78)										int _g3 = b->width;
HXDLIN(  78)										while((_g2 < _g3)){
HXDLIN(  78)											_g2 = (_g2 + 1);
HXDLIN(  78)											int x = (_g2 - 1);
HXDLIN(  78)											{
HXDLIN(  78)												w1 = (w1 + 1);
HXDLIN(  78)												b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  78)											{
HXDLIN(  78)												w1 = (w1 + 1);
HXDLIN(  78)												b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  78)											{
HXDLIN(  78)												w1 = (w1 + 1);
HXDLIN(  78)												b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  78)											{
HXDLIN(  78)												w1 = (w1 + 1);
HXDLIN(  78)												b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  78)					_hx_tmp1 = b;
            				}
            				break;
            				case (int)1: {
HXDLIN(  78)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  78)					{
HXDLIN(  78)						a->width = width;
HXDLIN(  78)						a->height = height;
HXDLIN(  78)						a->data = ::Array_obj< int >::__new(0);
HXDLIN(  78)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  78)						{
HXDLIN(  78)							int _g4 = 0;
HXDLIN(  78)							int _g5 = a->length;
HXDLIN(  78)							while((_g4 < _g5)){
HXDLIN(  78)								_g4 = (_g4 + 1);
HXDLIN(  78)								int i = (_g4 - 1);
HXDLIN(  78)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN(  78)					_hx_tmp1 = a;
            				}
            				break;
            				case (int)2: {
HXDLIN(  78)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  78)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  78)					{
HXDLIN(  78)						b1->width = width;
HXDLIN(  78)						b1->height = height;
HXDLIN(  78)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  78)						int size = (b1->length * 4);
HXDLIN(  78)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  78)						{
HXDLIN(  78)							int _g6 = 0;
HXDLIN(  78)							int _g7 = b1->length;
HXDLIN(  78)							while((_g6 < _g7)){
HXDLIN(  78)								_g6 = (_g6 + 1);
HXDLIN(  78)								int i1 = (_g6 - 1);
HXDLIN(  78)								{
HXDLIN(  78)									 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  78)									bool _hx_tmp2;
HXDLIN(  78)									if ((i1 >= 0)) {
HXDLIN(  78)										_hx_tmp2 = (i1 < (this3->byteLength >> 2));
            									}
            									else {
HXDLIN(  78)										_hx_tmp2 = false;
            									}
HXDLIN(  78)									if (_hx_tmp2) {
HXDLIN(  78)										 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  78)										int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  78)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  78)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  78)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  78)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN(  78)					_hx_tmp1 = b1;
            				}
            				break;
            				case (int)3: {
HXDLIN(  78)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)					 ::iterMagic::VecIntImg v = vec;
HXDLIN(  78)					{
HXDLIN(  78)						v->width = width;
HXDLIN(  78)						v->height = height;
HXDLIN(  78)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  78)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  78)						{
HXDLIN(  78)							int _g8 = 0;
HXDLIN(  78)							int _g9 = v->length;
HXDLIN(  78)							while((_g8 < _g9)){
HXDLIN(  78)								_g8 = (_g8 + 1);
HXDLIN(  78)								int i2 = (_g8 - 1);
HXDLIN(  78)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN(  78)					_hx_tmp1 = v;
            				}
            				break;
            				case (int)4: {
HXDLIN(  78)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  78)					{
HXDLIN(  78)						b2->width = width;
HXDLIN(  78)						b2->height = height;
HXDLIN(  78)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  78)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  78)						{
HXDLIN(  78)							int len1 = b2->length;
HXDLIN(  78)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  78)							if (::hx::IsNull( d->head )) {
HXDLIN(  78)								int _g10 = 0;
HXDLIN(  78)								int _g11 = len1;
HXDLIN(  78)								while((_g10 < _g11)){
HXDLIN(  78)									_g10 = (_g10 + 1);
HXDLIN(  78)									int i3 = (_g10 - 1);
HXDLIN(  78)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXDLIN(  78)								int _g12 = 0;
HXDLIN(  78)								int _g13 = len1;
HXDLIN(  78)								while((_g12 < _g13)){
HXDLIN(  78)									_g12 = (_g12 + 1);
HXDLIN(  78)									int i4 = (_g12 - 1);
HXDLIN(  78)									{
HXDLIN(  78)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  78)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  78)										{
HXDLIN(  78)											int _g14 = 0;
HXDLIN(  78)											int _g15 = i4;
HXDLIN(  78)											while((_g14 < _g15)){
HXDLIN(  78)												_g14 = (_g14 + 1);
HXDLIN(  78)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE(  78)										if (::hx::IsNull( prev )) {
HXDLIN(  78)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  78)											l = null();
            										}
            										else {
HXDLIN(  78)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  78)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  78)					_hx_tmp1 = b2;
            				}
            				break;
            			}
HXDLIN(  78)			this2->image = _hx_tmp1;
HXDLIN(  78)			this2->width = width;
HXDLIN(  78)			this2->height = height;
HXDLIN(  78)			this2->imageType = ( (int)(imageType) );
HXDLIN(  78)			 ::pi_xy::ImageStruct nextImage = this2;
HXDLIN(  78)			nextImage->transparent = transparent;
HXDLIN(  78)			while((_this_min < _this_max)){
HXDLIN(  78)				_this_min = (_this_min + 1);
HXDLIN(  78)				int i6 = (_this_min - 1);
HXDLIN(  78)				if ((range_y > range_yMax)) {
HXDLIN(  78)					range_y = range_yReset;
HXDLIN(  78)					range_x = (range_x + 1);
            				}
HXDLIN(  78)				range_y = (range_y + 1);
HXDLIN(  78)				int i7 = i6;
HXDLIN(  78)				{
HXDLIN(  78)					int x1 = (range_yMax - range_y);
HXDLIN(  78)					int y1 = range_x;
HXDLIN(  78)					int x2 = range_x;
HXDLIN(  78)					int y2 = range_y;
HXDLIN(  78)					::Dynamic this4 = thisImage->image;
HXDLIN(  78)					int index;
HXDLIN(  78)					if (thisImage->useVirtualPos) {
HXDLIN(  78)						index = ::Std_obj::_hx_int(((((( (Float)(y2) ) - thisImage->virtualY) * ( (Float)(thisImage->width) )) + x2) - thisImage->virtualX));
            					}
            					else {
HXDLIN(  78)						index = ::Std_obj::_hx_int(( (Float)(((y2 * thisImage->width) + x2)) ));
            					}
HXDLIN(  78)					int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN(  78)					int color;
HXDLIN(  78)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)						color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            					}
            					else {
HXDLIN(  78)						color = c;
            					}
HXDLIN(  78)					int c1 = color;
HXDLIN(  78)					bool _hx_tmp3;
HXDLIN(  78)					if ((((c1 >> 24) & 255) < 254)) {
HXDLIN(  78)						_hx_tmp3 = nextImage->transparent;
            					}
            					else {
HXDLIN(  78)						_hx_tmp3 = false;
            					}
HXDLIN(  78)					if (_hx_tmp3) {
HXDLIN(  78)						int location;
HXDLIN(  78)						if (nextImage->useVirtualPos) {
HXDLIN(  78)							location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x1) - nextImage->virtualX));
            						}
            						else {
HXDLIN(  78)							location = ::Std_obj::_hx_int(( (Float)(((y1 * nextImage->width) + x1)) ));
            						}
HXDLIN(  78)						int this5 = ::iterMagic::Iimg_obj::get(nextImage->image,location);
HXDLIN(  78)						int this6;
HXDLIN(  78)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)							this6 = ((((((this5 >> 24) & 255) << 24) | ((this5 & 255) << 16)) | (((this5 >> 8) & 255) << 8)) | ((this5 >> 16) & 255));
            						}
            						else {
HXDLIN(  78)							this6 = this5;
            						}
HXDLIN(  78)						Float a1;
HXDLIN(  78)						int this7 = ((this6 >> 24) & 255);
HXDLIN(  78)						if ((this7 == 0)) {
HXDLIN(  78)							a1 = ((Float)0.);
            						}
            						else {
HXDLIN(  78)							a1 = (( (Float)(this7) ) / ( (Float)(255) ));
            						}
HXDLIN(  78)						Float r1;
HXDLIN(  78)						int this8 = ((this6 >> 16) & 255);
HXDLIN(  78)						if ((this8 == 0)) {
HXDLIN(  78)							r1 = ((Float)0.);
            						}
            						else {
HXDLIN(  78)							r1 = (( (Float)(this8) ) / ( (Float)(255) ));
            						}
HXDLIN(  78)						Float g1;
HXDLIN(  78)						int this9 = ((this6 >> 8) & 255);
HXDLIN(  78)						if ((this9 == 0)) {
HXDLIN(  78)							g1 = ((Float)0.);
            						}
            						else {
HXDLIN(  78)							g1 = (( (Float)(this9) ) / ( (Float)(255) ));
            						}
HXDLIN(  78)						Float b11;
HXDLIN(  78)						int this10 = (this6 & 255);
HXDLIN(  78)						if ((this10 == 0)) {
HXDLIN(  78)							b11 = ((Float)0.);
            						}
            						else {
HXDLIN(  78)							b11 = (( (Float)(this10) ) / ( (Float)(255) ));
            						}
HXDLIN(  78)						Float a2;
HXDLIN(  78)						int this11 = ((color >> 24) & 255);
HXDLIN(  78)						if ((this11 == 0)) {
HXDLIN(  78)							a2 = ((Float)0.);
            						}
            						else {
HXDLIN(  78)							a2 = (( (Float)(this11) ) / ( (Float)(255) ));
            						}
HXDLIN(  78)						Float r2;
HXDLIN(  78)						int this12 = ((color >> 16) & 255);
HXDLIN(  78)						if ((this12 == 0)) {
HXDLIN(  78)							r2 = ((Float)0.);
            						}
            						else {
HXDLIN(  78)							r2 = (( (Float)(this12) ) / ( (Float)(255) ));
            						}
HXDLIN(  78)						Float g2;
HXDLIN(  78)						int this13 = ((color >> 8) & 255);
HXDLIN(  78)						if ((this13 == 0)) {
HXDLIN(  78)							g2 = ((Float)0.);
            						}
            						else {
HXDLIN(  78)							g2 = (( (Float)(this13) ) / ( (Float)(255) ));
            						}
HXDLIN(  78)						Float b21;
HXDLIN(  78)						int this14 = (color & 255);
HXDLIN(  78)						if ((this14 == 0)) {
HXDLIN(  78)							b21 = ((Float)0.);
            						}
            						else {
HXDLIN(  78)							b21 = (( (Float)(this14) ) / ( (Float)(255) ));
            						}
HXDLIN(  78)						Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  78)						int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  78)						int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  78)						int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  78)						int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  78)						int blended = ((((a4 << 24) | (r3 << 16)) | (g << 8)) | b3);
HXDLIN(  78)						{
HXDLIN(  78)							int _hx_tmp4;
HXDLIN(  78)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)								_hx_tmp4 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            							}
            							else {
HXDLIN(  78)								_hx_tmp4 = blended;
            							}
HXDLIN(  78)							::iterMagic::Iimg_obj::set(nextImage->image,location,_hx_tmp4);
            						}
            					}
            					else {
HXDLIN(  78)						::Dynamic this15 = nextImage->image;
HXDLIN(  78)						int index1;
HXDLIN(  78)						if (nextImage->useVirtualPos) {
HXDLIN(  78)							index1 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x1) - nextImage->virtualX));
            						}
            						else {
HXDLIN(  78)							index1 = ::Std_obj::_hx_int(( (Float)(((y1 * nextImage->width) + x1)) ));
            						}
HXDLIN(  78)						int _hx_tmp5;
HXDLIN(  78)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)							_hx_tmp5 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            						}
            						else {
HXDLIN(  78)							_hx_tmp5 = c1;
            						}
HXDLIN(  78)						::iterMagic::Iimg_obj::set(this15,index1,_hx_tmp5);
            					}
            				}
            			}
HXDLIN(  78)			bool _hx_tmp6;
HXDLIN(  78)			if (::hx::IsNotNull( thisImage->mask )) {
HXDLIN(  78)				_hx_tmp6 = includeMask;
            			}
            			else {
HXDLIN(  78)				_hx_tmp6 = false;
            			}
HXDLIN(  78)			if (_hx_tmp6) {
HXDLIN(  78)				 ::pi_xy::ImageStruct v1 = ::pi_xy::transformation::_SpinImage::SpinImage_Fields__obj::spinClock90(thisImage->mask,( (Float)(0) ),( (Float)(0) ),w,h,thisImage->mask->transparent,includeMask);
HXDLIN(  78)				nextImage->useMask = true;
HXDLIN(  78)				nextImage->mask = v1;
            			}
HXDLIN(  78)			return nextImage;
            		}
            		else {
HXDLIN(  78)			bool _hx_tmp7;
HXDLIN(  78)			if ((angle1 != -90)) {
HXDLIN(  78)				_hx_tmp7 = (angle1 == 270);
            			}
            			else {
HXDLIN(  78)				_hx_tmp7 = true;
            			}
HXDLIN(  78)			if (_hx_tmp7) {
HXDLIN(  78)				Float w2 = ( (Float)(this1->width) );
HXDLIN(  78)				Float h1 = ( (Float)(this1->height) );
HXDLIN(  78)				 ::pi_xy::ImageStruct thisImage1 = this1;
HXDLIN(  78)				 ::Dynamic r4 =  ::Dynamic(::hx::Anon_obj::Create(4)
            					->setFixed(0,HX_("h",68,00,00,00),h1)
            					->setFixed(1,HX_("w",77,00,00,00),w2)
            					->setFixed(2,HX_("x",78,00,00,00),0)
            					->setFixed(3,HX_("y",79,00,00,00),0));
HXDLIN(  78)				int xmax1 = ::Std_obj::_hx_int(( (Float)(((r4->__Field(HX_("x",78,00,00,00),::hx::paccDynamic) + r4->__Field(HX_("w",77,00,00,00),::hx::paccDynamic)) + 1)) ));
HXDLIN(  78)				int ymax1 = ::Std_obj::_hx_int(( (Float)(((r4->__Field(HX_("y",79,00,00,00),::hx::paccDynamic) + r4->__Field(HX_("h",68,00,00,00),::hx::paccDynamic)) + 1)) ));
HXDLIN(  78)				int ii_min2 = ::Std_obj::_hx_int(( (Float)(r4->__Field(HX_("x",78,00,00,00),::hx::paccDynamic)) ));
HXDLIN(  78)				int ii_max2 = xmax1;
HXDLIN(  78)				int xRange__start1 = ii_min2;
HXDLIN(  78)				int xRange__max1 = ii_max2;
HXDLIN(  78)				int ii_min3 = ::Std_obj::_hx_int(( (Float)(r4->__Field(HX_("y",79,00,00,00),::hx::paccDynamic)) ));
HXDLIN(  78)				int ii_max3 = ymax1;
HXDLIN(  78)				int yRange__start1 = ii_min3;
HXDLIN(  78)				int yRange__max1 = ii_max3;
HXDLIN(  78)				int range_x1 = xRange__start1;
HXDLIN(  78)				int range_y1 = (yRange__start1 - 1);
HXDLIN(  78)				int range_xReset1 = range_x1;
HXDLIN(  78)				int range_yReset1 = range_y1;
HXDLIN(  78)				int range_xMax1 = (xRange__max1 - 2);
HXDLIN(  78)				int range_yMax1 = (yRange__max1 - 2);
HXDLIN(  78)				int _this_min1 = 0;
HXDLIN(  78)				int _this_max1 = ::Std_obj::_hx_int(( (Float)(((xRange__max1 - xRange__start1) * (yRange__max1 - yRange__start1))) ));
HXDLIN(  78)				int width1 = ::Std_obj::_hx_int(w2);
HXDLIN(  78)				int height1 = ::Std_obj::_hx_int(h1);
HXDLIN(  78)				 ::Dynamic imageType1 = null();
HXDLIN(  78)				 ::pi_xy::ImageStruct this16 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  78)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE(  78)				::Dynamic _hx_tmp8;
HXDLIN(  78)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXDLIN(  78)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  78)						 ::iterMagic::BytesImg b4 = byt1;
HXDLIN(  78)						{
HXDLIN(  78)							b4->width = width1;
HXDLIN(  78)							b4->height = height1;
HXDLIN(  78)							b4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  78)							b4->data = ::haxe::io::Bytes_obj::alloc((b4->length * 4));
HXDLIN(  78)							{
HXDLIN(  78)								int len2 = b4->length;
HXDLIN(  78)								int w3 = 0;
HXDLIN(  78)								{
HXDLIN(  78)									int _g16 = 0;
HXDLIN(  78)									int _g17 = b4->height;
HXDLIN(  78)									while((_g16 < _g17)){
HXDLIN(  78)										_g16 = (_g16 + 1);
HXDLIN(  78)										int y3 = (_g16 - 1);
HXDLIN(  78)										{
HXDLIN(  78)											int _g18 = 0;
HXDLIN(  78)											int _g19 = b4->width;
HXDLIN(  78)											while((_g18 < _g19)){
HXDLIN(  78)												_g18 = (_g18 + 1);
HXDLIN(  78)												int x3 = (_g18 - 1);
HXDLIN(  78)												{
HXDLIN(  78)													w3 = (w3 + 1);
HXDLIN(  78)													b4->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  78)												{
HXDLIN(  78)													w3 = (w3 + 1);
HXDLIN(  78)													b4->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  78)												{
HXDLIN(  78)													w3 = (w3 + 1);
HXDLIN(  78)													b4->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  78)												{
HXDLIN(  78)													w3 = (w3 + 1);
HXDLIN(  78)													b4->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  78)						_hx_tmp8 = b4;
            					}
            					break;
            					case (int)1: {
HXDLIN(  78)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)						 ::iterMagic::ArrIntImg a5 = arrI1;
HXDLIN(  78)						{
HXDLIN(  78)							a5->width = width1;
HXDLIN(  78)							a5->height = height1;
HXDLIN(  78)							a5->data = ::Array_obj< int >::__new(0);
HXDLIN(  78)							a5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  78)							{
HXDLIN(  78)								int _g20 = 0;
HXDLIN(  78)								int _g21 = a5->length;
HXDLIN(  78)								while((_g20 < _g21)){
HXDLIN(  78)									_g20 = (_g20 + 1);
HXDLIN(  78)									int i8 = (_g20 - 1);
HXDLIN(  78)									a5->data[i8] = 0;
            								}
            							}
            						}
HXDLIN(  78)						_hx_tmp8 = a5;
            					}
            					break;
            					case (int)2: {
HXDLIN(  78)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  78)						 ::iterMagic::U32ArrImg b5 = u32a1;
HXDLIN(  78)						{
HXDLIN(  78)							b5->width = width1;
HXDLIN(  78)							b5->height = height1;
HXDLIN(  78)							b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  78)							int size1 = (b5->length * 4);
HXDLIN(  78)							b5->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  78)							{
HXDLIN(  78)								int _g22 = 0;
HXDLIN(  78)								int _g23 = b5->length;
HXDLIN(  78)								while((_g22 < _g23)){
HXDLIN(  78)									_g22 = (_g22 + 1);
HXDLIN(  78)									int i9 = (_g22 - 1);
HXDLIN(  78)									{
HXDLIN(  78)										 ::haxe::io::ArrayBufferViewImpl this17 = b5->data;
HXDLIN(  78)										bool _hx_tmp9;
HXDLIN(  78)										if ((i9 >= 0)) {
HXDLIN(  78)											_hx_tmp9 = (i9 < (this17->byteLength >> 2));
            										}
            										else {
HXDLIN(  78)											_hx_tmp9 = false;
            										}
HXDLIN(  78)										if (_hx_tmp9) {
HXDLIN(  78)											 ::haxe::io::Bytes _this1 = this17->bytes;
HXDLIN(  78)											int pos1 = ((i9 << 2) + this17->byteOffset);
HXDLIN(  78)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  78)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  78)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  78)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN(  78)						_hx_tmp8 = b5;
            					}
            					break;
            					case (int)3: {
HXDLIN(  78)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)						 ::iterMagic::VecIntImg v2 = vec1;
HXDLIN(  78)						{
HXDLIN(  78)							v2->width = width1;
HXDLIN(  78)							v2->height = height1;
HXDLIN(  78)							v2->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  78)							v2->data = ::Array_obj< int >::__new(v2->length);
HXDLIN(  78)							{
HXDLIN(  78)								int _g24 = 0;
HXDLIN(  78)								int _g25 = v2->length;
HXDLIN(  78)								while((_g24 < _g25)){
HXDLIN(  78)									_g24 = (_g24 + 1);
HXDLIN(  78)									int i10 = (_g24 - 1);
HXDLIN(  78)									v2->data->__unsafe_set(i10,0);
            								}
            							}
            						}
HXDLIN(  78)						_hx_tmp8 = v2;
            					}
            					break;
            					case (int)4: {
HXDLIN(  78)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)						 ::iterMagic::StackIntImg b6 = sInt1;
HXDLIN(  78)						{
HXDLIN(  78)							b6->width = width1;
HXDLIN(  78)							b6->height = height1;
HXDLIN(  78)							b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  78)							b6->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  78)							{
HXDLIN(  78)								int len3 = b6->length;
HXDLIN(  78)								 ::haxe::ds::GenericStack_Int d1 = b6->data;
HXDLIN(  78)								if (::hx::IsNull( d1->head )) {
HXDLIN(  78)									int _g26 = 0;
HXDLIN(  78)									int _g27 = len3;
HXDLIN(  78)									while((_g26 < _g27)){
HXDLIN(  78)										_g26 = (_g26 + 1);
HXDLIN(  78)										int i11 = (_g26 - 1);
HXDLIN(  78)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXDLIN(  78)									int _g28 = 0;
HXDLIN(  78)									int _g29 = len3;
HXDLIN(  78)									while((_g28 < _g29)){
HXDLIN(  78)										_g28 = (_g28 + 1);
HXDLIN(  78)										int i12 = (_g28 - 1);
HXDLIN(  78)										{
HXDLIN(  78)											 ::haxe::ds::GenericCell_Int l1 = b6->data->head;
HXDLIN(  78)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  78)											{
HXDLIN(  78)												int _g30 = 0;
HXDLIN(  78)												int _g31 = i12;
HXDLIN(  78)												while((_g30 < _g31)){
HXDLIN(  78)													_g30 = (_g30 + 1);
HXDLIN(  78)													int i13 = (_g30 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE(  78)											if (::hx::IsNull( prev1 )) {
HXDLIN(  78)												b6->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  78)												l1 = null();
            											}
            											else {
HXDLIN(  78)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  78)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  78)						_hx_tmp8 = b6;
            					}
            					break;
            				}
HXDLIN(  78)				this16->image = _hx_tmp8;
HXDLIN(  78)				this16->width = width1;
HXDLIN(  78)				this16->height = height1;
HXDLIN(  78)				this16->imageType = ( (int)(imageType1) );
HXDLIN(  78)				 ::pi_xy::ImageStruct nextImage1 = this16;
HXDLIN(  78)				nextImage1->transparent = transparent;
HXDLIN(  78)				while((_this_min1 < _this_max1)){
HXDLIN(  78)					_this_min1 = (_this_min1 + 1);
HXDLIN(  78)					int i14 = (_this_min1 - 1);
HXDLIN(  78)					if ((range_y1 > range_yMax1)) {
HXDLIN(  78)						range_y1 = range_yReset1;
HXDLIN(  78)						range_x1 = (range_x1 + 1);
            					}
HXDLIN(  78)					range_y1 = (range_y1 + 1);
HXDLIN(  78)					int i15 = i14;
HXDLIN(  78)					{
HXDLIN(  78)						int x4 = range_y1;
HXDLIN(  78)						int y4 = (range_xMax1 - range_x1);
HXDLIN(  78)						int x5 = range_y1;
HXDLIN(  78)						int y5 = range_x1;
HXDLIN(  78)						::Dynamic this18 = thisImage1->image;
HXDLIN(  78)						int index2;
HXDLIN(  78)						if (thisImage1->useVirtualPos) {
HXDLIN(  78)							index2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - thisImage1->virtualY) * ( (Float)(thisImage1->width) )) + x5) - thisImage1->virtualX));
            						}
            						else {
HXDLIN(  78)							index2 = ::Std_obj::_hx_int(( (Float)(((y5 * thisImage1->width) + x5)) ));
            						}
HXDLIN(  78)						int c2 = ::iterMagic::Iimg_obj::get(this18,index2);
HXDLIN(  78)						int color1;
HXDLIN(  78)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)							color1 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            						}
            						else {
HXDLIN(  78)							color1 = c2;
            						}
HXDLIN(  78)						int c3 = color1;
HXDLIN(  78)						bool _hx_tmp10;
HXDLIN(  78)						if ((((c3 >> 24) & 255) < 254)) {
HXDLIN(  78)							_hx_tmp10 = nextImage1->transparent;
            						}
            						else {
HXDLIN(  78)							_hx_tmp10 = false;
            						}
HXDLIN(  78)						if (_hx_tmp10) {
HXDLIN(  78)							int location1;
HXDLIN(  78)							if (nextImage1->useVirtualPos) {
HXDLIN(  78)								location1 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - nextImage1->virtualY) * ( (Float)(nextImage1->width) )) + x4) - nextImage1->virtualX));
            							}
            							else {
HXDLIN(  78)								location1 = ::Std_obj::_hx_int(( (Float)(((y4 * nextImage1->width) + x4)) ));
            							}
HXDLIN(  78)							int this19 = ::iterMagic::Iimg_obj::get(nextImage1->image,location1);
HXDLIN(  78)							int this20;
HXDLIN(  78)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)								this20 = ((((((this19 >> 24) & 255) << 24) | ((this19 & 255) << 16)) | (((this19 >> 8) & 255) << 8)) | ((this19 >> 16) & 255));
            							}
            							else {
HXDLIN(  78)								this20 = this19;
            							}
HXDLIN(  78)							Float a11;
HXDLIN(  78)							int this21 = ((this20 >> 24) & 255);
HXDLIN(  78)							if ((this21 == 0)) {
HXDLIN(  78)								a11 = ((Float)0.);
            							}
            							else {
HXDLIN(  78)								a11 = (( (Float)(this21) ) / ( (Float)(255) ));
            							}
HXDLIN(  78)							Float r11;
HXDLIN(  78)							int this22 = ((this20 >> 16) & 255);
HXDLIN(  78)							if ((this22 == 0)) {
HXDLIN(  78)								r11 = ((Float)0.);
            							}
            							else {
HXDLIN(  78)								r11 = (( (Float)(this22) ) / ( (Float)(255) ));
            							}
HXDLIN(  78)							Float g11;
HXDLIN(  78)							int this23 = ((this20 >> 8) & 255);
HXDLIN(  78)							if ((this23 == 0)) {
HXDLIN(  78)								g11 = ((Float)0.);
            							}
            							else {
HXDLIN(  78)								g11 = (( (Float)(this23) ) / ( (Float)(255) ));
            							}
HXDLIN(  78)							Float b12;
HXDLIN(  78)							int this24 = (this20 & 255);
HXDLIN(  78)							if ((this24 == 0)) {
HXDLIN(  78)								b12 = ((Float)0.);
            							}
            							else {
HXDLIN(  78)								b12 = (( (Float)(this24) ) / ( (Float)(255) ));
            							}
HXDLIN(  78)							Float a21;
HXDLIN(  78)							int this25 = ((color1 >> 24) & 255);
HXDLIN(  78)							if ((this25 == 0)) {
HXDLIN(  78)								a21 = ((Float)0.);
            							}
            							else {
HXDLIN(  78)								a21 = (( (Float)(this25) ) / ( (Float)(255) ));
            							}
HXDLIN(  78)							Float r21;
HXDLIN(  78)							int this26 = ((color1 >> 16) & 255);
HXDLIN(  78)							if ((this26 == 0)) {
HXDLIN(  78)								r21 = ((Float)0.);
            							}
            							else {
HXDLIN(  78)								r21 = (( (Float)(this26) ) / ( (Float)(255) ));
            							}
HXDLIN(  78)							Float g21;
HXDLIN(  78)							int this27 = ((color1 >> 8) & 255);
HXDLIN(  78)							if ((this27 == 0)) {
HXDLIN(  78)								g21 = ((Float)0.);
            							}
            							else {
HXDLIN(  78)								g21 = (( (Float)(this27) ) / ( (Float)(255) ));
            							}
HXDLIN(  78)							Float b22;
HXDLIN(  78)							int this28 = (color1 & 255);
HXDLIN(  78)							if ((this28 == 0)) {
HXDLIN(  78)								b22 = ((Float)0.);
            							}
            							else {
HXDLIN(  78)								b22 = (( (Float)(this28) ) / ( (Float)(255) ));
            							}
HXDLIN(  78)							Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  78)							int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  78)							int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  78)							int b7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  78)							int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  78)							int blended1 = ((((a6 << 24) | (r5 << 16)) | (g3 << 8)) | b7);
HXDLIN(  78)							{
HXDLIN(  78)								int _hx_tmp11;
HXDLIN(  78)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)									_hx_tmp11 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            								}
            								else {
HXDLIN(  78)									_hx_tmp11 = blended1;
            								}
HXDLIN(  78)								::iterMagic::Iimg_obj::set(nextImage1->image,location1,_hx_tmp11);
            							}
            						}
            						else {
HXDLIN(  78)							::Dynamic this29 = nextImage1->image;
HXDLIN(  78)							int index3;
HXDLIN(  78)							if (nextImage1->useVirtualPos) {
HXDLIN(  78)								index3 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - nextImage1->virtualY) * ( (Float)(nextImage1->width) )) + x4) - nextImage1->virtualX));
            							}
            							else {
HXDLIN(  78)								index3 = ::Std_obj::_hx_int(( (Float)(((y4 * nextImage1->width) + x4)) ));
            							}
HXDLIN(  78)							int _hx_tmp12;
HXDLIN(  78)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)								_hx_tmp12 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            							}
            							else {
HXDLIN(  78)								_hx_tmp12 = c3;
            							}
HXDLIN(  78)							::iterMagic::Iimg_obj::set(this29,index3,_hx_tmp12);
            						}
            					}
            				}
HXDLIN(  78)				bool _hx_tmp13;
HXDLIN(  78)				if (::hx::IsNotNull( thisImage1->mask )) {
HXDLIN(  78)					_hx_tmp13 = includeMask;
            				}
            				else {
HXDLIN(  78)					_hx_tmp13 = false;
            				}
HXDLIN(  78)				if (_hx_tmp13) {
HXDLIN(  78)					 ::pi_xy::ImageStruct v3 = ::pi_xy::transformation::_SpinImage::SpinImage_Fields__obj::spinAntiClock90(thisImage1->mask,( (Float)(0) ),( (Float)(0) ),w2,h1,thisImage1->mask->transparent,includeMask);
HXDLIN(  78)					nextImage1->useMask = true;
HXDLIN(  78)					nextImage1->mask = v3;
            				}
HXDLIN(  78)				return nextImage1;
            			}
            			else {
HXDLIN(  78)				bool _hx_tmp14;
HXDLIN(  78)				if ((angle1 != 180)) {
HXDLIN(  78)					_hx_tmp14 = (angle1 == -180);
            				}
            				else {
HXDLIN(  78)					_hx_tmp14 = true;
            				}
HXDLIN(  78)				if (_hx_tmp14) {
HXDLIN(  78)					Float w4 = ( (Float)(this1->width) );
HXDLIN(  78)					Float h2 = ( (Float)(this1->height) );
HXDLIN(  78)					 ::pi_xy::ImageStruct thisImage2 = this1;
HXDLIN(  78)					 ::Dynamic r6 =  ::Dynamic(::hx::Anon_obj::Create(4)
            						->setFixed(0,HX_("h",68,00,00,00),h2)
            						->setFixed(1,HX_("w",77,00,00,00),w4)
            						->setFixed(2,HX_("x",78,00,00,00),0)
            						->setFixed(3,HX_("y",79,00,00,00),0));
HXDLIN(  78)					int xmax2 = ::Std_obj::_hx_int(( (Float)(((r6->__Field(HX_("x",78,00,00,00),::hx::paccDynamic) + r6->__Field(HX_("w",77,00,00,00),::hx::paccDynamic)) + 1)) ));
HXDLIN(  78)					int ymax2 = ::Std_obj::_hx_int(( (Float)(((r6->__Field(HX_("y",79,00,00,00),::hx::paccDynamic) + r6->__Field(HX_("h",68,00,00,00),::hx::paccDynamic)) + 1)) ));
HXDLIN(  78)					int ii_min4 = ::Std_obj::_hx_int(( (Float)(r6->__Field(HX_("x",78,00,00,00),::hx::paccDynamic)) ));
HXDLIN(  78)					int ii_max4 = xmax2;
HXDLIN(  78)					int xRange__start2 = ii_min4;
HXDLIN(  78)					int xRange__max2 = ii_max4;
HXDLIN(  78)					int ii_min5 = ::Std_obj::_hx_int(( (Float)(r6->__Field(HX_("y",79,00,00,00),::hx::paccDynamic)) ));
HXDLIN(  78)					int ii_max5 = ymax2;
HXDLIN(  78)					int yRange__start2 = ii_min5;
HXDLIN(  78)					int yRange__max2 = ii_max5;
HXDLIN(  78)					int range_x2 = xRange__start2;
HXDLIN(  78)					int range_y2 = (yRange__start2 - 1);
HXDLIN(  78)					int range_xReset2 = range_x2;
HXDLIN(  78)					int range_yReset2 = range_y2;
HXDLIN(  78)					int range_xMax2 = (xRange__max2 - 2);
HXDLIN(  78)					int range_yMax2 = (yRange__max2 - 2);
HXDLIN(  78)					int _this_min2 = 0;
HXDLIN(  78)					int _this_max2 = ::Std_obj::_hx_int(( (Float)(((xRange__max2 - xRange__start2) * (yRange__max2 - yRange__start2))) ));
HXDLIN(  78)					int width2 = ::Std_obj::_hx_int(w4);
HXDLIN(  78)					int height2 = ::Std_obj::_hx_int(h2);
HXDLIN(  78)					 ::Dynamic imageType2 = null();
HXDLIN(  78)					 ::pi_xy::ImageStruct this30 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  78)					if (::hx::IsNull( imageType2 )) {
HXLINE(  54)						imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE(  78)					::Dynamic _hx_tmp15;
HXDLIN(  78)					switch((int)(( (int)(imageType2) ))){
            						case (int)0: {
HXDLIN(  78)							 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  78)							 ::iterMagic::BytesImg b8 = byt2;
HXDLIN(  78)							{
HXDLIN(  78)								b8->width = width2;
HXDLIN(  78)								b8->height = height2;
HXDLIN(  78)								b8->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  78)								b8->data = ::haxe::io::Bytes_obj::alloc((b8->length * 4));
HXDLIN(  78)								{
HXDLIN(  78)									int len4 = b8->length;
HXDLIN(  78)									int w5 = 0;
HXDLIN(  78)									{
HXDLIN(  78)										int _g32 = 0;
HXDLIN(  78)										int _g33 = b8->height;
HXDLIN(  78)										while((_g32 < _g33)){
HXDLIN(  78)											_g32 = (_g32 + 1);
HXDLIN(  78)											int y6 = (_g32 - 1);
HXDLIN(  78)											{
HXDLIN(  78)												int _g34 = 0;
HXDLIN(  78)												int _g35 = b8->width;
HXDLIN(  78)												while((_g34 < _g35)){
HXDLIN(  78)													_g34 = (_g34 + 1);
HXDLIN(  78)													int x6 = (_g34 - 1);
HXDLIN(  78)													{
HXDLIN(  78)														w5 = (w5 + 1);
HXDLIN(  78)														b8->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  78)													{
HXDLIN(  78)														w5 = (w5 + 1);
HXDLIN(  78)														b8->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  78)													{
HXDLIN(  78)														w5 = (w5 + 1);
HXDLIN(  78)														b8->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  78)													{
HXDLIN(  78)														w5 = (w5 + 1);
HXDLIN(  78)														b8->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  78)							_hx_tmp15 = b8;
            						}
            						break;
            						case (int)1: {
HXDLIN(  78)							 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)							 ::iterMagic::ArrIntImg a7 = arrI2;
HXDLIN(  78)							{
HXDLIN(  78)								a7->width = width2;
HXDLIN(  78)								a7->height = height2;
HXDLIN(  78)								a7->data = ::Array_obj< int >::__new(0);
HXDLIN(  78)								a7->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  78)								{
HXDLIN(  78)									int _g36 = 0;
HXDLIN(  78)									int _g37 = a7->length;
HXDLIN(  78)									while((_g36 < _g37)){
HXDLIN(  78)										_g36 = (_g36 + 1);
HXDLIN(  78)										int i16 = (_g36 - 1);
HXDLIN(  78)										a7->data[i16] = 0;
            									}
            								}
            							}
HXDLIN(  78)							_hx_tmp15 = a7;
            						}
            						break;
            						case (int)2: {
HXDLIN(  78)							 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  78)							 ::iterMagic::U32ArrImg b9 = u32a2;
HXDLIN(  78)							{
HXDLIN(  78)								b9->width = width2;
HXDLIN(  78)								b9->height = height2;
HXDLIN(  78)								b9->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  78)								int size2 = (b9->length * 4);
HXDLIN(  78)								b9->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN(  78)								{
HXDLIN(  78)									int _g38 = 0;
HXDLIN(  78)									int _g39 = b9->length;
HXDLIN(  78)									while((_g38 < _g39)){
HXDLIN(  78)										_g38 = (_g38 + 1);
HXDLIN(  78)										int i17 = (_g38 - 1);
HXDLIN(  78)										{
HXDLIN(  78)											 ::haxe::io::ArrayBufferViewImpl this31 = b9->data;
HXDLIN(  78)											bool _hx_tmp16;
HXDLIN(  78)											if ((i17 >= 0)) {
HXDLIN(  78)												_hx_tmp16 = (i17 < (this31->byteLength >> 2));
            											}
            											else {
HXDLIN(  78)												_hx_tmp16 = false;
            											}
HXDLIN(  78)											if (_hx_tmp16) {
HXDLIN(  78)												 ::haxe::io::Bytes _this2 = this31->bytes;
HXDLIN(  78)												int pos2 = ((i17 << 2) + this31->byteOffset);
HXDLIN(  78)												_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN(  78)												_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN(  78)												_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN(  78)												_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN(  78)							_hx_tmp15 = b9;
            						}
            						break;
            						case (int)3: {
HXDLIN(  78)							 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)							 ::iterMagic::VecIntImg v4 = vec2;
HXDLIN(  78)							{
HXDLIN(  78)								v4->width = width2;
HXDLIN(  78)								v4->height = height2;
HXDLIN(  78)								v4->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  78)								v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN(  78)								{
HXDLIN(  78)									int _g40 = 0;
HXDLIN(  78)									int _g41 = v4->length;
HXDLIN(  78)									while((_g40 < _g41)){
HXDLIN(  78)										_g40 = (_g40 + 1);
HXDLIN(  78)										int i18 = (_g40 - 1);
HXDLIN(  78)										v4->data->__unsafe_set(i18,0);
            									}
            								}
            							}
HXDLIN(  78)							_hx_tmp15 = v4;
            						}
            						break;
            						case (int)4: {
HXDLIN(  78)							 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)							 ::iterMagic::StackIntImg b10 = sInt2;
HXDLIN(  78)							{
HXDLIN(  78)								b10->width = width2;
HXDLIN(  78)								b10->height = height2;
HXDLIN(  78)								b10->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  78)								b10->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  78)								{
HXDLIN(  78)									int len5 = b10->length;
HXDLIN(  78)									 ::haxe::ds::GenericStack_Int d2 = b10->data;
HXDLIN(  78)									if (::hx::IsNull( d2->head )) {
HXDLIN(  78)										int _g42 = 0;
HXDLIN(  78)										int _g43 = len5;
HXDLIN(  78)										while((_g42 < _g43)){
HXDLIN(  78)											_g42 = (_g42 + 1);
HXDLIN(  78)											int i19 = (_g42 - 1);
HXDLIN(  78)											d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            										}
            									}
            									else {
HXDLIN(  78)										int _g44 = 0;
HXDLIN(  78)										int _g45 = len5;
HXDLIN(  78)										while((_g44 < _g45)){
HXDLIN(  78)											_g44 = (_g44 + 1);
HXDLIN(  78)											int i20 = (_g44 - 1);
HXDLIN(  78)											{
HXDLIN(  78)												 ::haxe::ds::GenericCell_Int l2 = b10->data->head;
HXDLIN(  78)												 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN(  78)												{
HXDLIN(  78)													int _g46 = 0;
HXDLIN(  78)													int _g47 = i20;
HXDLIN(  78)													while((_g46 < _g47)){
HXDLIN(  78)														_g46 = (_g46 + 1);
HXDLIN(  78)														int i21 = (_g46 - 1);
HXLINE( 345)														prev2 = l2;
HXLINE( 346)														l2 = l2->next;
            													}
            												}
HXLINE(  78)												if (::hx::IsNull( prev2 )) {
HXDLIN(  78)													b10->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  78)													l2 = null();
            												}
            												else {
HXDLIN(  78)													prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  78)													l2 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  78)							_hx_tmp15 = b10;
            						}
            						break;
            					}
HXDLIN(  78)					this30->image = _hx_tmp15;
HXDLIN(  78)					this30->width = width2;
HXDLIN(  78)					this30->height = height2;
HXDLIN(  78)					this30->imageType = ( (int)(imageType2) );
HXDLIN(  78)					 ::pi_xy::ImageStruct nextImage2 = this30;
HXDLIN(  78)					nextImage2->transparent = transparent;
HXDLIN(  78)					while((_this_min2 < _this_max2)){
HXDLIN(  78)						_this_min2 = (_this_min2 + 1);
HXDLIN(  78)						int i22 = (_this_min2 - 1);
HXDLIN(  78)						if ((range_y2 > range_yMax2)) {
HXDLIN(  78)							range_y2 = range_yReset2;
HXDLIN(  78)							range_x2 = (range_x2 + 1);
            						}
HXDLIN(  78)						range_y2 = (range_y2 + 1);
HXDLIN(  78)						int i23 = i22;
HXDLIN(  78)						{
HXDLIN(  78)							int x7 = (range_xMax2 - range_x2);
HXDLIN(  78)							int y7 = (range_yMax2 - range_y2);
HXDLIN(  78)							int x8 = range_x2;
HXDLIN(  78)							int y8 = range_y2;
HXDLIN(  78)							::Dynamic this32 = thisImage2->image;
HXDLIN(  78)							int index4;
HXDLIN(  78)							if (thisImage2->useVirtualPos) {
HXDLIN(  78)								index4 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - thisImage2->virtualY) * ( (Float)(thisImage2->width) )) + x8) - thisImage2->virtualX));
            							}
            							else {
HXDLIN(  78)								index4 = ::Std_obj::_hx_int(( (Float)(((y8 * thisImage2->width) + x8)) ));
            							}
HXDLIN(  78)							int c4 = ::iterMagic::Iimg_obj::get(this32,index4);
HXDLIN(  78)							int color2;
HXDLIN(  78)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)								color2 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            							}
            							else {
HXDLIN(  78)								color2 = c4;
            							}
HXDLIN(  78)							int c5 = color2;
HXDLIN(  78)							bool _hx_tmp17;
HXDLIN(  78)							if ((((c5 >> 24) & 255) < 254)) {
HXDLIN(  78)								_hx_tmp17 = nextImage2->transparent;
            							}
            							else {
HXDLIN(  78)								_hx_tmp17 = false;
            							}
HXDLIN(  78)							if (_hx_tmp17) {
HXDLIN(  78)								int location2;
HXDLIN(  78)								if (nextImage2->useVirtualPos) {
HXDLIN(  78)									location2 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - nextImage2->virtualY) * ( (Float)(nextImage2->width) )) + x7) - nextImage2->virtualX));
            								}
            								else {
HXDLIN(  78)									location2 = ::Std_obj::_hx_int(( (Float)(((y7 * nextImage2->width) + x7)) ));
            								}
HXDLIN(  78)								int this33 = ::iterMagic::Iimg_obj::get(nextImage2->image,location2);
HXDLIN(  78)								int this34;
HXDLIN(  78)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)									this34 = ((((((this33 >> 24) & 255) << 24) | ((this33 & 255) << 16)) | (((this33 >> 8) & 255) << 8)) | ((this33 >> 16) & 255));
            								}
            								else {
HXDLIN(  78)									this34 = this33;
            								}
HXDLIN(  78)								Float a12;
HXDLIN(  78)								int this35 = ((this34 >> 24) & 255);
HXDLIN(  78)								if ((this35 == 0)) {
HXDLIN(  78)									a12 = ((Float)0.);
            								}
            								else {
HXDLIN(  78)									a12 = (( (Float)(this35) ) / ( (Float)(255) ));
            								}
HXDLIN(  78)								Float r12;
HXDLIN(  78)								int this36 = ((this34 >> 16) & 255);
HXDLIN(  78)								if ((this36 == 0)) {
HXDLIN(  78)									r12 = ((Float)0.);
            								}
            								else {
HXDLIN(  78)									r12 = (( (Float)(this36) ) / ( (Float)(255) ));
            								}
HXDLIN(  78)								Float g12;
HXDLIN(  78)								int this37 = ((this34 >> 8) & 255);
HXDLIN(  78)								if ((this37 == 0)) {
HXDLIN(  78)									g12 = ((Float)0.);
            								}
            								else {
HXDLIN(  78)									g12 = (( (Float)(this37) ) / ( (Float)(255) ));
            								}
HXDLIN(  78)								Float b13;
HXDLIN(  78)								int this38 = (this34 & 255);
HXDLIN(  78)								if ((this38 == 0)) {
HXDLIN(  78)									b13 = ((Float)0.);
            								}
            								else {
HXDLIN(  78)									b13 = (( (Float)(this38) ) / ( (Float)(255) ));
            								}
HXDLIN(  78)								Float a22;
HXDLIN(  78)								int this39 = ((color2 >> 24) & 255);
HXDLIN(  78)								if ((this39 == 0)) {
HXDLIN(  78)									a22 = ((Float)0.);
            								}
            								else {
HXDLIN(  78)									a22 = (( (Float)(this39) ) / ( (Float)(255) ));
            								}
HXDLIN(  78)								Float r22;
HXDLIN(  78)								int this40 = ((color2 >> 16) & 255);
HXDLIN(  78)								if ((this40 == 0)) {
HXDLIN(  78)									r22 = ((Float)0.);
            								}
            								else {
HXDLIN(  78)									r22 = (( (Float)(this40) ) / ( (Float)(255) ));
            								}
HXDLIN(  78)								Float g22;
HXDLIN(  78)								int this41 = ((color2 >> 8) & 255);
HXDLIN(  78)								if ((this41 == 0)) {
HXDLIN(  78)									g22 = ((Float)0.);
            								}
            								else {
HXDLIN(  78)									g22 = (( (Float)(this41) ) / ( (Float)(255) ));
            								}
HXDLIN(  78)								Float b23;
HXDLIN(  78)								int this42 = (color2 & 255);
HXDLIN(  78)								if ((this42 == 0)) {
HXDLIN(  78)									b23 = ((Float)0.);
            								}
            								else {
HXDLIN(  78)									b23 = (( (Float)(this42) ) / ( (Float)(255) ));
            								}
HXDLIN(  78)								Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  78)								int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  78)								int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  78)								int b14 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  78)								int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  78)								int blended2 = ((((a8 << 24) | (r7 << 16)) | (g4 << 8)) | b14);
HXDLIN(  78)								{
HXDLIN(  78)									int _hx_tmp18;
HXDLIN(  78)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)										_hx_tmp18 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            									}
            									else {
HXDLIN(  78)										_hx_tmp18 = blended2;
            									}
HXDLIN(  78)									::iterMagic::Iimg_obj::set(nextImage2->image,location2,_hx_tmp18);
            								}
            							}
            							else {
HXDLIN(  78)								::Dynamic this43 = nextImage2->image;
HXDLIN(  78)								int index5;
HXDLIN(  78)								if (nextImage2->useVirtualPos) {
HXDLIN(  78)									index5 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - nextImage2->virtualY) * ( (Float)(nextImage2->width) )) + x7) - nextImage2->virtualX));
            								}
            								else {
HXDLIN(  78)									index5 = ::Std_obj::_hx_int(( (Float)(((y7 * nextImage2->width) + x7)) ));
            								}
HXDLIN(  78)								int _hx_tmp19;
HXDLIN(  78)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)									_hx_tmp19 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            								}
            								else {
HXDLIN(  78)									_hx_tmp19 = c5;
            								}
HXDLIN(  78)								::iterMagic::Iimg_obj::set(this43,index5,_hx_tmp19);
            							}
            						}
            					}
HXDLIN(  78)					bool _hx_tmp20;
HXDLIN(  78)					if (::hx::IsNotNull( thisImage2->mask )) {
HXDLIN(  78)						_hx_tmp20 = includeMask;
            					}
            					else {
HXDLIN(  78)						_hx_tmp20 = false;
            					}
HXDLIN(  78)					if (_hx_tmp20) {
HXDLIN(  78)						 ::pi_xy::ImageStruct v5 = ::pi_xy::transformation::_SpinImage::SpinImage_Fields__obj::spin180(thisImage2->mask,( (Float)(0) ),( (Float)(0) ),w4,h2,thisImage2->mask->transparent,includeMask);
HXDLIN(  78)						nextImage2->useMask = true;
HXDLIN(  78)						nextImage2->mask = v5;
            					}
HXDLIN(  78)					return nextImage2;
            				}
            				else {
HXDLIN(  78)					 ::pi_xy::ImageStruct this44 = this1;
HXDLIN(  78)					Float theta = ((angle1 * ::Math_obj::PI) / ( (Float)(180) ));
HXDLIN(  78)					Float centreX1 = centreX;
HXDLIN(  78)					Float centreY1 = centreY;
HXDLIN(  78)					Float ax = ((Float)0.);
HXDLIN(  78)					Float ay = ((Float)0.);
HXDLIN(  78)					if ((centreX1 != ((Float)0.))) {
HXLINE( 173)						centreX1 = ((( (Float)(this44->width) ) / ( (Float)(2) )) + centreX1);
HXLINE(  78)						ax = (ax - centreX1);
            					}
HXDLIN(  78)					if ((centreY1 != ((Float)0.))) {
HXLINE( 177)						centreY1 = ((( (Float)(this44->height) ) / ( (Float)(2) )) + centreY1);
HXLINE(  78)						ay = (ay - centreY1);
            					}
HXDLIN(  78)					Float bx = (ax + this44->width);
HXDLIN(  78)					Float by = ay;
HXDLIN(  78)					Float cx = bx;
HXDLIN(  78)					Float cy = (ay + this44->height);
HXDLIN(  78)					Float dx = ax;
HXDLIN(  78)					Float dy = cy;
HXDLIN(  78)					Float sin = ::Math_obj::sin(theta);
HXDLIN(  78)					Float cos = ::Math_obj::cos(theta);
HXDLIN(  78)					Float temp = ax;
HXLINE( 189)					ax = ((temp * cos) - (ay * sin));
HXLINE( 190)					ay = ((ay * cos) + (temp * sin));
HXLINE(  78)					Float temp1 = bx;
HXLINE( 192)					bx = ((temp1 * cos) - (by * sin));
HXLINE( 193)					by = ((by * cos) + (temp1 * sin));
HXLINE(  78)					Float temp2 = cx;
HXLINE( 195)					cx = ((temp2 * cos) - (cy * sin));
HXLINE( 196)					cy = ((cy * cos) + (temp2 * sin));
HXLINE(  78)					Float temp3 = dx;
HXLINE( 198)					dx = ((temp3 * cos) - (dy * sin));
HXLINE( 199)					dy = ((dy * cos) + (temp3 * sin));
HXLINE(  78)					if ((centreX1 != ((Float)0.))) {
HXDLIN(  78)						ax = (ax + centreX1);
HXDLIN(  78)						bx = (bx + centreX1);
HXDLIN(  78)						cx = (cx + centreX1);
HXDLIN(  78)						dx = (dx + centreX1);
            					}
HXDLIN(  78)					if ((centreY1 != ((Float)0.))) {
HXDLIN(  78)						ay = (ay + centreY1);
HXDLIN(  78)						by = (by + centreY1);
HXDLIN(  78)						cy = (cy + centreY1);
HXDLIN(  78)						dy = (dy + centreY1);
            					}
HXDLIN(  78)					int min = ::Math_obj::floor(ax);
HXDLIN(  78)					int max = ::Math_obj::ceil(ax);
HXDLIN(  78)					if ((bx < min)) {
HXLINE(  31)						min = ::Math_obj::floor(bx);
            					}
            					else {
HXDLIN(  78)						if ((bx > max)) {
HXLINE(  33)							max = ::Math_obj::ceil(bx);
            						}
            					}
HXLINE(  78)					if ((cx < min)) {
HXLINE(  36)						min = ::Math_obj::floor(cx);
            					}
            					else {
HXDLIN(  78)						if ((cx > max)) {
HXLINE(  38)							max = ::Math_obj::ceil(cx);
            						}
            					}
HXLINE(  78)					if ((dx < min)) {
HXLINE(  41)						min = ::Math_obj::floor(dx);
            					}
            					else {
HXDLIN(  78)						if ((dx > max)) {
HXLINE(  43)							max = ::Math_obj::ceil(dx);
            						}
            					}
HXLINE(  78)					int ii_min6 = min;
HXDLIN(  78)					int ii_max6 = max;
HXDLIN(  78)					 ::pi_xy::iter::IntIterStart boundX =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
HXDLIN(  78)					int min1 = ::Math_obj::floor(ay);
HXDLIN(  78)					int max1 = ::Math_obj::ceil(ay);
HXDLIN(  78)					if ((by < min1)) {
HXLINE(  31)						min1 = ::Math_obj::floor(by);
            					}
            					else {
HXDLIN(  78)						if ((by > max1)) {
HXLINE(  33)							max1 = ::Math_obj::ceil(by);
            						}
            					}
HXLINE(  78)					if ((cy < min1)) {
HXLINE(  36)						min1 = ::Math_obj::floor(cy);
            					}
            					else {
HXDLIN(  78)						if ((cy > max1)) {
HXLINE(  38)							max1 = ::Math_obj::ceil(cy);
            						}
            					}
HXLINE(  78)					if ((dy < min1)) {
HXLINE(  41)						min1 = ::Math_obj::floor(dy);
            					}
            					else {
HXDLIN(  78)						if ((dy > max1)) {
HXLINE(  43)							max1 = ::Math_obj::ceil(dy);
            						}
            					}
HXLINE(  78)					int ii_min7 = min1;
HXDLIN(  78)					int ii_max7 = max1;
HXDLIN(  78)					 ::pi_xy::iter::IntIterStart boundY =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
HXDLIN(  78)					int minX = boundX->start;
HXDLIN(  78)					int wid = ((boundX->max - boundX->start) + 1);
HXDLIN(  78)					int minY = boundY->start;
HXDLIN(  78)					int hi = ((boundY->max - boundY->start) + 1);
HXDLIN(  78)					 ::Dynamic imageType3 = null();
HXDLIN(  78)					 ::pi_xy::ImageStruct this45 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  78)					if (::hx::IsNull( imageType3 )) {
HXLINE(  54)						imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE(  78)					::Dynamic _hx_tmp21;
HXDLIN(  78)					switch((int)(( (int)(imageType3) ))){
            						case (int)0: {
HXDLIN(  78)							 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  78)							 ::iterMagic::BytesImg b15 = byt3;
HXDLIN(  78)							{
HXDLIN(  78)								b15->width = wid;
HXDLIN(  78)								b15->height = hi;
HXDLIN(  78)								b15->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  78)								b15->data = ::haxe::io::Bytes_obj::alloc((b15->length * 4));
HXDLIN(  78)								{
HXDLIN(  78)									int len6 = b15->length;
HXDLIN(  78)									int w6 = 0;
HXDLIN(  78)									{
HXDLIN(  78)										int _g48 = 0;
HXDLIN(  78)										int _g49 = b15->height;
HXDLIN(  78)										while((_g48 < _g49)){
HXDLIN(  78)											_g48 = (_g48 + 1);
HXDLIN(  78)											int y9 = (_g48 - 1);
HXDLIN(  78)											{
HXDLIN(  78)												int _g50 = 0;
HXDLIN(  78)												int _g51 = b15->width;
HXDLIN(  78)												while((_g50 < _g51)){
HXDLIN(  78)													_g50 = (_g50 + 1);
HXDLIN(  78)													int x9 = (_g50 - 1);
HXDLIN(  78)													{
HXDLIN(  78)														w6 = (w6 + 1);
HXDLIN(  78)														b15->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  78)													{
HXDLIN(  78)														w6 = (w6 + 1);
HXDLIN(  78)														b15->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  78)													{
HXDLIN(  78)														w6 = (w6 + 1);
HXDLIN(  78)														b15->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  78)													{
HXDLIN(  78)														w6 = (w6 + 1);
HXDLIN(  78)														b15->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  78)							_hx_tmp21 = b15;
            						}
            						break;
            						case (int)1: {
HXDLIN(  78)							 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)							 ::iterMagic::ArrIntImg a9 = arrI3;
HXDLIN(  78)							{
HXDLIN(  78)								a9->width = wid;
HXDLIN(  78)								a9->height = hi;
HXDLIN(  78)								a9->data = ::Array_obj< int >::__new(0);
HXDLIN(  78)								a9->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  78)								{
HXDLIN(  78)									int _g52 = 0;
HXDLIN(  78)									int _g53 = a9->length;
HXDLIN(  78)									while((_g52 < _g53)){
HXDLIN(  78)										_g52 = (_g52 + 1);
HXDLIN(  78)										int i24 = (_g52 - 1);
HXDLIN(  78)										a9->data[i24] = 0;
            									}
            								}
            							}
HXDLIN(  78)							_hx_tmp21 = a9;
            						}
            						break;
            						case (int)2: {
HXDLIN(  78)							 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  78)							 ::iterMagic::U32ArrImg b16 = u32a3;
HXDLIN(  78)							{
HXDLIN(  78)								b16->width = wid;
HXDLIN(  78)								b16->height = hi;
HXDLIN(  78)								b16->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  78)								int size3 = (b16->length * 4);
HXDLIN(  78)								b16->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN(  78)								{
HXDLIN(  78)									int _g54 = 0;
HXDLIN(  78)									int _g55 = b16->length;
HXDLIN(  78)									while((_g54 < _g55)){
HXDLIN(  78)										_g54 = (_g54 + 1);
HXDLIN(  78)										int i25 = (_g54 - 1);
HXDLIN(  78)										{
HXDLIN(  78)											 ::haxe::io::ArrayBufferViewImpl this46 = b16->data;
HXDLIN(  78)											bool _hx_tmp22;
HXDLIN(  78)											if ((i25 >= 0)) {
HXDLIN(  78)												_hx_tmp22 = (i25 < (this46->byteLength >> 2));
            											}
            											else {
HXDLIN(  78)												_hx_tmp22 = false;
            											}
HXDLIN(  78)											if (_hx_tmp22) {
HXDLIN(  78)												 ::haxe::io::Bytes _this3 = this46->bytes;
HXDLIN(  78)												int pos3 = ((i25 << 2) + this46->byteOffset);
HXDLIN(  78)												_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN(  78)												_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN(  78)												_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN(  78)												_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN(  78)							_hx_tmp21 = b16;
            						}
            						break;
            						case (int)3: {
HXDLIN(  78)							 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)							 ::iterMagic::VecIntImg v6 = vec3;
HXDLIN(  78)							{
HXDLIN(  78)								v6->width = wid;
HXDLIN(  78)								v6->height = hi;
HXDLIN(  78)								v6->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  78)								v6->data = ::Array_obj< int >::__new(v6->length);
HXDLIN(  78)								{
HXDLIN(  78)									int _g56 = 0;
HXDLIN(  78)									int _g57 = v6->length;
HXDLIN(  78)									while((_g56 < _g57)){
HXDLIN(  78)										_g56 = (_g56 + 1);
HXDLIN(  78)										int i26 = (_g56 - 1);
HXDLIN(  78)										v6->data->__unsafe_set(i26,0);
            									}
            								}
            							}
HXDLIN(  78)							_hx_tmp21 = v6;
            						}
            						break;
            						case (int)4: {
HXDLIN(  78)							 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)							 ::iterMagic::StackIntImg b17 = sInt3;
HXDLIN(  78)							{
HXDLIN(  78)								b17->width = wid;
HXDLIN(  78)								b17->height = hi;
HXDLIN(  78)								b17->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  78)								b17->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  78)								{
HXDLIN(  78)									int len7 = b17->length;
HXDLIN(  78)									 ::haxe::ds::GenericStack_Int d3 = b17->data;
HXDLIN(  78)									if (::hx::IsNull( d3->head )) {
HXDLIN(  78)										int _g58 = 0;
HXDLIN(  78)										int _g59 = len7;
HXDLIN(  78)										while((_g58 < _g59)){
HXDLIN(  78)											_g58 = (_g58 + 1);
HXDLIN(  78)											int i27 = (_g58 - 1);
HXDLIN(  78)											d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            										}
            									}
            									else {
HXDLIN(  78)										int _g60 = 0;
HXDLIN(  78)										int _g61 = len7;
HXDLIN(  78)										while((_g60 < _g61)){
HXDLIN(  78)											_g60 = (_g60 + 1);
HXDLIN(  78)											int i28 = (_g60 - 1);
HXDLIN(  78)											{
HXDLIN(  78)												 ::haxe::ds::GenericCell_Int l3 = b17->data->head;
HXDLIN(  78)												 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN(  78)												{
HXDLIN(  78)													int _g62 = 0;
HXDLIN(  78)													int _g63 = i28;
HXDLIN(  78)													while((_g62 < _g63)){
HXDLIN(  78)														_g62 = (_g62 + 1);
HXDLIN(  78)														int i29 = (_g62 - 1);
HXLINE( 345)														prev3 = l3;
HXLINE( 346)														l3 = l3->next;
            													}
            												}
HXLINE(  78)												if (::hx::IsNull( prev3 )) {
HXDLIN(  78)													b17->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  78)													l3 = null();
            												}
            												else {
HXDLIN(  78)													prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  78)													l3 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  78)							_hx_tmp21 = b17;
            						}
            						break;
            					}
HXDLIN(  78)					this45->image = _hx_tmp21;
HXDLIN(  78)					this45->width = wid;
HXDLIN(  78)					this45->height = hi;
HXDLIN(  78)					this45->imageType = ( (int)(imageType3) );
HXDLIN(  78)					 ::pi_xy::ImageStruct nextImage3 = this45;
HXDLIN(  78)					nextImage3->transparent = true;
HXDLIN(  78)					if ((minX < ((Float)0.))) {
HXDLIN(  78)						ax = (ax - ( (Float)(minX) ));
HXDLIN(  78)						bx = (bx - ( (Float)(minX) ));
HXDLIN(  78)						cx = (cx - ( (Float)(minX) ));
HXDLIN(  78)						dx = (dx - ( (Float)(minX) ));
            					}
HXDLIN(  78)					if ((minY < ((Float)0.))) {
HXDLIN(  78)						ay = (ay - ( (Float)(minY) ));
HXDLIN(  78)						by = (by - ( (Float)(minY) ));
HXDLIN(  78)						cy = (cy - ( (Float)(minY) ));
HXDLIN(  78)						dy = (dy - ( (Float)(minY) ));
            					}
HXDLIN(  78)					{
HXDLIN(  78)						 ::pi_xy::ImageStruct this47 = nextImage3;
HXDLIN(  78)						Float win_x = ( (Float)(0) );
HXDLIN(  78)						Float win_y = ( (Float)(0) );
HXDLIN(  78)						Float win_width = ( (Float)(this44->width) );
HXDLIN(  78)						Float win_height = ( (Float)(this44->height) );
HXDLIN(  78)						{
HXDLIN(  78)							Float bu = ((Float)1.);
HXDLIN(  78)							Float bv = ((Float)0.);
HXDLIN(  78)							Float cu = ((Float)1.);
HXDLIN(  78)							Float cv = ((Float)1.);
HXDLIN(  78)							Float du = ((Float)0.);
HXDLIN(  78)							Float dv = ((Float)1.);
HXDLIN(  78)							Float au = ((Float)0.);
HXDLIN(  78)							Float av = ((Float)0.);
HXDLIN(  78)							Float bu1 = bu;
HXDLIN(  78)							Float bv1 = bv;
HXDLIN(  78)							bool hasUndo = false;
HXDLIN(  78)							Float temp4 = au;
HXLINE( 422)							au = bu1;
HXLINE( 423)							bu1 = temp4;
HXLINE( 424)							temp4 = av;
HXLINE( 425)							av = bv1;
HXLINE( 426)							bv1 = temp4;
HXLINE(  78)							Float bcx = (bx - dx);
HXDLIN(  78)							Float bcy = (by - dy);
HXDLIN(  78)							Float acx = (ax - dx);
HXDLIN(  78)							Float acy = (ay - dy);
HXDLIN(  78)							Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  78)							Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  78)							Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  78)							Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  78)							 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  78)							if ((ax > bx)) {
HXDLIN(  78)								if ((ax > dx)) {
HXDLIN(  78)									int min2;
HXDLIN(  78)									if ((bx > dx)) {
HXDLIN(  78)										min2 = ::Math_obj::floor(dx);
            									}
            									else {
HXDLIN(  78)										min2 = ::Math_obj::floor(bx);
            									}
HXDLIN(  78)									int ii_min8 = min2;
HXDLIN(  78)									int ii_max8 = ::Math_obj::ceil(ax);
HXDLIN(  78)									xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            								}
            								else {
HXDLIN(  78)									int ii_min9 = ::Math_obj::floor(bx);
HXDLIN(  78)									int ii_max9 = ::Math_obj::ceil(dx);
HXDLIN(  78)									xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            								}
            							}
            							else {
HXDLIN(  78)								if ((bx > dx)) {
HXDLIN(  78)									int min3;
HXDLIN(  78)									if ((ax > dx)) {
HXDLIN(  78)										min3 = ::Math_obj::floor(dx);
            									}
            									else {
HXDLIN(  78)										min3 = ::Math_obj::ceil(ax);
            									}
HXDLIN(  78)									int ii_min10 = min3;
HXDLIN(  78)									int ii_max10 = ::Math_obj::ceil(bx);
HXDLIN(  78)									xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            								}
            								else {
HXDLIN(  78)									int ii_min11 = ::Math_obj::floor(ax);
HXDLIN(  78)									int ii_max11 = ::Math_obj::ceil(dx);
HXDLIN(  78)									xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            								}
            							}
HXDLIN(  78)							 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  78)							if ((ay > by)) {
HXDLIN(  78)								if ((ay > dy)) {
HXDLIN(  78)									int min4;
HXDLIN(  78)									if ((by > dy)) {
HXDLIN(  78)										min4 = ::Math_obj::floor(dy);
            									}
            									else {
HXDLIN(  78)										min4 = ::Math_obj::floor(by);
            									}
HXDLIN(  78)									int ii_min12 = min4;
HXDLIN(  78)									int ii_max12 = ::Math_obj::ceil(ay);
HXDLIN(  78)									yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            								}
            								else {
HXDLIN(  78)									int ii_min13 = ::Math_obj::floor(by);
HXDLIN(  78)									int ii_max13 = ::Math_obj::ceil(dy);
HXDLIN(  78)									yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            								}
            							}
            							else {
HXDLIN(  78)								if ((by > dy)) {
HXDLIN(  78)									int min5;
HXDLIN(  78)									if ((ay > dy)) {
HXDLIN(  78)										min5 = ::Math_obj::floor(dy);
            									}
            									else {
HXDLIN(  78)										min5 = ::Math_obj::ceil(ay);
            									}
HXDLIN(  78)									int ii_min14 = min5;
HXDLIN(  78)									int ii_max14 = ::Math_obj::ceil(by);
HXDLIN(  78)									yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            								}
            								else {
HXDLIN(  78)									int ii_min15 = ::Math_obj::floor(ay);
HXDLIN(  78)									int ii_max15 = ::Math_obj::ceil(dy);
HXDLIN(  78)									yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            								}
            							}
HXDLIN(  78)							 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  78)							if (hasUndo) {
HXDLIN(  78)								int width3 = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  78)								int height3 = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  78)								 ::Dynamic imageType4 = null();
HXDLIN(  78)								 ::pi_xy::ImageStruct this48 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  78)								if (::hx::IsNull( imageType4 )) {
HXLINE(  54)									imageType4 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE(  78)								::Dynamic undoImage1;
HXDLIN(  78)								switch((int)(( (int)(imageType4) ))){
            									case (int)0: {
HXDLIN(  78)										 ::iterMagic::BytesImg byt4 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  78)										 ::iterMagic::BytesImg b18 = byt4;
HXDLIN(  78)										{
HXDLIN(  78)											b18->width = width3;
HXDLIN(  78)											b18->height = height3;
HXDLIN(  78)											b18->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  78)											b18->data = ::haxe::io::Bytes_obj::alloc((b18->length * 4));
HXDLIN(  78)											{
HXDLIN(  78)												int len8 = b18->length;
HXDLIN(  78)												int w7 = 0;
HXDLIN(  78)												{
HXDLIN(  78)													int _g64 = 0;
HXDLIN(  78)													int _g65 = b18->height;
HXDLIN(  78)													while((_g64 < _g65)){
HXDLIN(  78)														_g64 = (_g64 + 1);
HXDLIN(  78)														int y10 = (_g64 - 1);
HXDLIN(  78)														{
HXDLIN(  78)															int _g66 = 0;
HXDLIN(  78)															int _g67 = b18->width;
HXDLIN(  78)															while((_g66 < _g67)){
HXDLIN(  78)																_g66 = (_g66 + 1);
HXDLIN(  78)																int x10 = (_g66 - 1);
HXDLIN(  78)																{
HXDLIN(  78)																	w7 = (w7 + 1);
HXDLIN(  78)																	b18->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  78)																{
HXDLIN(  78)																	w7 = (w7 + 1);
HXDLIN(  78)																	b18->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  78)																{
HXDLIN(  78)																	w7 = (w7 + 1);
HXDLIN(  78)																	b18->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  78)																{
HXDLIN(  78)																	w7 = (w7 + 1);
HXDLIN(  78)																	b18->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  78)										undoImage1 = b18;
            									}
            									break;
            									case (int)1: {
HXDLIN(  78)										 ::iterMagic::ArrIntImg arrI4 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)										 ::iterMagic::ArrIntImg a10 = arrI4;
HXDLIN(  78)										{
HXDLIN(  78)											a10->width = width3;
HXDLIN(  78)											a10->height = height3;
HXDLIN(  78)											a10->data = ::Array_obj< int >::__new(0);
HXDLIN(  78)											a10->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  78)											{
HXDLIN(  78)												int _g68 = 0;
HXDLIN(  78)												int _g69 = a10->length;
HXDLIN(  78)												while((_g68 < _g69)){
HXDLIN(  78)													_g68 = (_g68 + 1);
HXDLIN(  78)													int i30 = (_g68 - 1);
HXDLIN(  78)													a10->data[i30] = 0;
            												}
            											}
            										}
HXDLIN(  78)										undoImage1 = a10;
            									}
            									break;
            									case (int)2: {
HXDLIN(  78)										 ::iterMagic::U32ArrImg u32a4 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  78)										 ::iterMagic::U32ArrImg b19 = u32a4;
HXDLIN(  78)										{
HXDLIN(  78)											b19->width = width3;
HXDLIN(  78)											b19->height = height3;
HXDLIN(  78)											b19->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  78)											int size4 = (b19->length * 4);
HXDLIN(  78)											b19->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size4),0,size4);
HXDLIN(  78)											{
HXDLIN(  78)												int _g70 = 0;
HXDLIN(  78)												int _g71 = b19->length;
HXDLIN(  78)												while((_g70 < _g71)){
HXDLIN(  78)													_g70 = (_g70 + 1);
HXDLIN(  78)													int i31 = (_g70 - 1);
HXDLIN(  78)													{
HXDLIN(  78)														 ::haxe::io::ArrayBufferViewImpl this49 = b19->data;
HXDLIN(  78)														bool undoImage2;
HXDLIN(  78)														if ((i31 >= 0)) {
HXDLIN(  78)															undoImage2 = (i31 < (this49->byteLength >> 2));
            														}
            														else {
HXDLIN(  78)															undoImage2 = false;
            														}
HXDLIN(  78)														if (undoImage2) {
HXDLIN(  78)															 ::haxe::io::Bytes _this4 = this49->bytes;
HXDLIN(  78)															int pos4 = ((i31 << 2) + this49->byteOffset);
HXDLIN(  78)															_this4->b[pos4] = ( (unsigned char)(0) );
HXDLIN(  78)															_this4->b[(pos4 + 1)] = ( (unsigned char)(0) );
HXDLIN(  78)															_this4->b[(pos4 + 2)] = ( (unsigned char)(0) );
HXDLIN(  78)															_this4->b[(pos4 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN(  78)										undoImage1 = b19;
            									}
            									break;
            									case (int)3: {
HXDLIN(  78)										 ::iterMagic::VecIntImg vec4 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)										 ::iterMagic::VecIntImg v7 = vec4;
HXDLIN(  78)										{
HXDLIN(  78)											v7->width = width3;
HXDLIN(  78)											v7->height = height3;
HXDLIN(  78)											v7->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  78)											v7->data = ::Array_obj< int >::__new(v7->length);
HXDLIN(  78)											{
HXDLIN(  78)												int _g72 = 0;
HXDLIN(  78)												int _g73 = v7->length;
HXDLIN(  78)												while((_g72 < _g73)){
HXDLIN(  78)													_g72 = (_g72 + 1);
HXDLIN(  78)													int i32 = (_g72 - 1);
HXDLIN(  78)													v7->data->__unsafe_set(i32,0);
            												}
            											}
            										}
HXDLIN(  78)										undoImage1 = v7;
            									}
            									break;
            									case (int)4: {
HXDLIN(  78)										 ::iterMagic::StackIntImg sInt4 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)										 ::iterMagic::StackIntImg b20 = sInt4;
HXDLIN(  78)										{
HXDLIN(  78)											b20->width = width3;
HXDLIN(  78)											b20->height = height3;
HXDLIN(  78)											b20->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  78)											b20->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  78)											{
HXDLIN(  78)												int len9 = b20->length;
HXDLIN(  78)												 ::haxe::ds::GenericStack_Int d4 = b20->data;
HXDLIN(  78)												if (::hx::IsNull( d4->head )) {
HXDLIN(  78)													int _g74 = 0;
HXDLIN(  78)													int _g75 = len9;
HXDLIN(  78)													while((_g74 < _g75)){
HXDLIN(  78)														_g74 = (_g74 + 1);
HXDLIN(  78)														int i33 = (_g74 - 1);
HXDLIN(  78)														d4->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d4->head);
            													}
            												}
            												else {
HXDLIN(  78)													int _g76 = 0;
HXDLIN(  78)													int _g77 = len9;
HXDLIN(  78)													while((_g76 < _g77)){
HXDLIN(  78)														_g76 = (_g76 + 1);
HXDLIN(  78)														int i34 = (_g76 - 1);
HXDLIN(  78)														{
HXDLIN(  78)															 ::haxe::ds::GenericCell_Int l4 = b20->data->head;
HXDLIN(  78)															 ::haxe::ds::GenericCell_Int prev4 = null();
HXDLIN(  78)															{
HXDLIN(  78)																int _g78 = 0;
HXDLIN(  78)																int _g79 = i34;
HXDLIN(  78)																while((_g78 < _g79)){
HXDLIN(  78)																	_g78 = (_g78 + 1);
HXDLIN(  78)																	int i35 = (_g78 - 1);
HXLINE( 345)																	prev4 = l4;
HXLINE( 346)																	l4 = l4->next;
            																}
            															}
HXLINE(  78)															if (::hx::IsNull( prev4 )) {
HXDLIN(  78)																b20->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN(  78)																l4 = null();
            															}
            															else {
HXDLIN(  78)																prev4->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN(  78)																l4 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  78)										undoImage1 = b20;
            									}
            									break;
            								}
HXDLIN(  78)								this48->image = undoImage1;
HXDLIN(  78)								this48->width = width3;
HXDLIN(  78)								this48->height = height3;
HXDLIN(  78)								this48->imageType = ( (int)(imageType4) );
HXDLIN(  78)								undoImage = this48;
HXDLIN(  78)								{
HXDLIN(  78)									int rectLeft = xIter3->start;
HXDLIN(  78)									int rectTop = yIter3->start;
HXDLIN(  78)									int rectRight = xIter3->max;
HXDLIN(  78)									bool forceClear = false;
HXDLIN(  78)									{
HXDLIN(  78)										int _g80 = rectTop;
HXDLIN(  78)										int _g81 = yIter3->max;
HXDLIN(  78)										while((_g80 < _g81)){
HXDLIN(  78)											_g80 = (_g80 + 1);
HXDLIN(  78)											int dy1 = (_g80 - 1);
HXDLIN(  78)											{
HXDLIN(  78)												int _g82 = rectLeft;
HXDLIN(  78)												int _g83 = rectRight;
HXDLIN(  78)												while((_g82 < _g83)){
HXDLIN(  78)													_g82 = (_g82 + 1);
HXDLIN(  78)													int dx1 = (_g82 - 1);
HXDLIN(  78)													::Dynamic this50 = this47->image;
HXDLIN(  78)													int index6;
HXDLIN(  78)													if (this47->useVirtualPos) {
HXDLIN(  78)														index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this47->virtualY) * ( (Float)(this47->width) )) + dx1) - this47->virtualX));
            													}
            													else {
HXDLIN(  78)														index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this47->width) + dx1)) ));
            													}
HXDLIN(  78)													int c6 = ::iterMagic::Iimg_obj::get(this50,index6);
HXDLIN(  78)													int col;
HXDLIN(  78)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)														col = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            													}
            													else {
HXDLIN(  78)														col = c6;
            													}
HXDLIN(  78)													bool _hx_tmp23;
HXDLIN(  78)													if (this47->useMask) {
HXDLIN(  78)														_hx_tmp23 = ::hx::IsNotNull( this47->mask );
            													}
            													else {
HXDLIN(  78)														_hx_tmp23 = false;
            													}
HXDLIN(  78)													if (_hx_tmp23) {
HXDLIN(  78)														 ::pi_xy::ImageStruct this51 = this47->mask;
HXDLIN(  78)														::Dynamic this52 = this51->image;
HXDLIN(  78)														int index7;
HXDLIN(  78)														if (this51->useVirtualPos) {
HXDLIN(  78)															index7 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this51->virtualY) * ( (Float)(this51->width) )) + dx1) - this51->virtualX));
            														}
            														else {
HXDLIN(  78)															index7 = ::Std_obj::_hx_int(( (Float)(((dy1 * this51->width) + dx1)) ));
            														}
HXDLIN(  78)														int c7 = ::iterMagic::Iimg_obj::get(this52,index7);
HXDLIN(  78)														int v8;
HXDLIN(  78)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)															v8 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            														}
            														else {
HXDLIN(  78)															v8 = c7;
            														}
HXDLIN(  78)														int maskPixel = v8;
HXDLIN(  78)														int this53 = col;
HXDLIN(  78)														if ((maskPixel == 0)) {
HXDLIN(  78)															col = this53;
            														}
            														else {
HXDLIN(  78)															Float m0;
HXDLIN(  78)															int this54 = ((maskPixel >> 24) & 255);
HXDLIN(  78)															if ((this54 == 0)) {
HXDLIN(  78)																m0 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																m0 = (( (Float)(this54) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float m1;
HXDLIN(  78)															int this55 = ((maskPixel >> 16) & 255);
HXDLIN(  78)															if ((this55 == 0)) {
HXDLIN(  78)																m1 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																m1 = (( (Float)(this55) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float m2;
HXDLIN(  78)															int this56 = ((maskPixel >> 8) & 255);
HXDLIN(  78)															if ((this56 == 0)) {
HXDLIN(  78)																m2 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																m2 = (( (Float)(this56) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float m3;
HXDLIN(  78)															int this57 = (maskPixel & 255);
HXDLIN(  78)															if ((this57 == 0)) {
HXDLIN(  78)																m3 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																m3 = (( (Float)(this57) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this53 >> 24) & 255)) )));
HXDLIN(  78)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this53 >> 16) & 255)) )));
HXDLIN(  78)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this53 >> 8) & 255)) )));
HXDLIN(  78)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this53 & 255)) )));
HXDLIN(  78)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  78)													if ((col != 0)) {
HXDLIN(  78)														int x11 = (dx1 - rectLeft);
HXDLIN(  78)														int y11 = (dy1 - rectTop);
HXDLIN(  78)														int c8 = col;
HXDLIN(  78)														bool _hx_tmp24;
HXDLIN(  78)														if ((((c8 >> 24) & 255) < 254)) {
HXDLIN(  78)															_hx_tmp24 = undoImage->transparent;
            														}
            														else {
HXDLIN(  78)															_hx_tmp24 = false;
            														}
HXDLIN(  78)														if (_hx_tmp24) {
HXDLIN(  78)															int location3;
HXDLIN(  78)															if (undoImage->useVirtualPos) {
HXDLIN(  78)																location3 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x11) - undoImage->virtualX));
            															}
            															else {
HXDLIN(  78)																location3 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage->width) + x11)) ));
            															}
HXDLIN(  78)															int this58 = ::iterMagic::Iimg_obj::get(undoImage->image,location3);
HXDLIN(  78)															int this59;
HXDLIN(  78)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																this59 = ((((((this58 >> 24) & 255) << 24) | ((this58 & 255) << 16)) | (((this58 >> 8) & 255) << 8)) | ((this58 >> 16) & 255));
            															}
            															else {
HXDLIN(  78)																this59 = this58;
            															}
HXDLIN(  78)															Float a13;
HXDLIN(  78)															int this60 = ((this59 >> 24) & 255);
HXDLIN(  78)															if ((this60 == 0)) {
HXDLIN(  78)																a13 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																a13 = (( (Float)(this60) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float r13;
HXDLIN(  78)															int this61 = ((this59 >> 16) & 255);
HXDLIN(  78)															if ((this61 == 0)) {
HXDLIN(  78)																r13 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																r13 = (( (Float)(this61) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float g13;
HXDLIN(  78)															int this62 = ((this59 >> 8) & 255);
HXDLIN(  78)															if ((this62 == 0)) {
HXDLIN(  78)																g13 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																g13 = (( (Float)(this62) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float b110;
HXDLIN(  78)															int this63 = (this59 & 255);
HXDLIN(  78)															if ((this63 == 0)) {
HXDLIN(  78)																b110 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																b110 = (( (Float)(this63) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float a23;
HXDLIN(  78)															int this64 = ((col >> 24) & 255);
HXDLIN(  78)															if ((this64 == 0)) {
HXDLIN(  78)																a23 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																a23 = (( (Float)(this64) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float r23;
HXDLIN(  78)															int this65 = ((col >> 16) & 255);
HXDLIN(  78)															if ((this65 == 0)) {
HXDLIN(  78)																r23 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																r23 = (( (Float)(this65) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float g23;
HXDLIN(  78)															int this66 = ((col >> 8) & 255);
HXDLIN(  78)															if ((this66 == 0)) {
HXDLIN(  78)																g23 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																g23 = (( (Float)(this66) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float b24;
HXDLIN(  78)															int this67 = (col & 255);
HXDLIN(  78)															if ((this67 == 0)) {
HXDLIN(  78)																b24 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																b24 = (( (Float)(this67) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  78)															int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  78)															int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  78)															int b25 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a33) + (b24 * a23))));
HXDLIN(  78)															int a14 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  78)															int blended3 = ((((a14 << 24) | (r8 << 16)) | (g5 << 8)) | b25);
HXDLIN(  78)															{
HXDLIN(  78)																int _hx_tmp25;
HXDLIN(  78)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																	_hx_tmp25 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																}
            																else {
HXDLIN(  78)																	_hx_tmp25 = blended3;
            																}
HXDLIN(  78)																::iterMagic::Iimg_obj::set(undoImage->image,location3,_hx_tmp25);
            															}
            														}
            														else {
HXDLIN(  78)															::Dynamic this68 = undoImage->image;
HXDLIN(  78)															int index8;
HXDLIN(  78)															if (undoImage->useVirtualPos) {
HXDLIN(  78)																index8 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x11) - undoImage->virtualX));
            															}
            															else {
HXDLIN(  78)																index8 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage->width) + x11)) ));
            															}
HXDLIN(  78)															int _hx_tmp26;
HXDLIN(  78)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																_hx_tmp26 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            															}
            															else {
HXDLIN(  78)																_hx_tmp26 = c8;
            															}
HXDLIN(  78)															::iterMagic::Iimg_obj::set(this68,index8,_hx_tmp26);
            														}
            													}
            													else {
HXDLIN(  78)														if (forceClear) {
HXDLIN(  78)															::Dynamic this69 = undoImage->image;
HXDLIN(  78)															int x12 = (dx1 - rectLeft);
HXDLIN(  78)															int y12 = (dy1 - rectTop);
HXDLIN(  78)															int index9;
HXDLIN(  78)															if (undoImage->useVirtualPos) {
HXDLIN(  78)																index9 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x12) - undoImage->virtualX));
            															}
            															else {
HXDLIN(  78)																index9 = ::Std_obj::_hx_int(( (Float)(((y12 * undoImage->width) + x12)) ));
            															}
HXDLIN(  78)															::iterMagic::Iimg_obj::set(this69,index9,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  78)							{
HXDLIN(  78)								int _g_min = xIter3->start;
HXDLIN(  78)								int _g_max = xIter3->max;
HXDLIN(  78)								while((_g_min < _g_max)){
HXDLIN(  78)									_g_min = (_g_min + 1);
HXDLIN(  78)									int px = (_g_min - 1);
HXDLIN(  78)									Float pcx = (( (Float)(px) ) - dx);
HXDLIN(  78)									{
HXDLIN(  78)										int _g_min1 = yIter3->start;
HXDLIN(  78)										int _g_max1 = yIter3->max;
HXDLIN(  78)										while((_g_min1 < _g_max1)){
HXDLIN(  78)											_g_min1 = (_g_min1 + 1);
HXDLIN(  78)											int py = (_g_min1 - 1);
HXDLIN(  78)											Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  78)											Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  78)											Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  78)											Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  78)											Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  78)											Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  78)											bool _hx_tmp27;
HXDLIN(  78)											bool _hx_tmp28;
HXDLIN(  78)											if ((ratioA >= 0)) {
HXDLIN(  78)												_hx_tmp28 = (ratioB >= 0);
            											}
            											else {
HXDLIN(  78)												_hx_tmp28 = false;
            											}
HXDLIN(  78)											if (_hx_tmp28) {
HXDLIN(  78)												_hx_tmp27 = (ratioC >= 0);
            											}
            											else {
HXDLIN(  78)												_hx_tmp27 = false;
            											}
HXDLIN(  78)											if (_hx_tmp27) {
HXDLIN(  78)												Float u = (((au * ratioA) + (bu1 * ratioB)) + (du * ratioC));
HXDLIN(  78)												Float v9 = (((av * ratioA) + (bv1 * ratioB)) + (dv * ratioC));
HXDLIN(  78)												int x13 = ::Std_obj::_hx_int(((u * win_width) + win_x));
HXDLIN(  78)												int y13 = ::Std_obj::_hx_int(((v9 * win_height) + win_y));
HXDLIN(  78)												::Dynamic this70 = this44->image;
HXDLIN(  78)												int index10;
HXDLIN(  78)												if (this44->useVirtualPos) {
HXDLIN(  78)													index10 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - this44->virtualY) * ( (Float)(this44->width) )) + x13) - this44->virtualX));
            												}
            												else {
HXDLIN(  78)													index10 = ::Std_obj::_hx_int(( (Float)(((y13 * this44->width) + x13)) ));
            												}
HXDLIN(  78)												int c9 = ::iterMagic::Iimg_obj::get(this70,index10);
HXDLIN(  78)												int col1;
HXDLIN(  78)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)													col1 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            												}
            												else {
HXDLIN(  78)													col1 = c9;
            												}
HXDLIN(  78)												{
HXDLIN(  78)													int c10 = col1;
HXDLIN(  78)													bool _hx_tmp29;
HXDLIN(  78)													if ((((c10 >> 24) & 255) < 254)) {
HXDLIN(  78)														_hx_tmp29 = this47->transparent;
            													}
            													else {
HXDLIN(  78)														_hx_tmp29 = false;
            													}
HXDLIN(  78)													if (_hx_tmp29) {
HXDLIN(  78)														int location4;
HXDLIN(  78)														if (this47->useVirtualPos) {
HXDLIN(  78)															location4 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this47->virtualY) * ( (Float)(this47->width) )) + px) - this47->virtualX));
            														}
            														else {
HXDLIN(  78)															location4 = ::Std_obj::_hx_int(( (Float)(((py * this47->width) + px)) ));
            														}
HXDLIN(  78)														int this71 = ::iterMagic::Iimg_obj::get(this47->image,location4);
HXDLIN(  78)														int this72;
HXDLIN(  78)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)															this72 = ((((((this71 >> 24) & 255) << 24) | ((this71 & 255) << 16)) | (((this71 >> 8) & 255) << 8)) | ((this71 >> 16) & 255));
            														}
            														else {
HXDLIN(  78)															this72 = this71;
            														}
HXDLIN(  78)														Float a15;
HXDLIN(  78)														int this73 = ((this72 >> 24) & 255);
HXDLIN(  78)														if ((this73 == 0)) {
HXDLIN(  78)															a15 = ((Float)0.);
            														}
            														else {
HXDLIN(  78)															a15 = (( (Float)(this73) ) / ( (Float)(255) ));
            														}
HXDLIN(  78)														Float r14;
HXDLIN(  78)														int this74 = ((this72 >> 16) & 255);
HXDLIN(  78)														if ((this74 == 0)) {
HXDLIN(  78)															r14 = ((Float)0.);
            														}
            														else {
HXDLIN(  78)															r14 = (( (Float)(this74) ) / ( (Float)(255) ));
            														}
HXDLIN(  78)														Float g14;
HXDLIN(  78)														int this75 = ((this72 >> 8) & 255);
HXDLIN(  78)														if ((this75 == 0)) {
HXDLIN(  78)															g14 = ((Float)0.);
            														}
            														else {
HXDLIN(  78)															g14 = (( (Float)(this75) ) / ( (Float)(255) ));
            														}
HXDLIN(  78)														Float b111;
HXDLIN(  78)														int this76 = (this72 & 255);
HXDLIN(  78)														if ((this76 == 0)) {
HXDLIN(  78)															b111 = ((Float)0.);
            														}
            														else {
HXDLIN(  78)															b111 = (( (Float)(this76) ) / ( (Float)(255) ));
            														}
HXDLIN(  78)														Float a24;
HXDLIN(  78)														int this77 = ((col1 >> 24) & 255);
HXDLIN(  78)														if ((this77 == 0)) {
HXDLIN(  78)															a24 = ((Float)0.);
            														}
            														else {
HXDLIN(  78)															a24 = (( (Float)(this77) ) / ( (Float)(255) ));
            														}
HXDLIN(  78)														Float r24;
HXDLIN(  78)														int this78 = ((col1 >> 16) & 255);
HXDLIN(  78)														if ((this78 == 0)) {
HXDLIN(  78)															r24 = ((Float)0.);
            														}
            														else {
HXDLIN(  78)															r24 = (( (Float)(this78) ) / ( (Float)(255) ));
            														}
HXDLIN(  78)														Float g24;
HXDLIN(  78)														int this79 = ((col1 >> 8) & 255);
HXDLIN(  78)														if ((this79 == 0)) {
HXDLIN(  78)															g24 = ((Float)0.);
            														}
            														else {
HXDLIN(  78)															g24 = (( (Float)(this79) ) / ( (Float)(255) ));
            														}
HXDLIN(  78)														Float b26;
HXDLIN(  78)														int this80 = (col1 & 255);
HXDLIN(  78)														if ((this80 == 0)) {
HXDLIN(  78)															b26 = ((Float)0.);
            														}
            														else {
HXDLIN(  78)															b26 = (( (Float)(this80) ) / ( (Float)(255) ));
            														}
HXDLIN(  78)														Float a34 = (a15 * (( (Float)(1) ) - a24));
HXDLIN(  78)														int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN(  78)														int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN(  78)														int b27 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a34) + (b26 * a24))));
HXDLIN(  78)														int a16 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN(  78)														int blended4 = ((((a16 << 24) | (r9 << 16)) | (g6 << 8)) | b27);
HXDLIN(  78)														{
HXDLIN(  78)															int _hx_tmp30;
HXDLIN(  78)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																_hx_tmp30 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            															}
            															else {
HXDLIN(  78)																_hx_tmp30 = blended4;
            															}
HXDLIN(  78)															::iterMagic::Iimg_obj::set(this47->image,location4,_hx_tmp30);
            														}
            													}
            													else {
HXDLIN(  78)														::Dynamic this81 = this47->image;
HXDLIN(  78)														int index11;
HXDLIN(  78)														if (this47->useVirtualPos) {
HXDLIN(  78)															index11 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this47->virtualY) * ( (Float)(this47->width) )) + px) - this47->virtualX));
            														}
            														else {
HXDLIN(  78)															index11 = ::Std_obj::_hx_int(( (Float)(((py * this47->width) + px)) ));
            														}
HXDLIN(  78)														int _hx_tmp31;
HXDLIN(  78)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)															_hx_tmp31 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            														}
            														else {
HXDLIN(  78)															_hx_tmp31 = c10;
            														}
HXDLIN(  78)														::iterMagic::Iimg_obj::set(this81,index11,_hx_tmp31);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  78)							 ::pi_xy::iter::IntIterStart v_yIter3;
HXDLIN(  78)							 ::pi_xy::iter::IntIterStart v_xIter3;
HXDLIN(  78)							int v_undoY;
HXDLIN(  78)							int v_undoX;
HXDLIN(  78)							Float v_ty;
HXDLIN(  78)							Float v_tx;
HXDLIN(  78)							Float v_t0;
HXDLIN(  78)							Float v_sy;
HXDLIN(  78)							Float v_sx;
HXDLIN(  78)							Float v_s0;
HXDLIN(  78)							Float v_A;
HXDLIN(  78)							Float ax1 = ax;
HXDLIN(  78)							Float ay1 = ay;
HXDLIN(  78)							 ::pi_xy::ImageStruct v_undoImage = null();
HXDLIN(  78)							Float bx1 = bx;
HXDLIN(  78)							Float by1 = by;
HXDLIN(  78)							Float cx1 = dx;
HXDLIN(  78)							Float cy1 = dy;
HXDLIN(  78)							bool adjustWinding = (((((ax1 * by1) - (bx1 * ay1)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay1) - (ax1 * cy1))) > 0);
HXDLIN(  78)							if (!(adjustWinding)) {
HXDLIN(  78)								Float bx_ = bx1;
HXDLIN(  78)								Float by_ = by1;
HXLINE(  24)								bx1 = cx1;
HXLINE(  25)								by1 = cy1;
HXLINE(  26)								cx1 = bx_;
HXLINE(  27)								cy1 = by_;
            							}
HXLINE(  78)							Float v_ax = ax1;
HXDLIN(  78)							Float v_ay = ay1;
HXDLIN(  78)							Float v_bx = bx1;
HXDLIN(  78)							Float v_by = by1;
HXDLIN(  78)							Float v_cx = cx1;
HXDLIN(  78)							Float v_cy = cy1;
HXDLIN(  78)							bool v_preCalculated = true;
HXDLIN(  78)							{
HXDLIN(  78)								v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN(  78)								v_sx = (v_cy - v_ay);
HXDLIN(  78)								v_sy = (v_ax - v_cx);
HXDLIN(  78)								v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN(  78)								v_tx = (v_ay - v_by);
HXDLIN(  78)								v_ty = (v_bx - v_ax);
HXDLIN(  78)								v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN(  78)								Float a17 = v_ax;
HXDLIN(  78)								Float b28 = v_bx;
HXDLIN(  78)								Float c11 = v_cx;
HXDLIN(  78)								if ((a17 > b28)) {
HXDLIN(  78)									if ((a17 > c11)) {
HXDLIN(  78)										int min6;
HXDLIN(  78)										if ((b28 > c11)) {
HXDLIN(  78)											min6 = ::Math_obj::floor(c11);
            										}
            										else {
HXDLIN(  78)											min6 = ::Math_obj::floor(b28);
            										}
HXDLIN(  78)										int ii_min16 = min6;
HXDLIN(  78)										int ii_max16 = ::Math_obj::ceil(a17);
HXDLIN(  78)										v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            									}
            									else {
HXDLIN(  78)										int ii_min17 = ::Math_obj::floor(b28);
HXDLIN(  78)										int ii_max17 = ::Math_obj::ceil(c11);
HXDLIN(  78)										v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            									}
            								}
            								else {
HXDLIN(  78)									if ((b28 > c11)) {
HXDLIN(  78)										int min7;
HXDLIN(  78)										if ((a17 > c11)) {
HXDLIN(  78)											min7 = ::Math_obj::floor(c11);
            										}
            										else {
HXDLIN(  78)											min7 = ::Math_obj::ceil(a17);
            										}
HXDLIN(  78)										int ii_min18 = min7;
HXDLIN(  78)										int ii_max18 = ::Math_obj::ceil(b28);
HXDLIN(  78)										v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            									}
            									else {
HXDLIN(  78)										int ii_min19 = ::Math_obj::floor(a17);
HXDLIN(  78)										int ii_max19 = ::Math_obj::ceil(c11);
HXDLIN(  78)										v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            									}
            								}
HXDLIN(  78)								Float a18 = v_ay;
HXDLIN(  78)								Float b29 = v_by;
HXDLIN(  78)								Float c12 = v_cy;
HXDLIN(  78)								if ((a18 > b29)) {
HXDLIN(  78)									if ((a18 > c12)) {
HXDLIN(  78)										int min8;
HXDLIN(  78)										if ((b29 > c12)) {
HXDLIN(  78)											min8 = ::Math_obj::floor(c12);
            										}
            										else {
HXDLIN(  78)											min8 = ::Math_obj::floor(b29);
            										}
HXDLIN(  78)										int ii_min20 = min8;
HXDLIN(  78)										int ii_max20 = ::Math_obj::ceil(a18);
HXDLIN(  78)										v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            									}
            									else {
HXDLIN(  78)										int ii_min21 = ::Math_obj::floor(b29);
HXDLIN(  78)										int ii_max21 = ::Math_obj::ceil(c12);
HXDLIN(  78)										v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            									}
            								}
            								else {
HXDLIN(  78)									if ((b29 > c12)) {
HXDLIN(  78)										int min9;
HXDLIN(  78)										if ((a18 > c12)) {
HXDLIN(  78)											min9 = ::Math_obj::floor(c12);
            										}
            										else {
HXDLIN(  78)											min9 = ::Math_obj::ceil(a18);
            										}
HXDLIN(  78)										int ii_min22 = min9;
HXDLIN(  78)										int ii_max22 = ::Math_obj::ceil(b29);
HXDLIN(  78)										v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            									}
            									else {
HXDLIN(  78)										int ii_min23 = ::Math_obj::floor(a18);
HXDLIN(  78)										int ii_max23 = ::Math_obj::ceil(c12);
HXDLIN(  78)										v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            									}
            								}
            							}
HXDLIN(  78)							if (hasUndo) {
HXDLIN(  78)								v_undoImage = undoImage;
HXDLIN(  78)								v_undoX = xIter3->start;
HXDLIN(  78)								v_undoY = yIter3->start;
            							}
HXDLIN(  78)							Float au1 = bu;
HXDLIN(  78)							Float av1 = bv;
HXDLIN(  78)							Float bu2 = cu;
HXDLIN(  78)							Float bv2 = cv;
HXDLIN(  78)							bool hasUndo1 = false;
HXDLIN(  78)							Float temp5 = au1;
HXLINE( 422)							au1 = bu2;
HXLINE( 423)							bu2 = temp5;
HXLINE( 424)							temp5 = av1;
HXLINE( 425)							av1 = bv2;
HXLINE( 426)							bv2 = temp5;
HXLINE(  78)							Float bcx1 = (cx - dx);
HXDLIN(  78)							Float bcy1 = (cy - dy);
HXDLIN(  78)							Float acx1 = (bx - dx);
HXDLIN(  78)							Float acy1 = (by - dy);
HXDLIN(  78)							Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  78)							Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  78)							Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  78)							Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  78)							 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  78)							if ((bx > cx)) {
HXDLIN(  78)								if ((bx > dx)) {
HXDLIN(  78)									int min10;
HXDLIN(  78)									if ((cx > dx)) {
HXDLIN(  78)										min10 = ::Math_obj::floor(dx);
            									}
            									else {
HXDLIN(  78)										min10 = ::Math_obj::floor(cx);
            									}
HXDLIN(  78)									int ii_min24 = min10;
HXDLIN(  78)									int ii_max24 = ::Math_obj::ceil(bx);
HXDLIN(  78)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            								}
            								else {
HXDLIN(  78)									int ii_min25 = ::Math_obj::floor(cx);
HXDLIN(  78)									int ii_max25 = ::Math_obj::ceil(dx);
HXDLIN(  78)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            								}
            							}
            							else {
HXDLIN(  78)								if ((cx > dx)) {
HXDLIN(  78)									int min11;
HXDLIN(  78)									if ((bx > dx)) {
HXDLIN(  78)										min11 = ::Math_obj::floor(dx);
            									}
            									else {
HXDLIN(  78)										min11 = ::Math_obj::ceil(bx);
            									}
HXDLIN(  78)									int ii_min26 = min11;
HXDLIN(  78)									int ii_max26 = ::Math_obj::ceil(cx);
HXDLIN(  78)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            								}
            								else {
HXDLIN(  78)									int ii_min27 = ::Math_obj::floor(bx);
HXDLIN(  78)									int ii_max27 = ::Math_obj::ceil(dx);
HXDLIN(  78)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            								}
            							}
HXDLIN(  78)							 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  78)							if ((by > cy)) {
HXDLIN(  78)								if ((by > dy)) {
HXDLIN(  78)									int min12;
HXDLIN(  78)									if ((cy > dy)) {
HXDLIN(  78)										min12 = ::Math_obj::floor(dy);
            									}
            									else {
HXDLIN(  78)										min12 = ::Math_obj::floor(cy);
            									}
HXDLIN(  78)									int ii_min28 = min12;
HXDLIN(  78)									int ii_max28 = ::Math_obj::ceil(by);
HXDLIN(  78)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            								}
            								else {
HXDLIN(  78)									int ii_min29 = ::Math_obj::floor(cy);
HXDLIN(  78)									int ii_max29 = ::Math_obj::ceil(dy);
HXDLIN(  78)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            								}
            							}
            							else {
HXDLIN(  78)								if ((cy > dy)) {
HXDLIN(  78)									int min13;
HXDLIN(  78)									if ((by > dy)) {
HXDLIN(  78)										min13 = ::Math_obj::floor(dy);
            									}
            									else {
HXDLIN(  78)										min13 = ::Math_obj::ceil(by);
            									}
HXDLIN(  78)									int ii_min30 = min13;
HXDLIN(  78)									int ii_max30 = ::Math_obj::ceil(cy);
HXDLIN(  78)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            								}
            								else {
HXDLIN(  78)									int ii_min31 = ::Math_obj::floor(by);
HXDLIN(  78)									int ii_max31 = ::Math_obj::ceil(dy);
HXDLIN(  78)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            								}
            							}
HXDLIN(  78)							 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  78)							if (hasUndo1) {
HXDLIN(  78)								int width4 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  78)								int height4 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  78)								 ::Dynamic imageType5 = null();
HXDLIN(  78)								 ::pi_xy::ImageStruct this82 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  78)								if (::hx::IsNull( imageType5 )) {
HXLINE(  54)									imageType5 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE(  78)								::Dynamic undoImage4;
HXDLIN(  78)								switch((int)(( (int)(imageType5) ))){
            									case (int)0: {
HXDLIN(  78)										 ::iterMagic::BytesImg byt5 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  78)										 ::iterMagic::BytesImg b30 = byt5;
HXDLIN(  78)										{
HXDLIN(  78)											b30->width = width4;
HXDLIN(  78)											b30->height = height4;
HXDLIN(  78)											b30->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN(  78)											b30->data = ::haxe::io::Bytes_obj::alloc((b30->length * 4));
HXDLIN(  78)											{
HXDLIN(  78)												int len10 = b30->length;
HXDLIN(  78)												int w8 = 0;
HXDLIN(  78)												{
HXDLIN(  78)													int _g84 = 0;
HXDLIN(  78)													int _g85 = b30->height;
HXDLIN(  78)													while((_g84 < _g85)){
HXDLIN(  78)														_g84 = (_g84 + 1);
HXDLIN(  78)														int y14 = (_g84 - 1);
HXDLIN(  78)														{
HXDLIN(  78)															int _g86 = 0;
HXDLIN(  78)															int _g87 = b30->width;
HXDLIN(  78)															while((_g86 < _g87)){
HXDLIN(  78)																_g86 = (_g86 + 1);
HXDLIN(  78)																int x14 = (_g86 - 1);
HXDLIN(  78)																{
HXDLIN(  78)																	w8 = (w8 + 1);
HXDLIN(  78)																	b30->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  78)																{
HXDLIN(  78)																	w8 = (w8 + 1);
HXDLIN(  78)																	b30->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  78)																{
HXDLIN(  78)																	w8 = (w8 + 1);
HXDLIN(  78)																	b30->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  78)																{
HXDLIN(  78)																	w8 = (w8 + 1);
HXDLIN(  78)																	b30->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  78)										undoImage4 = b30;
            									}
            									break;
            									case (int)1: {
HXDLIN(  78)										 ::iterMagic::ArrIntImg arrI5 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)										 ::iterMagic::ArrIntImg a19 = arrI5;
HXDLIN(  78)										{
HXDLIN(  78)											a19->width = width4;
HXDLIN(  78)											a19->height = height4;
HXDLIN(  78)											a19->data = ::Array_obj< int >::__new(0);
HXDLIN(  78)											a19->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN(  78)											{
HXDLIN(  78)												int _g88 = 0;
HXDLIN(  78)												int _g89 = a19->length;
HXDLIN(  78)												while((_g88 < _g89)){
HXDLIN(  78)													_g88 = (_g88 + 1);
HXDLIN(  78)													int i36 = (_g88 - 1);
HXDLIN(  78)													a19->data[i36] = 0;
            												}
            											}
            										}
HXDLIN(  78)										undoImage4 = a19;
            									}
            									break;
            									case (int)2: {
HXDLIN(  78)										 ::iterMagic::U32ArrImg u32a5 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  78)										 ::iterMagic::U32ArrImg b31 = u32a5;
HXDLIN(  78)										{
HXDLIN(  78)											b31->width = width4;
HXDLIN(  78)											b31->height = height4;
HXDLIN(  78)											b31->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN(  78)											int size5 = (b31->length * 4);
HXDLIN(  78)											b31->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size5),0,size5);
HXDLIN(  78)											{
HXDLIN(  78)												int _g90 = 0;
HXDLIN(  78)												int _g91 = b31->length;
HXDLIN(  78)												while((_g90 < _g91)){
HXDLIN(  78)													_g90 = (_g90 + 1);
HXDLIN(  78)													int i37 = (_g90 - 1);
HXDLIN(  78)													{
HXDLIN(  78)														 ::haxe::io::ArrayBufferViewImpl this83 = b31->data;
HXDLIN(  78)														bool undoImage5;
HXDLIN(  78)														if ((i37 >= 0)) {
HXDLIN(  78)															undoImage5 = (i37 < (this83->byteLength >> 2));
            														}
            														else {
HXDLIN(  78)															undoImage5 = false;
            														}
HXDLIN(  78)														if (undoImage5) {
HXDLIN(  78)															 ::haxe::io::Bytes _this5 = this83->bytes;
HXDLIN(  78)															int pos5 = ((i37 << 2) + this83->byteOffset);
HXDLIN(  78)															_this5->b[pos5] = ( (unsigned char)(0) );
HXDLIN(  78)															_this5->b[(pos5 + 1)] = ( (unsigned char)(0) );
HXDLIN(  78)															_this5->b[(pos5 + 2)] = ( (unsigned char)(0) );
HXDLIN(  78)															_this5->b[(pos5 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN(  78)										undoImage4 = b31;
            									}
            									break;
            									case (int)3: {
HXDLIN(  78)										 ::iterMagic::VecIntImg vec5 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)										 ::iterMagic::VecIntImg v10 = vec5;
HXDLIN(  78)										{
HXDLIN(  78)											v10->width = width4;
HXDLIN(  78)											v10->height = height4;
HXDLIN(  78)											v10->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN(  78)											v10->data = ::Array_obj< int >::__new(v10->length);
HXDLIN(  78)											{
HXDLIN(  78)												int _g92 = 0;
HXDLIN(  78)												int _g93 = v10->length;
HXDLIN(  78)												while((_g92 < _g93)){
HXDLIN(  78)													_g92 = (_g92 + 1);
HXDLIN(  78)													int i38 = (_g92 - 1);
HXDLIN(  78)													v10->data->__unsafe_set(i38,0);
            												}
            											}
            										}
HXDLIN(  78)										undoImage4 = v10;
            									}
            									break;
            									case (int)4: {
HXDLIN(  78)										 ::iterMagic::StackIntImg sInt5 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)										 ::iterMagic::StackIntImg b32 = sInt5;
HXDLIN(  78)										{
HXDLIN(  78)											b32->width = width4;
HXDLIN(  78)											b32->height = height4;
HXDLIN(  78)											b32->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN(  78)											b32->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  78)											{
HXDLIN(  78)												int len11 = b32->length;
HXDLIN(  78)												 ::haxe::ds::GenericStack_Int d5 = b32->data;
HXDLIN(  78)												if (::hx::IsNull( d5->head )) {
HXDLIN(  78)													int _g94 = 0;
HXDLIN(  78)													int _g95 = len11;
HXDLIN(  78)													while((_g94 < _g95)){
HXDLIN(  78)														_g94 = (_g94 + 1);
HXDLIN(  78)														int i39 = (_g94 - 1);
HXDLIN(  78)														d5->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d5->head);
            													}
            												}
            												else {
HXDLIN(  78)													int _g96 = 0;
HXDLIN(  78)													int _g97 = len11;
HXDLIN(  78)													while((_g96 < _g97)){
HXDLIN(  78)														_g96 = (_g96 + 1);
HXDLIN(  78)														int i40 = (_g96 - 1);
HXDLIN(  78)														{
HXDLIN(  78)															 ::haxe::ds::GenericCell_Int l5 = b32->data->head;
HXDLIN(  78)															 ::haxe::ds::GenericCell_Int prev5 = null();
HXDLIN(  78)															{
HXDLIN(  78)																int _g98 = 0;
HXDLIN(  78)																int _g99 = i40;
HXDLIN(  78)																while((_g98 < _g99)){
HXDLIN(  78)																	_g98 = (_g98 + 1);
HXDLIN(  78)																	int i41 = (_g98 - 1);
HXLINE( 345)																	prev5 = l5;
HXLINE( 346)																	l5 = l5->next;
            																}
            															}
HXLINE(  78)															if (::hx::IsNull( prev5 )) {
HXDLIN(  78)																b32->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN(  78)																l5 = null();
            															}
            															else {
HXDLIN(  78)																prev5->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN(  78)																l5 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  78)										undoImage4 = b32;
            									}
            									break;
            								}
HXDLIN(  78)								this82->image = undoImage4;
HXDLIN(  78)								this82->width = width4;
HXDLIN(  78)								this82->height = height4;
HXDLIN(  78)								this82->imageType = ( (int)(imageType5) );
HXDLIN(  78)								undoImage3 = this82;
HXDLIN(  78)								{
HXDLIN(  78)									int rectLeft1 = xIter31->start;
HXDLIN(  78)									int rectTop1 = yIter31->start;
HXDLIN(  78)									int rectRight1 = xIter31->max;
HXDLIN(  78)									bool forceClear1 = false;
HXDLIN(  78)									{
HXDLIN(  78)										int _g100 = rectTop1;
HXDLIN(  78)										int _g101 = yIter31->max;
HXDLIN(  78)										while((_g100 < _g101)){
HXDLIN(  78)											_g100 = (_g100 + 1);
HXDLIN(  78)											int dy2 = (_g100 - 1);
HXDLIN(  78)											{
HXDLIN(  78)												int _g102 = rectLeft1;
HXDLIN(  78)												int _g103 = rectRight1;
HXDLIN(  78)												while((_g102 < _g103)){
HXDLIN(  78)													_g102 = (_g102 + 1);
HXDLIN(  78)													int dx2 = (_g102 - 1);
HXDLIN(  78)													::Dynamic this84 = this47->image;
HXDLIN(  78)													int index12;
HXDLIN(  78)													if (this47->useVirtualPos) {
HXDLIN(  78)														index12 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this47->virtualY) * ( (Float)(this47->width) )) + dx2) - this47->virtualX));
            													}
            													else {
HXDLIN(  78)														index12 = ::Std_obj::_hx_int(( (Float)(((dy2 * this47->width) + dx2)) ));
            													}
HXDLIN(  78)													int c13 = ::iterMagic::Iimg_obj::get(this84,index12);
HXDLIN(  78)													int col2;
HXDLIN(  78)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)														col2 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            													}
            													else {
HXDLIN(  78)														col2 = c13;
            													}
HXDLIN(  78)													bool _hx_tmp32;
HXDLIN(  78)													if (this47->useMask) {
HXDLIN(  78)														_hx_tmp32 = ::hx::IsNotNull( this47->mask );
            													}
            													else {
HXDLIN(  78)														_hx_tmp32 = false;
            													}
HXDLIN(  78)													if (_hx_tmp32) {
HXDLIN(  78)														 ::pi_xy::ImageStruct this85 = this47->mask;
HXDLIN(  78)														::Dynamic this86 = this85->image;
HXDLIN(  78)														int index13;
HXDLIN(  78)														if (this85->useVirtualPos) {
HXDLIN(  78)															index13 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this85->virtualY) * ( (Float)(this85->width) )) + dx2) - this85->virtualX));
            														}
            														else {
HXDLIN(  78)															index13 = ::Std_obj::_hx_int(( (Float)(((dy2 * this85->width) + dx2)) ));
            														}
HXDLIN(  78)														int c14 = ::iterMagic::Iimg_obj::get(this86,index13);
HXDLIN(  78)														int v11;
HXDLIN(  78)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)															v11 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            														}
            														else {
HXDLIN(  78)															v11 = c14;
            														}
HXDLIN(  78)														int maskPixel1 = v11;
HXDLIN(  78)														int this87 = col2;
HXDLIN(  78)														if ((maskPixel1 == 0)) {
HXDLIN(  78)															col2 = this87;
            														}
            														else {
HXDLIN(  78)															Float m01;
HXDLIN(  78)															int this88 = ((maskPixel1 >> 24) & 255);
HXDLIN(  78)															if ((this88 == 0)) {
HXDLIN(  78)																m01 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																m01 = (( (Float)(this88) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float m11;
HXDLIN(  78)															int this89 = ((maskPixel1 >> 16) & 255);
HXDLIN(  78)															if ((this89 == 0)) {
HXDLIN(  78)																m11 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																m11 = (( (Float)(this89) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float m21;
HXDLIN(  78)															int this90 = ((maskPixel1 >> 8) & 255);
HXDLIN(  78)															if ((this90 == 0)) {
HXDLIN(  78)																m21 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																m21 = (( (Float)(this90) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float m31;
HXDLIN(  78)															int this91 = (maskPixel1 & 255);
HXDLIN(  78)															if ((this91 == 0)) {
HXDLIN(  78)																m31 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																m31 = (( (Float)(this91) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this87 >> 24) & 255)) )));
HXDLIN(  78)															int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this87 >> 16) & 255)) )));
HXDLIN(  78)															int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this87 >> 8) & 255)) )));
HXDLIN(  78)															int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this87 & 255)) )));
HXDLIN(  78)															col2 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  78)													if ((col2 != 0)) {
HXDLIN(  78)														int x15 = (dx2 - rectLeft1);
HXDLIN(  78)														int y15 = (dy2 - rectTop1);
HXDLIN(  78)														int c15 = col2;
HXDLIN(  78)														bool _hx_tmp33;
HXDLIN(  78)														if ((((c15 >> 24) & 255) < 254)) {
HXDLIN(  78)															_hx_tmp33 = undoImage3->transparent;
            														}
            														else {
HXDLIN(  78)															_hx_tmp33 = false;
            														}
HXDLIN(  78)														if (_hx_tmp33) {
HXDLIN(  78)															int location5;
HXDLIN(  78)															if (undoImage3->useVirtualPos) {
HXDLIN(  78)																location5 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x15) - undoImage3->virtualX));
            															}
            															else {
HXDLIN(  78)																location5 = ::Std_obj::_hx_int(( (Float)(((y15 * undoImage3->width) + x15)) ));
            															}
HXDLIN(  78)															int this92 = ::iterMagic::Iimg_obj::get(undoImage3->image,location5);
HXDLIN(  78)															int this93;
HXDLIN(  78)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																this93 = ((((((this92 >> 24) & 255) << 24) | ((this92 & 255) << 16)) | (((this92 >> 8) & 255) << 8)) | ((this92 >> 16) & 255));
            															}
            															else {
HXDLIN(  78)																this93 = this92;
            															}
HXDLIN(  78)															Float a110;
HXDLIN(  78)															int this94 = ((this93 >> 24) & 255);
HXDLIN(  78)															if ((this94 == 0)) {
HXDLIN(  78)																a110 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																a110 = (( (Float)(this94) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float r15;
HXDLIN(  78)															int this95 = ((this93 >> 16) & 255);
HXDLIN(  78)															if ((this95 == 0)) {
HXDLIN(  78)																r15 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																r15 = (( (Float)(this95) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float g15;
HXDLIN(  78)															int this96 = ((this93 >> 8) & 255);
HXDLIN(  78)															if ((this96 == 0)) {
HXDLIN(  78)																g15 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																g15 = (( (Float)(this96) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float b112;
HXDLIN(  78)															int this97 = (this93 & 255);
HXDLIN(  78)															if ((this97 == 0)) {
HXDLIN(  78)																b112 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																b112 = (( (Float)(this97) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float a25;
HXDLIN(  78)															int this98 = ((col2 >> 24) & 255);
HXDLIN(  78)															if ((this98 == 0)) {
HXDLIN(  78)																a25 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																a25 = (( (Float)(this98) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float r25;
HXDLIN(  78)															int this99 = ((col2 >> 16) & 255);
HXDLIN(  78)															if ((this99 == 0)) {
HXDLIN(  78)																r25 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																r25 = (( (Float)(this99) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float g25;
HXDLIN(  78)															int this100 = ((col2 >> 8) & 255);
HXDLIN(  78)															if ((this100 == 0)) {
HXDLIN(  78)																g25 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																g25 = (( (Float)(this100) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float b210;
HXDLIN(  78)															int this101 = (col2 & 255);
HXDLIN(  78)															if ((this101 == 0)) {
HXDLIN(  78)																b210 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																b210 = (( (Float)(this101) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float a35 = (a110 * (( (Float)(1) ) - a25));
HXDLIN(  78)															int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN(  78)															int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN(  78)															int b33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a35) + (b210 * a25))));
HXDLIN(  78)															int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN(  78)															int blended5 = ((((a20 << 24) | (r10 << 16)) | (g7 << 8)) | b33);
HXDLIN(  78)															{
HXDLIN(  78)																int _hx_tmp34;
HXDLIN(  78)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																	_hx_tmp34 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            																}
            																else {
HXDLIN(  78)																	_hx_tmp34 = blended5;
            																}
HXDLIN(  78)																::iterMagic::Iimg_obj::set(undoImage3->image,location5,_hx_tmp34);
            															}
            														}
            														else {
HXDLIN(  78)															::Dynamic this102 = undoImage3->image;
HXDLIN(  78)															int index14;
HXDLIN(  78)															if (undoImage3->useVirtualPos) {
HXDLIN(  78)																index14 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x15) - undoImage3->virtualX));
            															}
            															else {
HXDLIN(  78)																index14 = ::Std_obj::_hx_int(( (Float)(((y15 * undoImage3->width) + x15)) ));
            															}
HXDLIN(  78)															int _hx_tmp35;
HXDLIN(  78)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																_hx_tmp35 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            															}
            															else {
HXDLIN(  78)																_hx_tmp35 = c15;
            															}
HXDLIN(  78)															::iterMagic::Iimg_obj::set(this102,index14,_hx_tmp35);
            														}
            													}
            													else {
HXDLIN(  78)														if (forceClear1) {
HXDLIN(  78)															::Dynamic this103 = undoImage3->image;
HXDLIN(  78)															int x16 = (dx2 - rectLeft1);
HXDLIN(  78)															int y16 = (dy2 - rectTop1);
HXDLIN(  78)															int index15;
HXDLIN(  78)															if (undoImage3->useVirtualPos) {
HXDLIN(  78)																index15 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x16) - undoImage3->virtualX));
            															}
            															else {
HXDLIN(  78)																index15 = ::Std_obj::_hx_int(( (Float)(((y16 * undoImage3->width) + x16)) ));
            															}
HXDLIN(  78)															::iterMagic::Iimg_obj::set(this103,index15,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  78)							{
HXDLIN(  78)								int _g_min2 = xIter31->start;
HXDLIN(  78)								int _g_max2 = xIter31->max;
HXDLIN(  78)								while((_g_min2 < _g_max2)){
HXDLIN(  78)									_g_min2 = (_g_min2 + 1);
HXDLIN(  78)									int px1 = (_g_min2 - 1);
HXDLIN(  78)									Float pcx1 = (( (Float)(px1) ) - dx);
HXDLIN(  78)									{
HXDLIN(  78)										int _g_min3 = yIter31->start;
HXDLIN(  78)										int _g_max3 = yIter31->max;
HXDLIN(  78)										while((_g_min3 < _g_max3)){
HXDLIN(  78)											_g_min3 = (_g_min3 + 1);
HXDLIN(  78)											int py1 = (_g_min3 - 1);
HXDLIN(  78)											Float pcy1 = (( (Float)(py1) ) - dy);
HXDLIN(  78)											Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN(  78)											Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN(  78)											Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN(  78)											Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN(  78)											Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN(  78)											bool _hx_tmp36;
HXDLIN(  78)											bool _hx_tmp37;
HXDLIN(  78)											if ((ratioA1 >= 0)) {
HXDLIN(  78)												_hx_tmp37 = (ratioB1 >= 0);
            											}
            											else {
HXDLIN(  78)												_hx_tmp37 = false;
            											}
HXDLIN(  78)											if (_hx_tmp37) {
HXDLIN(  78)												_hx_tmp36 = (ratioC1 >= 0);
            											}
            											else {
HXDLIN(  78)												_hx_tmp36 = false;
            											}
HXDLIN(  78)											if (_hx_tmp36) {
HXDLIN(  78)												Float u1 = (((au1 * ratioA1) + (bu2 * ratioB1)) + (du * ratioC1));
HXDLIN(  78)												Float v12 = (((av1 * ratioA1) + (bv2 * ratioB1)) + (dv * ratioC1));
HXDLIN(  78)												int x17 = ::Std_obj::_hx_int(((u1 * win_width) + win_x));
HXDLIN(  78)												int y17 = ::Std_obj::_hx_int(((v12 * win_height) + win_y));
HXDLIN(  78)												::Dynamic this104 = this44->image;
HXDLIN(  78)												int index16;
HXDLIN(  78)												if (this44->useVirtualPos) {
HXDLIN(  78)													index16 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - this44->virtualY) * ( (Float)(this44->width) )) + x17) - this44->virtualX));
            												}
            												else {
HXDLIN(  78)													index16 = ::Std_obj::_hx_int(( (Float)(((y17 * this44->width) + x17)) ));
            												}
HXDLIN(  78)												int c16 = ::iterMagic::Iimg_obj::get(this104,index16);
HXDLIN(  78)												int col3;
HXDLIN(  78)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)													col3 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            												}
            												else {
HXDLIN(  78)													col3 = c16;
            												}
HXDLIN(  78)												{
HXDLIN(  78)													int c17 = col3;
HXDLIN(  78)													bool _hx_tmp38;
HXDLIN(  78)													if ((((c17 >> 24) & 255) < 254)) {
HXDLIN(  78)														_hx_tmp38 = this47->transparent;
            													}
            													else {
HXDLIN(  78)														_hx_tmp38 = false;
            													}
HXDLIN(  78)													if (_hx_tmp38) {
HXDLIN(  78)														int location6;
HXDLIN(  78)														if (this47->useVirtualPos) {
HXDLIN(  78)															location6 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this47->virtualY) * ( (Float)(this47->width) )) + px1) - this47->virtualX));
            														}
            														else {
HXDLIN(  78)															location6 = ::Std_obj::_hx_int(( (Float)(((py1 * this47->width) + px1)) ));
            														}
HXDLIN(  78)														int this105 = ::iterMagic::Iimg_obj::get(this47->image,location6);
HXDLIN(  78)														int this106;
HXDLIN(  78)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)															this106 = ((((((this105 >> 24) & 255) << 24) | ((this105 & 255) << 16)) | (((this105 >> 8) & 255) << 8)) | ((this105 >> 16) & 255));
            														}
            														else {
HXDLIN(  78)															this106 = this105;
            														}
HXDLIN(  78)														Float a111;
HXDLIN(  78)														int this107 = ((this106 >> 24) & 255);
HXDLIN(  78)														if ((this107 == 0)) {
HXDLIN(  78)															a111 = ((Float)0.);
            														}
            														else {
HXDLIN(  78)															a111 = (( (Float)(this107) ) / ( (Float)(255) ));
            														}
HXDLIN(  78)														Float r16;
HXDLIN(  78)														int this108 = ((this106 >> 16) & 255);
HXDLIN(  78)														if ((this108 == 0)) {
HXDLIN(  78)															r16 = ((Float)0.);
            														}
            														else {
HXDLIN(  78)															r16 = (( (Float)(this108) ) / ( (Float)(255) ));
            														}
HXDLIN(  78)														Float g16;
HXDLIN(  78)														int this109 = ((this106 >> 8) & 255);
HXDLIN(  78)														if ((this109 == 0)) {
HXDLIN(  78)															g16 = ((Float)0.);
            														}
            														else {
HXDLIN(  78)															g16 = (( (Float)(this109) ) / ( (Float)(255) ));
            														}
HXDLIN(  78)														Float b113;
HXDLIN(  78)														int this110 = (this106 & 255);
HXDLIN(  78)														if ((this110 == 0)) {
HXDLIN(  78)															b113 = ((Float)0.);
            														}
            														else {
HXDLIN(  78)															b113 = (( (Float)(this110) ) / ( (Float)(255) ));
            														}
HXDLIN(  78)														Float a26;
HXDLIN(  78)														int this111 = ((col3 >> 24) & 255);
HXDLIN(  78)														if ((this111 == 0)) {
HXDLIN(  78)															a26 = ((Float)0.);
            														}
            														else {
HXDLIN(  78)															a26 = (( (Float)(this111) ) / ( (Float)(255) ));
            														}
HXDLIN(  78)														Float r26;
HXDLIN(  78)														int this112 = ((col3 >> 16) & 255);
HXDLIN(  78)														if ((this112 == 0)) {
HXDLIN(  78)															r26 = ((Float)0.);
            														}
            														else {
HXDLIN(  78)															r26 = (( (Float)(this112) ) / ( (Float)(255) ));
            														}
HXDLIN(  78)														Float g26;
HXDLIN(  78)														int this113 = ((col3 >> 8) & 255);
HXDLIN(  78)														if ((this113 == 0)) {
HXDLIN(  78)															g26 = ((Float)0.);
            														}
            														else {
HXDLIN(  78)															g26 = (( (Float)(this113) ) / ( (Float)(255) ));
            														}
HXDLIN(  78)														Float b211;
HXDLIN(  78)														int this114 = (col3 & 255);
HXDLIN(  78)														if ((this114 == 0)) {
HXDLIN(  78)															b211 = ((Float)0.);
            														}
            														else {
HXDLIN(  78)															b211 = (( (Float)(this114) ) / ( (Float)(255) ));
            														}
HXDLIN(  78)														Float a36 = (a111 * (( (Float)(1) ) - a26));
HXDLIN(  78)														int r17 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN(  78)														int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN(  78)														int b34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a36) + (b211 * a26))));
HXDLIN(  78)														int a27 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN(  78)														int blended6 = ((((a27 << 24) | (r17 << 16)) | (g8 << 8)) | b34);
HXDLIN(  78)														{
HXDLIN(  78)															int _hx_tmp39;
HXDLIN(  78)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																_hx_tmp39 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            															}
            															else {
HXDLIN(  78)																_hx_tmp39 = blended6;
            															}
HXDLIN(  78)															::iterMagic::Iimg_obj::set(this47->image,location6,_hx_tmp39);
            														}
            													}
            													else {
HXDLIN(  78)														::Dynamic this115 = this47->image;
HXDLIN(  78)														int index17;
HXDLIN(  78)														if (this47->useVirtualPos) {
HXDLIN(  78)															index17 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this47->virtualY) * ( (Float)(this47->width) )) + px1) - this47->virtualX));
            														}
            														else {
HXDLIN(  78)															index17 = ::Std_obj::_hx_int(( (Float)(((py1 * this47->width) + px1)) ));
            														}
HXDLIN(  78)														int _hx_tmp40;
HXDLIN(  78)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)															_hx_tmp40 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            														}
            														else {
HXDLIN(  78)															_hx_tmp40 = c17;
            														}
HXDLIN(  78)														::iterMagic::Iimg_obj::set(this115,index17,_hx_tmp40);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  78)							 ::pi_xy::iter::IntIterStart v_yIter31;
HXDLIN(  78)							 ::pi_xy::iter::IntIterStart v_xIter31;
HXDLIN(  78)							int v_undoY1;
HXDLIN(  78)							int v_undoX1;
HXDLIN(  78)							Float v_ty1;
HXDLIN(  78)							Float v_tx1;
HXDLIN(  78)							Float v_t01;
HXDLIN(  78)							Float v_sy1;
HXDLIN(  78)							Float v_sx1;
HXDLIN(  78)							Float v_s01;
HXDLIN(  78)							Float v_A1;
HXDLIN(  78)							Float ax2 = bx;
HXDLIN(  78)							Float ay2 = by;
HXDLIN(  78)							 ::pi_xy::ImageStruct v_undoImage1 = null();
HXDLIN(  78)							Float bx2 = cx;
HXDLIN(  78)							Float by2 = cy;
HXDLIN(  78)							Float cx2 = dx;
HXDLIN(  78)							Float cy2 = dy;
HXDLIN(  78)							bool adjustWinding1 = (((((ax2 * by2) - (bx2 * ay2)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ay2) - (ax2 * cy2))) > 0);
HXDLIN(  78)							if (!(adjustWinding1)) {
HXDLIN(  78)								Float bx_1 = bx2;
HXDLIN(  78)								Float by_1 = by2;
HXLINE(  24)								bx2 = cx2;
HXLINE(  25)								by2 = cy2;
HXLINE(  26)								cx2 = bx_1;
HXLINE(  27)								cy2 = by_1;
            							}
HXLINE(  78)							Float v_ax1 = ax2;
HXDLIN(  78)							Float v_ay1 = ay2;
HXDLIN(  78)							Float v_bx1 = bx2;
HXDLIN(  78)							Float v_by1 = by2;
HXDLIN(  78)							Float v_cx1 = cx2;
HXDLIN(  78)							Float v_cy1 = cy2;
HXDLIN(  78)							bool v_preCalculated1 = true;
HXDLIN(  78)							{
HXDLIN(  78)								v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN(  78)								v_sx1 = (v_cy1 - v_ay1);
HXDLIN(  78)								v_sy1 = (v_ax1 - v_cx1);
HXDLIN(  78)								v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN(  78)								v_tx1 = (v_ay1 - v_by1);
HXDLIN(  78)								v_ty1 = (v_bx1 - v_ax1);
HXDLIN(  78)								v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN(  78)								Float a28 = v_ax1;
HXDLIN(  78)								Float b35 = v_bx1;
HXDLIN(  78)								Float c18 = v_cx1;
HXDLIN(  78)								if ((a28 > b35)) {
HXDLIN(  78)									if ((a28 > c18)) {
HXDLIN(  78)										int min14;
HXDLIN(  78)										if ((b35 > c18)) {
HXDLIN(  78)											min14 = ::Math_obj::floor(c18);
            										}
            										else {
HXDLIN(  78)											min14 = ::Math_obj::floor(b35);
            										}
HXDLIN(  78)										int ii_min32 = min14;
HXDLIN(  78)										int ii_max32 = ::Math_obj::ceil(a28);
HXDLIN(  78)										v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min32,ii_max32);
            									}
            									else {
HXDLIN(  78)										int ii_min33 = ::Math_obj::floor(b35);
HXDLIN(  78)										int ii_max33 = ::Math_obj::ceil(c18);
HXDLIN(  78)										v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min33,ii_max33);
            									}
            								}
            								else {
HXDLIN(  78)									if ((b35 > c18)) {
HXDLIN(  78)										int min15;
HXDLIN(  78)										if ((a28 > c18)) {
HXDLIN(  78)											min15 = ::Math_obj::floor(c18);
            										}
            										else {
HXDLIN(  78)											min15 = ::Math_obj::ceil(a28);
            										}
HXDLIN(  78)										int ii_min34 = min15;
HXDLIN(  78)										int ii_max34 = ::Math_obj::ceil(b35);
HXDLIN(  78)										v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min34,ii_max34);
            									}
            									else {
HXDLIN(  78)										int ii_min35 = ::Math_obj::floor(a28);
HXDLIN(  78)										int ii_max35 = ::Math_obj::ceil(c18);
HXDLIN(  78)										v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min35,ii_max35);
            									}
            								}
HXDLIN(  78)								Float a29 = v_ay1;
HXDLIN(  78)								Float b36 = v_by1;
HXDLIN(  78)								Float c19 = v_cy1;
HXDLIN(  78)								if ((a29 > b36)) {
HXDLIN(  78)									if ((a29 > c19)) {
HXDLIN(  78)										int min16;
HXDLIN(  78)										if ((b36 > c19)) {
HXDLIN(  78)											min16 = ::Math_obj::floor(c19);
            										}
            										else {
HXDLIN(  78)											min16 = ::Math_obj::floor(b36);
            										}
HXDLIN(  78)										int ii_min36 = min16;
HXDLIN(  78)										int ii_max36 = ::Math_obj::ceil(a29);
HXDLIN(  78)										v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min36,ii_max36);
            									}
            									else {
HXDLIN(  78)										int ii_min37 = ::Math_obj::floor(b36);
HXDLIN(  78)										int ii_max37 = ::Math_obj::ceil(c19);
HXDLIN(  78)										v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min37,ii_max37);
            									}
            								}
            								else {
HXDLIN(  78)									if ((b36 > c19)) {
HXDLIN(  78)										int min17;
HXDLIN(  78)										if ((a29 > c19)) {
HXDLIN(  78)											min17 = ::Math_obj::floor(c19);
            										}
            										else {
HXDLIN(  78)											min17 = ::Math_obj::ceil(a29);
            										}
HXDLIN(  78)										int ii_min38 = min17;
HXDLIN(  78)										int ii_max38 = ::Math_obj::ceil(b36);
HXDLIN(  78)										v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min38,ii_max38);
            									}
            									else {
HXDLIN(  78)										int ii_min39 = ::Math_obj::floor(a29);
HXDLIN(  78)										int ii_max39 = ::Math_obj::ceil(c19);
HXDLIN(  78)										v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min39,ii_max39);
            									}
            								}
            							}
HXDLIN(  78)							if (hasUndo1) {
HXDLIN(  78)								v_undoImage1 = undoImage3;
HXDLIN(  78)								v_undoX1 = xIter31->start;
HXDLIN(  78)								v_undoY1 = yIter31->start;
            							}
            						}
            					}
HXDLIN(  78)					bool _hx_tmp41;
HXDLIN(  78)					if (::hx::IsNotNull( nextImage3->mask )) {
HXDLIN(  78)						_hx_tmp41 = includeMask;
            					}
            					else {
HXDLIN(  78)						_hx_tmp41 = false;
            					}
HXDLIN(  78)					if (_hx_tmp41) {
HXDLIN(  78)						 ::pi_xy::ImageStruct this116 = this44->mask;
HXDLIN(  78)						bool transparent1 = this44->mask->transparent;
HXDLIN(  78)						Float centreX2 = centreX1;
HXDLIN(  78)						Float centreY2 = centreY1;
HXDLIN(  78)						Float ax3 = ((Float)0.);
HXDLIN(  78)						Float ay3 = ((Float)0.);
HXDLIN(  78)						if ((centreX2 != ((Float)0.))) {
HXLINE( 173)							centreX2 = ((( (Float)(this116->width) ) / ( (Float)(2) )) + centreX2);
HXLINE(  78)							ax3 = (ax3 - centreX2);
            						}
HXDLIN(  78)						if ((centreY2 != ((Float)0.))) {
HXLINE( 177)							centreY2 = ((( (Float)(this116->height) ) / ( (Float)(2) )) + centreY2);
HXLINE(  78)							ay3 = (ay3 - centreY2);
            						}
HXDLIN(  78)						Float bx3 = (ax3 + this116->width);
HXDLIN(  78)						Float by3 = ay3;
HXDLIN(  78)						Float cx3 = bx3;
HXDLIN(  78)						Float cy3 = (ay3 + this116->height);
HXDLIN(  78)						Float dx3 = ax3;
HXDLIN(  78)						Float dy3 = cy3;
HXDLIN(  78)						Float sin1 = ::Math_obj::sin(theta);
HXDLIN(  78)						Float cos1 = ::Math_obj::cos(theta);
HXDLIN(  78)						Float temp6 = ax3;
HXLINE( 189)						ax3 = ((temp6 * cos1) - (ay3 * sin1));
HXLINE( 190)						ay3 = ((ay3 * cos1) + (temp6 * sin1));
HXLINE(  78)						Float temp7 = bx3;
HXLINE( 192)						bx3 = ((temp7 * cos1) - (by3 * sin1));
HXLINE( 193)						by3 = ((by3 * cos1) + (temp7 * sin1));
HXLINE(  78)						Float temp8 = cx3;
HXLINE( 195)						cx3 = ((temp8 * cos1) - (cy3 * sin1));
HXLINE( 196)						cy3 = ((cy3 * cos1) + (temp8 * sin1));
HXLINE(  78)						Float temp9 = dx3;
HXLINE( 198)						dx3 = ((temp9 * cos1) - (dy3 * sin1));
HXLINE( 199)						dy3 = ((dy3 * cos1) + (temp9 * sin1));
HXLINE(  78)						if ((centreX2 != ((Float)0.))) {
HXDLIN(  78)							ax3 = (ax3 + centreX2);
HXDLIN(  78)							bx3 = (bx3 + centreX2);
HXDLIN(  78)							cx3 = (cx3 + centreX2);
HXDLIN(  78)							dx3 = (dx3 + centreX2);
            						}
HXDLIN(  78)						if ((centreY2 != ((Float)0.))) {
HXDLIN(  78)							ay3 = (ay3 + centreY2);
HXDLIN(  78)							by3 = (by3 + centreY2);
HXDLIN(  78)							cy3 = (cy3 + centreY2);
HXDLIN(  78)							dy3 = (dy3 + centreY2);
            						}
HXDLIN(  78)						int min18 = ::Math_obj::floor(ax3);
HXDLIN(  78)						int max2 = ::Math_obj::ceil(ax3);
HXDLIN(  78)						if ((bx3 < min18)) {
HXLINE(  31)							min18 = ::Math_obj::floor(bx3);
            						}
            						else {
HXDLIN(  78)							if ((bx3 > max2)) {
HXLINE(  33)								max2 = ::Math_obj::ceil(bx3);
            							}
            						}
HXLINE(  78)						if ((cx3 < min18)) {
HXLINE(  36)							min18 = ::Math_obj::floor(cx3);
            						}
            						else {
HXDLIN(  78)							if ((cx3 > max2)) {
HXLINE(  38)								max2 = ::Math_obj::ceil(cx3);
            							}
            						}
HXLINE(  78)						if ((dx3 < min18)) {
HXLINE(  41)							min18 = ::Math_obj::floor(dx3);
            						}
            						else {
HXDLIN(  78)							if ((dx3 > max2)) {
HXLINE(  43)								max2 = ::Math_obj::ceil(dx3);
            							}
            						}
HXLINE(  78)						int ii_min40 = min18;
HXDLIN(  78)						int ii_max40 = max2;
HXDLIN(  78)						 ::pi_xy::iter::IntIterStart boundX1 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min40,ii_max40);
HXDLIN(  78)						int min19 = ::Math_obj::floor(ay3);
HXDLIN(  78)						int max3 = ::Math_obj::ceil(ay3);
HXDLIN(  78)						if ((by3 < min19)) {
HXLINE(  31)							min19 = ::Math_obj::floor(by3);
            						}
            						else {
HXDLIN(  78)							if ((by3 > max3)) {
HXLINE(  33)								max3 = ::Math_obj::ceil(by3);
            							}
            						}
HXLINE(  78)						if ((cy3 < min19)) {
HXLINE(  36)							min19 = ::Math_obj::floor(cy3);
            						}
            						else {
HXDLIN(  78)							if ((cy3 > max3)) {
HXLINE(  38)								max3 = ::Math_obj::ceil(cy3);
            							}
            						}
HXLINE(  78)						if ((dy3 < min19)) {
HXLINE(  41)							min19 = ::Math_obj::floor(dy3);
            						}
            						else {
HXDLIN(  78)							if ((dy3 > max3)) {
HXLINE(  43)								max3 = ::Math_obj::ceil(dy3);
            							}
            						}
HXLINE(  78)						int ii_min41 = min19;
HXDLIN(  78)						int ii_max41 = max3;
HXDLIN(  78)						 ::pi_xy::iter::IntIterStart boundY1 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min41,ii_max41);
HXDLIN(  78)						int minX1 = boundX1->start;
HXDLIN(  78)						int wid1 = ((boundX1->max - boundX1->start) + 1);
HXDLIN(  78)						int minY1 = boundY1->start;
HXDLIN(  78)						int hi1 = ((boundY1->max - boundY1->start) + 1);
HXDLIN(  78)						 ::Dynamic imageType6 = null();
HXDLIN(  78)						 ::pi_xy::ImageStruct this117 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  78)						if (::hx::IsNull( imageType6 )) {
HXLINE(  54)							imageType6 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE(  78)						::Dynamic _hx_tmp42;
HXDLIN(  78)						switch((int)(( (int)(imageType6) ))){
            							case (int)0: {
HXDLIN(  78)								 ::iterMagic::BytesImg byt6 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  78)								 ::iterMagic::BytesImg b37 = byt6;
HXDLIN(  78)								{
HXDLIN(  78)									b37->width = wid1;
HXDLIN(  78)									b37->height = hi1;
HXDLIN(  78)									b37->length = ::Std_obj::_hx_int(( (Float)((wid1 * hi1)) ));
HXDLIN(  78)									b37->data = ::haxe::io::Bytes_obj::alloc((b37->length * 4));
HXDLIN(  78)									{
HXDLIN(  78)										int len12 = b37->length;
HXDLIN(  78)										int w9 = 0;
HXDLIN(  78)										{
HXDLIN(  78)											int _g104 = 0;
HXDLIN(  78)											int _g105 = b37->height;
HXDLIN(  78)											while((_g104 < _g105)){
HXDLIN(  78)												_g104 = (_g104 + 1);
HXDLIN(  78)												int y18 = (_g104 - 1);
HXDLIN(  78)												{
HXDLIN(  78)													int _g106 = 0;
HXDLIN(  78)													int _g107 = b37->width;
HXDLIN(  78)													while((_g106 < _g107)){
HXDLIN(  78)														_g106 = (_g106 + 1);
HXDLIN(  78)														int x18 = (_g106 - 1);
HXDLIN(  78)														{
HXDLIN(  78)															w9 = (w9 + 1);
HXDLIN(  78)															b37->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  78)														{
HXDLIN(  78)															w9 = (w9 + 1);
HXDLIN(  78)															b37->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  78)														{
HXDLIN(  78)															w9 = (w9 + 1);
HXDLIN(  78)															b37->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  78)														{
HXDLIN(  78)															w9 = (w9 + 1);
HXDLIN(  78)															b37->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  78)								_hx_tmp42 = b37;
            							}
            							break;
            							case (int)1: {
HXDLIN(  78)								 ::iterMagic::ArrIntImg arrI6 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)								 ::iterMagic::ArrIntImg a30 = arrI6;
HXDLIN(  78)								{
HXDLIN(  78)									a30->width = wid1;
HXDLIN(  78)									a30->height = hi1;
HXDLIN(  78)									a30->data = ::Array_obj< int >::__new(0);
HXDLIN(  78)									a30->length = ::Std_obj::_hx_int(( (Float)((wid1 * hi1)) ));
HXDLIN(  78)									{
HXDLIN(  78)										int _g108 = 0;
HXDLIN(  78)										int _g109 = a30->length;
HXDLIN(  78)										while((_g108 < _g109)){
HXDLIN(  78)											_g108 = (_g108 + 1);
HXDLIN(  78)											int i42 = (_g108 - 1);
HXDLIN(  78)											a30->data[i42] = 0;
            										}
            									}
            								}
HXDLIN(  78)								_hx_tmp42 = a30;
            							}
            							break;
            							case (int)2: {
HXDLIN(  78)								 ::iterMagic::U32ArrImg u32a6 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  78)								 ::iterMagic::U32ArrImg b38 = u32a6;
HXDLIN(  78)								{
HXDLIN(  78)									b38->width = wid1;
HXDLIN(  78)									b38->height = hi1;
HXDLIN(  78)									b38->length = ::Std_obj::_hx_int(( (Float)((wid1 * hi1)) ));
HXDLIN(  78)									int size6 = (b38->length * 4);
HXDLIN(  78)									b38->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size6),0,size6);
HXDLIN(  78)									{
HXDLIN(  78)										int _g110 = 0;
HXDLIN(  78)										int _g111 = b38->length;
HXDLIN(  78)										while((_g110 < _g111)){
HXDLIN(  78)											_g110 = (_g110 + 1);
HXDLIN(  78)											int i43 = (_g110 - 1);
HXDLIN(  78)											{
HXDLIN(  78)												 ::haxe::io::ArrayBufferViewImpl this118 = b38->data;
HXDLIN(  78)												bool _hx_tmp43;
HXDLIN(  78)												if ((i43 >= 0)) {
HXDLIN(  78)													_hx_tmp43 = (i43 < (this118->byteLength >> 2));
            												}
            												else {
HXDLIN(  78)													_hx_tmp43 = false;
            												}
HXDLIN(  78)												if (_hx_tmp43) {
HXDLIN(  78)													 ::haxe::io::Bytes _this6 = this118->bytes;
HXDLIN(  78)													int pos6 = ((i43 << 2) + this118->byteOffset);
HXDLIN(  78)													_this6->b[pos6] = ( (unsigned char)(0) );
HXDLIN(  78)													_this6->b[(pos6 + 1)] = ( (unsigned char)(0) );
HXDLIN(  78)													_this6->b[(pos6 + 2)] = ( (unsigned char)(0) );
HXDLIN(  78)													_this6->b[(pos6 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN(  78)								_hx_tmp42 = b38;
            							}
            							break;
            							case (int)3: {
HXDLIN(  78)								 ::iterMagic::VecIntImg vec6 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)								 ::iterMagic::VecIntImg v13 = vec6;
HXDLIN(  78)								{
HXDLIN(  78)									v13->width = wid1;
HXDLIN(  78)									v13->height = hi1;
HXDLIN(  78)									v13->length = ::Std_obj::_hx_int(( (Float)((wid1 * hi1)) ));
HXDLIN(  78)									v13->data = ::Array_obj< int >::__new(v13->length);
HXDLIN(  78)									{
HXDLIN(  78)										int _g112 = 0;
HXDLIN(  78)										int _g113 = v13->length;
HXDLIN(  78)										while((_g112 < _g113)){
HXDLIN(  78)											_g112 = (_g112 + 1);
HXDLIN(  78)											int i44 = (_g112 - 1);
HXDLIN(  78)											v13->data->__unsafe_set(i44,0);
            										}
            									}
            								}
HXDLIN(  78)								_hx_tmp42 = v13;
            							}
            							break;
            							case (int)4: {
HXDLIN(  78)								 ::iterMagic::StackIntImg sInt6 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)								 ::iterMagic::StackIntImg b39 = sInt6;
HXDLIN(  78)								{
HXDLIN(  78)									b39->width = wid1;
HXDLIN(  78)									b39->height = hi1;
HXDLIN(  78)									b39->length = ::Std_obj::_hx_int(( (Float)((wid1 * hi1)) ));
HXDLIN(  78)									b39->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  78)									{
HXDLIN(  78)										int len13 = b39->length;
HXDLIN(  78)										 ::haxe::ds::GenericStack_Int d6 = b39->data;
HXDLIN(  78)										if (::hx::IsNull( d6->head )) {
HXDLIN(  78)											int _g114 = 0;
HXDLIN(  78)											int _g115 = len13;
HXDLIN(  78)											while((_g114 < _g115)){
HXDLIN(  78)												_g114 = (_g114 + 1);
HXDLIN(  78)												int i45 = (_g114 - 1);
HXDLIN(  78)												d6->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d6->head);
            											}
            										}
            										else {
HXDLIN(  78)											int _g116 = 0;
HXDLIN(  78)											int _g117 = len13;
HXDLIN(  78)											while((_g116 < _g117)){
HXDLIN(  78)												_g116 = (_g116 + 1);
HXDLIN(  78)												int i46 = (_g116 - 1);
HXDLIN(  78)												{
HXDLIN(  78)													 ::haxe::ds::GenericCell_Int l6 = b39->data->head;
HXDLIN(  78)													 ::haxe::ds::GenericCell_Int prev6 = null();
HXDLIN(  78)													{
HXDLIN(  78)														int _g118 = 0;
HXDLIN(  78)														int _g119 = i46;
HXDLIN(  78)														while((_g118 < _g119)){
HXDLIN(  78)															_g118 = (_g118 + 1);
HXDLIN(  78)															int i47 = (_g118 - 1);
HXLINE( 345)															prev6 = l6;
HXLINE( 346)															l6 = l6->next;
            														}
            													}
HXLINE(  78)													if (::hx::IsNull( prev6 )) {
HXDLIN(  78)														b39->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN(  78)														l6 = null();
            													}
            													else {
HXDLIN(  78)														prev6->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN(  78)														l6 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  78)								_hx_tmp42 = b39;
            							}
            							break;
            						}
HXDLIN(  78)						this117->image = _hx_tmp42;
HXDLIN(  78)						this117->width = wid1;
HXDLIN(  78)						this117->height = hi1;
HXDLIN(  78)						this117->imageType = ( (int)(imageType6) );
HXDLIN(  78)						 ::pi_xy::ImageStruct nextImage4 = this117;
HXDLIN(  78)						nextImage4->transparent = true;
HXDLIN(  78)						if ((minX1 < ((Float)0.))) {
HXDLIN(  78)							ax3 = (ax3 - ( (Float)(minX1) ));
HXDLIN(  78)							bx3 = (bx3 - ( (Float)(minX1) ));
HXDLIN(  78)							cx3 = (cx3 - ( (Float)(minX1) ));
HXDLIN(  78)							dx3 = (dx3 - ( (Float)(minX1) ));
            						}
HXDLIN(  78)						if ((minY1 < ((Float)0.))) {
HXDLIN(  78)							ay3 = (ay3 - ( (Float)(minY1) ));
HXDLIN(  78)							by3 = (by3 - ( (Float)(minY1) ));
HXDLIN(  78)							cy3 = (cy3 - ( (Float)(minY1) ));
HXDLIN(  78)							dy3 = (dy3 - ( (Float)(minY1) ));
            						}
HXDLIN(  78)						{
HXDLIN(  78)							 ::pi_xy::ImageStruct this119 = nextImage4;
HXDLIN(  78)							Float win_x1 = ( (Float)(0) );
HXDLIN(  78)							Float win_y1 = ( (Float)(0) );
HXDLIN(  78)							Float win_width1 = ( (Float)(this116->width) );
HXDLIN(  78)							Float win_height1 = ( (Float)(this116->height) );
HXDLIN(  78)							{
HXDLIN(  78)								Float bu3 = ((Float)1.);
HXDLIN(  78)								Float bv3 = ((Float)0.);
HXDLIN(  78)								Float cu1 = ((Float)1.);
HXDLIN(  78)								Float cv1 = ((Float)1.);
HXDLIN(  78)								Float du1 = ((Float)0.);
HXDLIN(  78)								Float dv1 = ((Float)1.);
HXDLIN(  78)								Float au2 = ((Float)0.);
HXDLIN(  78)								Float av2 = ((Float)0.);
HXDLIN(  78)								Float bu4 = bu3;
HXDLIN(  78)								Float bv4 = bv3;
HXDLIN(  78)								bool hasUndo2 = false;
HXDLIN(  78)								Float temp10 = au2;
HXLINE( 422)								au2 = bu4;
HXLINE( 423)								bu4 = temp10;
HXLINE( 424)								temp10 = av2;
HXLINE( 425)								av2 = bv4;
HXLINE( 426)								bv4 = temp10;
HXLINE(  78)								Float bcx2 = (bx3 - dx3);
HXDLIN(  78)								Float bcy2 = (by3 - dy3);
HXDLIN(  78)								Float acx2 = (ax3 - dx3);
HXDLIN(  78)								Float acy2 = (ay3 - dy3);
HXDLIN(  78)								Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN(  78)								Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN(  78)								Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN(  78)								Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN(  78)								 ::pi_xy::iter::IntIterStart xIter32;
HXDLIN(  78)								if ((ax3 > bx3)) {
HXDLIN(  78)									if ((ax3 > dx3)) {
HXDLIN(  78)										int min20;
HXDLIN(  78)										if ((bx3 > dx3)) {
HXDLIN(  78)											min20 = ::Math_obj::floor(dx3);
            										}
            										else {
HXDLIN(  78)											min20 = ::Math_obj::floor(bx3);
            										}
HXDLIN(  78)										int ii_min42 = min20;
HXDLIN(  78)										int ii_max42 = ::Math_obj::ceil(ax3);
HXDLIN(  78)										xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min42,ii_max42);
            									}
            									else {
HXDLIN(  78)										int ii_min43 = ::Math_obj::floor(bx3);
HXDLIN(  78)										int ii_max43 = ::Math_obj::ceil(dx3);
HXDLIN(  78)										xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min43,ii_max43);
            									}
            								}
            								else {
HXDLIN(  78)									if ((bx3 > dx3)) {
HXDLIN(  78)										int min21;
HXDLIN(  78)										if ((ax3 > dx3)) {
HXDLIN(  78)											min21 = ::Math_obj::floor(dx3);
            										}
            										else {
HXDLIN(  78)											min21 = ::Math_obj::ceil(ax3);
            										}
HXDLIN(  78)										int ii_min44 = min21;
HXDLIN(  78)										int ii_max44 = ::Math_obj::ceil(bx3);
HXDLIN(  78)										xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min44,ii_max44);
            									}
            									else {
HXDLIN(  78)										int ii_min45 = ::Math_obj::floor(ax3);
HXDLIN(  78)										int ii_max45 = ::Math_obj::ceil(dx3);
HXDLIN(  78)										xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min45,ii_max45);
            									}
            								}
HXDLIN(  78)								 ::pi_xy::iter::IntIterStart yIter32;
HXDLIN(  78)								if ((ay3 > by3)) {
HXDLIN(  78)									if ((ay3 > dy3)) {
HXDLIN(  78)										int min22;
HXDLIN(  78)										if ((by3 > dy3)) {
HXDLIN(  78)											min22 = ::Math_obj::floor(dy3);
            										}
            										else {
HXDLIN(  78)											min22 = ::Math_obj::floor(by3);
            										}
HXDLIN(  78)										int ii_min46 = min22;
HXDLIN(  78)										int ii_max46 = ::Math_obj::ceil(ay3);
HXDLIN(  78)										yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min46,ii_max46);
            									}
            									else {
HXDLIN(  78)										int ii_min47 = ::Math_obj::floor(by3);
HXDLIN(  78)										int ii_max47 = ::Math_obj::ceil(dy3);
HXDLIN(  78)										yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min47,ii_max47);
            									}
            								}
            								else {
HXDLIN(  78)									if ((by3 > dy3)) {
HXDLIN(  78)										int min23;
HXDLIN(  78)										if ((ay3 > dy3)) {
HXDLIN(  78)											min23 = ::Math_obj::floor(dy3);
            										}
            										else {
HXDLIN(  78)											min23 = ::Math_obj::ceil(ay3);
            										}
HXDLIN(  78)										int ii_min48 = min23;
HXDLIN(  78)										int ii_max48 = ::Math_obj::ceil(by3);
HXDLIN(  78)										yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min48,ii_max48);
            									}
            									else {
HXDLIN(  78)										int ii_min49 = ::Math_obj::floor(ay3);
HXDLIN(  78)										int ii_max49 = ::Math_obj::ceil(dy3);
HXDLIN(  78)										yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min49,ii_max49);
            									}
            								}
HXDLIN(  78)								 ::pi_xy::ImageStruct undoImage6 = null();
HXDLIN(  78)								if (hasUndo2) {
HXDLIN(  78)									int width5 = ((xIter32->max - xIter32->start) + 1);
HXDLIN(  78)									int height5 = ((yIter32->max - yIter32->start) + 1);
HXDLIN(  78)									 ::Dynamic imageType7 = null();
HXDLIN(  78)									 ::pi_xy::ImageStruct this120 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  78)									if (::hx::IsNull( imageType7 )) {
HXLINE(  54)										imageType7 = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE(  78)									::Dynamic undoImage7;
HXDLIN(  78)									switch((int)(( (int)(imageType7) ))){
            										case (int)0: {
HXDLIN(  78)											 ::iterMagic::BytesImg byt7 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  78)											 ::iterMagic::BytesImg b40 = byt7;
HXDLIN(  78)											{
HXDLIN(  78)												b40->width = width5;
HXDLIN(  78)												b40->height = height5;
HXDLIN(  78)												b40->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN(  78)												b40->data = ::haxe::io::Bytes_obj::alloc((b40->length * 4));
HXDLIN(  78)												{
HXDLIN(  78)													int len14 = b40->length;
HXDLIN(  78)													int w10 = 0;
HXDLIN(  78)													{
HXDLIN(  78)														int _g120 = 0;
HXDLIN(  78)														int _g121 = b40->height;
HXDLIN(  78)														while((_g120 < _g121)){
HXDLIN(  78)															_g120 = (_g120 + 1);
HXDLIN(  78)															int y19 = (_g120 - 1);
HXDLIN(  78)															{
HXDLIN(  78)																int _g122 = 0;
HXDLIN(  78)																int _g123 = b40->width;
HXDLIN(  78)																while((_g122 < _g123)){
HXDLIN(  78)																	_g122 = (_g122 + 1);
HXDLIN(  78)																	int x19 = (_g122 - 1);
HXDLIN(  78)																	{
HXDLIN(  78)																		w10 = (w10 + 1);
HXDLIN(  78)																		b40->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  78)																	{
HXDLIN(  78)																		w10 = (w10 + 1);
HXDLIN(  78)																		b40->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  78)																	{
HXDLIN(  78)																		w10 = (w10 + 1);
HXDLIN(  78)																		b40->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  78)																	{
HXDLIN(  78)																		w10 = (w10 + 1);
HXDLIN(  78)																		b40->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  78)											undoImage7 = b40;
            										}
            										break;
            										case (int)1: {
HXDLIN(  78)											 ::iterMagic::ArrIntImg arrI7 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)											 ::iterMagic::ArrIntImg a37 = arrI7;
HXDLIN(  78)											{
HXDLIN(  78)												a37->width = width5;
HXDLIN(  78)												a37->height = height5;
HXDLIN(  78)												a37->data = ::Array_obj< int >::__new(0);
HXDLIN(  78)												a37->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN(  78)												{
HXDLIN(  78)													int _g124 = 0;
HXDLIN(  78)													int _g125 = a37->length;
HXDLIN(  78)													while((_g124 < _g125)){
HXDLIN(  78)														_g124 = (_g124 + 1);
HXDLIN(  78)														int i48 = (_g124 - 1);
HXDLIN(  78)														a37->data[i48] = 0;
            													}
            												}
            											}
HXDLIN(  78)											undoImage7 = a37;
            										}
            										break;
            										case (int)2: {
HXDLIN(  78)											 ::iterMagic::U32ArrImg u32a7 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  78)											 ::iterMagic::U32ArrImg b41 = u32a7;
HXDLIN(  78)											{
HXDLIN(  78)												b41->width = width5;
HXDLIN(  78)												b41->height = height5;
HXDLIN(  78)												b41->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN(  78)												int size7 = (b41->length * 4);
HXDLIN(  78)												b41->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size7),0,size7);
HXDLIN(  78)												{
HXDLIN(  78)													int _g126 = 0;
HXDLIN(  78)													int _g127 = b41->length;
HXDLIN(  78)													while((_g126 < _g127)){
HXDLIN(  78)														_g126 = (_g126 + 1);
HXDLIN(  78)														int i49 = (_g126 - 1);
HXDLIN(  78)														{
HXDLIN(  78)															 ::haxe::io::ArrayBufferViewImpl this121 = b41->data;
HXDLIN(  78)															bool undoImage8;
HXDLIN(  78)															if ((i49 >= 0)) {
HXDLIN(  78)																undoImage8 = (i49 < (this121->byteLength >> 2));
            															}
            															else {
HXDLIN(  78)																undoImage8 = false;
            															}
HXDLIN(  78)															if (undoImage8) {
HXDLIN(  78)																 ::haxe::io::Bytes _this7 = this121->bytes;
HXDLIN(  78)																int pos7 = ((i49 << 2) + this121->byteOffset);
HXDLIN(  78)																_this7->b[pos7] = ( (unsigned char)(0) );
HXDLIN(  78)																_this7->b[(pos7 + 1)] = ( (unsigned char)(0) );
HXDLIN(  78)																_this7->b[(pos7 + 2)] = ( (unsigned char)(0) );
HXDLIN(  78)																_this7->b[(pos7 + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN(  78)											undoImage7 = b41;
            										}
            										break;
            										case (int)3: {
HXDLIN(  78)											 ::iterMagic::VecIntImg vec7 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)											 ::iterMagic::VecIntImg v14 = vec7;
HXDLIN(  78)											{
HXDLIN(  78)												v14->width = width5;
HXDLIN(  78)												v14->height = height5;
HXDLIN(  78)												v14->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN(  78)												v14->data = ::Array_obj< int >::__new(v14->length);
HXDLIN(  78)												{
HXDLIN(  78)													int _g128 = 0;
HXDLIN(  78)													int _g129 = v14->length;
HXDLIN(  78)													while((_g128 < _g129)){
HXDLIN(  78)														_g128 = (_g128 + 1);
HXDLIN(  78)														int i50 = (_g128 - 1);
HXDLIN(  78)														v14->data->__unsafe_set(i50,0);
            													}
            												}
            											}
HXDLIN(  78)											undoImage7 = v14;
            										}
            										break;
            										case (int)4: {
HXDLIN(  78)											 ::iterMagic::StackIntImg sInt7 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)											 ::iterMagic::StackIntImg b42 = sInt7;
HXDLIN(  78)											{
HXDLIN(  78)												b42->width = width5;
HXDLIN(  78)												b42->height = height5;
HXDLIN(  78)												b42->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN(  78)												b42->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  78)												{
HXDLIN(  78)													int len15 = b42->length;
HXDLIN(  78)													 ::haxe::ds::GenericStack_Int d7 = b42->data;
HXDLIN(  78)													if (::hx::IsNull( d7->head )) {
HXDLIN(  78)														int _g130 = 0;
HXDLIN(  78)														int _g131 = len15;
HXDLIN(  78)														while((_g130 < _g131)){
HXDLIN(  78)															_g130 = (_g130 + 1);
HXDLIN(  78)															int i51 = (_g130 - 1);
HXDLIN(  78)															d7->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d7->head);
            														}
            													}
            													else {
HXDLIN(  78)														int _g132 = 0;
HXDLIN(  78)														int _g133 = len15;
HXDLIN(  78)														while((_g132 < _g133)){
HXDLIN(  78)															_g132 = (_g132 + 1);
HXDLIN(  78)															int i52 = (_g132 - 1);
HXDLIN(  78)															{
HXDLIN(  78)																 ::haxe::ds::GenericCell_Int l7 = b42->data->head;
HXDLIN(  78)																 ::haxe::ds::GenericCell_Int prev7 = null();
HXDLIN(  78)																{
HXDLIN(  78)																	int _g134 = 0;
HXDLIN(  78)																	int _g135 = i52;
HXDLIN(  78)																	while((_g134 < _g135)){
HXDLIN(  78)																		_g134 = (_g134 + 1);
HXDLIN(  78)																		int i53 = (_g134 - 1);
HXLINE( 345)																		prev7 = l7;
HXLINE( 346)																		l7 = l7->next;
            																	}
            																}
HXLINE(  78)																if (::hx::IsNull( prev7 )) {
HXDLIN(  78)																	b42->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l7->next);
HXDLIN(  78)																	l7 = null();
            																}
            																else {
HXDLIN(  78)																	prev7->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l7->next);
HXDLIN(  78)																	l7 = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  78)											undoImage7 = b42;
            										}
            										break;
            									}
HXDLIN(  78)									this120->image = undoImage7;
HXDLIN(  78)									this120->width = width5;
HXDLIN(  78)									this120->height = height5;
HXDLIN(  78)									this120->imageType = ( (int)(imageType7) );
HXDLIN(  78)									undoImage6 = this120;
HXDLIN(  78)									{
HXDLIN(  78)										int rectLeft2 = xIter32->start;
HXDLIN(  78)										int rectTop2 = yIter32->start;
HXDLIN(  78)										int rectRight2 = xIter32->max;
HXDLIN(  78)										bool forceClear2 = false;
HXDLIN(  78)										{
HXDLIN(  78)											int _g136 = rectTop2;
HXDLIN(  78)											int _g137 = yIter32->max;
HXDLIN(  78)											while((_g136 < _g137)){
HXDLIN(  78)												_g136 = (_g136 + 1);
HXDLIN(  78)												int dy4 = (_g136 - 1);
HXDLIN(  78)												{
HXDLIN(  78)													int _g138 = rectLeft2;
HXDLIN(  78)													int _g139 = rectRight2;
HXDLIN(  78)													while((_g138 < _g139)){
HXDLIN(  78)														_g138 = (_g138 + 1);
HXDLIN(  78)														int dx4 = (_g138 - 1);
HXDLIN(  78)														::Dynamic this122 = this119->image;
HXDLIN(  78)														int index18;
HXDLIN(  78)														if (this119->useVirtualPos) {
HXDLIN(  78)															index18 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this119->virtualY) * ( (Float)(this119->width) )) + dx4) - this119->virtualX));
            														}
            														else {
HXDLIN(  78)															index18 = ::Std_obj::_hx_int(( (Float)(((dy4 * this119->width) + dx4)) ));
            														}
HXDLIN(  78)														int c20 = ::iterMagic::Iimg_obj::get(this122,index18);
HXDLIN(  78)														int col4;
HXDLIN(  78)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)															col4 = ((((((c20 >> 24) & 255) << 24) | ((c20 & 255) << 16)) | (((c20 >> 8) & 255) << 8)) | ((c20 >> 16) & 255));
            														}
            														else {
HXDLIN(  78)															col4 = c20;
            														}
HXDLIN(  78)														bool _hx_tmp44;
HXDLIN(  78)														if (this119->useMask) {
HXDLIN(  78)															_hx_tmp44 = ::hx::IsNotNull( this119->mask );
            														}
            														else {
HXDLIN(  78)															_hx_tmp44 = false;
            														}
HXDLIN(  78)														if (_hx_tmp44) {
HXDLIN(  78)															 ::pi_xy::ImageStruct this123 = this119->mask;
HXDLIN(  78)															::Dynamic this124 = this123->image;
HXDLIN(  78)															int index19;
HXDLIN(  78)															if (this123->useVirtualPos) {
HXDLIN(  78)																index19 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this123->virtualY) * ( (Float)(this123->width) )) + dx4) - this123->virtualX));
            															}
            															else {
HXDLIN(  78)																index19 = ::Std_obj::_hx_int(( (Float)(((dy4 * this123->width) + dx4)) ));
            															}
HXDLIN(  78)															int c21 = ::iterMagic::Iimg_obj::get(this124,index19);
HXDLIN(  78)															int v15;
HXDLIN(  78)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																v15 = ((((((c21 >> 24) & 255) << 24) | ((c21 & 255) << 16)) | (((c21 >> 8) & 255) << 8)) | ((c21 >> 16) & 255));
            															}
            															else {
HXDLIN(  78)																v15 = c21;
            															}
HXDLIN(  78)															int maskPixel2 = v15;
HXDLIN(  78)															int this125 = col4;
HXDLIN(  78)															if ((maskPixel2 == 0)) {
HXDLIN(  78)																col4 = this125;
            															}
            															else {
HXDLIN(  78)																Float m02;
HXDLIN(  78)																int this126 = ((maskPixel2 >> 24) & 255);
HXDLIN(  78)																if ((this126 == 0)) {
HXDLIN(  78)																	m02 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	m02 = (( (Float)(this126) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float m12;
HXDLIN(  78)																int this127 = ((maskPixel2 >> 16) & 255);
HXDLIN(  78)																if ((this127 == 0)) {
HXDLIN(  78)																	m12 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	m12 = (( (Float)(this127) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float m22;
HXDLIN(  78)																int this128 = ((maskPixel2 >> 8) & 255);
HXDLIN(  78)																if ((this128 == 0)) {
HXDLIN(  78)																	m22 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	m22 = (( (Float)(this128) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float m32;
HXDLIN(  78)																int this129 = (maskPixel2 & 255);
HXDLIN(  78)																if ((this129 == 0)) {
HXDLIN(  78)																	m32 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	m32 = (( (Float)(this129) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this125 >> 24) & 255)) )));
HXDLIN(  78)																int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this125 >> 16) & 255)) )));
HXDLIN(  78)																int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this125 >> 8) & 255)) )));
HXDLIN(  78)																int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this125 & 255)) )));
HXDLIN(  78)																col4 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  78)														if ((col4 != 0)) {
HXDLIN(  78)															int x20 = (dx4 - rectLeft2);
HXDLIN(  78)															int y20 = (dy4 - rectTop2);
HXDLIN(  78)															int c22 = col4;
HXDLIN(  78)															bool _hx_tmp45;
HXDLIN(  78)															if ((((c22 >> 24) & 255) < 254)) {
HXDLIN(  78)																_hx_tmp45 = undoImage6->transparent;
            															}
            															else {
HXDLIN(  78)																_hx_tmp45 = false;
            															}
HXDLIN(  78)															if (_hx_tmp45) {
HXDLIN(  78)																int location7;
HXDLIN(  78)																if (undoImage6->useVirtualPos) {
HXDLIN(  78)																	location7 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x20) - undoImage6->virtualX));
            																}
            																else {
HXDLIN(  78)																	location7 = ::Std_obj::_hx_int(( (Float)(((y20 * undoImage6->width) + x20)) ));
            																}
HXDLIN(  78)																int this130 = ::iterMagic::Iimg_obj::get(undoImage6->image,location7);
HXDLIN(  78)																int this131;
HXDLIN(  78)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																	this131 = ((((((this130 >> 24) & 255) << 24) | ((this130 & 255) << 16)) | (((this130 >> 8) & 255) << 8)) | ((this130 >> 16) & 255));
            																}
            																else {
HXDLIN(  78)																	this131 = this130;
            																}
HXDLIN(  78)																Float a112;
HXDLIN(  78)																int this132 = ((this131 >> 24) & 255);
HXDLIN(  78)																if ((this132 == 0)) {
HXDLIN(  78)																	a112 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	a112 = (( (Float)(this132) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float r18;
HXDLIN(  78)																int this133 = ((this131 >> 16) & 255);
HXDLIN(  78)																if ((this133 == 0)) {
HXDLIN(  78)																	r18 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	r18 = (( (Float)(this133) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float g17;
HXDLIN(  78)																int this134 = ((this131 >> 8) & 255);
HXDLIN(  78)																if ((this134 == 0)) {
HXDLIN(  78)																	g17 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	g17 = (( (Float)(this134) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float b114;
HXDLIN(  78)																int this135 = (this131 & 255);
HXDLIN(  78)																if ((this135 == 0)) {
HXDLIN(  78)																	b114 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	b114 = (( (Float)(this135) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float a210;
HXDLIN(  78)																int this136 = ((col4 >> 24) & 255);
HXDLIN(  78)																if ((this136 == 0)) {
HXDLIN(  78)																	a210 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	a210 = (( (Float)(this136) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float r27;
HXDLIN(  78)																int this137 = ((col4 >> 16) & 255);
HXDLIN(  78)																if ((this137 == 0)) {
HXDLIN(  78)																	r27 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	r27 = (( (Float)(this137) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float g27;
HXDLIN(  78)																int this138 = ((col4 >> 8) & 255);
HXDLIN(  78)																if ((this138 == 0)) {
HXDLIN(  78)																	g27 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	g27 = (( (Float)(this138) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float b212;
HXDLIN(  78)																int this139 = (col4 & 255);
HXDLIN(  78)																if ((this139 == 0)) {
HXDLIN(  78)																	b212 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	b212 = (( (Float)(this139) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float a38 = (a112 * (( (Float)(1) ) - a210));
HXDLIN(  78)																int r19 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a38) + (r27 * a210))));
HXDLIN(  78)																int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a38) + (g27 * a210))));
HXDLIN(  78)																int b43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a38) + (b212 * a210))));
HXDLIN(  78)																int a39 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a210)));
HXDLIN(  78)																int blended7 = ((((a39 << 24) | (r19 << 16)) | (g9 << 8)) | b43);
HXDLIN(  78)																{
HXDLIN(  78)																	int _hx_tmp46;
HXDLIN(  78)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																		_hx_tmp46 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            																	}
            																	else {
HXDLIN(  78)																		_hx_tmp46 = blended7;
            																	}
HXDLIN(  78)																	::iterMagic::Iimg_obj::set(undoImage6->image,location7,_hx_tmp46);
            																}
            															}
            															else {
HXDLIN(  78)																::Dynamic this140 = undoImage6->image;
HXDLIN(  78)																int index20;
HXDLIN(  78)																if (undoImage6->useVirtualPos) {
HXDLIN(  78)																	index20 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x20) - undoImage6->virtualX));
            																}
            																else {
HXDLIN(  78)																	index20 = ::Std_obj::_hx_int(( (Float)(((y20 * undoImage6->width) + x20)) ));
            																}
HXDLIN(  78)																int _hx_tmp47;
HXDLIN(  78)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																	_hx_tmp47 = ((((((c22 >> 24) & 255) << 24) | ((c22 & 255) << 16)) | (((c22 >> 8) & 255) << 8)) | ((c22 >> 16) & 255));
            																}
            																else {
HXDLIN(  78)																	_hx_tmp47 = c22;
            																}
HXDLIN(  78)																::iterMagic::Iimg_obj::set(this140,index20,_hx_tmp47);
            															}
            														}
            														else {
HXDLIN(  78)															if (forceClear2) {
HXDLIN(  78)																::Dynamic this141 = undoImage6->image;
HXDLIN(  78)																int x21 = (dx4 - rectLeft2);
HXDLIN(  78)																int y21 = (dy4 - rectTop2);
HXDLIN(  78)																int index21;
HXDLIN(  78)																if (undoImage6->useVirtualPos) {
HXDLIN(  78)																	index21 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x21) - undoImage6->virtualX));
            																}
            																else {
HXDLIN(  78)																	index21 = ::Std_obj::_hx_int(( (Float)(((y21 * undoImage6->width) + x21)) ));
            																}
HXDLIN(  78)																::iterMagic::Iimg_obj::set(this141,index21,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  78)								{
HXDLIN(  78)									int _g_min4 = xIter32->start;
HXDLIN(  78)									int _g_max4 = xIter32->max;
HXDLIN(  78)									while((_g_min4 < _g_max4)){
HXDLIN(  78)										_g_min4 = (_g_min4 + 1);
HXDLIN(  78)										int px2 = (_g_min4 - 1);
HXDLIN(  78)										Float pcx2 = (( (Float)(px2) ) - dx3);
HXDLIN(  78)										{
HXDLIN(  78)											int _g_min5 = yIter32->start;
HXDLIN(  78)											int _g_max5 = yIter32->max;
HXDLIN(  78)											while((_g_min5 < _g_max5)){
HXDLIN(  78)												_g_min5 = (_g_min5 + 1);
HXDLIN(  78)												int py2 = (_g_min5 - 1);
HXDLIN(  78)												Float pcy2 = (( (Float)(py2) ) - dy3);
HXDLIN(  78)												Float dot312 = ((pcx2 * bcx2) + (pcy2 * bcy2));
HXDLIN(  78)												Float dot322 = ((pcx2 * acx2) + (pcy2 * acy2));
HXDLIN(  78)												Float ratioA2 = (((dot222 * dot312) - (dot122 * dot322)) * denom12);
HXDLIN(  78)												Float ratioB2 = (((dot112 * dot322) - (dot122 * dot312)) * denom12);
HXDLIN(  78)												Float ratioC2 = ((((Float)1.0) - ratioB2) - ratioA2);
HXDLIN(  78)												bool _hx_tmp48;
HXDLIN(  78)												bool _hx_tmp49;
HXDLIN(  78)												if ((ratioA2 >= 0)) {
HXDLIN(  78)													_hx_tmp49 = (ratioB2 >= 0);
            												}
            												else {
HXDLIN(  78)													_hx_tmp49 = false;
            												}
HXDLIN(  78)												if (_hx_tmp49) {
HXDLIN(  78)													_hx_tmp48 = (ratioC2 >= 0);
            												}
            												else {
HXDLIN(  78)													_hx_tmp48 = false;
            												}
HXDLIN(  78)												if (_hx_tmp48) {
HXDLIN(  78)													Float u2 = (((au2 * ratioA2) + (bu4 * ratioB2)) + (du1 * ratioC2));
HXDLIN(  78)													Float v16 = (((av2 * ratioA2) + (bv4 * ratioB2)) + (dv1 * ratioC2));
HXDLIN(  78)													int x22 = ::Std_obj::_hx_int(((u2 * win_width1) + win_x1));
HXDLIN(  78)													int y22 = ::Std_obj::_hx_int(((v16 * win_height1) + win_y1));
HXDLIN(  78)													::Dynamic this142 = this116->image;
HXDLIN(  78)													int index22;
HXDLIN(  78)													if (this116->useVirtualPos) {
HXDLIN(  78)														index22 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - this116->virtualY) * ( (Float)(this116->width) )) + x22) - this116->virtualX));
            													}
            													else {
HXDLIN(  78)														index22 = ::Std_obj::_hx_int(( (Float)(((y22 * this116->width) + x22)) ));
            													}
HXDLIN(  78)													int c23 = ::iterMagic::Iimg_obj::get(this142,index22);
HXDLIN(  78)													int col5;
HXDLIN(  78)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)														col5 = ((((((c23 >> 24) & 255) << 24) | ((c23 & 255) << 16)) | (((c23 >> 8) & 255) << 8)) | ((c23 >> 16) & 255));
            													}
            													else {
HXDLIN(  78)														col5 = c23;
            													}
HXDLIN(  78)													{
HXDLIN(  78)														int c24 = col5;
HXDLIN(  78)														bool _hx_tmp50;
HXDLIN(  78)														if ((((c24 >> 24) & 255) < 254)) {
HXDLIN(  78)															_hx_tmp50 = this119->transparent;
            														}
            														else {
HXDLIN(  78)															_hx_tmp50 = false;
            														}
HXDLIN(  78)														if (_hx_tmp50) {
HXDLIN(  78)															int location8;
HXDLIN(  78)															if (this119->useVirtualPos) {
HXDLIN(  78)																location8 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - this119->virtualY) * ( (Float)(this119->width) )) + px2) - this119->virtualX));
            															}
            															else {
HXDLIN(  78)																location8 = ::Std_obj::_hx_int(( (Float)(((py2 * this119->width) + px2)) ));
            															}
HXDLIN(  78)															int this143 = ::iterMagic::Iimg_obj::get(this119->image,location8);
HXDLIN(  78)															int this144;
HXDLIN(  78)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																this144 = ((((((this143 >> 24) & 255) << 24) | ((this143 & 255) << 16)) | (((this143 >> 8) & 255) << 8)) | ((this143 >> 16) & 255));
            															}
            															else {
HXDLIN(  78)																this144 = this143;
            															}
HXDLIN(  78)															Float a113;
HXDLIN(  78)															int this145 = ((this144 >> 24) & 255);
HXDLIN(  78)															if ((this145 == 0)) {
HXDLIN(  78)																a113 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																a113 = (( (Float)(this145) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float r110;
HXDLIN(  78)															int this146 = ((this144 >> 16) & 255);
HXDLIN(  78)															if ((this146 == 0)) {
HXDLIN(  78)																r110 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																r110 = (( (Float)(this146) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float g18;
HXDLIN(  78)															int this147 = ((this144 >> 8) & 255);
HXDLIN(  78)															if ((this147 == 0)) {
HXDLIN(  78)																g18 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																g18 = (( (Float)(this147) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float b115;
HXDLIN(  78)															int this148 = (this144 & 255);
HXDLIN(  78)															if ((this148 == 0)) {
HXDLIN(  78)																b115 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																b115 = (( (Float)(this148) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float a211;
HXDLIN(  78)															int this149 = ((col5 >> 24) & 255);
HXDLIN(  78)															if ((this149 == 0)) {
HXDLIN(  78)																a211 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																a211 = (( (Float)(this149) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float r28;
HXDLIN(  78)															int this150 = ((col5 >> 16) & 255);
HXDLIN(  78)															if ((this150 == 0)) {
HXDLIN(  78)																r28 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																r28 = (( (Float)(this150) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float g28;
HXDLIN(  78)															int this151 = ((col5 >> 8) & 255);
HXDLIN(  78)															if ((this151 == 0)) {
HXDLIN(  78)																g28 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																g28 = (( (Float)(this151) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float b213;
HXDLIN(  78)															int this152 = (col5 & 255);
HXDLIN(  78)															if ((this152 == 0)) {
HXDLIN(  78)																b213 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																b213 = (( (Float)(this152) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float a310 = (a113 * (( (Float)(1) ) - a211));
HXDLIN(  78)															int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a310) + (r28 * a211))));
HXDLIN(  78)															int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a310) + (g28 * a211))));
HXDLIN(  78)															int b44 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a310) + (b213 * a211))));
HXDLIN(  78)															int a40 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a211)));
HXDLIN(  78)															int blended8 = ((((a40 << 24) | (r20 << 16)) | (g10 << 8)) | b44);
HXDLIN(  78)															{
HXDLIN(  78)																int _hx_tmp51;
HXDLIN(  78)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																	_hx_tmp51 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            																}
            																else {
HXDLIN(  78)																	_hx_tmp51 = blended8;
            																}
HXDLIN(  78)																::iterMagic::Iimg_obj::set(this119->image,location8,_hx_tmp51);
            															}
            														}
            														else {
HXDLIN(  78)															::Dynamic this153 = this119->image;
HXDLIN(  78)															int index23;
HXDLIN(  78)															if (this119->useVirtualPos) {
HXDLIN(  78)																index23 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - this119->virtualY) * ( (Float)(this119->width) )) + px2) - this119->virtualX));
            															}
            															else {
HXDLIN(  78)																index23 = ::Std_obj::_hx_int(( (Float)(((py2 * this119->width) + px2)) ));
            															}
HXDLIN(  78)															int _hx_tmp52;
HXDLIN(  78)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																_hx_tmp52 = ((((((c24 >> 24) & 255) << 24) | ((c24 & 255) << 16)) | (((c24 >> 8) & 255) << 8)) | ((c24 >> 16) & 255));
            															}
            															else {
HXDLIN(  78)																_hx_tmp52 = c24;
            															}
HXDLIN(  78)															::iterMagic::Iimg_obj::set(this153,index23,_hx_tmp52);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  78)								 ::pi_xy::iter::IntIterStart v_yIter32;
HXDLIN(  78)								 ::pi_xy::iter::IntIterStart v_xIter32;
HXDLIN(  78)								int v_undoY2;
HXDLIN(  78)								int v_undoX2;
HXDLIN(  78)								Float v_ty2;
HXDLIN(  78)								Float v_tx2;
HXDLIN(  78)								Float v_t02;
HXDLIN(  78)								Float v_sy2;
HXDLIN(  78)								Float v_sx2;
HXDLIN(  78)								Float v_s02;
HXDLIN(  78)								Float v_A2;
HXDLIN(  78)								Float ax4 = ax3;
HXDLIN(  78)								Float ay4 = ay3;
HXDLIN(  78)								 ::pi_xy::ImageStruct v_undoImage2 = null();
HXDLIN(  78)								Float bx4 = bx3;
HXDLIN(  78)								Float by4 = by3;
HXDLIN(  78)								Float cx4 = dx3;
HXDLIN(  78)								Float cy4 = dy3;
HXDLIN(  78)								bool adjustWinding2 = (((((ax4 * by4) - (bx4 * ay4)) + ((bx4 * cy4) - (cx4 * by4))) + ((cx4 * ay4) - (ax4 * cy4))) > 0);
HXDLIN(  78)								if (!(adjustWinding2)) {
HXDLIN(  78)									Float bx_2 = bx4;
HXDLIN(  78)									Float by_2 = by4;
HXLINE(  24)									bx4 = cx4;
HXLINE(  25)									by4 = cy4;
HXLINE(  26)									cx4 = bx_2;
HXLINE(  27)									cy4 = by_2;
            								}
HXLINE(  78)								Float v_ax2 = ax4;
HXDLIN(  78)								Float v_ay2 = ay4;
HXDLIN(  78)								Float v_bx2 = bx4;
HXDLIN(  78)								Float v_by2 = by4;
HXDLIN(  78)								Float v_cx2 = cx4;
HXDLIN(  78)								Float v_cy2 = cy4;
HXDLIN(  78)								bool v_preCalculated2 = true;
HXDLIN(  78)								{
HXDLIN(  78)									v_s02 = ((v_ay2 * v_cx2) - (v_ax2 * v_cy2));
HXDLIN(  78)									v_sx2 = (v_cy2 - v_ay2);
HXDLIN(  78)									v_sy2 = (v_ax2 - v_cx2);
HXDLIN(  78)									v_t02 = ((v_ax2 * v_by2) - (v_ay2 * v_bx2));
HXDLIN(  78)									v_tx2 = (v_ay2 - v_by2);
HXDLIN(  78)									v_ty2 = (v_bx2 - v_ax2);
HXDLIN(  78)									v_A2 = ((((-(v_by2) * v_cx2) + (v_ay2 * (-(v_bx2) + v_cx2))) + (v_ax2 * (v_by2 - v_cy2))) + (v_bx2 * v_cy2));
HXDLIN(  78)									Float a41 = v_ax2;
HXDLIN(  78)									Float b45 = v_bx2;
HXDLIN(  78)									Float c25 = v_cx2;
HXDLIN(  78)									if ((a41 > b45)) {
HXDLIN(  78)										if ((a41 > c25)) {
HXDLIN(  78)											int min24;
HXDLIN(  78)											if ((b45 > c25)) {
HXDLIN(  78)												min24 = ::Math_obj::floor(c25);
            											}
            											else {
HXDLIN(  78)												min24 = ::Math_obj::floor(b45);
            											}
HXDLIN(  78)											int ii_min50 = min24;
HXDLIN(  78)											int ii_max50 = ::Math_obj::ceil(a41);
HXDLIN(  78)											v_xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min50,ii_max50);
            										}
            										else {
HXDLIN(  78)											int ii_min51 = ::Math_obj::floor(b45);
HXDLIN(  78)											int ii_max51 = ::Math_obj::ceil(c25);
HXDLIN(  78)											v_xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min51,ii_max51);
            										}
            									}
            									else {
HXDLIN(  78)										if ((b45 > c25)) {
HXDLIN(  78)											int min25;
HXDLIN(  78)											if ((a41 > c25)) {
HXDLIN(  78)												min25 = ::Math_obj::floor(c25);
            											}
            											else {
HXDLIN(  78)												min25 = ::Math_obj::ceil(a41);
            											}
HXDLIN(  78)											int ii_min52 = min25;
HXDLIN(  78)											int ii_max52 = ::Math_obj::ceil(b45);
HXDLIN(  78)											v_xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min52,ii_max52);
            										}
            										else {
HXDLIN(  78)											int ii_min53 = ::Math_obj::floor(a41);
HXDLIN(  78)											int ii_max53 = ::Math_obj::ceil(c25);
HXDLIN(  78)											v_xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min53,ii_max53);
            										}
            									}
HXDLIN(  78)									Float a42 = v_ay2;
HXDLIN(  78)									Float b46 = v_by2;
HXDLIN(  78)									Float c26 = v_cy2;
HXDLIN(  78)									if ((a42 > b46)) {
HXDLIN(  78)										if ((a42 > c26)) {
HXDLIN(  78)											int min26;
HXDLIN(  78)											if ((b46 > c26)) {
HXDLIN(  78)												min26 = ::Math_obj::floor(c26);
            											}
            											else {
HXDLIN(  78)												min26 = ::Math_obj::floor(b46);
            											}
HXDLIN(  78)											int ii_min54 = min26;
HXDLIN(  78)											int ii_max54 = ::Math_obj::ceil(a42);
HXDLIN(  78)											v_yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min54,ii_max54);
            										}
            										else {
HXDLIN(  78)											int ii_min55 = ::Math_obj::floor(b46);
HXDLIN(  78)											int ii_max55 = ::Math_obj::ceil(c26);
HXDLIN(  78)											v_yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min55,ii_max55);
            										}
            									}
            									else {
HXDLIN(  78)										if ((b46 > c26)) {
HXDLIN(  78)											int min27;
HXDLIN(  78)											if ((a42 > c26)) {
HXDLIN(  78)												min27 = ::Math_obj::floor(c26);
            											}
            											else {
HXDLIN(  78)												min27 = ::Math_obj::ceil(a42);
            											}
HXDLIN(  78)											int ii_min56 = min27;
HXDLIN(  78)											int ii_max56 = ::Math_obj::ceil(b46);
HXDLIN(  78)											v_yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min56,ii_max56);
            										}
            										else {
HXDLIN(  78)											int ii_min57 = ::Math_obj::floor(a42);
HXDLIN(  78)											int ii_max57 = ::Math_obj::ceil(c26);
HXDLIN(  78)											v_yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min57,ii_max57);
            										}
            									}
            								}
HXDLIN(  78)								if (hasUndo2) {
HXDLIN(  78)									v_undoImage2 = undoImage6;
HXDLIN(  78)									v_undoX2 = xIter32->start;
HXDLIN(  78)									v_undoY2 = yIter32->start;
            								}
HXDLIN(  78)								Float au3 = bu3;
HXDLIN(  78)								Float av3 = bv3;
HXDLIN(  78)								Float bu5 = cu1;
HXDLIN(  78)								Float bv5 = cv1;
HXDLIN(  78)								bool hasUndo3 = false;
HXDLIN(  78)								Float temp11 = au3;
HXLINE( 422)								au3 = bu5;
HXLINE( 423)								bu5 = temp11;
HXLINE( 424)								temp11 = av3;
HXLINE( 425)								av3 = bv5;
HXLINE( 426)								bv5 = temp11;
HXLINE(  78)								Float bcx3 = (cx3 - dx3);
HXDLIN(  78)								Float bcy3 = (cy3 - dy3);
HXDLIN(  78)								Float acx3 = (bx3 - dx3);
HXDLIN(  78)								Float acy3 = (by3 - dy3);
HXDLIN(  78)								Float dot113 = ((bcx3 * bcx3) + (bcy3 * bcy3));
HXDLIN(  78)								Float dot123 = ((bcx3 * acx3) + (bcy3 * acy3));
HXDLIN(  78)								Float dot223 = ((acx3 * acx3) + (acy3 * acy3));
HXDLIN(  78)								Float denom13 = (( (Float)(1) ) / ((dot113 * dot223) - (dot123 * dot123)));
HXDLIN(  78)								 ::pi_xy::iter::IntIterStart xIter33;
HXDLIN(  78)								if ((bx3 > cx3)) {
HXDLIN(  78)									if ((bx3 > dx3)) {
HXDLIN(  78)										int min28;
HXDLIN(  78)										if ((cx3 > dx3)) {
HXDLIN(  78)											min28 = ::Math_obj::floor(dx3);
            										}
            										else {
HXDLIN(  78)											min28 = ::Math_obj::floor(cx3);
            										}
HXDLIN(  78)										int ii_min58 = min28;
HXDLIN(  78)										int ii_max58 = ::Math_obj::ceil(bx3);
HXDLIN(  78)										xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min58,ii_max58);
            									}
            									else {
HXDLIN(  78)										int ii_min59 = ::Math_obj::floor(cx3);
HXDLIN(  78)										int ii_max59 = ::Math_obj::ceil(dx3);
HXDLIN(  78)										xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min59,ii_max59);
            									}
            								}
            								else {
HXDLIN(  78)									if ((cx3 > dx3)) {
HXDLIN(  78)										int min29;
HXDLIN(  78)										if ((bx3 > dx3)) {
HXDLIN(  78)											min29 = ::Math_obj::floor(dx3);
            										}
            										else {
HXDLIN(  78)											min29 = ::Math_obj::ceil(bx3);
            										}
HXDLIN(  78)										int ii_min60 = min29;
HXDLIN(  78)										int ii_max60 = ::Math_obj::ceil(cx3);
HXDLIN(  78)										xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min60,ii_max60);
            									}
            									else {
HXDLIN(  78)										int ii_min61 = ::Math_obj::floor(bx3);
HXDLIN(  78)										int ii_max61 = ::Math_obj::ceil(dx3);
HXDLIN(  78)										xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min61,ii_max61);
            									}
            								}
HXDLIN(  78)								 ::pi_xy::iter::IntIterStart yIter33;
HXDLIN(  78)								if ((by3 > cy3)) {
HXDLIN(  78)									if ((by3 > dy3)) {
HXDLIN(  78)										int min30;
HXDLIN(  78)										if ((cy3 > dy3)) {
HXDLIN(  78)											min30 = ::Math_obj::floor(dy3);
            										}
            										else {
HXDLIN(  78)											min30 = ::Math_obj::floor(cy3);
            										}
HXDLIN(  78)										int ii_min62 = min30;
HXDLIN(  78)										int ii_max62 = ::Math_obj::ceil(by3);
HXDLIN(  78)										yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min62,ii_max62);
            									}
            									else {
HXDLIN(  78)										int ii_min63 = ::Math_obj::floor(cy3);
HXDLIN(  78)										int ii_max63 = ::Math_obj::ceil(dy3);
HXDLIN(  78)										yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min63,ii_max63);
            									}
            								}
            								else {
HXDLIN(  78)									if ((cy3 > dy3)) {
HXDLIN(  78)										int min31;
HXDLIN(  78)										if ((by3 > dy3)) {
HXDLIN(  78)											min31 = ::Math_obj::floor(dy3);
            										}
            										else {
HXDLIN(  78)											min31 = ::Math_obj::ceil(by3);
            										}
HXDLIN(  78)										int ii_min64 = min31;
HXDLIN(  78)										int ii_max64 = ::Math_obj::ceil(cy3);
HXDLIN(  78)										yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min64,ii_max64);
            									}
            									else {
HXDLIN(  78)										int ii_min65 = ::Math_obj::floor(by3);
HXDLIN(  78)										int ii_max65 = ::Math_obj::ceil(dy3);
HXDLIN(  78)										yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min65,ii_max65);
            									}
            								}
HXDLIN(  78)								 ::pi_xy::ImageStruct undoImage9 = null();
HXDLIN(  78)								if (hasUndo3) {
HXDLIN(  78)									int width6 = ((xIter33->max - xIter33->start) + 1);
HXDLIN(  78)									int height6 = ((yIter33->max - yIter33->start) + 1);
HXDLIN(  78)									 ::Dynamic imageType8 = null();
HXDLIN(  78)									 ::pi_xy::ImageStruct this154 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  78)									if (::hx::IsNull( imageType8 )) {
HXLINE(  54)										imageType8 = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE(  78)									::Dynamic undoImage10;
HXDLIN(  78)									switch((int)(( (int)(imageType8) ))){
            										case (int)0: {
HXDLIN(  78)											 ::iterMagic::BytesImg byt8 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  78)											 ::iterMagic::BytesImg b47 = byt8;
HXDLIN(  78)											{
HXDLIN(  78)												b47->width = width6;
HXDLIN(  78)												b47->height = height6;
HXDLIN(  78)												b47->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN(  78)												b47->data = ::haxe::io::Bytes_obj::alloc((b47->length * 4));
HXDLIN(  78)												{
HXDLIN(  78)													int len16 = b47->length;
HXDLIN(  78)													int w11 = 0;
HXDLIN(  78)													{
HXDLIN(  78)														int _g140 = 0;
HXDLIN(  78)														int _g141 = b47->height;
HXDLIN(  78)														while((_g140 < _g141)){
HXDLIN(  78)															_g140 = (_g140 + 1);
HXDLIN(  78)															int y23 = (_g140 - 1);
HXDLIN(  78)															{
HXDLIN(  78)																int _g142 = 0;
HXDLIN(  78)																int _g143 = b47->width;
HXDLIN(  78)																while((_g142 < _g143)){
HXDLIN(  78)																	_g142 = (_g142 + 1);
HXDLIN(  78)																	int x23 = (_g142 - 1);
HXDLIN(  78)																	{
HXDLIN(  78)																		w11 = (w11 + 1);
HXDLIN(  78)																		b47->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  78)																	{
HXDLIN(  78)																		w11 = (w11 + 1);
HXDLIN(  78)																		b47->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  78)																	{
HXDLIN(  78)																		w11 = (w11 + 1);
HXDLIN(  78)																		b47->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  78)																	{
HXDLIN(  78)																		w11 = (w11 + 1);
HXDLIN(  78)																		b47->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  78)											undoImage10 = b47;
            										}
            										break;
            										case (int)1: {
HXDLIN(  78)											 ::iterMagic::ArrIntImg arrI8 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)											 ::iterMagic::ArrIntImg a43 = arrI8;
HXDLIN(  78)											{
HXDLIN(  78)												a43->width = width6;
HXDLIN(  78)												a43->height = height6;
HXDLIN(  78)												a43->data = ::Array_obj< int >::__new(0);
HXDLIN(  78)												a43->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN(  78)												{
HXDLIN(  78)													int _g144 = 0;
HXDLIN(  78)													int _g145 = a43->length;
HXDLIN(  78)													while((_g144 < _g145)){
HXDLIN(  78)														_g144 = (_g144 + 1);
HXDLIN(  78)														int i54 = (_g144 - 1);
HXDLIN(  78)														a43->data[i54] = 0;
            													}
            												}
            											}
HXDLIN(  78)											undoImage10 = a43;
            										}
            										break;
            										case (int)2: {
HXDLIN(  78)											 ::iterMagic::U32ArrImg u32a8 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  78)											 ::iterMagic::U32ArrImg b48 = u32a8;
HXDLIN(  78)											{
HXDLIN(  78)												b48->width = width6;
HXDLIN(  78)												b48->height = height6;
HXDLIN(  78)												b48->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN(  78)												int size8 = (b48->length * 4);
HXDLIN(  78)												b48->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size8),0,size8);
HXDLIN(  78)												{
HXDLIN(  78)													int _g146 = 0;
HXDLIN(  78)													int _g147 = b48->length;
HXDLIN(  78)													while((_g146 < _g147)){
HXDLIN(  78)														_g146 = (_g146 + 1);
HXDLIN(  78)														int i55 = (_g146 - 1);
HXDLIN(  78)														{
HXDLIN(  78)															 ::haxe::io::ArrayBufferViewImpl this155 = b48->data;
HXDLIN(  78)															bool undoImage11;
HXDLIN(  78)															if ((i55 >= 0)) {
HXDLIN(  78)																undoImage11 = (i55 < (this155->byteLength >> 2));
            															}
            															else {
HXDLIN(  78)																undoImage11 = false;
            															}
HXDLIN(  78)															if (undoImage11) {
HXDLIN(  78)																 ::haxe::io::Bytes _this8 = this155->bytes;
HXDLIN(  78)																int pos8 = ((i55 << 2) + this155->byteOffset);
HXDLIN(  78)																_this8->b[pos8] = ( (unsigned char)(0) );
HXDLIN(  78)																_this8->b[(pos8 + 1)] = ( (unsigned char)(0) );
HXDLIN(  78)																_this8->b[(pos8 + 2)] = ( (unsigned char)(0) );
HXDLIN(  78)																_this8->b[(pos8 + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN(  78)											undoImage10 = b48;
            										}
            										break;
            										case (int)3: {
HXDLIN(  78)											 ::iterMagic::VecIntImg vec8 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)											 ::iterMagic::VecIntImg v17 = vec8;
HXDLIN(  78)											{
HXDLIN(  78)												v17->width = width6;
HXDLIN(  78)												v17->height = height6;
HXDLIN(  78)												v17->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN(  78)												v17->data = ::Array_obj< int >::__new(v17->length);
HXDLIN(  78)												{
HXDLIN(  78)													int _g148 = 0;
HXDLIN(  78)													int _g149 = v17->length;
HXDLIN(  78)													while((_g148 < _g149)){
HXDLIN(  78)														_g148 = (_g148 + 1);
HXDLIN(  78)														int i56 = (_g148 - 1);
HXDLIN(  78)														v17->data->__unsafe_set(i56,0);
            													}
            												}
            											}
HXDLIN(  78)											undoImage10 = v17;
            										}
            										break;
            										case (int)4: {
HXDLIN(  78)											 ::iterMagic::StackIntImg sInt8 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)											 ::iterMagic::StackIntImg b49 = sInt8;
HXDLIN(  78)											{
HXDLIN(  78)												b49->width = width6;
HXDLIN(  78)												b49->height = height6;
HXDLIN(  78)												b49->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN(  78)												b49->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  78)												{
HXDLIN(  78)													int len17 = b49->length;
HXDLIN(  78)													 ::haxe::ds::GenericStack_Int d8 = b49->data;
HXDLIN(  78)													if (::hx::IsNull( d8->head )) {
HXDLIN(  78)														int _g150 = 0;
HXDLIN(  78)														int _g151 = len17;
HXDLIN(  78)														while((_g150 < _g151)){
HXDLIN(  78)															_g150 = (_g150 + 1);
HXDLIN(  78)															int i57 = (_g150 - 1);
HXDLIN(  78)															d8->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d8->head);
            														}
            													}
            													else {
HXDLIN(  78)														int _g152 = 0;
HXDLIN(  78)														int _g153 = len17;
HXDLIN(  78)														while((_g152 < _g153)){
HXDLIN(  78)															_g152 = (_g152 + 1);
HXDLIN(  78)															int i58 = (_g152 - 1);
HXDLIN(  78)															{
HXDLIN(  78)																 ::haxe::ds::GenericCell_Int l8 = b49->data->head;
HXDLIN(  78)																 ::haxe::ds::GenericCell_Int prev8 = null();
HXDLIN(  78)																{
HXDLIN(  78)																	int _g154 = 0;
HXDLIN(  78)																	int _g155 = i58;
HXDLIN(  78)																	while((_g154 < _g155)){
HXDLIN(  78)																		_g154 = (_g154 + 1);
HXDLIN(  78)																		int i59 = (_g154 - 1);
HXLINE( 345)																		prev8 = l8;
HXLINE( 346)																		l8 = l8->next;
            																	}
            																}
HXLINE(  78)																if (::hx::IsNull( prev8 )) {
HXDLIN(  78)																	b49->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l8->next);
HXDLIN(  78)																	l8 = null();
            																}
            																else {
HXDLIN(  78)																	prev8->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l8->next);
HXDLIN(  78)																	l8 = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  78)											undoImage10 = b49;
            										}
            										break;
            									}
HXDLIN(  78)									this154->image = undoImage10;
HXDLIN(  78)									this154->width = width6;
HXDLIN(  78)									this154->height = height6;
HXDLIN(  78)									this154->imageType = ( (int)(imageType8) );
HXDLIN(  78)									undoImage9 = this154;
HXDLIN(  78)									{
HXDLIN(  78)										int rectLeft3 = xIter33->start;
HXDLIN(  78)										int rectTop3 = yIter33->start;
HXDLIN(  78)										int rectRight3 = xIter33->max;
HXDLIN(  78)										bool forceClear3 = false;
HXDLIN(  78)										{
HXDLIN(  78)											int _g156 = rectTop3;
HXDLIN(  78)											int _g157 = yIter33->max;
HXDLIN(  78)											while((_g156 < _g157)){
HXDLIN(  78)												_g156 = (_g156 + 1);
HXDLIN(  78)												int dy5 = (_g156 - 1);
HXDLIN(  78)												{
HXDLIN(  78)													int _g158 = rectLeft3;
HXDLIN(  78)													int _g159 = rectRight3;
HXDLIN(  78)													while((_g158 < _g159)){
HXDLIN(  78)														_g158 = (_g158 + 1);
HXDLIN(  78)														int dx5 = (_g158 - 1);
HXDLIN(  78)														::Dynamic this156 = this119->image;
HXDLIN(  78)														int index24;
HXDLIN(  78)														if (this119->useVirtualPos) {
HXDLIN(  78)															index24 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this119->virtualY) * ( (Float)(this119->width) )) + dx5) - this119->virtualX));
            														}
            														else {
HXDLIN(  78)															index24 = ::Std_obj::_hx_int(( (Float)(((dy5 * this119->width) + dx5)) ));
            														}
HXDLIN(  78)														int c27 = ::iterMagic::Iimg_obj::get(this156,index24);
HXDLIN(  78)														int col6;
HXDLIN(  78)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)															col6 = ((((((c27 >> 24) & 255) << 24) | ((c27 & 255) << 16)) | (((c27 >> 8) & 255) << 8)) | ((c27 >> 16) & 255));
            														}
            														else {
HXDLIN(  78)															col6 = c27;
            														}
HXDLIN(  78)														bool _hx_tmp53;
HXDLIN(  78)														if (this119->useMask) {
HXDLIN(  78)															_hx_tmp53 = ::hx::IsNotNull( this119->mask );
            														}
            														else {
HXDLIN(  78)															_hx_tmp53 = false;
            														}
HXDLIN(  78)														if (_hx_tmp53) {
HXDLIN(  78)															 ::pi_xy::ImageStruct this157 = this119->mask;
HXDLIN(  78)															::Dynamic this158 = this157->image;
HXDLIN(  78)															int index25;
HXDLIN(  78)															if (this157->useVirtualPos) {
HXDLIN(  78)																index25 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this157->virtualY) * ( (Float)(this157->width) )) + dx5) - this157->virtualX));
            															}
            															else {
HXDLIN(  78)																index25 = ::Std_obj::_hx_int(( (Float)(((dy5 * this157->width) + dx5)) ));
            															}
HXDLIN(  78)															int c28 = ::iterMagic::Iimg_obj::get(this158,index25);
HXDLIN(  78)															int v18;
HXDLIN(  78)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																v18 = ((((((c28 >> 24) & 255) << 24) | ((c28 & 255) << 16)) | (((c28 >> 8) & 255) << 8)) | ((c28 >> 16) & 255));
            															}
            															else {
HXDLIN(  78)																v18 = c28;
            															}
HXDLIN(  78)															int maskPixel3 = v18;
HXDLIN(  78)															int this159 = col6;
HXDLIN(  78)															if ((maskPixel3 == 0)) {
HXDLIN(  78)																col6 = this159;
            															}
            															else {
HXDLIN(  78)																Float m03;
HXDLIN(  78)																int this160 = ((maskPixel3 >> 24) & 255);
HXDLIN(  78)																if ((this160 == 0)) {
HXDLIN(  78)																	m03 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	m03 = (( (Float)(this160) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float m13;
HXDLIN(  78)																int this161 = ((maskPixel3 >> 16) & 255);
HXDLIN(  78)																if ((this161 == 0)) {
HXDLIN(  78)																	m13 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	m13 = (( (Float)(this161) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float m23;
HXDLIN(  78)																int this162 = ((maskPixel3 >> 8) & 255);
HXDLIN(  78)																if ((this162 == 0)) {
HXDLIN(  78)																	m23 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	m23 = (( (Float)(this162) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float m33;
HXDLIN(  78)																int this163 = (maskPixel3 & 255);
HXDLIN(  78)																if ((this163 == 0)) {
HXDLIN(  78)																	m33 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	m33 = (( (Float)(this163) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																int ch03 = ::Std_obj::_hx_int(((((Float)1.) - m03) * ( (Float)(((this159 >> 24) & 255)) )));
HXDLIN(  78)																int ch13 = ::Std_obj::_hx_int(((((Float)1.) - m13) * ( (Float)(((this159 >> 16) & 255)) )));
HXDLIN(  78)																int ch23 = ::Std_obj::_hx_int(((((Float)1.) - m23) * ( (Float)(((this159 >> 8) & 255)) )));
HXDLIN(  78)																int ch33 = ::Std_obj::_hx_int(((((Float)1.) - m33) * ( (Float)((this159 & 255)) )));
HXDLIN(  78)																col6 = ((((::Math_obj::round((( (Float)(ch03) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch13) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch23) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch33) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  78)														if ((col6 != 0)) {
HXDLIN(  78)															int x24 = (dx5 - rectLeft3);
HXDLIN(  78)															int y24 = (dy5 - rectTop3);
HXDLIN(  78)															int c29 = col6;
HXDLIN(  78)															bool _hx_tmp54;
HXDLIN(  78)															if ((((c29 >> 24) & 255) < 254)) {
HXDLIN(  78)																_hx_tmp54 = undoImage9->transparent;
            															}
            															else {
HXDLIN(  78)																_hx_tmp54 = false;
            															}
HXDLIN(  78)															if (_hx_tmp54) {
HXDLIN(  78)																int location9;
HXDLIN(  78)																if (undoImage9->useVirtualPos) {
HXDLIN(  78)																	location9 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x24) - undoImage9->virtualX));
            																}
            																else {
HXDLIN(  78)																	location9 = ::Std_obj::_hx_int(( (Float)(((y24 * undoImage9->width) + x24)) ));
            																}
HXDLIN(  78)																int this164 = ::iterMagic::Iimg_obj::get(undoImage9->image,location9);
HXDLIN(  78)																int this165;
HXDLIN(  78)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																	this165 = ((((((this164 >> 24) & 255) << 24) | ((this164 & 255) << 16)) | (((this164 >> 8) & 255) << 8)) | ((this164 >> 16) & 255));
            																}
            																else {
HXDLIN(  78)																	this165 = this164;
            																}
HXDLIN(  78)																Float a114;
HXDLIN(  78)																int this166 = ((this165 >> 24) & 255);
HXDLIN(  78)																if ((this166 == 0)) {
HXDLIN(  78)																	a114 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	a114 = (( (Float)(this166) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float r111;
HXDLIN(  78)																int this167 = ((this165 >> 16) & 255);
HXDLIN(  78)																if ((this167 == 0)) {
HXDLIN(  78)																	r111 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	r111 = (( (Float)(this167) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float g19;
HXDLIN(  78)																int this168 = ((this165 >> 8) & 255);
HXDLIN(  78)																if ((this168 == 0)) {
HXDLIN(  78)																	g19 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	g19 = (( (Float)(this168) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float b116;
HXDLIN(  78)																int this169 = (this165 & 255);
HXDLIN(  78)																if ((this169 == 0)) {
HXDLIN(  78)																	b116 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	b116 = (( (Float)(this169) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float a212;
HXDLIN(  78)																int this170 = ((col6 >> 24) & 255);
HXDLIN(  78)																if ((this170 == 0)) {
HXDLIN(  78)																	a212 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	a212 = (( (Float)(this170) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float r29;
HXDLIN(  78)																int this171 = ((col6 >> 16) & 255);
HXDLIN(  78)																if ((this171 == 0)) {
HXDLIN(  78)																	r29 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	r29 = (( (Float)(this171) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float g29;
HXDLIN(  78)																int this172 = ((col6 >> 8) & 255);
HXDLIN(  78)																if ((this172 == 0)) {
HXDLIN(  78)																	g29 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	g29 = (( (Float)(this172) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float b214;
HXDLIN(  78)																int this173 = (col6 & 255);
HXDLIN(  78)																if ((this173 == 0)) {
HXDLIN(  78)																	b214 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	b214 = (( (Float)(this173) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float a311 = (a114 * (( (Float)(1) ) - a212));
HXDLIN(  78)																int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r111 * a311) + (r29 * a212))));
HXDLIN(  78)																int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a311) + (g29 * a212))));
HXDLIN(  78)																int b50 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a311) + (b214 * a212))));
HXDLIN(  78)																int a44 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a212)));
HXDLIN(  78)																int blended9 = ((((a44 << 24) | (r30 << 16)) | (g20 << 8)) | b50);
HXDLIN(  78)																{
HXDLIN(  78)																	int _hx_tmp55;
HXDLIN(  78)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																		_hx_tmp55 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            																	}
            																	else {
HXDLIN(  78)																		_hx_tmp55 = blended9;
            																	}
HXDLIN(  78)																	::iterMagic::Iimg_obj::set(undoImage9->image,location9,_hx_tmp55);
            																}
            															}
            															else {
HXDLIN(  78)																::Dynamic this174 = undoImage9->image;
HXDLIN(  78)																int index26;
HXDLIN(  78)																if (undoImage9->useVirtualPos) {
HXDLIN(  78)																	index26 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x24) - undoImage9->virtualX));
            																}
            																else {
HXDLIN(  78)																	index26 = ::Std_obj::_hx_int(( (Float)(((y24 * undoImage9->width) + x24)) ));
            																}
HXDLIN(  78)																int _hx_tmp56;
HXDLIN(  78)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																	_hx_tmp56 = ((((((c29 >> 24) & 255) << 24) | ((c29 & 255) << 16)) | (((c29 >> 8) & 255) << 8)) | ((c29 >> 16) & 255));
            																}
            																else {
HXDLIN(  78)																	_hx_tmp56 = c29;
            																}
HXDLIN(  78)																::iterMagic::Iimg_obj::set(this174,index26,_hx_tmp56);
            															}
            														}
            														else {
HXDLIN(  78)															if (forceClear3) {
HXDLIN(  78)																::Dynamic this175 = undoImage9->image;
HXDLIN(  78)																int x25 = (dx5 - rectLeft3);
HXDLIN(  78)																int y25 = (dy5 - rectTop3);
HXDLIN(  78)																int index27;
HXDLIN(  78)																if (undoImage9->useVirtualPos) {
HXDLIN(  78)																	index27 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x25) - undoImage9->virtualX));
            																}
            																else {
HXDLIN(  78)																	index27 = ::Std_obj::_hx_int(( (Float)(((y25 * undoImage9->width) + x25)) ));
            																}
HXDLIN(  78)																::iterMagic::Iimg_obj::set(this175,index27,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  78)								{
HXDLIN(  78)									int _g_min6 = xIter33->start;
HXDLIN(  78)									int _g_max6 = xIter33->max;
HXDLIN(  78)									while((_g_min6 < _g_max6)){
HXDLIN(  78)										_g_min6 = (_g_min6 + 1);
HXDLIN(  78)										int px3 = (_g_min6 - 1);
HXDLIN(  78)										Float pcx3 = (( (Float)(px3) ) - dx3);
HXDLIN(  78)										{
HXDLIN(  78)											int _g_min7 = yIter33->start;
HXDLIN(  78)											int _g_max7 = yIter33->max;
HXDLIN(  78)											while((_g_min7 < _g_max7)){
HXDLIN(  78)												_g_min7 = (_g_min7 + 1);
HXDLIN(  78)												int py3 = (_g_min7 - 1);
HXDLIN(  78)												Float pcy3 = (( (Float)(py3) ) - dy3);
HXDLIN(  78)												Float dot313 = ((pcx3 * bcx3) + (pcy3 * bcy3));
HXDLIN(  78)												Float dot323 = ((pcx3 * acx3) + (pcy3 * acy3));
HXDLIN(  78)												Float ratioA3 = (((dot223 * dot313) - (dot123 * dot323)) * denom13);
HXDLIN(  78)												Float ratioB3 = (((dot113 * dot323) - (dot123 * dot313)) * denom13);
HXDLIN(  78)												Float ratioC3 = ((((Float)1.0) - ratioB3) - ratioA3);
HXDLIN(  78)												bool _hx_tmp57;
HXDLIN(  78)												bool _hx_tmp58;
HXDLIN(  78)												if ((ratioA3 >= 0)) {
HXDLIN(  78)													_hx_tmp58 = (ratioB3 >= 0);
            												}
            												else {
HXDLIN(  78)													_hx_tmp58 = false;
            												}
HXDLIN(  78)												if (_hx_tmp58) {
HXDLIN(  78)													_hx_tmp57 = (ratioC3 >= 0);
            												}
            												else {
HXDLIN(  78)													_hx_tmp57 = false;
            												}
HXDLIN(  78)												if (_hx_tmp57) {
HXDLIN(  78)													Float u3 = (((au3 * ratioA3) + (bu5 * ratioB3)) + (du1 * ratioC3));
HXDLIN(  78)													Float v19 = (((av3 * ratioA3) + (bv5 * ratioB3)) + (dv1 * ratioC3));
HXDLIN(  78)													int x26 = ::Std_obj::_hx_int(((u3 * win_width1) + win_x1));
HXDLIN(  78)													int y26 = ::Std_obj::_hx_int(((v19 * win_height1) + win_y1));
HXDLIN(  78)													::Dynamic this176 = this116->image;
HXDLIN(  78)													int index28;
HXDLIN(  78)													if (this116->useVirtualPos) {
HXDLIN(  78)														index28 = ::Std_obj::_hx_int(((((( (Float)(y26) ) - this116->virtualY) * ( (Float)(this116->width) )) + x26) - this116->virtualX));
            													}
            													else {
HXDLIN(  78)														index28 = ::Std_obj::_hx_int(( (Float)(((y26 * this116->width) + x26)) ));
            													}
HXDLIN(  78)													int c30 = ::iterMagic::Iimg_obj::get(this176,index28);
HXDLIN(  78)													int col7;
HXDLIN(  78)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)														col7 = ((((((c30 >> 24) & 255) << 24) | ((c30 & 255) << 16)) | (((c30 >> 8) & 255) << 8)) | ((c30 >> 16) & 255));
            													}
            													else {
HXDLIN(  78)														col7 = c30;
            													}
HXDLIN(  78)													{
HXDLIN(  78)														int c31 = col7;
HXDLIN(  78)														bool _hx_tmp59;
HXDLIN(  78)														if ((((c31 >> 24) & 255) < 254)) {
HXDLIN(  78)															_hx_tmp59 = this119->transparent;
            														}
            														else {
HXDLIN(  78)															_hx_tmp59 = false;
            														}
HXDLIN(  78)														if (_hx_tmp59) {
HXDLIN(  78)															int location10;
HXDLIN(  78)															if (this119->useVirtualPos) {
HXDLIN(  78)																location10 = ::Std_obj::_hx_int(((((( (Float)(py3) ) - this119->virtualY) * ( (Float)(this119->width) )) + px3) - this119->virtualX));
            															}
            															else {
HXDLIN(  78)																location10 = ::Std_obj::_hx_int(( (Float)(((py3 * this119->width) + px3)) ));
            															}
HXDLIN(  78)															int this177 = ::iterMagic::Iimg_obj::get(this119->image,location10);
HXDLIN(  78)															int this178;
HXDLIN(  78)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																this178 = ((((((this177 >> 24) & 255) << 24) | ((this177 & 255) << 16)) | (((this177 >> 8) & 255) << 8)) | ((this177 >> 16) & 255));
            															}
            															else {
HXDLIN(  78)																this178 = this177;
            															}
HXDLIN(  78)															Float a115;
HXDLIN(  78)															int this179 = ((this178 >> 24) & 255);
HXDLIN(  78)															if ((this179 == 0)) {
HXDLIN(  78)																a115 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																a115 = (( (Float)(this179) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float r112;
HXDLIN(  78)															int this180 = ((this178 >> 16) & 255);
HXDLIN(  78)															if ((this180 == 0)) {
HXDLIN(  78)																r112 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																r112 = (( (Float)(this180) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float g110;
HXDLIN(  78)															int this181 = ((this178 >> 8) & 255);
HXDLIN(  78)															if ((this181 == 0)) {
HXDLIN(  78)																g110 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																g110 = (( (Float)(this181) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float b117;
HXDLIN(  78)															int this182 = (this178 & 255);
HXDLIN(  78)															if ((this182 == 0)) {
HXDLIN(  78)																b117 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																b117 = (( (Float)(this182) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float a213;
HXDLIN(  78)															int this183 = ((col7 >> 24) & 255);
HXDLIN(  78)															if ((this183 == 0)) {
HXDLIN(  78)																a213 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																a213 = (( (Float)(this183) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float r210;
HXDLIN(  78)															int this184 = ((col7 >> 16) & 255);
HXDLIN(  78)															if ((this184 == 0)) {
HXDLIN(  78)																r210 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																r210 = (( (Float)(this184) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float g210;
HXDLIN(  78)															int this185 = ((col7 >> 8) & 255);
HXDLIN(  78)															if ((this185 == 0)) {
HXDLIN(  78)																g210 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																g210 = (( (Float)(this185) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float b215;
HXDLIN(  78)															int this186 = (col7 & 255);
HXDLIN(  78)															if ((this186 == 0)) {
HXDLIN(  78)																b215 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																b215 = (( (Float)(this186) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float a312 = (a115 * (( (Float)(1) ) - a213));
HXDLIN(  78)															int r31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r112 * a312) + (r210 * a213))));
HXDLIN(  78)															int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a312) + (g210 * a213))));
HXDLIN(  78)															int b51 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b117 * a312) + (b215 * a213))));
HXDLIN(  78)															int a45 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a213)));
HXDLIN(  78)															int blended10 = ((((a45 << 24) | (r31 << 16)) | (g30 << 8)) | b51);
HXDLIN(  78)															{
HXDLIN(  78)																int _hx_tmp60;
HXDLIN(  78)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																	_hx_tmp60 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            																}
            																else {
HXDLIN(  78)																	_hx_tmp60 = blended10;
            																}
HXDLIN(  78)																::iterMagic::Iimg_obj::set(this119->image,location10,_hx_tmp60);
            															}
            														}
            														else {
HXDLIN(  78)															::Dynamic this187 = this119->image;
HXDLIN(  78)															int index29;
HXDLIN(  78)															if (this119->useVirtualPos) {
HXDLIN(  78)																index29 = ::Std_obj::_hx_int(((((( (Float)(py3) ) - this119->virtualY) * ( (Float)(this119->width) )) + px3) - this119->virtualX));
            															}
            															else {
HXDLIN(  78)																index29 = ::Std_obj::_hx_int(( (Float)(((py3 * this119->width) + px3)) ));
            															}
HXDLIN(  78)															int _hx_tmp61;
HXDLIN(  78)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																_hx_tmp61 = ((((((c31 >> 24) & 255) << 24) | ((c31 & 255) << 16)) | (((c31 >> 8) & 255) << 8)) | ((c31 >> 16) & 255));
            															}
            															else {
HXDLIN(  78)																_hx_tmp61 = c31;
            															}
HXDLIN(  78)															::iterMagic::Iimg_obj::set(this187,index29,_hx_tmp61);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  78)								 ::pi_xy::iter::IntIterStart v_yIter33;
HXDLIN(  78)								 ::pi_xy::iter::IntIterStart v_xIter33;
HXDLIN(  78)								int v_undoY3;
HXDLIN(  78)								int v_undoX3;
HXDLIN(  78)								Float v_ty3;
HXDLIN(  78)								Float v_tx3;
HXDLIN(  78)								Float v_t03;
HXDLIN(  78)								Float v_sy3;
HXDLIN(  78)								Float v_sx3;
HXDLIN(  78)								Float v_s03;
HXDLIN(  78)								Float v_A3;
HXDLIN(  78)								Float ax5 = bx3;
HXDLIN(  78)								Float ay5 = by3;
HXDLIN(  78)								 ::pi_xy::ImageStruct v_undoImage3 = null();
HXDLIN(  78)								Float bx5 = cx3;
HXDLIN(  78)								Float by5 = cy3;
HXDLIN(  78)								Float cx5 = dx3;
HXDLIN(  78)								Float cy5 = dy3;
HXDLIN(  78)								bool adjustWinding3 = (((((ax5 * by5) - (bx5 * ay5)) + ((bx5 * cy5) - (cx5 * by5))) + ((cx5 * ay5) - (ax5 * cy5))) > 0);
HXDLIN(  78)								if (!(adjustWinding3)) {
HXDLIN(  78)									Float bx_3 = bx5;
HXDLIN(  78)									Float by_3 = by5;
HXLINE(  24)									bx5 = cx5;
HXLINE(  25)									by5 = cy5;
HXLINE(  26)									cx5 = bx_3;
HXLINE(  27)									cy5 = by_3;
            								}
HXLINE(  78)								Float v_ax3 = ax5;
HXDLIN(  78)								Float v_ay3 = ay5;
HXDLIN(  78)								Float v_bx3 = bx5;
HXDLIN(  78)								Float v_by3 = by5;
HXDLIN(  78)								Float v_cx3 = cx5;
HXDLIN(  78)								Float v_cy3 = cy5;
HXDLIN(  78)								bool v_preCalculated3 = true;
HXDLIN(  78)								{
HXDLIN(  78)									v_s03 = ((v_ay3 * v_cx3) - (v_ax3 * v_cy3));
HXDLIN(  78)									v_sx3 = (v_cy3 - v_ay3);
HXDLIN(  78)									v_sy3 = (v_ax3 - v_cx3);
HXDLIN(  78)									v_t03 = ((v_ax3 * v_by3) - (v_ay3 * v_bx3));
HXDLIN(  78)									v_tx3 = (v_ay3 - v_by3);
HXDLIN(  78)									v_ty3 = (v_bx3 - v_ax3);
HXDLIN(  78)									v_A3 = ((((-(v_by3) * v_cx3) + (v_ay3 * (-(v_bx3) + v_cx3))) + (v_ax3 * (v_by3 - v_cy3))) + (v_bx3 * v_cy3));
HXDLIN(  78)									Float a46 = v_ax3;
HXDLIN(  78)									Float b52 = v_bx3;
HXDLIN(  78)									Float c32 = v_cx3;
HXDLIN(  78)									if ((a46 > b52)) {
HXDLIN(  78)										if ((a46 > c32)) {
HXDLIN(  78)											int min32;
HXDLIN(  78)											if ((b52 > c32)) {
HXDLIN(  78)												min32 = ::Math_obj::floor(c32);
            											}
            											else {
HXDLIN(  78)												min32 = ::Math_obj::floor(b52);
            											}
HXDLIN(  78)											int ii_min66 = min32;
HXDLIN(  78)											int ii_max66 = ::Math_obj::ceil(a46);
HXDLIN(  78)											v_xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min66,ii_max66);
            										}
            										else {
HXDLIN(  78)											int ii_min67 = ::Math_obj::floor(b52);
HXDLIN(  78)											int ii_max67 = ::Math_obj::ceil(c32);
HXDLIN(  78)											v_xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min67,ii_max67);
            										}
            									}
            									else {
HXDLIN(  78)										if ((b52 > c32)) {
HXDLIN(  78)											int min33;
HXDLIN(  78)											if ((a46 > c32)) {
HXDLIN(  78)												min33 = ::Math_obj::floor(c32);
            											}
            											else {
HXDLIN(  78)												min33 = ::Math_obj::ceil(a46);
            											}
HXDLIN(  78)											int ii_min68 = min33;
HXDLIN(  78)											int ii_max68 = ::Math_obj::ceil(b52);
HXDLIN(  78)											v_xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min68,ii_max68);
            										}
            										else {
HXDLIN(  78)											int ii_min69 = ::Math_obj::floor(a46);
HXDLIN(  78)											int ii_max69 = ::Math_obj::ceil(c32);
HXDLIN(  78)											v_xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min69,ii_max69);
            										}
            									}
HXDLIN(  78)									Float a47 = v_ay3;
HXDLIN(  78)									Float b53 = v_by3;
HXDLIN(  78)									Float c33 = v_cy3;
HXDLIN(  78)									if ((a47 > b53)) {
HXDLIN(  78)										if ((a47 > c33)) {
HXDLIN(  78)											int min34;
HXDLIN(  78)											if ((b53 > c33)) {
HXDLIN(  78)												min34 = ::Math_obj::floor(c33);
            											}
            											else {
HXDLIN(  78)												min34 = ::Math_obj::floor(b53);
            											}
HXDLIN(  78)											int ii_min70 = min34;
HXDLIN(  78)											int ii_max70 = ::Math_obj::ceil(a47);
HXDLIN(  78)											v_yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min70,ii_max70);
            										}
            										else {
HXDLIN(  78)											int ii_min71 = ::Math_obj::floor(b53);
HXDLIN(  78)											int ii_max71 = ::Math_obj::ceil(c33);
HXDLIN(  78)											v_yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min71,ii_max71);
            										}
            									}
            									else {
HXDLIN(  78)										if ((b53 > c33)) {
HXDLIN(  78)											int min35;
HXDLIN(  78)											if ((a47 > c33)) {
HXDLIN(  78)												min35 = ::Math_obj::floor(c33);
            											}
            											else {
HXDLIN(  78)												min35 = ::Math_obj::ceil(a47);
            											}
HXDLIN(  78)											int ii_min72 = min35;
HXDLIN(  78)											int ii_max72 = ::Math_obj::ceil(b53);
HXDLIN(  78)											v_yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min72,ii_max72);
            										}
            										else {
HXDLIN(  78)											int ii_min73 = ::Math_obj::floor(a47);
HXDLIN(  78)											int ii_max73 = ::Math_obj::ceil(c33);
HXDLIN(  78)											v_yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min73,ii_max73);
            										}
            									}
            								}
HXDLIN(  78)								if (hasUndo3) {
HXDLIN(  78)									v_undoImage3 = undoImage9;
HXDLIN(  78)									v_undoX3 = xIter33->start;
HXDLIN(  78)									v_undoY3 = yIter33->start;
            								}
            							}
            						}
HXDLIN(  78)						bool _hx_tmp62;
HXDLIN(  78)						if (::hx::IsNotNull( nextImage4->mask )) {
HXDLIN(  78)							_hx_tmp62 = includeMask;
            						}
            						else {
HXDLIN(  78)							_hx_tmp62 = false;
            						}
HXDLIN(  78)						if (_hx_tmp62) {
HXDLIN(  78)							 ::pi_xy::ImageStruct v20 = ::pi_xy::imageAbstracts::_TransformImage::TransformImage_Impl__obj::rotate(this116->mask,theta,centreX2,centreY2,this116->mask->transparent,includeMask);
HXDLIN(  78)							nextImage4->useMask = true;
HXDLIN(  78)							nextImage4->mask = v20;
            						}
HXDLIN(  78)						 ::pi_xy::ImageStruct v21 = nextImage4;
HXDLIN(  78)						nextImage3->useMask = true;
HXDLIN(  78)						nextImage3->mask = v21;
            					}
HXDLIN(  78)					return nextImage3;
            				}
            			}
            		}
HXDLIN(  78)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(TransformImage_Impl__obj,rotateClockwiseDegrees,return )

 ::pi_xy::ImageStruct TransformImage_Impl__obj::rotateClockwiseRadians( ::pi_xy::ImageStruct this1,Float theta,::hx::Null< Float >  __o_centreX,::hx::Null< Float >  __o_centreY,::hx::Null< bool >  __o_transparent,::hx::Null< bool >  __o_includeMask){
            		Float centreX = __o_centreX.Default(((Float)0.));
            		Float centreY = __o_centreY.Default(((Float)0.));
            		bool transparent = __o_transparent.Default(false);
            		bool includeMask = __o_includeMask.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_68d25436a32dba6f_85_rotateClockwiseRadians)
HXDLIN(  85)		Float theta1 = theta;
HXDLIN(  85)		while((theta1 >= (( (Float)(2) ) * ::Math_obj::PI))){
HXDLIN(  85)			theta1 = (theta1 - (( (Float)(2) ) * ::Math_obj::PI));
            		}
HXDLIN(  85)		while((theta1 <= (( (Float)(-2) ) * ::Math_obj::PI))){
HXDLIN(  85)			theta1 = (theta1 + (( (Float)(2) ) * ::Math_obj::PI));
            		}
HXDLIN(  85)		bool _hx_tmp;
HXDLIN(  85)		if ((theta1 != (::Math_obj::PI / ( (Float)(2) )))) {
HXDLIN(  85)			_hx_tmp = (theta1 == ((( (Float)(-3) ) * ::Math_obj::PI) / ( (Float)(2) )));
            		}
            		else {
HXDLIN(  85)			_hx_tmp = true;
            		}
HXDLIN(  85)		if (_hx_tmp) {
HXDLIN(  85)			Float w = ( (Float)(this1->width) );
HXDLIN(  85)			Float h = ( (Float)(this1->height) );
HXDLIN(  85)			 ::pi_xy::ImageStruct thisImage = this1;
HXDLIN(  85)			 ::Dynamic r =  ::Dynamic(::hx::Anon_obj::Create(4)
            				->setFixed(0,HX_("h",68,00,00,00),h)
            				->setFixed(1,HX_("w",77,00,00,00),w)
            				->setFixed(2,HX_("x",78,00,00,00),0)
            				->setFixed(3,HX_("y",79,00,00,00),0));
HXDLIN(  85)			int xmax = ::Std_obj::_hx_int(( (Float)(((r->__Field(HX_("x",78,00,00,00),::hx::paccDynamic) + r->__Field(HX_("w",77,00,00,00),::hx::paccDynamic)) + 1)) ));
HXDLIN(  85)			int ymax = ::Std_obj::_hx_int(( (Float)(((r->__Field(HX_("y",79,00,00,00),::hx::paccDynamic) + r->__Field(HX_("h",68,00,00,00),::hx::paccDynamic)) + 1)) ));
HXDLIN(  85)			int ii_min = ::Std_obj::_hx_int(( (Float)(r->__Field(HX_("x",78,00,00,00),::hx::paccDynamic)) ));
HXDLIN(  85)			int ii_max = xmax;
HXDLIN(  85)			int xRange__start = ii_min;
HXDLIN(  85)			int xRange__max = ii_max;
HXDLIN(  85)			int ii_min1 = ::Std_obj::_hx_int(( (Float)(r->__Field(HX_("y",79,00,00,00),::hx::paccDynamic)) ));
HXDLIN(  85)			int ii_max1 = ymax;
HXDLIN(  85)			int yRange__start = ii_min1;
HXDLIN(  85)			int yRange__max = ii_max1;
HXDLIN(  85)			int range_x = xRange__start;
HXDLIN(  85)			int range_y = (yRange__start - 1);
HXDLIN(  85)			int range_xReset = range_x;
HXDLIN(  85)			int range_yReset = range_y;
HXDLIN(  85)			int range_xMax = (xRange__max - 2);
HXDLIN(  85)			int range_yMax = (yRange__max - 2);
HXDLIN(  85)			int _this_min = 0;
HXDLIN(  85)			int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXDLIN(  85)			int width = ::Std_obj::_hx_int(w);
HXDLIN(  85)			int height = ::Std_obj::_hx_int(h);
HXDLIN(  85)			 ::Dynamic imageType = null();
HXDLIN(  85)			 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  85)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE(  85)			::Dynamic _hx_tmp1;
HXDLIN(  85)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXDLIN(  85)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  85)					 ::iterMagic::BytesImg b = byt;
HXDLIN(  85)					{
HXDLIN(  85)						b->width = width;
HXDLIN(  85)						b->height = height;
HXDLIN(  85)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  85)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  85)						{
HXDLIN(  85)							int len = b->length;
HXDLIN(  85)							int w1 = 0;
HXDLIN(  85)							{
HXDLIN(  85)								int _g = 0;
HXDLIN(  85)								int _g1 = b->height;
HXDLIN(  85)								while((_g < _g1)){
HXDLIN(  85)									_g = (_g + 1);
HXDLIN(  85)									int y = (_g - 1);
HXDLIN(  85)									{
HXDLIN(  85)										int _g2 = 0;
HXDLIN(  85)										int _g3 = b->width;
HXDLIN(  85)										while((_g2 < _g3)){
HXDLIN(  85)											_g2 = (_g2 + 1);
HXDLIN(  85)											int x = (_g2 - 1);
HXDLIN(  85)											{
HXDLIN(  85)												w1 = (w1 + 1);
HXDLIN(  85)												b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  85)											{
HXDLIN(  85)												w1 = (w1 + 1);
HXDLIN(  85)												b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  85)											{
HXDLIN(  85)												w1 = (w1 + 1);
HXDLIN(  85)												b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  85)											{
HXDLIN(  85)												w1 = (w1 + 1);
HXDLIN(  85)												b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  85)					_hx_tmp1 = b;
            				}
            				break;
            				case (int)1: {
HXDLIN(  85)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  85)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  85)					{
HXDLIN(  85)						a->width = width;
HXDLIN(  85)						a->height = height;
HXDLIN(  85)						a->data = ::Array_obj< int >::__new(0);
HXDLIN(  85)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  85)						{
HXDLIN(  85)							int _g4 = 0;
HXDLIN(  85)							int _g5 = a->length;
HXDLIN(  85)							while((_g4 < _g5)){
HXDLIN(  85)								_g4 = (_g4 + 1);
HXDLIN(  85)								int i = (_g4 - 1);
HXDLIN(  85)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN(  85)					_hx_tmp1 = a;
            				}
            				break;
            				case (int)2: {
HXDLIN(  85)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  85)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  85)					{
HXDLIN(  85)						b1->width = width;
HXDLIN(  85)						b1->height = height;
HXDLIN(  85)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  85)						int size = (b1->length * 4);
HXDLIN(  85)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  85)						{
HXDLIN(  85)							int _g6 = 0;
HXDLIN(  85)							int _g7 = b1->length;
HXDLIN(  85)							while((_g6 < _g7)){
HXDLIN(  85)								_g6 = (_g6 + 1);
HXDLIN(  85)								int i1 = (_g6 - 1);
HXDLIN(  85)								{
HXDLIN(  85)									 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  85)									bool _hx_tmp2;
HXDLIN(  85)									if ((i1 >= 0)) {
HXDLIN(  85)										_hx_tmp2 = (i1 < (this3->byteLength >> 2));
            									}
            									else {
HXDLIN(  85)										_hx_tmp2 = false;
            									}
HXDLIN(  85)									if (_hx_tmp2) {
HXDLIN(  85)										 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  85)										int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  85)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  85)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  85)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  85)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN(  85)					_hx_tmp1 = b1;
            				}
            				break;
            				case (int)3: {
HXDLIN(  85)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  85)					 ::iterMagic::VecIntImg v = vec;
HXDLIN(  85)					{
HXDLIN(  85)						v->width = width;
HXDLIN(  85)						v->height = height;
HXDLIN(  85)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  85)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  85)						{
HXDLIN(  85)							int _g8 = 0;
HXDLIN(  85)							int _g9 = v->length;
HXDLIN(  85)							while((_g8 < _g9)){
HXDLIN(  85)								_g8 = (_g8 + 1);
HXDLIN(  85)								int i2 = (_g8 - 1);
HXDLIN(  85)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN(  85)					_hx_tmp1 = v;
            				}
            				break;
            				case (int)4: {
HXDLIN(  85)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  85)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  85)					{
HXDLIN(  85)						b2->width = width;
HXDLIN(  85)						b2->height = height;
HXDLIN(  85)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  85)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  85)						{
HXDLIN(  85)							int len1 = b2->length;
HXDLIN(  85)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  85)							if (::hx::IsNull( d->head )) {
HXDLIN(  85)								int _g10 = 0;
HXDLIN(  85)								int _g11 = len1;
HXDLIN(  85)								while((_g10 < _g11)){
HXDLIN(  85)									_g10 = (_g10 + 1);
HXDLIN(  85)									int i3 = (_g10 - 1);
HXDLIN(  85)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXDLIN(  85)								int _g12 = 0;
HXDLIN(  85)								int _g13 = len1;
HXDLIN(  85)								while((_g12 < _g13)){
HXDLIN(  85)									_g12 = (_g12 + 1);
HXDLIN(  85)									int i4 = (_g12 - 1);
HXDLIN(  85)									{
HXDLIN(  85)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  85)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  85)										{
HXDLIN(  85)											int _g14 = 0;
HXDLIN(  85)											int _g15 = i4;
HXDLIN(  85)											while((_g14 < _g15)){
HXDLIN(  85)												_g14 = (_g14 + 1);
HXDLIN(  85)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE(  85)										if (::hx::IsNull( prev )) {
HXDLIN(  85)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  85)											l = null();
            										}
            										else {
HXDLIN(  85)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  85)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  85)					_hx_tmp1 = b2;
            				}
            				break;
            			}
HXDLIN(  85)			this2->image = _hx_tmp1;
HXDLIN(  85)			this2->width = width;
HXDLIN(  85)			this2->height = height;
HXDLIN(  85)			this2->imageType = ( (int)(imageType) );
HXDLIN(  85)			 ::pi_xy::ImageStruct nextImage = this2;
HXDLIN(  85)			nextImage->transparent = transparent;
HXDLIN(  85)			while((_this_min < _this_max)){
HXDLIN(  85)				_this_min = (_this_min + 1);
HXDLIN(  85)				int i6 = (_this_min - 1);
HXDLIN(  85)				if ((range_y > range_yMax)) {
HXDLIN(  85)					range_y = range_yReset;
HXDLIN(  85)					range_x = (range_x + 1);
            				}
HXDLIN(  85)				range_y = (range_y + 1);
HXDLIN(  85)				int i7 = i6;
HXDLIN(  85)				{
HXDLIN(  85)					int x1 = (range_yMax - range_y);
HXDLIN(  85)					int y1 = range_x;
HXDLIN(  85)					int x2 = range_x;
HXDLIN(  85)					int y2 = range_y;
HXDLIN(  85)					::Dynamic this4 = thisImage->image;
HXDLIN(  85)					int index;
HXDLIN(  85)					if (thisImage->useVirtualPos) {
HXDLIN(  85)						index = ::Std_obj::_hx_int(((((( (Float)(y2) ) - thisImage->virtualY) * ( (Float)(thisImage->width) )) + x2) - thisImage->virtualX));
            					}
            					else {
HXDLIN(  85)						index = ::Std_obj::_hx_int(( (Float)(((y2 * thisImage->width) + x2)) ));
            					}
HXDLIN(  85)					int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN(  85)					int color;
HXDLIN(  85)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)						color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            					}
            					else {
HXDLIN(  85)						color = c;
            					}
HXDLIN(  85)					int c1 = color;
HXDLIN(  85)					bool _hx_tmp3;
HXDLIN(  85)					if ((((c1 >> 24) & 255) < 254)) {
HXDLIN(  85)						_hx_tmp3 = nextImage->transparent;
            					}
            					else {
HXDLIN(  85)						_hx_tmp3 = false;
            					}
HXDLIN(  85)					if (_hx_tmp3) {
HXDLIN(  85)						int location;
HXDLIN(  85)						if (nextImage->useVirtualPos) {
HXDLIN(  85)							location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x1) - nextImage->virtualX));
            						}
            						else {
HXDLIN(  85)							location = ::Std_obj::_hx_int(( (Float)(((y1 * nextImage->width) + x1)) ));
            						}
HXDLIN(  85)						int this5 = ::iterMagic::Iimg_obj::get(nextImage->image,location);
HXDLIN(  85)						int this6;
HXDLIN(  85)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)							this6 = ((((((this5 >> 24) & 255) << 24) | ((this5 & 255) << 16)) | (((this5 >> 8) & 255) << 8)) | ((this5 >> 16) & 255));
            						}
            						else {
HXDLIN(  85)							this6 = this5;
            						}
HXDLIN(  85)						Float a1;
HXDLIN(  85)						int this7 = ((this6 >> 24) & 255);
HXDLIN(  85)						if ((this7 == 0)) {
HXDLIN(  85)							a1 = ((Float)0.);
            						}
            						else {
HXDLIN(  85)							a1 = (( (Float)(this7) ) / ( (Float)(255) ));
            						}
HXDLIN(  85)						Float r1;
HXDLIN(  85)						int this8 = ((this6 >> 16) & 255);
HXDLIN(  85)						if ((this8 == 0)) {
HXDLIN(  85)							r1 = ((Float)0.);
            						}
            						else {
HXDLIN(  85)							r1 = (( (Float)(this8) ) / ( (Float)(255) ));
            						}
HXDLIN(  85)						Float g1;
HXDLIN(  85)						int this9 = ((this6 >> 8) & 255);
HXDLIN(  85)						if ((this9 == 0)) {
HXDLIN(  85)							g1 = ((Float)0.);
            						}
            						else {
HXDLIN(  85)							g1 = (( (Float)(this9) ) / ( (Float)(255) ));
            						}
HXDLIN(  85)						Float b11;
HXDLIN(  85)						int this10 = (this6 & 255);
HXDLIN(  85)						if ((this10 == 0)) {
HXDLIN(  85)							b11 = ((Float)0.);
            						}
            						else {
HXDLIN(  85)							b11 = (( (Float)(this10) ) / ( (Float)(255) ));
            						}
HXDLIN(  85)						Float a2;
HXDLIN(  85)						int this11 = ((color >> 24) & 255);
HXDLIN(  85)						if ((this11 == 0)) {
HXDLIN(  85)							a2 = ((Float)0.);
            						}
            						else {
HXDLIN(  85)							a2 = (( (Float)(this11) ) / ( (Float)(255) ));
            						}
HXDLIN(  85)						Float r2;
HXDLIN(  85)						int this12 = ((color >> 16) & 255);
HXDLIN(  85)						if ((this12 == 0)) {
HXDLIN(  85)							r2 = ((Float)0.);
            						}
            						else {
HXDLIN(  85)							r2 = (( (Float)(this12) ) / ( (Float)(255) ));
            						}
HXDLIN(  85)						Float g2;
HXDLIN(  85)						int this13 = ((color >> 8) & 255);
HXDLIN(  85)						if ((this13 == 0)) {
HXDLIN(  85)							g2 = ((Float)0.);
            						}
            						else {
HXDLIN(  85)							g2 = (( (Float)(this13) ) / ( (Float)(255) ));
            						}
HXDLIN(  85)						Float b21;
HXDLIN(  85)						int this14 = (color & 255);
HXDLIN(  85)						if ((this14 == 0)) {
HXDLIN(  85)							b21 = ((Float)0.);
            						}
            						else {
HXDLIN(  85)							b21 = (( (Float)(this14) ) / ( (Float)(255) ));
            						}
HXDLIN(  85)						Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  85)						int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  85)						int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  85)						int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  85)						int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  85)						int blended = ((((a4 << 24) | (r3 << 16)) | (g << 8)) | b3);
HXDLIN(  85)						{
HXDLIN(  85)							int _hx_tmp4;
HXDLIN(  85)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)								_hx_tmp4 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            							}
            							else {
HXDLIN(  85)								_hx_tmp4 = blended;
            							}
HXDLIN(  85)							::iterMagic::Iimg_obj::set(nextImage->image,location,_hx_tmp4);
            						}
            					}
            					else {
HXDLIN(  85)						::Dynamic this15 = nextImage->image;
HXDLIN(  85)						int index1;
HXDLIN(  85)						if (nextImage->useVirtualPos) {
HXDLIN(  85)							index1 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x1) - nextImage->virtualX));
            						}
            						else {
HXDLIN(  85)							index1 = ::Std_obj::_hx_int(( (Float)(((y1 * nextImage->width) + x1)) ));
            						}
HXDLIN(  85)						int _hx_tmp5;
HXDLIN(  85)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)							_hx_tmp5 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            						}
            						else {
HXDLIN(  85)							_hx_tmp5 = c1;
            						}
HXDLIN(  85)						::iterMagic::Iimg_obj::set(this15,index1,_hx_tmp5);
            					}
            				}
            			}
HXDLIN(  85)			bool _hx_tmp6;
HXDLIN(  85)			if (::hx::IsNotNull( thisImage->mask )) {
HXDLIN(  85)				_hx_tmp6 = includeMask;
            			}
            			else {
HXDLIN(  85)				_hx_tmp6 = false;
            			}
HXDLIN(  85)			if (_hx_tmp6) {
HXDLIN(  85)				 ::pi_xy::ImageStruct v1 = ::pi_xy::transformation::_SpinImage::SpinImage_Fields__obj::spinClock90(thisImage->mask,( (Float)(0) ),( (Float)(0) ),w,h,thisImage->mask->transparent,includeMask);
HXDLIN(  85)				nextImage->useMask = true;
HXDLIN(  85)				nextImage->mask = v1;
            			}
HXDLIN(  85)			return nextImage;
            		}
            		else {
HXDLIN(  85)			bool _hx_tmp7;
HXDLIN(  85)			if ((theta1 != (-(::Math_obj::PI) / ( (Float)(2) )))) {
HXDLIN(  85)				_hx_tmp7 = (theta1 == ((( (Float)(3) ) * ::Math_obj::PI) / ( (Float)(2) )));
            			}
            			else {
HXDLIN(  85)				_hx_tmp7 = true;
            			}
HXDLIN(  85)			if (_hx_tmp7) {
HXDLIN(  85)				Float w2 = ( (Float)(this1->width) );
HXDLIN(  85)				Float h1 = ( (Float)(this1->height) );
HXDLIN(  85)				 ::pi_xy::ImageStruct thisImage1 = this1;
HXDLIN(  85)				 ::Dynamic r4 =  ::Dynamic(::hx::Anon_obj::Create(4)
            					->setFixed(0,HX_("h",68,00,00,00),h1)
            					->setFixed(1,HX_("w",77,00,00,00),w2)
            					->setFixed(2,HX_("x",78,00,00,00),0)
            					->setFixed(3,HX_("y",79,00,00,00),0));
HXDLIN(  85)				int xmax1 = ::Std_obj::_hx_int(( (Float)(((r4->__Field(HX_("x",78,00,00,00),::hx::paccDynamic) + r4->__Field(HX_("w",77,00,00,00),::hx::paccDynamic)) + 1)) ));
HXDLIN(  85)				int ymax1 = ::Std_obj::_hx_int(( (Float)(((r4->__Field(HX_("y",79,00,00,00),::hx::paccDynamic) + r4->__Field(HX_("h",68,00,00,00),::hx::paccDynamic)) + 1)) ));
HXDLIN(  85)				int ii_min2 = ::Std_obj::_hx_int(( (Float)(r4->__Field(HX_("x",78,00,00,00),::hx::paccDynamic)) ));
HXDLIN(  85)				int ii_max2 = xmax1;
HXDLIN(  85)				int xRange__start1 = ii_min2;
HXDLIN(  85)				int xRange__max1 = ii_max2;
HXDLIN(  85)				int ii_min3 = ::Std_obj::_hx_int(( (Float)(r4->__Field(HX_("y",79,00,00,00),::hx::paccDynamic)) ));
HXDLIN(  85)				int ii_max3 = ymax1;
HXDLIN(  85)				int yRange__start1 = ii_min3;
HXDLIN(  85)				int yRange__max1 = ii_max3;
HXDLIN(  85)				int range_x1 = xRange__start1;
HXDLIN(  85)				int range_y1 = (yRange__start1 - 1);
HXDLIN(  85)				int range_xReset1 = range_x1;
HXDLIN(  85)				int range_yReset1 = range_y1;
HXDLIN(  85)				int range_xMax1 = (xRange__max1 - 2);
HXDLIN(  85)				int range_yMax1 = (yRange__max1 - 2);
HXDLIN(  85)				int _this_min1 = 0;
HXDLIN(  85)				int _this_max1 = ::Std_obj::_hx_int(( (Float)(((xRange__max1 - xRange__start1) * (yRange__max1 - yRange__start1))) ));
HXDLIN(  85)				int width1 = ::Std_obj::_hx_int(w2);
HXDLIN(  85)				int height1 = ::Std_obj::_hx_int(h1);
HXDLIN(  85)				 ::Dynamic imageType1 = null();
HXDLIN(  85)				 ::pi_xy::ImageStruct this16 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  85)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE(  85)				::Dynamic _hx_tmp8;
HXDLIN(  85)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXDLIN(  85)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  85)						 ::iterMagic::BytesImg b4 = byt1;
HXDLIN(  85)						{
HXDLIN(  85)							b4->width = width1;
HXDLIN(  85)							b4->height = height1;
HXDLIN(  85)							b4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  85)							b4->data = ::haxe::io::Bytes_obj::alloc((b4->length * 4));
HXDLIN(  85)							{
HXDLIN(  85)								int len2 = b4->length;
HXDLIN(  85)								int w3 = 0;
HXDLIN(  85)								{
HXDLIN(  85)									int _g16 = 0;
HXDLIN(  85)									int _g17 = b4->height;
HXDLIN(  85)									while((_g16 < _g17)){
HXDLIN(  85)										_g16 = (_g16 + 1);
HXDLIN(  85)										int y3 = (_g16 - 1);
HXDLIN(  85)										{
HXDLIN(  85)											int _g18 = 0;
HXDLIN(  85)											int _g19 = b4->width;
HXDLIN(  85)											while((_g18 < _g19)){
HXDLIN(  85)												_g18 = (_g18 + 1);
HXDLIN(  85)												int x3 = (_g18 - 1);
HXDLIN(  85)												{
HXDLIN(  85)													w3 = (w3 + 1);
HXDLIN(  85)													b4->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  85)												{
HXDLIN(  85)													w3 = (w3 + 1);
HXDLIN(  85)													b4->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  85)												{
HXDLIN(  85)													w3 = (w3 + 1);
HXDLIN(  85)													b4->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  85)												{
HXDLIN(  85)													w3 = (w3 + 1);
HXDLIN(  85)													b4->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  85)						_hx_tmp8 = b4;
            					}
            					break;
            					case (int)1: {
HXDLIN(  85)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  85)						 ::iterMagic::ArrIntImg a5 = arrI1;
HXDLIN(  85)						{
HXDLIN(  85)							a5->width = width1;
HXDLIN(  85)							a5->height = height1;
HXDLIN(  85)							a5->data = ::Array_obj< int >::__new(0);
HXDLIN(  85)							a5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  85)							{
HXDLIN(  85)								int _g20 = 0;
HXDLIN(  85)								int _g21 = a5->length;
HXDLIN(  85)								while((_g20 < _g21)){
HXDLIN(  85)									_g20 = (_g20 + 1);
HXDLIN(  85)									int i8 = (_g20 - 1);
HXDLIN(  85)									a5->data[i8] = 0;
            								}
            							}
            						}
HXDLIN(  85)						_hx_tmp8 = a5;
            					}
            					break;
            					case (int)2: {
HXDLIN(  85)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  85)						 ::iterMagic::U32ArrImg b5 = u32a1;
HXDLIN(  85)						{
HXDLIN(  85)							b5->width = width1;
HXDLIN(  85)							b5->height = height1;
HXDLIN(  85)							b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  85)							int size1 = (b5->length * 4);
HXDLIN(  85)							b5->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  85)							{
HXDLIN(  85)								int _g22 = 0;
HXDLIN(  85)								int _g23 = b5->length;
HXDLIN(  85)								while((_g22 < _g23)){
HXDLIN(  85)									_g22 = (_g22 + 1);
HXDLIN(  85)									int i9 = (_g22 - 1);
HXDLIN(  85)									{
HXDLIN(  85)										 ::haxe::io::ArrayBufferViewImpl this17 = b5->data;
HXDLIN(  85)										bool _hx_tmp9;
HXDLIN(  85)										if ((i9 >= 0)) {
HXDLIN(  85)											_hx_tmp9 = (i9 < (this17->byteLength >> 2));
            										}
            										else {
HXDLIN(  85)											_hx_tmp9 = false;
            										}
HXDLIN(  85)										if (_hx_tmp9) {
HXDLIN(  85)											 ::haxe::io::Bytes _this1 = this17->bytes;
HXDLIN(  85)											int pos1 = ((i9 << 2) + this17->byteOffset);
HXDLIN(  85)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  85)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  85)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  85)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN(  85)						_hx_tmp8 = b5;
            					}
            					break;
            					case (int)3: {
HXDLIN(  85)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  85)						 ::iterMagic::VecIntImg v2 = vec1;
HXDLIN(  85)						{
HXDLIN(  85)							v2->width = width1;
HXDLIN(  85)							v2->height = height1;
HXDLIN(  85)							v2->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  85)							v2->data = ::Array_obj< int >::__new(v2->length);
HXDLIN(  85)							{
HXDLIN(  85)								int _g24 = 0;
HXDLIN(  85)								int _g25 = v2->length;
HXDLIN(  85)								while((_g24 < _g25)){
HXDLIN(  85)									_g24 = (_g24 + 1);
HXDLIN(  85)									int i10 = (_g24 - 1);
HXDLIN(  85)									v2->data->__unsafe_set(i10,0);
            								}
            							}
            						}
HXDLIN(  85)						_hx_tmp8 = v2;
            					}
            					break;
            					case (int)4: {
HXDLIN(  85)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  85)						 ::iterMagic::StackIntImg b6 = sInt1;
HXDLIN(  85)						{
HXDLIN(  85)							b6->width = width1;
HXDLIN(  85)							b6->height = height1;
HXDLIN(  85)							b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  85)							b6->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  85)							{
HXDLIN(  85)								int len3 = b6->length;
HXDLIN(  85)								 ::haxe::ds::GenericStack_Int d1 = b6->data;
HXDLIN(  85)								if (::hx::IsNull( d1->head )) {
HXDLIN(  85)									int _g26 = 0;
HXDLIN(  85)									int _g27 = len3;
HXDLIN(  85)									while((_g26 < _g27)){
HXDLIN(  85)										_g26 = (_g26 + 1);
HXDLIN(  85)										int i11 = (_g26 - 1);
HXDLIN(  85)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXDLIN(  85)									int _g28 = 0;
HXDLIN(  85)									int _g29 = len3;
HXDLIN(  85)									while((_g28 < _g29)){
HXDLIN(  85)										_g28 = (_g28 + 1);
HXDLIN(  85)										int i12 = (_g28 - 1);
HXDLIN(  85)										{
HXDLIN(  85)											 ::haxe::ds::GenericCell_Int l1 = b6->data->head;
HXDLIN(  85)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  85)											{
HXDLIN(  85)												int _g30 = 0;
HXDLIN(  85)												int _g31 = i12;
HXDLIN(  85)												while((_g30 < _g31)){
HXDLIN(  85)													_g30 = (_g30 + 1);
HXDLIN(  85)													int i13 = (_g30 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE(  85)											if (::hx::IsNull( prev1 )) {
HXDLIN(  85)												b6->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  85)												l1 = null();
            											}
            											else {
HXDLIN(  85)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  85)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  85)						_hx_tmp8 = b6;
            					}
            					break;
            				}
HXDLIN(  85)				this16->image = _hx_tmp8;
HXDLIN(  85)				this16->width = width1;
HXDLIN(  85)				this16->height = height1;
HXDLIN(  85)				this16->imageType = ( (int)(imageType1) );
HXDLIN(  85)				 ::pi_xy::ImageStruct nextImage1 = this16;
HXDLIN(  85)				nextImage1->transparent = transparent;
HXDLIN(  85)				while((_this_min1 < _this_max1)){
HXDLIN(  85)					_this_min1 = (_this_min1 + 1);
HXDLIN(  85)					int i14 = (_this_min1 - 1);
HXDLIN(  85)					if ((range_y1 > range_yMax1)) {
HXDLIN(  85)						range_y1 = range_yReset1;
HXDLIN(  85)						range_x1 = (range_x1 + 1);
            					}
HXDLIN(  85)					range_y1 = (range_y1 + 1);
HXDLIN(  85)					int i15 = i14;
HXDLIN(  85)					{
HXDLIN(  85)						int x4 = range_y1;
HXDLIN(  85)						int y4 = (range_xMax1 - range_x1);
HXDLIN(  85)						int x5 = range_y1;
HXDLIN(  85)						int y5 = range_x1;
HXDLIN(  85)						::Dynamic this18 = thisImage1->image;
HXDLIN(  85)						int index2;
HXDLIN(  85)						if (thisImage1->useVirtualPos) {
HXDLIN(  85)							index2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - thisImage1->virtualY) * ( (Float)(thisImage1->width) )) + x5) - thisImage1->virtualX));
            						}
            						else {
HXDLIN(  85)							index2 = ::Std_obj::_hx_int(( (Float)(((y5 * thisImage1->width) + x5)) ));
            						}
HXDLIN(  85)						int c2 = ::iterMagic::Iimg_obj::get(this18,index2);
HXDLIN(  85)						int color1;
HXDLIN(  85)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)							color1 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            						}
            						else {
HXDLIN(  85)							color1 = c2;
            						}
HXDLIN(  85)						int c3 = color1;
HXDLIN(  85)						bool _hx_tmp10;
HXDLIN(  85)						if ((((c3 >> 24) & 255) < 254)) {
HXDLIN(  85)							_hx_tmp10 = nextImage1->transparent;
            						}
            						else {
HXDLIN(  85)							_hx_tmp10 = false;
            						}
HXDLIN(  85)						if (_hx_tmp10) {
HXDLIN(  85)							int location1;
HXDLIN(  85)							if (nextImage1->useVirtualPos) {
HXDLIN(  85)								location1 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - nextImage1->virtualY) * ( (Float)(nextImage1->width) )) + x4) - nextImage1->virtualX));
            							}
            							else {
HXDLIN(  85)								location1 = ::Std_obj::_hx_int(( (Float)(((y4 * nextImage1->width) + x4)) ));
            							}
HXDLIN(  85)							int this19 = ::iterMagic::Iimg_obj::get(nextImage1->image,location1);
HXDLIN(  85)							int this20;
HXDLIN(  85)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)								this20 = ((((((this19 >> 24) & 255) << 24) | ((this19 & 255) << 16)) | (((this19 >> 8) & 255) << 8)) | ((this19 >> 16) & 255));
            							}
            							else {
HXDLIN(  85)								this20 = this19;
            							}
HXDLIN(  85)							Float a11;
HXDLIN(  85)							int this21 = ((this20 >> 24) & 255);
HXDLIN(  85)							if ((this21 == 0)) {
HXDLIN(  85)								a11 = ((Float)0.);
            							}
            							else {
HXDLIN(  85)								a11 = (( (Float)(this21) ) / ( (Float)(255) ));
            							}
HXDLIN(  85)							Float r11;
HXDLIN(  85)							int this22 = ((this20 >> 16) & 255);
HXDLIN(  85)							if ((this22 == 0)) {
HXDLIN(  85)								r11 = ((Float)0.);
            							}
            							else {
HXDLIN(  85)								r11 = (( (Float)(this22) ) / ( (Float)(255) ));
            							}
HXDLIN(  85)							Float g11;
HXDLIN(  85)							int this23 = ((this20 >> 8) & 255);
HXDLIN(  85)							if ((this23 == 0)) {
HXDLIN(  85)								g11 = ((Float)0.);
            							}
            							else {
HXDLIN(  85)								g11 = (( (Float)(this23) ) / ( (Float)(255) ));
            							}
HXDLIN(  85)							Float b12;
HXDLIN(  85)							int this24 = (this20 & 255);
HXDLIN(  85)							if ((this24 == 0)) {
HXDLIN(  85)								b12 = ((Float)0.);
            							}
            							else {
HXDLIN(  85)								b12 = (( (Float)(this24) ) / ( (Float)(255) ));
            							}
HXDLIN(  85)							Float a21;
HXDLIN(  85)							int this25 = ((color1 >> 24) & 255);
HXDLIN(  85)							if ((this25 == 0)) {
HXDLIN(  85)								a21 = ((Float)0.);
            							}
            							else {
HXDLIN(  85)								a21 = (( (Float)(this25) ) / ( (Float)(255) ));
            							}
HXDLIN(  85)							Float r21;
HXDLIN(  85)							int this26 = ((color1 >> 16) & 255);
HXDLIN(  85)							if ((this26 == 0)) {
HXDLIN(  85)								r21 = ((Float)0.);
            							}
            							else {
HXDLIN(  85)								r21 = (( (Float)(this26) ) / ( (Float)(255) ));
            							}
HXDLIN(  85)							Float g21;
HXDLIN(  85)							int this27 = ((color1 >> 8) & 255);
HXDLIN(  85)							if ((this27 == 0)) {
HXDLIN(  85)								g21 = ((Float)0.);
            							}
            							else {
HXDLIN(  85)								g21 = (( (Float)(this27) ) / ( (Float)(255) ));
            							}
HXDLIN(  85)							Float b22;
HXDLIN(  85)							int this28 = (color1 & 255);
HXDLIN(  85)							if ((this28 == 0)) {
HXDLIN(  85)								b22 = ((Float)0.);
            							}
            							else {
HXDLIN(  85)								b22 = (( (Float)(this28) ) / ( (Float)(255) ));
            							}
HXDLIN(  85)							Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  85)							int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  85)							int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  85)							int b7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  85)							int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  85)							int blended1 = ((((a6 << 24) | (r5 << 16)) | (g3 << 8)) | b7);
HXDLIN(  85)							{
HXDLIN(  85)								int _hx_tmp11;
HXDLIN(  85)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)									_hx_tmp11 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            								}
            								else {
HXDLIN(  85)									_hx_tmp11 = blended1;
            								}
HXDLIN(  85)								::iterMagic::Iimg_obj::set(nextImage1->image,location1,_hx_tmp11);
            							}
            						}
            						else {
HXDLIN(  85)							::Dynamic this29 = nextImage1->image;
HXDLIN(  85)							int index3;
HXDLIN(  85)							if (nextImage1->useVirtualPos) {
HXDLIN(  85)								index3 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - nextImage1->virtualY) * ( (Float)(nextImage1->width) )) + x4) - nextImage1->virtualX));
            							}
            							else {
HXDLIN(  85)								index3 = ::Std_obj::_hx_int(( (Float)(((y4 * nextImage1->width) + x4)) ));
            							}
HXDLIN(  85)							int _hx_tmp12;
HXDLIN(  85)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)								_hx_tmp12 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            							}
            							else {
HXDLIN(  85)								_hx_tmp12 = c3;
            							}
HXDLIN(  85)							::iterMagic::Iimg_obj::set(this29,index3,_hx_tmp12);
            						}
            					}
            				}
HXDLIN(  85)				bool _hx_tmp13;
HXDLIN(  85)				if (::hx::IsNotNull( thisImage1->mask )) {
HXDLIN(  85)					_hx_tmp13 = includeMask;
            				}
            				else {
HXDLIN(  85)					_hx_tmp13 = false;
            				}
HXDLIN(  85)				if (_hx_tmp13) {
HXDLIN(  85)					 ::pi_xy::ImageStruct v3 = ::pi_xy::transformation::_SpinImage::SpinImage_Fields__obj::spinAntiClock90(thisImage1->mask,( (Float)(0) ),( (Float)(0) ),w2,h1,thisImage1->mask->transparent,includeMask);
HXDLIN(  85)					nextImage1->useMask = true;
HXDLIN(  85)					nextImage1->mask = v3;
            				}
HXDLIN(  85)				return nextImage1;
            			}
            			else {
HXDLIN(  85)				bool _hx_tmp14;
HXDLIN(  85)				if ((theta1 != ::Math_obj::PI)) {
HXDLIN(  85)					_hx_tmp14 = (theta1 == -(::Math_obj::PI));
            				}
            				else {
HXDLIN(  85)					_hx_tmp14 = true;
            				}
HXDLIN(  85)				if (_hx_tmp14) {
HXDLIN(  85)					Float w4 = ( (Float)(this1->width) );
HXDLIN(  85)					Float h2 = ( (Float)(this1->height) );
HXDLIN(  85)					 ::pi_xy::ImageStruct thisImage2 = this1;
HXDLIN(  85)					 ::Dynamic r6 =  ::Dynamic(::hx::Anon_obj::Create(4)
            						->setFixed(0,HX_("h",68,00,00,00),h2)
            						->setFixed(1,HX_("w",77,00,00,00),w4)
            						->setFixed(2,HX_("x",78,00,00,00),0)
            						->setFixed(3,HX_("y",79,00,00,00),0));
HXDLIN(  85)					int xmax2 = ::Std_obj::_hx_int(( (Float)(((r6->__Field(HX_("x",78,00,00,00),::hx::paccDynamic) + r6->__Field(HX_("w",77,00,00,00),::hx::paccDynamic)) + 1)) ));
HXDLIN(  85)					int ymax2 = ::Std_obj::_hx_int(( (Float)(((r6->__Field(HX_("y",79,00,00,00),::hx::paccDynamic) + r6->__Field(HX_("h",68,00,00,00),::hx::paccDynamic)) + 1)) ));
HXDLIN(  85)					int ii_min4 = ::Std_obj::_hx_int(( (Float)(r6->__Field(HX_("x",78,00,00,00),::hx::paccDynamic)) ));
HXDLIN(  85)					int ii_max4 = xmax2;
HXDLIN(  85)					int xRange__start2 = ii_min4;
HXDLIN(  85)					int xRange__max2 = ii_max4;
HXDLIN(  85)					int ii_min5 = ::Std_obj::_hx_int(( (Float)(r6->__Field(HX_("y",79,00,00,00),::hx::paccDynamic)) ));
HXDLIN(  85)					int ii_max5 = ymax2;
HXDLIN(  85)					int yRange__start2 = ii_min5;
HXDLIN(  85)					int yRange__max2 = ii_max5;
HXDLIN(  85)					int range_x2 = xRange__start2;
HXDLIN(  85)					int range_y2 = (yRange__start2 - 1);
HXDLIN(  85)					int range_xReset2 = range_x2;
HXDLIN(  85)					int range_yReset2 = range_y2;
HXDLIN(  85)					int range_xMax2 = (xRange__max2 - 2);
HXDLIN(  85)					int range_yMax2 = (yRange__max2 - 2);
HXDLIN(  85)					int _this_min2 = 0;
HXDLIN(  85)					int _this_max2 = ::Std_obj::_hx_int(( (Float)(((xRange__max2 - xRange__start2) * (yRange__max2 - yRange__start2))) ));
HXDLIN(  85)					int width2 = ::Std_obj::_hx_int(w4);
HXDLIN(  85)					int height2 = ::Std_obj::_hx_int(h2);
HXDLIN(  85)					 ::Dynamic imageType2 = null();
HXDLIN(  85)					 ::pi_xy::ImageStruct this30 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  85)					if (::hx::IsNull( imageType2 )) {
HXLINE(  54)						imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE(  85)					::Dynamic _hx_tmp15;
HXDLIN(  85)					switch((int)(( (int)(imageType2) ))){
            						case (int)0: {
HXDLIN(  85)							 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  85)							 ::iterMagic::BytesImg b8 = byt2;
HXDLIN(  85)							{
HXDLIN(  85)								b8->width = width2;
HXDLIN(  85)								b8->height = height2;
HXDLIN(  85)								b8->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  85)								b8->data = ::haxe::io::Bytes_obj::alloc((b8->length * 4));
HXDLIN(  85)								{
HXDLIN(  85)									int len4 = b8->length;
HXDLIN(  85)									int w5 = 0;
HXDLIN(  85)									{
HXDLIN(  85)										int _g32 = 0;
HXDLIN(  85)										int _g33 = b8->height;
HXDLIN(  85)										while((_g32 < _g33)){
HXDLIN(  85)											_g32 = (_g32 + 1);
HXDLIN(  85)											int y6 = (_g32 - 1);
HXDLIN(  85)											{
HXDLIN(  85)												int _g34 = 0;
HXDLIN(  85)												int _g35 = b8->width;
HXDLIN(  85)												while((_g34 < _g35)){
HXDLIN(  85)													_g34 = (_g34 + 1);
HXDLIN(  85)													int x6 = (_g34 - 1);
HXDLIN(  85)													{
HXDLIN(  85)														w5 = (w5 + 1);
HXDLIN(  85)														b8->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  85)													{
HXDLIN(  85)														w5 = (w5 + 1);
HXDLIN(  85)														b8->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  85)													{
HXDLIN(  85)														w5 = (w5 + 1);
HXDLIN(  85)														b8->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  85)													{
HXDLIN(  85)														w5 = (w5 + 1);
HXDLIN(  85)														b8->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  85)							_hx_tmp15 = b8;
            						}
            						break;
            						case (int)1: {
HXDLIN(  85)							 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  85)							 ::iterMagic::ArrIntImg a7 = arrI2;
HXDLIN(  85)							{
HXDLIN(  85)								a7->width = width2;
HXDLIN(  85)								a7->height = height2;
HXDLIN(  85)								a7->data = ::Array_obj< int >::__new(0);
HXDLIN(  85)								a7->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  85)								{
HXDLIN(  85)									int _g36 = 0;
HXDLIN(  85)									int _g37 = a7->length;
HXDLIN(  85)									while((_g36 < _g37)){
HXDLIN(  85)										_g36 = (_g36 + 1);
HXDLIN(  85)										int i16 = (_g36 - 1);
HXDLIN(  85)										a7->data[i16] = 0;
            									}
            								}
            							}
HXDLIN(  85)							_hx_tmp15 = a7;
            						}
            						break;
            						case (int)2: {
HXDLIN(  85)							 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  85)							 ::iterMagic::U32ArrImg b9 = u32a2;
HXDLIN(  85)							{
HXDLIN(  85)								b9->width = width2;
HXDLIN(  85)								b9->height = height2;
HXDLIN(  85)								b9->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  85)								int size2 = (b9->length * 4);
HXDLIN(  85)								b9->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN(  85)								{
HXDLIN(  85)									int _g38 = 0;
HXDLIN(  85)									int _g39 = b9->length;
HXDLIN(  85)									while((_g38 < _g39)){
HXDLIN(  85)										_g38 = (_g38 + 1);
HXDLIN(  85)										int i17 = (_g38 - 1);
HXDLIN(  85)										{
HXDLIN(  85)											 ::haxe::io::ArrayBufferViewImpl this31 = b9->data;
HXDLIN(  85)											bool _hx_tmp16;
HXDLIN(  85)											if ((i17 >= 0)) {
HXDLIN(  85)												_hx_tmp16 = (i17 < (this31->byteLength >> 2));
            											}
            											else {
HXDLIN(  85)												_hx_tmp16 = false;
            											}
HXDLIN(  85)											if (_hx_tmp16) {
HXDLIN(  85)												 ::haxe::io::Bytes _this2 = this31->bytes;
HXDLIN(  85)												int pos2 = ((i17 << 2) + this31->byteOffset);
HXDLIN(  85)												_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN(  85)												_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN(  85)												_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN(  85)												_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN(  85)							_hx_tmp15 = b9;
            						}
            						break;
            						case (int)3: {
HXDLIN(  85)							 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  85)							 ::iterMagic::VecIntImg v4 = vec2;
HXDLIN(  85)							{
HXDLIN(  85)								v4->width = width2;
HXDLIN(  85)								v4->height = height2;
HXDLIN(  85)								v4->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  85)								v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN(  85)								{
HXDLIN(  85)									int _g40 = 0;
HXDLIN(  85)									int _g41 = v4->length;
HXDLIN(  85)									while((_g40 < _g41)){
HXDLIN(  85)										_g40 = (_g40 + 1);
HXDLIN(  85)										int i18 = (_g40 - 1);
HXDLIN(  85)										v4->data->__unsafe_set(i18,0);
            									}
            								}
            							}
HXDLIN(  85)							_hx_tmp15 = v4;
            						}
            						break;
            						case (int)4: {
HXDLIN(  85)							 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  85)							 ::iterMagic::StackIntImg b10 = sInt2;
HXDLIN(  85)							{
HXDLIN(  85)								b10->width = width2;
HXDLIN(  85)								b10->height = height2;
HXDLIN(  85)								b10->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  85)								b10->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  85)								{
HXDLIN(  85)									int len5 = b10->length;
HXDLIN(  85)									 ::haxe::ds::GenericStack_Int d2 = b10->data;
HXDLIN(  85)									if (::hx::IsNull( d2->head )) {
HXDLIN(  85)										int _g42 = 0;
HXDLIN(  85)										int _g43 = len5;
HXDLIN(  85)										while((_g42 < _g43)){
HXDLIN(  85)											_g42 = (_g42 + 1);
HXDLIN(  85)											int i19 = (_g42 - 1);
HXDLIN(  85)											d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            										}
            									}
            									else {
HXDLIN(  85)										int _g44 = 0;
HXDLIN(  85)										int _g45 = len5;
HXDLIN(  85)										while((_g44 < _g45)){
HXDLIN(  85)											_g44 = (_g44 + 1);
HXDLIN(  85)											int i20 = (_g44 - 1);
HXDLIN(  85)											{
HXDLIN(  85)												 ::haxe::ds::GenericCell_Int l2 = b10->data->head;
HXDLIN(  85)												 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN(  85)												{
HXDLIN(  85)													int _g46 = 0;
HXDLIN(  85)													int _g47 = i20;
HXDLIN(  85)													while((_g46 < _g47)){
HXDLIN(  85)														_g46 = (_g46 + 1);
HXDLIN(  85)														int i21 = (_g46 - 1);
HXLINE( 345)														prev2 = l2;
HXLINE( 346)														l2 = l2->next;
            													}
            												}
HXLINE(  85)												if (::hx::IsNull( prev2 )) {
HXDLIN(  85)													b10->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  85)													l2 = null();
            												}
            												else {
HXDLIN(  85)													prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  85)													l2 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  85)							_hx_tmp15 = b10;
            						}
            						break;
            					}
HXDLIN(  85)					this30->image = _hx_tmp15;
HXDLIN(  85)					this30->width = width2;
HXDLIN(  85)					this30->height = height2;
HXDLIN(  85)					this30->imageType = ( (int)(imageType2) );
HXDLIN(  85)					 ::pi_xy::ImageStruct nextImage2 = this30;
HXDLIN(  85)					nextImage2->transparent = transparent;
HXDLIN(  85)					while((_this_min2 < _this_max2)){
HXDLIN(  85)						_this_min2 = (_this_min2 + 1);
HXDLIN(  85)						int i22 = (_this_min2 - 1);
HXDLIN(  85)						if ((range_y2 > range_yMax2)) {
HXDLIN(  85)							range_y2 = range_yReset2;
HXDLIN(  85)							range_x2 = (range_x2 + 1);
            						}
HXDLIN(  85)						range_y2 = (range_y2 + 1);
HXDLIN(  85)						int i23 = i22;
HXDLIN(  85)						{
HXDLIN(  85)							int x7 = (range_xMax2 - range_x2);
HXDLIN(  85)							int y7 = (range_yMax2 - range_y2);
HXDLIN(  85)							int x8 = range_x2;
HXDLIN(  85)							int y8 = range_y2;
HXDLIN(  85)							::Dynamic this32 = thisImage2->image;
HXDLIN(  85)							int index4;
HXDLIN(  85)							if (thisImage2->useVirtualPos) {
HXDLIN(  85)								index4 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - thisImage2->virtualY) * ( (Float)(thisImage2->width) )) + x8) - thisImage2->virtualX));
            							}
            							else {
HXDLIN(  85)								index4 = ::Std_obj::_hx_int(( (Float)(((y8 * thisImage2->width) + x8)) ));
            							}
HXDLIN(  85)							int c4 = ::iterMagic::Iimg_obj::get(this32,index4);
HXDLIN(  85)							int color2;
HXDLIN(  85)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)								color2 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            							}
            							else {
HXDLIN(  85)								color2 = c4;
            							}
HXDLIN(  85)							int c5 = color2;
HXDLIN(  85)							bool _hx_tmp17;
HXDLIN(  85)							if ((((c5 >> 24) & 255) < 254)) {
HXDLIN(  85)								_hx_tmp17 = nextImage2->transparent;
            							}
            							else {
HXDLIN(  85)								_hx_tmp17 = false;
            							}
HXDLIN(  85)							if (_hx_tmp17) {
HXDLIN(  85)								int location2;
HXDLIN(  85)								if (nextImage2->useVirtualPos) {
HXDLIN(  85)									location2 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - nextImage2->virtualY) * ( (Float)(nextImage2->width) )) + x7) - nextImage2->virtualX));
            								}
            								else {
HXDLIN(  85)									location2 = ::Std_obj::_hx_int(( (Float)(((y7 * nextImage2->width) + x7)) ));
            								}
HXDLIN(  85)								int this33 = ::iterMagic::Iimg_obj::get(nextImage2->image,location2);
HXDLIN(  85)								int this34;
HXDLIN(  85)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)									this34 = ((((((this33 >> 24) & 255) << 24) | ((this33 & 255) << 16)) | (((this33 >> 8) & 255) << 8)) | ((this33 >> 16) & 255));
            								}
            								else {
HXDLIN(  85)									this34 = this33;
            								}
HXDLIN(  85)								Float a12;
HXDLIN(  85)								int this35 = ((this34 >> 24) & 255);
HXDLIN(  85)								if ((this35 == 0)) {
HXDLIN(  85)									a12 = ((Float)0.);
            								}
            								else {
HXDLIN(  85)									a12 = (( (Float)(this35) ) / ( (Float)(255) ));
            								}
HXDLIN(  85)								Float r12;
HXDLIN(  85)								int this36 = ((this34 >> 16) & 255);
HXDLIN(  85)								if ((this36 == 0)) {
HXDLIN(  85)									r12 = ((Float)0.);
            								}
            								else {
HXDLIN(  85)									r12 = (( (Float)(this36) ) / ( (Float)(255) ));
            								}
HXDLIN(  85)								Float g12;
HXDLIN(  85)								int this37 = ((this34 >> 8) & 255);
HXDLIN(  85)								if ((this37 == 0)) {
HXDLIN(  85)									g12 = ((Float)0.);
            								}
            								else {
HXDLIN(  85)									g12 = (( (Float)(this37) ) / ( (Float)(255) ));
            								}
HXDLIN(  85)								Float b13;
HXDLIN(  85)								int this38 = (this34 & 255);
HXDLIN(  85)								if ((this38 == 0)) {
HXDLIN(  85)									b13 = ((Float)0.);
            								}
            								else {
HXDLIN(  85)									b13 = (( (Float)(this38) ) / ( (Float)(255) ));
            								}
HXDLIN(  85)								Float a22;
HXDLIN(  85)								int this39 = ((color2 >> 24) & 255);
HXDLIN(  85)								if ((this39 == 0)) {
HXDLIN(  85)									a22 = ((Float)0.);
            								}
            								else {
HXDLIN(  85)									a22 = (( (Float)(this39) ) / ( (Float)(255) ));
            								}
HXDLIN(  85)								Float r22;
HXDLIN(  85)								int this40 = ((color2 >> 16) & 255);
HXDLIN(  85)								if ((this40 == 0)) {
HXDLIN(  85)									r22 = ((Float)0.);
            								}
            								else {
HXDLIN(  85)									r22 = (( (Float)(this40) ) / ( (Float)(255) ));
            								}
HXDLIN(  85)								Float g22;
HXDLIN(  85)								int this41 = ((color2 >> 8) & 255);
HXDLIN(  85)								if ((this41 == 0)) {
HXDLIN(  85)									g22 = ((Float)0.);
            								}
            								else {
HXDLIN(  85)									g22 = (( (Float)(this41) ) / ( (Float)(255) ));
            								}
HXDLIN(  85)								Float b23;
HXDLIN(  85)								int this42 = (color2 & 255);
HXDLIN(  85)								if ((this42 == 0)) {
HXDLIN(  85)									b23 = ((Float)0.);
            								}
            								else {
HXDLIN(  85)									b23 = (( (Float)(this42) ) / ( (Float)(255) ));
            								}
HXDLIN(  85)								Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  85)								int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  85)								int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  85)								int b14 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  85)								int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  85)								int blended2 = ((((a8 << 24) | (r7 << 16)) | (g4 << 8)) | b14);
HXDLIN(  85)								{
HXDLIN(  85)									int _hx_tmp18;
HXDLIN(  85)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)										_hx_tmp18 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            									}
            									else {
HXDLIN(  85)										_hx_tmp18 = blended2;
            									}
HXDLIN(  85)									::iterMagic::Iimg_obj::set(nextImage2->image,location2,_hx_tmp18);
            								}
            							}
            							else {
HXDLIN(  85)								::Dynamic this43 = nextImage2->image;
HXDLIN(  85)								int index5;
HXDLIN(  85)								if (nextImage2->useVirtualPos) {
HXDLIN(  85)									index5 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - nextImage2->virtualY) * ( (Float)(nextImage2->width) )) + x7) - nextImage2->virtualX));
            								}
            								else {
HXDLIN(  85)									index5 = ::Std_obj::_hx_int(( (Float)(((y7 * nextImage2->width) + x7)) ));
            								}
HXDLIN(  85)								int _hx_tmp19;
HXDLIN(  85)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)									_hx_tmp19 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            								}
            								else {
HXDLIN(  85)									_hx_tmp19 = c5;
            								}
HXDLIN(  85)								::iterMagic::Iimg_obj::set(this43,index5,_hx_tmp19);
            							}
            						}
            					}
HXDLIN(  85)					bool _hx_tmp20;
HXDLIN(  85)					if (::hx::IsNotNull( thisImage2->mask )) {
HXDLIN(  85)						_hx_tmp20 = includeMask;
            					}
            					else {
HXDLIN(  85)						_hx_tmp20 = false;
            					}
HXDLIN(  85)					if (_hx_tmp20) {
HXDLIN(  85)						 ::pi_xy::ImageStruct v5 = ::pi_xy::transformation::_SpinImage::SpinImage_Fields__obj::spin180(thisImage2->mask,( (Float)(0) ),( (Float)(0) ),w4,h2,thisImage2->mask->transparent,includeMask);
HXDLIN(  85)						nextImage2->useMask = true;
HXDLIN(  85)						nextImage2->mask = v5;
            					}
HXDLIN(  85)					return nextImage2;
            				}
            				else {
HXDLIN(  85)					 ::pi_xy::ImageStruct this44 = this1;
HXDLIN(  85)					Float centreX1 = centreX;
HXDLIN(  85)					Float centreY1 = centreY;
HXDLIN(  85)					Float ax = ((Float)0.);
HXDLIN(  85)					Float ay = ((Float)0.);
HXDLIN(  85)					if ((centreX1 != ((Float)0.))) {
HXLINE( 173)						centreX1 = ((( (Float)(this44->width) ) / ( (Float)(2) )) + centreX1);
HXLINE(  85)						ax = (ax - centreX1);
            					}
HXDLIN(  85)					if ((centreY1 != ((Float)0.))) {
HXLINE( 177)						centreY1 = ((( (Float)(this44->height) ) / ( (Float)(2) )) + centreY1);
HXLINE(  85)						ay = (ay - centreY1);
            					}
HXDLIN(  85)					Float bx = (ax + this44->width);
HXDLIN(  85)					Float by = ay;
HXDLIN(  85)					Float cx = bx;
HXDLIN(  85)					Float cy = (ay + this44->height);
HXDLIN(  85)					Float dx = ax;
HXDLIN(  85)					Float dy = cy;
HXDLIN(  85)					Float sin = ::Math_obj::sin(theta1);
HXDLIN(  85)					Float cos = ::Math_obj::cos(theta1);
HXDLIN(  85)					Float temp = ax;
HXLINE( 189)					ax = ((temp * cos) - (ay * sin));
HXLINE( 190)					ay = ((ay * cos) + (temp * sin));
HXLINE(  85)					Float temp1 = bx;
HXLINE( 192)					bx = ((temp1 * cos) - (by * sin));
HXLINE( 193)					by = ((by * cos) + (temp1 * sin));
HXLINE(  85)					Float temp2 = cx;
HXLINE( 195)					cx = ((temp2 * cos) - (cy * sin));
HXLINE( 196)					cy = ((cy * cos) + (temp2 * sin));
HXLINE(  85)					Float temp3 = dx;
HXLINE( 198)					dx = ((temp3 * cos) - (dy * sin));
HXLINE( 199)					dy = ((dy * cos) + (temp3 * sin));
HXLINE(  85)					if ((centreX1 != ((Float)0.))) {
HXDLIN(  85)						ax = (ax + centreX1);
HXDLIN(  85)						bx = (bx + centreX1);
HXDLIN(  85)						cx = (cx + centreX1);
HXDLIN(  85)						dx = (dx + centreX1);
            					}
HXDLIN(  85)					if ((centreY1 != ((Float)0.))) {
HXDLIN(  85)						ay = (ay + centreY1);
HXDLIN(  85)						by = (by + centreY1);
HXDLIN(  85)						cy = (cy + centreY1);
HXDLIN(  85)						dy = (dy + centreY1);
            					}
HXDLIN(  85)					int min = ::Math_obj::floor(ax);
HXDLIN(  85)					int max = ::Math_obj::ceil(ax);
HXDLIN(  85)					if ((bx < min)) {
HXLINE(  31)						min = ::Math_obj::floor(bx);
            					}
            					else {
HXDLIN(  85)						if ((bx > max)) {
HXLINE(  33)							max = ::Math_obj::ceil(bx);
            						}
            					}
HXLINE(  85)					if ((cx < min)) {
HXLINE(  36)						min = ::Math_obj::floor(cx);
            					}
            					else {
HXDLIN(  85)						if ((cx > max)) {
HXLINE(  38)							max = ::Math_obj::ceil(cx);
            						}
            					}
HXLINE(  85)					if ((dx < min)) {
HXLINE(  41)						min = ::Math_obj::floor(dx);
            					}
            					else {
HXDLIN(  85)						if ((dx > max)) {
HXLINE(  43)							max = ::Math_obj::ceil(dx);
            						}
            					}
HXLINE(  85)					int ii_min6 = min;
HXDLIN(  85)					int ii_max6 = max;
HXDLIN(  85)					 ::pi_xy::iter::IntIterStart boundX =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
HXDLIN(  85)					int min1 = ::Math_obj::floor(ay);
HXDLIN(  85)					int max1 = ::Math_obj::ceil(ay);
HXDLIN(  85)					if ((by < min1)) {
HXLINE(  31)						min1 = ::Math_obj::floor(by);
            					}
            					else {
HXDLIN(  85)						if ((by > max1)) {
HXLINE(  33)							max1 = ::Math_obj::ceil(by);
            						}
            					}
HXLINE(  85)					if ((cy < min1)) {
HXLINE(  36)						min1 = ::Math_obj::floor(cy);
            					}
            					else {
HXDLIN(  85)						if ((cy > max1)) {
HXLINE(  38)							max1 = ::Math_obj::ceil(cy);
            						}
            					}
HXLINE(  85)					if ((dy < min1)) {
HXLINE(  41)						min1 = ::Math_obj::floor(dy);
            					}
            					else {
HXDLIN(  85)						if ((dy > max1)) {
HXLINE(  43)							max1 = ::Math_obj::ceil(dy);
            						}
            					}
HXLINE(  85)					int ii_min7 = min1;
HXDLIN(  85)					int ii_max7 = max1;
HXDLIN(  85)					 ::pi_xy::iter::IntIterStart boundY =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
HXDLIN(  85)					int minX = boundX->start;
HXDLIN(  85)					int wid = ((boundX->max - boundX->start) + 1);
HXDLIN(  85)					int minY = boundY->start;
HXDLIN(  85)					int hi = ((boundY->max - boundY->start) + 1);
HXDLIN(  85)					 ::Dynamic imageType3 = null();
HXDLIN(  85)					 ::pi_xy::ImageStruct this45 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  85)					if (::hx::IsNull( imageType3 )) {
HXLINE(  54)						imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE(  85)					::Dynamic _hx_tmp21;
HXDLIN(  85)					switch((int)(( (int)(imageType3) ))){
            						case (int)0: {
HXDLIN(  85)							 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  85)							 ::iterMagic::BytesImg b15 = byt3;
HXDLIN(  85)							{
HXDLIN(  85)								b15->width = wid;
HXDLIN(  85)								b15->height = hi;
HXDLIN(  85)								b15->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  85)								b15->data = ::haxe::io::Bytes_obj::alloc((b15->length * 4));
HXDLIN(  85)								{
HXDLIN(  85)									int len6 = b15->length;
HXDLIN(  85)									int w6 = 0;
HXDLIN(  85)									{
HXDLIN(  85)										int _g48 = 0;
HXDLIN(  85)										int _g49 = b15->height;
HXDLIN(  85)										while((_g48 < _g49)){
HXDLIN(  85)											_g48 = (_g48 + 1);
HXDLIN(  85)											int y9 = (_g48 - 1);
HXDLIN(  85)											{
HXDLIN(  85)												int _g50 = 0;
HXDLIN(  85)												int _g51 = b15->width;
HXDLIN(  85)												while((_g50 < _g51)){
HXDLIN(  85)													_g50 = (_g50 + 1);
HXDLIN(  85)													int x9 = (_g50 - 1);
HXDLIN(  85)													{
HXDLIN(  85)														w6 = (w6 + 1);
HXDLIN(  85)														b15->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  85)													{
HXDLIN(  85)														w6 = (w6 + 1);
HXDLIN(  85)														b15->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  85)													{
HXDLIN(  85)														w6 = (w6 + 1);
HXDLIN(  85)														b15->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  85)													{
HXDLIN(  85)														w6 = (w6 + 1);
HXDLIN(  85)														b15->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  85)							_hx_tmp21 = b15;
            						}
            						break;
            						case (int)1: {
HXDLIN(  85)							 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  85)							 ::iterMagic::ArrIntImg a9 = arrI3;
HXDLIN(  85)							{
HXDLIN(  85)								a9->width = wid;
HXDLIN(  85)								a9->height = hi;
HXDLIN(  85)								a9->data = ::Array_obj< int >::__new(0);
HXDLIN(  85)								a9->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  85)								{
HXDLIN(  85)									int _g52 = 0;
HXDLIN(  85)									int _g53 = a9->length;
HXDLIN(  85)									while((_g52 < _g53)){
HXDLIN(  85)										_g52 = (_g52 + 1);
HXDLIN(  85)										int i24 = (_g52 - 1);
HXDLIN(  85)										a9->data[i24] = 0;
            									}
            								}
            							}
HXDLIN(  85)							_hx_tmp21 = a9;
            						}
            						break;
            						case (int)2: {
HXDLIN(  85)							 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  85)							 ::iterMagic::U32ArrImg b16 = u32a3;
HXDLIN(  85)							{
HXDLIN(  85)								b16->width = wid;
HXDLIN(  85)								b16->height = hi;
HXDLIN(  85)								b16->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  85)								int size3 = (b16->length * 4);
HXDLIN(  85)								b16->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN(  85)								{
HXDLIN(  85)									int _g54 = 0;
HXDLIN(  85)									int _g55 = b16->length;
HXDLIN(  85)									while((_g54 < _g55)){
HXDLIN(  85)										_g54 = (_g54 + 1);
HXDLIN(  85)										int i25 = (_g54 - 1);
HXDLIN(  85)										{
HXDLIN(  85)											 ::haxe::io::ArrayBufferViewImpl this46 = b16->data;
HXDLIN(  85)											bool _hx_tmp22;
HXDLIN(  85)											if ((i25 >= 0)) {
HXDLIN(  85)												_hx_tmp22 = (i25 < (this46->byteLength >> 2));
            											}
            											else {
HXDLIN(  85)												_hx_tmp22 = false;
            											}
HXDLIN(  85)											if (_hx_tmp22) {
HXDLIN(  85)												 ::haxe::io::Bytes _this3 = this46->bytes;
HXDLIN(  85)												int pos3 = ((i25 << 2) + this46->byteOffset);
HXDLIN(  85)												_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN(  85)												_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN(  85)												_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN(  85)												_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN(  85)							_hx_tmp21 = b16;
            						}
            						break;
            						case (int)3: {
HXDLIN(  85)							 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  85)							 ::iterMagic::VecIntImg v6 = vec3;
HXDLIN(  85)							{
HXDLIN(  85)								v6->width = wid;
HXDLIN(  85)								v6->height = hi;
HXDLIN(  85)								v6->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  85)								v6->data = ::Array_obj< int >::__new(v6->length);
HXDLIN(  85)								{
HXDLIN(  85)									int _g56 = 0;
HXDLIN(  85)									int _g57 = v6->length;
HXDLIN(  85)									while((_g56 < _g57)){
HXDLIN(  85)										_g56 = (_g56 + 1);
HXDLIN(  85)										int i26 = (_g56 - 1);
HXDLIN(  85)										v6->data->__unsafe_set(i26,0);
            									}
            								}
            							}
HXDLIN(  85)							_hx_tmp21 = v6;
            						}
            						break;
            						case (int)4: {
HXDLIN(  85)							 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  85)							 ::iterMagic::StackIntImg b17 = sInt3;
HXDLIN(  85)							{
HXDLIN(  85)								b17->width = wid;
HXDLIN(  85)								b17->height = hi;
HXDLIN(  85)								b17->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  85)								b17->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  85)								{
HXDLIN(  85)									int len7 = b17->length;
HXDLIN(  85)									 ::haxe::ds::GenericStack_Int d3 = b17->data;
HXDLIN(  85)									if (::hx::IsNull( d3->head )) {
HXDLIN(  85)										int _g58 = 0;
HXDLIN(  85)										int _g59 = len7;
HXDLIN(  85)										while((_g58 < _g59)){
HXDLIN(  85)											_g58 = (_g58 + 1);
HXDLIN(  85)											int i27 = (_g58 - 1);
HXDLIN(  85)											d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            										}
            									}
            									else {
HXDLIN(  85)										int _g60 = 0;
HXDLIN(  85)										int _g61 = len7;
HXDLIN(  85)										while((_g60 < _g61)){
HXDLIN(  85)											_g60 = (_g60 + 1);
HXDLIN(  85)											int i28 = (_g60 - 1);
HXDLIN(  85)											{
HXDLIN(  85)												 ::haxe::ds::GenericCell_Int l3 = b17->data->head;
HXDLIN(  85)												 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN(  85)												{
HXDLIN(  85)													int _g62 = 0;
HXDLIN(  85)													int _g63 = i28;
HXDLIN(  85)													while((_g62 < _g63)){
HXDLIN(  85)														_g62 = (_g62 + 1);
HXDLIN(  85)														int i29 = (_g62 - 1);
HXLINE( 345)														prev3 = l3;
HXLINE( 346)														l3 = l3->next;
            													}
            												}
HXLINE(  85)												if (::hx::IsNull( prev3 )) {
HXDLIN(  85)													b17->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  85)													l3 = null();
            												}
            												else {
HXDLIN(  85)													prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  85)													l3 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  85)							_hx_tmp21 = b17;
            						}
            						break;
            					}
HXDLIN(  85)					this45->image = _hx_tmp21;
HXDLIN(  85)					this45->width = wid;
HXDLIN(  85)					this45->height = hi;
HXDLIN(  85)					this45->imageType = ( (int)(imageType3) );
HXDLIN(  85)					 ::pi_xy::ImageStruct nextImage3 = this45;
HXDLIN(  85)					nextImage3->transparent = true;
HXDLIN(  85)					if ((minX < ((Float)0.))) {
HXDLIN(  85)						ax = (ax - ( (Float)(minX) ));
HXDLIN(  85)						bx = (bx - ( (Float)(minX) ));
HXDLIN(  85)						cx = (cx - ( (Float)(minX) ));
HXDLIN(  85)						dx = (dx - ( (Float)(minX) ));
            					}
HXDLIN(  85)					if ((minY < ((Float)0.))) {
HXDLIN(  85)						ay = (ay - ( (Float)(minY) ));
HXDLIN(  85)						by = (by - ( (Float)(minY) ));
HXDLIN(  85)						cy = (cy - ( (Float)(minY) ));
HXDLIN(  85)						dy = (dy - ( (Float)(minY) ));
            					}
HXDLIN(  85)					{
HXDLIN(  85)						 ::pi_xy::ImageStruct this47 = nextImage3;
HXDLIN(  85)						Float win_x = ( (Float)(0) );
HXDLIN(  85)						Float win_y = ( (Float)(0) );
HXDLIN(  85)						Float win_width = ( (Float)(this44->width) );
HXDLIN(  85)						Float win_height = ( (Float)(this44->height) );
HXDLIN(  85)						{
HXDLIN(  85)							Float bu = ((Float)1.);
HXDLIN(  85)							Float bv = ((Float)0.);
HXDLIN(  85)							Float cu = ((Float)1.);
HXDLIN(  85)							Float cv = ((Float)1.);
HXDLIN(  85)							Float du = ((Float)0.);
HXDLIN(  85)							Float dv = ((Float)1.);
HXDLIN(  85)							Float au = ((Float)0.);
HXDLIN(  85)							Float av = ((Float)0.);
HXDLIN(  85)							Float bu1 = bu;
HXDLIN(  85)							Float bv1 = bv;
HXDLIN(  85)							bool hasUndo = false;
HXDLIN(  85)							Float temp4 = au;
HXLINE( 422)							au = bu1;
HXLINE( 423)							bu1 = temp4;
HXLINE( 424)							temp4 = av;
HXLINE( 425)							av = bv1;
HXLINE( 426)							bv1 = temp4;
HXLINE(  85)							Float bcx = (bx - dx);
HXDLIN(  85)							Float bcy = (by - dy);
HXDLIN(  85)							Float acx = (ax - dx);
HXDLIN(  85)							Float acy = (ay - dy);
HXDLIN(  85)							Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  85)							Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  85)							Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  85)							Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  85)							 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  85)							if ((ax > bx)) {
HXDLIN(  85)								if ((ax > dx)) {
HXDLIN(  85)									int min2;
HXDLIN(  85)									if ((bx > dx)) {
HXDLIN(  85)										min2 = ::Math_obj::floor(dx);
            									}
            									else {
HXDLIN(  85)										min2 = ::Math_obj::floor(bx);
            									}
HXDLIN(  85)									int ii_min8 = min2;
HXDLIN(  85)									int ii_max8 = ::Math_obj::ceil(ax);
HXDLIN(  85)									xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            								}
            								else {
HXDLIN(  85)									int ii_min9 = ::Math_obj::floor(bx);
HXDLIN(  85)									int ii_max9 = ::Math_obj::ceil(dx);
HXDLIN(  85)									xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            								}
            							}
            							else {
HXDLIN(  85)								if ((bx > dx)) {
HXDLIN(  85)									int min3;
HXDLIN(  85)									if ((ax > dx)) {
HXDLIN(  85)										min3 = ::Math_obj::floor(dx);
            									}
            									else {
HXDLIN(  85)										min3 = ::Math_obj::ceil(ax);
            									}
HXDLIN(  85)									int ii_min10 = min3;
HXDLIN(  85)									int ii_max10 = ::Math_obj::ceil(bx);
HXDLIN(  85)									xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            								}
            								else {
HXDLIN(  85)									int ii_min11 = ::Math_obj::floor(ax);
HXDLIN(  85)									int ii_max11 = ::Math_obj::ceil(dx);
HXDLIN(  85)									xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            								}
            							}
HXDLIN(  85)							 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  85)							if ((ay > by)) {
HXDLIN(  85)								if ((ay > dy)) {
HXDLIN(  85)									int min4;
HXDLIN(  85)									if ((by > dy)) {
HXDLIN(  85)										min4 = ::Math_obj::floor(dy);
            									}
            									else {
HXDLIN(  85)										min4 = ::Math_obj::floor(by);
            									}
HXDLIN(  85)									int ii_min12 = min4;
HXDLIN(  85)									int ii_max12 = ::Math_obj::ceil(ay);
HXDLIN(  85)									yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            								}
            								else {
HXDLIN(  85)									int ii_min13 = ::Math_obj::floor(by);
HXDLIN(  85)									int ii_max13 = ::Math_obj::ceil(dy);
HXDLIN(  85)									yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            								}
            							}
            							else {
HXDLIN(  85)								if ((by > dy)) {
HXDLIN(  85)									int min5;
HXDLIN(  85)									if ((ay > dy)) {
HXDLIN(  85)										min5 = ::Math_obj::floor(dy);
            									}
            									else {
HXDLIN(  85)										min5 = ::Math_obj::ceil(ay);
            									}
HXDLIN(  85)									int ii_min14 = min5;
HXDLIN(  85)									int ii_max14 = ::Math_obj::ceil(by);
HXDLIN(  85)									yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            								}
            								else {
HXDLIN(  85)									int ii_min15 = ::Math_obj::floor(ay);
HXDLIN(  85)									int ii_max15 = ::Math_obj::ceil(dy);
HXDLIN(  85)									yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            								}
            							}
HXDLIN(  85)							 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  85)							if (hasUndo) {
HXDLIN(  85)								int width3 = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  85)								int height3 = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  85)								 ::Dynamic imageType4 = null();
HXDLIN(  85)								 ::pi_xy::ImageStruct this48 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  85)								if (::hx::IsNull( imageType4 )) {
HXLINE(  54)									imageType4 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE(  85)								::Dynamic undoImage1;
HXDLIN(  85)								switch((int)(( (int)(imageType4) ))){
            									case (int)0: {
HXDLIN(  85)										 ::iterMagic::BytesImg byt4 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  85)										 ::iterMagic::BytesImg b18 = byt4;
HXDLIN(  85)										{
HXDLIN(  85)											b18->width = width3;
HXDLIN(  85)											b18->height = height3;
HXDLIN(  85)											b18->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  85)											b18->data = ::haxe::io::Bytes_obj::alloc((b18->length * 4));
HXDLIN(  85)											{
HXDLIN(  85)												int len8 = b18->length;
HXDLIN(  85)												int w7 = 0;
HXDLIN(  85)												{
HXDLIN(  85)													int _g64 = 0;
HXDLIN(  85)													int _g65 = b18->height;
HXDLIN(  85)													while((_g64 < _g65)){
HXDLIN(  85)														_g64 = (_g64 + 1);
HXDLIN(  85)														int y10 = (_g64 - 1);
HXDLIN(  85)														{
HXDLIN(  85)															int _g66 = 0;
HXDLIN(  85)															int _g67 = b18->width;
HXDLIN(  85)															while((_g66 < _g67)){
HXDLIN(  85)																_g66 = (_g66 + 1);
HXDLIN(  85)																int x10 = (_g66 - 1);
HXDLIN(  85)																{
HXDLIN(  85)																	w7 = (w7 + 1);
HXDLIN(  85)																	b18->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  85)																{
HXDLIN(  85)																	w7 = (w7 + 1);
HXDLIN(  85)																	b18->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  85)																{
HXDLIN(  85)																	w7 = (w7 + 1);
HXDLIN(  85)																	b18->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  85)																{
HXDLIN(  85)																	w7 = (w7 + 1);
HXDLIN(  85)																	b18->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  85)										undoImage1 = b18;
            									}
            									break;
            									case (int)1: {
HXDLIN(  85)										 ::iterMagic::ArrIntImg arrI4 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  85)										 ::iterMagic::ArrIntImg a10 = arrI4;
HXDLIN(  85)										{
HXDLIN(  85)											a10->width = width3;
HXDLIN(  85)											a10->height = height3;
HXDLIN(  85)											a10->data = ::Array_obj< int >::__new(0);
HXDLIN(  85)											a10->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  85)											{
HXDLIN(  85)												int _g68 = 0;
HXDLIN(  85)												int _g69 = a10->length;
HXDLIN(  85)												while((_g68 < _g69)){
HXDLIN(  85)													_g68 = (_g68 + 1);
HXDLIN(  85)													int i30 = (_g68 - 1);
HXDLIN(  85)													a10->data[i30] = 0;
            												}
            											}
            										}
HXDLIN(  85)										undoImage1 = a10;
            									}
            									break;
            									case (int)2: {
HXDLIN(  85)										 ::iterMagic::U32ArrImg u32a4 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  85)										 ::iterMagic::U32ArrImg b19 = u32a4;
HXDLIN(  85)										{
HXDLIN(  85)											b19->width = width3;
HXDLIN(  85)											b19->height = height3;
HXDLIN(  85)											b19->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  85)											int size4 = (b19->length * 4);
HXDLIN(  85)											b19->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size4),0,size4);
HXDLIN(  85)											{
HXDLIN(  85)												int _g70 = 0;
HXDLIN(  85)												int _g71 = b19->length;
HXDLIN(  85)												while((_g70 < _g71)){
HXDLIN(  85)													_g70 = (_g70 + 1);
HXDLIN(  85)													int i31 = (_g70 - 1);
HXDLIN(  85)													{
HXDLIN(  85)														 ::haxe::io::ArrayBufferViewImpl this49 = b19->data;
HXDLIN(  85)														bool undoImage2;
HXDLIN(  85)														if ((i31 >= 0)) {
HXDLIN(  85)															undoImage2 = (i31 < (this49->byteLength >> 2));
            														}
            														else {
HXDLIN(  85)															undoImage2 = false;
            														}
HXDLIN(  85)														if (undoImage2) {
HXDLIN(  85)															 ::haxe::io::Bytes _this4 = this49->bytes;
HXDLIN(  85)															int pos4 = ((i31 << 2) + this49->byteOffset);
HXDLIN(  85)															_this4->b[pos4] = ( (unsigned char)(0) );
HXDLIN(  85)															_this4->b[(pos4 + 1)] = ( (unsigned char)(0) );
HXDLIN(  85)															_this4->b[(pos4 + 2)] = ( (unsigned char)(0) );
HXDLIN(  85)															_this4->b[(pos4 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN(  85)										undoImage1 = b19;
            									}
            									break;
            									case (int)3: {
HXDLIN(  85)										 ::iterMagic::VecIntImg vec4 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  85)										 ::iterMagic::VecIntImg v7 = vec4;
HXDLIN(  85)										{
HXDLIN(  85)											v7->width = width3;
HXDLIN(  85)											v7->height = height3;
HXDLIN(  85)											v7->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  85)											v7->data = ::Array_obj< int >::__new(v7->length);
HXDLIN(  85)											{
HXDLIN(  85)												int _g72 = 0;
HXDLIN(  85)												int _g73 = v7->length;
HXDLIN(  85)												while((_g72 < _g73)){
HXDLIN(  85)													_g72 = (_g72 + 1);
HXDLIN(  85)													int i32 = (_g72 - 1);
HXDLIN(  85)													v7->data->__unsafe_set(i32,0);
            												}
            											}
            										}
HXDLIN(  85)										undoImage1 = v7;
            									}
            									break;
            									case (int)4: {
HXDLIN(  85)										 ::iterMagic::StackIntImg sInt4 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  85)										 ::iterMagic::StackIntImg b20 = sInt4;
HXDLIN(  85)										{
HXDLIN(  85)											b20->width = width3;
HXDLIN(  85)											b20->height = height3;
HXDLIN(  85)											b20->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  85)											b20->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  85)											{
HXDLIN(  85)												int len9 = b20->length;
HXDLIN(  85)												 ::haxe::ds::GenericStack_Int d4 = b20->data;
HXDLIN(  85)												if (::hx::IsNull( d4->head )) {
HXDLIN(  85)													int _g74 = 0;
HXDLIN(  85)													int _g75 = len9;
HXDLIN(  85)													while((_g74 < _g75)){
HXDLIN(  85)														_g74 = (_g74 + 1);
HXDLIN(  85)														int i33 = (_g74 - 1);
HXDLIN(  85)														d4->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d4->head);
            													}
            												}
            												else {
HXDLIN(  85)													int _g76 = 0;
HXDLIN(  85)													int _g77 = len9;
HXDLIN(  85)													while((_g76 < _g77)){
HXDLIN(  85)														_g76 = (_g76 + 1);
HXDLIN(  85)														int i34 = (_g76 - 1);
HXDLIN(  85)														{
HXDLIN(  85)															 ::haxe::ds::GenericCell_Int l4 = b20->data->head;
HXDLIN(  85)															 ::haxe::ds::GenericCell_Int prev4 = null();
HXDLIN(  85)															{
HXDLIN(  85)																int _g78 = 0;
HXDLIN(  85)																int _g79 = i34;
HXDLIN(  85)																while((_g78 < _g79)){
HXDLIN(  85)																	_g78 = (_g78 + 1);
HXDLIN(  85)																	int i35 = (_g78 - 1);
HXLINE( 345)																	prev4 = l4;
HXLINE( 346)																	l4 = l4->next;
            																}
            															}
HXLINE(  85)															if (::hx::IsNull( prev4 )) {
HXDLIN(  85)																b20->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN(  85)																l4 = null();
            															}
            															else {
HXDLIN(  85)																prev4->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN(  85)																l4 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  85)										undoImage1 = b20;
            									}
            									break;
            								}
HXDLIN(  85)								this48->image = undoImage1;
HXDLIN(  85)								this48->width = width3;
HXDLIN(  85)								this48->height = height3;
HXDLIN(  85)								this48->imageType = ( (int)(imageType4) );
HXDLIN(  85)								undoImage = this48;
HXDLIN(  85)								{
HXDLIN(  85)									int rectLeft = xIter3->start;
HXDLIN(  85)									int rectTop = yIter3->start;
HXDLIN(  85)									int rectRight = xIter3->max;
HXDLIN(  85)									bool forceClear = false;
HXDLIN(  85)									{
HXDLIN(  85)										int _g80 = rectTop;
HXDLIN(  85)										int _g81 = yIter3->max;
HXDLIN(  85)										while((_g80 < _g81)){
HXDLIN(  85)											_g80 = (_g80 + 1);
HXDLIN(  85)											int dy1 = (_g80 - 1);
HXDLIN(  85)											{
HXDLIN(  85)												int _g82 = rectLeft;
HXDLIN(  85)												int _g83 = rectRight;
HXDLIN(  85)												while((_g82 < _g83)){
HXDLIN(  85)													_g82 = (_g82 + 1);
HXDLIN(  85)													int dx1 = (_g82 - 1);
HXDLIN(  85)													::Dynamic this50 = this47->image;
HXDLIN(  85)													int index6;
HXDLIN(  85)													if (this47->useVirtualPos) {
HXDLIN(  85)														index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this47->virtualY) * ( (Float)(this47->width) )) + dx1) - this47->virtualX));
            													}
            													else {
HXDLIN(  85)														index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this47->width) + dx1)) ));
            													}
HXDLIN(  85)													int c6 = ::iterMagic::Iimg_obj::get(this50,index6);
HXDLIN(  85)													int col;
HXDLIN(  85)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)														col = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            													}
            													else {
HXDLIN(  85)														col = c6;
            													}
HXDLIN(  85)													bool _hx_tmp23;
HXDLIN(  85)													if (this47->useMask) {
HXDLIN(  85)														_hx_tmp23 = ::hx::IsNotNull( this47->mask );
            													}
            													else {
HXDLIN(  85)														_hx_tmp23 = false;
            													}
HXDLIN(  85)													if (_hx_tmp23) {
HXDLIN(  85)														 ::pi_xy::ImageStruct this51 = this47->mask;
HXDLIN(  85)														::Dynamic this52 = this51->image;
HXDLIN(  85)														int index7;
HXDLIN(  85)														if (this51->useVirtualPos) {
HXDLIN(  85)															index7 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this51->virtualY) * ( (Float)(this51->width) )) + dx1) - this51->virtualX));
            														}
            														else {
HXDLIN(  85)															index7 = ::Std_obj::_hx_int(( (Float)(((dy1 * this51->width) + dx1)) ));
            														}
HXDLIN(  85)														int c7 = ::iterMagic::Iimg_obj::get(this52,index7);
HXDLIN(  85)														int v8;
HXDLIN(  85)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)															v8 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            														}
            														else {
HXDLIN(  85)															v8 = c7;
            														}
HXDLIN(  85)														int maskPixel = v8;
HXDLIN(  85)														int this53 = col;
HXDLIN(  85)														if ((maskPixel == 0)) {
HXDLIN(  85)															col = this53;
            														}
            														else {
HXDLIN(  85)															Float m0;
HXDLIN(  85)															int this54 = ((maskPixel >> 24) & 255);
HXDLIN(  85)															if ((this54 == 0)) {
HXDLIN(  85)																m0 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																m0 = (( (Float)(this54) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float m1;
HXDLIN(  85)															int this55 = ((maskPixel >> 16) & 255);
HXDLIN(  85)															if ((this55 == 0)) {
HXDLIN(  85)																m1 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																m1 = (( (Float)(this55) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float m2;
HXDLIN(  85)															int this56 = ((maskPixel >> 8) & 255);
HXDLIN(  85)															if ((this56 == 0)) {
HXDLIN(  85)																m2 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																m2 = (( (Float)(this56) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float m3;
HXDLIN(  85)															int this57 = (maskPixel & 255);
HXDLIN(  85)															if ((this57 == 0)) {
HXDLIN(  85)																m3 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																m3 = (( (Float)(this57) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this53 >> 24) & 255)) )));
HXDLIN(  85)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this53 >> 16) & 255)) )));
HXDLIN(  85)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this53 >> 8) & 255)) )));
HXDLIN(  85)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this53 & 255)) )));
HXDLIN(  85)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  85)													if ((col != 0)) {
HXDLIN(  85)														int x11 = (dx1 - rectLeft);
HXDLIN(  85)														int y11 = (dy1 - rectTop);
HXDLIN(  85)														int c8 = col;
HXDLIN(  85)														bool _hx_tmp24;
HXDLIN(  85)														if ((((c8 >> 24) & 255) < 254)) {
HXDLIN(  85)															_hx_tmp24 = undoImage->transparent;
            														}
            														else {
HXDLIN(  85)															_hx_tmp24 = false;
            														}
HXDLIN(  85)														if (_hx_tmp24) {
HXDLIN(  85)															int location3;
HXDLIN(  85)															if (undoImage->useVirtualPos) {
HXDLIN(  85)																location3 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x11) - undoImage->virtualX));
            															}
            															else {
HXDLIN(  85)																location3 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage->width) + x11)) ));
            															}
HXDLIN(  85)															int this58 = ::iterMagic::Iimg_obj::get(undoImage->image,location3);
HXDLIN(  85)															int this59;
HXDLIN(  85)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)																this59 = ((((((this58 >> 24) & 255) << 24) | ((this58 & 255) << 16)) | (((this58 >> 8) & 255) << 8)) | ((this58 >> 16) & 255));
            															}
            															else {
HXDLIN(  85)																this59 = this58;
            															}
HXDLIN(  85)															Float a13;
HXDLIN(  85)															int this60 = ((this59 >> 24) & 255);
HXDLIN(  85)															if ((this60 == 0)) {
HXDLIN(  85)																a13 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																a13 = (( (Float)(this60) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float r13;
HXDLIN(  85)															int this61 = ((this59 >> 16) & 255);
HXDLIN(  85)															if ((this61 == 0)) {
HXDLIN(  85)																r13 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																r13 = (( (Float)(this61) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float g13;
HXDLIN(  85)															int this62 = ((this59 >> 8) & 255);
HXDLIN(  85)															if ((this62 == 0)) {
HXDLIN(  85)																g13 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																g13 = (( (Float)(this62) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float b110;
HXDLIN(  85)															int this63 = (this59 & 255);
HXDLIN(  85)															if ((this63 == 0)) {
HXDLIN(  85)																b110 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																b110 = (( (Float)(this63) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float a23;
HXDLIN(  85)															int this64 = ((col >> 24) & 255);
HXDLIN(  85)															if ((this64 == 0)) {
HXDLIN(  85)																a23 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																a23 = (( (Float)(this64) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float r23;
HXDLIN(  85)															int this65 = ((col >> 16) & 255);
HXDLIN(  85)															if ((this65 == 0)) {
HXDLIN(  85)																r23 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																r23 = (( (Float)(this65) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float g23;
HXDLIN(  85)															int this66 = ((col >> 8) & 255);
HXDLIN(  85)															if ((this66 == 0)) {
HXDLIN(  85)																g23 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																g23 = (( (Float)(this66) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float b24;
HXDLIN(  85)															int this67 = (col & 255);
HXDLIN(  85)															if ((this67 == 0)) {
HXDLIN(  85)																b24 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																b24 = (( (Float)(this67) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  85)															int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  85)															int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  85)															int b25 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a33) + (b24 * a23))));
HXDLIN(  85)															int a14 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  85)															int blended3 = ((((a14 << 24) | (r8 << 16)) | (g5 << 8)) | b25);
HXDLIN(  85)															{
HXDLIN(  85)																int _hx_tmp25;
HXDLIN(  85)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)																	_hx_tmp25 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																}
            																else {
HXDLIN(  85)																	_hx_tmp25 = blended3;
            																}
HXDLIN(  85)																::iterMagic::Iimg_obj::set(undoImage->image,location3,_hx_tmp25);
            															}
            														}
            														else {
HXDLIN(  85)															::Dynamic this68 = undoImage->image;
HXDLIN(  85)															int index8;
HXDLIN(  85)															if (undoImage->useVirtualPos) {
HXDLIN(  85)																index8 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x11) - undoImage->virtualX));
            															}
            															else {
HXDLIN(  85)																index8 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage->width) + x11)) ));
            															}
HXDLIN(  85)															int _hx_tmp26;
HXDLIN(  85)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)																_hx_tmp26 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            															}
            															else {
HXDLIN(  85)																_hx_tmp26 = c8;
            															}
HXDLIN(  85)															::iterMagic::Iimg_obj::set(this68,index8,_hx_tmp26);
            														}
            													}
            													else {
HXDLIN(  85)														if (forceClear) {
HXDLIN(  85)															::Dynamic this69 = undoImage->image;
HXDLIN(  85)															int x12 = (dx1 - rectLeft);
HXDLIN(  85)															int y12 = (dy1 - rectTop);
HXDLIN(  85)															int index9;
HXDLIN(  85)															if (undoImage->useVirtualPos) {
HXDLIN(  85)																index9 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x12) - undoImage->virtualX));
            															}
            															else {
HXDLIN(  85)																index9 = ::Std_obj::_hx_int(( (Float)(((y12 * undoImage->width) + x12)) ));
            															}
HXDLIN(  85)															::iterMagic::Iimg_obj::set(this69,index9,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  85)							{
HXDLIN(  85)								int _g_min = xIter3->start;
HXDLIN(  85)								int _g_max = xIter3->max;
HXDLIN(  85)								while((_g_min < _g_max)){
HXDLIN(  85)									_g_min = (_g_min + 1);
HXDLIN(  85)									int px = (_g_min - 1);
HXDLIN(  85)									Float pcx = (( (Float)(px) ) - dx);
HXDLIN(  85)									{
HXDLIN(  85)										int _g_min1 = yIter3->start;
HXDLIN(  85)										int _g_max1 = yIter3->max;
HXDLIN(  85)										while((_g_min1 < _g_max1)){
HXDLIN(  85)											_g_min1 = (_g_min1 + 1);
HXDLIN(  85)											int py = (_g_min1 - 1);
HXDLIN(  85)											Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  85)											Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  85)											Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  85)											Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  85)											Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  85)											Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  85)											bool _hx_tmp27;
HXDLIN(  85)											bool _hx_tmp28;
HXDLIN(  85)											if ((ratioA >= 0)) {
HXDLIN(  85)												_hx_tmp28 = (ratioB >= 0);
            											}
            											else {
HXDLIN(  85)												_hx_tmp28 = false;
            											}
HXDLIN(  85)											if (_hx_tmp28) {
HXDLIN(  85)												_hx_tmp27 = (ratioC >= 0);
            											}
            											else {
HXDLIN(  85)												_hx_tmp27 = false;
            											}
HXDLIN(  85)											if (_hx_tmp27) {
HXDLIN(  85)												Float u = (((au * ratioA) + (bu1 * ratioB)) + (du * ratioC));
HXDLIN(  85)												Float v9 = (((av * ratioA) + (bv1 * ratioB)) + (dv * ratioC));
HXDLIN(  85)												int x13 = ::Std_obj::_hx_int(((u * win_width) + win_x));
HXDLIN(  85)												int y13 = ::Std_obj::_hx_int(((v9 * win_height) + win_y));
HXDLIN(  85)												::Dynamic this70 = this44->image;
HXDLIN(  85)												int index10;
HXDLIN(  85)												if (this44->useVirtualPos) {
HXDLIN(  85)													index10 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - this44->virtualY) * ( (Float)(this44->width) )) + x13) - this44->virtualX));
            												}
            												else {
HXDLIN(  85)													index10 = ::Std_obj::_hx_int(( (Float)(((y13 * this44->width) + x13)) ));
            												}
HXDLIN(  85)												int c9 = ::iterMagic::Iimg_obj::get(this70,index10);
HXDLIN(  85)												int col1;
HXDLIN(  85)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)													col1 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            												}
            												else {
HXDLIN(  85)													col1 = c9;
            												}
HXDLIN(  85)												{
HXDLIN(  85)													int c10 = col1;
HXDLIN(  85)													bool _hx_tmp29;
HXDLIN(  85)													if ((((c10 >> 24) & 255) < 254)) {
HXDLIN(  85)														_hx_tmp29 = this47->transparent;
            													}
            													else {
HXDLIN(  85)														_hx_tmp29 = false;
            													}
HXDLIN(  85)													if (_hx_tmp29) {
HXDLIN(  85)														int location4;
HXDLIN(  85)														if (this47->useVirtualPos) {
HXDLIN(  85)															location4 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this47->virtualY) * ( (Float)(this47->width) )) + px) - this47->virtualX));
            														}
            														else {
HXDLIN(  85)															location4 = ::Std_obj::_hx_int(( (Float)(((py * this47->width) + px)) ));
            														}
HXDLIN(  85)														int this71 = ::iterMagic::Iimg_obj::get(this47->image,location4);
HXDLIN(  85)														int this72;
HXDLIN(  85)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)															this72 = ((((((this71 >> 24) & 255) << 24) | ((this71 & 255) << 16)) | (((this71 >> 8) & 255) << 8)) | ((this71 >> 16) & 255));
            														}
            														else {
HXDLIN(  85)															this72 = this71;
            														}
HXDLIN(  85)														Float a15;
HXDLIN(  85)														int this73 = ((this72 >> 24) & 255);
HXDLIN(  85)														if ((this73 == 0)) {
HXDLIN(  85)															a15 = ((Float)0.);
            														}
            														else {
HXDLIN(  85)															a15 = (( (Float)(this73) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float r14;
HXDLIN(  85)														int this74 = ((this72 >> 16) & 255);
HXDLIN(  85)														if ((this74 == 0)) {
HXDLIN(  85)															r14 = ((Float)0.);
            														}
            														else {
HXDLIN(  85)															r14 = (( (Float)(this74) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float g14;
HXDLIN(  85)														int this75 = ((this72 >> 8) & 255);
HXDLIN(  85)														if ((this75 == 0)) {
HXDLIN(  85)															g14 = ((Float)0.);
            														}
            														else {
HXDLIN(  85)															g14 = (( (Float)(this75) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float b111;
HXDLIN(  85)														int this76 = (this72 & 255);
HXDLIN(  85)														if ((this76 == 0)) {
HXDLIN(  85)															b111 = ((Float)0.);
            														}
            														else {
HXDLIN(  85)															b111 = (( (Float)(this76) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float a24;
HXDLIN(  85)														int this77 = ((col1 >> 24) & 255);
HXDLIN(  85)														if ((this77 == 0)) {
HXDLIN(  85)															a24 = ((Float)0.);
            														}
            														else {
HXDLIN(  85)															a24 = (( (Float)(this77) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float r24;
HXDLIN(  85)														int this78 = ((col1 >> 16) & 255);
HXDLIN(  85)														if ((this78 == 0)) {
HXDLIN(  85)															r24 = ((Float)0.);
            														}
            														else {
HXDLIN(  85)															r24 = (( (Float)(this78) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float g24;
HXDLIN(  85)														int this79 = ((col1 >> 8) & 255);
HXDLIN(  85)														if ((this79 == 0)) {
HXDLIN(  85)															g24 = ((Float)0.);
            														}
            														else {
HXDLIN(  85)															g24 = (( (Float)(this79) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float b26;
HXDLIN(  85)														int this80 = (col1 & 255);
HXDLIN(  85)														if ((this80 == 0)) {
HXDLIN(  85)															b26 = ((Float)0.);
            														}
            														else {
HXDLIN(  85)															b26 = (( (Float)(this80) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float a34 = (a15 * (( (Float)(1) ) - a24));
HXDLIN(  85)														int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN(  85)														int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN(  85)														int b27 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a34) + (b26 * a24))));
HXDLIN(  85)														int a16 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN(  85)														int blended4 = ((((a16 << 24) | (r9 << 16)) | (g6 << 8)) | b27);
HXDLIN(  85)														{
HXDLIN(  85)															int _hx_tmp30;
HXDLIN(  85)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)																_hx_tmp30 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            															}
            															else {
HXDLIN(  85)																_hx_tmp30 = blended4;
            															}
HXDLIN(  85)															::iterMagic::Iimg_obj::set(this47->image,location4,_hx_tmp30);
            														}
            													}
            													else {
HXDLIN(  85)														::Dynamic this81 = this47->image;
HXDLIN(  85)														int index11;
HXDLIN(  85)														if (this47->useVirtualPos) {
HXDLIN(  85)															index11 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this47->virtualY) * ( (Float)(this47->width) )) + px) - this47->virtualX));
            														}
            														else {
HXDLIN(  85)															index11 = ::Std_obj::_hx_int(( (Float)(((py * this47->width) + px)) ));
            														}
HXDLIN(  85)														int _hx_tmp31;
HXDLIN(  85)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)															_hx_tmp31 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            														}
            														else {
HXDLIN(  85)															_hx_tmp31 = c10;
            														}
HXDLIN(  85)														::iterMagic::Iimg_obj::set(this81,index11,_hx_tmp31);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  85)							 ::pi_xy::iter::IntIterStart v_yIter3;
HXDLIN(  85)							 ::pi_xy::iter::IntIterStart v_xIter3;
HXDLIN(  85)							int v_undoY;
HXDLIN(  85)							int v_undoX;
HXDLIN(  85)							Float v_ty;
HXDLIN(  85)							Float v_tx;
HXDLIN(  85)							Float v_t0;
HXDLIN(  85)							Float v_sy;
HXDLIN(  85)							Float v_sx;
HXDLIN(  85)							Float v_s0;
HXDLIN(  85)							Float v_A;
HXDLIN(  85)							Float ax1 = ax;
HXDLIN(  85)							Float ay1 = ay;
HXDLIN(  85)							 ::pi_xy::ImageStruct v_undoImage = null();
HXDLIN(  85)							Float bx1 = bx;
HXDLIN(  85)							Float by1 = by;
HXDLIN(  85)							Float cx1 = dx;
HXDLIN(  85)							Float cy1 = dy;
HXDLIN(  85)							bool adjustWinding = (((((ax1 * by1) - (bx1 * ay1)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay1) - (ax1 * cy1))) > 0);
HXDLIN(  85)							if (!(adjustWinding)) {
HXDLIN(  85)								Float bx_ = bx1;
HXDLIN(  85)								Float by_ = by1;
HXLINE(  24)								bx1 = cx1;
HXLINE(  25)								by1 = cy1;
HXLINE(  26)								cx1 = bx_;
HXLINE(  27)								cy1 = by_;
            							}
HXLINE(  85)							Float v_ax = ax1;
HXDLIN(  85)							Float v_ay = ay1;
HXDLIN(  85)							Float v_bx = bx1;
HXDLIN(  85)							Float v_by = by1;
HXDLIN(  85)							Float v_cx = cx1;
HXDLIN(  85)							Float v_cy = cy1;
HXDLIN(  85)							bool v_preCalculated = true;
HXDLIN(  85)							{
HXDLIN(  85)								v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN(  85)								v_sx = (v_cy - v_ay);
HXDLIN(  85)								v_sy = (v_ax - v_cx);
HXDLIN(  85)								v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN(  85)								v_tx = (v_ay - v_by);
HXDLIN(  85)								v_ty = (v_bx - v_ax);
HXDLIN(  85)								v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN(  85)								Float a17 = v_ax;
HXDLIN(  85)								Float b28 = v_bx;
HXDLIN(  85)								Float c11 = v_cx;
HXDLIN(  85)								if ((a17 > b28)) {
HXDLIN(  85)									if ((a17 > c11)) {
HXDLIN(  85)										int min6;
HXDLIN(  85)										if ((b28 > c11)) {
HXDLIN(  85)											min6 = ::Math_obj::floor(c11);
            										}
            										else {
HXDLIN(  85)											min6 = ::Math_obj::floor(b28);
            										}
HXDLIN(  85)										int ii_min16 = min6;
HXDLIN(  85)										int ii_max16 = ::Math_obj::ceil(a17);
HXDLIN(  85)										v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            									}
            									else {
HXDLIN(  85)										int ii_min17 = ::Math_obj::floor(b28);
HXDLIN(  85)										int ii_max17 = ::Math_obj::ceil(c11);
HXDLIN(  85)										v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            									}
            								}
            								else {
HXDLIN(  85)									if ((b28 > c11)) {
HXDLIN(  85)										int min7;
HXDLIN(  85)										if ((a17 > c11)) {
HXDLIN(  85)											min7 = ::Math_obj::floor(c11);
            										}
            										else {
HXDLIN(  85)											min7 = ::Math_obj::ceil(a17);
            										}
HXDLIN(  85)										int ii_min18 = min7;
HXDLIN(  85)										int ii_max18 = ::Math_obj::ceil(b28);
HXDLIN(  85)										v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            									}
            									else {
HXDLIN(  85)										int ii_min19 = ::Math_obj::floor(a17);
HXDLIN(  85)										int ii_max19 = ::Math_obj::ceil(c11);
HXDLIN(  85)										v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            									}
            								}
HXDLIN(  85)								Float a18 = v_ay;
HXDLIN(  85)								Float b29 = v_by;
HXDLIN(  85)								Float c12 = v_cy;
HXDLIN(  85)								if ((a18 > b29)) {
HXDLIN(  85)									if ((a18 > c12)) {
HXDLIN(  85)										int min8;
HXDLIN(  85)										if ((b29 > c12)) {
HXDLIN(  85)											min8 = ::Math_obj::floor(c12);
            										}
            										else {
HXDLIN(  85)											min8 = ::Math_obj::floor(b29);
            										}
HXDLIN(  85)										int ii_min20 = min8;
HXDLIN(  85)										int ii_max20 = ::Math_obj::ceil(a18);
HXDLIN(  85)										v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            									}
            									else {
HXDLIN(  85)										int ii_min21 = ::Math_obj::floor(b29);
HXDLIN(  85)										int ii_max21 = ::Math_obj::ceil(c12);
HXDLIN(  85)										v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            									}
            								}
            								else {
HXDLIN(  85)									if ((b29 > c12)) {
HXDLIN(  85)										int min9;
HXDLIN(  85)										if ((a18 > c12)) {
HXDLIN(  85)											min9 = ::Math_obj::floor(c12);
            										}
            										else {
HXDLIN(  85)											min9 = ::Math_obj::ceil(a18);
            										}
HXDLIN(  85)										int ii_min22 = min9;
HXDLIN(  85)										int ii_max22 = ::Math_obj::ceil(b29);
HXDLIN(  85)										v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            									}
            									else {
HXDLIN(  85)										int ii_min23 = ::Math_obj::floor(a18);
HXDLIN(  85)										int ii_max23 = ::Math_obj::ceil(c12);
HXDLIN(  85)										v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            									}
            								}
            							}
HXDLIN(  85)							if (hasUndo) {
HXDLIN(  85)								v_undoImage = undoImage;
HXDLIN(  85)								v_undoX = xIter3->start;
HXDLIN(  85)								v_undoY = yIter3->start;
            							}
HXDLIN(  85)							Float au1 = bu;
HXDLIN(  85)							Float av1 = bv;
HXDLIN(  85)							Float bu2 = cu;
HXDLIN(  85)							Float bv2 = cv;
HXDLIN(  85)							bool hasUndo1 = false;
HXDLIN(  85)							Float temp5 = au1;
HXLINE( 422)							au1 = bu2;
HXLINE( 423)							bu2 = temp5;
HXLINE( 424)							temp5 = av1;
HXLINE( 425)							av1 = bv2;
HXLINE( 426)							bv2 = temp5;
HXLINE(  85)							Float bcx1 = (cx - dx);
HXDLIN(  85)							Float bcy1 = (cy - dy);
HXDLIN(  85)							Float acx1 = (bx - dx);
HXDLIN(  85)							Float acy1 = (by - dy);
HXDLIN(  85)							Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  85)							Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  85)							Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  85)							Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  85)							 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  85)							if ((bx > cx)) {
HXDLIN(  85)								if ((bx > dx)) {
HXDLIN(  85)									int min10;
HXDLIN(  85)									if ((cx > dx)) {
HXDLIN(  85)										min10 = ::Math_obj::floor(dx);
            									}
            									else {
HXDLIN(  85)										min10 = ::Math_obj::floor(cx);
            									}
HXDLIN(  85)									int ii_min24 = min10;
HXDLIN(  85)									int ii_max24 = ::Math_obj::ceil(bx);
HXDLIN(  85)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            								}
            								else {
HXDLIN(  85)									int ii_min25 = ::Math_obj::floor(cx);
HXDLIN(  85)									int ii_max25 = ::Math_obj::ceil(dx);
HXDLIN(  85)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            								}
            							}
            							else {
HXDLIN(  85)								if ((cx > dx)) {
HXDLIN(  85)									int min11;
HXDLIN(  85)									if ((bx > dx)) {
HXDLIN(  85)										min11 = ::Math_obj::floor(dx);
            									}
            									else {
HXDLIN(  85)										min11 = ::Math_obj::ceil(bx);
            									}
HXDLIN(  85)									int ii_min26 = min11;
HXDLIN(  85)									int ii_max26 = ::Math_obj::ceil(cx);
HXDLIN(  85)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            								}
            								else {
HXDLIN(  85)									int ii_min27 = ::Math_obj::floor(bx);
HXDLIN(  85)									int ii_max27 = ::Math_obj::ceil(dx);
HXDLIN(  85)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            								}
            							}
HXDLIN(  85)							 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  85)							if ((by > cy)) {
HXDLIN(  85)								if ((by > dy)) {
HXDLIN(  85)									int min12;
HXDLIN(  85)									if ((cy > dy)) {
HXDLIN(  85)										min12 = ::Math_obj::floor(dy);
            									}
            									else {
HXDLIN(  85)										min12 = ::Math_obj::floor(cy);
            									}
HXDLIN(  85)									int ii_min28 = min12;
HXDLIN(  85)									int ii_max28 = ::Math_obj::ceil(by);
HXDLIN(  85)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            								}
            								else {
HXDLIN(  85)									int ii_min29 = ::Math_obj::floor(cy);
HXDLIN(  85)									int ii_max29 = ::Math_obj::ceil(dy);
HXDLIN(  85)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            								}
            							}
            							else {
HXDLIN(  85)								if ((cy > dy)) {
HXDLIN(  85)									int min13;
HXDLIN(  85)									if ((by > dy)) {
HXDLIN(  85)										min13 = ::Math_obj::floor(dy);
            									}
            									else {
HXDLIN(  85)										min13 = ::Math_obj::ceil(by);
            									}
HXDLIN(  85)									int ii_min30 = min13;
HXDLIN(  85)									int ii_max30 = ::Math_obj::ceil(cy);
HXDLIN(  85)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            								}
            								else {
HXDLIN(  85)									int ii_min31 = ::Math_obj::floor(by);
HXDLIN(  85)									int ii_max31 = ::Math_obj::ceil(dy);
HXDLIN(  85)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            								}
            							}
HXDLIN(  85)							 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  85)							if (hasUndo1) {
HXDLIN(  85)								int width4 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  85)								int height4 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  85)								 ::Dynamic imageType5 = null();
HXDLIN(  85)								 ::pi_xy::ImageStruct this82 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  85)								if (::hx::IsNull( imageType5 )) {
HXLINE(  54)									imageType5 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE(  85)								::Dynamic undoImage4;
HXDLIN(  85)								switch((int)(( (int)(imageType5) ))){
            									case (int)0: {
HXDLIN(  85)										 ::iterMagic::BytesImg byt5 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  85)										 ::iterMagic::BytesImg b30 = byt5;
HXDLIN(  85)										{
HXDLIN(  85)											b30->width = width4;
HXDLIN(  85)											b30->height = height4;
HXDLIN(  85)											b30->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN(  85)											b30->data = ::haxe::io::Bytes_obj::alloc((b30->length * 4));
HXDLIN(  85)											{
HXDLIN(  85)												int len10 = b30->length;
HXDLIN(  85)												int w8 = 0;
HXDLIN(  85)												{
HXDLIN(  85)													int _g84 = 0;
HXDLIN(  85)													int _g85 = b30->height;
HXDLIN(  85)													while((_g84 < _g85)){
HXDLIN(  85)														_g84 = (_g84 + 1);
HXDLIN(  85)														int y14 = (_g84 - 1);
HXDLIN(  85)														{
HXDLIN(  85)															int _g86 = 0;
HXDLIN(  85)															int _g87 = b30->width;
HXDLIN(  85)															while((_g86 < _g87)){
HXDLIN(  85)																_g86 = (_g86 + 1);
HXDLIN(  85)																int x14 = (_g86 - 1);
HXDLIN(  85)																{
HXDLIN(  85)																	w8 = (w8 + 1);
HXDLIN(  85)																	b30->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  85)																{
HXDLIN(  85)																	w8 = (w8 + 1);
HXDLIN(  85)																	b30->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  85)																{
HXDLIN(  85)																	w8 = (w8 + 1);
HXDLIN(  85)																	b30->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  85)																{
HXDLIN(  85)																	w8 = (w8 + 1);
HXDLIN(  85)																	b30->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  85)										undoImage4 = b30;
            									}
            									break;
            									case (int)1: {
HXDLIN(  85)										 ::iterMagic::ArrIntImg arrI5 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  85)										 ::iterMagic::ArrIntImg a19 = arrI5;
HXDLIN(  85)										{
HXDLIN(  85)											a19->width = width4;
HXDLIN(  85)											a19->height = height4;
HXDLIN(  85)											a19->data = ::Array_obj< int >::__new(0);
HXDLIN(  85)											a19->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN(  85)											{
HXDLIN(  85)												int _g88 = 0;
HXDLIN(  85)												int _g89 = a19->length;
HXDLIN(  85)												while((_g88 < _g89)){
HXDLIN(  85)													_g88 = (_g88 + 1);
HXDLIN(  85)													int i36 = (_g88 - 1);
HXDLIN(  85)													a19->data[i36] = 0;
            												}
            											}
            										}
HXDLIN(  85)										undoImage4 = a19;
            									}
            									break;
            									case (int)2: {
HXDLIN(  85)										 ::iterMagic::U32ArrImg u32a5 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  85)										 ::iterMagic::U32ArrImg b31 = u32a5;
HXDLIN(  85)										{
HXDLIN(  85)											b31->width = width4;
HXDLIN(  85)											b31->height = height4;
HXDLIN(  85)											b31->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN(  85)											int size5 = (b31->length * 4);
HXDLIN(  85)											b31->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size5),0,size5);
HXDLIN(  85)											{
HXDLIN(  85)												int _g90 = 0;
HXDLIN(  85)												int _g91 = b31->length;
HXDLIN(  85)												while((_g90 < _g91)){
HXDLIN(  85)													_g90 = (_g90 + 1);
HXDLIN(  85)													int i37 = (_g90 - 1);
HXDLIN(  85)													{
HXDLIN(  85)														 ::haxe::io::ArrayBufferViewImpl this83 = b31->data;
HXDLIN(  85)														bool undoImage5;
HXDLIN(  85)														if ((i37 >= 0)) {
HXDLIN(  85)															undoImage5 = (i37 < (this83->byteLength >> 2));
            														}
            														else {
HXDLIN(  85)															undoImage5 = false;
            														}
HXDLIN(  85)														if (undoImage5) {
HXDLIN(  85)															 ::haxe::io::Bytes _this5 = this83->bytes;
HXDLIN(  85)															int pos5 = ((i37 << 2) + this83->byteOffset);
HXDLIN(  85)															_this5->b[pos5] = ( (unsigned char)(0) );
HXDLIN(  85)															_this5->b[(pos5 + 1)] = ( (unsigned char)(0) );
HXDLIN(  85)															_this5->b[(pos5 + 2)] = ( (unsigned char)(0) );
HXDLIN(  85)															_this5->b[(pos5 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN(  85)										undoImage4 = b31;
            									}
            									break;
            									case (int)3: {
HXDLIN(  85)										 ::iterMagic::VecIntImg vec5 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  85)										 ::iterMagic::VecIntImg v10 = vec5;
HXDLIN(  85)										{
HXDLIN(  85)											v10->width = width4;
HXDLIN(  85)											v10->height = height4;
HXDLIN(  85)											v10->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN(  85)											v10->data = ::Array_obj< int >::__new(v10->length);
HXDLIN(  85)											{
HXDLIN(  85)												int _g92 = 0;
HXDLIN(  85)												int _g93 = v10->length;
HXDLIN(  85)												while((_g92 < _g93)){
HXDLIN(  85)													_g92 = (_g92 + 1);
HXDLIN(  85)													int i38 = (_g92 - 1);
HXDLIN(  85)													v10->data->__unsafe_set(i38,0);
            												}
            											}
            										}
HXDLIN(  85)										undoImage4 = v10;
            									}
            									break;
            									case (int)4: {
HXDLIN(  85)										 ::iterMagic::StackIntImg sInt5 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  85)										 ::iterMagic::StackIntImg b32 = sInt5;
HXDLIN(  85)										{
HXDLIN(  85)											b32->width = width4;
HXDLIN(  85)											b32->height = height4;
HXDLIN(  85)											b32->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN(  85)											b32->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  85)											{
HXDLIN(  85)												int len11 = b32->length;
HXDLIN(  85)												 ::haxe::ds::GenericStack_Int d5 = b32->data;
HXDLIN(  85)												if (::hx::IsNull( d5->head )) {
HXDLIN(  85)													int _g94 = 0;
HXDLIN(  85)													int _g95 = len11;
HXDLIN(  85)													while((_g94 < _g95)){
HXDLIN(  85)														_g94 = (_g94 + 1);
HXDLIN(  85)														int i39 = (_g94 - 1);
HXDLIN(  85)														d5->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d5->head);
            													}
            												}
            												else {
HXDLIN(  85)													int _g96 = 0;
HXDLIN(  85)													int _g97 = len11;
HXDLIN(  85)													while((_g96 < _g97)){
HXDLIN(  85)														_g96 = (_g96 + 1);
HXDLIN(  85)														int i40 = (_g96 - 1);
HXDLIN(  85)														{
HXDLIN(  85)															 ::haxe::ds::GenericCell_Int l5 = b32->data->head;
HXDLIN(  85)															 ::haxe::ds::GenericCell_Int prev5 = null();
HXDLIN(  85)															{
HXDLIN(  85)																int _g98 = 0;
HXDLIN(  85)																int _g99 = i40;
HXDLIN(  85)																while((_g98 < _g99)){
HXDLIN(  85)																	_g98 = (_g98 + 1);
HXDLIN(  85)																	int i41 = (_g98 - 1);
HXLINE( 345)																	prev5 = l5;
HXLINE( 346)																	l5 = l5->next;
            																}
            															}
HXLINE(  85)															if (::hx::IsNull( prev5 )) {
HXDLIN(  85)																b32->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN(  85)																l5 = null();
            															}
            															else {
HXDLIN(  85)																prev5->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN(  85)																l5 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  85)										undoImage4 = b32;
            									}
            									break;
            								}
HXDLIN(  85)								this82->image = undoImage4;
HXDLIN(  85)								this82->width = width4;
HXDLIN(  85)								this82->height = height4;
HXDLIN(  85)								this82->imageType = ( (int)(imageType5) );
HXDLIN(  85)								undoImage3 = this82;
HXDLIN(  85)								{
HXDLIN(  85)									int rectLeft1 = xIter31->start;
HXDLIN(  85)									int rectTop1 = yIter31->start;
HXDLIN(  85)									int rectRight1 = xIter31->max;
HXDLIN(  85)									bool forceClear1 = false;
HXDLIN(  85)									{
HXDLIN(  85)										int _g100 = rectTop1;
HXDLIN(  85)										int _g101 = yIter31->max;
HXDLIN(  85)										while((_g100 < _g101)){
HXDLIN(  85)											_g100 = (_g100 + 1);
HXDLIN(  85)											int dy2 = (_g100 - 1);
HXDLIN(  85)											{
HXDLIN(  85)												int _g102 = rectLeft1;
HXDLIN(  85)												int _g103 = rectRight1;
HXDLIN(  85)												while((_g102 < _g103)){
HXDLIN(  85)													_g102 = (_g102 + 1);
HXDLIN(  85)													int dx2 = (_g102 - 1);
HXDLIN(  85)													::Dynamic this84 = this47->image;
HXDLIN(  85)													int index12;
HXDLIN(  85)													if (this47->useVirtualPos) {
HXDLIN(  85)														index12 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this47->virtualY) * ( (Float)(this47->width) )) + dx2) - this47->virtualX));
            													}
            													else {
HXDLIN(  85)														index12 = ::Std_obj::_hx_int(( (Float)(((dy2 * this47->width) + dx2)) ));
            													}
HXDLIN(  85)													int c13 = ::iterMagic::Iimg_obj::get(this84,index12);
HXDLIN(  85)													int col2;
HXDLIN(  85)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)														col2 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            													}
            													else {
HXDLIN(  85)														col2 = c13;
            													}
HXDLIN(  85)													bool _hx_tmp32;
HXDLIN(  85)													if (this47->useMask) {
HXDLIN(  85)														_hx_tmp32 = ::hx::IsNotNull( this47->mask );
            													}
            													else {
HXDLIN(  85)														_hx_tmp32 = false;
            													}
HXDLIN(  85)													if (_hx_tmp32) {
HXDLIN(  85)														 ::pi_xy::ImageStruct this85 = this47->mask;
HXDLIN(  85)														::Dynamic this86 = this85->image;
HXDLIN(  85)														int index13;
HXDLIN(  85)														if (this85->useVirtualPos) {
HXDLIN(  85)															index13 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this85->virtualY) * ( (Float)(this85->width) )) + dx2) - this85->virtualX));
            														}
            														else {
HXDLIN(  85)															index13 = ::Std_obj::_hx_int(( (Float)(((dy2 * this85->width) + dx2)) ));
            														}
HXDLIN(  85)														int c14 = ::iterMagic::Iimg_obj::get(this86,index13);
HXDLIN(  85)														int v11;
HXDLIN(  85)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)															v11 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            														}
            														else {
HXDLIN(  85)															v11 = c14;
            														}
HXDLIN(  85)														int maskPixel1 = v11;
HXDLIN(  85)														int this87 = col2;
HXDLIN(  85)														if ((maskPixel1 == 0)) {
HXDLIN(  85)															col2 = this87;
            														}
            														else {
HXDLIN(  85)															Float m01;
HXDLIN(  85)															int this88 = ((maskPixel1 >> 24) & 255);
HXDLIN(  85)															if ((this88 == 0)) {
HXDLIN(  85)																m01 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																m01 = (( (Float)(this88) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float m11;
HXDLIN(  85)															int this89 = ((maskPixel1 >> 16) & 255);
HXDLIN(  85)															if ((this89 == 0)) {
HXDLIN(  85)																m11 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																m11 = (( (Float)(this89) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float m21;
HXDLIN(  85)															int this90 = ((maskPixel1 >> 8) & 255);
HXDLIN(  85)															if ((this90 == 0)) {
HXDLIN(  85)																m21 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																m21 = (( (Float)(this90) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float m31;
HXDLIN(  85)															int this91 = (maskPixel1 & 255);
HXDLIN(  85)															if ((this91 == 0)) {
HXDLIN(  85)																m31 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																m31 = (( (Float)(this91) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this87 >> 24) & 255)) )));
HXDLIN(  85)															int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this87 >> 16) & 255)) )));
HXDLIN(  85)															int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this87 >> 8) & 255)) )));
HXDLIN(  85)															int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this87 & 255)) )));
HXDLIN(  85)															col2 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  85)													if ((col2 != 0)) {
HXDLIN(  85)														int x15 = (dx2 - rectLeft1);
HXDLIN(  85)														int y15 = (dy2 - rectTop1);
HXDLIN(  85)														int c15 = col2;
HXDLIN(  85)														bool _hx_tmp33;
HXDLIN(  85)														if ((((c15 >> 24) & 255) < 254)) {
HXDLIN(  85)															_hx_tmp33 = undoImage3->transparent;
            														}
            														else {
HXDLIN(  85)															_hx_tmp33 = false;
            														}
HXDLIN(  85)														if (_hx_tmp33) {
HXDLIN(  85)															int location5;
HXDLIN(  85)															if (undoImage3->useVirtualPos) {
HXDLIN(  85)																location5 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x15) - undoImage3->virtualX));
            															}
            															else {
HXDLIN(  85)																location5 = ::Std_obj::_hx_int(( (Float)(((y15 * undoImage3->width) + x15)) ));
            															}
HXDLIN(  85)															int this92 = ::iterMagic::Iimg_obj::get(undoImage3->image,location5);
HXDLIN(  85)															int this93;
HXDLIN(  85)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)																this93 = ((((((this92 >> 24) & 255) << 24) | ((this92 & 255) << 16)) | (((this92 >> 8) & 255) << 8)) | ((this92 >> 16) & 255));
            															}
            															else {
HXDLIN(  85)																this93 = this92;
            															}
HXDLIN(  85)															Float a110;
HXDLIN(  85)															int this94 = ((this93 >> 24) & 255);
HXDLIN(  85)															if ((this94 == 0)) {
HXDLIN(  85)																a110 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																a110 = (( (Float)(this94) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float r15;
HXDLIN(  85)															int this95 = ((this93 >> 16) & 255);
HXDLIN(  85)															if ((this95 == 0)) {
HXDLIN(  85)																r15 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																r15 = (( (Float)(this95) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float g15;
HXDLIN(  85)															int this96 = ((this93 >> 8) & 255);
HXDLIN(  85)															if ((this96 == 0)) {
HXDLIN(  85)																g15 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																g15 = (( (Float)(this96) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float b112;
HXDLIN(  85)															int this97 = (this93 & 255);
HXDLIN(  85)															if ((this97 == 0)) {
HXDLIN(  85)																b112 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																b112 = (( (Float)(this97) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float a25;
HXDLIN(  85)															int this98 = ((col2 >> 24) & 255);
HXDLIN(  85)															if ((this98 == 0)) {
HXDLIN(  85)																a25 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																a25 = (( (Float)(this98) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float r25;
HXDLIN(  85)															int this99 = ((col2 >> 16) & 255);
HXDLIN(  85)															if ((this99 == 0)) {
HXDLIN(  85)																r25 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																r25 = (( (Float)(this99) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float g25;
HXDLIN(  85)															int this100 = ((col2 >> 8) & 255);
HXDLIN(  85)															if ((this100 == 0)) {
HXDLIN(  85)																g25 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																g25 = (( (Float)(this100) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float b210;
HXDLIN(  85)															int this101 = (col2 & 255);
HXDLIN(  85)															if ((this101 == 0)) {
HXDLIN(  85)																b210 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																b210 = (( (Float)(this101) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float a35 = (a110 * (( (Float)(1) ) - a25));
HXDLIN(  85)															int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN(  85)															int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN(  85)															int b33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a35) + (b210 * a25))));
HXDLIN(  85)															int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN(  85)															int blended5 = ((((a20 << 24) | (r10 << 16)) | (g7 << 8)) | b33);
HXDLIN(  85)															{
HXDLIN(  85)																int _hx_tmp34;
HXDLIN(  85)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)																	_hx_tmp34 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            																}
            																else {
HXDLIN(  85)																	_hx_tmp34 = blended5;
            																}
HXDLIN(  85)																::iterMagic::Iimg_obj::set(undoImage3->image,location5,_hx_tmp34);
            															}
            														}
            														else {
HXDLIN(  85)															::Dynamic this102 = undoImage3->image;
HXDLIN(  85)															int index14;
HXDLIN(  85)															if (undoImage3->useVirtualPos) {
HXDLIN(  85)																index14 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x15) - undoImage3->virtualX));
            															}
            															else {
HXDLIN(  85)																index14 = ::Std_obj::_hx_int(( (Float)(((y15 * undoImage3->width) + x15)) ));
            															}
HXDLIN(  85)															int _hx_tmp35;
HXDLIN(  85)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)																_hx_tmp35 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            															}
            															else {
HXDLIN(  85)																_hx_tmp35 = c15;
            															}
HXDLIN(  85)															::iterMagic::Iimg_obj::set(this102,index14,_hx_tmp35);
            														}
            													}
            													else {
HXDLIN(  85)														if (forceClear1) {
HXDLIN(  85)															::Dynamic this103 = undoImage3->image;
HXDLIN(  85)															int x16 = (dx2 - rectLeft1);
HXDLIN(  85)															int y16 = (dy2 - rectTop1);
HXDLIN(  85)															int index15;
HXDLIN(  85)															if (undoImage3->useVirtualPos) {
HXDLIN(  85)																index15 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x16) - undoImage3->virtualX));
            															}
            															else {
HXDLIN(  85)																index15 = ::Std_obj::_hx_int(( (Float)(((y16 * undoImage3->width) + x16)) ));
            															}
HXDLIN(  85)															::iterMagic::Iimg_obj::set(this103,index15,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  85)							{
HXDLIN(  85)								int _g_min2 = xIter31->start;
HXDLIN(  85)								int _g_max2 = xIter31->max;
HXDLIN(  85)								while((_g_min2 < _g_max2)){
HXDLIN(  85)									_g_min2 = (_g_min2 + 1);
HXDLIN(  85)									int px1 = (_g_min2 - 1);
HXDLIN(  85)									Float pcx1 = (( (Float)(px1) ) - dx);
HXDLIN(  85)									{
HXDLIN(  85)										int _g_min3 = yIter31->start;
HXDLIN(  85)										int _g_max3 = yIter31->max;
HXDLIN(  85)										while((_g_min3 < _g_max3)){
HXDLIN(  85)											_g_min3 = (_g_min3 + 1);
HXDLIN(  85)											int py1 = (_g_min3 - 1);
HXDLIN(  85)											Float pcy1 = (( (Float)(py1) ) - dy);
HXDLIN(  85)											Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN(  85)											Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN(  85)											Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN(  85)											Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN(  85)											Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN(  85)											bool _hx_tmp36;
HXDLIN(  85)											bool _hx_tmp37;
HXDLIN(  85)											if ((ratioA1 >= 0)) {
HXDLIN(  85)												_hx_tmp37 = (ratioB1 >= 0);
            											}
            											else {
HXDLIN(  85)												_hx_tmp37 = false;
            											}
HXDLIN(  85)											if (_hx_tmp37) {
HXDLIN(  85)												_hx_tmp36 = (ratioC1 >= 0);
            											}
            											else {
HXDLIN(  85)												_hx_tmp36 = false;
            											}
HXDLIN(  85)											if (_hx_tmp36) {
HXDLIN(  85)												Float u1 = (((au1 * ratioA1) + (bu2 * ratioB1)) + (du * ratioC1));
HXDLIN(  85)												Float v12 = (((av1 * ratioA1) + (bv2 * ratioB1)) + (dv * ratioC1));
HXDLIN(  85)												int x17 = ::Std_obj::_hx_int(((u1 * win_width) + win_x));
HXDLIN(  85)												int y17 = ::Std_obj::_hx_int(((v12 * win_height) + win_y));
HXDLIN(  85)												::Dynamic this104 = this44->image;
HXDLIN(  85)												int index16;
HXDLIN(  85)												if (this44->useVirtualPos) {
HXDLIN(  85)													index16 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - this44->virtualY) * ( (Float)(this44->width) )) + x17) - this44->virtualX));
            												}
            												else {
HXDLIN(  85)													index16 = ::Std_obj::_hx_int(( (Float)(((y17 * this44->width) + x17)) ));
            												}
HXDLIN(  85)												int c16 = ::iterMagic::Iimg_obj::get(this104,index16);
HXDLIN(  85)												int col3;
HXDLIN(  85)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)													col3 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            												}
            												else {
HXDLIN(  85)													col3 = c16;
            												}
HXDLIN(  85)												{
HXDLIN(  85)													int c17 = col3;
HXDLIN(  85)													bool _hx_tmp38;
HXDLIN(  85)													if ((((c17 >> 24) & 255) < 254)) {
HXDLIN(  85)														_hx_tmp38 = this47->transparent;
            													}
            													else {
HXDLIN(  85)														_hx_tmp38 = false;
            													}
HXDLIN(  85)													if (_hx_tmp38) {
HXDLIN(  85)														int location6;
HXDLIN(  85)														if (this47->useVirtualPos) {
HXDLIN(  85)															location6 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this47->virtualY) * ( (Float)(this47->width) )) + px1) - this47->virtualX));
            														}
            														else {
HXDLIN(  85)															location6 = ::Std_obj::_hx_int(( (Float)(((py1 * this47->width) + px1)) ));
            														}
HXDLIN(  85)														int this105 = ::iterMagic::Iimg_obj::get(this47->image,location6);
HXDLIN(  85)														int this106;
HXDLIN(  85)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)															this106 = ((((((this105 >> 24) & 255) << 24) | ((this105 & 255) << 16)) | (((this105 >> 8) & 255) << 8)) | ((this105 >> 16) & 255));
            														}
            														else {
HXDLIN(  85)															this106 = this105;
            														}
HXDLIN(  85)														Float a111;
HXDLIN(  85)														int this107 = ((this106 >> 24) & 255);
HXDLIN(  85)														if ((this107 == 0)) {
HXDLIN(  85)															a111 = ((Float)0.);
            														}
            														else {
HXDLIN(  85)															a111 = (( (Float)(this107) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float r16;
HXDLIN(  85)														int this108 = ((this106 >> 16) & 255);
HXDLIN(  85)														if ((this108 == 0)) {
HXDLIN(  85)															r16 = ((Float)0.);
            														}
            														else {
HXDLIN(  85)															r16 = (( (Float)(this108) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float g16;
HXDLIN(  85)														int this109 = ((this106 >> 8) & 255);
HXDLIN(  85)														if ((this109 == 0)) {
HXDLIN(  85)															g16 = ((Float)0.);
            														}
            														else {
HXDLIN(  85)															g16 = (( (Float)(this109) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float b113;
HXDLIN(  85)														int this110 = (this106 & 255);
HXDLIN(  85)														if ((this110 == 0)) {
HXDLIN(  85)															b113 = ((Float)0.);
            														}
            														else {
HXDLIN(  85)															b113 = (( (Float)(this110) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float a26;
HXDLIN(  85)														int this111 = ((col3 >> 24) & 255);
HXDLIN(  85)														if ((this111 == 0)) {
HXDLIN(  85)															a26 = ((Float)0.);
            														}
            														else {
HXDLIN(  85)															a26 = (( (Float)(this111) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float r26;
HXDLIN(  85)														int this112 = ((col3 >> 16) & 255);
HXDLIN(  85)														if ((this112 == 0)) {
HXDLIN(  85)															r26 = ((Float)0.);
            														}
            														else {
HXDLIN(  85)															r26 = (( (Float)(this112) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float g26;
HXDLIN(  85)														int this113 = ((col3 >> 8) & 255);
HXDLIN(  85)														if ((this113 == 0)) {
HXDLIN(  85)															g26 = ((Float)0.);
            														}
            														else {
HXDLIN(  85)															g26 = (( (Float)(this113) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float b211;
HXDLIN(  85)														int this114 = (col3 & 255);
HXDLIN(  85)														if ((this114 == 0)) {
HXDLIN(  85)															b211 = ((Float)0.);
            														}
            														else {
HXDLIN(  85)															b211 = (( (Float)(this114) ) / ( (Float)(255) ));
            														}
HXDLIN(  85)														Float a36 = (a111 * (( (Float)(1) ) - a26));
HXDLIN(  85)														int r17 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN(  85)														int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN(  85)														int b34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a36) + (b211 * a26))));
HXDLIN(  85)														int a27 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN(  85)														int blended6 = ((((a27 << 24) | (r17 << 16)) | (g8 << 8)) | b34);
HXDLIN(  85)														{
HXDLIN(  85)															int _hx_tmp39;
HXDLIN(  85)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)																_hx_tmp39 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            															}
            															else {
HXDLIN(  85)																_hx_tmp39 = blended6;
            															}
HXDLIN(  85)															::iterMagic::Iimg_obj::set(this47->image,location6,_hx_tmp39);
            														}
            													}
            													else {
HXDLIN(  85)														::Dynamic this115 = this47->image;
HXDLIN(  85)														int index17;
HXDLIN(  85)														if (this47->useVirtualPos) {
HXDLIN(  85)															index17 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this47->virtualY) * ( (Float)(this47->width) )) + px1) - this47->virtualX));
            														}
            														else {
HXDLIN(  85)															index17 = ::Std_obj::_hx_int(( (Float)(((py1 * this47->width) + px1)) ));
            														}
HXDLIN(  85)														int _hx_tmp40;
HXDLIN(  85)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)															_hx_tmp40 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            														}
            														else {
HXDLIN(  85)															_hx_tmp40 = c17;
            														}
HXDLIN(  85)														::iterMagic::Iimg_obj::set(this115,index17,_hx_tmp40);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  85)							 ::pi_xy::iter::IntIterStart v_yIter31;
HXDLIN(  85)							 ::pi_xy::iter::IntIterStart v_xIter31;
HXDLIN(  85)							int v_undoY1;
HXDLIN(  85)							int v_undoX1;
HXDLIN(  85)							Float v_ty1;
HXDLIN(  85)							Float v_tx1;
HXDLIN(  85)							Float v_t01;
HXDLIN(  85)							Float v_sy1;
HXDLIN(  85)							Float v_sx1;
HXDLIN(  85)							Float v_s01;
HXDLIN(  85)							Float v_A1;
HXDLIN(  85)							Float ax2 = bx;
HXDLIN(  85)							Float ay2 = by;
HXDLIN(  85)							 ::pi_xy::ImageStruct v_undoImage1 = null();
HXDLIN(  85)							Float bx2 = cx;
HXDLIN(  85)							Float by2 = cy;
HXDLIN(  85)							Float cx2 = dx;
HXDLIN(  85)							Float cy2 = dy;
HXDLIN(  85)							bool adjustWinding1 = (((((ax2 * by2) - (bx2 * ay2)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ay2) - (ax2 * cy2))) > 0);
HXDLIN(  85)							if (!(adjustWinding1)) {
HXDLIN(  85)								Float bx_1 = bx2;
HXDLIN(  85)								Float by_1 = by2;
HXLINE(  24)								bx2 = cx2;
HXLINE(  25)								by2 = cy2;
HXLINE(  26)								cx2 = bx_1;
HXLINE(  27)								cy2 = by_1;
            							}
HXLINE(  85)							Float v_ax1 = ax2;
HXDLIN(  85)							Float v_ay1 = ay2;
HXDLIN(  85)							Float v_bx1 = bx2;
HXDLIN(  85)							Float v_by1 = by2;
HXDLIN(  85)							Float v_cx1 = cx2;
HXDLIN(  85)							Float v_cy1 = cy2;
HXDLIN(  85)							bool v_preCalculated1 = true;
HXDLIN(  85)							{
HXDLIN(  85)								v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN(  85)								v_sx1 = (v_cy1 - v_ay1);
HXDLIN(  85)								v_sy1 = (v_ax1 - v_cx1);
HXDLIN(  85)								v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN(  85)								v_tx1 = (v_ay1 - v_by1);
HXDLIN(  85)								v_ty1 = (v_bx1 - v_ax1);
HXDLIN(  85)								v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN(  85)								Float a28 = v_ax1;
HXDLIN(  85)								Float b35 = v_bx1;
HXDLIN(  85)								Float c18 = v_cx1;
HXDLIN(  85)								if ((a28 > b35)) {
HXDLIN(  85)									if ((a28 > c18)) {
HXDLIN(  85)										int min14;
HXDLIN(  85)										if ((b35 > c18)) {
HXDLIN(  85)											min14 = ::Math_obj::floor(c18);
            										}
            										else {
HXDLIN(  85)											min14 = ::Math_obj::floor(b35);
            										}
HXDLIN(  85)										int ii_min32 = min14;
HXDLIN(  85)										int ii_max32 = ::Math_obj::ceil(a28);
HXDLIN(  85)										v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min32,ii_max32);
            									}
            									else {
HXDLIN(  85)										int ii_min33 = ::Math_obj::floor(b35);
HXDLIN(  85)										int ii_max33 = ::Math_obj::ceil(c18);
HXDLIN(  85)										v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min33,ii_max33);
            									}
            								}
            								else {
HXDLIN(  85)									if ((b35 > c18)) {
HXDLIN(  85)										int min15;
HXDLIN(  85)										if ((a28 > c18)) {
HXDLIN(  85)											min15 = ::Math_obj::floor(c18);
            										}
            										else {
HXDLIN(  85)											min15 = ::Math_obj::ceil(a28);
            										}
HXDLIN(  85)										int ii_min34 = min15;
HXDLIN(  85)										int ii_max34 = ::Math_obj::ceil(b35);
HXDLIN(  85)										v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min34,ii_max34);
            									}
            									else {
HXDLIN(  85)										int ii_min35 = ::Math_obj::floor(a28);
HXDLIN(  85)										int ii_max35 = ::Math_obj::ceil(c18);
HXDLIN(  85)										v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min35,ii_max35);
            									}
            								}
HXDLIN(  85)								Float a29 = v_ay1;
HXDLIN(  85)								Float b36 = v_by1;
HXDLIN(  85)								Float c19 = v_cy1;
HXDLIN(  85)								if ((a29 > b36)) {
HXDLIN(  85)									if ((a29 > c19)) {
HXDLIN(  85)										int min16;
HXDLIN(  85)										if ((b36 > c19)) {
HXDLIN(  85)											min16 = ::Math_obj::floor(c19);
            										}
            										else {
HXDLIN(  85)											min16 = ::Math_obj::floor(b36);
            										}
HXDLIN(  85)										int ii_min36 = min16;
HXDLIN(  85)										int ii_max36 = ::Math_obj::ceil(a29);
HXDLIN(  85)										v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min36,ii_max36);
            									}
            									else {
HXDLIN(  85)										int ii_min37 = ::Math_obj::floor(b36);
HXDLIN(  85)										int ii_max37 = ::Math_obj::ceil(c19);
HXDLIN(  85)										v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min37,ii_max37);
            									}
            								}
            								else {
HXDLIN(  85)									if ((b36 > c19)) {
HXDLIN(  85)										int min17;
HXDLIN(  85)										if ((a29 > c19)) {
HXDLIN(  85)											min17 = ::Math_obj::floor(c19);
            										}
            										else {
HXDLIN(  85)											min17 = ::Math_obj::ceil(a29);
            										}
HXDLIN(  85)										int ii_min38 = min17;
HXDLIN(  85)										int ii_max38 = ::Math_obj::ceil(b36);
HXDLIN(  85)										v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min38,ii_max38);
            									}
            									else {
HXDLIN(  85)										int ii_min39 = ::Math_obj::floor(a29);
HXDLIN(  85)										int ii_max39 = ::Math_obj::ceil(c19);
HXDLIN(  85)										v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min39,ii_max39);
            									}
            								}
            							}
HXDLIN(  85)							if (hasUndo1) {
HXDLIN(  85)								v_undoImage1 = undoImage3;
HXDLIN(  85)								v_undoX1 = xIter31->start;
HXDLIN(  85)								v_undoY1 = yIter31->start;
            							}
            						}
            					}
HXDLIN(  85)					bool _hx_tmp41;
HXDLIN(  85)					if (::hx::IsNotNull( nextImage3->mask )) {
HXDLIN(  85)						_hx_tmp41 = includeMask;
            					}
            					else {
HXDLIN(  85)						_hx_tmp41 = false;
            					}
HXDLIN(  85)					if (_hx_tmp41) {
HXDLIN(  85)						 ::pi_xy::ImageStruct this116 = this44->mask;
HXDLIN(  85)						bool transparent1 = this44->mask->transparent;
HXDLIN(  85)						Float centreX2 = centreX1;
HXDLIN(  85)						Float centreY2 = centreY1;
HXDLIN(  85)						Float ax3 = ((Float)0.);
HXDLIN(  85)						Float ay3 = ((Float)0.);
HXDLIN(  85)						if ((centreX2 != ((Float)0.))) {
HXLINE( 173)							centreX2 = ((( (Float)(this116->width) ) / ( (Float)(2) )) + centreX2);
HXLINE(  85)							ax3 = (ax3 - centreX2);
            						}
HXDLIN(  85)						if ((centreY2 != ((Float)0.))) {
HXLINE( 177)							centreY2 = ((( (Float)(this116->height) ) / ( (Float)(2) )) + centreY2);
HXLINE(  85)							ay3 = (ay3 - centreY2);
            						}
HXDLIN(  85)						Float bx3 = (ax3 + this116->width);
HXDLIN(  85)						Float by3 = ay3;
HXDLIN(  85)						Float cx3 = bx3;
HXDLIN(  85)						Float cy3 = (ay3 + this116->height);
HXDLIN(  85)						Float dx3 = ax3;
HXDLIN(  85)						Float dy3 = cy3;
HXDLIN(  85)						Float sin1 = ::Math_obj::sin(theta1);
HXDLIN(  85)						Float cos1 = ::Math_obj::cos(theta1);
HXDLIN(  85)						Float temp6 = ax3;
HXLINE( 189)						ax3 = ((temp6 * cos1) - (ay3 * sin1));
HXLINE( 190)						ay3 = ((ay3 * cos1) + (temp6 * sin1));
HXLINE(  85)						Float temp7 = bx3;
HXLINE( 192)						bx3 = ((temp7 * cos1) - (by3 * sin1));
HXLINE( 193)						by3 = ((by3 * cos1) + (temp7 * sin1));
HXLINE(  85)						Float temp8 = cx3;
HXLINE( 195)						cx3 = ((temp8 * cos1) - (cy3 * sin1));
HXLINE( 196)						cy3 = ((cy3 * cos1) + (temp8 * sin1));
HXLINE(  85)						Float temp9 = dx3;
HXLINE( 198)						dx3 = ((temp9 * cos1) - (dy3 * sin1));
HXLINE( 199)						dy3 = ((dy3 * cos1) + (temp9 * sin1));
HXLINE(  85)						if ((centreX2 != ((Float)0.))) {
HXDLIN(  85)							ax3 = (ax3 + centreX2);
HXDLIN(  85)							bx3 = (bx3 + centreX2);
HXDLIN(  85)							cx3 = (cx3 + centreX2);
HXDLIN(  85)							dx3 = (dx3 + centreX2);
            						}
HXDLIN(  85)						if ((centreY2 != ((Float)0.))) {
HXDLIN(  85)							ay3 = (ay3 + centreY2);
HXDLIN(  85)							by3 = (by3 + centreY2);
HXDLIN(  85)							cy3 = (cy3 + centreY2);
HXDLIN(  85)							dy3 = (dy3 + centreY2);
            						}
HXDLIN(  85)						int min18 = ::Math_obj::floor(ax3);
HXDLIN(  85)						int max2 = ::Math_obj::ceil(ax3);
HXDLIN(  85)						if ((bx3 < min18)) {
HXLINE(  31)							min18 = ::Math_obj::floor(bx3);
            						}
            						else {
HXDLIN(  85)							if ((bx3 > max2)) {
HXLINE(  33)								max2 = ::Math_obj::ceil(bx3);
            							}
            						}
HXLINE(  85)						if ((cx3 < min18)) {
HXLINE(  36)							min18 = ::Math_obj::floor(cx3);
            						}
            						else {
HXDLIN(  85)							if ((cx3 > max2)) {
HXLINE(  38)								max2 = ::Math_obj::ceil(cx3);
            							}
            						}
HXLINE(  85)						if ((dx3 < min18)) {
HXLINE(  41)							min18 = ::Math_obj::floor(dx3);
            						}
            						else {
HXDLIN(  85)							if ((dx3 > max2)) {
HXLINE(  43)								max2 = ::Math_obj::ceil(dx3);
            							}
            						}
HXLINE(  85)						int ii_min40 = min18;
HXDLIN(  85)						int ii_max40 = max2;
HXDLIN(  85)						 ::pi_xy::iter::IntIterStart boundX1 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min40,ii_max40);
HXDLIN(  85)						int min19 = ::Math_obj::floor(ay3);
HXDLIN(  85)						int max3 = ::Math_obj::ceil(ay3);
HXDLIN(  85)						if ((by3 < min19)) {
HXLINE(  31)							min19 = ::Math_obj::floor(by3);
            						}
            						else {
HXDLIN(  85)							if ((by3 > max3)) {
HXLINE(  33)								max3 = ::Math_obj::ceil(by3);
            							}
            						}
HXLINE(  85)						if ((cy3 < min19)) {
HXLINE(  36)							min19 = ::Math_obj::floor(cy3);
            						}
            						else {
HXDLIN(  85)							if ((cy3 > max3)) {
HXLINE(  38)								max3 = ::Math_obj::ceil(cy3);
            							}
            						}
HXLINE(  85)						if ((dy3 < min19)) {
HXLINE(  41)							min19 = ::Math_obj::floor(dy3);
            						}
            						else {
HXDLIN(  85)							if ((dy3 > max3)) {
HXLINE(  43)								max3 = ::Math_obj::ceil(dy3);
            							}
            						}
HXLINE(  85)						int ii_min41 = min19;
HXDLIN(  85)						int ii_max41 = max3;
HXDLIN(  85)						 ::pi_xy::iter::IntIterStart boundY1 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min41,ii_max41);
HXDLIN(  85)						int minX1 = boundX1->start;
HXDLIN(  85)						int wid1 = ((boundX1->max - boundX1->start) + 1);
HXDLIN(  85)						int minY1 = boundY1->start;
HXDLIN(  85)						int hi1 = ((boundY1->max - boundY1->start) + 1);
HXDLIN(  85)						 ::Dynamic imageType6 = null();
HXDLIN(  85)						 ::pi_xy::ImageStruct this117 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  85)						if (::hx::IsNull( imageType6 )) {
HXLINE(  54)							imageType6 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE(  85)						::Dynamic _hx_tmp42;
HXDLIN(  85)						switch((int)(( (int)(imageType6) ))){
            							case (int)0: {
HXDLIN(  85)								 ::iterMagic::BytesImg byt6 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  85)								 ::iterMagic::BytesImg b37 = byt6;
HXDLIN(  85)								{
HXDLIN(  85)									b37->width = wid1;
HXDLIN(  85)									b37->height = hi1;
HXDLIN(  85)									b37->length = ::Std_obj::_hx_int(( (Float)((wid1 * hi1)) ));
HXDLIN(  85)									b37->data = ::haxe::io::Bytes_obj::alloc((b37->length * 4));
HXDLIN(  85)									{
HXDLIN(  85)										int len12 = b37->length;
HXDLIN(  85)										int w9 = 0;
HXDLIN(  85)										{
HXDLIN(  85)											int _g104 = 0;
HXDLIN(  85)											int _g105 = b37->height;
HXDLIN(  85)											while((_g104 < _g105)){
HXDLIN(  85)												_g104 = (_g104 + 1);
HXDLIN(  85)												int y18 = (_g104 - 1);
HXDLIN(  85)												{
HXDLIN(  85)													int _g106 = 0;
HXDLIN(  85)													int _g107 = b37->width;
HXDLIN(  85)													while((_g106 < _g107)){
HXDLIN(  85)														_g106 = (_g106 + 1);
HXDLIN(  85)														int x18 = (_g106 - 1);
HXDLIN(  85)														{
HXDLIN(  85)															w9 = (w9 + 1);
HXDLIN(  85)															b37->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  85)														{
HXDLIN(  85)															w9 = (w9 + 1);
HXDLIN(  85)															b37->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  85)														{
HXDLIN(  85)															w9 = (w9 + 1);
HXDLIN(  85)															b37->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  85)														{
HXDLIN(  85)															w9 = (w9 + 1);
HXDLIN(  85)															b37->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  85)								_hx_tmp42 = b37;
            							}
            							break;
            							case (int)1: {
HXDLIN(  85)								 ::iterMagic::ArrIntImg arrI6 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  85)								 ::iterMagic::ArrIntImg a30 = arrI6;
HXDLIN(  85)								{
HXDLIN(  85)									a30->width = wid1;
HXDLIN(  85)									a30->height = hi1;
HXDLIN(  85)									a30->data = ::Array_obj< int >::__new(0);
HXDLIN(  85)									a30->length = ::Std_obj::_hx_int(( (Float)((wid1 * hi1)) ));
HXDLIN(  85)									{
HXDLIN(  85)										int _g108 = 0;
HXDLIN(  85)										int _g109 = a30->length;
HXDLIN(  85)										while((_g108 < _g109)){
HXDLIN(  85)											_g108 = (_g108 + 1);
HXDLIN(  85)											int i42 = (_g108 - 1);
HXDLIN(  85)											a30->data[i42] = 0;
            										}
            									}
            								}
HXDLIN(  85)								_hx_tmp42 = a30;
            							}
            							break;
            							case (int)2: {
HXDLIN(  85)								 ::iterMagic::U32ArrImg u32a6 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  85)								 ::iterMagic::U32ArrImg b38 = u32a6;
HXDLIN(  85)								{
HXDLIN(  85)									b38->width = wid1;
HXDLIN(  85)									b38->height = hi1;
HXDLIN(  85)									b38->length = ::Std_obj::_hx_int(( (Float)((wid1 * hi1)) ));
HXDLIN(  85)									int size6 = (b38->length * 4);
HXDLIN(  85)									b38->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size6),0,size6);
HXDLIN(  85)									{
HXDLIN(  85)										int _g110 = 0;
HXDLIN(  85)										int _g111 = b38->length;
HXDLIN(  85)										while((_g110 < _g111)){
HXDLIN(  85)											_g110 = (_g110 + 1);
HXDLIN(  85)											int i43 = (_g110 - 1);
HXDLIN(  85)											{
HXDLIN(  85)												 ::haxe::io::ArrayBufferViewImpl this118 = b38->data;
HXDLIN(  85)												bool _hx_tmp43;
HXDLIN(  85)												if ((i43 >= 0)) {
HXDLIN(  85)													_hx_tmp43 = (i43 < (this118->byteLength >> 2));
            												}
            												else {
HXDLIN(  85)													_hx_tmp43 = false;
            												}
HXDLIN(  85)												if (_hx_tmp43) {
HXDLIN(  85)													 ::haxe::io::Bytes _this6 = this118->bytes;
HXDLIN(  85)													int pos6 = ((i43 << 2) + this118->byteOffset);
HXDLIN(  85)													_this6->b[pos6] = ( (unsigned char)(0) );
HXDLIN(  85)													_this6->b[(pos6 + 1)] = ( (unsigned char)(0) );
HXDLIN(  85)													_this6->b[(pos6 + 2)] = ( (unsigned char)(0) );
HXDLIN(  85)													_this6->b[(pos6 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN(  85)								_hx_tmp42 = b38;
            							}
            							break;
            							case (int)3: {
HXDLIN(  85)								 ::iterMagic::VecIntImg vec6 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  85)								 ::iterMagic::VecIntImg v13 = vec6;
HXDLIN(  85)								{
HXDLIN(  85)									v13->width = wid1;
HXDLIN(  85)									v13->height = hi1;
HXDLIN(  85)									v13->length = ::Std_obj::_hx_int(( (Float)((wid1 * hi1)) ));
HXDLIN(  85)									v13->data = ::Array_obj< int >::__new(v13->length);
HXDLIN(  85)									{
HXDLIN(  85)										int _g112 = 0;
HXDLIN(  85)										int _g113 = v13->length;
HXDLIN(  85)										while((_g112 < _g113)){
HXDLIN(  85)											_g112 = (_g112 + 1);
HXDLIN(  85)											int i44 = (_g112 - 1);
HXDLIN(  85)											v13->data->__unsafe_set(i44,0);
            										}
            									}
            								}
HXDLIN(  85)								_hx_tmp42 = v13;
            							}
            							break;
            							case (int)4: {
HXDLIN(  85)								 ::iterMagic::StackIntImg sInt6 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  85)								 ::iterMagic::StackIntImg b39 = sInt6;
HXDLIN(  85)								{
HXDLIN(  85)									b39->width = wid1;
HXDLIN(  85)									b39->height = hi1;
HXDLIN(  85)									b39->length = ::Std_obj::_hx_int(( (Float)((wid1 * hi1)) ));
HXDLIN(  85)									b39->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  85)									{
HXDLIN(  85)										int len13 = b39->length;
HXDLIN(  85)										 ::haxe::ds::GenericStack_Int d6 = b39->data;
HXDLIN(  85)										if (::hx::IsNull( d6->head )) {
HXDLIN(  85)											int _g114 = 0;
HXDLIN(  85)											int _g115 = len13;
HXDLIN(  85)											while((_g114 < _g115)){
HXDLIN(  85)												_g114 = (_g114 + 1);
HXDLIN(  85)												int i45 = (_g114 - 1);
HXDLIN(  85)												d6->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d6->head);
            											}
            										}
            										else {
HXDLIN(  85)											int _g116 = 0;
HXDLIN(  85)											int _g117 = len13;
HXDLIN(  85)											while((_g116 < _g117)){
HXDLIN(  85)												_g116 = (_g116 + 1);
HXDLIN(  85)												int i46 = (_g116 - 1);
HXDLIN(  85)												{
HXDLIN(  85)													 ::haxe::ds::GenericCell_Int l6 = b39->data->head;
HXDLIN(  85)													 ::haxe::ds::GenericCell_Int prev6 = null();
HXDLIN(  85)													{
HXDLIN(  85)														int _g118 = 0;
HXDLIN(  85)														int _g119 = i46;
HXDLIN(  85)														while((_g118 < _g119)){
HXDLIN(  85)															_g118 = (_g118 + 1);
HXDLIN(  85)															int i47 = (_g118 - 1);
HXLINE( 345)															prev6 = l6;
HXLINE( 346)															l6 = l6->next;
            														}
            													}
HXLINE(  85)													if (::hx::IsNull( prev6 )) {
HXDLIN(  85)														b39->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN(  85)														l6 = null();
            													}
            													else {
HXDLIN(  85)														prev6->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN(  85)														l6 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  85)								_hx_tmp42 = b39;
            							}
            							break;
            						}
HXDLIN(  85)						this117->image = _hx_tmp42;
HXDLIN(  85)						this117->width = wid1;
HXDLIN(  85)						this117->height = hi1;
HXDLIN(  85)						this117->imageType = ( (int)(imageType6) );
HXDLIN(  85)						 ::pi_xy::ImageStruct nextImage4 = this117;
HXDLIN(  85)						nextImage4->transparent = true;
HXDLIN(  85)						if ((minX1 < ((Float)0.))) {
HXDLIN(  85)							ax3 = (ax3 - ( (Float)(minX1) ));
HXDLIN(  85)							bx3 = (bx3 - ( (Float)(minX1) ));
HXDLIN(  85)							cx3 = (cx3 - ( (Float)(minX1) ));
HXDLIN(  85)							dx3 = (dx3 - ( (Float)(minX1) ));
            						}
HXDLIN(  85)						if ((minY1 < ((Float)0.))) {
HXDLIN(  85)							ay3 = (ay3 - ( (Float)(minY1) ));
HXDLIN(  85)							by3 = (by3 - ( (Float)(minY1) ));
HXDLIN(  85)							cy3 = (cy3 - ( (Float)(minY1) ));
HXDLIN(  85)							dy3 = (dy3 - ( (Float)(minY1) ));
            						}
HXDLIN(  85)						{
HXDLIN(  85)							 ::pi_xy::ImageStruct this119 = nextImage4;
HXDLIN(  85)							Float win_x1 = ( (Float)(0) );
HXDLIN(  85)							Float win_y1 = ( (Float)(0) );
HXDLIN(  85)							Float win_width1 = ( (Float)(this116->width) );
HXDLIN(  85)							Float win_height1 = ( (Float)(this116->height) );
HXDLIN(  85)							{
HXDLIN(  85)								Float bu3 = ((Float)1.);
HXDLIN(  85)								Float bv3 = ((Float)0.);
HXDLIN(  85)								Float cu1 = ((Float)1.);
HXDLIN(  85)								Float cv1 = ((Float)1.);
HXDLIN(  85)								Float du1 = ((Float)0.);
HXDLIN(  85)								Float dv1 = ((Float)1.);
HXDLIN(  85)								Float au2 = ((Float)0.);
HXDLIN(  85)								Float av2 = ((Float)0.);
HXDLIN(  85)								Float bu4 = bu3;
HXDLIN(  85)								Float bv4 = bv3;
HXDLIN(  85)								bool hasUndo2 = false;
HXDLIN(  85)								Float temp10 = au2;
HXLINE( 422)								au2 = bu4;
HXLINE( 423)								bu4 = temp10;
HXLINE( 424)								temp10 = av2;
HXLINE( 425)								av2 = bv4;
HXLINE( 426)								bv4 = temp10;
HXLINE(  85)								Float bcx2 = (bx3 - dx3);
HXDLIN(  85)								Float bcy2 = (by3 - dy3);
HXDLIN(  85)								Float acx2 = (ax3 - dx3);
HXDLIN(  85)								Float acy2 = (ay3 - dy3);
HXDLIN(  85)								Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN(  85)								Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN(  85)								Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN(  85)								Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN(  85)								 ::pi_xy::iter::IntIterStart xIter32;
HXDLIN(  85)								if ((ax3 > bx3)) {
HXDLIN(  85)									if ((ax3 > dx3)) {
HXDLIN(  85)										int min20;
HXDLIN(  85)										if ((bx3 > dx3)) {
HXDLIN(  85)											min20 = ::Math_obj::floor(dx3);
            										}
            										else {
HXDLIN(  85)											min20 = ::Math_obj::floor(bx3);
            										}
HXDLIN(  85)										int ii_min42 = min20;
HXDLIN(  85)										int ii_max42 = ::Math_obj::ceil(ax3);
HXDLIN(  85)										xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min42,ii_max42);
            									}
            									else {
HXDLIN(  85)										int ii_min43 = ::Math_obj::floor(bx3);
HXDLIN(  85)										int ii_max43 = ::Math_obj::ceil(dx3);
HXDLIN(  85)										xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min43,ii_max43);
            									}
            								}
            								else {
HXDLIN(  85)									if ((bx3 > dx3)) {
HXDLIN(  85)										int min21;
HXDLIN(  85)										if ((ax3 > dx3)) {
HXDLIN(  85)											min21 = ::Math_obj::floor(dx3);
            										}
            										else {
HXDLIN(  85)											min21 = ::Math_obj::ceil(ax3);
            										}
HXDLIN(  85)										int ii_min44 = min21;
HXDLIN(  85)										int ii_max44 = ::Math_obj::ceil(bx3);
HXDLIN(  85)										xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min44,ii_max44);
            									}
            									else {
HXDLIN(  85)										int ii_min45 = ::Math_obj::floor(ax3);
HXDLIN(  85)										int ii_max45 = ::Math_obj::ceil(dx3);
HXDLIN(  85)										xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min45,ii_max45);
            									}
            								}
HXDLIN(  85)								 ::pi_xy::iter::IntIterStart yIter32;
HXDLIN(  85)								if ((ay3 > by3)) {
HXDLIN(  85)									if ((ay3 > dy3)) {
HXDLIN(  85)										int min22;
HXDLIN(  85)										if ((by3 > dy3)) {
HXDLIN(  85)											min22 = ::Math_obj::floor(dy3);
            										}
            										else {
HXDLIN(  85)											min22 = ::Math_obj::floor(by3);
            										}
HXDLIN(  85)										int ii_min46 = min22;
HXDLIN(  85)										int ii_max46 = ::Math_obj::ceil(ay3);
HXDLIN(  85)										yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min46,ii_max46);
            									}
            									else {
HXDLIN(  85)										int ii_min47 = ::Math_obj::floor(by3);
HXDLIN(  85)										int ii_max47 = ::Math_obj::ceil(dy3);
HXDLIN(  85)										yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min47,ii_max47);
            									}
            								}
            								else {
HXDLIN(  85)									if ((by3 > dy3)) {
HXDLIN(  85)										int min23;
HXDLIN(  85)										if ((ay3 > dy3)) {
HXDLIN(  85)											min23 = ::Math_obj::floor(dy3);
            										}
            										else {
HXDLIN(  85)											min23 = ::Math_obj::ceil(ay3);
            										}
HXDLIN(  85)										int ii_min48 = min23;
HXDLIN(  85)										int ii_max48 = ::Math_obj::ceil(by3);
HXDLIN(  85)										yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min48,ii_max48);
            									}
            									else {
HXDLIN(  85)										int ii_min49 = ::Math_obj::floor(ay3);
HXDLIN(  85)										int ii_max49 = ::Math_obj::ceil(dy3);
HXDLIN(  85)										yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min49,ii_max49);
            									}
            								}
HXDLIN(  85)								 ::pi_xy::ImageStruct undoImage6 = null();
HXDLIN(  85)								if (hasUndo2) {
HXDLIN(  85)									int width5 = ((xIter32->max - xIter32->start) + 1);
HXDLIN(  85)									int height5 = ((yIter32->max - yIter32->start) + 1);
HXDLIN(  85)									 ::Dynamic imageType7 = null();
HXDLIN(  85)									 ::pi_xy::ImageStruct this120 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  85)									if (::hx::IsNull( imageType7 )) {
HXLINE(  54)										imageType7 = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE(  85)									::Dynamic undoImage7;
HXDLIN(  85)									switch((int)(( (int)(imageType7) ))){
            										case (int)0: {
HXDLIN(  85)											 ::iterMagic::BytesImg byt7 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  85)											 ::iterMagic::BytesImg b40 = byt7;
HXDLIN(  85)											{
HXDLIN(  85)												b40->width = width5;
HXDLIN(  85)												b40->height = height5;
HXDLIN(  85)												b40->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN(  85)												b40->data = ::haxe::io::Bytes_obj::alloc((b40->length * 4));
HXDLIN(  85)												{
HXDLIN(  85)													int len14 = b40->length;
HXDLIN(  85)													int w10 = 0;
HXDLIN(  85)													{
HXDLIN(  85)														int _g120 = 0;
HXDLIN(  85)														int _g121 = b40->height;
HXDLIN(  85)														while((_g120 < _g121)){
HXDLIN(  85)															_g120 = (_g120 + 1);
HXDLIN(  85)															int y19 = (_g120 - 1);
HXDLIN(  85)															{
HXDLIN(  85)																int _g122 = 0;
HXDLIN(  85)																int _g123 = b40->width;
HXDLIN(  85)																while((_g122 < _g123)){
HXDLIN(  85)																	_g122 = (_g122 + 1);
HXDLIN(  85)																	int x19 = (_g122 - 1);
HXDLIN(  85)																	{
HXDLIN(  85)																		w10 = (w10 + 1);
HXDLIN(  85)																		b40->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  85)																	{
HXDLIN(  85)																		w10 = (w10 + 1);
HXDLIN(  85)																		b40->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  85)																	{
HXDLIN(  85)																		w10 = (w10 + 1);
HXDLIN(  85)																		b40->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  85)																	{
HXDLIN(  85)																		w10 = (w10 + 1);
HXDLIN(  85)																		b40->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  85)											undoImage7 = b40;
            										}
            										break;
            										case (int)1: {
HXDLIN(  85)											 ::iterMagic::ArrIntImg arrI7 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  85)											 ::iterMagic::ArrIntImg a37 = arrI7;
HXDLIN(  85)											{
HXDLIN(  85)												a37->width = width5;
HXDLIN(  85)												a37->height = height5;
HXDLIN(  85)												a37->data = ::Array_obj< int >::__new(0);
HXDLIN(  85)												a37->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN(  85)												{
HXDLIN(  85)													int _g124 = 0;
HXDLIN(  85)													int _g125 = a37->length;
HXDLIN(  85)													while((_g124 < _g125)){
HXDLIN(  85)														_g124 = (_g124 + 1);
HXDLIN(  85)														int i48 = (_g124 - 1);
HXDLIN(  85)														a37->data[i48] = 0;
            													}
            												}
            											}
HXDLIN(  85)											undoImage7 = a37;
            										}
            										break;
            										case (int)2: {
HXDLIN(  85)											 ::iterMagic::U32ArrImg u32a7 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  85)											 ::iterMagic::U32ArrImg b41 = u32a7;
HXDLIN(  85)											{
HXDLIN(  85)												b41->width = width5;
HXDLIN(  85)												b41->height = height5;
HXDLIN(  85)												b41->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN(  85)												int size7 = (b41->length * 4);
HXDLIN(  85)												b41->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size7),0,size7);
HXDLIN(  85)												{
HXDLIN(  85)													int _g126 = 0;
HXDLIN(  85)													int _g127 = b41->length;
HXDLIN(  85)													while((_g126 < _g127)){
HXDLIN(  85)														_g126 = (_g126 + 1);
HXDLIN(  85)														int i49 = (_g126 - 1);
HXDLIN(  85)														{
HXDLIN(  85)															 ::haxe::io::ArrayBufferViewImpl this121 = b41->data;
HXDLIN(  85)															bool undoImage8;
HXDLIN(  85)															if ((i49 >= 0)) {
HXDLIN(  85)																undoImage8 = (i49 < (this121->byteLength >> 2));
            															}
            															else {
HXDLIN(  85)																undoImage8 = false;
            															}
HXDLIN(  85)															if (undoImage8) {
HXDLIN(  85)																 ::haxe::io::Bytes _this7 = this121->bytes;
HXDLIN(  85)																int pos7 = ((i49 << 2) + this121->byteOffset);
HXDLIN(  85)																_this7->b[pos7] = ( (unsigned char)(0) );
HXDLIN(  85)																_this7->b[(pos7 + 1)] = ( (unsigned char)(0) );
HXDLIN(  85)																_this7->b[(pos7 + 2)] = ( (unsigned char)(0) );
HXDLIN(  85)																_this7->b[(pos7 + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN(  85)											undoImage7 = b41;
            										}
            										break;
            										case (int)3: {
HXDLIN(  85)											 ::iterMagic::VecIntImg vec7 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  85)											 ::iterMagic::VecIntImg v14 = vec7;
HXDLIN(  85)											{
HXDLIN(  85)												v14->width = width5;
HXDLIN(  85)												v14->height = height5;
HXDLIN(  85)												v14->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN(  85)												v14->data = ::Array_obj< int >::__new(v14->length);
HXDLIN(  85)												{
HXDLIN(  85)													int _g128 = 0;
HXDLIN(  85)													int _g129 = v14->length;
HXDLIN(  85)													while((_g128 < _g129)){
HXDLIN(  85)														_g128 = (_g128 + 1);
HXDLIN(  85)														int i50 = (_g128 - 1);
HXDLIN(  85)														v14->data->__unsafe_set(i50,0);
            													}
            												}
            											}
HXDLIN(  85)											undoImage7 = v14;
            										}
            										break;
            										case (int)4: {
HXDLIN(  85)											 ::iterMagic::StackIntImg sInt7 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  85)											 ::iterMagic::StackIntImg b42 = sInt7;
HXDLIN(  85)											{
HXDLIN(  85)												b42->width = width5;
HXDLIN(  85)												b42->height = height5;
HXDLIN(  85)												b42->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN(  85)												b42->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  85)												{
HXDLIN(  85)													int len15 = b42->length;
HXDLIN(  85)													 ::haxe::ds::GenericStack_Int d7 = b42->data;
HXDLIN(  85)													if (::hx::IsNull( d7->head )) {
HXDLIN(  85)														int _g130 = 0;
HXDLIN(  85)														int _g131 = len15;
HXDLIN(  85)														while((_g130 < _g131)){
HXDLIN(  85)															_g130 = (_g130 + 1);
HXDLIN(  85)															int i51 = (_g130 - 1);
HXDLIN(  85)															d7->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d7->head);
            														}
            													}
            													else {
HXDLIN(  85)														int _g132 = 0;
HXDLIN(  85)														int _g133 = len15;
HXDLIN(  85)														while((_g132 < _g133)){
HXDLIN(  85)															_g132 = (_g132 + 1);
HXDLIN(  85)															int i52 = (_g132 - 1);
HXDLIN(  85)															{
HXDLIN(  85)																 ::haxe::ds::GenericCell_Int l7 = b42->data->head;
HXDLIN(  85)																 ::haxe::ds::GenericCell_Int prev7 = null();
HXDLIN(  85)																{
HXDLIN(  85)																	int _g134 = 0;
HXDLIN(  85)																	int _g135 = i52;
HXDLIN(  85)																	while((_g134 < _g135)){
HXDLIN(  85)																		_g134 = (_g134 + 1);
HXDLIN(  85)																		int i53 = (_g134 - 1);
HXLINE( 345)																		prev7 = l7;
HXLINE( 346)																		l7 = l7->next;
            																	}
            																}
HXLINE(  85)																if (::hx::IsNull( prev7 )) {
HXDLIN(  85)																	b42->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l7->next);
HXDLIN(  85)																	l7 = null();
            																}
            																else {
HXDLIN(  85)																	prev7->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l7->next);
HXDLIN(  85)																	l7 = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  85)											undoImage7 = b42;
            										}
            										break;
            									}
HXDLIN(  85)									this120->image = undoImage7;
HXDLIN(  85)									this120->width = width5;
HXDLIN(  85)									this120->height = height5;
HXDLIN(  85)									this120->imageType = ( (int)(imageType7) );
HXDLIN(  85)									undoImage6 = this120;
HXDLIN(  85)									{
HXDLIN(  85)										int rectLeft2 = xIter32->start;
HXDLIN(  85)										int rectTop2 = yIter32->start;
HXDLIN(  85)										int rectRight2 = xIter32->max;
HXDLIN(  85)										bool forceClear2 = false;
HXDLIN(  85)										{
HXDLIN(  85)											int _g136 = rectTop2;
HXDLIN(  85)											int _g137 = yIter32->max;
HXDLIN(  85)											while((_g136 < _g137)){
HXDLIN(  85)												_g136 = (_g136 + 1);
HXDLIN(  85)												int dy4 = (_g136 - 1);
HXDLIN(  85)												{
HXDLIN(  85)													int _g138 = rectLeft2;
HXDLIN(  85)													int _g139 = rectRight2;
HXDLIN(  85)													while((_g138 < _g139)){
HXDLIN(  85)														_g138 = (_g138 + 1);
HXDLIN(  85)														int dx4 = (_g138 - 1);
HXDLIN(  85)														::Dynamic this122 = this119->image;
HXDLIN(  85)														int index18;
HXDLIN(  85)														if (this119->useVirtualPos) {
HXDLIN(  85)															index18 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this119->virtualY) * ( (Float)(this119->width) )) + dx4) - this119->virtualX));
            														}
            														else {
HXDLIN(  85)															index18 = ::Std_obj::_hx_int(( (Float)(((dy4 * this119->width) + dx4)) ));
            														}
HXDLIN(  85)														int c20 = ::iterMagic::Iimg_obj::get(this122,index18);
HXDLIN(  85)														int col4;
HXDLIN(  85)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)															col4 = ((((((c20 >> 24) & 255) << 24) | ((c20 & 255) << 16)) | (((c20 >> 8) & 255) << 8)) | ((c20 >> 16) & 255));
            														}
            														else {
HXDLIN(  85)															col4 = c20;
            														}
HXDLIN(  85)														bool _hx_tmp44;
HXDLIN(  85)														if (this119->useMask) {
HXDLIN(  85)															_hx_tmp44 = ::hx::IsNotNull( this119->mask );
            														}
            														else {
HXDLIN(  85)															_hx_tmp44 = false;
            														}
HXDLIN(  85)														if (_hx_tmp44) {
HXDLIN(  85)															 ::pi_xy::ImageStruct this123 = this119->mask;
HXDLIN(  85)															::Dynamic this124 = this123->image;
HXDLIN(  85)															int index19;
HXDLIN(  85)															if (this123->useVirtualPos) {
HXDLIN(  85)																index19 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this123->virtualY) * ( (Float)(this123->width) )) + dx4) - this123->virtualX));
            															}
            															else {
HXDLIN(  85)																index19 = ::Std_obj::_hx_int(( (Float)(((dy4 * this123->width) + dx4)) ));
            															}
HXDLIN(  85)															int c21 = ::iterMagic::Iimg_obj::get(this124,index19);
HXDLIN(  85)															int v15;
HXDLIN(  85)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)																v15 = ((((((c21 >> 24) & 255) << 24) | ((c21 & 255) << 16)) | (((c21 >> 8) & 255) << 8)) | ((c21 >> 16) & 255));
            															}
            															else {
HXDLIN(  85)																v15 = c21;
            															}
HXDLIN(  85)															int maskPixel2 = v15;
HXDLIN(  85)															int this125 = col4;
HXDLIN(  85)															if ((maskPixel2 == 0)) {
HXDLIN(  85)																col4 = this125;
            															}
            															else {
HXDLIN(  85)																Float m02;
HXDLIN(  85)																int this126 = ((maskPixel2 >> 24) & 255);
HXDLIN(  85)																if ((this126 == 0)) {
HXDLIN(  85)																	m02 = ((Float)0.);
            																}
            																else {
HXDLIN(  85)																	m02 = (( (Float)(this126) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float m12;
HXDLIN(  85)																int this127 = ((maskPixel2 >> 16) & 255);
HXDLIN(  85)																if ((this127 == 0)) {
HXDLIN(  85)																	m12 = ((Float)0.);
            																}
            																else {
HXDLIN(  85)																	m12 = (( (Float)(this127) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float m22;
HXDLIN(  85)																int this128 = ((maskPixel2 >> 8) & 255);
HXDLIN(  85)																if ((this128 == 0)) {
HXDLIN(  85)																	m22 = ((Float)0.);
            																}
            																else {
HXDLIN(  85)																	m22 = (( (Float)(this128) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float m32;
HXDLIN(  85)																int this129 = (maskPixel2 & 255);
HXDLIN(  85)																if ((this129 == 0)) {
HXDLIN(  85)																	m32 = ((Float)0.);
            																}
            																else {
HXDLIN(  85)																	m32 = (( (Float)(this129) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this125 >> 24) & 255)) )));
HXDLIN(  85)																int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this125 >> 16) & 255)) )));
HXDLIN(  85)																int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this125 >> 8) & 255)) )));
HXDLIN(  85)																int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this125 & 255)) )));
HXDLIN(  85)																col4 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  85)														if ((col4 != 0)) {
HXDLIN(  85)															int x20 = (dx4 - rectLeft2);
HXDLIN(  85)															int y20 = (dy4 - rectTop2);
HXDLIN(  85)															int c22 = col4;
HXDLIN(  85)															bool _hx_tmp45;
HXDLIN(  85)															if ((((c22 >> 24) & 255) < 254)) {
HXDLIN(  85)																_hx_tmp45 = undoImage6->transparent;
            															}
            															else {
HXDLIN(  85)																_hx_tmp45 = false;
            															}
HXDLIN(  85)															if (_hx_tmp45) {
HXDLIN(  85)																int location7;
HXDLIN(  85)																if (undoImage6->useVirtualPos) {
HXDLIN(  85)																	location7 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x20) - undoImage6->virtualX));
            																}
            																else {
HXDLIN(  85)																	location7 = ::Std_obj::_hx_int(( (Float)(((y20 * undoImage6->width) + x20)) ));
            																}
HXDLIN(  85)																int this130 = ::iterMagic::Iimg_obj::get(undoImage6->image,location7);
HXDLIN(  85)																int this131;
HXDLIN(  85)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)																	this131 = ((((((this130 >> 24) & 255) << 24) | ((this130 & 255) << 16)) | (((this130 >> 8) & 255) << 8)) | ((this130 >> 16) & 255));
            																}
            																else {
HXDLIN(  85)																	this131 = this130;
            																}
HXDLIN(  85)																Float a112;
HXDLIN(  85)																int this132 = ((this131 >> 24) & 255);
HXDLIN(  85)																if ((this132 == 0)) {
HXDLIN(  85)																	a112 = ((Float)0.);
            																}
            																else {
HXDLIN(  85)																	a112 = (( (Float)(this132) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float r18;
HXDLIN(  85)																int this133 = ((this131 >> 16) & 255);
HXDLIN(  85)																if ((this133 == 0)) {
HXDLIN(  85)																	r18 = ((Float)0.);
            																}
            																else {
HXDLIN(  85)																	r18 = (( (Float)(this133) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float g17;
HXDLIN(  85)																int this134 = ((this131 >> 8) & 255);
HXDLIN(  85)																if ((this134 == 0)) {
HXDLIN(  85)																	g17 = ((Float)0.);
            																}
            																else {
HXDLIN(  85)																	g17 = (( (Float)(this134) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float b114;
HXDLIN(  85)																int this135 = (this131 & 255);
HXDLIN(  85)																if ((this135 == 0)) {
HXDLIN(  85)																	b114 = ((Float)0.);
            																}
            																else {
HXDLIN(  85)																	b114 = (( (Float)(this135) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float a210;
HXDLIN(  85)																int this136 = ((col4 >> 24) & 255);
HXDLIN(  85)																if ((this136 == 0)) {
HXDLIN(  85)																	a210 = ((Float)0.);
            																}
            																else {
HXDLIN(  85)																	a210 = (( (Float)(this136) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float r27;
HXDLIN(  85)																int this137 = ((col4 >> 16) & 255);
HXDLIN(  85)																if ((this137 == 0)) {
HXDLIN(  85)																	r27 = ((Float)0.);
            																}
            																else {
HXDLIN(  85)																	r27 = (( (Float)(this137) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float g27;
HXDLIN(  85)																int this138 = ((col4 >> 8) & 255);
HXDLIN(  85)																if ((this138 == 0)) {
HXDLIN(  85)																	g27 = ((Float)0.);
            																}
            																else {
HXDLIN(  85)																	g27 = (( (Float)(this138) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float b212;
HXDLIN(  85)																int this139 = (col4 & 255);
HXDLIN(  85)																if ((this139 == 0)) {
HXDLIN(  85)																	b212 = ((Float)0.);
            																}
            																else {
HXDLIN(  85)																	b212 = (( (Float)(this139) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float a38 = (a112 * (( (Float)(1) ) - a210));
HXDLIN(  85)																int r19 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a38) + (r27 * a210))));
HXDLIN(  85)																int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a38) + (g27 * a210))));
HXDLIN(  85)																int b43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a38) + (b212 * a210))));
HXDLIN(  85)																int a39 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a210)));
HXDLIN(  85)																int blended7 = ((((a39 << 24) | (r19 << 16)) | (g9 << 8)) | b43);
HXDLIN(  85)																{
HXDLIN(  85)																	int _hx_tmp46;
HXDLIN(  85)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)																		_hx_tmp46 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            																	}
            																	else {
HXDLIN(  85)																		_hx_tmp46 = blended7;
            																	}
HXDLIN(  85)																	::iterMagic::Iimg_obj::set(undoImage6->image,location7,_hx_tmp46);
            																}
            															}
            															else {
HXDLIN(  85)																::Dynamic this140 = undoImage6->image;
HXDLIN(  85)																int index20;
HXDLIN(  85)																if (undoImage6->useVirtualPos) {
HXDLIN(  85)																	index20 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x20) - undoImage6->virtualX));
            																}
            																else {
HXDLIN(  85)																	index20 = ::Std_obj::_hx_int(( (Float)(((y20 * undoImage6->width) + x20)) ));
            																}
HXDLIN(  85)																int _hx_tmp47;
HXDLIN(  85)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)																	_hx_tmp47 = ((((((c22 >> 24) & 255) << 24) | ((c22 & 255) << 16)) | (((c22 >> 8) & 255) << 8)) | ((c22 >> 16) & 255));
            																}
            																else {
HXDLIN(  85)																	_hx_tmp47 = c22;
            																}
HXDLIN(  85)																::iterMagic::Iimg_obj::set(this140,index20,_hx_tmp47);
            															}
            														}
            														else {
HXDLIN(  85)															if (forceClear2) {
HXDLIN(  85)																::Dynamic this141 = undoImage6->image;
HXDLIN(  85)																int x21 = (dx4 - rectLeft2);
HXDLIN(  85)																int y21 = (dy4 - rectTop2);
HXDLIN(  85)																int index21;
HXDLIN(  85)																if (undoImage6->useVirtualPos) {
HXDLIN(  85)																	index21 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x21) - undoImage6->virtualX));
            																}
            																else {
HXDLIN(  85)																	index21 = ::Std_obj::_hx_int(( (Float)(((y21 * undoImage6->width) + x21)) ));
            																}
HXDLIN(  85)																::iterMagic::Iimg_obj::set(this141,index21,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  85)								{
HXDLIN(  85)									int _g_min4 = xIter32->start;
HXDLIN(  85)									int _g_max4 = xIter32->max;
HXDLIN(  85)									while((_g_min4 < _g_max4)){
HXDLIN(  85)										_g_min4 = (_g_min4 + 1);
HXDLIN(  85)										int px2 = (_g_min4 - 1);
HXDLIN(  85)										Float pcx2 = (( (Float)(px2) ) - dx3);
HXDLIN(  85)										{
HXDLIN(  85)											int _g_min5 = yIter32->start;
HXDLIN(  85)											int _g_max5 = yIter32->max;
HXDLIN(  85)											while((_g_min5 < _g_max5)){
HXDLIN(  85)												_g_min5 = (_g_min5 + 1);
HXDLIN(  85)												int py2 = (_g_min5 - 1);
HXDLIN(  85)												Float pcy2 = (( (Float)(py2) ) - dy3);
HXDLIN(  85)												Float dot312 = ((pcx2 * bcx2) + (pcy2 * bcy2));
HXDLIN(  85)												Float dot322 = ((pcx2 * acx2) + (pcy2 * acy2));
HXDLIN(  85)												Float ratioA2 = (((dot222 * dot312) - (dot122 * dot322)) * denom12);
HXDLIN(  85)												Float ratioB2 = (((dot112 * dot322) - (dot122 * dot312)) * denom12);
HXDLIN(  85)												Float ratioC2 = ((((Float)1.0) - ratioB2) - ratioA2);
HXDLIN(  85)												bool _hx_tmp48;
HXDLIN(  85)												bool _hx_tmp49;
HXDLIN(  85)												if ((ratioA2 >= 0)) {
HXDLIN(  85)													_hx_tmp49 = (ratioB2 >= 0);
            												}
            												else {
HXDLIN(  85)													_hx_tmp49 = false;
            												}
HXDLIN(  85)												if (_hx_tmp49) {
HXDLIN(  85)													_hx_tmp48 = (ratioC2 >= 0);
            												}
            												else {
HXDLIN(  85)													_hx_tmp48 = false;
            												}
HXDLIN(  85)												if (_hx_tmp48) {
HXDLIN(  85)													Float u2 = (((au2 * ratioA2) + (bu4 * ratioB2)) + (du1 * ratioC2));
HXDLIN(  85)													Float v16 = (((av2 * ratioA2) + (bv4 * ratioB2)) + (dv1 * ratioC2));
HXDLIN(  85)													int x22 = ::Std_obj::_hx_int(((u2 * win_width1) + win_x1));
HXDLIN(  85)													int y22 = ::Std_obj::_hx_int(((v16 * win_height1) + win_y1));
HXDLIN(  85)													::Dynamic this142 = this116->image;
HXDLIN(  85)													int index22;
HXDLIN(  85)													if (this116->useVirtualPos) {
HXDLIN(  85)														index22 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - this116->virtualY) * ( (Float)(this116->width) )) + x22) - this116->virtualX));
            													}
            													else {
HXDLIN(  85)														index22 = ::Std_obj::_hx_int(( (Float)(((y22 * this116->width) + x22)) ));
            													}
HXDLIN(  85)													int c23 = ::iterMagic::Iimg_obj::get(this142,index22);
HXDLIN(  85)													int col5;
HXDLIN(  85)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)														col5 = ((((((c23 >> 24) & 255) << 24) | ((c23 & 255) << 16)) | (((c23 >> 8) & 255) << 8)) | ((c23 >> 16) & 255));
            													}
            													else {
HXDLIN(  85)														col5 = c23;
            													}
HXDLIN(  85)													{
HXDLIN(  85)														int c24 = col5;
HXDLIN(  85)														bool _hx_tmp50;
HXDLIN(  85)														if ((((c24 >> 24) & 255) < 254)) {
HXDLIN(  85)															_hx_tmp50 = this119->transparent;
            														}
            														else {
HXDLIN(  85)															_hx_tmp50 = false;
            														}
HXDLIN(  85)														if (_hx_tmp50) {
HXDLIN(  85)															int location8;
HXDLIN(  85)															if (this119->useVirtualPos) {
HXDLIN(  85)																location8 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - this119->virtualY) * ( (Float)(this119->width) )) + px2) - this119->virtualX));
            															}
            															else {
HXDLIN(  85)																location8 = ::Std_obj::_hx_int(( (Float)(((py2 * this119->width) + px2)) ));
            															}
HXDLIN(  85)															int this143 = ::iterMagic::Iimg_obj::get(this119->image,location8);
HXDLIN(  85)															int this144;
HXDLIN(  85)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)																this144 = ((((((this143 >> 24) & 255) << 24) | ((this143 & 255) << 16)) | (((this143 >> 8) & 255) << 8)) | ((this143 >> 16) & 255));
            															}
            															else {
HXDLIN(  85)																this144 = this143;
            															}
HXDLIN(  85)															Float a113;
HXDLIN(  85)															int this145 = ((this144 >> 24) & 255);
HXDLIN(  85)															if ((this145 == 0)) {
HXDLIN(  85)																a113 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																a113 = (( (Float)(this145) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float r110;
HXDLIN(  85)															int this146 = ((this144 >> 16) & 255);
HXDLIN(  85)															if ((this146 == 0)) {
HXDLIN(  85)																r110 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																r110 = (( (Float)(this146) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float g18;
HXDLIN(  85)															int this147 = ((this144 >> 8) & 255);
HXDLIN(  85)															if ((this147 == 0)) {
HXDLIN(  85)																g18 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																g18 = (( (Float)(this147) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float b115;
HXDLIN(  85)															int this148 = (this144 & 255);
HXDLIN(  85)															if ((this148 == 0)) {
HXDLIN(  85)																b115 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																b115 = (( (Float)(this148) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float a211;
HXDLIN(  85)															int this149 = ((col5 >> 24) & 255);
HXDLIN(  85)															if ((this149 == 0)) {
HXDLIN(  85)																a211 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																a211 = (( (Float)(this149) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float r28;
HXDLIN(  85)															int this150 = ((col5 >> 16) & 255);
HXDLIN(  85)															if ((this150 == 0)) {
HXDLIN(  85)																r28 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																r28 = (( (Float)(this150) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float g28;
HXDLIN(  85)															int this151 = ((col5 >> 8) & 255);
HXDLIN(  85)															if ((this151 == 0)) {
HXDLIN(  85)																g28 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																g28 = (( (Float)(this151) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float b213;
HXDLIN(  85)															int this152 = (col5 & 255);
HXDLIN(  85)															if ((this152 == 0)) {
HXDLIN(  85)																b213 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																b213 = (( (Float)(this152) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float a310 = (a113 * (( (Float)(1) ) - a211));
HXDLIN(  85)															int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a310) + (r28 * a211))));
HXDLIN(  85)															int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a310) + (g28 * a211))));
HXDLIN(  85)															int b44 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a310) + (b213 * a211))));
HXDLIN(  85)															int a40 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a211)));
HXDLIN(  85)															int blended8 = ((((a40 << 24) | (r20 << 16)) | (g10 << 8)) | b44);
HXDLIN(  85)															{
HXDLIN(  85)																int _hx_tmp51;
HXDLIN(  85)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)																	_hx_tmp51 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            																}
            																else {
HXDLIN(  85)																	_hx_tmp51 = blended8;
            																}
HXDLIN(  85)																::iterMagic::Iimg_obj::set(this119->image,location8,_hx_tmp51);
            															}
            														}
            														else {
HXDLIN(  85)															::Dynamic this153 = this119->image;
HXDLIN(  85)															int index23;
HXDLIN(  85)															if (this119->useVirtualPos) {
HXDLIN(  85)																index23 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - this119->virtualY) * ( (Float)(this119->width) )) + px2) - this119->virtualX));
            															}
            															else {
HXDLIN(  85)																index23 = ::Std_obj::_hx_int(( (Float)(((py2 * this119->width) + px2)) ));
            															}
HXDLIN(  85)															int _hx_tmp52;
HXDLIN(  85)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)																_hx_tmp52 = ((((((c24 >> 24) & 255) << 24) | ((c24 & 255) << 16)) | (((c24 >> 8) & 255) << 8)) | ((c24 >> 16) & 255));
            															}
            															else {
HXDLIN(  85)																_hx_tmp52 = c24;
            															}
HXDLIN(  85)															::iterMagic::Iimg_obj::set(this153,index23,_hx_tmp52);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  85)								 ::pi_xy::iter::IntIterStart v_yIter32;
HXDLIN(  85)								 ::pi_xy::iter::IntIterStart v_xIter32;
HXDLIN(  85)								int v_undoY2;
HXDLIN(  85)								int v_undoX2;
HXDLIN(  85)								Float v_ty2;
HXDLIN(  85)								Float v_tx2;
HXDLIN(  85)								Float v_t02;
HXDLIN(  85)								Float v_sy2;
HXDLIN(  85)								Float v_sx2;
HXDLIN(  85)								Float v_s02;
HXDLIN(  85)								Float v_A2;
HXDLIN(  85)								Float ax4 = ax3;
HXDLIN(  85)								Float ay4 = ay3;
HXDLIN(  85)								 ::pi_xy::ImageStruct v_undoImage2 = null();
HXDLIN(  85)								Float bx4 = bx3;
HXDLIN(  85)								Float by4 = by3;
HXDLIN(  85)								Float cx4 = dx3;
HXDLIN(  85)								Float cy4 = dy3;
HXDLIN(  85)								bool adjustWinding2 = (((((ax4 * by4) - (bx4 * ay4)) + ((bx4 * cy4) - (cx4 * by4))) + ((cx4 * ay4) - (ax4 * cy4))) > 0);
HXDLIN(  85)								if (!(adjustWinding2)) {
HXDLIN(  85)									Float bx_2 = bx4;
HXDLIN(  85)									Float by_2 = by4;
HXLINE(  24)									bx4 = cx4;
HXLINE(  25)									by4 = cy4;
HXLINE(  26)									cx4 = bx_2;
HXLINE(  27)									cy4 = by_2;
            								}
HXLINE(  85)								Float v_ax2 = ax4;
HXDLIN(  85)								Float v_ay2 = ay4;
HXDLIN(  85)								Float v_bx2 = bx4;
HXDLIN(  85)								Float v_by2 = by4;
HXDLIN(  85)								Float v_cx2 = cx4;
HXDLIN(  85)								Float v_cy2 = cy4;
HXDLIN(  85)								bool v_preCalculated2 = true;
HXDLIN(  85)								{
HXDLIN(  85)									v_s02 = ((v_ay2 * v_cx2) - (v_ax2 * v_cy2));
HXDLIN(  85)									v_sx2 = (v_cy2 - v_ay2);
HXDLIN(  85)									v_sy2 = (v_ax2 - v_cx2);
HXDLIN(  85)									v_t02 = ((v_ax2 * v_by2) - (v_ay2 * v_bx2));
HXDLIN(  85)									v_tx2 = (v_ay2 - v_by2);
HXDLIN(  85)									v_ty2 = (v_bx2 - v_ax2);
HXDLIN(  85)									v_A2 = ((((-(v_by2) * v_cx2) + (v_ay2 * (-(v_bx2) + v_cx2))) + (v_ax2 * (v_by2 - v_cy2))) + (v_bx2 * v_cy2));
HXDLIN(  85)									Float a41 = v_ax2;
HXDLIN(  85)									Float b45 = v_bx2;
HXDLIN(  85)									Float c25 = v_cx2;
HXDLIN(  85)									if ((a41 > b45)) {
HXDLIN(  85)										if ((a41 > c25)) {
HXDLIN(  85)											int min24;
HXDLIN(  85)											if ((b45 > c25)) {
HXDLIN(  85)												min24 = ::Math_obj::floor(c25);
            											}
            											else {
HXDLIN(  85)												min24 = ::Math_obj::floor(b45);
            											}
HXDLIN(  85)											int ii_min50 = min24;
HXDLIN(  85)											int ii_max50 = ::Math_obj::ceil(a41);
HXDLIN(  85)											v_xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min50,ii_max50);
            										}
            										else {
HXDLIN(  85)											int ii_min51 = ::Math_obj::floor(b45);
HXDLIN(  85)											int ii_max51 = ::Math_obj::ceil(c25);
HXDLIN(  85)											v_xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min51,ii_max51);
            										}
            									}
            									else {
HXDLIN(  85)										if ((b45 > c25)) {
HXDLIN(  85)											int min25;
HXDLIN(  85)											if ((a41 > c25)) {
HXDLIN(  85)												min25 = ::Math_obj::floor(c25);
            											}
            											else {
HXDLIN(  85)												min25 = ::Math_obj::ceil(a41);
            											}
HXDLIN(  85)											int ii_min52 = min25;
HXDLIN(  85)											int ii_max52 = ::Math_obj::ceil(b45);
HXDLIN(  85)											v_xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min52,ii_max52);
            										}
            										else {
HXDLIN(  85)											int ii_min53 = ::Math_obj::floor(a41);
HXDLIN(  85)											int ii_max53 = ::Math_obj::ceil(c25);
HXDLIN(  85)											v_xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min53,ii_max53);
            										}
            									}
HXDLIN(  85)									Float a42 = v_ay2;
HXDLIN(  85)									Float b46 = v_by2;
HXDLIN(  85)									Float c26 = v_cy2;
HXDLIN(  85)									if ((a42 > b46)) {
HXDLIN(  85)										if ((a42 > c26)) {
HXDLIN(  85)											int min26;
HXDLIN(  85)											if ((b46 > c26)) {
HXDLIN(  85)												min26 = ::Math_obj::floor(c26);
            											}
            											else {
HXDLIN(  85)												min26 = ::Math_obj::floor(b46);
            											}
HXDLIN(  85)											int ii_min54 = min26;
HXDLIN(  85)											int ii_max54 = ::Math_obj::ceil(a42);
HXDLIN(  85)											v_yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min54,ii_max54);
            										}
            										else {
HXDLIN(  85)											int ii_min55 = ::Math_obj::floor(b46);
HXDLIN(  85)											int ii_max55 = ::Math_obj::ceil(c26);
HXDLIN(  85)											v_yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min55,ii_max55);
            										}
            									}
            									else {
HXDLIN(  85)										if ((b46 > c26)) {
HXDLIN(  85)											int min27;
HXDLIN(  85)											if ((a42 > c26)) {
HXDLIN(  85)												min27 = ::Math_obj::floor(c26);
            											}
            											else {
HXDLIN(  85)												min27 = ::Math_obj::ceil(a42);
            											}
HXDLIN(  85)											int ii_min56 = min27;
HXDLIN(  85)											int ii_max56 = ::Math_obj::ceil(b46);
HXDLIN(  85)											v_yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min56,ii_max56);
            										}
            										else {
HXDLIN(  85)											int ii_min57 = ::Math_obj::floor(a42);
HXDLIN(  85)											int ii_max57 = ::Math_obj::ceil(c26);
HXDLIN(  85)											v_yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min57,ii_max57);
            										}
            									}
            								}
HXDLIN(  85)								if (hasUndo2) {
HXDLIN(  85)									v_undoImage2 = undoImage6;
HXDLIN(  85)									v_undoX2 = xIter32->start;
HXDLIN(  85)									v_undoY2 = yIter32->start;
            								}
HXDLIN(  85)								Float au3 = bu3;
HXDLIN(  85)								Float av3 = bv3;
HXDLIN(  85)								Float bu5 = cu1;
HXDLIN(  85)								Float bv5 = cv1;
HXDLIN(  85)								bool hasUndo3 = false;
HXDLIN(  85)								Float temp11 = au3;
HXLINE( 422)								au3 = bu5;
HXLINE( 423)								bu5 = temp11;
HXLINE( 424)								temp11 = av3;
HXLINE( 425)								av3 = bv5;
HXLINE( 426)								bv5 = temp11;
HXLINE(  85)								Float bcx3 = (cx3 - dx3);
HXDLIN(  85)								Float bcy3 = (cy3 - dy3);
HXDLIN(  85)								Float acx3 = (bx3 - dx3);
HXDLIN(  85)								Float acy3 = (by3 - dy3);
HXDLIN(  85)								Float dot113 = ((bcx3 * bcx3) + (bcy3 * bcy3));
HXDLIN(  85)								Float dot123 = ((bcx3 * acx3) + (bcy3 * acy3));
HXDLIN(  85)								Float dot223 = ((acx3 * acx3) + (acy3 * acy3));
HXDLIN(  85)								Float denom13 = (( (Float)(1) ) / ((dot113 * dot223) - (dot123 * dot123)));
HXDLIN(  85)								 ::pi_xy::iter::IntIterStart xIter33;
HXDLIN(  85)								if ((bx3 > cx3)) {
HXDLIN(  85)									if ((bx3 > dx3)) {
HXDLIN(  85)										int min28;
HXDLIN(  85)										if ((cx3 > dx3)) {
HXDLIN(  85)											min28 = ::Math_obj::floor(dx3);
            										}
            										else {
HXDLIN(  85)											min28 = ::Math_obj::floor(cx3);
            										}
HXDLIN(  85)										int ii_min58 = min28;
HXDLIN(  85)										int ii_max58 = ::Math_obj::ceil(bx3);
HXDLIN(  85)										xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min58,ii_max58);
            									}
            									else {
HXDLIN(  85)										int ii_min59 = ::Math_obj::floor(cx3);
HXDLIN(  85)										int ii_max59 = ::Math_obj::ceil(dx3);
HXDLIN(  85)										xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min59,ii_max59);
            									}
            								}
            								else {
HXDLIN(  85)									if ((cx3 > dx3)) {
HXDLIN(  85)										int min29;
HXDLIN(  85)										if ((bx3 > dx3)) {
HXDLIN(  85)											min29 = ::Math_obj::floor(dx3);
            										}
            										else {
HXDLIN(  85)											min29 = ::Math_obj::ceil(bx3);
            										}
HXDLIN(  85)										int ii_min60 = min29;
HXDLIN(  85)										int ii_max60 = ::Math_obj::ceil(cx3);
HXDLIN(  85)										xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min60,ii_max60);
            									}
            									else {
HXDLIN(  85)										int ii_min61 = ::Math_obj::floor(bx3);
HXDLIN(  85)										int ii_max61 = ::Math_obj::ceil(dx3);
HXDLIN(  85)										xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min61,ii_max61);
            									}
            								}
HXDLIN(  85)								 ::pi_xy::iter::IntIterStart yIter33;
HXDLIN(  85)								if ((by3 > cy3)) {
HXDLIN(  85)									if ((by3 > dy3)) {
HXDLIN(  85)										int min30;
HXDLIN(  85)										if ((cy3 > dy3)) {
HXDLIN(  85)											min30 = ::Math_obj::floor(dy3);
            										}
            										else {
HXDLIN(  85)											min30 = ::Math_obj::floor(cy3);
            										}
HXDLIN(  85)										int ii_min62 = min30;
HXDLIN(  85)										int ii_max62 = ::Math_obj::ceil(by3);
HXDLIN(  85)										yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min62,ii_max62);
            									}
            									else {
HXDLIN(  85)										int ii_min63 = ::Math_obj::floor(cy3);
HXDLIN(  85)										int ii_max63 = ::Math_obj::ceil(dy3);
HXDLIN(  85)										yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min63,ii_max63);
            									}
            								}
            								else {
HXDLIN(  85)									if ((cy3 > dy3)) {
HXDLIN(  85)										int min31;
HXDLIN(  85)										if ((by3 > dy3)) {
HXDLIN(  85)											min31 = ::Math_obj::floor(dy3);
            										}
            										else {
HXDLIN(  85)											min31 = ::Math_obj::ceil(by3);
            										}
HXDLIN(  85)										int ii_min64 = min31;
HXDLIN(  85)										int ii_max64 = ::Math_obj::ceil(cy3);
HXDLIN(  85)										yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min64,ii_max64);
            									}
            									else {
HXDLIN(  85)										int ii_min65 = ::Math_obj::floor(by3);
HXDLIN(  85)										int ii_max65 = ::Math_obj::ceil(dy3);
HXDLIN(  85)										yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min65,ii_max65);
            									}
            								}
HXDLIN(  85)								 ::pi_xy::ImageStruct undoImage9 = null();
HXDLIN(  85)								if (hasUndo3) {
HXDLIN(  85)									int width6 = ((xIter33->max - xIter33->start) + 1);
HXDLIN(  85)									int height6 = ((yIter33->max - yIter33->start) + 1);
HXDLIN(  85)									 ::Dynamic imageType8 = null();
HXDLIN(  85)									 ::pi_xy::ImageStruct this154 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  85)									if (::hx::IsNull( imageType8 )) {
HXLINE(  54)										imageType8 = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE(  85)									::Dynamic undoImage10;
HXDLIN(  85)									switch((int)(( (int)(imageType8) ))){
            										case (int)0: {
HXDLIN(  85)											 ::iterMagic::BytesImg byt8 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  85)											 ::iterMagic::BytesImg b47 = byt8;
HXDLIN(  85)											{
HXDLIN(  85)												b47->width = width6;
HXDLIN(  85)												b47->height = height6;
HXDLIN(  85)												b47->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN(  85)												b47->data = ::haxe::io::Bytes_obj::alloc((b47->length * 4));
HXDLIN(  85)												{
HXDLIN(  85)													int len16 = b47->length;
HXDLIN(  85)													int w11 = 0;
HXDLIN(  85)													{
HXDLIN(  85)														int _g140 = 0;
HXDLIN(  85)														int _g141 = b47->height;
HXDLIN(  85)														while((_g140 < _g141)){
HXDLIN(  85)															_g140 = (_g140 + 1);
HXDLIN(  85)															int y23 = (_g140 - 1);
HXDLIN(  85)															{
HXDLIN(  85)																int _g142 = 0;
HXDLIN(  85)																int _g143 = b47->width;
HXDLIN(  85)																while((_g142 < _g143)){
HXDLIN(  85)																	_g142 = (_g142 + 1);
HXDLIN(  85)																	int x23 = (_g142 - 1);
HXDLIN(  85)																	{
HXDLIN(  85)																		w11 = (w11 + 1);
HXDLIN(  85)																		b47->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  85)																	{
HXDLIN(  85)																		w11 = (w11 + 1);
HXDLIN(  85)																		b47->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  85)																	{
HXDLIN(  85)																		w11 = (w11 + 1);
HXDLIN(  85)																		b47->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  85)																	{
HXDLIN(  85)																		w11 = (w11 + 1);
HXDLIN(  85)																		b47->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  85)											undoImage10 = b47;
            										}
            										break;
            										case (int)1: {
HXDLIN(  85)											 ::iterMagic::ArrIntImg arrI8 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  85)											 ::iterMagic::ArrIntImg a43 = arrI8;
HXDLIN(  85)											{
HXDLIN(  85)												a43->width = width6;
HXDLIN(  85)												a43->height = height6;
HXDLIN(  85)												a43->data = ::Array_obj< int >::__new(0);
HXDLIN(  85)												a43->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN(  85)												{
HXDLIN(  85)													int _g144 = 0;
HXDLIN(  85)													int _g145 = a43->length;
HXDLIN(  85)													while((_g144 < _g145)){
HXDLIN(  85)														_g144 = (_g144 + 1);
HXDLIN(  85)														int i54 = (_g144 - 1);
HXDLIN(  85)														a43->data[i54] = 0;
            													}
            												}
            											}
HXDLIN(  85)											undoImage10 = a43;
            										}
            										break;
            										case (int)2: {
HXDLIN(  85)											 ::iterMagic::U32ArrImg u32a8 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  85)											 ::iterMagic::U32ArrImg b48 = u32a8;
HXDLIN(  85)											{
HXDLIN(  85)												b48->width = width6;
HXDLIN(  85)												b48->height = height6;
HXDLIN(  85)												b48->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN(  85)												int size8 = (b48->length * 4);
HXDLIN(  85)												b48->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size8),0,size8);
HXDLIN(  85)												{
HXDLIN(  85)													int _g146 = 0;
HXDLIN(  85)													int _g147 = b48->length;
HXDLIN(  85)													while((_g146 < _g147)){
HXDLIN(  85)														_g146 = (_g146 + 1);
HXDLIN(  85)														int i55 = (_g146 - 1);
HXDLIN(  85)														{
HXDLIN(  85)															 ::haxe::io::ArrayBufferViewImpl this155 = b48->data;
HXDLIN(  85)															bool undoImage11;
HXDLIN(  85)															if ((i55 >= 0)) {
HXDLIN(  85)																undoImage11 = (i55 < (this155->byteLength >> 2));
            															}
            															else {
HXDLIN(  85)																undoImage11 = false;
            															}
HXDLIN(  85)															if (undoImage11) {
HXDLIN(  85)																 ::haxe::io::Bytes _this8 = this155->bytes;
HXDLIN(  85)																int pos8 = ((i55 << 2) + this155->byteOffset);
HXDLIN(  85)																_this8->b[pos8] = ( (unsigned char)(0) );
HXDLIN(  85)																_this8->b[(pos8 + 1)] = ( (unsigned char)(0) );
HXDLIN(  85)																_this8->b[(pos8 + 2)] = ( (unsigned char)(0) );
HXDLIN(  85)																_this8->b[(pos8 + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN(  85)											undoImage10 = b48;
            										}
            										break;
            										case (int)3: {
HXDLIN(  85)											 ::iterMagic::VecIntImg vec8 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  85)											 ::iterMagic::VecIntImg v17 = vec8;
HXDLIN(  85)											{
HXDLIN(  85)												v17->width = width6;
HXDLIN(  85)												v17->height = height6;
HXDLIN(  85)												v17->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN(  85)												v17->data = ::Array_obj< int >::__new(v17->length);
HXDLIN(  85)												{
HXDLIN(  85)													int _g148 = 0;
HXDLIN(  85)													int _g149 = v17->length;
HXDLIN(  85)													while((_g148 < _g149)){
HXDLIN(  85)														_g148 = (_g148 + 1);
HXDLIN(  85)														int i56 = (_g148 - 1);
HXDLIN(  85)														v17->data->__unsafe_set(i56,0);
            													}
            												}
            											}
HXDLIN(  85)											undoImage10 = v17;
            										}
            										break;
            										case (int)4: {
HXDLIN(  85)											 ::iterMagic::StackIntImg sInt8 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  85)											 ::iterMagic::StackIntImg b49 = sInt8;
HXDLIN(  85)											{
HXDLIN(  85)												b49->width = width6;
HXDLIN(  85)												b49->height = height6;
HXDLIN(  85)												b49->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN(  85)												b49->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  85)												{
HXDLIN(  85)													int len17 = b49->length;
HXDLIN(  85)													 ::haxe::ds::GenericStack_Int d8 = b49->data;
HXDLIN(  85)													if (::hx::IsNull( d8->head )) {
HXDLIN(  85)														int _g150 = 0;
HXDLIN(  85)														int _g151 = len17;
HXDLIN(  85)														while((_g150 < _g151)){
HXDLIN(  85)															_g150 = (_g150 + 1);
HXDLIN(  85)															int i57 = (_g150 - 1);
HXDLIN(  85)															d8->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d8->head);
            														}
            													}
            													else {
HXDLIN(  85)														int _g152 = 0;
HXDLIN(  85)														int _g153 = len17;
HXDLIN(  85)														while((_g152 < _g153)){
HXDLIN(  85)															_g152 = (_g152 + 1);
HXDLIN(  85)															int i58 = (_g152 - 1);
HXDLIN(  85)															{
HXDLIN(  85)																 ::haxe::ds::GenericCell_Int l8 = b49->data->head;
HXDLIN(  85)																 ::haxe::ds::GenericCell_Int prev8 = null();
HXDLIN(  85)																{
HXDLIN(  85)																	int _g154 = 0;
HXDLIN(  85)																	int _g155 = i58;
HXDLIN(  85)																	while((_g154 < _g155)){
HXDLIN(  85)																		_g154 = (_g154 + 1);
HXDLIN(  85)																		int i59 = (_g154 - 1);
HXLINE( 345)																		prev8 = l8;
HXLINE( 346)																		l8 = l8->next;
            																	}
            																}
HXLINE(  85)																if (::hx::IsNull( prev8 )) {
HXDLIN(  85)																	b49->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l8->next);
HXDLIN(  85)																	l8 = null();
            																}
            																else {
HXDLIN(  85)																	prev8->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l8->next);
HXDLIN(  85)																	l8 = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  85)											undoImage10 = b49;
            										}
            										break;
            									}
HXDLIN(  85)									this154->image = undoImage10;
HXDLIN(  85)									this154->width = width6;
HXDLIN(  85)									this154->height = height6;
HXDLIN(  85)									this154->imageType = ( (int)(imageType8) );
HXDLIN(  85)									undoImage9 = this154;
HXDLIN(  85)									{
HXDLIN(  85)										int rectLeft3 = xIter33->start;
HXDLIN(  85)										int rectTop3 = yIter33->start;
HXDLIN(  85)										int rectRight3 = xIter33->max;
HXDLIN(  85)										bool forceClear3 = false;
HXDLIN(  85)										{
HXDLIN(  85)											int _g156 = rectTop3;
HXDLIN(  85)											int _g157 = yIter33->max;
HXDLIN(  85)											while((_g156 < _g157)){
HXDLIN(  85)												_g156 = (_g156 + 1);
HXDLIN(  85)												int dy5 = (_g156 - 1);
HXDLIN(  85)												{
HXDLIN(  85)													int _g158 = rectLeft3;
HXDLIN(  85)													int _g159 = rectRight3;
HXDLIN(  85)													while((_g158 < _g159)){
HXDLIN(  85)														_g158 = (_g158 + 1);
HXDLIN(  85)														int dx5 = (_g158 - 1);
HXDLIN(  85)														::Dynamic this156 = this119->image;
HXDLIN(  85)														int index24;
HXDLIN(  85)														if (this119->useVirtualPos) {
HXDLIN(  85)															index24 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this119->virtualY) * ( (Float)(this119->width) )) + dx5) - this119->virtualX));
            														}
            														else {
HXDLIN(  85)															index24 = ::Std_obj::_hx_int(( (Float)(((dy5 * this119->width) + dx5)) ));
            														}
HXDLIN(  85)														int c27 = ::iterMagic::Iimg_obj::get(this156,index24);
HXDLIN(  85)														int col6;
HXDLIN(  85)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)															col6 = ((((((c27 >> 24) & 255) << 24) | ((c27 & 255) << 16)) | (((c27 >> 8) & 255) << 8)) | ((c27 >> 16) & 255));
            														}
            														else {
HXDLIN(  85)															col6 = c27;
            														}
HXDLIN(  85)														bool _hx_tmp53;
HXDLIN(  85)														if (this119->useMask) {
HXDLIN(  85)															_hx_tmp53 = ::hx::IsNotNull( this119->mask );
            														}
            														else {
HXDLIN(  85)															_hx_tmp53 = false;
            														}
HXDLIN(  85)														if (_hx_tmp53) {
HXDLIN(  85)															 ::pi_xy::ImageStruct this157 = this119->mask;
HXDLIN(  85)															::Dynamic this158 = this157->image;
HXDLIN(  85)															int index25;
HXDLIN(  85)															if (this157->useVirtualPos) {
HXDLIN(  85)																index25 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this157->virtualY) * ( (Float)(this157->width) )) + dx5) - this157->virtualX));
            															}
            															else {
HXDLIN(  85)																index25 = ::Std_obj::_hx_int(( (Float)(((dy5 * this157->width) + dx5)) ));
            															}
HXDLIN(  85)															int c28 = ::iterMagic::Iimg_obj::get(this158,index25);
HXDLIN(  85)															int v18;
HXDLIN(  85)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)																v18 = ((((((c28 >> 24) & 255) << 24) | ((c28 & 255) << 16)) | (((c28 >> 8) & 255) << 8)) | ((c28 >> 16) & 255));
            															}
            															else {
HXDLIN(  85)																v18 = c28;
            															}
HXDLIN(  85)															int maskPixel3 = v18;
HXDLIN(  85)															int this159 = col6;
HXDLIN(  85)															if ((maskPixel3 == 0)) {
HXDLIN(  85)																col6 = this159;
            															}
            															else {
HXDLIN(  85)																Float m03;
HXDLIN(  85)																int this160 = ((maskPixel3 >> 24) & 255);
HXDLIN(  85)																if ((this160 == 0)) {
HXDLIN(  85)																	m03 = ((Float)0.);
            																}
            																else {
HXDLIN(  85)																	m03 = (( (Float)(this160) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float m13;
HXDLIN(  85)																int this161 = ((maskPixel3 >> 16) & 255);
HXDLIN(  85)																if ((this161 == 0)) {
HXDLIN(  85)																	m13 = ((Float)0.);
            																}
            																else {
HXDLIN(  85)																	m13 = (( (Float)(this161) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float m23;
HXDLIN(  85)																int this162 = ((maskPixel3 >> 8) & 255);
HXDLIN(  85)																if ((this162 == 0)) {
HXDLIN(  85)																	m23 = ((Float)0.);
            																}
            																else {
HXDLIN(  85)																	m23 = (( (Float)(this162) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float m33;
HXDLIN(  85)																int this163 = (maskPixel3 & 255);
HXDLIN(  85)																if ((this163 == 0)) {
HXDLIN(  85)																	m33 = ((Float)0.);
            																}
            																else {
HXDLIN(  85)																	m33 = (( (Float)(this163) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																int ch03 = ::Std_obj::_hx_int(((((Float)1.) - m03) * ( (Float)(((this159 >> 24) & 255)) )));
HXDLIN(  85)																int ch13 = ::Std_obj::_hx_int(((((Float)1.) - m13) * ( (Float)(((this159 >> 16) & 255)) )));
HXDLIN(  85)																int ch23 = ::Std_obj::_hx_int(((((Float)1.) - m23) * ( (Float)(((this159 >> 8) & 255)) )));
HXDLIN(  85)																int ch33 = ::Std_obj::_hx_int(((((Float)1.) - m33) * ( (Float)((this159 & 255)) )));
HXDLIN(  85)																col6 = ((((::Math_obj::round((( (Float)(ch03) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch13) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch23) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch33) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  85)														if ((col6 != 0)) {
HXDLIN(  85)															int x24 = (dx5 - rectLeft3);
HXDLIN(  85)															int y24 = (dy5 - rectTop3);
HXDLIN(  85)															int c29 = col6;
HXDLIN(  85)															bool _hx_tmp54;
HXDLIN(  85)															if ((((c29 >> 24) & 255) < 254)) {
HXDLIN(  85)																_hx_tmp54 = undoImage9->transparent;
            															}
            															else {
HXDLIN(  85)																_hx_tmp54 = false;
            															}
HXDLIN(  85)															if (_hx_tmp54) {
HXDLIN(  85)																int location9;
HXDLIN(  85)																if (undoImage9->useVirtualPos) {
HXDLIN(  85)																	location9 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x24) - undoImage9->virtualX));
            																}
            																else {
HXDLIN(  85)																	location9 = ::Std_obj::_hx_int(( (Float)(((y24 * undoImage9->width) + x24)) ));
            																}
HXDLIN(  85)																int this164 = ::iterMagic::Iimg_obj::get(undoImage9->image,location9);
HXDLIN(  85)																int this165;
HXDLIN(  85)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)																	this165 = ((((((this164 >> 24) & 255) << 24) | ((this164 & 255) << 16)) | (((this164 >> 8) & 255) << 8)) | ((this164 >> 16) & 255));
            																}
            																else {
HXDLIN(  85)																	this165 = this164;
            																}
HXDLIN(  85)																Float a114;
HXDLIN(  85)																int this166 = ((this165 >> 24) & 255);
HXDLIN(  85)																if ((this166 == 0)) {
HXDLIN(  85)																	a114 = ((Float)0.);
            																}
            																else {
HXDLIN(  85)																	a114 = (( (Float)(this166) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float r111;
HXDLIN(  85)																int this167 = ((this165 >> 16) & 255);
HXDLIN(  85)																if ((this167 == 0)) {
HXDLIN(  85)																	r111 = ((Float)0.);
            																}
            																else {
HXDLIN(  85)																	r111 = (( (Float)(this167) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float g19;
HXDLIN(  85)																int this168 = ((this165 >> 8) & 255);
HXDLIN(  85)																if ((this168 == 0)) {
HXDLIN(  85)																	g19 = ((Float)0.);
            																}
            																else {
HXDLIN(  85)																	g19 = (( (Float)(this168) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float b116;
HXDLIN(  85)																int this169 = (this165 & 255);
HXDLIN(  85)																if ((this169 == 0)) {
HXDLIN(  85)																	b116 = ((Float)0.);
            																}
            																else {
HXDLIN(  85)																	b116 = (( (Float)(this169) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float a212;
HXDLIN(  85)																int this170 = ((col6 >> 24) & 255);
HXDLIN(  85)																if ((this170 == 0)) {
HXDLIN(  85)																	a212 = ((Float)0.);
            																}
            																else {
HXDLIN(  85)																	a212 = (( (Float)(this170) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float r29;
HXDLIN(  85)																int this171 = ((col6 >> 16) & 255);
HXDLIN(  85)																if ((this171 == 0)) {
HXDLIN(  85)																	r29 = ((Float)0.);
            																}
            																else {
HXDLIN(  85)																	r29 = (( (Float)(this171) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float g29;
HXDLIN(  85)																int this172 = ((col6 >> 8) & 255);
HXDLIN(  85)																if ((this172 == 0)) {
HXDLIN(  85)																	g29 = ((Float)0.);
            																}
            																else {
HXDLIN(  85)																	g29 = (( (Float)(this172) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float b214;
HXDLIN(  85)																int this173 = (col6 & 255);
HXDLIN(  85)																if ((this173 == 0)) {
HXDLIN(  85)																	b214 = ((Float)0.);
            																}
            																else {
HXDLIN(  85)																	b214 = (( (Float)(this173) ) / ( (Float)(255) ));
            																}
HXDLIN(  85)																Float a311 = (a114 * (( (Float)(1) ) - a212));
HXDLIN(  85)																int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r111 * a311) + (r29 * a212))));
HXDLIN(  85)																int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a311) + (g29 * a212))));
HXDLIN(  85)																int b50 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a311) + (b214 * a212))));
HXDLIN(  85)																int a44 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a212)));
HXDLIN(  85)																int blended9 = ((((a44 << 24) | (r30 << 16)) | (g20 << 8)) | b50);
HXDLIN(  85)																{
HXDLIN(  85)																	int _hx_tmp55;
HXDLIN(  85)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)																		_hx_tmp55 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            																	}
            																	else {
HXDLIN(  85)																		_hx_tmp55 = blended9;
            																	}
HXDLIN(  85)																	::iterMagic::Iimg_obj::set(undoImage9->image,location9,_hx_tmp55);
            																}
            															}
            															else {
HXDLIN(  85)																::Dynamic this174 = undoImage9->image;
HXDLIN(  85)																int index26;
HXDLIN(  85)																if (undoImage9->useVirtualPos) {
HXDLIN(  85)																	index26 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x24) - undoImage9->virtualX));
            																}
            																else {
HXDLIN(  85)																	index26 = ::Std_obj::_hx_int(( (Float)(((y24 * undoImage9->width) + x24)) ));
            																}
HXDLIN(  85)																int _hx_tmp56;
HXDLIN(  85)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)																	_hx_tmp56 = ((((((c29 >> 24) & 255) << 24) | ((c29 & 255) << 16)) | (((c29 >> 8) & 255) << 8)) | ((c29 >> 16) & 255));
            																}
            																else {
HXDLIN(  85)																	_hx_tmp56 = c29;
            																}
HXDLIN(  85)																::iterMagic::Iimg_obj::set(this174,index26,_hx_tmp56);
            															}
            														}
            														else {
HXDLIN(  85)															if (forceClear3) {
HXDLIN(  85)																::Dynamic this175 = undoImage9->image;
HXDLIN(  85)																int x25 = (dx5 - rectLeft3);
HXDLIN(  85)																int y25 = (dy5 - rectTop3);
HXDLIN(  85)																int index27;
HXDLIN(  85)																if (undoImage9->useVirtualPos) {
HXDLIN(  85)																	index27 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x25) - undoImage9->virtualX));
            																}
            																else {
HXDLIN(  85)																	index27 = ::Std_obj::_hx_int(( (Float)(((y25 * undoImage9->width) + x25)) ));
            																}
HXDLIN(  85)																::iterMagic::Iimg_obj::set(this175,index27,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  85)								{
HXDLIN(  85)									int _g_min6 = xIter33->start;
HXDLIN(  85)									int _g_max6 = xIter33->max;
HXDLIN(  85)									while((_g_min6 < _g_max6)){
HXDLIN(  85)										_g_min6 = (_g_min6 + 1);
HXDLIN(  85)										int px3 = (_g_min6 - 1);
HXDLIN(  85)										Float pcx3 = (( (Float)(px3) ) - dx3);
HXDLIN(  85)										{
HXDLIN(  85)											int _g_min7 = yIter33->start;
HXDLIN(  85)											int _g_max7 = yIter33->max;
HXDLIN(  85)											while((_g_min7 < _g_max7)){
HXDLIN(  85)												_g_min7 = (_g_min7 + 1);
HXDLIN(  85)												int py3 = (_g_min7 - 1);
HXDLIN(  85)												Float pcy3 = (( (Float)(py3) ) - dy3);
HXDLIN(  85)												Float dot313 = ((pcx3 * bcx3) + (pcy3 * bcy3));
HXDLIN(  85)												Float dot323 = ((pcx3 * acx3) + (pcy3 * acy3));
HXDLIN(  85)												Float ratioA3 = (((dot223 * dot313) - (dot123 * dot323)) * denom13);
HXDLIN(  85)												Float ratioB3 = (((dot113 * dot323) - (dot123 * dot313)) * denom13);
HXDLIN(  85)												Float ratioC3 = ((((Float)1.0) - ratioB3) - ratioA3);
HXDLIN(  85)												bool _hx_tmp57;
HXDLIN(  85)												bool _hx_tmp58;
HXDLIN(  85)												if ((ratioA3 >= 0)) {
HXDLIN(  85)													_hx_tmp58 = (ratioB3 >= 0);
            												}
            												else {
HXDLIN(  85)													_hx_tmp58 = false;
            												}
HXDLIN(  85)												if (_hx_tmp58) {
HXDLIN(  85)													_hx_tmp57 = (ratioC3 >= 0);
            												}
            												else {
HXDLIN(  85)													_hx_tmp57 = false;
            												}
HXDLIN(  85)												if (_hx_tmp57) {
HXDLIN(  85)													Float u3 = (((au3 * ratioA3) + (bu5 * ratioB3)) + (du1 * ratioC3));
HXDLIN(  85)													Float v19 = (((av3 * ratioA3) + (bv5 * ratioB3)) + (dv1 * ratioC3));
HXDLIN(  85)													int x26 = ::Std_obj::_hx_int(((u3 * win_width1) + win_x1));
HXDLIN(  85)													int y26 = ::Std_obj::_hx_int(((v19 * win_height1) + win_y1));
HXDLIN(  85)													::Dynamic this176 = this116->image;
HXDLIN(  85)													int index28;
HXDLIN(  85)													if (this116->useVirtualPos) {
HXDLIN(  85)														index28 = ::Std_obj::_hx_int(((((( (Float)(y26) ) - this116->virtualY) * ( (Float)(this116->width) )) + x26) - this116->virtualX));
            													}
            													else {
HXDLIN(  85)														index28 = ::Std_obj::_hx_int(( (Float)(((y26 * this116->width) + x26)) ));
            													}
HXDLIN(  85)													int c30 = ::iterMagic::Iimg_obj::get(this176,index28);
HXDLIN(  85)													int col7;
HXDLIN(  85)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)														col7 = ((((((c30 >> 24) & 255) << 24) | ((c30 & 255) << 16)) | (((c30 >> 8) & 255) << 8)) | ((c30 >> 16) & 255));
            													}
            													else {
HXDLIN(  85)														col7 = c30;
            													}
HXDLIN(  85)													{
HXDLIN(  85)														int c31 = col7;
HXDLIN(  85)														bool _hx_tmp59;
HXDLIN(  85)														if ((((c31 >> 24) & 255) < 254)) {
HXDLIN(  85)															_hx_tmp59 = this119->transparent;
            														}
            														else {
HXDLIN(  85)															_hx_tmp59 = false;
            														}
HXDLIN(  85)														if (_hx_tmp59) {
HXDLIN(  85)															int location10;
HXDLIN(  85)															if (this119->useVirtualPos) {
HXDLIN(  85)																location10 = ::Std_obj::_hx_int(((((( (Float)(py3) ) - this119->virtualY) * ( (Float)(this119->width) )) + px3) - this119->virtualX));
            															}
            															else {
HXDLIN(  85)																location10 = ::Std_obj::_hx_int(( (Float)(((py3 * this119->width) + px3)) ));
            															}
HXDLIN(  85)															int this177 = ::iterMagic::Iimg_obj::get(this119->image,location10);
HXDLIN(  85)															int this178;
HXDLIN(  85)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)																this178 = ((((((this177 >> 24) & 255) << 24) | ((this177 & 255) << 16)) | (((this177 >> 8) & 255) << 8)) | ((this177 >> 16) & 255));
            															}
            															else {
HXDLIN(  85)																this178 = this177;
            															}
HXDLIN(  85)															Float a115;
HXDLIN(  85)															int this179 = ((this178 >> 24) & 255);
HXDLIN(  85)															if ((this179 == 0)) {
HXDLIN(  85)																a115 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																a115 = (( (Float)(this179) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float r112;
HXDLIN(  85)															int this180 = ((this178 >> 16) & 255);
HXDLIN(  85)															if ((this180 == 0)) {
HXDLIN(  85)																r112 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																r112 = (( (Float)(this180) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float g110;
HXDLIN(  85)															int this181 = ((this178 >> 8) & 255);
HXDLIN(  85)															if ((this181 == 0)) {
HXDLIN(  85)																g110 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																g110 = (( (Float)(this181) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float b117;
HXDLIN(  85)															int this182 = (this178 & 255);
HXDLIN(  85)															if ((this182 == 0)) {
HXDLIN(  85)																b117 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																b117 = (( (Float)(this182) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float a213;
HXDLIN(  85)															int this183 = ((col7 >> 24) & 255);
HXDLIN(  85)															if ((this183 == 0)) {
HXDLIN(  85)																a213 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																a213 = (( (Float)(this183) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float r210;
HXDLIN(  85)															int this184 = ((col7 >> 16) & 255);
HXDLIN(  85)															if ((this184 == 0)) {
HXDLIN(  85)																r210 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																r210 = (( (Float)(this184) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float g210;
HXDLIN(  85)															int this185 = ((col7 >> 8) & 255);
HXDLIN(  85)															if ((this185 == 0)) {
HXDLIN(  85)																g210 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																g210 = (( (Float)(this185) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float b215;
HXDLIN(  85)															int this186 = (col7 & 255);
HXDLIN(  85)															if ((this186 == 0)) {
HXDLIN(  85)																b215 = ((Float)0.);
            															}
            															else {
HXDLIN(  85)																b215 = (( (Float)(this186) ) / ( (Float)(255) ));
            															}
HXDLIN(  85)															Float a312 = (a115 * (( (Float)(1) ) - a213));
HXDLIN(  85)															int r31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r112 * a312) + (r210 * a213))));
HXDLIN(  85)															int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a312) + (g210 * a213))));
HXDLIN(  85)															int b51 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b117 * a312) + (b215 * a213))));
HXDLIN(  85)															int a45 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a213)));
HXDLIN(  85)															int blended10 = ((((a45 << 24) | (r31 << 16)) | (g30 << 8)) | b51);
HXDLIN(  85)															{
HXDLIN(  85)																int _hx_tmp60;
HXDLIN(  85)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)																	_hx_tmp60 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            																}
            																else {
HXDLIN(  85)																	_hx_tmp60 = blended10;
            																}
HXDLIN(  85)																::iterMagic::Iimg_obj::set(this119->image,location10,_hx_tmp60);
            															}
            														}
            														else {
HXDLIN(  85)															::Dynamic this187 = this119->image;
HXDLIN(  85)															int index29;
HXDLIN(  85)															if (this119->useVirtualPos) {
HXDLIN(  85)																index29 = ::Std_obj::_hx_int(((((( (Float)(py3) ) - this119->virtualY) * ( (Float)(this119->width) )) + px3) - this119->virtualX));
            															}
            															else {
HXDLIN(  85)																index29 = ::Std_obj::_hx_int(( (Float)(((py3 * this119->width) + px3)) ));
            															}
HXDLIN(  85)															int _hx_tmp61;
HXDLIN(  85)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  85)																_hx_tmp61 = ((((((c31 >> 24) & 255) << 24) | ((c31 & 255) << 16)) | (((c31 >> 8) & 255) << 8)) | ((c31 >> 16) & 255));
            															}
            															else {
HXDLIN(  85)																_hx_tmp61 = c31;
            															}
HXDLIN(  85)															::iterMagic::Iimg_obj::set(this187,index29,_hx_tmp61);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  85)								 ::pi_xy::iter::IntIterStart v_yIter33;
HXDLIN(  85)								 ::pi_xy::iter::IntIterStart v_xIter33;
HXDLIN(  85)								int v_undoY3;
HXDLIN(  85)								int v_undoX3;
HXDLIN(  85)								Float v_ty3;
HXDLIN(  85)								Float v_tx3;
HXDLIN(  85)								Float v_t03;
HXDLIN(  85)								Float v_sy3;
HXDLIN(  85)								Float v_sx3;
HXDLIN(  85)								Float v_s03;
HXDLIN(  85)								Float v_A3;
HXDLIN(  85)								Float ax5 = bx3;
HXDLIN(  85)								Float ay5 = by3;
HXDLIN(  85)								 ::pi_xy::ImageStruct v_undoImage3 = null();
HXDLIN(  85)								Float bx5 = cx3;
HXDLIN(  85)								Float by5 = cy3;
HXDLIN(  85)								Float cx5 = dx3;
HXDLIN(  85)								Float cy5 = dy3;
HXDLIN(  85)								bool adjustWinding3 = (((((ax5 * by5) - (bx5 * ay5)) + ((bx5 * cy5) - (cx5 * by5))) + ((cx5 * ay5) - (ax5 * cy5))) > 0);
HXDLIN(  85)								if (!(adjustWinding3)) {
HXDLIN(  85)									Float bx_3 = bx5;
HXDLIN(  85)									Float by_3 = by5;
HXLINE(  24)									bx5 = cx5;
HXLINE(  25)									by5 = cy5;
HXLINE(  26)									cx5 = bx_3;
HXLINE(  27)									cy5 = by_3;
            								}
HXLINE(  85)								Float v_ax3 = ax5;
HXDLIN(  85)								Float v_ay3 = ay5;
HXDLIN(  85)								Float v_bx3 = bx5;
HXDLIN(  85)								Float v_by3 = by5;
HXDLIN(  85)								Float v_cx3 = cx5;
HXDLIN(  85)								Float v_cy3 = cy5;
HXDLIN(  85)								bool v_preCalculated3 = true;
HXDLIN(  85)								{
HXDLIN(  85)									v_s03 = ((v_ay3 * v_cx3) - (v_ax3 * v_cy3));
HXDLIN(  85)									v_sx3 = (v_cy3 - v_ay3);
HXDLIN(  85)									v_sy3 = (v_ax3 - v_cx3);
HXDLIN(  85)									v_t03 = ((v_ax3 * v_by3) - (v_ay3 * v_bx3));
HXDLIN(  85)									v_tx3 = (v_ay3 - v_by3);
HXDLIN(  85)									v_ty3 = (v_bx3 - v_ax3);
HXDLIN(  85)									v_A3 = ((((-(v_by3) * v_cx3) + (v_ay3 * (-(v_bx3) + v_cx3))) + (v_ax3 * (v_by3 - v_cy3))) + (v_bx3 * v_cy3));
HXDLIN(  85)									Float a46 = v_ax3;
HXDLIN(  85)									Float b52 = v_bx3;
HXDLIN(  85)									Float c32 = v_cx3;
HXDLIN(  85)									if ((a46 > b52)) {
HXDLIN(  85)										if ((a46 > c32)) {
HXDLIN(  85)											int min32;
HXDLIN(  85)											if ((b52 > c32)) {
HXDLIN(  85)												min32 = ::Math_obj::floor(c32);
            											}
            											else {
HXDLIN(  85)												min32 = ::Math_obj::floor(b52);
            											}
HXDLIN(  85)											int ii_min66 = min32;
HXDLIN(  85)											int ii_max66 = ::Math_obj::ceil(a46);
HXDLIN(  85)											v_xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min66,ii_max66);
            										}
            										else {
HXDLIN(  85)											int ii_min67 = ::Math_obj::floor(b52);
HXDLIN(  85)											int ii_max67 = ::Math_obj::ceil(c32);
HXDLIN(  85)											v_xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min67,ii_max67);
            										}
            									}
            									else {
HXDLIN(  85)										if ((b52 > c32)) {
HXDLIN(  85)											int min33;
HXDLIN(  85)											if ((a46 > c32)) {
HXDLIN(  85)												min33 = ::Math_obj::floor(c32);
            											}
            											else {
HXDLIN(  85)												min33 = ::Math_obj::ceil(a46);
            											}
HXDLIN(  85)											int ii_min68 = min33;
HXDLIN(  85)											int ii_max68 = ::Math_obj::ceil(b52);
HXDLIN(  85)											v_xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min68,ii_max68);
            										}
            										else {
HXDLIN(  85)											int ii_min69 = ::Math_obj::floor(a46);
HXDLIN(  85)											int ii_max69 = ::Math_obj::ceil(c32);
HXDLIN(  85)											v_xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min69,ii_max69);
            										}
            									}
HXDLIN(  85)									Float a47 = v_ay3;
HXDLIN(  85)									Float b53 = v_by3;
HXDLIN(  85)									Float c33 = v_cy3;
HXDLIN(  85)									if ((a47 > b53)) {
HXDLIN(  85)										if ((a47 > c33)) {
HXDLIN(  85)											int min34;
HXDLIN(  85)											if ((b53 > c33)) {
HXDLIN(  85)												min34 = ::Math_obj::floor(c33);
            											}
            											else {
HXDLIN(  85)												min34 = ::Math_obj::floor(b53);
            											}
HXDLIN(  85)											int ii_min70 = min34;
HXDLIN(  85)											int ii_max70 = ::Math_obj::ceil(a47);
HXDLIN(  85)											v_yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min70,ii_max70);
            										}
            										else {
HXDLIN(  85)											int ii_min71 = ::Math_obj::floor(b53);
HXDLIN(  85)											int ii_max71 = ::Math_obj::ceil(c33);
HXDLIN(  85)											v_yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min71,ii_max71);
            										}
            									}
            									else {
HXDLIN(  85)										if ((b53 > c33)) {
HXDLIN(  85)											int min35;
HXDLIN(  85)											if ((a47 > c33)) {
HXDLIN(  85)												min35 = ::Math_obj::floor(c33);
            											}
            											else {
HXDLIN(  85)												min35 = ::Math_obj::ceil(a47);
            											}
HXDLIN(  85)											int ii_min72 = min35;
HXDLIN(  85)											int ii_max72 = ::Math_obj::ceil(b53);
HXDLIN(  85)											v_yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min72,ii_max72);
            										}
            										else {
HXDLIN(  85)											int ii_min73 = ::Math_obj::floor(a47);
HXDLIN(  85)											int ii_max73 = ::Math_obj::ceil(c33);
HXDLIN(  85)											v_yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min73,ii_max73);
            										}
            									}
            								}
HXDLIN(  85)								if (hasUndo3) {
HXDLIN(  85)									v_undoImage3 = undoImage9;
HXDLIN(  85)									v_undoX3 = xIter33->start;
HXDLIN(  85)									v_undoY3 = yIter33->start;
            								}
            							}
            						}
HXDLIN(  85)						bool _hx_tmp62;
HXDLIN(  85)						if (::hx::IsNotNull( nextImage4->mask )) {
HXDLIN(  85)							_hx_tmp62 = includeMask;
            						}
            						else {
HXDLIN(  85)							_hx_tmp62 = false;
            						}
HXDLIN(  85)						if (_hx_tmp62) {
HXDLIN(  85)							 ::pi_xy::ImageStruct v20 = ::pi_xy::imageAbstracts::_TransformImage::TransformImage_Impl__obj::rotate(this116->mask,theta1,centreX2,centreY2,this116->mask->transparent,includeMask);
HXDLIN(  85)							nextImage4->useMask = true;
HXDLIN(  85)							nextImage4->mask = v20;
            						}
HXDLIN(  85)						 ::pi_xy::ImageStruct v21 = nextImage4;
HXDLIN(  85)						nextImage3->useMask = true;
HXDLIN(  85)						nextImage3->mask = v21;
            					}
HXDLIN(  85)					return nextImage3;
            				}
            			}
            		}
HXDLIN(  85)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(TransformImage_Impl__obj,rotateClockwiseRadians,return )

 ::pi_xy::ImageStruct TransformImage_Impl__obj::rotate( ::pi_xy::ImageStruct this1,Float theta,::hx::Null< Float >  __o_centreX,::hx::Null< Float >  __o_centreY,::hx::Null< bool >  __o_transparent,::hx::Null< bool >  __o_includeMask){
            		Float centreX = __o_centreX.Default(((Float)0.));
            		Float centreY = __o_centreY.Default(((Float)0.));
            		bool transparent = __o_transparent.Default(false);
            		bool includeMask = __o_includeMask.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_68d25436a32dba6f_93_rotate)
HXDLIN(  93)		Float centreX1 = centreX;
HXDLIN(  93)		Float centreY1 = centreY;
HXDLIN(  93)		Float ax = ((Float)0.);
HXDLIN(  93)		Float ay = ((Float)0.);
HXDLIN(  93)		if ((centreX1 != ((Float)0.))) {
HXLINE( 173)			centreX1 = ((( (Float)(this1->width) ) / ( (Float)(2) )) + centreX1);
HXLINE(  93)			ax = (ax - centreX1);
            		}
HXDLIN(  93)		if ((centreY1 != ((Float)0.))) {
HXLINE( 177)			centreY1 = ((( (Float)(this1->height) ) / ( (Float)(2) )) + centreY1);
HXLINE(  93)			ay = (ay - centreY1);
            		}
HXDLIN(  93)		Float bx = (ax + this1->width);
HXDLIN(  93)		Float by = ay;
HXDLIN(  93)		Float cx = bx;
HXDLIN(  93)		Float cy = (ay + this1->height);
HXDLIN(  93)		Float dx = ax;
HXDLIN(  93)		Float dy = cy;
HXDLIN(  93)		Float sin = ::Math_obj::sin(theta);
HXDLIN(  93)		Float cos = ::Math_obj::cos(theta);
HXDLIN(  93)		Float temp = ax;
HXLINE( 189)		ax = ((temp * cos) - (ay * sin));
HXLINE( 190)		ay = ((ay * cos) + (temp * sin));
HXLINE(  93)		Float temp1 = bx;
HXLINE( 192)		bx = ((temp1 * cos) - (by * sin));
HXLINE( 193)		by = ((by * cos) + (temp1 * sin));
HXLINE(  93)		Float temp2 = cx;
HXLINE( 195)		cx = ((temp2 * cos) - (cy * sin));
HXLINE( 196)		cy = ((cy * cos) + (temp2 * sin));
HXLINE(  93)		Float temp3 = dx;
HXLINE( 198)		dx = ((temp3 * cos) - (dy * sin));
HXLINE( 199)		dy = ((dy * cos) + (temp3 * sin));
HXLINE(  93)		if ((centreX1 != ((Float)0.))) {
HXDLIN(  93)			ax = (ax + centreX1);
HXDLIN(  93)			bx = (bx + centreX1);
HXDLIN(  93)			cx = (cx + centreX1);
HXDLIN(  93)			dx = (dx + centreX1);
            		}
HXDLIN(  93)		if ((centreY1 != ((Float)0.))) {
HXDLIN(  93)			ay = (ay + centreY1);
HXDLIN(  93)			by = (by + centreY1);
HXDLIN(  93)			cy = (cy + centreY1);
HXDLIN(  93)			dy = (dy + centreY1);
            		}
HXDLIN(  93)		int min = ::Math_obj::floor(ax);
HXDLIN(  93)		int max = ::Math_obj::ceil(ax);
HXDLIN(  93)		if ((bx < min)) {
HXLINE(  31)			min = ::Math_obj::floor(bx);
            		}
            		else {
HXDLIN(  93)			if ((bx > max)) {
HXLINE(  33)				max = ::Math_obj::ceil(bx);
            			}
            		}
HXLINE(  93)		if ((cx < min)) {
HXLINE(  36)			min = ::Math_obj::floor(cx);
            		}
            		else {
HXDLIN(  93)			if ((cx > max)) {
HXLINE(  38)				max = ::Math_obj::ceil(cx);
            			}
            		}
HXLINE(  93)		if ((dx < min)) {
HXLINE(  41)			min = ::Math_obj::floor(dx);
            		}
            		else {
HXDLIN(  93)			if ((dx > max)) {
HXLINE(  43)				max = ::Math_obj::ceil(dx);
            			}
            		}
HXLINE(  93)		int ii_min = min;
HXDLIN(  93)		int ii_max = max;
HXDLIN(  93)		 ::pi_xy::iter::IntIterStart boundX =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  93)		int min1 = ::Math_obj::floor(ay);
HXDLIN(  93)		int max1 = ::Math_obj::ceil(ay);
HXDLIN(  93)		if ((by < min1)) {
HXLINE(  31)			min1 = ::Math_obj::floor(by);
            		}
            		else {
HXDLIN(  93)			if ((by > max1)) {
HXLINE(  33)				max1 = ::Math_obj::ceil(by);
            			}
            		}
HXLINE(  93)		if ((cy < min1)) {
HXLINE(  36)			min1 = ::Math_obj::floor(cy);
            		}
            		else {
HXDLIN(  93)			if ((cy > max1)) {
HXLINE(  38)				max1 = ::Math_obj::ceil(cy);
            			}
            		}
HXLINE(  93)		if ((dy < min1)) {
HXLINE(  41)			min1 = ::Math_obj::floor(dy);
            		}
            		else {
HXDLIN(  93)			if ((dy > max1)) {
HXLINE(  43)				max1 = ::Math_obj::ceil(dy);
            			}
            		}
HXLINE(  93)		int ii_min1 = min1;
HXDLIN(  93)		int ii_max1 = max1;
HXDLIN(  93)		 ::pi_xy::iter::IntIterStart boundY =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
HXDLIN(  93)		int minX = boundX->start;
HXDLIN(  93)		int wid = ((boundX->max - boundX->start) + 1);
HXDLIN(  93)		int minY = boundY->start;
HXDLIN(  93)		int hi = ((boundY->max - boundY->start) + 1);
HXDLIN(  93)		 ::Dynamic imageType = null();
HXDLIN(  93)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  93)		if (::hx::IsNull( imageType )) {
HXLINE(  54)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXLINE(  93)		::Dynamic _hx_tmp;
HXDLIN(  93)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXDLIN(  93)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  93)				 ::iterMagic::BytesImg b = byt;
HXDLIN(  93)				{
HXDLIN(  93)					b->width = wid;
HXDLIN(  93)					b->height = hi;
HXDLIN(  93)					b->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  93)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  93)					{
HXDLIN(  93)						int len = b->length;
HXDLIN(  93)						int w = 0;
HXDLIN(  93)						{
HXDLIN(  93)							int _g = 0;
HXDLIN(  93)							int _g1 = b->height;
HXDLIN(  93)							while((_g < _g1)){
HXDLIN(  93)								_g = (_g + 1);
HXDLIN(  93)								int y = (_g - 1);
HXDLIN(  93)								{
HXDLIN(  93)									int _g2 = 0;
HXDLIN(  93)									int _g3 = b->width;
HXDLIN(  93)									while((_g2 < _g3)){
HXDLIN(  93)										_g2 = (_g2 + 1);
HXDLIN(  93)										int x = (_g2 - 1);
HXDLIN(  93)										{
HXDLIN(  93)											w = (w + 1);
HXDLIN(  93)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  93)										{
HXDLIN(  93)											w = (w + 1);
HXDLIN(  93)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  93)										{
HXDLIN(  93)											w = (w + 1);
HXDLIN(  93)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  93)										{
HXDLIN(  93)											w = (w + 1);
HXDLIN(  93)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  93)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXDLIN(  93)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  93)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  93)				{
HXDLIN(  93)					a->width = wid;
HXDLIN(  93)					a->height = hi;
HXDLIN(  93)					a->data = ::Array_obj< int >::__new(0);
HXDLIN(  93)					a->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  93)					{
HXDLIN(  93)						int _g4 = 0;
HXDLIN(  93)						int _g5 = a->length;
HXDLIN(  93)						while((_g4 < _g5)){
HXDLIN(  93)							_g4 = (_g4 + 1);
HXDLIN(  93)							int i = (_g4 - 1);
HXDLIN(  93)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN(  93)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXDLIN(  93)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  93)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  93)				{
HXDLIN(  93)					b1->width = wid;
HXDLIN(  93)					b1->height = hi;
HXDLIN(  93)					b1->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  93)					int size = (b1->length * 4);
HXDLIN(  93)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  93)					{
HXDLIN(  93)						int _g6 = 0;
HXDLIN(  93)						int _g7 = b1->length;
HXDLIN(  93)						while((_g6 < _g7)){
HXDLIN(  93)							_g6 = (_g6 + 1);
HXDLIN(  93)							int i1 = (_g6 - 1);
HXDLIN(  93)							{
HXDLIN(  93)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  93)								bool _hx_tmp1;
HXDLIN(  93)								if ((i1 >= 0)) {
HXDLIN(  93)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXDLIN(  93)									_hx_tmp1 = false;
            								}
HXDLIN(  93)								if (_hx_tmp1) {
HXDLIN(  93)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  93)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  93)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  93)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  93)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  93)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(  93)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXDLIN(  93)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  93)				 ::iterMagic::VecIntImg v = vec;
HXDLIN(  93)				{
HXDLIN(  93)					v->width = wid;
HXDLIN(  93)					v->height = hi;
HXDLIN(  93)					v->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  93)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  93)					{
HXDLIN(  93)						int _g8 = 0;
HXDLIN(  93)						int _g9 = v->length;
HXDLIN(  93)						while((_g8 < _g9)){
HXDLIN(  93)							_g8 = (_g8 + 1);
HXDLIN(  93)							int i2 = (_g8 - 1);
HXDLIN(  93)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN(  93)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXDLIN(  93)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  93)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  93)				{
HXDLIN(  93)					b2->width = wid;
HXDLIN(  93)					b2->height = hi;
HXDLIN(  93)					b2->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  93)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  93)					{
HXDLIN(  93)						int len1 = b2->length;
HXDLIN(  93)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  93)						if (::hx::IsNull( d->head )) {
HXDLIN(  93)							int _g10 = 0;
HXDLIN(  93)							int _g11 = len1;
HXDLIN(  93)							while((_g10 < _g11)){
HXDLIN(  93)								_g10 = (_g10 + 1);
HXDLIN(  93)								int i3 = (_g10 - 1);
HXDLIN(  93)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXDLIN(  93)							int _g12 = 0;
HXDLIN(  93)							int _g13 = len1;
HXDLIN(  93)							while((_g12 < _g13)){
HXDLIN(  93)								_g12 = (_g12 + 1);
HXDLIN(  93)								int i4 = (_g12 - 1);
HXDLIN(  93)								{
HXDLIN(  93)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  93)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  93)									{
HXDLIN(  93)										int _g14 = 0;
HXDLIN(  93)										int _g15 = i4;
HXDLIN(  93)										while((_g14 < _g15)){
HXDLIN(  93)											_g14 = (_g14 + 1);
HXDLIN(  93)											int i5 = (_g14 - 1);
HXLINE( 345)											prev = l;
HXLINE( 346)											l = l->next;
            										}
            									}
HXLINE(  93)									if (::hx::IsNull( prev )) {
HXDLIN(  93)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  93)										l = null();
            									}
            									else {
HXDLIN(  93)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  93)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  93)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN(  93)		this2->image = _hx_tmp;
HXDLIN(  93)		this2->width = wid;
HXDLIN(  93)		this2->height = hi;
HXDLIN(  93)		this2->imageType = ( (int)(imageType) );
HXDLIN(  93)		 ::pi_xy::ImageStruct nextImage = this2;
HXDLIN(  93)		nextImage->transparent = true;
HXDLIN(  93)		if ((minX < ((Float)0.))) {
HXDLIN(  93)			ax = (ax - ( (Float)(minX) ));
HXDLIN(  93)			bx = (bx - ( (Float)(minX) ));
HXDLIN(  93)			cx = (cx - ( (Float)(minX) ));
HXDLIN(  93)			dx = (dx - ( (Float)(minX) ));
            		}
HXDLIN(  93)		if ((minY < ((Float)0.))) {
HXDLIN(  93)			ay = (ay - ( (Float)(minY) ));
HXDLIN(  93)			by = (by - ( (Float)(minY) ));
HXDLIN(  93)			cy = (cy - ( (Float)(minY) ));
HXDLIN(  93)			dy = (dy - ( (Float)(minY) ));
            		}
HXDLIN(  93)		{
HXDLIN(  93)			 ::pi_xy::ImageStruct this4 = nextImage;
HXDLIN(  93)			Float win_x = ( (Float)(0) );
HXDLIN(  93)			Float win_y = ( (Float)(0) );
HXDLIN(  93)			Float win_width = ( (Float)(this1->width) );
HXDLIN(  93)			Float win_height = ( (Float)(this1->height) );
HXDLIN(  93)			{
HXDLIN(  93)				Float bu = ((Float)1.);
HXDLIN(  93)				Float bv = ((Float)0.);
HXDLIN(  93)				Float cu = ((Float)1.);
HXDLIN(  93)				Float cv = ((Float)1.);
HXDLIN(  93)				Float du = ((Float)0.);
HXDLIN(  93)				Float dv = ((Float)1.);
HXDLIN(  93)				Float au = ((Float)0.);
HXDLIN(  93)				Float av = ((Float)0.);
HXDLIN(  93)				Float bu1 = bu;
HXDLIN(  93)				Float bv1 = bv;
HXDLIN(  93)				bool hasUndo = false;
HXDLIN(  93)				Float temp4 = au;
HXLINE( 422)				au = bu1;
HXLINE( 423)				bu1 = temp4;
HXLINE( 424)				temp4 = av;
HXLINE( 425)				av = bv1;
HXLINE( 426)				bv1 = temp4;
HXLINE(  93)				Float bcx = (bx - dx);
HXDLIN(  93)				Float bcy = (by - dy);
HXDLIN(  93)				Float acx = (ax - dx);
HXDLIN(  93)				Float acy = (ay - dy);
HXDLIN(  93)				Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  93)				Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  93)				Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  93)				Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  93)				 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  93)				if ((ax > bx)) {
HXDLIN(  93)					if ((ax > dx)) {
HXDLIN(  93)						int min2;
HXDLIN(  93)						if ((bx > dx)) {
HXDLIN(  93)							min2 = ::Math_obj::floor(dx);
            						}
            						else {
HXDLIN(  93)							min2 = ::Math_obj::floor(bx);
            						}
HXDLIN(  93)						int ii_min2 = min2;
HXDLIN(  93)						int ii_max2 = ::Math_obj::ceil(ax);
HXDLIN(  93)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            					}
            					else {
HXDLIN(  93)						int ii_min3 = ::Math_obj::floor(bx);
HXDLIN(  93)						int ii_max3 = ::Math_obj::ceil(dx);
HXDLIN(  93)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            					}
            				}
            				else {
HXDLIN(  93)					if ((bx > dx)) {
HXDLIN(  93)						int min3;
HXDLIN(  93)						if ((ax > dx)) {
HXDLIN(  93)							min3 = ::Math_obj::floor(dx);
            						}
            						else {
HXDLIN(  93)							min3 = ::Math_obj::ceil(ax);
            						}
HXDLIN(  93)						int ii_min4 = min3;
HXDLIN(  93)						int ii_max4 = ::Math_obj::ceil(bx);
HXDLIN(  93)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            					}
            					else {
HXDLIN(  93)						int ii_min5 = ::Math_obj::floor(ax);
HXDLIN(  93)						int ii_max5 = ::Math_obj::ceil(dx);
HXDLIN(  93)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            					}
            				}
HXDLIN(  93)				 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  93)				if ((ay > by)) {
HXDLIN(  93)					if ((ay > dy)) {
HXDLIN(  93)						int min4;
HXDLIN(  93)						if ((by > dy)) {
HXDLIN(  93)							min4 = ::Math_obj::floor(dy);
            						}
            						else {
HXDLIN(  93)							min4 = ::Math_obj::floor(by);
            						}
HXDLIN(  93)						int ii_min6 = min4;
HXDLIN(  93)						int ii_max6 = ::Math_obj::ceil(ay);
HXDLIN(  93)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            					}
            					else {
HXDLIN(  93)						int ii_min7 = ::Math_obj::floor(by);
HXDLIN(  93)						int ii_max7 = ::Math_obj::ceil(dy);
HXDLIN(  93)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            					}
            				}
            				else {
HXDLIN(  93)					if ((by > dy)) {
HXDLIN(  93)						int min5;
HXDLIN(  93)						if ((ay > dy)) {
HXDLIN(  93)							min5 = ::Math_obj::floor(dy);
            						}
            						else {
HXDLIN(  93)							min5 = ::Math_obj::ceil(ay);
            						}
HXDLIN(  93)						int ii_min8 = min5;
HXDLIN(  93)						int ii_max8 = ::Math_obj::ceil(by);
HXDLIN(  93)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            					}
            					else {
HXDLIN(  93)						int ii_min9 = ::Math_obj::floor(ay);
HXDLIN(  93)						int ii_max9 = ::Math_obj::ceil(dy);
HXDLIN(  93)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            					}
            				}
HXDLIN(  93)				 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  93)				if (hasUndo) {
HXDLIN(  93)					int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  93)					int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  93)					 ::Dynamic imageType1 = null();
HXDLIN(  93)					 ::pi_xy::ImageStruct this5 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  93)					if (::hx::IsNull( imageType1 )) {
HXLINE(  54)						imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE(  93)					::Dynamic undoImage1;
HXDLIN(  93)					switch((int)(( (int)(imageType1) ))){
            						case (int)0: {
HXDLIN(  93)							 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  93)							 ::iterMagic::BytesImg b3 = byt1;
HXDLIN(  93)							{
HXDLIN(  93)								b3->width = width;
HXDLIN(  93)								b3->height = height;
HXDLIN(  93)								b3->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  93)								b3->data = ::haxe::io::Bytes_obj::alloc((b3->length * 4));
HXDLIN(  93)								{
HXDLIN(  93)									int len2 = b3->length;
HXDLIN(  93)									int w1 = 0;
HXDLIN(  93)									{
HXDLIN(  93)										int _g16 = 0;
HXDLIN(  93)										int _g17 = b3->height;
HXDLIN(  93)										while((_g16 < _g17)){
HXDLIN(  93)											_g16 = (_g16 + 1);
HXDLIN(  93)											int y1 = (_g16 - 1);
HXDLIN(  93)											{
HXDLIN(  93)												int _g18 = 0;
HXDLIN(  93)												int _g19 = b3->width;
HXDLIN(  93)												while((_g18 < _g19)){
HXDLIN(  93)													_g18 = (_g18 + 1);
HXDLIN(  93)													int x1 = (_g18 - 1);
HXDLIN(  93)													{
HXDLIN(  93)														w1 = (w1 + 1);
HXDLIN(  93)														b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  93)													{
HXDLIN(  93)														w1 = (w1 + 1);
HXDLIN(  93)														b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  93)													{
HXDLIN(  93)														w1 = (w1 + 1);
HXDLIN(  93)														b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  93)													{
HXDLIN(  93)														w1 = (w1 + 1);
HXDLIN(  93)														b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  93)							undoImage1 = b3;
            						}
            						break;
            						case (int)1: {
HXDLIN(  93)							 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  93)							 ::iterMagic::ArrIntImg a1 = arrI1;
HXDLIN(  93)							{
HXDLIN(  93)								a1->width = width;
HXDLIN(  93)								a1->height = height;
HXDLIN(  93)								a1->data = ::Array_obj< int >::__new(0);
HXDLIN(  93)								a1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  93)								{
HXDLIN(  93)									int _g20 = 0;
HXDLIN(  93)									int _g21 = a1->length;
HXDLIN(  93)									while((_g20 < _g21)){
HXDLIN(  93)										_g20 = (_g20 + 1);
HXDLIN(  93)										int i6 = (_g20 - 1);
HXDLIN(  93)										a1->data[i6] = 0;
            									}
            								}
            							}
HXDLIN(  93)							undoImage1 = a1;
            						}
            						break;
            						case (int)2: {
HXDLIN(  93)							 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  93)							 ::iterMagic::U32ArrImg b4 = u32a1;
HXDLIN(  93)							{
HXDLIN(  93)								b4->width = width;
HXDLIN(  93)								b4->height = height;
HXDLIN(  93)								b4->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  93)								int size1 = (b4->length * 4);
HXDLIN(  93)								b4->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  93)								{
HXDLIN(  93)									int _g22 = 0;
HXDLIN(  93)									int _g23 = b4->length;
HXDLIN(  93)									while((_g22 < _g23)){
HXDLIN(  93)										_g22 = (_g22 + 1);
HXDLIN(  93)										int i7 = (_g22 - 1);
HXDLIN(  93)										{
HXDLIN(  93)											 ::haxe::io::ArrayBufferViewImpl this6 = b4->data;
HXDLIN(  93)											bool undoImage2;
HXDLIN(  93)											if ((i7 >= 0)) {
HXDLIN(  93)												undoImage2 = (i7 < (this6->byteLength >> 2));
            											}
            											else {
HXDLIN(  93)												undoImage2 = false;
            											}
HXDLIN(  93)											if (undoImage2) {
HXDLIN(  93)												 ::haxe::io::Bytes _this1 = this6->bytes;
HXDLIN(  93)												int pos1 = ((i7 << 2) + this6->byteOffset);
HXDLIN(  93)												_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  93)												_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  93)												_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  93)												_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN(  93)							undoImage1 = b4;
            						}
            						break;
            						case (int)3: {
HXDLIN(  93)							 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  93)							 ::iterMagic::VecIntImg v1 = vec1;
HXDLIN(  93)							{
HXDLIN(  93)								v1->width = width;
HXDLIN(  93)								v1->height = height;
HXDLIN(  93)								v1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  93)								v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN(  93)								{
HXDLIN(  93)									int _g24 = 0;
HXDLIN(  93)									int _g25 = v1->length;
HXDLIN(  93)									while((_g24 < _g25)){
HXDLIN(  93)										_g24 = (_g24 + 1);
HXDLIN(  93)										int i8 = (_g24 - 1);
HXDLIN(  93)										v1->data->__unsafe_set(i8,0);
            									}
            								}
            							}
HXDLIN(  93)							undoImage1 = v1;
            						}
            						break;
            						case (int)4: {
HXDLIN(  93)							 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  93)							 ::iterMagic::StackIntImg b5 = sInt1;
HXDLIN(  93)							{
HXDLIN(  93)								b5->width = width;
HXDLIN(  93)								b5->height = height;
HXDLIN(  93)								b5->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  93)								b5->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  93)								{
HXDLIN(  93)									int len3 = b5->length;
HXDLIN(  93)									 ::haxe::ds::GenericStack_Int d1 = b5->data;
HXDLIN(  93)									if (::hx::IsNull( d1->head )) {
HXDLIN(  93)										int _g26 = 0;
HXDLIN(  93)										int _g27 = len3;
HXDLIN(  93)										while((_g26 < _g27)){
HXDLIN(  93)											_g26 = (_g26 + 1);
HXDLIN(  93)											int i9 = (_g26 - 1);
HXDLIN(  93)											d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            										}
            									}
            									else {
HXDLIN(  93)										int _g28 = 0;
HXDLIN(  93)										int _g29 = len3;
HXDLIN(  93)										while((_g28 < _g29)){
HXDLIN(  93)											_g28 = (_g28 + 1);
HXDLIN(  93)											int i10 = (_g28 - 1);
HXDLIN(  93)											{
HXDLIN(  93)												 ::haxe::ds::GenericCell_Int l1 = b5->data->head;
HXDLIN(  93)												 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  93)												{
HXDLIN(  93)													int _g30 = 0;
HXDLIN(  93)													int _g31 = i10;
HXDLIN(  93)													while((_g30 < _g31)){
HXDLIN(  93)														_g30 = (_g30 + 1);
HXDLIN(  93)														int i11 = (_g30 - 1);
HXLINE( 345)														prev1 = l1;
HXLINE( 346)														l1 = l1->next;
            													}
            												}
HXLINE(  93)												if (::hx::IsNull( prev1 )) {
HXDLIN(  93)													b5->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  93)													l1 = null();
            												}
            												else {
HXDLIN(  93)													prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  93)													l1 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  93)							undoImage1 = b5;
            						}
            						break;
            					}
HXDLIN(  93)					this5->image = undoImage1;
HXDLIN(  93)					this5->width = width;
HXDLIN(  93)					this5->height = height;
HXDLIN(  93)					this5->imageType = ( (int)(imageType1) );
HXDLIN(  93)					undoImage = this5;
HXDLIN(  93)					{
HXDLIN(  93)						int rectLeft = xIter3->start;
HXDLIN(  93)						int rectTop = yIter3->start;
HXDLIN(  93)						int rectRight = xIter3->max;
HXDLIN(  93)						bool forceClear = false;
HXDLIN(  93)						{
HXDLIN(  93)							int _g32 = rectTop;
HXDLIN(  93)							int _g33 = yIter3->max;
HXDLIN(  93)							while((_g32 < _g33)){
HXDLIN(  93)								_g32 = (_g32 + 1);
HXDLIN(  93)								int dy1 = (_g32 - 1);
HXDLIN(  93)								{
HXDLIN(  93)									int _g34 = rectLeft;
HXDLIN(  93)									int _g35 = rectRight;
HXDLIN(  93)									while((_g34 < _g35)){
HXDLIN(  93)										_g34 = (_g34 + 1);
HXDLIN(  93)										int dx1 = (_g34 - 1);
HXDLIN(  93)										::Dynamic this7 = this4->image;
HXDLIN(  93)										int index;
HXDLIN(  93)										if (this4->useVirtualPos) {
HXDLIN(  93)											index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx1) - this4->virtualX));
            										}
            										else {
HXDLIN(  93)											index = ::Std_obj::_hx_int(( (Float)(((dy1 * this4->width) + dx1)) ));
            										}
HXDLIN(  93)										int c = ::iterMagic::Iimg_obj::get(this7,index);
HXDLIN(  93)										int col;
HXDLIN(  93)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)											col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXDLIN(  93)											col = c;
            										}
HXDLIN(  93)										bool _hx_tmp2;
HXDLIN(  93)										if (this4->useMask) {
HXDLIN(  93)											_hx_tmp2 = ::hx::IsNotNull( this4->mask );
            										}
            										else {
HXDLIN(  93)											_hx_tmp2 = false;
            										}
HXDLIN(  93)										if (_hx_tmp2) {
HXDLIN(  93)											 ::pi_xy::ImageStruct this8 = this4->mask;
HXDLIN(  93)											::Dynamic this9 = this8->image;
HXDLIN(  93)											int index1;
HXDLIN(  93)											if (this8->useVirtualPos) {
HXDLIN(  93)												index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this8->virtualY) * ( (Float)(this8->width) )) + dx1) - this8->virtualX));
            											}
            											else {
HXDLIN(  93)												index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this8->width) + dx1)) ));
            											}
HXDLIN(  93)											int c1 = ::iterMagic::Iimg_obj::get(this9,index1);
HXDLIN(  93)											int v2;
HXDLIN(  93)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)												v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            											}
            											else {
HXDLIN(  93)												v2 = c1;
            											}
HXDLIN(  93)											int maskPixel = v2;
HXDLIN(  93)											int this10 = col;
HXDLIN(  93)											if ((maskPixel == 0)) {
HXDLIN(  93)												col = this10;
            											}
            											else {
HXDLIN(  93)												Float m0;
HXDLIN(  93)												int this11 = ((maskPixel >> 24) & 255);
HXDLIN(  93)												if ((this11 == 0)) {
HXDLIN(  93)													m0 = ((Float)0.);
            												}
            												else {
HXDLIN(  93)													m0 = (( (Float)(this11) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float m1;
HXDLIN(  93)												int this12 = ((maskPixel >> 16) & 255);
HXDLIN(  93)												if ((this12 == 0)) {
HXDLIN(  93)													m1 = ((Float)0.);
            												}
            												else {
HXDLIN(  93)													m1 = (( (Float)(this12) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float m2;
HXDLIN(  93)												int this13 = ((maskPixel >> 8) & 255);
HXDLIN(  93)												if ((this13 == 0)) {
HXDLIN(  93)													m2 = ((Float)0.);
            												}
            												else {
HXDLIN(  93)													m2 = (( (Float)(this13) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float m3;
HXDLIN(  93)												int this14 = (maskPixel & 255);
HXDLIN(  93)												if ((this14 == 0)) {
HXDLIN(  93)													m3 = ((Float)0.);
            												}
            												else {
HXDLIN(  93)													m3 = (( (Float)(this14) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this10 >> 24) & 255)) )));
HXDLIN(  93)												int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this10 >> 16) & 255)) )));
HXDLIN(  93)												int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this10 >> 8) & 255)) )));
HXDLIN(  93)												int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this10 & 255)) )));
HXDLIN(  93)												col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN(  93)										if ((col != 0)) {
HXDLIN(  93)											int x2 = (dx1 - rectLeft);
HXDLIN(  93)											int y2 = (dy1 - rectTop);
HXDLIN(  93)											int c2 = col;
HXDLIN(  93)											bool _hx_tmp3;
HXDLIN(  93)											if ((((c2 >> 24) & 255) < 254)) {
HXDLIN(  93)												_hx_tmp3 = undoImage->transparent;
            											}
            											else {
HXDLIN(  93)												_hx_tmp3 = false;
            											}
HXDLIN(  93)											if (_hx_tmp3) {
HXDLIN(  93)												int location;
HXDLIN(  93)												if (undoImage->useVirtualPos) {
HXDLIN(  93)													location = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            												}
            												else {
HXDLIN(  93)													location = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            												}
HXDLIN(  93)												int this15 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN(  93)												int this16;
HXDLIN(  93)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)													this16 = ((((((this15 >> 24) & 255) << 24) | ((this15 & 255) << 16)) | (((this15 >> 8) & 255) << 8)) | ((this15 >> 16) & 255));
            												}
            												else {
HXDLIN(  93)													this16 = this15;
            												}
HXDLIN(  93)												Float a11;
HXDLIN(  93)												int this17 = ((this16 >> 24) & 255);
HXDLIN(  93)												if ((this17 == 0)) {
HXDLIN(  93)													a11 = ((Float)0.);
            												}
            												else {
HXDLIN(  93)													a11 = (( (Float)(this17) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float r1;
HXDLIN(  93)												int this18 = ((this16 >> 16) & 255);
HXDLIN(  93)												if ((this18 == 0)) {
HXDLIN(  93)													r1 = ((Float)0.);
            												}
            												else {
HXDLIN(  93)													r1 = (( (Float)(this18) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float g1;
HXDLIN(  93)												int this19 = ((this16 >> 8) & 255);
HXDLIN(  93)												if ((this19 == 0)) {
HXDLIN(  93)													g1 = ((Float)0.);
            												}
            												else {
HXDLIN(  93)													g1 = (( (Float)(this19) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float b11;
HXDLIN(  93)												int this20 = (this16 & 255);
HXDLIN(  93)												if ((this20 == 0)) {
HXDLIN(  93)													b11 = ((Float)0.);
            												}
            												else {
HXDLIN(  93)													b11 = (( (Float)(this20) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float a2;
HXDLIN(  93)												int this21 = ((col >> 24) & 255);
HXDLIN(  93)												if ((this21 == 0)) {
HXDLIN(  93)													a2 = ((Float)0.);
            												}
            												else {
HXDLIN(  93)													a2 = (( (Float)(this21) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float r2;
HXDLIN(  93)												int this22 = ((col >> 16) & 255);
HXDLIN(  93)												if ((this22 == 0)) {
HXDLIN(  93)													r2 = ((Float)0.);
            												}
            												else {
HXDLIN(  93)													r2 = (( (Float)(this22) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float g2;
HXDLIN(  93)												int this23 = ((col >> 8) & 255);
HXDLIN(  93)												if ((this23 == 0)) {
HXDLIN(  93)													g2 = ((Float)0.);
            												}
            												else {
HXDLIN(  93)													g2 = (( (Float)(this23) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float b21;
HXDLIN(  93)												int this24 = (col & 255);
HXDLIN(  93)												if ((this24 == 0)) {
HXDLIN(  93)													b21 = ((Float)0.);
            												}
            												else {
HXDLIN(  93)													b21 = (( (Float)(this24) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN(  93)												int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  93)												int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  93)												int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  93)												int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  93)												int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b6);
HXDLIN(  93)												{
HXDLIN(  93)													int _hx_tmp4;
HXDLIN(  93)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)														_hx_tmp4 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            													}
            													else {
HXDLIN(  93)														_hx_tmp4 = blended;
            													}
HXDLIN(  93)													::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp4);
            												}
            											}
            											else {
HXDLIN(  93)												::Dynamic this25 = undoImage->image;
HXDLIN(  93)												int index2;
HXDLIN(  93)												if (undoImage->useVirtualPos) {
HXDLIN(  93)													index2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            												}
            												else {
HXDLIN(  93)													index2 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            												}
HXDLIN(  93)												int _hx_tmp5;
HXDLIN(  93)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)													_hx_tmp5 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            												}
            												else {
HXDLIN(  93)													_hx_tmp5 = c2;
            												}
HXDLIN(  93)												::iterMagic::Iimg_obj::set(this25,index2,_hx_tmp5);
            											}
            										}
            										else {
HXDLIN(  93)											if (forceClear) {
HXDLIN(  93)												::Dynamic this26 = undoImage->image;
HXDLIN(  93)												int x3 = (dx1 - rectLeft);
HXDLIN(  93)												int y3 = (dy1 - rectTop);
HXDLIN(  93)												int index3;
HXDLIN(  93)												if (undoImage->useVirtualPos) {
HXDLIN(  93)													index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x3) - undoImage->virtualX));
            												}
            												else {
HXDLIN(  93)													index3 = ::Std_obj::_hx_int(( (Float)(((y3 * undoImage->width) + x3)) ));
            												}
HXDLIN(  93)												::iterMagic::Iimg_obj::set(this26,index3,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  93)				{
HXDLIN(  93)					int _g_min = xIter3->start;
HXDLIN(  93)					int _g_max = xIter3->max;
HXDLIN(  93)					while((_g_min < _g_max)){
HXDLIN(  93)						_g_min = (_g_min + 1);
HXDLIN(  93)						int px = (_g_min - 1);
HXDLIN(  93)						Float pcx = (( (Float)(px) ) - dx);
HXDLIN(  93)						{
HXDLIN(  93)							int _g_min1 = yIter3->start;
HXDLIN(  93)							int _g_max1 = yIter3->max;
HXDLIN(  93)							while((_g_min1 < _g_max1)){
HXDLIN(  93)								_g_min1 = (_g_min1 + 1);
HXDLIN(  93)								int py = (_g_min1 - 1);
HXDLIN(  93)								Float pcy = (( (Float)(py) ) - dy);
HXDLIN(  93)								Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  93)								Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  93)								Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  93)								Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  93)								Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  93)								bool _hx_tmp6;
HXDLIN(  93)								bool _hx_tmp7;
HXDLIN(  93)								if ((ratioA >= 0)) {
HXDLIN(  93)									_hx_tmp7 = (ratioB >= 0);
            								}
            								else {
HXDLIN(  93)									_hx_tmp7 = false;
            								}
HXDLIN(  93)								if (_hx_tmp7) {
HXDLIN(  93)									_hx_tmp6 = (ratioC >= 0);
            								}
            								else {
HXDLIN(  93)									_hx_tmp6 = false;
            								}
HXDLIN(  93)								if (_hx_tmp6) {
HXDLIN(  93)									Float u = (((au * ratioA) + (bu1 * ratioB)) + (du * ratioC));
HXDLIN(  93)									Float v3 = (((av * ratioA) + (bv1 * ratioB)) + (dv * ratioC));
HXDLIN(  93)									int x4 = ::Std_obj::_hx_int(((u * win_width) + win_x));
HXDLIN(  93)									int y4 = ::Std_obj::_hx_int(((v3 * win_height) + win_y));
HXDLIN(  93)									::Dynamic this27 = this1->image;
HXDLIN(  93)									int index4;
HXDLIN(  93)									if (this1->useVirtualPos) {
HXDLIN(  93)										index4 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - this1->virtualY) * ( (Float)(this1->width) )) + x4) - this1->virtualX));
            									}
            									else {
HXDLIN(  93)										index4 = ::Std_obj::_hx_int(( (Float)(((y4 * this1->width) + x4)) ));
            									}
HXDLIN(  93)									int c3 = ::iterMagic::Iimg_obj::get(this27,index4);
HXDLIN(  93)									int col1;
HXDLIN(  93)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)										col1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            									}
            									else {
HXDLIN(  93)										col1 = c3;
            									}
HXDLIN(  93)									{
HXDLIN(  93)										int c4 = col1;
HXDLIN(  93)										bool _hx_tmp8;
HXDLIN(  93)										if ((((c4 >> 24) & 255) < 254)) {
HXDLIN(  93)											_hx_tmp8 = this4->transparent;
            										}
            										else {
HXDLIN(  93)											_hx_tmp8 = false;
            										}
HXDLIN(  93)										if (_hx_tmp8) {
HXDLIN(  93)											int location1;
HXDLIN(  93)											if (this4->useVirtualPos) {
HXDLIN(  93)												location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this4->virtualY) * ( (Float)(this4->width) )) + px) - this4->virtualX));
            											}
            											else {
HXDLIN(  93)												location1 = ::Std_obj::_hx_int(( (Float)(((py * this4->width) + px)) ));
            											}
HXDLIN(  93)											int this28 = ::iterMagic::Iimg_obj::get(this4->image,location1);
HXDLIN(  93)											int this29;
HXDLIN(  93)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)												this29 = ((((((this28 >> 24) & 255) << 24) | ((this28 & 255) << 16)) | (((this28 >> 8) & 255) << 8)) | ((this28 >> 16) & 255));
            											}
            											else {
HXDLIN(  93)												this29 = this28;
            											}
HXDLIN(  93)											Float a12;
HXDLIN(  93)											int this30 = ((this29 >> 24) & 255);
HXDLIN(  93)											if ((this30 == 0)) {
HXDLIN(  93)												a12 = ((Float)0.);
            											}
            											else {
HXDLIN(  93)												a12 = (( (Float)(this30) ) / ( (Float)(255) ));
            											}
HXDLIN(  93)											Float r11;
HXDLIN(  93)											int this31 = ((this29 >> 16) & 255);
HXDLIN(  93)											if ((this31 == 0)) {
HXDLIN(  93)												r11 = ((Float)0.);
            											}
            											else {
HXDLIN(  93)												r11 = (( (Float)(this31) ) / ( (Float)(255) ));
            											}
HXDLIN(  93)											Float g11;
HXDLIN(  93)											int this32 = ((this29 >> 8) & 255);
HXDLIN(  93)											if ((this32 == 0)) {
HXDLIN(  93)												g11 = ((Float)0.);
            											}
            											else {
HXDLIN(  93)												g11 = (( (Float)(this32) ) / ( (Float)(255) ));
            											}
HXDLIN(  93)											Float b12;
HXDLIN(  93)											int this33 = (this29 & 255);
HXDLIN(  93)											if ((this33 == 0)) {
HXDLIN(  93)												b12 = ((Float)0.);
            											}
            											else {
HXDLIN(  93)												b12 = (( (Float)(this33) ) / ( (Float)(255) ));
            											}
HXDLIN(  93)											Float a21;
HXDLIN(  93)											int this34 = ((col1 >> 24) & 255);
HXDLIN(  93)											if ((this34 == 0)) {
HXDLIN(  93)												a21 = ((Float)0.);
            											}
            											else {
HXDLIN(  93)												a21 = (( (Float)(this34) ) / ( (Float)(255) ));
            											}
HXDLIN(  93)											Float r21;
HXDLIN(  93)											int this35 = ((col1 >> 16) & 255);
HXDLIN(  93)											if ((this35 == 0)) {
HXDLIN(  93)												r21 = ((Float)0.);
            											}
            											else {
HXDLIN(  93)												r21 = (( (Float)(this35) ) / ( (Float)(255) ));
            											}
HXDLIN(  93)											Float g21;
HXDLIN(  93)											int this36 = ((col1 >> 8) & 255);
HXDLIN(  93)											if ((this36 == 0)) {
HXDLIN(  93)												g21 = ((Float)0.);
            											}
            											else {
HXDLIN(  93)												g21 = (( (Float)(this36) ) / ( (Float)(255) ));
            											}
HXDLIN(  93)											Float b22;
HXDLIN(  93)											int this37 = (col1 & 255);
HXDLIN(  93)											if ((this37 == 0)) {
HXDLIN(  93)												b22 = ((Float)0.);
            											}
            											else {
HXDLIN(  93)												b22 = (( (Float)(this37) ) / ( (Float)(255) ));
            											}
HXDLIN(  93)											Float a31 = (a12 * (( (Float)(1) ) - a21));
HXDLIN(  93)											int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  93)											int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  93)											int b7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  93)											int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  93)											int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b7);
HXDLIN(  93)											{
HXDLIN(  93)												int _hx_tmp9;
HXDLIN(  93)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)													_hx_tmp9 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            												}
            												else {
HXDLIN(  93)													_hx_tmp9 = blended1;
            												}
HXDLIN(  93)												::iterMagic::Iimg_obj::set(this4->image,location1,_hx_tmp9);
            											}
            										}
            										else {
HXDLIN(  93)											::Dynamic this38 = this4->image;
HXDLIN(  93)											int index5;
HXDLIN(  93)											if (this4->useVirtualPos) {
HXDLIN(  93)												index5 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this4->virtualY) * ( (Float)(this4->width) )) + px) - this4->virtualX));
            											}
            											else {
HXDLIN(  93)												index5 = ::Std_obj::_hx_int(( (Float)(((py * this4->width) + px)) ));
            											}
HXDLIN(  93)											int _hx_tmp10;
HXDLIN(  93)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)												_hx_tmp10 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            											}
            											else {
HXDLIN(  93)												_hx_tmp10 = c4;
            											}
HXDLIN(  93)											::iterMagic::Iimg_obj::set(this38,index5,_hx_tmp10);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  93)				 ::pi_xy::iter::IntIterStart v_yIter3;
HXDLIN(  93)				 ::pi_xy::iter::IntIterStart v_xIter3;
HXDLIN(  93)				int v_undoY;
HXDLIN(  93)				int v_undoX;
HXDLIN(  93)				Float v_ty;
HXDLIN(  93)				Float v_tx;
HXDLIN(  93)				Float v_t0;
HXDLIN(  93)				Float v_sy;
HXDLIN(  93)				Float v_sx;
HXDLIN(  93)				Float v_s0;
HXDLIN(  93)				Float v_A;
HXDLIN(  93)				Float ax1 = ax;
HXDLIN(  93)				Float ay1 = ay;
HXDLIN(  93)				 ::pi_xy::ImageStruct v_undoImage = null();
HXDLIN(  93)				Float bx1 = bx;
HXDLIN(  93)				Float by1 = by;
HXDLIN(  93)				Float cx1 = dx;
HXDLIN(  93)				Float cy1 = dy;
HXDLIN(  93)				bool adjustWinding = (((((ax1 * by1) - (bx1 * ay1)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay1) - (ax1 * cy1))) > 0);
HXDLIN(  93)				if (!(adjustWinding)) {
HXDLIN(  93)					Float bx_ = bx1;
HXDLIN(  93)					Float by_ = by1;
HXLINE(  24)					bx1 = cx1;
HXLINE(  25)					by1 = cy1;
HXLINE(  26)					cx1 = bx_;
HXLINE(  27)					cy1 = by_;
            				}
HXLINE(  93)				Float v_ax = ax1;
HXDLIN(  93)				Float v_ay = ay1;
HXDLIN(  93)				Float v_bx = bx1;
HXDLIN(  93)				Float v_by = by1;
HXDLIN(  93)				Float v_cx = cx1;
HXDLIN(  93)				Float v_cy = cy1;
HXDLIN(  93)				bool v_preCalculated = true;
HXDLIN(  93)				{
HXDLIN(  93)					v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN(  93)					v_sx = (v_cy - v_ay);
HXDLIN(  93)					v_sy = (v_ax - v_cx);
HXDLIN(  93)					v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN(  93)					v_tx = (v_ay - v_by);
HXDLIN(  93)					v_ty = (v_bx - v_ax);
HXDLIN(  93)					v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN(  93)					Float a6 = v_ax;
HXDLIN(  93)					Float b8 = v_bx;
HXDLIN(  93)					Float c5 = v_cx;
HXDLIN(  93)					if ((a6 > b8)) {
HXDLIN(  93)						if ((a6 > c5)) {
HXDLIN(  93)							int min6;
HXDLIN(  93)							if ((b8 > c5)) {
HXDLIN(  93)								min6 = ::Math_obj::floor(c5);
            							}
            							else {
HXDLIN(  93)								min6 = ::Math_obj::floor(b8);
            							}
HXDLIN(  93)							int ii_min10 = min6;
HXDLIN(  93)							int ii_max10 = ::Math_obj::ceil(a6);
HXDLIN(  93)							v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            						}
            						else {
HXDLIN(  93)							int ii_min11 = ::Math_obj::floor(b8);
HXDLIN(  93)							int ii_max11 = ::Math_obj::ceil(c5);
HXDLIN(  93)							v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            						}
            					}
            					else {
HXDLIN(  93)						if ((b8 > c5)) {
HXDLIN(  93)							int min7;
HXDLIN(  93)							if ((a6 > c5)) {
HXDLIN(  93)								min7 = ::Math_obj::floor(c5);
            							}
            							else {
HXDLIN(  93)								min7 = ::Math_obj::ceil(a6);
            							}
HXDLIN(  93)							int ii_min12 = min7;
HXDLIN(  93)							int ii_max12 = ::Math_obj::ceil(b8);
HXDLIN(  93)							v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            						}
            						else {
HXDLIN(  93)							int ii_min13 = ::Math_obj::floor(a6);
HXDLIN(  93)							int ii_max13 = ::Math_obj::ceil(c5);
HXDLIN(  93)							v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            						}
            					}
HXDLIN(  93)					Float a7 = v_ay;
HXDLIN(  93)					Float b9 = v_by;
HXDLIN(  93)					Float c6 = v_cy;
HXDLIN(  93)					if ((a7 > b9)) {
HXDLIN(  93)						if ((a7 > c6)) {
HXDLIN(  93)							int min8;
HXDLIN(  93)							if ((b9 > c6)) {
HXDLIN(  93)								min8 = ::Math_obj::floor(c6);
            							}
            							else {
HXDLIN(  93)								min8 = ::Math_obj::floor(b9);
            							}
HXDLIN(  93)							int ii_min14 = min8;
HXDLIN(  93)							int ii_max14 = ::Math_obj::ceil(a7);
HXDLIN(  93)							v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            						}
            						else {
HXDLIN(  93)							int ii_min15 = ::Math_obj::floor(b9);
HXDLIN(  93)							int ii_max15 = ::Math_obj::ceil(c6);
HXDLIN(  93)							v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            						}
            					}
            					else {
HXDLIN(  93)						if ((b9 > c6)) {
HXDLIN(  93)							int min9;
HXDLIN(  93)							if ((a7 > c6)) {
HXDLIN(  93)								min9 = ::Math_obj::floor(c6);
            							}
            							else {
HXDLIN(  93)								min9 = ::Math_obj::ceil(a7);
            							}
HXDLIN(  93)							int ii_min16 = min9;
HXDLIN(  93)							int ii_max16 = ::Math_obj::ceil(b9);
HXDLIN(  93)							v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            						}
            						else {
HXDLIN(  93)							int ii_min17 = ::Math_obj::floor(a7);
HXDLIN(  93)							int ii_max17 = ::Math_obj::ceil(c6);
HXDLIN(  93)							v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            						}
            					}
            				}
HXDLIN(  93)				if (hasUndo) {
HXDLIN(  93)					v_undoImage = undoImage;
HXDLIN(  93)					v_undoX = xIter3->start;
HXDLIN(  93)					v_undoY = yIter3->start;
            				}
HXDLIN(  93)				Float au1 = bu;
HXDLIN(  93)				Float av1 = bv;
HXDLIN(  93)				Float bu2 = cu;
HXDLIN(  93)				Float bv2 = cv;
HXDLIN(  93)				bool hasUndo1 = false;
HXDLIN(  93)				Float temp5 = au1;
HXLINE( 422)				au1 = bu2;
HXLINE( 423)				bu2 = temp5;
HXLINE( 424)				temp5 = av1;
HXLINE( 425)				av1 = bv2;
HXLINE( 426)				bv2 = temp5;
HXLINE(  93)				Float bcx1 = (cx - dx);
HXDLIN(  93)				Float bcy1 = (cy - dy);
HXDLIN(  93)				Float acx1 = (bx - dx);
HXDLIN(  93)				Float acy1 = (by - dy);
HXDLIN(  93)				Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  93)				Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  93)				Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  93)				Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  93)				 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  93)				if ((bx > cx)) {
HXDLIN(  93)					if ((bx > dx)) {
HXDLIN(  93)						int min10;
HXDLIN(  93)						if ((cx > dx)) {
HXDLIN(  93)							min10 = ::Math_obj::floor(dx);
            						}
            						else {
HXDLIN(  93)							min10 = ::Math_obj::floor(cx);
            						}
HXDLIN(  93)						int ii_min18 = min10;
HXDLIN(  93)						int ii_max18 = ::Math_obj::ceil(bx);
HXDLIN(  93)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            					}
            					else {
HXDLIN(  93)						int ii_min19 = ::Math_obj::floor(cx);
HXDLIN(  93)						int ii_max19 = ::Math_obj::ceil(dx);
HXDLIN(  93)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            					}
            				}
            				else {
HXDLIN(  93)					if ((cx > dx)) {
HXDLIN(  93)						int min11;
HXDLIN(  93)						if ((bx > dx)) {
HXDLIN(  93)							min11 = ::Math_obj::floor(dx);
            						}
            						else {
HXDLIN(  93)							min11 = ::Math_obj::ceil(bx);
            						}
HXDLIN(  93)						int ii_min20 = min11;
HXDLIN(  93)						int ii_max20 = ::Math_obj::ceil(cx);
HXDLIN(  93)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            					}
            					else {
HXDLIN(  93)						int ii_min21 = ::Math_obj::floor(bx);
HXDLIN(  93)						int ii_max21 = ::Math_obj::ceil(dx);
HXDLIN(  93)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            					}
            				}
HXDLIN(  93)				 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  93)				if ((by > cy)) {
HXDLIN(  93)					if ((by > dy)) {
HXDLIN(  93)						int min12;
HXDLIN(  93)						if ((cy > dy)) {
HXDLIN(  93)							min12 = ::Math_obj::floor(dy);
            						}
            						else {
HXDLIN(  93)							min12 = ::Math_obj::floor(cy);
            						}
HXDLIN(  93)						int ii_min22 = min12;
HXDLIN(  93)						int ii_max22 = ::Math_obj::ceil(by);
HXDLIN(  93)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            					}
            					else {
HXDLIN(  93)						int ii_min23 = ::Math_obj::floor(cy);
HXDLIN(  93)						int ii_max23 = ::Math_obj::ceil(dy);
HXDLIN(  93)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            					}
            				}
            				else {
HXDLIN(  93)					if ((cy > dy)) {
HXDLIN(  93)						int min13;
HXDLIN(  93)						if ((by > dy)) {
HXDLIN(  93)							min13 = ::Math_obj::floor(dy);
            						}
            						else {
HXDLIN(  93)							min13 = ::Math_obj::ceil(by);
            						}
HXDLIN(  93)						int ii_min24 = min13;
HXDLIN(  93)						int ii_max24 = ::Math_obj::ceil(cy);
HXDLIN(  93)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            					}
            					else {
HXDLIN(  93)						int ii_min25 = ::Math_obj::floor(by);
HXDLIN(  93)						int ii_max25 = ::Math_obj::ceil(dy);
HXDLIN(  93)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            					}
            				}
HXDLIN(  93)				 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  93)				if (hasUndo1) {
HXDLIN(  93)					int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  93)					int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  93)					 ::Dynamic imageType2 = null();
HXDLIN(  93)					 ::pi_xy::ImageStruct this39 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  93)					if (::hx::IsNull( imageType2 )) {
HXLINE(  54)						imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE(  93)					::Dynamic undoImage4;
HXDLIN(  93)					switch((int)(( (int)(imageType2) ))){
            						case (int)0: {
HXDLIN(  93)							 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  93)							 ::iterMagic::BytesImg b10 = byt2;
HXDLIN(  93)							{
HXDLIN(  93)								b10->width = width1;
HXDLIN(  93)								b10->height = height1;
HXDLIN(  93)								b10->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  93)								b10->data = ::haxe::io::Bytes_obj::alloc((b10->length * 4));
HXDLIN(  93)								{
HXDLIN(  93)									int len4 = b10->length;
HXDLIN(  93)									int w2 = 0;
HXDLIN(  93)									{
HXDLIN(  93)										int _g36 = 0;
HXDLIN(  93)										int _g37 = b10->height;
HXDLIN(  93)										while((_g36 < _g37)){
HXDLIN(  93)											_g36 = (_g36 + 1);
HXDLIN(  93)											int y5 = (_g36 - 1);
HXDLIN(  93)											{
HXDLIN(  93)												int _g38 = 0;
HXDLIN(  93)												int _g39 = b10->width;
HXDLIN(  93)												while((_g38 < _g39)){
HXDLIN(  93)													_g38 = (_g38 + 1);
HXDLIN(  93)													int x5 = (_g38 - 1);
HXDLIN(  93)													{
HXDLIN(  93)														w2 = (w2 + 1);
HXDLIN(  93)														b10->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  93)													{
HXDLIN(  93)														w2 = (w2 + 1);
HXDLIN(  93)														b10->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  93)													{
HXDLIN(  93)														w2 = (w2 + 1);
HXDLIN(  93)														b10->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  93)													{
HXDLIN(  93)														w2 = (w2 + 1);
HXDLIN(  93)														b10->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  93)							undoImage4 = b10;
            						}
            						break;
            						case (int)1: {
HXDLIN(  93)							 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  93)							 ::iterMagic::ArrIntImg a8 = arrI2;
HXDLIN(  93)							{
HXDLIN(  93)								a8->width = width1;
HXDLIN(  93)								a8->height = height1;
HXDLIN(  93)								a8->data = ::Array_obj< int >::__new(0);
HXDLIN(  93)								a8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  93)								{
HXDLIN(  93)									int _g40 = 0;
HXDLIN(  93)									int _g41 = a8->length;
HXDLIN(  93)									while((_g40 < _g41)){
HXDLIN(  93)										_g40 = (_g40 + 1);
HXDLIN(  93)										int i12 = (_g40 - 1);
HXDLIN(  93)										a8->data[i12] = 0;
            									}
            								}
            							}
HXDLIN(  93)							undoImage4 = a8;
            						}
            						break;
            						case (int)2: {
HXDLIN(  93)							 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  93)							 ::iterMagic::U32ArrImg b13 = u32a2;
HXDLIN(  93)							{
HXDLIN(  93)								b13->width = width1;
HXDLIN(  93)								b13->height = height1;
HXDLIN(  93)								b13->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  93)								int size2 = (b13->length * 4);
HXDLIN(  93)								b13->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN(  93)								{
HXDLIN(  93)									int _g42 = 0;
HXDLIN(  93)									int _g43 = b13->length;
HXDLIN(  93)									while((_g42 < _g43)){
HXDLIN(  93)										_g42 = (_g42 + 1);
HXDLIN(  93)										int i13 = (_g42 - 1);
HXDLIN(  93)										{
HXDLIN(  93)											 ::haxe::io::ArrayBufferViewImpl this40 = b13->data;
HXDLIN(  93)											bool undoImage5;
HXDLIN(  93)											if ((i13 >= 0)) {
HXDLIN(  93)												undoImage5 = (i13 < (this40->byteLength >> 2));
            											}
            											else {
HXDLIN(  93)												undoImage5 = false;
            											}
HXDLIN(  93)											if (undoImage5) {
HXDLIN(  93)												 ::haxe::io::Bytes _this2 = this40->bytes;
HXDLIN(  93)												int pos2 = ((i13 << 2) + this40->byteOffset);
HXDLIN(  93)												_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN(  93)												_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN(  93)												_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN(  93)												_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN(  93)							undoImage4 = b13;
            						}
            						break;
            						case (int)3: {
HXDLIN(  93)							 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  93)							 ::iterMagic::VecIntImg v4 = vec2;
HXDLIN(  93)							{
HXDLIN(  93)								v4->width = width1;
HXDLIN(  93)								v4->height = height1;
HXDLIN(  93)								v4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  93)								v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN(  93)								{
HXDLIN(  93)									int _g44 = 0;
HXDLIN(  93)									int _g45 = v4->length;
HXDLIN(  93)									while((_g44 < _g45)){
HXDLIN(  93)										_g44 = (_g44 + 1);
HXDLIN(  93)										int i14 = (_g44 - 1);
HXDLIN(  93)										v4->data->__unsafe_set(i14,0);
            									}
            								}
            							}
HXDLIN(  93)							undoImage4 = v4;
            						}
            						break;
            						case (int)4: {
HXDLIN(  93)							 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  93)							 ::iterMagic::StackIntImg b14 = sInt2;
HXDLIN(  93)							{
HXDLIN(  93)								b14->width = width1;
HXDLIN(  93)								b14->height = height1;
HXDLIN(  93)								b14->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  93)								b14->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  93)								{
HXDLIN(  93)									int len5 = b14->length;
HXDLIN(  93)									 ::haxe::ds::GenericStack_Int d2 = b14->data;
HXDLIN(  93)									if (::hx::IsNull( d2->head )) {
HXDLIN(  93)										int _g46 = 0;
HXDLIN(  93)										int _g47 = len5;
HXDLIN(  93)										while((_g46 < _g47)){
HXDLIN(  93)											_g46 = (_g46 + 1);
HXDLIN(  93)											int i15 = (_g46 - 1);
HXDLIN(  93)											d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            										}
            									}
            									else {
HXDLIN(  93)										int _g48 = 0;
HXDLIN(  93)										int _g49 = len5;
HXDLIN(  93)										while((_g48 < _g49)){
HXDLIN(  93)											_g48 = (_g48 + 1);
HXDLIN(  93)											int i16 = (_g48 - 1);
HXDLIN(  93)											{
HXDLIN(  93)												 ::haxe::ds::GenericCell_Int l2 = b14->data->head;
HXDLIN(  93)												 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN(  93)												{
HXDLIN(  93)													int _g50 = 0;
HXDLIN(  93)													int _g51 = i16;
HXDLIN(  93)													while((_g50 < _g51)){
HXDLIN(  93)														_g50 = (_g50 + 1);
HXDLIN(  93)														int i17 = (_g50 - 1);
HXLINE( 345)														prev2 = l2;
HXLINE( 346)														l2 = l2->next;
            													}
            												}
HXLINE(  93)												if (::hx::IsNull( prev2 )) {
HXDLIN(  93)													b14->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  93)													l2 = null();
            												}
            												else {
HXDLIN(  93)													prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  93)													l2 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  93)							undoImage4 = b14;
            						}
            						break;
            					}
HXDLIN(  93)					this39->image = undoImage4;
HXDLIN(  93)					this39->width = width1;
HXDLIN(  93)					this39->height = height1;
HXDLIN(  93)					this39->imageType = ( (int)(imageType2) );
HXDLIN(  93)					undoImage3 = this39;
HXDLIN(  93)					{
HXDLIN(  93)						int rectLeft1 = xIter31->start;
HXDLIN(  93)						int rectTop1 = yIter31->start;
HXDLIN(  93)						int rectRight1 = xIter31->max;
HXDLIN(  93)						bool forceClear1 = false;
HXDLIN(  93)						{
HXDLIN(  93)							int _g52 = rectTop1;
HXDLIN(  93)							int _g53 = yIter31->max;
HXDLIN(  93)							while((_g52 < _g53)){
HXDLIN(  93)								_g52 = (_g52 + 1);
HXDLIN(  93)								int dy2 = (_g52 - 1);
HXDLIN(  93)								{
HXDLIN(  93)									int _g54 = rectLeft1;
HXDLIN(  93)									int _g55 = rectRight1;
HXDLIN(  93)									while((_g54 < _g55)){
HXDLIN(  93)										_g54 = (_g54 + 1);
HXDLIN(  93)										int dx2 = (_g54 - 1);
HXDLIN(  93)										::Dynamic this41 = this4->image;
HXDLIN(  93)										int index6;
HXDLIN(  93)										if (this4->useVirtualPos) {
HXDLIN(  93)											index6 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx2) - this4->virtualX));
            										}
            										else {
HXDLIN(  93)											index6 = ::Std_obj::_hx_int(( (Float)(((dy2 * this4->width) + dx2)) ));
            										}
HXDLIN(  93)										int c7 = ::iterMagic::Iimg_obj::get(this41,index6);
HXDLIN(  93)										int col2;
HXDLIN(  93)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)											col2 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            										}
            										else {
HXDLIN(  93)											col2 = c7;
            										}
HXDLIN(  93)										bool _hx_tmp11;
HXDLIN(  93)										if (this4->useMask) {
HXDLIN(  93)											_hx_tmp11 = ::hx::IsNotNull( this4->mask );
            										}
            										else {
HXDLIN(  93)											_hx_tmp11 = false;
            										}
HXDLIN(  93)										if (_hx_tmp11) {
HXDLIN(  93)											 ::pi_xy::ImageStruct this42 = this4->mask;
HXDLIN(  93)											::Dynamic this43 = this42->image;
HXDLIN(  93)											int index7;
HXDLIN(  93)											if (this42->useVirtualPos) {
HXDLIN(  93)												index7 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this42->virtualY) * ( (Float)(this42->width) )) + dx2) - this42->virtualX));
            											}
            											else {
HXDLIN(  93)												index7 = ::Std_obj::_hx_int(( (Float)(((dy2 * this42->width) + dx2)) ));
            											}
HXDLIN(  93)											int c8 = ::iterMagic::Iimg_obj::get(this43,index7);
HXDLIN(  93)											int v5;
HXDLIN(  93)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)												v5 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            											}
            											else {
HXDLIN(  93)												v5 = c8;
            											}
HXDLIN(  93)											int maskPixel1 = v5;
HXDLIN(  93)											int this44 = col2;
HXDLIN(  93)											if ((maskPixel1 == 0)) {
HXDLIN(  93)												col2 = this44;
            											}
            											else {
HXDLIN(  93)												Float m01;
HXDLIN(  93)												int this45 = ((maskPixel1 >> 24) & 255);
HXDLIN(  93)												if ((this45 == 0)) {
HXDLIN(  93)													m01 = ((Float)0.);
            												}
            												else {
HXDLIN(  93)													m01 = (( (Float)(this45) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float m11;
HXDLIN(  93)												int this46 = ((maskPixel1 >> 16) & 255);
HXDLIN(  93)												if ((this46 == 0)) {
HXDLIN(  93)													m11 = ((Float)0.);
            												}
            												else {
HXDLIN(  93)													m11 = (( (Float)(this46) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float m21;
HXDLIN(  93)												int this47 = ((maskPixel1 >> 8) & 255);
HXDLIN(  93)												if ((this47 == 0)) {
HXDLIN(  93)													m21 = ((Float)0.);
            												}
            												else {
HXDLIN(  93)													m21 = (( (Float)(this47) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float m31;
HXDLIN(  93)												int this48 = (maskPixel1 & 255);
HXDLIN(  93)												if ((this48 == 0)) {
HXDLIN(  93)													m31 = ((Float)0.);
            												}
            												else {
HXDLIN(  93)													m31 = (( (Float)(this48) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this44 >> 24) & 255)) )));
HXDLIN(  93)												int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this44 >> 16) & 255)) )));
HXDLIN(  93)												int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this44 >> 8) & 255)) )));
HXDLIN(  93)												int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this44 & 255)) )));
HXDLIN(  93)												col2 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN(  93)										if ((col2 != 0)) {
HXDLIN(  93)											int x6 = (dx2 - rectLeft1);
HXDLIN(  93)											int y6 = (dy2 - rectTop1);
HXDLIN(  93)											int c9 = col2;
HXDLIN(  93)											bool _hx_tmp12;
HXDLIN(  93)											if ((((c9 >> 24) & 255) < 254)) {
HXDLIN(  93)												_hx_tmp12 = undoImage3->transparent;
            											}
            											else {
HXDLIN(  93)												_hx_tmp12 = false;
            											}
HXDLIN(  93)											if (_hx_tmp12) {
HXDLIN(  93)												int location2;
HXDLIN(  93)												if (undoImage3->useVirtualPos) {
HXDLIN(  93)													location2 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            												}
            												else {
HXDLIN(  93)													location2 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            												}
HXDLIN(  93)												int this49 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN(  93)												int this50;
HXDLIN(  93)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)													this50 = ((((((this49 >> 24) & 255) << 24) | ((this49 & 255) << 16)) | (((this49 >> 8) & 255) << 8)) | ((this49 >> 16) & 255));
            												}
            												else {
HXDLIN(  93)													this50 = this49;
            												}
HXDLIN(  93)												Float a13;
HXDLIN(  93)												int this51 = ((this50 >> 24) & 255);
HXDLIN(  93)												if ((this51 == 0)) {
HXDLIN(  93)													a13 = ((Float)0.);
            												}
            												else {
HXDLIN(  93)													a13 = (( (Float)(this51) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float r12;
HXDLIN(  93)												int this52 = ((this50 >> 16) & 255);
HXDLIN(  93)												if ((this52 == 0)) {
HXDLIN(  93)													r12 = ((Float)0.);
            												}
            												else {
HXDLIN(  93)													r12 = (( (Float)(this52) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float g12;
HXDLIN(  93)												int this53 = ((this50 >> 8) & 255);
HXDLIN(  93)												if ((this53 == 0)) {
HXDLIN(  93)													g12 = ((Float)0.);
            												}
            												else {
HXDLIN(  93)													g12 = (( (Float)(this53) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float b15;
HXDLIN(  93)												int this54 = (this50 & 255);
HXDLIN(  93)												if ((this54 == 0)) {
HXDLIN(  93)													b15 = ((Float)0.);
            												}
            												else {
HXDLIN(  93)													b15 = (( (Float)(this54) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float a22;
HXDLIN(  93)												int this55 = ((col2 >> 24) & 255);
HXDLIN(  93)												if ((this55 == 0)) {
HXDLIN(  93)													a22 = ((Float)0.);
            												}
            												else {
HXDLIN(  93)													a22 = (( (Float)(this55) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float r22;
HXDLIN(  93)												int this56 = ((col2 >> 16) & 255);
HXDLIN(  93)												if ((this56 == 0)) {
HXDLIN(  93)													r22 = ((Float)0.);
            												}
            												else {
HXDLIN(  93)													r22 = (( (Float)(this56) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float g22;
HXDLIN(  93)												int this57 = ((col2 >> 8) & 255);
HXDLIN(  93)												if ((this57 == 0)) {
HXDLIN(  93)													g22 = ((Float)0.);
            												}
            												else {
HXDLIN(  93)													g22 = (( (Float)(this57) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float b23;
HXDLIN(  93)												int this58 = (col2 & 255);
HXDLIN(  93)												if ((this58 == 0)) {
HXDLIN(  93)													b23 = ((Float)0.);
            												}
            												else {
HXDLIN(  93)													b23 = (( (Float)(this58) ) / ( (Float)(255) ));
            												}
HXDLIN(  93)												Float a32 = (a13 * (( (Float)(1) ) - a22));
HXDLIN(  93)												int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  93)												int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  93)												int b16 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a32) + (b23 * a22))));
HXDLIN(  93)												int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  93)												int blended2 = ((((a9 << 24) | (r4 << 16)) | (g4 << 8)) | b16);
HXDLIN(  93)												{
HXDLIN(  93)													int _hx_tmp13;
HXDLIN(  93)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)														_hx_tmp13 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            													}
            													else {
HXDLIN(  93)														_hx_tmp13 = blended2;
            													}
HXDLIN(  93)													::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp13);
            												}
            											}
            											else {
HXDLIN(  93)												::Dynamic this59 = undoImage3->image;
HXDLIN(  93)												int index8;
HXDLIN(  93)												if (undoImage3->useVirtualPos) {
HXDLIN(  93)													index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            												}
            												else {
HXDLIN(  93)													index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            												}
HXDLIN(  93)												int _hx_tmp14;
HXDLIN(  93)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)													_hx_tmp14 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            												}
            												else {
HXDLIN(  93)													_hx_tmp14 = c9;
            												}
HXDLIN(  93)												::iterMagic::Iimg_obj::set(this59,index8,_hx_tmp14);
            											}
            										}
            										else {
HXDLIN(  93)											if (forceClear1) {
HXDLIN(  93)												::Dynamic this60 = undoImage3->image;
HXDLIN(  93)												int x7 = (dx2 - rectLeft1);
HXDLIN(  93)												int y7 = (dy2 - rectTop1);
HXDLIN(  93)												int index9;
HXDLIN(  93)												if (undoImage3->useVirtualPos) {
HXDLIN(  93)													index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x7) - undoImage3->virtualX));
            												}
            												else {
HXDLIN(  93)													index9 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage3->width) + x7)) ));
            												}
HXDLIN(  93)												::iterMagic::Iimg_obj::set(this60,index9,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  93)				{
HXDLIN(  93)					int _g_min2 = xIter31->start;
HXDLIN(  93)					int _g_max2 = xIter31->max;
HXDLIN(  93)					while((_g_min2 < _g_max2)){
HXDLIN(  93)						_g_min2 = (_g_min2 + 1);
HXDLIN(  93)						int px1 = (_g_min2 - 1);
HXDLIN(  93)						Float pcx1 = (( (Float)(px1) ) - dx);
HXDLIN(  93)						{
HXDLIN(  93)							int _g_min3 = yIter31->start;
HXDLIN(  93)							int _g_max3 = yIter31->max;
HXDLIN(  93)							while((_g_min3 < _g_max3)){
HXDLIN(  93)								_g_min3 = (_g_min3 + 1);
HXDLIN(  93)								int py1 = (_g_min3 - 1);
HXDLIN(  93)								Float pcy1 = (( (Float)(py1) ) - dy);
HXDLIN(  93)								Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN(  93)								Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN(  93)								Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN(  93)								Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN(  93)								Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN(  93)								bool _hx_tmp15;
HXDLIN(  93)								bool _hx_tmp16;
HXDLIN(  93)								if ((ratioA1 >= 0)) {
HXDLIN(  93)									_hx_tmp16 = (ratioB1 >= 0);
            								}
            								else {
HXDLIN(  93)									_hx_tmp16 = false;
            								}
HXDLIN(  93)								if (_hx_tmp16) {
HXDLIN(  93)									_hx_tmp15 = (ratioC1 >= 0);
            								}
            								else {
HXDLIN(  93)									_hx_tmp15 = false;
            								}
HXDLIN(  93)								if (_hx_tmp15) {
HXDLIN(  93)									Float u1 = (((au1 * ratioA1) + (bu2 * ratioB1)) + (du * ratioC1));
HXDLIN(  93)									Float v6 = (((av1 * ratioA1) + (bv2 * ratioB1)) + (dv * ratioC1));
HXDLIN(  93)									int x8 = ::Std_obj::_hx_int(((u1 * win_width) + win_x));
HXDLIN(  93)									int y8 = ::Std_obj::_hx_int(((v6 * win_height) + win_y));
HXDLIN(  93)									::Dynamic this61 = this1->image;
HXDLIN(  93)									int index10;
HXDLIN(  93)									if (this1->useVirtualPos) {
HXDLIN(  93)										index10 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - this1->virtualY) * ( (Float)(this1->width) )) + x8) - this1->virtualX));
            									}
            									else {
HXDLIN(  93)										index10 = ::Std_obj::_hx_int(( (Float)(((y8 * this1->width) + x8)) ));
            									}
HXDLIN(  93)									int c10 = ::iterMagic::Iimg_obj::get(this61,index10);
HXDLIN(  93)									int col3;
HXDLIN(  93)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)										col3 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            									}
            									else {
HXDLIN(  93)										col3 = c10;
            									}
HXDLIN(  93)									{
HXDLIN(  93)										int c11 = col3;
HXDLIN(  93)										bool _hx_tmp17;
HXDLIN(  93)										if ((((c11 >> 24) & 255) < 254)) {
HXDLIN(  93)											_hx_tmp17 = this4->transparent;
            										}
            										else {
HXDLIN(  93)											_hx_tmp17 = false;
            										}
HXDLIN(  93)										if (_hx_tmp17) {
HXDLIN(  93)											int location3;
HXDLIN(  93)											if (this4->useVirtualPos) {
HXDLIN(  93)												location3 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this4->virtualY) * ( (Float)(this4->width) )) + px1) - this4->virtualX));
            											}
            											else {
HXDLIN(  93)												location3 = ::Std_obj::_hx_int(( (Float)(((py1 * this4->width) + px1)) ));
            											}
HXDLIN(  93)											int this62 = ::iterMagic::Iimg_obj::get(this4->image,location3);
HXDLIN(  93)											int this63;
HXDLIN(  93)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)												this63 = ((((((this62 >> 24) & 255) << 24) | ((this62 & 255) << 16)) | (((this62 >> 8) & 255) << 8)) | ((this62 >> 16) & 255));
            											}
            											else {
HXDLIN(  93)												this63 = this62;
            											}
HXDLIN(  93)											Float a14;
HXDLIN(  93)											int this64 = ((this63 >> 24) & 255);
HXDLIN(  93)											if ((this64 == 0)) {
HXDLIN(  93)												a14 = ((Float)0.);
            											}
            											else {
HXDLIN(  93)												a14 = (( (Float)(this64) ) / ( (Float)(255) ));
            											}
HXDLIN(  93)											Float r13;
HXDLIN(  93)											int this65 = ((this63 >> 16) & 255);
HXDLIN(  93)											if ((this65 == 0)) {
HXDLIN(  93)												r13 = ((Float)0.);
            											}
            											else {
HXDLIN(  93)												r13 = (( (Float)(this65) ) / ( (Float)(255) ));
            											}
HXDLIN(  93)											Float g13;
HXDLIN(  93)											int this66 = ((this63 >> 8) & 255);
HXDLIN(  93)											if ((this66 == 0)) {
HXDLIN(  93)												g13 = ((Float)0.);
            											}
            											else {
HXDLIN(  93)												g13 = (( (Float)(this66) ) / ( (Float)(255) ));
            											}
HXDLIN(  93)											Float b17;
HXDLIN(  93)											int this67 = (this63 & 255);
HXDLIN(  93)											if ((this67 == 0)) {
HXDLIN(  93)												b17 = ((Float)0.);
            											}
            											else {
HXDLIN(  93)												b17 = (( (Float)(this67) ) / ( (Float)(255) ));
            											}
HXDLIN(  93)											Float a23;
HXDLIN(  93)											int this68 = ((col3 >> 24) & 255);
HXDLIN(  93)											if ((this68 == 0)) {
HXDLIN(  93)												a23 = ((Float)0.);
            											}
            											else {
HXDLIN(  93)												a23 = (( (Float)(this68) ) / ( (Float)(255) ));
            											}
HXDLIN(  93)											Float r23;
HXDLIN(  93)											int this69 = ((col3 >> 16) & 255);
HXDLIN(  93)											if ((this69 == 0)) {
HXDLIN(  93)												r23 = ((Float)0.);
            											}
            											else {
HXDLIN(  93)												r23 = (( (Float)(this69) ) / ( (Float)(255) ));
            											}
HXDLIN(  93)											Float g23;
HXDLIN(  93)											int this70 = ((col3 >> 8) & 255);
HXDLIN(  93)											if ((this70 == 0)) {
HXDLIN(  93)												g23 = ((Float)0.);
            											}
            											else {
HXDLIN(  93)												g23 = (( (Float)(this70) ) / ( (Float)(255) ));
            											}
HXDLIN(  93)											Float b24;
HXDLIN(  93)											int this71 = (col3 & 255);
HXDLIN(  93)											if ((this71 == 0)) {
HXDLIN(  93)												b24 = ((Float)0.);
            											}
            											else {
HXDLIN(  93)												b24 = (( (Float)(this71) ) / ( (Float)(255) ));
            											}
HXDLIN(  93)											Float a33 = (a14 * (( (Float)(1) ) - a23));
HXDLIN(  93)											int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  93)											int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  93)											int b18 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b17 * a33) + (b24 * a23))));
HXDLIN(  93)											int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  93)											int blended3 = ((((a10 << 24) | (r5 << 16)) | (g5 << 8)) | b18);
HXDLIN(  93)											{
HXDLIN(  93)												int _hx_tmp18;
HXDLIN(  93)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)													_hx_tmp18 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            												}
            												else {
HXDLIN(  93)													_hx_tmp18 = blended3;
            												}
HXDLIN(  93)												::iterMagic::Iimg_obj::set(this4->image,location3,_hx_tmp18);
            											}
            										}
            										else {
HXDLIN(  93)											::Dynamic this72 = this4->image;
HXDLIN(  93)											int index11;
HXDLIN(  93)											if (this4->useVirtualPos) {
HXDLIN(  93)												index11 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this4->virtualY) * ( (Float)(this4->width) )) + px1) - this4->virtualX));
            											}
            											else {
HXDLIN(  93)												index11 = ::Std_obj::_hx_int(( (Float)(((py1 * this4->width) + px1)) ));
            											}
HXDLIN(  93)											int _hx_tmp19;
HXDLIN(  93)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  93)												_hx_tmp19 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            											}
            											else {
HXDLIN(  93)												_hx_tmp19 = c11;
            											}
HXDLIN(  93)											::iterMagic::Iimg_obj::set(this72,index11,_hx_tmp19);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  93)				 ::pi_xy::iter::IntIterStart v_yIter31;
HXDLIN(  93)				 ::pi_xy::iter::IntIterStart v_xIter31;
HXDLIN(  93)				int v_undoY1;
HXDLIN(  93)				int v_undoX1;
HXDLIN(  93)				Float v_ty1;
HXDLIN(  93)				Float v_tx1;
HXDLIN(  93)				Float v_t01;
HXDLIN(  93)				Float v_sy1;
HXDLIN(  93)				Float v_sx1;
HXDLIN(  93)				Float v_s01;
HXDLIN(  93)				Float v_A1;
HXDLIN(  93)				Float ax2 = bx;
HXDLIN(  93)				Float ay2 = by;
HXDLIN(  93)				 ::pi_xy::ImageStruct v_undoImage1 = null();
HXDLIN(  93)				Float bx2 = cx;
HXDLIN(  93)				Float by2 = cy;
HXDLIN(  93)				Float cx2 = dx;
HXDLIN(  93)				Float cy2 = dy;
HXDLIN(  93)				bool adjustWinding1 = (((((ax2 * by2) - (bx2 * ay2)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ay2) - (ax2 * cy2))) > 0);
HXDLIN(  93)				if (!(adjustWinding1)) {
HXDLIN(  93)					Float bx_1 = bx2;
HXDLIN(  93)					Float by_1 = by2;
HXLINE(  24)					bx2 = cx2;
HXLINE(  25)					by2 = cy2;
HXLINE(  26)					cx2 = bx_1;
HXLINE(  27)					cy2 = by_1;
            				}
HXLINE(  93)				Float v_ax1 = ax2;
HXDLIN(  93)				Float v_ay1 = ay2;
HXDLIN(  93)				Float v_bx1 = bx2;
HXDLIN(  93)				Float v_by1 = by2;
HXDLIN(  93)				Float v_cx1 = cx2;
HXDLIN(  93)				Float v_cy1 = cy2;
HXDLIN(  93)				bool v_preCalculated1 = true;
HXDLIN(  93)				{
HXDLIN(  93)					v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN(  93)					v_sx1 = (v_cy1 - v_ay1);
HXDLIN(  93)					v_sy1 = (v_ax1 - v_cx1);
HXDLIN(  93)					v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN(  93)					v_tx1 = (v_ay1 - v_by1);
HXDLIN(  93)					v_ty1 = (v_bx1 - v_ax1);
HXDLIN(  93)					v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN(  93)					Float a15 = v_ax1;
HXDLIN(  93)					Float b19 = v_bx1;
HXDLIN(  93)					Float c12 = v_cx1;
HXDLIN(  93)					if ((a15 > b19)) {
HXDLIN(  93)						if ((a15 > c12)) {
HXDLIN(  93)							int min14;
HXDLIN(  93)							if ((b19 > c12)) {
HXDLIN(  93)								min14 = ::Math_obj::floor(c12);
            							}
            							else {
HXDLIN(  93)								min14 = ::Math_obj::floor(b19);
            							}
HXDLIN(  93)							int ii_min26 = min14;
HXDLIN(  93)							int ii_max26 = ::Math_obj::ceil(a15);
HXDLIN(  93)							v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            						}
            						else {
HXDLIN(  93)							int ii_min27 = ::Math_obj::floor(b19);
HXDLIN(  93)							int ii_max27 = ::Math_obj::ceil(c12);
HXDLIN(  93)							v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            						}
            					}
            					else {
HXDLIN(  93)						if ((b19 > c12)) {
HXDLIN(  93)							int min15;
HXDLIN(  93)							if ((a15 > c12)) {
HXDLIN(  93)								min15 = ::Math_obj::floor(c12);
            							}
            							else {
HXDLIN(  93)								min15 = ::Math_obj::ceil(a15);
            							}
HXDLIN(  93)							int ii_min28 = min15;
HXDLIN(  93)							int ii_max28 = ::Math_obj::ceil(b19);
HXDLIN(  93)							v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            						}
            						else {
HXDLIN(  93)							int ii_min29 = ::Math_obj::floor(a15);
HXDLIN(  93)							int ii_max29 = ::Math_obj::ceil(c12);
HXDLIN(  93)							v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            						}
            					}
HXDLIN(  93)					Float a16 = v_ay1;
HXDLIN(  93)					Float b20 = v_by1;
HXDLIN(  93)					Float c13 = v_cy1;
HXDLIN(  93)					if ((a16 > b20)) {
HXDLIN(  93)						if ((a16 > c13)) {
HXDLIN(  93)							int min16;
HXDLIN(  93)							if ((b20 > c13)) {
HXDLIN(  93)								min16 = ::Math_obj::floor(c13);
            							}
            							else {
HXDLIN(  93)								min16 = ::Math_obj::floor(b20);
            							}
HXDLIN(  93)							int ii_min30 = min16;
HXDLIN(  93)							int ii_max30 = ::Math_obj::ceil(a16);
HXDLIN(  93)							v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            						}
            						else {
HXDLIN(  93)							int ii_min31 = ::Math_obj::floor(b20);
HXDLIN(  93)							int ii_max31 = ::Math_obj::ceil(c13);
HXDLIN(  93)							v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            						}
            					}
            					else {
HXDLIN(  93)						if ((b20 > c13)) {
HXDLIN(  93)							int min17;
HXDLIN(  93)							if ((a16 > c13)) {
HXDLIN(  93)								min17 = ::Math_obj::floor(c13);
            							}
            							else {
HXDLIN(  93)								min17 = ::Math_obj::ceil(a16);
            							}
HXDLIN(  93)							int ii_min32 = min17;
HXDLIN(  93)							int ii_max32 = ::Math_obj::ceil(b20);
HXDLIN(  93)							v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min32,ii_max32);
            						}
            						else {
HXDLIN(  93)							int ii_min33 = ::Math_obj::floor(a16);
HXDLIN(  93)							int ii_max33 = ::Math_obj::ceil(c13);
HXDLIN(  93)							v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min33,ii_max33);
            						}
            					}
            				}
HXDLIN(  93)				if (hasUndo1) {
HXDLIN(  93)					v_undoImage1 = undoImage3;
HXDLIN(  93)					v_undoX1 = xIter31->start;
HXDLIN(  93)					v_undoY1 = yIter31->start;
            				}
            			}
            		}
HXDLIN(  93)		bool _hx_tmp20;
HXDLIN(  93)		if (::hx::IsNotNull( nextImage->mask )) {
HXDLIN(  93)			_hx_tmp20 = includeMask;
            		}
            		else {
HXDLIN(  93)			_hx_tmp20 = false;
            		}
HXDLIN(  93)		if (_hx_tmp20) {
HXDLIN(  93)			 ::pi_xy::ImageStruct v7 = ::pi_xy::imageAbstracts::_TransformImage::TransformImage_Impl__obj::rotate(this1->mask,theta,centreX1,centreY1,this1->mask->transparent,includeMask);
HXDLIN(  93)			nextImage->useMask = true;
HXDLIN(  93)			nextImage->mask = v7;
            		}
HXDLIN(  93)		return nextImage;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(TransformImage_Impl__obj,rotate,return )

 ::pi_xy::ImageStruct TransformImage_Impl__obj::scaleUpInt( ::pi_xy::ImageStruct this1,::hx::Null< int >  __o_scaleW,::hx::Null< int >  __o_scaleH,::hx::Null< bool >  __o_transparent,::hx::Null< bool >  __o_includeMask){
            		int scaleW = __o_scaleW.Default(2);
            		int scaleH = __o_scaleH.Default(2);
            		bool transparent = __o_transparent.Default(false);
            		bool includeMask = __o_includeMask.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_68d25436a32dba6f_100_scaleUpInt)
HXDLIN( 100)		int p = 0;
HXDLIN( 100)		int xx = p;
HXDLIN( 100)		int q = 0;
HXDLIN( 100)		int wNew = ::Std_obj::_hx_int(( (Float)((this1->width * scaleW)) ));
HXDLIN( 100)		int hNew = ::Std_obj::_hx_int(( (Float)((this1->height * scaleH)) ));
HXDLIN( 100)		 ::Dynamic imageType = null();
HXDLIN( 100)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 100)		if (::hx::IsNull( imageType )) {
HXDLIN( 100)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXDLIN( 100)		::Dynamic _hx_tmp;
HXDLIN( 100)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXDLIN( 100)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 100)				 ::iterMagic::BytesImg b = byt;
HXDLIN( 100)				{
HXDLIN( 100)					b->width = wNew;
HXDLIN( 100)					b->height = hNew;
HXDLIN( 100)					b->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN( 100)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 100)					{
HXDLIN( 100)						int len = b->length;
HXDLIN( 100)						int w = 0;
HXDLIN( 100)						{
HXDLIN( 100)							int _g = 0;
HXDLIN( 100)							int _g1 = b->height;
HXDLIN( 100)							while((_g < _g1)){
HXDLIN( 100)								_g = (_g + 1);
HXDLIN( 100)								int y = (_g - 1);
HXDLIN( 100)								{
HXDLIN( 100)									int _g2 = 0;
HXDLIN( 100)									int _g3 = b->width;
HXDLIN( 100)									while((_g2 < _g3)){
HXDLIN( 100)										_g2 = (_g2 + 1);
HXDLIN( 100)										int x = (_g2 - 1);
HXDLIN( 100)										{
HXDLIN( 100)											w = (w + 1);
HXDLIN( 100)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 100)										{
HXDLIN( 100)											w = (w + 1);
HXDLIN( 100)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 100)										{
HXDLIN( 100)											w = (w + 1);
HXDLIN( 100)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 100)										{
HXDLIN( 100)											w = (w + 1);
HXDLIN( 100)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 100)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXDLIN( 100)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 100)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 100)				{
HXDLIN( 100)					a->width = wNew;
HXDLIN( 100)					a->height = hNew;
HXDLIN( 100)					a->data = ::Array_obj< int >::__new(0);
HXDLIN( 100)					a->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN( 100)					{
HXDLIN( 100)						int _g4 = 0;
HXDLIN( 100)						int _g5 = a->length;
HXDLIN( 100)						while((_g4 < _g5)){
HXDLIN( 100)							_g4 = (_g4 + 1);
HXDLIN( 100)							int i = (_g4 - 1);
HXDLIN( 100)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN( 100)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXDLIN( 100)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 100)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 100)				{
HXDLIN( 100)					b1->width = wNew;
HXDLIN( 100)					b1->height = hNew;
HXDLIN( 100)					b1->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN( 100)					int size = (b1->length * 4);
HXDLIN( 100)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 100)					{
HXDLIN( 100)						int _g6 = 0;
HXDLIN( 100)						int _g7 = b1->length;
HXDLIN( 100)						while((_g6 < _g7)){
HXDLIN( 100)							_g6 = (_g6 + 1);
HXDLIN( 100)							int i1 = (_g6 - 1);
HXDLIN( 100)							{
HXDLIN( 100)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 100)								bool _hx_tmp1;
HXDLIN( 100)								if ((i1 >= 0)) {
HXDLIN( 100)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXDLIN( 100)									_hx_tmp1 = false;
            								}
HXDLIN( 100)								if (_hx_tmp1) {
HXDLIN( 100)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 100)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 100)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 100)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 100)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 100)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN( 100)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXDLIN( 100)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 100)				 ::iterMagic::VecIntImg v = vec;
HXDLIN( 100)				{
HXDLIN( 100)					v->width = wNew;
HXDLIN( 100)					v->height = hNew;
HXDLIN( 100)					v->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN( 100)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 100)					{
HXDLIN( 100)						int _g8 = 0;
HXDLIN( 100)						int _g9 = v->length;
HXDLIN( 100)						while((_g8 < _g9)){
HXDLIN( 100)							_g8 = (_g8 + 1);
HXDLIN( 100)							int i2 = (_g8 - 1);
HXDLIN( 100)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN( 100)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXDLIN( 100)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 100)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 100)				{
HXDLIN( 100)					b2->width = wNew;
HXDLIN( 100)					b2->height = hNew;
HXDLIN( 100)					b2->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN( 100)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 100)					{
HXDLIN( 100)						int len1 = b2->length;
HXDLIN( 100)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 100)						if (::hx::IsNull( d->head )) {
HXDLIN( 100)							int _g10 = 0;
HXDLIN( 100)							int _g11 = len1;
HXDLIN( 100)							while((_g10 < _g11)){
HXDLIN( 100)								_g10 = (_g10 + 1);
HXDLIN( 100)								int i3 = (_g10 - 1);
HXDLIN( 100)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXDLIN( 100)							int _g12 = 0;
HXDLIN( 100)							int _g13 = len1;
HXDLIN( 100)							while((_g12 < _g13)){
HXDLIN( 100)								_g12 = (_g12 + 1);
HXDLIN( 100)								int i4 = (_g12 - 1);
HXDLIN( 100)								{
HXDLIN( 100)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 100)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 100)									{
HXDLIN( 100)										int _g14 = 0;
HXDLIN( 100)										int _g15 = i4;
HXDLIN( 100)										while((_g14 < _g15)){
HXDLIN( 100)											_g14 = (_g14 + 1);
HXDLIN( 100)											int i5 = (_g14 - 1);
HXDLIN( 100)											prev = l;
HXDLIN( 100)											l = l->next;
            										}
            									}
HXDLIN( 100)									if (::hx::IsNull( prev )) {
HXDLIN( 100)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 100)										l = null();
            									}
            									else {
HXDLIN( 100)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 100)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 100)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN( 100)		this2->image = _hx_tmp;
HXDLIN( 100)		this2->width = wNew;
HXDLIN( 100)		this2->height = hNew;
HXDLIN( 100)		this2->imageType = ( (int)(imageType) );
HXDLIN( 100)		 ::pi_xy::ImageStruct nextImage = this2;
HXDLIN( 100)		int maxX = wNew;
HXDLIN( 100)		int maxY = hNew;
HXDLIN( 100)		do {
HXDLIN( 100)			int x1 = ::Std_obj::_hx_int((( (Float)(p) ) / ( (Float)(scaleW) )));
HXDLIN( 100)			int y1 = ::Std_obj::_hx_int((( (Float)(q) ) / ( (Float)(scaleH) )));
HXDLIN( 100)			::Dynamic this4 = this1->image;
HXDLIN( 100)			int index;
HXDLIN( 100)			if (this1->useVirtualPos) {
HXDLIN( 100)				index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this1->virtualY) * ( (Float)(this1->width) )) + x1) - this1->virtualX));
            			}
            			else {
HXDLIN( 100)				index = ::Std_obj::_hx_int(( (Float)(((y1 * this1->width) + x1)) ));
            			}
HXDLIN( 100)			int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN( 100)			int color;
HXDLIN( 100)			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 100)				color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            			}
            			else {
HXDLIN( 100)				color = c;
            			}
HXDLIN( 100)			{
HXDLIN( 100)				p = (p + 1);
HXDLIN( 100)				int x2 = (p - 1);
HXDLIN( 100)				int c1 = color;
HXDLIN( 100)				bool _hx_tmp2;
HXDLIN( 100)				if ((((c1 >> 24) & 255) < 254)) {
HXDLIN( 100)					_hx_tmp2 = nextImage->transparent;
            				}
            				else {
HXDLIN( 100)					_hx_tmp2 = false;
            				}
HXDLIN( 100)				if (_hx_tmp2) {
HXDLIN( 100)					int location;
HXDLIN( 100)					if (nextImage->useVirtualPos) {
HXDLIN( 100)						location = ::Std_obj::_hx_int(((((( (Float)(q) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x2) - nextImage->virtualX));
            					}
            					else {
HXDLIN( 100)						location = ::Std_obj::_hx_int(( (Float)(((q * nextImage->width) + x2)) ));
            					}
HXDLIN( 100)					int this5 = ::iterMagic::Iimg_obj::get(nextImage->image,location);
HXDLIN( 100)					int this6;
HXDLIN( 100)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 100)						this6 = ((((((this5 >> 24) & 255) << 24) | ((this5 & 255) << 16)) | (((this5 >> 8) & 255) << 8)) | ((this5 >> 16) & 255));
            					}
            					else {
HXDLIN( 100)						this6 = this5;
            					}
HXDLIN( 100)					Float a1;
HXDLIN( 100)					int this7 = ((this6 >> 24) & 255);
HXDLIN( 100)					if ((this7 == 0)) {
HXDLIN( 100)						a1 = ((Float)0.);
            					}
            					else {
HXDLIN( 100)						a1 = (( (Float)(this7) ) / ( (Float)(255) ));
            					}
HXDLIN( 100)					Float r1;
HXDLIN( 100)					int this8 = ((this6 >> 16) & 255);
HXDLIN( 100)					if ((this8 == 0)) {
HXDLIN( 100)						r1 = ((Float)0.);
            					}
            					else {
HXDLIN( 100)						r1 = (( (Float)(this8) ) / ( (Float)(255) ));
            					}
HXDLIN( 100)					Float g1;
HXDLIN( 100)					int this9 = ((this6 >> 8) & 255);
HXDLIN( 100)					if ((this9 == 0)) {
HXDLIN( 100)						g1 = ((Float)0.);
            					}
            					else {
HXDLIN( 100)						g1 = (( (Float)(this9) ) / ( (Float)(255) ));
            					}
HXDLIN( 100)					Float b11;
HXDLIN( 100)					int this10 = (this6 & 255);
HXDLIN( 100)					if ((this10 == 0)) {
HXDLIN( 100)						b11 = ((Float)0.);
            					}
            					else {
HXDLIN( 100)						b11 = (( (Float)(this10) ) / ( (Float)(255) ));
            					}
HXDLIN( 100)					Float a2;
HXDLIN( 100)					int this11 = ((color >> 24) & 255);
HXDLIN( 100)					if ((this11 == 0)) {
HXDLIN( 100)						a2 = ((Float)0.);
            					}
            					else {
HXDLIN( 100)						a2 = (( (Float)(this11) ) / ( (Float)(255) ));
            					}
HXDLIN( 100)					Float r2;
HXDLIN( 100)					int this12 = ((color >> 16) & 255);
HXDLIN( 100)					if ((this12 == 0)) {
HXDLIN( 100)						r2 = ((Float)0.);
            					}
            					else {
HXDLIN( 100)						r2 = (( (Float)(this12) ) / ( (Float)(255) ));
            					}
HXDLIN( 100)					Float g2;
HXDLIN( 100)					int this13 = ((color >> 8) & 255);
HXDLIN( 100)					if ((this13 == 0)) {
HXDLIN( 100)						g2 = ((Float)0.);
            					}
            					else {
HXDLIN( 100)						g2 = (( (Float)(this13) ) / ( (Float)(255) ));
            					}
HXDLIN( 100)					Float b21;
HXDLIN( 100)					int this14 = (color & 255);
HXDLIN( 100)					if ((this14 == 0)) {
HXDLIN( 100)						b21 = ((Float)0.);
            					}
            					else {
HXDLIN( 100)						b21 = (( (Float)(this14) ) / ( (Float)(255) ));
            					}
HXDLIN( 100)					Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 100)					int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 100)					int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 100)					int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 100)					int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 100)					int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 100)					{
HXDLIN( 100)						int _hx_tmp3;
HXDLIN( 100)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 100)							_hx_tmp3 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            						}
            						else {
HXDLIN( 100)							_hx_tmp3 = blended;
            						}
HXDLIN( 100)						::iterMagic::Iimg_obj::set(nextImage->image,location,_hx_tmp3);
            					}
            				}
            				else {
HXDLIN( 100)					::Dynamic this15 = nextImage->image;
HXDLIN( 100)					int index1;
HXDLIN( 100)					if (nextImage->useVirtualPos) {
HXDLIN( 100)						index1 = ::Std_obj::_hx_int(((((( (Float)(q) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x2) - nextImage->virtualX));
            					}
            					else {
HXDLIN( 100)						index1 = ::Std_obj::_hx_int(( (Float)(((q * nextImage->width) + x2)) ));
            					}
HXDLIN( 100)					int _hx_tmp4;
HXDLIN( 100)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 100)						_hx_tmp4 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            					}
            					else {
HXDLIN( 100)						_hx_tmp4 = c1;
            					}
HXDLIN( 100)					::iterMagic::Iimg_obj::set(this15,index1,_hx_tmp4);
            				}
            			}
HXDLIN( 100)			if ((p > maxX)) {
HXDLIN( 100)				p = xx;
HXDLIN( 100)				q = (q + 1);
            			}
            		} while((q <= maxY));
;
HXDLIN( 100)		bool _hx_tmp5;
HXDLIN( 100)		if (::hx::IsNotNull( this1->mask )) {
HXDLIN( 100)			_hx_tmp5 = includeMask;
            		}
            		else {
HXDLIN( 100)			_hx_tmp5 = false;
            		}
HXDLIN( 100)		if (_hx_tmp5) {
HXDLIN( 100)			 ::pi_xy::ImageStruct v1 = ::pi_xy::transformation::_ScaleImage::ScaleImage_Fields__obj::scaleUpInteger(this1->mask,scaleW,scaleH,this1->mask->transparent,includeMask);
HXDLIN( 100)			nextImage->useMask = true;
HXDLIN( 100)			nextImage->mask = v1;
            		}
HXDLIN( 100)		return nextImage;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(TransformImage_Impl__obj,scaleUpInt,return )


TransformImage_Impl__obj::TransformImage_Impl__obj()
{
}

bool TransformImage_Impl__obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"_new") ) { outValue = _new_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"rotate") ) { outValue = rotate_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"spun180") ) { outValue = spun180_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"scaleXY") ) { outValue = scaleXY_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"flippedX") ) { outValue = flippedX_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"flippedY") ) { outValue = flippedY_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"scaleMatch") ) { outValue = scaleMatch_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"scaleUpInt") ) { outValue = scaleUpInt_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"spunClock90") ) { outValue = spunClock90_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"spunAntiClock90") ) { outValue = spunAntiClock90_dyn(); return true; }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"rotateClockwiseDegrees") ) { outValue = rotateClockwiseDegrees_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"rotateClockwiseRadians") ) { outValue = rotateClockwiseRadians_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *TransformImage_Impl__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *TransformImage_Impl__obj_sStaticStorageInfo = 0;
#endif

::hx::Class TransformImage_Impl__obj::__mClass;

static ::String TransformImage_Impl__obj_sStaticFields[] = {
	HX_("_new",61,15,1f,3f),
	HX_("flippedX",d6,4d,d6,17),
	HX_("flippedY",d7,4d,d6,17),
	HX_("spunClock90",8f,99,65,3c),
	HX_("spunAntiClock90",0d,c7,89,d9),
	HX_("spun180",f3,78,d9,1c),
	HX_("scaleMatch",5b,f6,56,24),
	HX_("scaleXY",0b,52,07,65),
	HX_("rotateClockwiseDegrees",50,d8,88,3d),
	HX_("rotateClockwiseRadians",1b,3b,1e,2a),
	HX_("rotate",5b,46,20,cb),
	HX_("scaleUpInt",6a,36,55,c9),
	::String(null())
};

void TransformImage_Impl__obj::__register()
{
	TransformImage_Impl__obj _hx_dummy;
	TransformImage_Impl__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pi_xy.imageAbstracts._TransformImage.TransformImage_Impl_",80,93,f7,3c);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &TransformImage_Impl__obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(TransformImage_Impl__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< TransformImage_Impl__obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = TransformImage_Impl__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = TransformImage_Impl__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pi_xy
} // end namespace imageAbstracts
} // end namespace _TransformImage
