// Generated by Haxe 4.3.0-rc.1+
(function ($global) { "use strict";
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var HxOverrides = function() { };
HxOverrides.__name__ = "HxOverrides";
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.now = function() {
	return Date.now();
};
var IntIterator = function(min,max) {
	this.min = min;
	this.max = max;
};
IntIterator.__name__ = "IntIterator";
IntIterator.prototype = {
	hasNext: function() {
		return this.min < this.max;
	}
	,next: function() {
		return this.min++;
	}
	,__class__: IntIterator
};
Math.__name__ = "Math";
var Std = function() { };
Std.__name__ = "Std";
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	var v = parseInt(x);
	if(isNaN(v)) {
		return null;
	}
	return v;
};
var StringBuf = function() {
	this.b = "";
};
StringBuf.__name__ = "StringBuf";
StringBuf.prototype = {
	__class__: StringBuf
};
var StringTools = function() { };
StringTools.__name__ = "StringTools";
StringTools.htmlEscape = function(s,quotes) {
	var buf_b = "";
	var _g_offset = 0;
	var _g_s = s;
	while(_g_offset < _g_s.length) {
		var s = _g_s;
		var index = _g_offset++;
		var c = s.charCodeAt(index);
		if(c >= 55296 && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
		}
		var c1 = c;
		if(c1 >= 65536) {
			++_g_offset;
		}
		var code = c1;
		switch(code) {
		case 34:
			if(quotes) {
				buf_b += "&quot;";
			} else {
				buf_b += String.fromCodePoint(code);
			}
			break;
		case 38:
			buf_b += "&amp;";
			break;
		case 39:
			if(quotes) {
				buf_b += "&#039;";
			} else {
				buf_b += String.fromCodePoint(code);
			}
			break;
		case 60:
			buf_b += "&lt;";
			break;
		case 62:
			buf_b += "&gt;";
			break;
		default:
			buf_b += String.fromCodePoint(code);
		}
	}
	return buf_b;
};
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.hex = function(n,digits) {
	var s = "";
	var hexChars = "0123456789ABCDEF";
	while(true) {
		s = hexChars.charAt(n & 15) + s;
		n >>>= 4;
		if(!(n > 0)) {
			break;
		}
	}
	if(digits != null) {
		while(s.length < digits) s = "0" + s;
	}
	return s;
};
var XmlType = {};
XmlType.toString = function(this1) {
	switch(this1) {
	case 0:
		return "Element";
	case 1:
		return "PCData";
	case 2:
		return "CData";
	case 3:
		return "Comment";
	case 4:
		return "DocType";
	case 5:
		return "ProcessingInstruction";
	case 6:
		return "Document";
	}
};
var Xml = function(nodeType) {
	this.nodeType = nodeType;
	this.children = [];
	this.attributeMap = new haxe_ds_StringMap();
};
Xml.__name__ = "Xml";
Xml.parse = function(str) {
	return haxe_xml_Parser.parse(str);
};
Xml.createElement = function(name) {
	var xml = new Xml(Xml.Element);
	if(xml.nodeType != Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, expected Element but found " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeName = name;
	return xml;
};
Xml.createPCData = function(data) {
	var xml = new Xml(Xml.PCData);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createCData = function(data) {
	var xml = new Xml(Xml.CData);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createComment = function(data) {
	var xml = new Xml(Xml.Comment);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createDocType = function(data) {
	var xml = new Xml(Xml.DocType);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createProcessingInstruction = function(data) {
	var xml = new Xml(Xml.ProcessingInstruction);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createDocument = function() {
	return new Xml(Xml.Document);
};
Xml.prototype = {
	get: function(att) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return this.attributeMap.h[att];
	}
	,set: function(att,value) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		this.attributeMap.h[att] = value;
	}
	,exists: function(att) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return Object.prototype.hasOwnProperty.call(this.attributeMap.h,att);
	}
	,attributes: function() {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return new haxe_ds__$StringMap_StringMapKeyIterator(this.attributeMap.h);
	}
	,elements: function() {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = this.children;
		while(_g1 < _g2.length) {
			var child = _g2[_g1];
			++_g1;
			if(child.nodeType == Xml.Element) {
				_g.push(child);
			}
		}
		var ret = _g;
		return new haxe_iterators_ArrayIterator(ret);
	}
	,addChild: function(x) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		if(x.parent != null) {
			x.parent.removeChild(x);
		}
		this.children.push(x);
		x.parent = this;
	}
	,removeChild: function(x) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		if(HxOverrides.remove(this.children,x)) {
			x.parent = null;
			return true;
		}
		return false;
	}
	,toString: function() {
		return haxe_xml_Printer.print(this);
	}
	,__class__: Xml
};
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
haxe_Exception.__name__ = "haxe.Exception";
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	get_native: function() {
		return this.__nativeException;
	}
	,__class__: haxe_Exception
});
var haxe_Log = function() { };
haxe_Log.__name__ = "haxe.Log";
haxe_Log.formatOutput = function(v,infos) {
	var str = Std.string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			str += ", " + Std.string(v);
		}
	}
	return pstr + ": " + str;
};
haxe_Log.trace = function(v,infos) {
	var str = haxe_Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
haxe_ValueException.__name__ = "haxe.ValueException";
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
	__class__: haxe_ValueException
});
var haxe_ds_StringMap = function() {
	this.h = Object.create(null);
};
haxe_ds_StringMap.__name__ = "haxe.ds.StringMap";
haxe_ds_StringMap.prototype = {
	__class__: haxe_ds_StringMap
};
var haxe_ds__$StringMap_StringMapKeyIterator = function(h) {
	this.h = h;
	this.keys = Object.keys(h);
	this.length = this.keys.length;
	this.current = 0;
};
haxe_ds__$StringMap_StringMapKeyIterator.__name__ = "haxe.ds._StringMap.StringMapKeyIterator";
haxe_ds__$StringMap_StringMapKeyIterator.prototype = {
	hasNext: function() {
		return this.current < this.length;
	}
	,next: function() {
		return this.keys[this.current++];
	}
	,__class__: haxe_ds__$StringMap_StringMapKeyIterator
};
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator";
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
	,__class__: haxe_iterators_ArrayIterator
};
var haxe_xml_XmlParserException = function(message,xml,position) {
	this.xml = xml;
	this.message = message;
	this.position = position;
	this.lineNumber = 1;
	this.positionAtLine = 0;
	var _g = 0;
	var _g1 = position;
	while(_g < _g1) {
		var i = _g++;
		var c = xml.charCodeAt(i);
		if(c == 10) {
			this.lineNumber++;
			this.positionAtLine = 0;
		} else if(c != 13) {
			this.positionAtLine++;
		}
	}
};
haxe_xml_XmlParserException.__name__ = "haxe.xml.XmlParserException";
haxe_xml_XmlParserException.prototype = {
	toString: function() {
		var c = js_Boot.getClass(this);
		return c.__name__ + ": " + this.message + " at line " + this.lineNumber + " char " + this.positionAtLine;
	}
	,__class__: haxe_xml_XmlParserException
};
var haxe_xml_Parser = function() { };
haxe_xml_Parser.__name__ = "haxe.xml.Parser";
haxe_xml_Parser.parse = function(str,strict) {
	if(strict == null) {
		strict = false;
	}
	var doc = Xml.createDocument();
	haxe_xml_Parser.doParse(str,strict,0,doc);
	return doc;
};
haxe_xml_Parser.doParse = function(str,strict,p,parent) {
	if(p == null) {
		p = 0;
	}
	var xml = null;
	var state = 1;
	var next = 1;
	var aname = null;
	var start = 0;
	var nsubs = 0;
	var nbrackets = 0;
	var buf = new StringBuf();
	var escapeNext = 1;
	var attrValQuote = -1;
	while(p < str.length) {
		var c = str.charCodeAt(p);
		switch(state) {
		case 0:
			switch(c) {
			case 9:case 10:case 13:case 32:
				break;
			default:
				state = next;
				continue;
			}
			break;
		case 1:
			if(c == 60) {
				state = 0;
				next = 2;
			} else {
				start = p;
				state = 13;
				continue;
			}
			break;
		case 2:
			switch(c) {
			case 33:
				if(str.charCodeAt(p + 1) == 91) {
					p += 2;
					if(HxOverrides.substr(str,p,6).toUpperCase() != "CDATA[") {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected <![CDATA[",str,p));
					}
					p += 5;
					state = 17;
					start = p + 1;
				} else if(str.charCodeAt(p + 1) == 68 || str.charCodeAt(p + 1) == 100) {
					if(HxOverrides.substr(str,p + 2,6).toUpperCase() != "OCTYPE") {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected <!DOCTYPE",str,p));
					}
					p += 8;
					state = 16;
					start = p + 1;
				} else if(str.charCodeAt(p + 1) != 45 || str.charCodeAt(p + 2) != 45) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected <!--",str,p));
				} else {
					p += 2;
					state = 15;
					start = p + 1;
				}
				break;
			case 47:
				if(parent == null) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected node name",str,p));
				}
				start = p + 1;
				state = 0;
				next = 10;
				break;
			case 63:
				state = 14;
				start = p;
				break;
			default:
				state = 3;
				start = p;
				continue;
			}
			break;
		case 3:
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
				if(p == start) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected node name",str,p));
				}
				xml = Xml.createElement(HxOverrides.substr(str,start,p - start));
				parent.addChild(xml);
				++nsubs;
				state = 0;
				next = 4;
				continue;
			}
			break;
		case 4:
			switch(c) {
			case 47:
				state = 11;
				break;
			case 62:
				state = 9;
				break;
			default:
				state = 5;
				start = p;
				continue;
			}
			break;
		case 5:
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
				if(start == p) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected attribute name",str,p));
				}
				var tmp = HxOverrides.substr(str,start,p - start);
				aname = tmp;
				if(xml.exists(aname)) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Duplicate attribute [" + aname + "]",str,p));
				}
				state = 0;
				next = 6;
				continue;
			}
			break;
		case 6:
			if(c == 61) {
				state = 0;
				next = 7;
			} else {
				throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected =",str,p));
			}
			break;
		case 7:
			switch(c) {
			case 34:case 39:
				buf = new StringBuf();
				state = 8;
				start = p + 1;
				attrValQuote = c;
				break;
			default:
				throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected \"",str,p));
			}
			break;
		case 8:
			switch(c) {
			case 38:
				var len = p - start;
				buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
				state = 18;
				escapeNext = 8;
				start = p + 1;
				break;
			case 60:case 62:
				if(strict) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Invalid unescaped " + String.fromCodePoint(c) + " in attribute value",str,p));
				} else if(c == attrValQuote) {
					var len1 = p - start;
					buf.b += len1 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len1);
					var val = buf.b;
					buf = new StringBuf();
					xml.set(aname,val);
					state = 0;
					next = 4;
				}
				break;
			default:
				if(c == attrValQuote) {
					var len2 = p - start;
					buf.b += len2 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len2);
					var val1 = buf.b;
					buf = new StringBuf();
					xml.set(aname,val1);
					state = 0;
					next = 4;
				}
			}
			break;
		case 9:
			p = haxe_xml_Parser.doParse(str,strict,p,xml);
			start = p;
			state = 1;
			break;
		case 10:
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
				if(start == p) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected node name",str,p));
				}
				var v = HxOverrides.substr(str,start,p - start);
				if(parent == null || parent.nodeType != 0) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Unexpected </" + v + ">, tag is not open",str,p));
				}
				if(parent.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (parent.nodeType == null ? "null" : XmlType.toString(parent.nodeType)));
				}
				if(v != parent.nodeName) {
					if(parent.nodeType != Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, expected Element but found " + (parent.nodeType == null ? "null" : XmlType.toString(parent.nodeType)));
					}
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected </" + parent.nodeName + ">",str,p));
				}
				state = 0;
				next = 12;
				continue;
			}
			break;
		case 11:
			if(c == 62) {
				state = 1;
			} else {
				throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected >",str,p));
			}
			break;
		case 12:
			if(c == 62) {
				if(nsubs == 0) {
					parent.addChild(Xml.createPCData(""));
				}
				return p;
			} else {
				throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected >",str,p));
			}
			break;
		case 13:
			if(c == 60) {
				var len3 = p - start;
				buf.b += len3 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len3);
				var child = Xml.createPCData(buf.b);
				buf = new StringBuf();
				parent.addChild(child);
				++nsubs;
				state = 0;
				next = 2;
			} else if(c == 38) {
				var len4 = p - start;
				buf.b += len4 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len4);
				state = 18;
				escapeNext = 13;
				start = p + 1;
			}
			break;
		case 14:
			if(c == 63 && str.charCodeAt(p + 1) == 62) {
				++p;
				var str1 = HxOverrides.substr(str,start + 1,p - start - 2);
				parent.addChild(Xml.createProcessingInstruction(str1));
				++nsubs;
				state = 1;
			}
			break;
		case 15:
			if(c == 45 && str.charCodeAt(p + 1) == 45 && str.charCodeAt(p + 2) == 62) {
				parent.addChild(Xml.createComment(HxOverrides.substr(str,start,p - start)));
				++nsubs;
				p += 2;
				state = 1;
			}
			break;
		case 16:
			if(c == 91) {
				++nbrackets;
			} else if(c == 93) {
				--nbrackets;
			} else if(c == 62 && nbrackets == 0) {
				parent.addChild(Xml.createDocType(HxOverrides.substr(str,start,p - start)));
				++nsubs;
				state = 1;
			}
			break;
		case 17:
			if(c == 93 && str.charCodeAt(p + 1) == 93 && str.charCodeAt(p + 2) == 62) {
				var child1 = Xml.createCData(HxOverrides.substr(str,start,p - start));
				parent.addChild(child1);
				++nsubs;
				p += 2;
				state = 1;
			}
			break;
		case 18:
			if(c == 59) {
				var s = HxOverrides.substr(str,start,p - start);
				if(s.charCodeAt(0) == 35) {
					var c1 = s.charCodeAt(1) == 120 ? Std.parseInt("0" + HxOverrides.substr(s,1,s.length - 1)) : Std.parseInt(HxOverrides.substr(s,1,s.length - 1));
					buf.b += String.fromCodePoint(c1);
				} else if(!Object.prototype.hasOwnProperty.call(haxe_xml_Parser.escapes.h,s)) {
					if(strict) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Undefined entity: " + s,str,p));
					}
					buf.b += Std.string("&" + s + ";");
				} else {
					buf.b += Std.string(haxe_xml_Parser.escapes.h[s]);
				}
				start = p + 1;
				state = escapeNext;
			} else if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45) && c != 35) {
				if(strict) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Invalid character in entity: " + String.fromCodePoint(c),str,p));
				}
				buf.b += String.fromCodePoint(38);
				var len5 = p - start;
				buf.b += len5 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len5);
				--p;
				start = p + 1;
				state = escapeNext;
			}
			break;
		}
		++p;
	}
	if(state == 1) {
		start = p;
		state = 13;
	}
	if(state == 13) {
		if(parent.nodeType == 0) {
			if(parent.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (parent.nodeType == null ? "null" : XmlType.toString(parent.nodeType)));
			}
			throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Unclosed node <" + parent.nodeName + ">",str,p));
		}
		if(p != start || nsubs == 0) {
			var len = p - start;
			buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
			parent.addChild(Xml.createPCData(buf.b));
			++nsubs;
		}
		return p;
	}
	if(!strict && state == 18 && escapeNext == 13) {
		buf.b += String.fromCodePoint(38);
		var len = p - start;
		buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
		parent.addChild(Xml.createPCData(buf.b));
		++nsubs;
		return p;
	}
	throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Unexpected end",str,p));
};
var haxe_xml_Printer = function(pretty) {
	this.output = new StringBuf();
	this.pretty = pretty;
};
haxe_xml_Printer.__name__ = "haxe.xml.Printer";
haxe_xml_Printer.print = function(xml,pretty) {
	if(pretty == null) {
		pretty = false;
	}
	var printer = new haxe_xml_Printer(pretty);
	printer.writeNode(xml,"");
	return printer.output.b;
};
haxe_xml_Printer.prototype = {
	writeNode: function(value,tabs) {
		switch(value.nodeType) {
		case 0:
			this.output.b += Std.string(tabs + "<");
			if(value.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string(value.nodeName);
			var attribute = value.attributes();
			while(attribute.hasNext()) {
				var attribute1 = attribute.next();
				this.output.b += Std.string(" " + attribute1 + "=\"");
				var input = StringTools.htmlEscape(value.get(attribute1),true);
				this.output.b += Std.string(input);
				this.output.b += "\"";
			}
			if(this.hasChildren(value)) {
				this.output.b += ">";
				if(this.pretty) {
					this.output.b += "\n";
				}
				if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
				}
				var _g_current = 0;
				var _g_array = value.children;
				while(_g_current < _g_array.length) {
					var child = _g_array[_g_current++];
					this.writeNode(child,this.pretty ? tabs + "\t" : tabs);
				}
				this.output.b += Std.string(tabs + "</");
				if(value.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
				}
				this.output.b += Std.string(value.nodeName);
				this.output.b += ">";
				if(this.pretty) {
					this.output.b += "\n";
				}
			} else {
				this.output.b += "/>";
				if(this.pretty) {
					this.output.b += "\n";
				}
			}
			break;
		case 1:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			var nodeValue = value.nodeValue;
			if(nodeValue.length != 0) {
				var input = tabs + StringTools.htmlEscape(nodeValue);
				this.output.b += Std.string(input);
				if(this.pretty) {
					this.output.b += "\n";
				}
			}
			break;
		case 2:
			this.output.b += Std.string(tabs + "<![CDATA[");
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string(value.nodeValue);
			this.output.b += "]]>";
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 3:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			var commentContent = value.nodeValue;
			var _this_r = new RegExp("[\n\r\t]+","g".split("u").join(""));
			commentContent = commentContent.replace(_this_r,"");
			commentContent = "<!--" + commentContent + "-->";
			this.output.b += tabs == null ? "null" : "" + tabs;
			var input = StringTools.trim(commentContent);
			this.output.b += Std.string(input);
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 4:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string("<!DOCTYPE " + value.nodeValue + ">");
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 5:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string("<?" + value.nodeValue + "?>");
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 6:
			if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			var _g_current = 0;
			var _g_array = value.children;
			while(_g_current < _g_array.length) {
				var child = _g_array[_g_current++];
				this.writeNode(child,tabs);
			}
			break;
		}
	}
	,hasChildren: function(value) {
		if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
		}
		var _g_current = 0;
		var _g_array = value.children;
		while(_g_current < _g_array.length) {
			var child = _g_array[_g_current++];
			switch(child.nodeType) {
			case 0:case 1:
				return true;
			case 2:case 3:
				if(child.nodeType == Xml.Document || child.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (child.nodeType == null ? "null" : XmlType.toString(child.nodeType)));
				}
				if(StringTools.ltrim(child.nodeValue).length != 0) {
					return true;
				}
				break;
			default:
			}
		}
		return false;
	}
	,__class__: haxe_xml_Printer
};
var htmlHelper_canvas_CanvasSetup = function() {
	this.factor = 4.;
	this.divertTrace = new htmlHelper_tools_DivertTrace();
	var e = null;
	var this1;
	if(e == null) {
		var canvas = window.document.createElement("canvas");
		var dom = canvas;
		var style = dom.style;
		style.paddingLeft = "0px";
		style.paddingTop = "0px";
		style.left = "0px";
		style.top = "0px";
		style.position = "absolute";
		this1 = canvas;
	} else {
		this1 = e;
	}
	this.canvasWrapper = this1;
	this.canvasWrapper.width = 1024;
	this.canvasWrapper.height = 768;
	var dom = this.canvasWrapper;
	var style = dom.style;
	style.background = "black";
	window.document.body.appendChild(this.canvasWrapper);
	var this1 = new htmlHelper_canvas_CanvasPlus(this.canvasWrapper.getContext("2d",null),10,10);
	this1.me.lineWidth = 1;
	var tmp = StringTools.hex(16744272,6);
	this1.me.strokeStyle = "#" + tmp;
	this.surface = this1;
	this.overSampleCanvas();
};
htmlHelper_canvas_CanvasSetup.__name__ = "htmlHelper.canvas.CanvasSetup";
htmlHelper_canvas_CanvasSetup.prototype = {
	overSampleCanvas: function() {
		var ctx = this.surface.me;
		var canvas = this.canvasWrapper;
		var width = canvas.width;
		var height = canvas.height;
		canvas.width = 0 | (width * this.factor | 0);
		canvas.height = 0 | (height * this.factor | 0);
		var dom = this.canvasWrapper;
		var style = dom.style;
		style.width = width + "px";
		style.height = height + "px";
		ctx.scale(this.factor,this.factor);
	}
	,__class__: htmlHelper_canvas_CanvasSetup
};
var htmlHelper_canvas_CanvasPlus = function(me,x,y) {
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.y = 0.;
	this.x = 0.;
	this.x = x;
	this.y = y;
	this.me = me;
};
htmlHelper_canvas_CanvasPlus.__name__ = "htmlHelper.canvas.CanvasPlus";
htmlHelper_canvas_CanvasPlus.prototype = {
	__class__: htmlHelper_canvas_CanvasPlus
};
var htmlHelper_tools_DivertTrace = function(left,d) {
	if(left == null) {
		left = 610;
	}
	this.textStyle1 = "<span style=\"font-size:14px; color:Grey\">";
	this.textStyle0 = "<span style=\"font-size:12px; color:Silver\">";
	this.traceString = "";
	this.divertTrace(left,d);
};
htmlHelper_tools_DivertTrace.__name__ = "htmlHelper.tools.DivertTrace";
htmlHelper_tools_DivertTrace.prototype = {
	divertTrace: function(left,d) {
		if(d == null) {
			var doc = window.document;
			this.traceDiv = doc.createElement("div");
			doc.body.appendChild(this.traceDiv);
			var dom = this.traceDiv;
			var style = dom.style;
			style.position = "absolute";
			style.top = "0px";
			style.left = (left == null ? "null" : "" + left) + "px";
			style.height = "500px";
			style.width = "500px";
			style.zIndex = "99";
			style.overflow = "auto";
		} else {
			this.traceDiv = d;
		}
		haxe_Log.trace = $bind(this,this.myTrace);
	}
	,myTrace: function(v,inf) {
		if(Std.string(v) == "") {
			return;
		}
		this.traceString += this.textStyle0 + inf.className + "." + inf.methodName + " ( " + (inf.lineNumber == null ? "null" : "" + inf.lineNumber) + " )" + "</span>" + "<br> - " + this.textStyle1 + Std.string(v) + "</span>" + "<br>";
		this.traceDiv.innerHTML = this.traceString;
	}
	,__class__: htmlHelper_tools_DivertTrace
};
var js_Boot = function() { };
js_Boot.__name__ = "js.Boot";
js_Boot.getClass = function(o) {
	if(o == null) {
		return null;
	} else if(((o) instanceof Array)) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var pixelimage_DemoUse = function() {
	this.canvasSetup = new htmlHelper_canvas_CanvasSetup();
	haxe_Log.trace("Pixelimage example on Canvas",{ fileName : "src/pixelimage/DemoUse.hx", lineNumber : 19, className : "pixelimage.DemoUse", methodName : "new"});
	var g = this.canvasSetup.surface;
	var this1 = new Uint32Array(12582912);
	var this2 = new pixelimage_ImageStruct(4096,3072,this1);
	var this1 = this2;
	var p = this1;
	p.transparent = true;
	pixelimage_Pixelimage.setRelativePosition(p,0,0);
	var _this = Xml.parse(pixelimage_shapeStruct_XMLshapeSamples_circleTest);
	if(_this.nodeType != Xml.Document && _this.nodeType != Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (_this.nodeType == null ? "null" : XmlType.toString(_this.nodeType)));
	}
	var xml = _this.children[0];
	new pixelimage_shapeStruct_XMLshape(p,xml);
	var ctx = g.me;
	if(p.useMask && p.mask != null) {
		var w = p.width;
		var h = p.height;
		var this1 = new Uint32Array(w * h | 0);
		var this2 = new pixelimage_ImageStruct(w,h,this1);
		var temp = this2;
		var _g = 0;
		var _g1 = p.image.length;
		while(_g < _g1) {
			var i = _g++;
			var this1 = p.image[i];
			var p0 = this1;
			var this2 = p.mask.image[i];
			var m1 = this2;
			var value;
			if(m1 == 0) {
				var this3 = p0;
				value = this3;
			} else {
				var this4 = m1 >> 24 & 255;
				var m0 = this4 == 0 ? 0. : this4 / 255;
				var this5 = m1 >> 16 & 255;
				var m11 = this5 == 0 ? 0. : this5 / 255;
				var this6 = m1 >> 8 & 255;
				var m2 = this6 == 0 ? 0. : this6 / 255;
				var this7 = m1 & 255;
				var m3 = this7 == 0 ? 0. : this7 / 255;
				var ch0 = (1. - m0) * (p0 >> 24 & 255) | 0;
				var ch1 = (1. - m11) * (p0 >> 16 & 255) | 0;
				var ch2 = (1. - m2) * (p0 >> 8 & 255) | 0;
				var ch3 = (1. - m3) * (p0 & 255) | 0;
				value = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
			}
			temp.image[i] = value;
		}
		var dataimg = temp.image;
		var data = new Uint8ClampedArray(new Uint8Array(dataimg.buffer).buffer);
		var imageData = new ImageData(data,p.width,p.height);
		if(p.useVirtualPos) {
			ctx.putImageData(imageData,0 - p.virtualX,0 - p.virtualY);
		} else {
			ctx.putImageData(imageData,0,0);
		}
	} else {
		var dataimg = p.image;
		var data = new Uint8ClampedArray(new Uint8Array(dataimg.buffer).buffer);
		var imageData = new ImageData(data,p.width,p.height);
		if(p.useVirtualPos) {
			ctx.putImageData(imageData,0 - p.virtualX,0 - p.virtualY);
		} else {
			ctx.putImageData(imageData,0,0);
		}
	}
};
pixelimage_DemoUse.__name__ = "pixelimage.DemoUse";
pixelimage_DemoUse.prototype = {
	__class__: pixelimage_DemoUse
};
function pixelimage_DemoUse_main() {
	new pixelimage_DemoUse();
}
var pixelimage_ImageStruct = function(width,height,image) {
	this.useMask = false;
	this.useVirtualPos = false;
	this.virtualY = 0;
	this.virtualX = 0;
	this.transparent = false;
	this.width = width;
	this.height = height;
	this.image = image;
	this.isLittle = pixelimage_Endian_isLittleEndian;
	this.transparent = false;
};
pixelimage_ImageStruct.__name__ = "pixelimage.ImageStruct";
pixelimage_ImageStruct.prototype = {
	__class__: pixelimage_ImageStruct
};
var pixelimage_Pixelimage = {};
pixelimage_Pixelimage.setRelativePosition = function(this1,x,y,update) {
	if(update == null) {
		update = false;
	}
	this1.useVirtualPos = true;
	if(x < 0) {
		x = 0;
	}
	if(y < 0) {
		y = 0;
	}
	this1.virtualX = x;
	this1.virtualY = y;
};
var pixelimage_iter_IntIterStart = function(min_,max_) {
	this.start = min_;
	this.max = max_;
};
pixelimage_iter_IntIterStart.__name__ = "pixelimage.iter.IntIterStart";
pixelimage_iter_IntIterStart.prototype = {
	__class__: pixelimage_iter_IntIterStart
};
var pixelimage_shapeStruct_GroupShape = function(opacity,visibility) {
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	this.visibility = visibility;
	this.opacity = opacity;
};
pixelimage_shapeStruct_GroupShape.__name__ = "pixelimage.shapeStruct.GroupShape";
pixelimage_shapeStruct_GroupShape.prototype = {
	setParameter: function(name,value) {
		switch(name) {
		case "opacity":
			this.opacity = parseFloat(value);
			break;
		case "visibility":
			this.visibility = value.toLowerCase() == "true";
			break;
		default:
			haxe_Log.trace("property not found",{ fileName : "src/pixelimage/shapeStruct/GroupShape.hx", lineNumber : 20, className : "pixelimage.shapeStruct.GroupShape", methodName : "setParameter"});
		}
	}
	,render: function(pixelImage) {
	}
	,__class__: pixelimage_shapeStruct_GroupShape
};
var pixelimage_shapeStruct_BasicGradient = function(opacity,visibility,cornerColors) {
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	this.cornerColors = [];
	pixelimage_shapeStruct_GroupShape.call(this,opacity,visibility);
	if(cornerColors != null) {
		this.cornerColors = cornerColors;
	}
};
pixelimage_shapeStruct_BasicGradient.__name__ = "pixelimage.shapeStruct.BasicGradient";
pixelimage_shapeStruct_BasicGradient.__super__ = pixelimage_shapeStruct_GroupShape;
pixelimage_shapeStruct_BasicGradient.prototype = $extend(pixelimage_shapeStruct_GroupShape.prototype,{
	setParameter: function(name,value) {
		if(name == "cornerColors") {
			value = value.split("[")[1].split("]")[0];
			var _g = [];
			var _g1 = 0;
			var _g2 = value.split(",");
			while(_g1 < _g2.length) {
				var n = _g2[_g1];
				++_g1;
				_g.push(Std.parseInt(n));
			}
			this.cornerColors = _g;
		} else {
			pixelimage_shapeStruct_GroupShape.prototype.setParameter.call(this,name,value);
		}
	}
	,__class__: pixelimage_shapeStruct_BasicGradient
});
var pixelimage_shapeStruct_BasicShape = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray) {
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = 0;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pixelimage_shapeStruct_GroupShape.call(this,opacity,visibility);
	this.strokeColor = strokeColor;
	this.strokeWidth = strokeWidth;
	this.strokeDashGapArray = strokeDashGapArray;
};
pixelimage_shapeStruct_BasicShape.__name__ = "pixelimage.shapeStruct.BasicShape";
pixelimage_shapeStruct_BasicShape.__super__ = pixelimage_shapeStruct_GroupShape;
pixelimage_shapeStruct_BasicShape.prototype = $extend(pixelimage_shapeStruct_GroupShape.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "strokeColor":
			this.strokeColor = Std.parseInt(value);
			break;
		case "strokeDashGapArray":
			this.strokeDashGapArray = null;
			break;
		case "strokeWidth":
			this.strokeWidth = parseFloat(value);
			break;
		default:
			pixelimage_shapeStruct_GroupShape.prototype.setParameter.call(this,name,value);
		}
	}
	,__class__: pixelimage_shapeStruct_BasicShape
});
var pixelimage_shapeStruct_FillShape = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill) {
	if(fill == null) {
		fill = 0;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = 0;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pixelimage_shapeStruct_BasicShape.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray);
	this.fill = fill;
};
pixelimage_shapeStruct_FillShape.__name__ = "pixelimage.shapeStruct.FillShape";
pixelimage_shapeStruct_FillShape.__super__ = pixelimage_shapeStruct_BasicShape;
pixelimage_shapeStruct_FillShape.prototype = $extend(pixelimage_shapeStruct_BasicShape.prototype,{
	setParameter: function(name,value) {
		if(name == "fill") {
			this.fill = Std.parseInt(value);
		} else {
			pixelimage_shapeStruct_BasicShape.prototype.setParameter.call(this,name,value);
		}
	}
	,__class__: pixelimage_shapeStruct_FillShape
});
var pixelimage_shapeStruct_ChordArcShape = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,width,height,startAngle,sweepAngle) {
	if(sweepAngle == null) {
		sweepAngle = 0.;
	}
	if(startAngle == null) {
		startAngle = 0.;
	}
	if(height == null) {
		height = 1.;
	}
	if(width == null) {
		width = 1.;
	}
	if(top == null) {
		top = 0.;
	}
	if(left == null) {
		left = 0.;
	}
	if(fill == null) {
		fill = 0;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = 0;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pixelimage_shapeStruct_FillShape.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill);
	this.left = left;
	this.top = top;
	this.width = width;
	this.height = height;
	this.startAngle = startAngle;
	this.sweepAngle = sweepAngle;
};
pixelimage_shapeStruct_ChordArcShape.__name__ = "pixelimage.shapeStruct.ChordArcShape";
pixelimage_shapeStruct_ChordArcShape.__super__ = pixelimage_shapeStruct_FillShape;
pixelimage_shapeStruct_ChordArcShape.prototype = $extend(pixelimage_shapeStruct_FillShape.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "height":
			this.height = parseFloat(value);
			break;
		case "left":
			this.left = parseFloat(value);
			break;
		case "startAngle":
			var degree = parseFloat(value);
			this.startAngle = degree == 0 ? 0 : Math.PI * degree / 180;
			break;
		case "sweepAngle":
			var degree = parseFloat(value);
			this.sweepAngle = degree == 0 ? 0 : Math.PI * degree / 180;
			break;
		case "top":
			this.top = parseFloat(value);
			break;
		case "width":
			this.width = parseFloat(value);
			break;
		default:
			pixelimage_shapeStruct_FillShape.prototype.setParameter.call(this,name,value);
		}
	}
	,render: function(pixelImage) {
		haxe_Log.trace("Not implemented yet",{ fileName : "src/pixelimage/shapeStruct/ChordArcShape.hx", lineNumber : 57, className : "pixelimage.shapeStruct.ChordArcShape", methodName : "render"});
	}
	,__class__: pixelimage_shapeStruct_ChordArcShape
});
var pixelimage_shapeStruct_CircleShape = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,diameter) {
	if(diameter == null) {
		diameter = 1.;
	}
	if(top == null) {
		top = 0.;
	}
	if(left == null) {
		left = 0.;
	}
	if(fill == null) {
		fill = 0;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = 0;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pixelimage_shapeStruct_FillShape.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill);
	this.left = left;
	this.top = top;
	this.diameter = diameter;
};
pixelimage_shapeStruct_CircleShape.__name__ = "pixelimage.shapeStruct.CircleShape";
pixelimage_shapeStruct_CircleShape.__super__ = pixelimage_shapeStruct_FillShape;
pixelimage_shapeStruct_CircleShape.prototype = $extend(pixelimage_shapeStruct_FillShape.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "diameter":
			this.diameter = parseFloat(value);
			break;
		case "left":
			this.left = parseFloat(value);
			break;
		case "strokeWidth":
			this.top = parseFloat(value);
			break;
		default:
			pixelimage_shapeStruct_FillShape.prototype.setParameter.call(this,name,value);
		}
	}
	,render: function(pixelImage) {
		var r = this.diameter / 2;
		var innerR = this.diameter / 2 - this.strokeWidth / 2;
		var cx = this.left - this.diameter / 2;
		var cy = this.top - this.diameter / 2;
		var phi = 0.;
		var innerCx = cx + this.strokeWidth;
		var innerCy = cy + this.strokeWidth;
		var w = Math.ceil(this.diameter);
		var h = Math.ceil(this.diameter);
		var this1 = new Uint32Array(w * h | 0);
		var this2 = new pixelimage_ImageStruct(w,h,this1);
		var temp = this2;
		temp.transparent = false;
		var color = this.strokeColor;
		var phi1 = phi;
		if(phi1 == null) {
			phi1 = 0;
		}
		var rSmall = r > r ? r : r;
		var targetE = 1.05;
		if(targetE == null) {
			targetE = 1.05;
		}
		var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
		var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
		var phi2 = phi1;
		var sides = noSides;
		if(sides == null) {
			sides = 36;
		}
		if(phi2 == null) {
			phi2 = 0.;
		}
		var phi1 = phi2;
		var sides1 = sides;
		var cornerUp = true;
		if(cornerUp == null) {
			cornerUp = true;
		}
		if(sides1 == null) {
			sides1 = 36;
		}
		if(phi1 == null) {
			phi1 = 0.;
		}
		var theta = 2 * Math.PI / sides1;
		var omega;
		if(cornerUp) {
			omega = 0.;
		} else if((sides1 / 2 | 0) == sides1 / 2) {
			omega = Math.PI / sides1;
		} else {
			var v = sides1 / 2 - 0.5;
			omega = (v / 2 | 0) == v / 2 ? 0.5 * Math.PI / sides1 - Math.PI : 0.5 * Math.PI / sides1;
		}
		var lastX = 0.;
		var lastY = 0.;
		if(phi1 != 0) {
			lastX = r * Math.cos(sides1 * theta + omega) * Math.cos(phi1) - r * Math.sin(sides1 * theta + omega) * Math.sin(phi1) + cx;
			lastY = r * Math.cos(sides1 * theta + omega) * Math.sin(phi1) + r * Math.sin(sides1 * theta + omega) * Math.cos(phi1) + cy;
		} else {
			lastX = cx + r * Math.cos(sides1 * theta + omega);
			lastY = cy + r * Math.sin(sides1 * theta + omega);
		}
		if(phi1 != 0) {
			var cphi = Math.cos(phi1);
			var sphi = Math.sin(phi1);
			var _g = 0;
			var _g1 = sides1 + 1;
			while(_g < _g1) {
				var i = _g++;
				var stheta = Math.sin(i * theta + omega);
				var ctheta = Math.cos(i * theta + omega);
				var nextX = r * ctheta * cphi - r * stheta * sphi + cx;
				var nextY = r * ctheta * sphi + r * stheta * cphi + cy;
				var bx = lastX;
				var by = lastY;
				var cx1 = nextX;
				var cy1 = nextY;
				var adjustWinding = cx * by - bx * cy + (bx * cy1 - cx1 * by) + (cx1 * cy - cx * cy1) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx1;
					by = cy1;
					cx1 = bx_;
					cy1 = by_;
				}
				var s0 = cy * cx1 - cx * cy1;
				var sx = cy1 - cy;
				var sy = cx - cx1;
				var t0 = cx * by - cy * bx;
				var tx = cy - by;
				var ty = bx - cx;
				var A = -by * cx1 + cy * (-bx + cx1) + cx * (by - cy1) + bx * cy1;
				var ii = cy > by ? cy > cy1 ? new IntIterator(by > cy1 ? Math.floor(cy1) : Math.floor(by),Math.ceil(cy)) : new IntIterator(Math.floor(by),Math.ceil(cy1)) : by > cy1 ? new IntIterator(cy > cy1 ? Math.floor(cy1) : Math.ceil(cy),Math.ceil(by)) : new IntIterator(Math.floor(cy),Math.ceil(cy1));
				var this1 = new pixelimage_iter_IntIterStart(ii.min,ii.max);
				var yIter3 = this1;
				var foundY = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g2 = cx > bx ? cx > cx1 ? new IntIterator(bx > cx1 ? Math.floor(cx1) : Math.floor(bx),Math.ceil(cx)) : new IntIterator(Math.floor(bx),Math.ceil(cx1)) : bx > cx1 ? new IntIterator(cx > cx1 ? Math.floor(cx1) : Math.ceil(cx),Math.ceil(bx)) : new IntIterator(Math.floor(cx),Math.ceil(cx1));
				while(_g2.min < _g2.max) {
					var x = _g2.min++;
					sxx = sx * x;
					txx = tx * x;
					foundY = false;
					var _g_min = yIter3.start;
					var _g_max = yIter3.max;
					while(_g_min < _g_max) {
						var y = _g_min++;
						s = s0 + sxx + sy * y;
						t = t0 + txx + ty * y;
						if(s <= 0 || t <= 0) {
							if(foundY) {
								break;
							}
						} else if(s + t < A) {
							var this2 = color;
							var c = this2;
							if((c >> 24 & 255) < 254 && pixelImage.transparent) {
								var location = pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0;
								var this3 = pixelImage.image[location];
								var this4 = this3;
								var this5 = pixelimage_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = color >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = color >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = color >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = color & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r3 << 16 | g << 8 | b;
								pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								pixelImage.image[pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							}
							foundY = true;
						} else if(foundY) {
							break;
						}
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
		} else {
			var _g = 0;
			var _g1 = sides1 + 1;
			while(_g < _g1) {
				var i = _g++;
				var nextX = cx + r * Math.cos(i * theta + omega);
				var nextY = cy + r * Math.sin(i * theta + omega);
				var bx = lastX;
				var by = lastY;
				var cx1 = nextX;
				var cy1 = nextY;
				var adjustWinding = cx * by - bx * cy + (bx * cy1 - cx1 * by) + (cx1 * cy - cx * cy1) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx1;
					by = cy1;
					cx1 = bx_;
					cy1 = by_;
				}
				var s0 = cy * cx1 - cx * cy1;
				var sx = cy1 - cy;
				var sy = cx - cx1;
				var t0 = cx * by - cy * bx;
				var tx = cy - by;
				var ty = bx - cx;
				var A = -by * cx1 + cy * (-bx + cx1) + cx * (by - cy1) + bx * cy1;
				var ii = cy > by ? cy > cy1 ? new IntIterator(by > cy1 ? Math.floor(cy1) : Math.floor(by),Math.ceil(cy)) : new IntIterator(Math.floor(by),Math.ceil(cy1)) : by > cy1 ? new IntIterator(cy > cy1 ? Math.floor(cy1) : Math.ceil(cy),Math.ceil(by)) : new IntIterator(Math.floor(cy),Math.ceil(cy1));
				var this1 = new pixelimage_iter_IntIterStart(ii.min,ii.max);
				var yIter3 = this1;
				var foundY = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g2 = cx > bx ? cx > cx1 ? new IntIterator(bx > cx1 ? Math.floor(cx1) : Math.floor(bx),Math.ceil(cx)) : new IntIterator(Math.floor(bx),Math.ceil(cx1)) : bx > cx1 ? new IntIterator(cx > cx1 ? Math.floor(cx1) : Math.ceil(cx),Math.ceil(bx)) : new IntIterator(Math.floor(cx),Math.ceil(cx1));
				while(_g2.min < _g2.max) {
					var x = _g2.min++;
					sxx = sx * x;
					txx = tx * x;
					foundY = false;
					var _g_min = yIter3.start;
					var _g_max = yIter3.max;
					while(_g_min < _g_max) {
						var y = _g_min++;
						s = s0 + sxx + sy * y;
						t = t0 + txx + ty * y;
						if(s <= 0 || t <= 0) {
							if(foundY) {
								break;
							}
						} else if(s + t < A) {
							var this2 = color;
							var c = this2;
							if((c >> 24 & 255) < 254 && pixelImage.transparent) {
								var location = pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0;
								var this3 = pixelImage.image[location];
								var this4 = this3;
								var this5 = pixelimage_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = color >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = color >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = color >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = color & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r3 << 16 | g << 8 | b;
								pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								pixelImage.image[pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							}
							foundY = true;
						} else if(foundY) {
							break;
						}
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
		}
		var color = this.fill;
		var phi1 = phi;
		if(phi1 == null) {
			phi1 = 0;
		}
		var rSmall = innerR > innerR ? innerR : innerR;
		var targetE = 1.05;
		if(targetE == null) {
			targetE = 1.05;
		}
		var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
		var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
		var phi = phi1;
		var sides = noSides;
		if(sides == null) {
			sides = 36;
		}
		if(phi == null) {
			phi = 0.;
		}
		var phi1 = phi;
		var sides1 = sides;
		var cornerUp = true;
		if(cornerUp == null) {
			cornerUp = true;
		}
		if(sides1 == null) {
			sides1 = 36;
		}
		if(phi1 == null) {
			phi1 = 0.;
		}
		var theta = 2 * Math.PI / sides1;
		var omega;
		if(cornerUp) {
			omega = 0.;
		} else if((sides1 / 2 | 0) == sides1 / 2) {
			omega = Math.PI / sides1;
		} else {
			var v = sides1 / 2 - 0.5;
			omega = (v / 2 | 0) == v / 2 ? 0.5 * Math.PI / sides1 - Math.PI : 0.5 * Math.PI / sides1;
		}
		var lastX = 0.;
		var lastY = 0.;
		if(phi1 != 0) {
			lastX = innerR * Math.cos(sides1 * theta + omega) * Math.cos(phi1) - innerR * Math.sin(sides1 * theta + omega) * Math.sin(phi1) + innerCx;
			lastY = innerR * Math.cos(sides1 * theta + omega) * Math.sin(phi1) + innerR * Math.sin(sides1 * theta + omega) * Math.cos(phi1) + innerCy;
		} else {
			lastX = innerCx + innerR * Math.cos(sides1 * theta + omega);
			lastY = innerCy + innerR * Math.sin(sides1 * theta + omega);
		}
		if(phi1 != 0) {
			var cphi = Math.cos(phi1);
			var sphi = Math.sin(phi1);
			var _g = 0;
			var _g1 = sides1 + 1;
			while(_g < _g1) {
				var i = _g++;
				var stheta = Math.sin(i * theta + omega);
				var ctheta = Math.cos(i * theta + omega);
				var nextX = innerR * ctheta * cphi - innerR * stheta * sphi + innerCx;
				var nextY = innerR * ctheta * sphi + innerR * stheta * cphi + innerCy;
				var bx = lastX;
				var by = lastY;
				var cx = nextX;
				var cy = nextY;
				var adjustWinding = innerCx * by - bx * innerCy + (bx * cy - cx * by) + (cx * innerCy - innerCx * cy) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx;
					by = cy;
					cx = bx_;
					cy = by_;
				}
				var s0 = innerCy * cx - innerCx * cy;
				var sx = cy - innerCy;
				var sy = innerCx - cx;
				var t0 = innerCx * by - innerCy * bx;
				var tx = innerCy - by;
				var ty = bx - innerCx;
				var A = -by * cx + innerCy * (-bx + cx) + innerCx * (by - cy) + bx * cy;
				var ii = innerCy > by ? innerCy > cy ? new IntIterator(by > cy ? Math.floor(cy) : Math.floor(by),Math.ceil(innerCy)) : new IntIterator(Math.floor(by),Math.ceil(cy)) : by > cy ? new IntIterator(innerCy > cy ? Math.floor(cy) : Math.ceil(innerCy),Math.ceil(by)) : new IntIterator(Math.floor(innerCy),Math.ceil(cy));
				var this1 = new pixelimage_iter_IntIterStart(ii.min,ii.max);
				var yIter3 = this1;
				var foundY = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g2 = innerCx > bx ? innerCx > cx ? new IntIterator(bx > cx ? Math.floor(cx) : Math.floor(bx),Math.ceil(innerCx)) : new IntIterator(Math.floor(bx),Math.ceil(cx)) : bx > cx ? new IntIterator(innerCx > cx ? Math.floor(cx) : Math.ceil(innerCx),Math.ceil(bx)) : new IntIterator(Math.floor(innerCx),Math.ceil(cx));
				while(_g2.min < _g2.max) {
					var x = _g2.min++;
					sxx = sx * x;
					txx = tx * x;
					foundY = false;
					var _g_min = yIter3.start;
					var _g_max = yIter3.max;
					while(_g_min < _g_max) {
						var y = _g_min++;
						s = s0 + sxx + sy * y;
						t = t0 + txx + ty * y;
						if(s <= 0 || t <= 0) {
							if(foundY) {
								break;
							}
						} else if(s + t < A) {
							var this2 = color;
							var c = this2;
							if((c >> 24 & 255) < 254 && pixelImage.transparent) {
								var location = pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0;
								var this3 = pixelImage.image[location];
								var this4 = this3;
								var this5 = pixelimage_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = color >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = color >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = color >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = color & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								pixelImage.image[pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							}
							foundY = true;
						} else if(foundY) {
							break;
						}
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
		} else {
			var _g = 0;
			var _g1 = sides1 + 1;
			while(_g < _g1) {
				var i = _g++;
				var nextX = innerCx + innerR * Math.cos(i * theta + omega);
				var nextY = innerCy + innerR * Math.sin(i * theta + omega);
				var bx = lastX;
				var by = lastY;
				var cx = nextX;
				var cy = nextY;
				var adjustWinding = innerCx * by - bx * innerCy + (bx * cy - cx * by) + (cx * innerCy - innerCx * cy) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx;
					by = cy;
					cx = bx_;
					cy = by_;
				}
				var s0 = innerCy * cx - innerCx * cy;
				var sx = cy - innerCy;
				var sy = innerCx - cx;
				var t0 = innerCx * by - innerCy * bx;
				var tx = innerCy - by;
				var ty = bx - innerCx;
				var A = -by * cx + innerCy * (-bx + cx) + innerCx * (by - cy) + bx * cy;
				var ii = innerCy > by ? innerCy > cy ? new IntIterator(by > cy ? Math.floor(cy) : Math.floor(by),Math.ceil(innerCy)) : new IntIterator(Math.floor(by),Math.ceil(cy)) : by > cy ? new IntIterator(innerCy > cy ? Math.floor(cy) : Math.ceil(innerCy),Math.ceil(by)) : new IntIterator(Math.floor(innerCy),Math.ceil(cy));
				var this1 = new pixelimage_iter_IntIterStart(ii.min,ii.max);
				var yIter3 = this1;
				var foundY = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g2 = innerCx > bx ? innerCx > cx ? new IntIterator(bx > cx ? Math.floor(cx) : Math.floor(bx),Math.ceil(innerCx)) : new IntIterator(Math.floor(bx),Math.ceil(cx)) : bx > cx ? new IntIterator(innerCx > cx ? Math.floor(cx) : Math.ceil(innerCx),Math.ceil(bx)) : new IntIterator(Math.floor(innerCx),Math.ceil(cx));
				while(_g2.min < _g2.max) {
					var x = _g2.min++;
					sxx = sx * x;
					txx = tx * x;
					foundY = false;
					var _g_min = yIter3.start;
					var _g_max = yIter3.max;
					while(_g_min < _g_max) {
						var y = _g_min++;
						s = s0 + sxx + sy * y;
						t = t0 + txx + ty * y;
						if(s <= 0 || t <= 0) {
							if(foundY) {
								break;
							}
						} else if(s + t < A) {
							var this2 = color;
							var c = this2;
							if((c >> 24 & 255) < 254 && pixelImage.transparent) {
								var location = pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0;
								var this3 = pixelImage.image[location];
								var this4 = this3;
								var this5 = pixelimage_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = color >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = color >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = color >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = color & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								pixelImage.image[pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							}
							foundY = true;
						} else if(foundY) {
							break;
						}
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
		}
		var x = this.left | 0;
		var y = this.top | 0;
		var _g = 0;
		var _g1 = temp.height;
		while(_g < _g1) {
			var dy = _g++;
			var _g2 = 0;
			var _g3 = temp.width;
			while(_g2 < _g3) {
				var dx = _g2++;
				var c = temp.image[temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0];
				var col = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				if(temp.useMask && temp.mask != null) {
					var this1 = temp.mask;
					var c1 = this1.image[this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0];
					var this2 = pixelimage_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
					var maskPixel = this2;
					var this3 = col;
					var this4 = this3;
					if(maskPixel == 0) {
						var this5 = this4;
						col = this5;
					} else {
						var this6 = maskPixel >> 24 & 255;
						var m0 = this6 == 0 ? 0. : this6 / 255;
						var this7 = maskPixel >> 16 & 255;
						var m1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = maskPixel >> 8 & 255;
						var m2 = this8 == 0 ? 0. : this8 / 255;
						var this9 = maskPixel & 255;
						var m3 = this9 == 0 ? 0. : this9 / 255;
						var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
						var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
						var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
						var ch3 = (1. - m3) * (this4 & 255) | 0;
						col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
					}
				}
				if(col != 0) {
					var x1 = x + dx;
					var y1 = y + dy;
					var this10 = col;
					var c2 = this10;
					if((c2 >> 24 & 255) < 254 && pixelImage.transparent) {
						var location = pixelImage.useVirtualPos ? (y1 - pixelImage.virtualY) * pixelImage.width + x1 - pixelImage.virtualX | 0 : y1 * pixelImage.width + x1 | 0;
						var this11 = pixelImage.image[location];
						var this12 = this11;
						var this13 = pixelimage_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
						var this14 = this13 >> 24 & 255;
						var a1 = this14 == 0 ? 0. : this14 / 255;
						var this15 = this13 >> 16 & 255;
						var r1 = this15 == 0 ? 0. : this15 / 255;
						var this16 = this13 >> 8 & 255;
						var g1 = this16 == 0 ? 0. : this16 / 255;
						var this17 = this13 & 255;
						var b1 = this17 == 0 ? 0. : this17 / 255;
						var this18 = col >> 24 & 255;
						var a2 = this18 == 0 ? 0. : this18 / 255;
						var this19 = col >> 16 & 255;
						var r2 = this19 == 0 ? 0. : this19 / 255;
						var this20 = col >> 8 & 255;
						var g2 = this20 == 0 ? 0. : this20 / 255;
						var this21 = col & 255;
						var b2 = this21 == 0 ? 0. : this21 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelImage.image[pixelImage.useVirtualPos ? (y1 - pixelImage.virtualY) * pixelImage.width + x1 - pixelImage.virtualX | 0 : y1 * pixelImage.width + x1 | 0] = pixelimage_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
					}
				}
			}
		}
		temp = null;
	}
	,__class__: pixelimage_shapeStruct_CircleShape
});
var pixelimage_shapeStruct_ComponentShape = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,width,height) {
	if(height == null) {
		height = 1.;
	}
	if(width == null) {
		width = 1.;
	}
	if(top == null) {
		top = 0.;
	}
	if(left == null) {
		left = 0.;
	}
	if(fill == null) {
		fill = 0;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = 0;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pixelimage_shapeStruct_FillShape.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill);
	this.left = left;
	this.top = top;
	this.width = width;
	this.height = height;
};
pixelimage_shapeStruct_ComponentShape.__name__ = "pixelimage.shapeStruct.ComponentShape";
pixelimage_shapeStruct_ComponentShape.__super__ = pixelimage_shapeStruct_FillShape;
pixelimage_shapeStruct_ComponentShape.prototype = $extend(pixelimage_shapeStruct_FillShape.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "height":
			this.height = parseFloat(value);
			break;
		case "left":
			this.left = parseFloat(value);
			break;
		case "top":
			this.top = parseFloat(value);
			break;
		case "width":
			this.width = parseFloat(value);
			break;
		default:
			pixelimage_shapeStruct_FillShape.prototype.setParameter.call(this,name,value);
		}
	}
	,__class__: pixelimage_shapeStruct_ComponentShape
});
var pixelimage_shapeStruct_CubicCurveShape = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,thru,x1,y1,x2,y2,x3,y3) {
	if(y3 == null) {
		y3 = 0.;
	}
	if(x3 == null) {
		x3 = 0.;
	}
	if(y2 == null) {
		y2 = 0.;
	}
	if(x2 == null) {
		x2 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	if(thru == null) {
		thru = false;
	}
	if(fill == null) {
		fill = 0;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = 0;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pixelimage_shapeStruct_FillShape.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill);
	this.thru = thru;
	this.x1 = x1;
	this.y1 = y1;
	this.x2 = x2;
	this.y2 = y2;
	this.x3 = x3;
	this.y3 = y3;
};
pixelimage_shapeStruct_CubicCurveShape.__name__ = "pixelimage.shapeStruct.CubicCurveShape";
pixelimage_shapeStruct_CubicCurveShape.__super__ = pixelimage_shapeStruct_FillShape;
pixelimage_shapeStruct_CubicCurveShape.prototype = $extend(pixelimage_shapeStruct_FillShape.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "thru":
			this.thru = value.toLowerCase() == "true";
			break;
		case "x1":
			this.x1 = parseFloat(value);
			break;
		case "x2":
			this.x2 = parseFloat(value);
			break;
		case "x3":
			this.x3 = parseFloat(value);
			break;
		case "y1":
			this.y1 = parseFloat(value);
			break;
		case "y2":
			this.y2 = parseFloat(value);
			break;
		case "y3":
			this.y3 = parseFloat(value);
			break;
		default:
			pixelimage_shapeStruct_FillShape.prototype.setParameter.call(this,name,value);
		}
	}
	,render: function(pixelImage) {
		haxe_Log.trace("not implemeted yet",{ fileName : "src/pixelimage/shapeStruct/CubicCurveShape.hx", lineNumber : 60, className : "pixelimage.shapeStruct.CubicCurveShape", methodName : "render"});
	}
	,__class__: pixelimage_shapeStruct_CubicCurveShape
});
var pixelimage_shapeStruct_EllipseArcShape = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,width,height,startAngle,sweepAngle) {
	if(sweepAngle == null) {
		sweepAngle = 0.;
	}
	if(startAngle == null) {
		startAngle = 0.;
	}
	if(height == null) {
		height = 1.;
	}
	if(width == null) {
		width = 1.;
	}
	if(top == null) {
		top = 0.;
	}
	if(left == null) {
		left = 0.;
	}
	if(fill == null) {
		fill = 0;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = 0;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pixelimage_shapeStruct_FillShape.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill);
	this.left = left;
	this.top = top;
	this.width = width;
	this.height = height;
	this.startAngle = startAngle;
	this.sweepAngle = sweepAngle;
};
pixelimage_shapeStruct_EllipseArcShape.__name__ = "pixelimage.shapeStruct.EllipseArcShape";
pixelimage_shapeStruct_EllipseArcShape.__super__ = pixelimage_shapeStruct_FillShape;
pixelimage_shapeStruct_EllipseArcShape.prototype = $extend(pixelimage_shapeStruct_FillShape.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "height":
			this.height = parseFloat(value);
			break;
		case "left":
			this.left = parseFloat(value);
			break;
		case "startAngle":
			var degree = parseFloat(value);
			this.startAngle = degree == 0 ? 0 : Math.PI * degree / 180;
			break;
		case "sweepAngle":
			var degree = parseFloat(value);
			this.sweepAngle = degree == 0 ? 0 : Math.PI * degree / 180;
			break;
		case "top":
			this.top = parseFloat(value);
			break;
		case "width":
			this.width = parseFloat(value);
			break;
		default:
			pixelimage_shapeStruct_FillShape.prototype.setParameter.call(this,name,value);
		}
	}
	,render: function(pixelImage) {
		haxe_Log.trace("no implemented yet",{ fileName : "src/pixelimage/shapeStruct/EllipseArcShape.hx", lineNumber : 57, className : "pixelimage.shapeStruct.EllipseArcShape", methodName : "render"});
	}
	,__class__: pixelimage_shapeStruct_EllipseArcShape
});
var pixelimage_shapeStruct_LineGradient = function(opacity,visibility,x1,y1,x2,y2,colorA,colorB,colorC,colorD,strokeWidth) {
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(colorD == null) {
		colorD = -9240321;
	}
	if(colorC == null) {
		colorC = -16717057;
	}
	if(colorB == null) {
		colorB = -4194560;
	}
	if(colorA == null) {
		colorA = -26368;
	}
	if(y2 == null) {
		y2 = 0.;
	}
	if(x2 == null) {
		x2 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pixelimage_shapeStruct_BasicGradient.call(this,opacity,visibility,[colorA,colorB,colorC,colorD]);
	this.x1 = x1;
	this.y1 = y1;
	this.x2 = x2;
	this.y2 = y2;
	this.strokeWidth = strokeWidth;
};
pixelimage_shapeStruct_LineGradient.__name__ = "pixelimage.shapeStruct.LineGradient";
pixelimage_shapeStruct_LineGradient.__super__ = pixelimage_shapeStruct_BasicGradient;
pixelimage_shapeStruct_LineGradient.prototype = $extend(pixelimage_shapeStruct_BasicGradient.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "colorA":
			this.cornerColors[0] = Std.parseInt(value);
			break;
		case "colorB":
			this.cornerColors[1] = Std.parseInt(value);
			break;
		case "colorBottom":
			this.cornerColors[4] = Std.parseInt(value);
			this.cornerColors[3] = Std.parseInt(value);
			break;
		case "colorC":
			this.cornerColors[2] = Std.parseInt(value);
			break;
		case "colorD":
			this.cornerColors[3] = Std.parseInt(value);
			break;
		case "colorFirst":
			this.cornerColors[0] = Std.parseInt(value);
			this.cornerColors[4] = Std.parseInt(value);
			break;
		case "colorSecond":
			this.cornerColors[2] = Std.parseInt(value);
			this.cornerColors[3] = Std.parseInt(value);
			break;
		case "colorTop":
			this.cornerColors[0] = Std.parseInt(value);
			this.cornerColors[2] = Std.parseInt(value);
			break;
		case "x1":
			this.x1 = parseFloat(value);
			break;
		case "x2":
			this.x2 = parseFloat(value);
			break;
		case "y1":
			this.y1 = parseFloat(value);
			break;
		case "y2":
			this.y2 = parseFloat(value);
			break;
		default:
			pixelimage_shapeStruct_BasicGradient.prototype.setParameter.call(this,name,value);
		}
	}
	,render: function(pixelImage) {
		var px = this.x1;
		var py = this.y1;
		var colorA = this.cornerColors[0];
		var colorB = this.cornerColors[1];
		var colorC = this.cornerColors[2];
		var colorD = this.cornerColors[3];
		var o = this.y2 - py;
		var a = this.x2 - py;
		var h = Math.pow(o * o + a * a,0.5);
		var theta = Math.atan2(o,a);
		var debugCorners = false;
		if(debugCorners == null) {
			debugCorners = false;
		}
		var sin = Math.sin(theta);
		var cos = Math.cos(theta);
		var radius = this.strokeWidth / 2;
		var dx = 0.1;
		var dy = radius;
		var cx = h;
		var cy = radius;
		var bx = h;
		var by = -radius;
		var ax = 0.1;
		var ay = -radius;
		var temp = 0.;
		temp = px + (ax * cos - ay * sin);
		ay = py + (ay * cos + ax * sin);
		ax = temp;
		temp = px + (bx * cos - by * sin);
		by = py + (by * cos + bx * sin);
		bx = temp;
		temp = px + (cx * cos - cy * sin);
		cy = py + (cy * cos + cx * sin);
		cx = temp;
		temp = px + (dx * cos - dy * sin);
		dy = py + (dy * cos + dx * sin);
		dx = temp;
		if(debugCorners) {
			var x = ax - 6.;
			var y = ay - 6.;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + 12 | 0;
			var maxY = y + 12 | 0;
			while(true) {
				var x = p++;
				var this1 = colorA;
				var c = this1;
				if((c >> 24 & 255) < 254 && pixelImage.transparent) {
					var location = pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0;
					var this2 = pixelImage.image[location];
					var this3 = this2;
					var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = colorA >> 24 & 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = colorA >> 16 & 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = colorA >> 8 & 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = colorA & 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					pixelImage.image[pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var x = bx - 6.;
			var y = by - 6.;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + 12 | 0;
			var maxY = y + 12 | 0;
			while(true) {
				var x = p++;
				var this1 = colorB;
				var c = this1;
				if((c >> 24 & 255) < 254 && pixelImage.transparent) {
					var location = pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0;
					var this2 = pixelImage.image[location];
					var this3 = this2;
					var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = colorB >> 24 & 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = colorB >> 16 & 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = colorB >> 8 & 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = colorB & 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					pixelImage.image[pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var x = cx - 6.;
			var y = cy - 6.;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + 12 | 0;
			var maxY = y + 12 | 0;
			while(true) {
				var x = p++;
				var this1 = colorC;
				var c = this1;
				if((c >> 24 & 255) < 254 && pixelImage.transparent) {
					var location = pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0;
					var this2 = pixelImage.image[location];
					var this3 = this2;
					var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = colorC >> 24 & 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = colorC >> 16 & 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = colorC >> 8 & 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = colorC & 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					pixelImage.image[pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var x = dx - 6.;
			var y = dy - 6.;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + 12 | 0;
			var maxY = y + 12 | 0;
			while(true) {
				var x = p++;
				var this1 = colorD;
				var c = this1;
				if((c >> 24 & 255) < 254 && pixelImage.transparent) {
					var location = pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0;
					var this2 = pixelImage.image[location];
					var this3 = this2;
					var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = colorD >> 24 & 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = colorD >> 16 & 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = colorD >> 8 & 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = colorD & 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					pixelImage.image[pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
		}
		var aA = colorB >> 24 & 255;
		var rA = colorB >> 16 & 255;
		var gA = colorB >> 8 & 255;
		var bA = colorB & 255;
		var aB = colorA >> 24 & 255;
		var rB = colorA >> 16 & 255;
		var gB = colorA >> 8 & 255;
		var bB = colorA & 255;
		var aC = colorD >> 24 & 255;
		var rC = colorD >> 16 & 255;
		var gC = colorD >> 8 & 255;
		var bC = colorD & 255;
		var bcx = bx - dx;
		var bcy = by - dy;
		var acx = ax - dx;
		var acy = ay - dy;
		var dot11 = bcx * bcx + bcy * bcy;
		var dot12 = bcx * acx + bcy * acy;
		var dot22 = acx * acx + acy * acy;
		var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
		var _g = dx > bx ? dx > ax ? new IntIterator(bx > ax ? Math.floor(ax) : Math.floor(bx),Math.ceil(dx)) : new IntIterator(Math.floor(bx),Math.ceil(ax)) : bx > ax ? new IntIterator(dx > ax ? Math.floor(ax) : Math.ceil(dx),Math.ceil(bx)) : new IntIterator(Math.floor(dx),Math.ceil(ax));
		while(_g.min < _g.max) {
			var px = _g.min++;
			var pcx = px - dx;
			var _g1 = dy > by ? dy > ay ? new IntIterator(by > ay ? Math.floor(ay) : Math.floor(by),Math.ceil(dy)) : new IntIterator(Math.floor(by),Math.ceil(ay)) : by > ay ? new IntIterator(dy > ay ? Math.floor(ay) : Math.ceil(dy),Math.ceil(by)) : new IntIterator(Math.floor(dy),Math.ceil(ay));
			while(_g1.min < _g1.max) {
				var py = _g1.min++;
				var pcy = py - dy;
				var dot31 = pcx * bcx + pcy * bcy;
				var dot32 = pcx * acx + pcy * acy;
				var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
				var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
				var ratioC = 1.0 - ratioB - ratioA;
				if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
					var i = aA * ratioA + aB * ratioB + aC * ratioC | 0;
					if(i > 255) {
						i = 255;
					}
					if(i < 0) {
						i = 0;
					}
					var this1 = i;
					var a = this1;
					var i1 = rA * ratioA + rB * ratioB + rC * ratioC | 0;
					if(i1 > 255) {
						i1 = 255;
					}
					if(i1 < 0) {
						i1 = 0;
					}
					var this2 = i1;
					var r = this2;
					var i2 = gA * ratioA + gB * ratioB + gC * ratioC | 0;
					if(i2 > 255) {
						i2 = 255;
					}
					if(i2 < 0) {
						i2 = 0;
					}
					var this3 = i2;
					var g = this3;
					var i3 = bA * ratioA + bB * ratioB + bC * ratioC | 0;
					if(i3 > 255) {
						i3 = 255;
					}
					if(i3 < 0) {
						i3 = 0;
					}
					var this4 = i3;
					var b = this4;
					var location = pixelImage.useVirtualPos ? (py - pixelImage.virtualY) * pixelImage.width + px - pixelImage.virtualX | 0 : py * pixelImage.width + px | 0;
					if(pixelImage.transparent && a < 254) {
						var this5 = pixelImage.image[location];
						var this6 = this5;
						var old = pixelimage_Endian_isLittleEndian ? (this6 >> 24 & 255) << 24 | (this6 & 255) << 16 | (this6 >> 8 & 255) << 8 | this6 >> 16 & 255 : this6;
						var rhs = a << 24 | r << 16 | g << 8 | b;
						var this7 = old >> 24 & 255;
						var a1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = old >> 16 & 255;
						var r1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = old >> 8 & 255;
						var g1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = old & 255;
						var b1 = this10 == 0 ? 0. : this10 / 255;
						var this11 = rhs >> 24 & 255;
						var a2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = rhs >> 16 & 255;
						var r2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = rhs >> 8 & 255;
						var g2 = this13 == 0 ? 0. : this13 / 255;
						var this14 = rhs & 255;
						var b2 = this14 == 0 ? 0. : this14 / 255;
						var a3 = a1 * (1 - a2);
						var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
						var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
						var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
						var a4 = 255 * (a3 + a2) | 0;
						var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
						pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelImage.image[location] = pixelImage.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b;
					}
				}
			}
		}
		var aA = colorC >> 24 & 255;
		var rA = colorC >> 16 & 255;
		var gA = colorC >> 8 & 255;
		var bA = colorC & 255;
		var aB = colorB >> 24 & 255;
		var rB = colorB >> 16 & 255;
		var gB = colorB >> 8 & 255;
		var bB = colorB & 255;
		var aC = colorD >> 24 & 255;
		var rC = colorD >> 16 & 255;
		var gC = colorD >> 8 & 255;
		var bC = colorD & 255;
		var bcx = cx - dx;
		var bcy = cy - dy;
		var acx = bx - dx;
		var acy = by - dy;
		var dot11 = bcx * bcx + bcy * bcy;
		var dot12 = bcx * acx + bcy * acy;
		var dot22 = acx * acx + acy * acy;
		var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
		var _g = dx > cx ? dx > bx ? new IntIterator(cx > bx ? Math.floor(bx) : Math.floor(cx),Math.ceil(dx)) : new IntIterator(Math.floor(cx),Math.ceil(bx)) : cx > bx ? new IntIterator(dx > bx ? Math.floor(bx) : Math.ceil(dx),Math.ceil(cx)) : new IntIterator(Math.floor(dx),Math.ceil(bx));
		while(_g.min < _g.max) {
			var px = _g.min++;
			var pcx = px - dx;
			var _g1 = dy > cy ? dy > by ? new IntIterator(cy > by ? Math.floor(by) : Math.floor(cy),Math.ceil(dy)) : new IntIterator(Math.floor(cy),Math.ceil(by)) : cy > by ? new IntIterator(dy > by ? Math.floor(by) : Math.ceil(dy),Math.ceil(cy)) : new IntIterator(Math.floor(dy),Math.ceil(by));
			while(_g1.min < _g1.max) {
				var py = _g1.min++;
				var pcy = py - dy;
				var dot31 = pcx * bcx + pcy * bcy;
				var dot32 = pcx * acx + pcy * acy;
				var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
				var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
				var ratioC = 1.0 - ratioB - ratioA;
				if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
					var i = aA * ratioA + aB * ratioB + aC * ratioC | 0;
					if(i > 255) {
						i = 255;
					}
					if(i < 0) {
						i = 0;
					}
					var this1 = i;
					var a = this1;
					var i1 = rA * ratioA + rB * ratioB + rC * ratioC | 0;
					if(i1 > 255) {
						i1 = 255;
					}
					if(i1 < 0) {
						i1 = 0;
					}
					var this2 = i1;
					var r = this2;
					var i2 = gA * ratioA + gB * ratioB + gC * ratioC | 0;
					if(i2 > 255) {
						i2 = 255;
					}
					if(i2 < 0) {
						i2 = 0;
					}
					var this3 = i2;
					var g = this3;
					var i3 = bA * ratioA + bB * ratioB + bC * ratioC | 0;
					if(i3 > 255) {
						i3 = 255;
					}
					if(i3 < 0) {
						i3 = 0;
					}
					var this4 = i3;
					var b = this4;
					var location = pixelImage.useVirtualPos ? (py - pixelImage.virtualY) * pixelImage.width + px - pixelImage.virtualX | 0 : py * pixelImage.width + px | 0;
					if(pixelImage.transparent && a < 254) {
						var this5 = pixelImage.image[location];
						var this6 = this5;
						var old = pixelimage_Endian_isLittleEndian ? (this6 >> 24 & 255) << 24 | (this6 & 255) << 16 | (this6 >> 8 & 255) << 8 | this6 >> 16 & 255 : this6;
						var rhs = a << 24 | r << 16 | g << 8 | b;
						var this7 = old >> 24 & 255;
						var a1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = old >> 16 & 255;
						var r1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = old >> 8 & 255;
						var g1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = old & 255;
						var b1 = this10 == 0 ? 0. : this10 / 255;
						var this11 = rhs >> 24 & 255;
						var a2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = rhs >> 16 & 255;
						var r2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = rhs >> 8 & 255;
						var g2 = this13 == 0 ? 0. : this13 / 255;
						var this14 = rhs & 255;
						var b2 = this14 == 0 ? 0. : this14 / 255;
						var a3 = a1 * (1 - a2);
						var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
						var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
						var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
						var a4 = 255 * (a3 + a2) | 0;
						var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
						pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelImage.image[location] = pixelImage.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b;
					}
				}
			}
		}
	}
	,__class__: pixelimage_shapeStruct_LineGradient
});
var pixelimage_shapeStruct_LineShape = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,x1,y1,x2,y2) {
	if(y2 == null) {
		y2 = 0.;
	}
	if(x2 == null) {
		x2 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = 0;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pixelimage_shapeStruct_BasicShape.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray);
	this.x1 = x1;
	this.y1 = y1;
	this.x2 = x2;
	this.y2 = y2;
};
pixelimage_shapeStruct_LineShape.__name__ = "pixelimage.shapeStruct.LineShape";
pixelimage_shapeStruct_LineShape.__super__ = pixelimage_shapeStruct_BasicShape;
pixelimage_shapeStruct_LineShape.prototype = $extend(pixelimage_shapeStruct_BasicShape.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "x1":
			this.x1 = parseFloat(value);
			break;
		case "x2":
			this.x2 = parseFloat(value);
			break;
		case "y1":
			this.y1 = parseFloat(value);
			break;
		case "y2":
			this.y2 = parseFloat(value);
			break;
		default:
			pixelimage_shapeStruct_BasicShape.prototype.setParameter.call(this,name,value);
		}
	}
	,render: function(pixelImage) {
		var px = this.x1;
		var py = this.y1;
		var color = this.strokeColor;
		var o = this.y2 - py;
		var a = this.x2 - py;
		var h = Math.pow(o * o + a * a,0.5);
		var theta = Math.atan2(o,a);
		var debugCorners = false;
		if(debugCorners == null) {
			debugCorners = false;
		}
		var sin = Math.sin(theta);
		var cos = Math.cos(theta);
		var radius = this.strokeWidth / 2;
		var dx = 0.1;
		var dy = radius;
		var cx = h;
		var cy = radius;
		var bx = h;
		var by = -radius;
		var ax = 0.1;
		var ay = -radius;
		var temp = 0.;
		temp = px + (ax * cos - ay * sin);
		ay = py + (ay * cos + ax * sin);
		ax = temp;
		temp = px + (bx * cos - by * sin);
		by = py + (by * cos + bx * sin);
		bx = temp;
		temp = px + (cx * cos - cy * sin);
		cy = py + (cy * cos + cx * sin);
		cx = temp;
		temp = px + (dx * cos - dy * sin);
		dy = py + (dy * cos + dx * sin);
		dx = temp;
		if(debugCorners) {
			var x = ax - 6.;
			var y = ay - 6.;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + 12 | 0;
			var maxY = y + 12 | 0;
			while(true) {
				var x = p++;
				var this1 = -65536;
				var c = this1;
				if((c >> 24 & 255) < 254 && pixelImage.transparent) {
					var location = pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0;
					var this2 = pixelImage.image[location];
					var this3 = this2;
					var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 0;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 0;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					pixelImage.image[pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var x = bx - 6.;
			var y = by - 6.;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + 12 | 0;
			var maxY = y + 12 | 0;
			while(true) {
				var x = p++;
				var this1 = -16711936;
				var c = this1;
				if((c >> 24 & 255) < 254 && pixelImage.transparent) {
					var location = pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0;
					var this2 = pixelImage.image[location];
					var this3 = this2;
					var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = 0;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 0;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					pixelImage.image[pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var x = cx - 6.;
			var y = cy - 6.;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + 12 | 0;
			var maxY = y + 12 | 0;
			while(true) {
				var x = p++;
				var this1 = -16776961;
				var c = this1;
				if((c >> 24 & 255) < 254 && pixelImage.transparent) {
					var location = pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0;
					var this2 = pixelImage.image[location];
					var this3 = this2;
					var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = 0;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 0;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					pixelImage.image[pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var x = dx - 6.;
			var y = dy - 6.;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + 12 | 0;
			var maxY = y + 12 | 0;
			while(true) {
				var x = p++;
				var this1 = -1048336;
				var c = this1;
				if((c >> 24 & 255) < 254 && pixelImage.transparent) {
					var location = pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0;
					var this2 = pixelImage.image[location];
					var this3 = this2;
					var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = 240;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 0;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 240;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					pixelImage.image[pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
		}
		var bx1 = bx;
		var by1 = by;
		var cx1 = dx;
		var cy1 = dy;
		var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy1 - cx1 * by1) + (cx1 * ay - ax * cy1) > 0;
		if(!adjustWinding) {
			var bx_ = bx1;
			var by_ = by1;
			bx1 = cx1;
			by1 = cy1;
			cx1 = bx_;
			cy1 = by_;
		}
		var s0 = ay * cx1 - ax * cy1;
		var sx = cy1 - ay;
		var sy = ax - cx1;
		var t0 = ax * by1 - ay * bx1;
		var tx = ay - by1;
		var ty = bx1 - ax;
		var A = -by1 * cx1 + ay * (-bx1 + cx1) + ax * (by1 - cy1) + bx1 * cy1;
		var ii = ay > by1 ? ay > cy1 ? new IntIterator(by1 > cy1 ? Math.floor(cy1) : Math.floor(by1),Math.ceil(ay)) : new IntIterator(Math.floor(by1),Math.ceil(cy1)) : by1 > cy1 ? new IntIterator(ay > cy1 ? Math.floor(cy1) : Math.ceil(ay),Math.ceil(by1)) : new IntIterator(Math.floor(ay),Math.ceil(cy1));
		var this1 = new pixelimage_iter_IntIterStart(ii.min,ii.max);
		var yIter3 = this1;
		var foundY = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g = ax > bx1 ? ax > cx1 ? new IntIterator(bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1),Math.ceil(ax)) : new IntIterator(Math.floor(bx1),Math.ceil(cx1)) : bx1 > cx1 ? new IntIterator(ax > cx1 ? Math.floor(cx1) : Math.ceil(ax),Math.ceil(bx1)) : new IntIterator(Math.floor(ax),Math.ceil(cx1));
		while(_g.min < _g.max) {
			var x = _g.min++;
			sxx = sx * x;
			txx = tx * x;
			foundY = false;
			var _g_min = yIter3.start;
			var _g_max = yIter3.max;
			while(_g_min < _g_max) {
				var y = _g_min++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(foundY) {
						break;
					}
				} else if(s + t < A) {
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && pixelImage.transparent) {
						var location = pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0;
						var this2 = pixelImage.image[location];
						var this3 = this2;
						var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelImage.image[pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					foundY = true;
				} else if(foundY) {
					break;
				}
			}
		}
		var bx1 = cx;
		var by1 = cy;
		var cx = dx;
		var cy = dy;
		var adjustWinding = bx * by1 - bx1 * by + (bx1 * cy - cx * by1) + (cx * by - bx * cy) > 0;
		if(!adjustWinding) {
			var bx_ = bx1;
			var by_ = by1;
			bx1 = cx;
			by1 = cy;
			cx = bx_;
			cy = by_;
		}
		var s0 = by * cx - bx * cy;
		var sx = cy - by;
		var sy = bx - cx;
		var t0 = bx * by1 - by * bx1;
		var tx = by - by1;
		var ty = bx1 - bx;
		var A = -by1 * cx + by * (-bx1 + cx) + bx * (by1 - cy) + bx1 * cy;
		var ii = by > by1 ? by > cy ? new IntIterator(by1 > cy ? Math.floor(cy) : Math.floor(by1),Math.ceil(by)) : new IntIterator(Math.floor(by1),Math.ceil(cy)) : by1 > cy ? new IntIterator(by > cy ? Math.floor(cy) : Math.ceil(by),Math.ceil(by1)) : new IntIterator(Math.floor(by),Math.ceil(cy));
		var this1 = new pixelimage_iter_IntIterStart(ii.min,ii.max);
		var yIter3 = this1;
		var foundY = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g = bx > bx1 ? bx > cx ? new IntIterator(bx1 > cx ? Math.floor(cx) : Math.floor(bx1),Math.ceil(bx)) : new IntIterator(Math.floor(bx1),Math.ceil(cx)) : bx1 > cx ? new IntIterator(bx > cx ? Math.floor(cx) : Math.ceil(bx),Math.ceil(bx1)) : new IntIterator(Math.floor(bx),Math.ceil(cx));
		while(_g.min < _g.max) {
			var x = _g.min++;
			sxx = sx * x;
			txx = tx * x;
			foundY = false;
			var _g_min = yIter3.start;
			var _g_max = yIter3.max;
			while(_g_min < _g_max) {
				var y = _g_min++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(foundY) {
						break;
					}
				} else if(s + t < A) {
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && pixelImage.transparent) {
						var location = pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0;
						var this2 = pixelImage.image[location];
						var this3 = this2;
						var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelImage.image[pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					foundY = true;
				} else if(foundY) {
					break;
				}
			}
		}
	}
	,__class__: pixelimage_shapeStruct_LineShape
});
var pixelimage_shapeStruct_PathElementShape = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,pathData) {
	if(pathData == null) {
		pathData = "";
	}
	if(fill == null) {
		fill = 0;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = 0;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pixelimage_shapeStruct_FillShape.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill);
	this.pathData = pathData;
};
pixelimage_shapeStruct_PathElementShape.__name__ = "pixelimage.shapeStruct.PathElementShape";
pixelimage_shapeStruct_PathElementShape.__super__ = pixelimage_shapeStruct_FillShape;
pixelimage_shapeStruct_PathElementShape.prototype = $extend(pixelimage_shapeStruct_FillShape.prototype,{
	setParameter: function(name,value) {
		if(name == "pathData") {
			this.pathData = value;
		} else {
			pixelimage_shapeStruct_FillShape.prototype.setParameter.call(this,name,value);
		}
	}
	,__class__: pixelimage_shapeStruct_PathElementShape
});
var pixelimage_shapeStruct_PieArcShape = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,width,height,startAngle,sweepAngle) {
	if(sweepAngle == null) {
		sweepAngle = 0.;
	}
	if(startAngle == null) {
		startAngle = 0.;
	}
	if(height == null) {
		height = 1.;
	}
	if(width == null) {
		width = 1.;
	}
	if(top == null) {
		top = 0.;
	}
	if(left == null) {
		left = 0.;
	}
	if(fill == null) {
		fill = 0;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = 0;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pixelimage_shapeStruct_FillShape.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill);
	this.left = left;
	this.top = top;
	this.width = width;
	this.height = height;
	this.startAngle = startAngle;
	this.sweepAngle = sweepAngle;
};
pixelimage_shapeStruct_PieArcShape.__name__ = "pixelimage.shapeStruct.PieArcShape";
pixelimage_shapeStruct_PieArcShape.__super__ = pixelimage_shapeStruct_FillShape;
pixelimage_shapeStruct_PieArcShape.prototype = $extend(pixelimage_shapeStruct_FillShape.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "height":
			this.height = parseFloat(value);
			break;
		case "left":
			this.left = parseFloat(value);
			break;
		case "startAngle":
			var degree = parseFloat(value);
			this.startAngle = degree == 0 ? 0 : Math.PI * degree / 180;
			break;
		case "sweepAngle":
			var degree = parseFloat(value);
			this.sweepAngle = degree == 0 ? 0 : Math.PI * degree / 180;
			break;
		case "top":
			this.top = parseFloat(value);
			break;
		case "width":
			this.width = parseFloat(value);
			break;
		default:
			pixelimage_shapeStruct_FillShape.prototype.setParameter.call(this,name,value);
		}
	}
	,__class__: pixelimage_shapeStruct_PieArcShape
});
var pixelimage_shapeStruct_PolyLineGradient = function(opacity,visibility,strokeWidth,points,colorDirection,colors) {
	if(colorDirection == null) {
		colorDirection = "longways";
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pixelimage_shapeStruct_BasicGradient.call(this,opacity,visibility,colors);
	this.strokeWidth = strokeWidth;
	this.colorDirection = colorDirection;
	this.points = points;
};
pixelimage_shapeStruct_PolyLineGradient.__name__ = "pixelimage.shapeStruct.PolyLineGradient";
pixelimage_shapeStruct_PolyLineGradient.__super__ = pixelimage_shapeStruct_BasicGradient;
pixelimage_shapeStruct_PolyLineGradient.prototype = $extend(pixelimage_shapeStruct_BasicGradient.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "colorDirection":
			this.colorDirection = value == "widthways" ? "widthways" : "longways";
			break;
		case "colors":
			value = value.split("[")[1].split("]")[0];
			var _g = [];
			var _g1 = 0;
			var _g2 = value.split(",");
			while(_g1 < _g2.length) {
				var n = _g2[_g1];
				++_g1;
				_g.push(Std.parseInt(n));
			}
			this.cornerColors = _g;
			break;
		case "points":
			value = value.split("[")[1].split("]")[0];
			var _g = [];
			var _g1 = 0;
			var _g2 = value.split(",");
			while(_g1 < _g2.length) {
				var n = _g2[_g1];
				++_g1;
				_g.push(parseFloat(n));
			}
			this.points = _g;
			break;
		case "strokeWidth":
			this.strokeWidth = parseFloat(value);
			break;
		default:
			pixelimage_shapeStruct_BasicGradient.prototype.setParameter.call(this,name,value);
		}
	}
	,render: function(pixelImage) {
		var l = this.points.length;
		if(l < 4) {
			return;
		}
		if(l % 2 != 0) {
			return;
		}
		var i = 0;
		var x = 0.;
		var y = 0.;
		var nextX = 0.;
		var nextY = 0.;
		x = this.points[i];
		++i;
		y = this.points[i];
		++i;
		var colorCount = 0;
		var colorLen = this.cornerColors.length;
		var colorA = 0;
		var colorB = 0;
		var colorC = 0;
		var colorD = 0;
		while(i < l) {
			x = this.points[i];
			++i;
			y = this.points[i];
			++i;
			nextX = x;
			nextY = y;
			if(this.colorDirection == "longways") {
				if(colorCount >= colorLen) {
					colorCount = 0;
				}
				colorA = this.cornerColors[colorCount];
				colorD = colorA;
				++colorCount;
				if(colorCount >= colorLen) {
					colorCount = 0;
				}
				colorB = this.cornerColors[colorCount];
				colorC = colorB;
			} else {
				if(colorCount >= colorLen) {
					colorCount = 0;
				}
				colorA = this.cornerColors[colorCount];
				colorB = colorA;
				++colorCount;
				if(colorCount >= colorLen) {
					colorCount = 0;
				}
				colorD = this.cornerColors[colorCount];
				colorC = colorD;
				++colorCount;
				if(colorCount >= colorLen) {
					colorCount = 0;
				}
			}
			var o = nextY - y;
			var a = nextX - y;
			var h = Math.pow(o * o + a * a,0.5);
			var theta = Math.atan2(o,a);
			var debugCorners = false;
			if(debugCorners == null) {
				debugCorners = false;
			}
			var sin = Math.sin(theta);
			var cos = Math.cos(theta);
			var radius = this.strokeWidth / 2;
			var dx = 0.1;
			var dy = radius;
			var cx = h;
			var cy = radius;
			var bx = h;
			var by = -radius;
			var ax = 0.1;
			var ay = -radius;
			var temp = 0.;
			temp = x + (ax * cos - ay * sin);
			ay = y + (ay * cos + ax * sin);
			ax = temp;
			temp = x + (bx * cos - by * sin);
			by = y + (by * cos + bx * sin);
			bx = temp;
			temp = x + (cx * cos - cy * sin);
			cy = y + (cy * cos + cx * sin);
			cx = temp;
			temp = x + (dx * cos - dy * sin);
			dy = y + (dy * cos + dx * sin);
			dx = temp;
			if(debugCorners) {
				var x1 = ax - 6.;
				var y1 = ay - 6.;
				var p = x1 | 0;
				var xx = p;
				var q = y1 | 0;
				var maxX = x1 + 12 | 0;
				var maxY = y1 + 12 | 0;
				while(true) {
					var x2 = p++;
					var this1 = colorA;
					var c = this1;
					if((c >> 24 & 255) < 254 && pixelImage.transparent) {
						var location = pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x2 - pixelImage.virtualX | 0 : q * pixelImage.width + x2 | 0;
						var this2 = pixelImage.image[location];
						var this3 = this2;
						var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = colorA >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = colorA >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = colorA >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = colorA & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a4 = 255 * (a3 + a2) | 0;
						var blended = a4 << 24 | r << 16 | g << 8 | b;
						pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelImage.image[pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x2 - pixelImage.virtualX | 0 : q * pixelImage.width + x2 | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					if(p > maxX) {
						p = xx;
						++q;
					}
					if(q > maxY) {
						break;
					}
				}
				var x3 = bx - 6.;
				var y2 = by - 6.;
				var p1 = x3 | 0;
				var xx1 = p1;
				var q1 = y2 | 0;
				var maxX1 = x3 + 12 | 0;
				var maxY1 = y2 + 12 | 0;
				while(true) {
					var x4 = p1++;
					var this13 = colorB;
					var c1 = this13;
					if((c1 >> 24 & 255) < 254 && pixelImage.transparent) {
						var location1 = pixelImage.useVirtualPos ? (q1 - pixelImage.virtualY) * pixelImage.width + x4 - pixelImage.virtualX | 0 : q1 * pixelImage.width + x4 | 0;
						var this14 = pixelImage.image[location1];
						var this15 = this14;
						var this16 = pixelimage_Endian_isLittleEndian ? (this15 >> 24 & 255) << 24 | (this15 & 255) << 16 | (this15 >> 8 & 255) << 8 | this15 >> 16 & 255 : this15;
						var this17 = this16 >> 24 & 255;
						var a11 = this17 == 0 ? 0. : this17 / 255;
						var this18 = this16 >> 16 & 255;
						var r11 = this18 == 0 ? 0. : this18 / 255;
						var this19 = this16 >> 8 & 255;
						var g11 = this19 == 0 ? 0. : this19 / 255;
						var this20 = this16 & 255;
						var b11 = this20 == 0 ? 0. : this20 / 255;
						var this21 = colorB >> 24 & 255;
						var a21 = this21 == 0 ? 0. : this21 / 255;
						var this22 = colorB >> 16 & 255;
						var r21 = this22 == 0 ? 0. : this22 / 255;
						var this23 = colorB >> 8 & 255;
						var g21 = this23 == 0 ? 0. : this23 / 255;
						var this24 = colorB & 255;
						var b21 = this24 == 0 ? 0. : this24 / 255;
						var a31 = a11 * (1 - a21);
						var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
						var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
						var b3 = 255 * (b11 * a31 + b21 * a21) | 0;
						var a5 = 255 * (a31 + a21) | 0;
						var blended1 = a5 << 24 | r3 << 16 | g3 << 8 | b3;
						pixelImage.image[location1] = pixelimage_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1;
					} else {
						pixelImage.image[pixelImage.useVirtualPos ? (q1 - pixelImage.virtualY) * pixelImage.width + x4 - pixelImage.virtualX | 0 : q1 * pixelImage.width + x4 | 0] = pixelimage_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
					}
					if(p1 > maxX1) {
						p1 = xx1;
						++q1;
					}
					if(q1 > maxY1) {
						break;
					}
				}
				var x5 = cx - 6.;
				var y3 = cy - 6.;
				var p2 = x5 | 0;
				var xx2 = p2;
				var q2 = y3 | 0;
				var maxX2 = x5 + 12 | 0;
				var maxY2 = y3 + 12 | 0;
				while(true) {
					var x6 = p2++;
					var this25 = colorC;
					var c2 = this25;
					if((c2 >> 24 & 255) < 254 && pixelImage.transparent) {
						var location2 = pixelImage.useVirtualPos ? (q2 - pixelImage.virtualY) * pixelImage.width + x6 - pixelImage.virtualX | 0 : q2 * pixelImage.width + x6 | 0;
						var this26 = pixelImage.image[location2];
						var this27 = this26;
						var this28 = pixelimage_Endian_isLittleEndian ? (this27 >> 24 & 255) << 24 | (this27 & 255) << 16 | (this27 >> 8 & 255) << 8 | this27 >> 16 & 255 : this27;
						var this29 = this28 >> 24 & 255;
						var a12 = this29 == 0 ? 0. : this29 / 255;
						var this30 = this28 >> 16 & 255;
						var r12 = this30 == 0 ? 0. : this30 / 255;
						var this31 = this28 >> 8 & 255;
						var g12 = this31 == 0 ? 0. : this31 / 255;
						var this32 = this28 & 255;
						var b12 = this32 == 0 ? 0. : this32 / 255;
						var this33 = colorC >> 24 & 255;
						var a22 = this33 == 0 ? 0. : this33 / 255;
						var this34 = colorC >> 16 & 255;
						var r22 = this34 == 0 ? 0. : this34 / 255;
						var this35 = colorC >> 8 & 255;
						var g22 = this35 == 0 ? 0. : this35 / 255;
						var this36 = colorC & 255;
						var b22 = this36 == 0 ? 0. : this36 / 255;
						var a32 = a12 * (1 - a22);
						var r4 = 255 * (r12 * a32 + r22 * a22) | 0;
						var g4 = 255 * (g12 * a32 + g22 * a22) | 0;
						var b4 = 255 * (b12 * a32 + b22 * a22) | 0;
						var a6 = 255 * (a32 + a22) | 0;
						var blended2 = a6 << 24 | r4 << 16 | g4 << 8 | b4;
						pixelImage.image[location2] = pixelimage_Endian_isLittleEndian ? (blended2 >> 24 & 255) << 24 | (blended2 & 255) << 16 | (blended2 >> 8 & 255) << 8 | blended2 >> 16 & 255 : blended2;
					} else {
						pixelImage.image[pixelImage.useVirtualPos ? (q2 - pixelImage.virtualY) * pixelImage.width + x6 - pixelImage.virtualX | 0 : q2 * pixelImage.width + x6 | 0] = pixelimage_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
					}
					if(p2 > maxX2) {
						p2 = xx2;
						++q2;
					}
					if(q2 > maxY2) {
						break;
					}
				}
				var x7 = dx - 6.;
				var y4 = dy - 6.;
				var p3 = x7 | 0;
				var xx3 = p3;
				var q3 = y4 | 0;
				var maxX3 = x7 + 12 | 0;
				var maxY3 = y4 + 12 | 0;
				while(true) {
					var x8 = p3++;
					var this37 = colorD;
					var c3 = this37;
					if((c3 >> 24 & 255) < 254 && pixelImage.transparent) {
						var location3 = pixelImage.useVirtualPos ? (q3 - pixelImage.virtualY) * pixelImage.width + x8 - pixelImage.virtualX | 0 : q3 * pixelImage.width + x8 | 0;
						var this38 = pixelImage.image[location3];
						var this39 = this38;
						var this40 = pixelimage_Endian_isLittleEndian ? (this39 >> 24 & 255) << 24 | (this39 & 255) << 16 | (this39 >> 8 & 255) << 8 | this39 >> 16 & 255 : this39;
						var this41 = this40 >> 24 & 255;
						var a13 = this41 == 0 ? 0. : this41 / 255;
						var this42 = this40 >> 16 & 255;
						var r13 = this42 == 0 ? 0. : this42 / 255;
						var this43 = this40 >> 8 & 255;
						var g13 = this43 == 0 ? 0. : this43 / 255;
						var this44 = this40 & 255;
						var b13 = this44 == 0 ? 0. : this44 / 255;
						var this45 = colorD >> 24 & 255;
						var a23 = this45 == 0 ? 0. : this45 / 255;
						var this46 = colorD >> 16 & 255;
						var r23 = this46 == 0 ? 0. : this46 / 255;
						var this47 = colorD >> 8 & 255;
						var g23 = this47 == 0 ? 0. : this47 / 255;
						var this48 = colorD & 255;
						var b23 = this48 == 0 ? 0. : this48 / 255;
						var a33 = a13 * (1 - a23);
						var r5 = 255 * (r13 * a33 + r23 * a23) | 0;
						var g5 = 255 * (g13 * a33 + g23 * a23) | 0;
						var b5 = 255 * (b13 * a33 + b23 * a23) | 0;
						var a7 = 255 * (a33 + a23) | 0;
						var blended3 = a7 << 24 | r5 << 16 | g5 << 8 | b5;
						pixelImage.image[location3] = pixelimage_Endian_isLittleEndian ? (blended3 >> 24 & 255) << 24 | (blended3 & 255) << 16 | (blended3 >> 8 & 255) << 8 | blended3 >> 16 & 255 : blended3;
					} else {
						pixelImage.image[pixelImage.useVirtualPos ? (q3 - pixelImage.virtualY) * pixelImage.width + x8 - pixelImage.virtualX | 0 : q3 * pixelImage.width + x8 | 0] = pixelimage_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3;
					}
					if(p3 > maxX3) {
						p3 = xx3;
						++q3;
					}
					if(q3 > maxY3) {
						break;
					}
				}
			}
			var aA = colorB >> 24 & 255;
			var rA = colorB >> 16 & 255;
			var gA = colorB >> 8 & 255;
			var bA = colorB & 255;
			var aB = colorA >> 24 & 255;
			var rB = colorA >> 16 & 255;
			var gB = colorA >> 8 & 255;
			var bB = colorA & 255;
			var aC = colorD >> 24 & 255;
			var rC = colorD >> 16 & 255;
			var gC = colorD >> 8 & 255;
			var bC = colorD & 255;
			var bcx = bx - dx;
			var bcy = by - dy;
			var acx = ax - dx;
			var acy = ay - dy;
			var dot11 = bcx * bcx + bcy * bcy;
			var dot12 = bcx * acx + bcy * acy;
			var dot22 = acx * acx + acy * acy;
			var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
			var _g = dx > bx ? dx > ax ? new IntIterator(bx > ax ? Math.floor(ax) : Math.floor(bx),Math.ceil(dx)) : new IntIterator(Math.floor(bx),Math.ceil(ax)) : bx > ax ? new IntIterator(dx > ax ? Math.floor(ax) : Math.ceil(dx),Math.ceil(bx)) : new IntIterator(Math.floor(dx),Math.ceil(ax));
			while(_g.min < _g.max) {
				var px = _g.min++;
				var pcx = px - dx;
				var _g1 = dy > by ? dy > ay ? new IntIterator(by > ay ? Math.floor(ay) : Math.floor(by),Math.ceil(dy)) : new IntIterator(Math.floor(by),Math.ceil(ay)) : by > ay ? new IntIterator(dy > ay ? Math.floor(ay) : Math.ceil(dy),Math.ceil(by)) : new IntIterator(Math.floor(dy),Math.ceil(ay));
				while(_g1.min < _g1.max) {
					var py = _g1.min++;
					var pcy = py - dy;
					var dot31 = pcx * bcx + pcy * bcy;
					var dot32 = pcx * acx + pcy * acy;
					var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
					var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
					var ratioC = 1.0 - ratioB - ratioA;
					if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
						var i1 = aA * ratioA + aB * ratioB + aC * ratioC | 0;
						if(i1 > 255) {
							i1 = 255;
						}
						if(i1 < 0) {
							i1 = 0;
						}
						var this49 = i1;
						var a8 = this49;
						var i2 = rA * ratioA + rB * ratioB + rC * ratioC | 0;
						if(i2 > 255) {
							i2 = 255;
						}
						if(i2 < 0) {
							i2 = 0;
						}
						var this50 = i2;
						var r6 = this50;
						var i3 = gA * ratioA + gB * ratioB + gC * ratioC | 0;
						if(i3 > 255) {
							i3 = 255;
						}
						if(i3 < 0) {
							i3 = 0;
						}
						var this51 = i3;
						var g6 = this51;
						var i4 = bA * ratioA + bB * ratioB + bC * ratioC | 0;
						if(i4 > 255) {
							i4 = 255;
						}
						if(i4 < 0) {
							i4 = 0;
						}
						var this52 = i4;
						var b6 = this52;
						var location4 = pixelImage.useVirtualPos ? (py - pixelImage.virtualY) * pixelImage.width + px - pixelImage.virtualX | 0 : py * pixelImage.width + px | 0;
						if(pixelImage.transparent && a8 < 254) {
							var this53 = pixelImage.image[location4];
							var this54 = this53;
							var old = pixelimage_Endian_isLittleEndian ? (this54 >> 24 & 255) << 24 | (this54 & 255) << 16 | (this54 >> 8 & 255) << 8 | this54 >> 16 & 255 : this54;
							var rhs = a8 << 24 | r6 << 16 | g6 << 8 | b6;
							var this55 = old >> 24 & 255;
							var a14 = this55 == 0 ? 0. : this55 / 255;
							var this56 = old >> 16 & 255;
							var r14 = this56 == 0 ? 0. : this56 / 255;
							var this57 = old >> 8 & 255;
							var g14 = this57 == 0 ? 0. : this57 / 255;
							var this58 = old & 255;
							var b14 = this58 == 0 ? 0. : this58 / 255;
							var this59 = rhs >> 24 & 255;
							var a24 = this59 == 0 ? 0. : this59 / 255;
							var this60 = rhs >> 16 & 255;
							var r24 = this60 == 0 ? 0. : this60 / 255;
							var this61 = rhs >> 8 & 255;
							var g24 = this61 == 0 ? 0. : this61 / 255;
							var this62 = rhs & 255;
							var b24 = this62 == 0 ? 0. : this62 / 255;
							var a34 = a14 * (1 - a24);
							var r7 = 255 * (r14 * a34 + r24 * a24) | 0;
							var g7 = 255 * (g14 * a34 + g24 * a24) | 0;
							var b7 = 255 * (b14 * a34 + b24 * a24) | 0;
							var a9 = 255 * (a34 + a24) | 0;
							var blended4 = a9 << 24 | r7 << 16 | g7 << 8 | b7;
							pixelImage.image[location4] = pixelimage_Endian_isLittleEndian ? (blended4 >> 24 & 255) << 24 | (blended4 & 255) << 16 | (blended4 >> 8 & 255) << 8 | blended4 >> 16 & 255 : blended4;
						} else {
							pixelImage.image[location4] = pixelImage.isLittle ? a8 << 24 | b6 << 16 | g6 << 8 | r6 : a8 << 24 | r6 << 16 | g6 << 8 | b6;
						}
					}
				}
			}
			var aA1 = colorC >> 24 & 255;
			var rA1 = colorC >> 16 & 255;
			var gA1 = colorC >> 8 & 255;
			var bA1 = colorC & 255;
			var aB1 = colorB >> 24 & 255;
			var rB1 = colorB >> 16 & 255;
			var gB1 = colorB >> 8 & 255;
			var bB1 = colorB & 255;
			var aC1 = colorD >> 24 & 255;
			var rC1 = colorD >> 16 & 255;
			var gC1 = colorD >> 8 & 255;
			var bC1 = colorD & 255;
			var bcx1 = cx - dx;
			var bcy1 = cy - dy;
			var acx1 = bx - dx;
			var acy1 = by - dy;
			var dot111 = bcx1 * bcx1 + bcy1 * bcy1;
			var dot121 = bcx1 * acx1 + bcy1 * acy1;
			var dot221 = acx1 * acx1 + acy1 * acy1;
			var denom11 = 1 / (dot111 * dot221 - dot121 * dot121);
			var _g2 = dx > cx ? dx > bx ? new IntIterator(cx > bx ? Math.floor(bx) : Math.floor(cx),Math.ceil(dx)) : new IntIterator(Math.floor(cx),Math.ceil(bx)) : cx > bx ? new IntIterator(dx > bx ? Math.floor(bx) : Math.ceil(dx),Math.ceil(cx)) : new IntIterator(Math.floor(dx),Math.ceil(bx));
			while(_g2.min < _g2.max) {
				var px1 = _g2.min++;
				var pcx1 = px1 - dx;
				var _g3 = dy > cy ? dy > by ? new IntIterator(cy > by ? Math.floor(by) : Math.floor(cy),Math.ceil(dy)) : new IntIterator(Math.floor(cy),Math.ceil(by)) : cy > by ? new IntIterator(dy > by ? Math.floor(by) : Math.ceil(dy),Math.ceil(cy)) : new IntIterator(Math.floor(dy),Math.ceil(by));
				while(_g3.min < _g3.max) {
					var py1 = _g3.min++;
					var pcy1 = py1 - dy;
					var dot311 = pcx1 * bcx1 + pcy1 * bcy1;
					var dot321 = pcx1 * acx1 + pcy1 * acy1;
					var ratioA1 = (dot221 * dot311 - dot121 * dot321) * denom11;
					var ratioB1 = (dot111 * dot321 - dot121 * dot311) * denom11;
					var ratioC1 = 1.0 - ratioB1 - ratioA1;
					if(ratioA1 >= 0 && ratioB1 >= 0 && ratioC1 >= 0) {
						var i5 = aA1 * ratioA1 + aB1 * ratioB1 + aC1 * ratioC1 | 0;
						if(i5 > 255) {
							i5 = 255;
						}
						if(i5 < 0) {
							i5 = 0;
						}
						var this63 = i5;
						var a10 = this63;
						var i6 = rA1 * ratioA1 + rB1 * ratioB1 + rC1 * ratioC1 | 0;
						if(i6 > 255) {
							i6 = 255;
						}
						if(i6 < 0) {
							i6 = 0;
						}
						var this64 = i6;
						var r8 = this64;
						var i7 = gA1 * ratioA1 + gB1 * ratioB1 + gC1 * ratioC1 | 0;
						if(i7 > 255) {
							i7 = 255;
						}
						if(i7 < 0) {
							i7 = 0;
						}
						var this65 = i7;
						var g8 = this65;
						var i8 = bA1 * ratioA1 + bB1 * ratioB1 + bC1 * ratioC1 | 0;
						if(i8 > 255) {
							i8 = 255;
						}
						if(i8 < 0) {
							i8 = 0;
						}
						var this66 = i8;
						var b8 = this66;
						var location5 = pixelImage.useVirtualPos ? (py1 - pixelImage.virtualY) * pixelImage.width + px1 - pixelImage.virtualX | 0 : py1 * pixelImage.width + px1 | 0;
						if(pixelImage.transparent && a10 < 254) {
							var this67 = pixelImage.image[location5];
							var this68 = this67;
							var old1 = pixelimage_Endian_isLittleEndian ? (this68 >> 24 & 255) << 24 | (this68 & 255) << 16 | (this68 >> 8 & 255) << 8 | this68 >> 16 & 255 : this68;
							var rhs1 = a10 << 24 | r8 << 16 | g8 << 8 | b8;
							var this69 = old1 >> 24 & 255;
							var a15 = this69 == 0 ? 0. : this69 / 255;
							var this70 = old1 >> 16 & 255;
							var r15 = this70 == 0 ? 0. : this70 / 255;
							var this71 = old1 >> 8 & 255;
							var g15 = this71 == 0 ? 0. : this71 / 255;
							var this72 = old1 & 255;
							var b15 = this72 == 0 ? 0. : this72 / 255;
							var this73 = rhs1 >> 24 & 255;
							var a25 = this73 == 0 ? 0. : this73 / 255;
							var this74 = rhs1 >> 16 & 255;
							var r25 = this74 == 0 ? 0. : this74 / 255;
							var this75 = rhs1 >> 8 & 255;
							var g25 = this75 == 0 ? 0. : this75 / 255;
							var this76 = rhs1 & 255;
							var b25 = this76 == 0 ? 0. : this76 / 255;
							var a35 = a15 * (1 - a25);
							var r9 = 255 * (r15 * a35 + r25 * a25) | 0;
							var g9 = 255 * (g15 * a35 + g25 * a25) | 0;
							var b9 = 255 * (b15 * a35 + b25 * a25) | 0;
							var a16 = 255 * (a35 + a25) | 0;
							var blended5 = a16 << 24 | r9 << 16 | g9 << 8 | b9;
							pixelImage.image[location5] = pixelimage_Endian_isLittleEndian ? (blended5 >> 24 & 255) << 24 | (blended5 & 255) << 16 | (blended5 >> 8 & 255) << 8 | blended5 >> 16 & 255 : blended5;
						} else {
							pixelImage.image[location5] = pixelImage.isLittle ? a10 << 24 | b8 << 16 | g8 << 8 | r8 : a10 << 24 | r8 << 16 | g8 << 8 | b8;
						}
					}
				}
			}
		}
	}
	,__class__: pixelimage_shapeStruct_PolyLineGradient
});
var pixelimage_shapeStruct_PolyLineShape = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,points) {
	if(fill == null) {
		fill = 0;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = 0;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pixelimage_shapeStruct_FillShape.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill);
	this.points = points;
};
pixelimage_shapeStruct_PolyLineShape.__name__ = "pixelimage.shapeStruct.PolyLineShape";
pixelimage_shapeStruct_PolyLineShape.__super__ = pixelimage_shapeStruct_FillShape;
pixelimage_shapeStruct_PolyLineShape.prototype = $extend(pixelimage_shapeStruct_FillShape.prototype,{
	setParameter: function(name,value) {
		if(name == "points") {
			value = value.split("[")[1].split("]")[0];
			var _g = [];
			var _g1 = 0;
			var _g2 = value.split(",");
			while(_g1 < _g2.length) {
				var n = _g2[_g1];
				++_g1;
				_g.push(parseFloat(n));
			}
			this.points = _g;
		} else {
			pixelimage_shapeStruct_FillShape.prototype.setParameter.call(this,name,value);
		}
	}
	,render: function(pixelImage) {
		var l = this.points.length;
		if(l < 4) {
			return;
		}
		if(l % 2 != 0) {
			return;
		}
		var i = 0;
		var x = 0.;
		var y = 0.;
		var nextX = 0.;
		var nextY = 0.;
		x = this.points[i];
		++i;
		y = this.points[i];
		++i;
		while(i < l) {
			x = this.points[i];
			++i;
			y = this.points[i];
			++i;
			nextX = x;
			nextY = y;
			var color = this.strokeColor;
			var o = nextY - y;
			var a = nextX - y;
			var h = Math.pow(o * o + a * a,0.5);
			var theta = Math.atan2(o,a);
			var debugCorners = false;
			if(debugCorners == null) {
				debugCorners = false;
			}
			var sin = Math.sin(theta);
			var cos = Math.cos(theta);
			var radius = this.strokeWidth / 2;
			var dx = 0.1;
			var dy = radius;
			var cx = h;
			var cy = radius;
			var bx = h;
			var by = -radius;
			var ax = 0.1;
			var ay = -radius;
			var temp = 0.;
			temp = x + (ax * cos - ay * sin);
			ay = y + (ay * cos + ax * sin);
			ax = temp;
			temp = x + (bx * cos - by * sin);
			by = y + (by * cos + bx * sin);
			bx = temp;
			temp = x + (cx * cos - cy * sin);
			cy = y + (cy * cos + cx * sin);
			cx = temp;
			temp = x + (dx * cos - dy * sin);
			dy = y + (dy * cos + dx * sin);
			dx = temp;
			if(debugCorners) {
				var x1 = ax - 6.;
				var y1 = ay - 6.;
				var p = x1 | 0;
				var xx = p;
				var q = y1 | 0;
				var maxX = x1 + 12 | 0;
				var maxY = y1 + 12 | 0;
				while(true) {
					var x2 = p++;
					var this1 = -65536;
					var c = this1;
					if((c >> 24 & 255) < 254 && pixelImage.transparent) {
						var location = pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x2 - pixelImage.virtualX | 0 : q * pixelImage.width + x2 | 0;
						var this2 = pixelImage.image[location];
						var this3 = this2;
						var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = 0;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = 0;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a4 = 255 * (a3 + a2) | 0;
						var blended = a4 << 24 | r << 16 | g << 8 | b;
						pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelImage.image[pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x2 - pixelImage.virtualX | 0 : q * pixelImage.width + x2 | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					if(p > maxX) {
						p = xx;
						++q;
					}
					if(q > maxY) {
						break;
					}
				}
				var x3 = bx - 6.;
				var y2 = by - 6.;
				var p1 = x3 | 0;
				var xx1 = p1;
				var q1 = y2 | 0;
				var maxX1 = x3 + 12 | 0;
				var maxY1 = y2 + 12 | 0;
				while(true) {
					var x4 = p1++;
					var this13 = -16711936;
					var c1 = this13;
					if((c1 >> 24 & 255) < 254 && pixelImage.transparent) {
						var location1 = pixelImage.useVirtualPos ? (q1 - pixelImage.virtualY) * pixelImage.width + x4 - pixelImage.virtualX | 0 : q1 * pixelImage.width + x4 | 0;
						var this14 = pixelImage.image[location1];
						var this15 = this14;
						var this16 = pixelimage_Endian_isLittleEndian ? (this15 >> 24 & 255) << 24 | (this15 & 255) << 16 | (this15 >> 8 & 255) << 8 | this15 >> 16 & 255 : this15;
						var this17 = this16 >> 24 & 255;
						var a11 = this17 == 0 ? 0. : this17 / 255;
						var this18 = this16 >> 16 & 255;
						var r11 = this18 == 0 ? 0. : this18 / 255;
						var this19 = this16 >> 8 & 255;
						var g11 = this19 == 0 ? 0. : this19 / 255;
						var this20 = this16 & 255;
						var b11 = this20 == 0 ? 0. : this20 / 255;
						var this21 = 255;
						var a21 = this21 == 0 ? 0. : this21 / 255;
						var this22 = 0;
						var r21 = this22 == 0 ? 0. : this22 / 255;
						var this23 = 255;
						var g21 = this23 == 0 ? 0. : this23 / 255;
						var this24 = 0;
						var b21 = this24 == 0 ? 0. : this24 / 255;
						var a31 = a11 * (1 - a21);
						var r3 = 255 * (r11 * a31 + r21 * a21) | 0;
						var g3 = 255 * (g11 * a31 + g21 * a21) | 0;
						var b3 = 255 * (b11 * a31 + b21 * a21) | 0;
						var a5 = 255 * (a31 + a21) | 0;
						var blended1 = a5 << 24 | r3 << 16 | g3 << 8 | b3;
						pixelImage.image[location1] = pixelimage_Endian_isLittleEndian ? (blended1 >> 24 & 255) << 24 | (blended1 & 255) << 16 | (blended1 >> 8 & 255) << 8 | blended1 >> 16 & 255 : blended1;
					} else {
						pixelImage.image[pixelImage.useVirtualPos ? (q1 - pixelImage.virtualY) * pixelImage.width + x4 - pixelImage.virtualX | 0 : q1 * pixelImage.width + x4 | 0] = pixelimage_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
					}
					if(p1 > maxX1) {
						p1 = xx1;
						++q1;
					}
					if(q1 > maxY1) {
						break;
					}
				}
				var x5 = cx - 6.;
				var y3 = cy - 6.;
				var p2 = x5 | 0;
				var xx2 = p2;
				var q2 = y3 | 0;
				var maxX2 = x5 + 12 | 0;
				var maxY2 = y3 + 12 | 0;
				while(true) {
					var x6 = p2++;
					var this25 = -16776961;
					var c2 = this25;
					if((c2 >> 24 & 255) < 254 && pixelImage.transparent) {
						var location2 = pixelImage.useVirtualPos ? (q2 - pixelImage.virtualY) * pixelImage.width + x6 - pixelImage.virtualX | 0 : q2 * pixelImage.width + x6 | 0;
						var this26 = pixelImage.image[location2];
						var this27 = this26;
						var this28 = pixelimage_Endian_isLittleEndian ? (this27 >> 24 & 255) << 24 | (this27 & 255) << 16 | (this27 >> 8 & 255) << 8 | this27 >> 16 & 255 : this27;
						var this29 = this28 >> 24 & 255;
						var a12 = this29 == 0 ? 0. : this29 / 255;
						var this30 = this28 >> 16 & 255;
						var r12 = this30 == 0 ? 0. : this30 / 255;
						var this31 = this28 >> 8 & 255;
						var g12 = this31 == 0 ? 0. : this31 / 255;
						var this32 = this28 & 255;
						var b12 = this32 == 0 ? 0. : this32 / 255;
						var this33 = 255;
						var a22 = this33 == 0 ? 0. : this33 / 255;
						var this34 = 0;
						var r22 = this34 == 0 ? 0. : this34 / 255;
						var this35 = 0;
						var g22 = this35 == 0 ? 0. : this35 / 255;
						var this36 = 255;
						var b22 = this36 == 0 ? 0. : this36 / 255;
						var a32 = a12 * (1 - a22);
						var r4 = 255 * (r12 * a32 + r22 * a22) | 0;
						var g4 = 255 * (g12 * a32 + g22 * a22) | 0;
						var b4 = 255 * (b12 * a32 + b22 * a22) | 0;
						var a6 = 255 * (a32 + a22) | 0;
						var blended2 = a6 << 24 | r4 << 16 | g4 << 8 | b4;
						pixelImage.image[location2] = pixelimage_Endian_isLittleEndian ? (blended2 >> 24 & 255) << 24 | (blended2 & 255) << 16 | (blended2 >> 8 & 255) << 8 | blended2 >> 16 & 255 : blended2;
					} else {
						pixelImage.image[pixelImage.useVirtualPos ? (q2 - pixelImage.virtualY) * pixelImage.width + x6 - pixelImage.virtualX | 0 : q2 * pixelImage.width + x6 | 0] = pixelimage_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
					}
					if(p2 > maxX2) {
						p2 = xx2;
						++q2;
					}
					if(q2 > maxY2) {
						break;
					}
				}
				var x7 = dx - 6.;
				var y4 = dy - 6.;
				var p3 = x7 | 0;
				var xx3 = p3;
				var q3 = y4 | 0;
				var maxX3 = x7 + 12 | 0;
				var maxY3 = y4 + 12 | 0;
				while(true) {
					var x8 = p3++;
					var this37 = -1048336;
					var c3 = this37;
					if((c3 >> 24 & 255) < 254 && pixelImage.transparent) {
						var location3 = pixelImage.useVirtualPos ? (q3 - pixelImage.virtualY) * pixelImage.width + x8 - pixelImage.virtualX | 0 : q3 * pixelImage.width + x8 | 0;
						var this38 = pixelImage.image[location3];
						var this39 = this38;
						var this40 = pixelimage_Endian_isLittleEndian ? (this39 >> 24 & 255) << 24 | (this39 & 255) << 16 | (this39 >> 8 & 255) << 8 | this39 >> 16 & 255 : this39;
						var this41 = this40 >> 24 & 255;
						var a13 = this41 == 0 ? 0. : this41 / 255;
						var this42 = this40 >> 16 & 255;
						var r13 = this42 == 0 ? 0. : this42 / 255;
						var this43 = this40 >> 8 & 255;
						var g13 = this43 == 0 ? 0. : this43 / 255;
						var this44 = this40 & 255;
						var b13 = this44 == 0 ? 0. : this44 / 255;
						var this45 = 255;
						var a23 = this45 == 0 ? 0. : this45 / 255;
						var this46 = 240;
						var r23 = this46 == 0 ? 0. : this46 / 255;
						var this47 = 0;
						var g23 = this47 == 0 ? 0. : this47 / 255;
						var this48 = 240;
						var b23 = this48 == 0 ? 0. : this48 / 255;
						var a33 = a13 * (1 - a23);
						var r5 = 255 * (r13 * a33 + r23 * a23) | 0;
						var g5 = 255 * (g13 * a33 + g23 * a23) | 0;
						var b5 = 255 * (b13 * a33 + b23 * a23) | 0;
						var a7 = 255 * (a33 + a23) | 0;
						var blended3 = a7 << 24 | r5 << 16 | g5 << 8 | b5;
						pixelImage.image[location3] = pixelimage_Endian_isLittleEndian ? (blended3 >> 24 & 255) << 24 | (blended3 & 255) << 16 | (blended3 >> 8 & 255) << 8 | blended3 >> 16 & 255 : blended3;
					} else {
						pixelImage.image[pixelImage.useVirtualPos ? (q3 - pixelImage.virtualY) * pixelImage.width + x8 - pixelImage.virtualX | 0 : q3 * pixelImage.width + x8 | 0] = pixelimage_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3;
					}
					if(p3 > maxX3) {
						p3 = xx3;
						++q3;
					}
					if(q3 > maxY3) {
						break;
					}
				}
			}
			var bx1 = bx;
			var by1 = by;
			var cx1 = dx;
			var cy1 = dy;
			var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy1 - cx1 * by1) + (cx1 * ay - ax * cy1) > 0;
			if(!adjustWinding) {
				var bx_ = bx1;
				var by_ = by1;
				bx1 = cx1;
				by1 = cy1;
				cx1 = bx_;
				cy1 = by_;
			}
			var s0 = ay * cx1 - ax * cy1;
			var sx = cy1 - ay;
			var sy = ax - cx1;
			var t0 = ax * by1 - ay * bx1;
			var tx = ay - by1;
			var ty = bx1 - ax;
			var A = -by1 * cx1 + ay * (-bx1 + cx1) + ax * (by1 - cy1) + bx1 * cy1;
			var ii = ay > by1 ? ay > cy1 ? new IntIterator(by1 > cy1 ? Math.floor(cy1) : Math.floor(by1),Math.ceil(ay)) : new IntIterator(Math.floor(by1),Math.ceil(cy1)) : by1 > cy1 ? new IntIterator(ay > cy1 ? Math.floor(cy1) : Math.ceil(ay),Math.ceil(by1)) : new IntIterator(Math.floor(ay),Math.ceil(cy1));
			var this49 = new pixelimage_iter_IntIterStart(ii.min,ii.max);
			var yIter3 = this49;
			var foundY = false;
			var s = 0.;
			var t = 0.;
			var sxx = 0.;
			var txx = 0.;
			var _g = ax > bx1 ? ax > cx1 ? new IntIterator(bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1),Math.ceil(ax)) : new IntIterator(Math.floor(bx1),Math.ceil(cx1)) : bx1 > cx1 ? new IntIterator(ax > cx1 ? Math.floor(cx1) : Math.ceil(ax),Math.ceil(bx1)) : new IntIterator(Math.floor(ax),Math.ceil(cx1));
			while(_g.min < _g.max) {
				var x9 = _g.min++;
				sxx = sx * x9;
				txx = tx * x9;
				foundY = false;
				var _g_min = yIter3.start;
				var _g_max = yIter3.max;
				while(_g_min < _g_max) {
					var y5 = _g_min++;
					s = s0 + sxx + sy * y5;
					t = t0 + txx + ty * y5;
					if(s <= 0 || t <= 0) {
						if(foundY) {
							break;
						}
					} else if(s + t < A) {
						var this50 = color;
						var c4 = this50;
						if((c4 >> 24 & 255) < 254 && pixelImage.transparent) {
							var location4 = pixelImage.useVirtualPos ? (y5 - pixelImage.virtualY) * pixelImage.width + x9 - pixelImage.virtualX | 0 : y5 * pixelImage.width + x9 | 0;
							var this51 = pixelImage.image[location4];
							var this52 = this51;
							var this53 = pixelimage_Endian_isLittleEndian ? (this52 >> 24 & 255) << 24 | (this52 & 255) << 16 | (this52 >> 8 & 255) << 8 | this52 >> 16 & 255 : this52;
							var this54 = this53 >> 24 & 255;
							var a14 = this54 == 0 ? 0. : this54 / 255;
							var this55 = this53 >> 16 & 255;
							var r14 = this55 == 0 ? 0. : this55 / 255;
							var this56 = this53 >> 8 & 255;
							var g14 = this56 == 0 ? 0. : this56 / 255;
							var this57 = this53 & 255;
							var b14 = this57 == 0 ? 0. : this57 / 255;
							var this58 = color >> 24 & 255;
							var a24 = this58 == 0 ? 0. : this58 / 255;
							var this59 = color >> 16 & 255;
							var r24 = this59 == 0 ? 0. : this59 / 255;
							var this60 = color >> 8 & 255;
							var g24 = this60 == 0 ? 0. : this60 / 255;
							var this61 = color & 255;
							var b24 = this61 == 0 ? 0. : this61 / 255;
							var a34 = a14 * (1 - a24);
							var r6 = 255 * (r14 * a34 + r24 * a24) | 0;
							var g6 = 255 * (g14 * a34 + g24 * a24) | 0;
							var b6 = 255 * (b14 * a34 + b24 * a24) | 0;
							var a8 = 255 * (a34 + a24) | 0;
							var blended4 = a8 << 24 | r6 << 16 | g6 << 8 | b6;
							pixelImage.image[location4] = pixelimage_Endian_isLittleEndian ? (blended4 >> 24 & 255) << 24 | (blended4 & 255) << 16 | (blended4 >> 8 & 255) << 8 | blended4 >> 16 & 255 : blended4;
						} else {
							pixelImage.image[pixelImage.useVirtualPos ? (y5 - pixelImage.virtualY) * pixelImage.width + x9 - pixelImage.virtualX | 0 : y5 * pixelImage.width + x9 | 0] = pixelimage_Endian_isLittleEndian ? (c4 >> 24 & 255) << 24 | (c4 & 255) << 16 | (c4 >> 8 & 255) << 8 | c4 >> 16 & 255 : c4;
						}
						foundY = true;
					} else if(foundY) {
						break;
					}
				}
			}
			var bx2 = cx;
			var by2 = cy;
			var cx2 = dx;
			var cy2 = dy;
			var adjustWinding1 = bx * by2 - bx2 * by + (bx2 * cy2 - cx2 * by2) + (cx2 * by - bx * cy2) > 0;
			if(!adjustWinding1) {
				var bx_1 = bx2;
				var by_1 = by2;
				bx2 = cx2;
				by2 = cy2;
				cx2 = bx_1;
				cy2 = by_1;
			}
			var s01 = by * cx2 - bx * cy2;
			var sx1 = cy2 - by;
			var sy1 = bx - cx2;
			var t01 = bx * by2 - by * bx2;
			var tx1 = by - by2;
			var ty1 = bx2 - bx;
			var A1 = -by2 * cx2 + by * (-bx2 + cx2) + bx * (by2 - cy2) + bx2 * cy2;
			var ii1 = by > by2 ? by > cy2 ? new IntIterator(by2 > cy2 ? Math.floor(cy2) : Math.floor(by2),Math.ceil(by)) : new IntIterator(Math.floor(by2),Math.ceil(cy2)) : by2 > cy2 ? new IntIterator(by > cy2 ? Math.floor(cy2) : Math.ceil(by),Math.ceil(by2)) : new IntIterator(Math.floor(by),Math.ceil(cy2));
			var this62 = new pixelimage_iter_IntIterStart(ii1.min,ii1.max);
			var yIter31 = this62;
			var foundY1 = false;
			var s1 = 0.;
			var t1 = 0.;
			var sxx1 = 0.;
			var txx1 = 0.;
			var _g1 = bx > bx2 ? bx > cx2 ? new IntIterator(bx2 > cx2 ? Math.floor(cx2) : Math.floor(bx2),Math.ceil(bx)) : new IntIterator(Math.floor(bx2),Math.ceil(cx2)) : bx2 > cx2 ? new IntIterator(bx > cx2 ? Math.floor(cx2) : Math.ceil(bx),Math.ceil(bx2)) : new IntIterator(Math.floor(bx),Math.ceil(cx2));
			while(_g1.min < _g1.max) {
				var x10 = _g1.min++;
				sxx1 = sx1 * x10;
				txx1 = tx1 * x10;
				foundY1 = false;
				var _g_min1 = yIter31.start;
				var _g_max1 = yIter31.max;
				while(_g_min1 < _g_max1) {
					var y6 = _g_min1++;
					s1 = s01 + sxx1 + sy1 * y6;
					t1 = t01 + txx1 + ty1 * y6;
					if(s1 <= 0 || t1 <= 0) {
						if(foundY1) {
							break;
						}
					} else if(s1 + t1 < A1) {
						var this63 = color;
						var c5 = this63;
						if((c5 >> 24 & 255) < 254 && pixelImage.transparent) {
							var location5 = pixelImage.useVirtualPos ? (y6 - pixelImage.virtualY) * pixelImage.width + x10 - pixelImage.virtualX | 0 : y6 * pixelImage.width + x10 | 0;
							var this64 = pixelImage.image[location5];
							var this65 = this64;
							var this66 = pixelimage_Endian_isLittleEndian ? (this65 >> 24 & 255) << 24 | (this65 & 255) << 16 | (this65 >> 8 & 255) << 8 | this65 >> 16 & 255 : this65;
							var this67 = this66 >> 24 & 255;
							var a15 = this67 == 0 ? 0. : this67 / 255;
							var this68 = this66 >> 16 & 255;
							var r15 = this68 == 0 ? 0. : this68 / 255;
							var this69 = this66 >> 8 & 255;
							var g15 = this69 == 0 ? 0. : this69 / 255;
							var this70 = this66 & 255;
							var b15 = this70 == 0 ? 0. : this70 / 255;
							var this71 = color >> 24 & 255;
							var a25 = this71 == 0 ? 0. : this71 / 255;
							var this72 = color >> 16 & 255;
							var r25 = this72 == 0 ? 0. : this72 / 255;
							var this73 = color >> 8 & 255;
							var g25 = this73 == 0 ? 0. : this73 / 255;
							var this74 = color & 255;
							var b25 = this74 == 0 ? 0. : this74 / 255;
							var a35 = a15 * (1 - a25);
							var r7 = 255 * (r15 * a35 + r25 * a25) | 0;
							var g7 = 255 * (g15 * a35 + g25 * a25) | 0;
							var b7 = 255 * (b15 * a35 + b25 * a25) | 0;
							var a9 = 255 * (a35 + a25) | 0;
							var blended5 = a9 << 24 | r7 << 16 | g7 << 8 | b7;
							pixelImage.image[location5] = pixelimage_Endian_isLittleEndian ? (blended5 >> 24 & 255) << 24 | (blended5 & 255) << 16 | (blended5 >> 8 & 255) << 8 | blended5 >> 16 & 255 : blended5;
						} else {
							pixelImage.image[pixelImage.useVirtualPos ? (y6 - pixelImage.virtualY) * pixelImage.width + x10 - pixelImage.virtualX | 0 : y6 * pixelImage.width + x10 | 0] = pixelimage_Endian_isLittleEndian ? (c5 >> 24 & 255) << 24 | (c5 & 255) << 16 | (c5 >> 8 & 255) << 8 | c5 >> 16 & 255 : c5;
						}
						foundY1 = true;
					} else if(foundY1) {
						break;
					}
				}
			}
		}
	}
	,__class__: pixelimage_shapeStruct_PolyLineShape
});
var pixelimage_shapeStruct_QuadCurveShape = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,thru,x1,y1,x2,y2,x3,y3,x4,y4) {
	if(y4 == null) {
		y4 = 0.;
	}
	if(x4 == null) {
		x4 = 0.;
	}
	if(y3 == null) {
		y3 = 0.;
	}
	if(x3 == null) {
		x3 = 0.;
	}
	if(y2 == null) {
		y2 = 0.;
	}
	if(x2 == null) {
		x2 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	if(thru == null) {
		thru = false;
	}
	if(fill == null) {
		fill = 0;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = 0;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pixelimage_shapeStruct_FillShape.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill);
	this.x1 = x1;
	this.y1 = y1;
	this.x2 = x2;
	this.y2 = y2;
	this.x3 = x3;
	this.y3 = y3;
	this.x4 = x4;
	this.y4 = y4;
};
pixelimage_shapeStruct_QuadCurveShape.__name__ = "pixelimage.shapeStruct.QuadCurveShape";
pixelimage_shapeStruct_QuadCurveShape.__super__ = pixelimage_shapeStruct_FillShape;
pixelimage_shapeStruct_QuadCurveShape.prototype = $extend(pixelimage_shapeStruct_FillShape.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "x1":
			this.x1 = parseFloat(value);
			break;
		case "x2":
			this.x2 = parseFloat(value);
			break;
		case "x3":
			this.x3 = parseFloat(value);
			break;
		case "x4":
			this.x4 = parseFloat(value);
			break;
		case "y1":
			this.y1 = parseFloat(value);
			break;
		case "y2":
			this.y2 = parseFloat(value);
			break;
		case "y3":
			this.y3 = parseFloat(value);
			break;
		case "y4":
			this.y4 = parseFloat(value);
			break;
		default:
			pixelimage_shapeStruct_FillShape.prototype.setParameter.call(this,name,value);
		}
	}
	,render: function(pixelImage) {
		haxe_Log.trace("Yet to implement",{ fileName : "src/pixelimage/shapeStruct/QuadCurveShape.hx", lineNumber : 66, className : "pixelimage.shapeStruct.QuadCurveShape", methodName : "render"});
	}
	,__class__: pixelimage_shapeStruct_QuadCurveShape
});
var pixelimage_shapeStruct_QuadShape = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,x1,y1,x2,y2,x3,y3,x4,y4) {
	if(y4 == null) {
		y4 = 0.;
	}
	if(x4 == null) {
		x4 = 0.;
	}
	if(y3 == null) {
		y3 = 0.;
	}
	if(x3 == null) {
		x3 = 0.;
	}
	if(y2 == null) {
		y2 = 0.;
	}
	if(x2 == null) {
		x2 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	if(fill == null) {
		fill = 0;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = 0;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pixelimage_shapeStruct_FillShape.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill);
	this.x1 = x1;
	this.y1 = y1;
	this.x2 = x2;
	this.y2 = y2;
	this.x3 = x3;
	this.y3 = y3;
	this.x4 = x4;
	this.y4 = y4;
};
pixelimage_shapeStruct_QuadShape.__name__ = "pixelimage.shapeStruct.QuadShape";
pixelimage_shapeStruct_QuadShape.__super__ = pixelimage_shapeStruct_FillShape;
pixelimage_shapeStruct_QuadShape.prototype = $extend(pixelimage_shapeStruct_FillShape.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "x1":
			this.x1 = parseFloat(value);
			break;
		case "x2":
			this.x2 = parseFloat(value);
			break;
		case "x3":
			this.x3 = parseFloat(value);
			break;
		case "x4":
			this.x4 = parseFloat(value);
			break;
		case "y1":
			this.y1 = parseFloat(value);
			break;
		case "y2":
			this.y2 = parseFloat(value);
			break;
		case "y3":
			this.y3 = parseFloat(value);
			break;
		case "y4":
			this.y4 = parseFloat(value);
			break;
		default:
			pixelimage_shapeStruct_FillShape.prototype.setParameter.call(this,name,value);
		}
	}
	,render: function(pixelImage) {
		var ax = this.x1;
		var ay = this.y1;
		var bx = this.x2;
		var by = this.y2;
		var cx = this.x3;
		var cy = this.y3;
		var dx = this.x4;
		var dy = this.y4;
		var color = this.fill;
		var bx1 = bx;
		var by1 = by;
		var cx1 = dx;
		var cy1 = dy;
		var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy1 - cx1 * by1) + (cx1 * ay - ax * cy1) > 0;
		if(!adjustWinding) {
			var bx_ = bx1;
			var by_ = by1;
			bx1 = cx1;
			by1 = cy1;
			cx1 = bx_;
			cy1 = by_;
		}
		var s0 = ay * cx1 - ax * cy1;
		var sx = cy1 - ay;
		var sy = ax - cx1;
		var t0 = ax * by1 - ay * bx1;
		var tx = ay - by1;
		var ty = bx1 - ax;
		var A = -by1 * cx1 + ay * (-bx1 + cx1) + ax * (by1 - cy1) + bx1 * cy1;
		var ii = ay > by1 ? ay > cy1 ? new IntIterator(by1 > cy1 ? Math.floor(cy1) : Math.floor(by1),Math.ceil(ay)) : new IntIterator(Math.floor(by1),Math.ceil(cy1)) : by1 > cy1 ? new IntIterator(ay > cy1 ? Math.floor(cy1) : Math.ceil(ay),Math.ceil(by1)) : new IntIterator(Math.floor(ay),Math.ceil(cy1));
		var this1 = new pixelimage_iter_IntIterStart(ii.min,ii.max);
		var yIter3 = this1;
		var foundY = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g = ax > bx1 ? ax > cx1 ? new IntIterator(bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1),Math.ceil(ax)) : new IntIterator(Math.floor(bx1),Math.ceil(cx1)) : bx1 > cx1 ? new IntIterator(ax > cx1 ? Math.floor(cx1) : Math.ceil(ax),Math.ceil(bx1)) : new IntIterator(Math.floor(ax),Math.ceil(cx1));
		while(_g.min < _g.max) {
			var x = _g.min++;
			sxx = sx * x;
			txx = tx * x;
			foundY = false;
			var _g_min = yIter3.start;
			var _g_max = yIter3.max;
			while(_g_min < _g_max) {
				var y = _g_min++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(foundY) {
						break;
					}
				} else if(s + t < A) {
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && pixelImage.transparent) {
						var location = pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0;
						var this2 = pixelImage.image[location];
						var this3 = this2;
						var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelImage.image[pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					foundY = true;
				} else if(foundY) {
					break;
				}
			}
		}
		var bx1 = cx;
		var by1 = cy;
		var cx = dx;
		var cy = dy;
		var adjustWinding = bx * by1 - bx1 * by + (bx1 * cy - cx * by1) + (cx * by - bx * cy) > 0;
		if(!adjustWinding) {
			var bx_ = bx1;
			var by_ = by1;
			bx1 = cx;
			by1 = cy;
			cx = bx_;
			cy = by_;
		}
		var s0 = by * cx - bx * cy;
		var sx = cy - by;
		var sy = bx - cx;
		var t0 = bx * by1 - by * bx1;
		var tx = by - by1;
		var ty = bx1 - bx;
		var A = -by1 * cx + by * (-bx1 + cx) + bx * (by1 - cy) + bx1 * cy;
		var ii = by > by1 ? by > cy ? new IntIterator(by1 > cy ? Math.floor(cy) : Math.floor(by1),Math.ceil(by)) : new IntIterator(Math.floor(by1),Math.ceil(cy)) : by1 > cy ? new IntIterator(by > cy ? Math.floor(cy) : Math.ceil(by),Math.ceil(by1)) : new IntIterator(Math.floor(by),Math.ceil(cy));
		var this1 = new pixelimage_iter_IntIterStart(ii.min,ii.max);
		var yIter3 = this1;
		var foundY = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g = bx > bx1 ? bx > cx ? new IntIterator(bx1 > cx ? Math.floor(cx) : Math.floor(bx1),Math.ceil(bx)) : new IntIterator(Math.floor(bx1),Math.ceil(cx)) : bx1 > cx ? new IntIterator(bx > cx ? Math.floor(cx) : Math.ceil(bx),Math.ceil(bx1)) : new IntIterator(Math.floor(bx),Math.ceil(cx));
		while(_g.min < _g.max) {
			var x = _g.min++;
			sxx = sx * x;
			txx = tx * x;
			foundY = false;
			var _g_min = yIter3.start;
			var _g_max = yIter3.max;
			while(_g_min < _g_max) {
				var y = _g_min++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(foundY) {
						break;
					}
				} else if(s + t < A) {
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && pixelImage.transparent) {
						var location = pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0;
						var this2 = pixelImage.image[location];
						var this3 = this2;
						var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelImage.image[pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					foundY = true;
				} else if(foundY) {
					break;
				}
			}
		}
	}
	,__class__: pixelimage_shapeStruct_QuadShape
});
var pixelimage_shapeStruct_RectangleShape = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,width,height,rounded) {
	if(rounded == null) {
		rounded = false;
	}
	if(height == null) {
		height = 1.;
	}
	if(width == null) {
		width = 1.;
	}
	if(top == null) {
		top = 0.;
	}
	if(left == null) {
		left = 0.;
	}
	if(fill == null) {
		fill = 0;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = 0;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pixelimage_shapeStruct_FillShape.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill);
	this.left = left;
	this.top = top;
	this.width = width;
	this.height = height;
	this.rounded = rounded;
};
pixelimage_shapeStruct_RectangleShape.__name__ = "pixelimage.shapeStruct.RectangleShape";
pixelimage_shapeStruct_RectangleShape.__super__ = pixelimage_shapeStruct_FillShape;
pixelimage_shapeStruct_RectangleShape.prototype = $extend(pixelimage_shapeStruct_FillShape.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "height":
			this.height = parseFloat(value);
			break;
		case "left":
			this.left = parseFloat(value);
			break;
		case "rounded":
			this.rounded = value.toLowerCase() == "true";
			break;
		case "top":
			this.top = parseFloat(value);
			break;
		case "width":
			this.width = parseFloat(value);
			break;
		default:
			pixelimage_shapeStruct_FillShape.prototype.setParameter.call(this,name,value);
		}
	}
	,render: function(pixelImage) {
		if(this.rounded == false) {
			var w = Math.ceil(this.width);
			var h = Math.ceil(this.height);
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimage_ImageStruct(w,h,this1);
			var temp = this2;
			temp.transparent = false;
			var color = this.strokeColor;
			var p = 0;
			var xx = p;
			var q = 0;
			var maxX = this.width | 0;
			var maxY = this.height | 0;
			while(true) {
				var x = p++;
				var this1 = color;
				var c = this1;
				if((c >> 24 & 255) < 254 && temp.transparent) {
					var location = temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0;
					var this2 = temp.image[location];
					var this3 = this2;
					var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = color >> 24 & 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = color >> 16 & 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = color >> 8 & 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = color & 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					temp.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					temp.image[temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var x = this.strokeWidth;
			var y = this.strokeWidth;
			var color = this.fill;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + (this.width - 2 * this.strokeWidth) | 0;
			var maxY = y + (this.height - 2 * this.strokeWidth) | 0;
			while(true) {
				var x = p++;
				var this1 = color;
				var c = this1;
				if((c >> 24 & 255) < 254 && temp.transparent) {
					var location = temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0;
					var this2 = temp.image[location];
					var this3 = this2;
					var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = color >> 24 & 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = color >> 16 & 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = color >> 8 & 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = color & 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					temp.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					temp.image[temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var x = this.left | 0;
			var y = this.top | 0;
			var _g = 0;
			var _g1 = temp.height;
			while(_g < _g1) {
				var dy = _g++;
				var _g2 = 0;
				var _g3 = temp.width;
				while(_g2 < _g3) {
					var dx = _g2++;
					var c = temp.image[temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0];
					var col = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(temp.useMask && temp.mask != null) {
						var this1 = temp.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0];
						var this2 = pixelimage_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x1 = x + dx;
						var y1 = y + dy;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && pixelImage.transparent) {
							var location = pixelImage.useVirtualPos ? (y1 - pixelImage.virtualY) * pixelImage.width + x1 - pixelImage.virtualX | 0 : y1 * pixelImage.width + x1 | 0;
							var this11 = pixelImage.image[location];
							var this12 = this11;
							var this13 = pixelimage_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							pixelImage.image[pixelImage.useVirtualPos ? (y1 - pixelImage.virtualY) * pixelImage.width + x1 - pixelImage.virtualX | 0 : y1 * pixelImage.width + x1 | 0] = pixelimage_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
			temp = null;
		} else {
			var w = Math.ceil(this.width);
			var h = Math.ceil(this.height);
			var this1 = new Uint32Array(w * h | 0);
			var this2 = new pixelimage_ImageStruct(w,h,this1);
			var temp = this2;
			temp.transparent = false;
			var pixelshape = temp;
			var wid = this.width;
			var hi = this.height;
			var color = this.strokeColor;
			var dx = -1.;
			var dy = -1.;
			var fat = -1.;
			var tall = -1.;
			if(dx < 0.) {
				var smallest = hi < wid ? hi : wid;
				var goldenRatio = 1.61803398875;
				dx = smallest / (goldenRatio + 2);
			}
			if(dy < 0.) {
				dy = dx;
			}
			if(fat < 0.) {
				fat = wid - 2 * dx;
			}
			if(tall < 0.) {
				tall = hi - 2 * dy;
			}
			var rightRadius = wid - fat - dx;
			var bottomRadius = hi - tall - dy;
			var farX = dx + fat;
			var lowerY = dy + tall;
			var cx = dx;
			var cy = dy;
			var targetError = 1.05;
			if(targetError == null) {
				targetError = 1.05;
			}
			var targetError1 = targetError;
			if(targetError1 == null) {
				targetError1 = 1.05;
			}
			var rSmall = dx > dy ? dy : dx;
			var targetE = targetError1;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var sides = Math.ceil(noSides / 4) * 4;
			var theta = 2 * Math.PI / sides;
			var omega = Math.PI;
			var quarter = sides / 4 | 0;
			var lastX = 0.;
			var lastY = 0.;
			lastX = cx + dx * Math.cos(sides * theta + omega);
			lastY = cy + dy * Math.sin(sides * theta + omega);
			var _g = 0;
			var _g1 = quarter + 1;
			while(_g < _g1) {
				var i = _g++;
				var nextX = cx + dx * Math.cos(i * theta + 0.0001 + omega);
				var nextY = cy + dy * Math.sin(i * theta + 0.0001 + omega);
				var bx = lastX;
				var by = lastY;
				var cx1 = nextX;
				var cy1 = nextY;
				var adjustWinding = cx * by - bx * cy + (bx * cy1 - cx1 * by) + (cx1 * cy - cx * cy1) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx1;
					by = cy1;
					cx1 = bx_;
					cy1 = by_;
				}
				var s0 = cy * cx1 - cx * cy1;
				var sx = cy1 - cy;
				var sy = cx - cx1;
				var t0 = cx * by - cy * bx;
				var tx = cy - by;
				var ty = bx - cx;
				var A = -by * cx1 + cy * (-bx + cx1) + cx * (by - cy1) + bx * cy1;
				var ii = cy > by ? cy > cy1 ? new IntIterator(by > cy1 ? Math.floor(cy1) : Math.floor(by),Math.ceil(cy)) : new IntIterator(Math.floor(by),Math.ceil(cy1)) : by > cy1 ? new IntIterator(cy > cy1 ? Math.floor(cy1) : Math.ceil(cy),Math.ceil(by)) : new IntIterator(Math.floor(cy),Math.ceil(cy1));
				var this1 = new pixelimage_iter_IntIterStart(ii.min,ii.max);
				var yIter3 = this1;
				var foundY = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g2 = cx > bx ? cx > cx1 ? new IntIterator(bx > cx1 ? Math.floor(cx1) : Math.floor(bx),Math.ceil(cx)) : new IntIterator(Math.floor(bx),Math.ceil(cx1)) : bx > cx1 ? new IntIterator(cx > cx1 ? Math.floor(cx1) : Math.ceil(cx),Math.ceil(bx)) : new IntIterator(Math.floor(cx),Math.ceil(cx1));
				while(_g2.min < _g2.max) {
					var x = _g2.min++;
					sxx = sx * x;
					txx = tx * x;
					foundY = false;
					var _g_min = yIter3.start;
					var _g_max = yIter3.max;
					while(_g_min < _g_max) {
						var y = _g_min++;
						s = s0 + sxx + sy * y;
						t = t0 + txx + ty * y;
						if(s <= 0 || t <= 0) {
							if(foundY) {
								break;
							}
						} else if(s + t < A) {
							var this2 = color;
							var c = this2;
							if((c >> 24 & 255) < 254 && pixelshape.transparent) {
								var location = pixelshape.useVirtualPos ? (y - pixelshape.virtualY) * pixelshape.width + x - pixelshape.virtualX | 0 : y * pixelshape.width + x | 0;
								var this3 = pixelshape.image[location];
								var this4 = this3;
								var this5 = pixelimage_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = color >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = color >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = color >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = color & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								pixelshape.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								pixelshape.image[pixelshape.useVirtualPos ? (y - pixelshape.virtualY) * pixelshape.width + x - pixelshape.virtualX | 0 : y * pixelshape.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							}
							foundY = true;
						} else if(foundY) {
							break;
						}
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
			var x = dx;
			var p = x | 0;
			var xx = p;
			var q = 0;
			var maxX = x + fat | 0;
			var maxY = dy | 0;
			while(true) {
				var x = p++;
				var this1 = color;
				var c = this1;
				if((c >> 24 & 255) < 254 && pixelshape.transparent) {
					var location = pixelshape.useVirtualPos ? (q - pixelshape.virtualY) * pixelshape.width + x - pixelshape.virtualX | 0 : q * pixelshape.width + x | 0;
					var this2 = pixelshape.image[location];
					var this3 = this2;
					var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = color >> 24 & 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = color >> 16 & 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = color >> 8 & 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = color & 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					pixelshape.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					pixelshape.image[pixelshape.useVirtualPos ? (q - pixelshape.virtualY) * pixelshape.width + x - pixelshape.virtualX | 0 : q * pixelshape.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var cy = dy;
			var targetError = 1.05;
			if(targetError == null) {
				targetError = 1.05;
			}
			var targetError1 = targetError;
			if(targetError1 == null) {
				targetError1 = 1.05;
			}
			var rSmall = rightRadius > dy ? dy : rightRadius;
			var targetE = targetError1;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var sides = Math.ceil(noSides / 4) * 4;
			var theta = 2 * Math.PI / sides;
			var omega = 3 * Math.PI / 2;
			var quarter = sides / 4 | 0;
			var lastX = 0.;
			var lastY = 0.;
			lastX = farX + rightRadius * Math.cos(sides * theta + omega);
			lastY = cy + dy * Math.sin(sides * theta + omega);
			var _g = 0;
			var _g1 = quarter + 1;
			while(_g < _g1) {
				var i = _g++;
				var nextX = farX + rightRadius * Math.cos(i * theta + 0.0001 + omega);
				var nextY = cy + dy * Math.sin(i * theta + 0.0001 + omega);
				var bx = lastX;
				var by = lastY;
				var cx = nextX;
				var cy1 = nextY;
				var adjustWinding = farX * by - bx * cy + (bx * cy1 - cx * by) + (cx * cy - farX * cy1) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx;
					by = cy1;
					cx = bx_;
					cy1 = by_;
				}
				var s0 = cy * cx - farX * cy1;
				var sx = cy1 - cy;
				var sy = farX - cx;
				var t0 = farX * by - cy * bx;
				var tx = cy - by;
				var ty = bx - farX;
				var A = -by * cx + cy * (-bx + cx) + farX * (by - cy1) + bx * cy1;
				var ii = cy > by ? cy > cy1 ? new IntIterator(by > cy1 ? Math.floor(cy1) : Math.floor(by),Math.ceil(cy)) : new IntIterator(Math.floor(by),Math.ceil(cy1)) : by > cy1 ? new IntIterator(cy > cy1 ? Math.floor(cy1) : Math.ceil(cy),Math.ceil(by)) : new IntIterator(Math.floor(cy),Math.ceil(cy1));
				var this1 = new pixelimage_iter_IntIterStart(ii.min,ii.max);
				var yIter3 = this1;
				var foundY = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g2 = farX > bx ? farX > cx ? new IntIterator(bx > cx ? Math.floor(cx) : Math.floor(bx),Math.ceil(farX)) : new IntIterator(Math.floor(bx),Math.ceil(cx)) : bx > cx ? new IntIterator(farX > cx ? Math.floor(cx) : Math.ceil(farX),Math.ceil(bx)) : new IntIterator(Math.floor(farX),Math.ceil(cx));
				while(_g2.min < _g2.max) {
					var x = _g2.min++;
					sxx = sx * x;
					txx = tx * x;
					foundY = false;
					var _g_min = yIter3.start;
					var _g_max = yIter3.max;
					while(_g_min < _g_max) {
						var y = _g_min++;
						s = s0 + sxx + sy * y;
						t = t0 + txx + ty * y;
						if(s <= 0 || t <= 0) {
							if(foundY) {
								break;
							}
						} else if(s + t < A) {
							var this2 = color;
							var c = this2;
							if((c >> 24 & 255) < 254 && pixelshape.transparent) {
								var location = pixelshape.useVirtualPos ? (y - pixelshape.virtualY) * pixelshape.width + x - pixelshape.virtualX | 0 : y * pixelshape.width + x | 0;
								var this3 = pixelshape.image[location];
								var this4 = this3;
								var this5 = pixelimage_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = color >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = color >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = color >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = color & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								pixelshape.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								pixelshape.image[pixelshape.useVirtualPos ? (y - pixelshape.virtualY) * pixelshape.width + x - pixelshape.virtualX | 0 : y * pixelshape.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							}
							foundY = true;
						} else if(foundY) {
							break;
						}
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
			var y = dy;
			var p = 0;
			var xx = p;
			var q = y | 0;
			var maxX = wid | 0;
			var maxY = y + tall | 0;
			while(true) {
				var x = p++;
				var this1 = color;
				var c = this1;
				if((c >> 24 & 255) < 254 && pixelshape.transparent) {
					var location = pixelshape.useVirtualPos ? (q - pixelshape.virtualY) * pixelshape.width + x - pixelshape.virtualX | 0 : q * pixelshape.width + x | 0;
					var this2 = pixelshape.image[location];
					var this3 = this2;
					var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = color >> 24 & 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = color >> 16 & 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = color >> 8 & 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = color & 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					pixelshape.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					pixelshape.image[pixelshape.useVirtualPos ? (q - pixelshape.virtualY) * pixelshape.width + x - pixelshape.virtualX | 0 : q * pixelshape.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var cx = dx;
			var targetError = 1.05;
			if(targetError == null) {
				targetError = 1.05;
			}
			var targetError1 = targetError;
			if(targetError1 == null) {
				targetError1 = 1.05;
			}
			var rSmall = dx > bottomRadius ? bottomRadius : dx;
			var targetE = targetError1;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var sides = Math.ceil(noSides / 4) * 4;
			var theta = 2 * Math.PI / sides;
			var omega = Math.PI / 2;
			var quarter = sides / 4 | 0;
			var lastX = 0.;
			var lastY = 0.;
			lastX = cx + dx * Math.cos(sides * theta + omega);
			lastY = lowerY + bottomRadius * Math.sin(sides * theta + omega);
			var _g = 0;
			var _g1 = quarter + 1;
			while(_g < _g1) {
				var i = _g++;
				var nextX = cx + dx * Math.cos(i * theta + 0.0001 + omega);
				var nextY = lowerY + bottomRadius * Math.sin(i * theta + 0.0001 + omega);
				var bx = lastX;
				var by = lastY;
				var cx1 = nextX;
				var cy = nextY;
				var adjustWinding = cx * by - bx * lowerY + (bx * cy - cx1 * by) + (cx1 * lowerY - cx * cy) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx1;
					by = cy;
					cx1 = bx_;
					cy = by_;
				}
				var s0 = lowerY * cx1 - cx * cy;
				var sx = cy - lowerY;
				var sy = cx - cx1;
				var t0 = cx * by - lowerY * bx;
				var tx = lowerY - by;
				var ty = bx - cx;
				var A = -by * cx1 + lowerY * (-bx + cx1) + cx * (by - cy) + bx * cy;
				var ii = lowerY > by ? lowerY > cy ? new IntIterator(by > cy ? Math.floor(cy) : Math.floor(by),Math.ceil(lowerY)) : new IntIterator(Math.floor(by),Math.ceil(cy)) : by > cy ? new IntIterator(lowerY > cy ? Math.floor(cy) : Math.ceil(lowerY),Math.ceil(by)) : new IntIterator(Math.floor(lowerY),Math.ceil(cy));
				var this1 = new pixelimage_iter_IntIterStart(ii.min,ii.max);
				var yIter3 = this1;
				var foundY = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g2 = cx > bx ? cx > cx1 ? new IntIterator(bx > cx1 ? Math.floor(cx1) : Math.floor(bx),Math.ceil(cx)) : new IntIterator(Math.floor(bx),Math.ceil(cx1)) : bx > cx1 ? new IntIterator(cx > cx1 ? Math.floor(cx1) : Math.ceil(cx),Math.ceil(bx)) : new IntIterator(Math.floor(cx),Math.ceil(cx1));
				while(_g2.min < _g2.max) {
					var x = _g2.min++;
					sxx = sx * x;
					txx = tx * x;
					foundY = false;
					var _g_min = yIter3.start;
					var _g_max = yIter3.max;
					while(_g_min < _g_max) {
						var y = _g_min++;
						s = s0 + sxx + sy * y;
						t = t0 + txx + ty * y;
						if(s <= 0 || t <= 0) {
							if(foundY) {
								break;
							}
						} else if(s + t < A) {
							var this2 = color;
							var c = this2;
							if((c >> 24 & 255) < 254 && pixelshape.transparent) {
								var location = pixelshape.useVirtualPos ? (y - pixelshape.virtualY) * pixelshape.width + x - pixelshape.virtualX | 0 : y * pixelshape.width + x | 0;
								var this3 = pixelshape.image[location];
								var this4 = this3;
								var this5 = pixelimage_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = color >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = color >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = color >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = color & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								pixelshape.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								pixelshape.image[pixelshape.useVirtualPos ? (y - pixelshape.virtualY) * pixelshape.width + x - pixelshape.virtualX | 0 : y * pixelshape.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							}
							foundY = true;
						} else if(foundY) {
							break;
						}
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
			var x = dx;
			var p = x | 0;
			var xx = p;
			var q = lowerY | 0;
			var maxX = x + fat | 0;
			var maxY = lowerY + bottomRadius | 0;
			while(true) {
				var x = p++;
				var this1 = color;
				var c = this1;
				if((c >> 24 & 255) < 254 && pixelshape.transparent) {
					var location = pixelshape.useVirtualPos ? (q - pixelshape.virtualY) * pixelshape.width + x - pixelshape.virtualX | 0 : q * pixelshape.width + x | 0;
					var this2 = pixelshape.image[location];
					var this3 = this2;
					var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = color >> 24 & 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = color >> 16 & 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = color >> 8 & 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = color & 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					pixelshape.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					pixelshape.image[pixelshape.useVirtualPos ? (q - pixelshape.virtualY) * pixelshape.width + x - pixelshape.virtualX | 0 : q * pixelshape.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var targetError = 1.05;
			if(targetError == null) {
				targetError = 1.05;
			}
			var targetError1 = targetError;
			if(targetError1 == null) {
				targetError1 = 1.05;
			}
			var rSmall = rightRadius > bottomRadius ? bottomRadius : rightRadius;
			var targetE = targetError1;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var sides = Math.ceil(noSides / 4) * 4;
			var theta = 2 * Math.PI / sides;
			var omega = 0.;
			var quarter = sides / 4 | 0;
			var lastX = 0.;
			var lastY = 0.;
			lastX = farX + rightRadius * Math.cos(sides * theta + omega);
			lastY = lowerY + bottomRadius * Math.sin(sides * theta + omega);
			var _g = 0;
			var _g1 = quarter + 1;
			while(_g < _g1) {
				var i = _g++;
				var nextX = farX + rightRadius * Math.cos(i * theta + 0.0001 + omega);
				var nextY = lowerY + bottomRadius * Math.sin(i * theta + 0.0001 + omega);
				var bx = lastX;
				var by = lastY;
				var cx = nextX;
				var cy = nextY;
				var adjustWinding = farX * by - bx * lowerY + (bx * cy - cx * by) + (cx * lowerY - farX * cy) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx;
					by = cy;
					cx = bx_;
					cy = by_;
				}
				var s0 = lowerY * cx - farX * cy;
				var sx = cy - lowerY;
				var sy = farX - cx;
				var t0 = farX * by - lowerY * bx;
				var tx = lowerY - by;
				var ty = bx - farX;
				var A = -by * cx + lowerY * (-bx + cx) + farX * (by - cy) + bx * cy;
				var ii = lowerY > by ? lowerY > cy ? new IntIterator(by > cy ? Math.floor(cy) : Math.floor(by),Math.ceil(lowerY)) : new IntIterator(Math.floor(by),Math.ceil(cy)) : by > cy ? new IntIterator(lowerY > cy ? Math.floor(cy) : Math.ceil(lowerY),Math.ceil(by)) : new IntIterator(Math.floor(lowerY),Math.ceil(cy));
				var this1 = new pixelimage_iter_IntIterStart(ii.min,ii.max);
				var yIter3 = this1;
				var foundY = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g2 = farX > bx ? farX > cx ? new IntIterator(bx > cx ? Math.floor(cx) : Math.floor(bx),Math.ceil(farX)) : new IntIterator(Math.floor(bx),Math.ceil(cx)) : bx > cx ? new IntIterator(farX > cx ? Math.floor(cx) : Math.ceil(farX),Math.ceil(bx)) : new IntIterator(Math.floor(farX),Math.ceil(cx));
				while(_g2.min < _g2.max) {
					var x = _g2.min++;
					sxx = sx * x;
					txx = tx * x;
					foundY = false;
					var _g_min = yIter3.start;
					var _g_max = yIter3.max;
					while(_g_min < _g_max) {
						var y = _g_min++;
						s = s0 + sxx + sy * y;
						t = t0 + txx + ty * y;
						if(s <= 0 || t <= 0) {
							if(foundY) {
								break;
							}
						} else if(s + t < A) {
							var this2 = color;
							var c = this2;
							if((c >> 24 & 255) < 254 && pixelshape.transparent) {
								var location = pixelshape.useVirtualPos ? (y - pixelshape.virtualY) * pixelshape.width + x - pixelshape.virtualX | 0 : y * pixelshape.width + x | 0;
								var this3 = pixelshape.image[location];
								var this4 = this3;
								var this5 = pixelimage_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = color >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = color >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = color >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = color & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								pixelshape.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								pixelshape.image[pixelshape.useVirtualPos ? (y - pixelshape.virtualY) * pixelshape.width + x - pixelshape.virtualX | 0 : y * pixelshape.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							}
							foundY = true;
						} else if(foundY) {
							break;
						}
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
			var pixelshape = temp;
			var x = this.strokeWidth;
			var y = this.strokeWidth;
			var wid = this.width - 2 * this.strokeWidth;
			var hi = this.height - 2 * this.strokeWidth;
			var color = this.fill;
			var dx = -1.;
			var dy = -1.;
			var fat = -1.;
			var tall = -1.;
			if(dx < 0.) {
				var smallest = hi < wid ? hi : wid;
				var goldenRatio = 1.61803398875;
				dx = smallest / (goldenRatio + 2);
			}
			if(dy < 0.) {
				dy = dx;
			}
			if(fat < 0.) {
				fat = wid - 2 * dx;
			}
			if(tall < 0.) {
				tall = hi - 2 * dy;
			}
			var rightRadius = wid - fat - dx;
			var bottomRadius = hi - tall - dy;
			var farX = x + dx + fat;
			var lowerY = y + dy + tall;
			var cx = x + dx;
			var cy = y + dy;
			var targetError = 1.05;
			if(targetError == null) {
				targetError = 1.05;
			}
			var targetError1 = targetError;
			if(targetError1 == null) {
				targetError1 = 1.05;
			}
			var rSmall = dx > dy ? dy : dx;
			var targetE = targetError1;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var sides = Math.ceil(noSides / 4) * 4;
			var theta = 2 * Math.PI / sides;
			var omega = Math.PI;
			var quarter = sides / 4 | 0;
			var lastX = 0.;
			var lastY = 0.;
			lastX = cx + dx * Math.cos(sides * theta + omega);
			lastY = cy + dy * Math.sin(sides * theta + omega);
			var _g = 0;
			var _g1 = quarter + 1;
			while(_g < _g1) {
				var i = _g++;
				var nextX = cx + dx * Math.cos(i * theta + 0.0001 + omega);
				var nextY = cy + dy * Math.sin(i * theta + 0.0001 + omega);
				var bx = lastX;
				var by = lastY;
				var cx1 = nextX;
				var cy1 = nextY;
				var adjustWinding = cx * by - bx * cy + (bx * cy1 - cx1 * by) + (cx1 * cy - cx * cy1) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx1;
					by = cy1;
					cx1 = bx_;
					cy1 = by_;
				}
				var s0 = cy * cx1 - cx * cy1;
				var sx = cy1 - cy;
				var sy = cx - cx1;
				var t0 = cx * by - cy * bx;
				var tx = cy - by;
				var ty = bx - cx;
				var A = -by * cx1 + cy * (-bx + cx1) + cx * (by - cy1) + bx * cy1;
				var ii = cy > by ? cy > cy1 ? new IntIterator(by > cy1 ? Math.floor(cy1) : Math.floor(by),Math.ceil(cy)) : new IntIterator(Math.floor(by),Math.ceil(cy1)) : by > cy1 ? new IntIterator(cy > cy1 ? Math.floor(cy1) : Math.ceil(cy),Math.ceil(by)) : new IntIterator(Math.floor(cy),Math.ceil(cy1));
				var this1 = new pixelimage_iter_IntIterStart(ii.min,ii.max);
				var yIter3 = this1;
				var foundY = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g2 = cx > bx ? cx > cx1 ? new IntIterator(bx > cx1 ? Math.floor(cx1) : Math.floor(bx),Math.ceil(cx)) : new IntIterator(Math.floor(bx),Math.ceil(cx1)) : bx > cx1 ? new IntIterator(cx > cx1 ? Math.floor(cx1) : Math.ceil(cx),Math.ceil(bx)) : new IntIterator(Math.floor(cx),Math.ceil(cx1));
				while(_g2.min < _g2.max) {
					var x1 = _g2.min++;
					sxx = sx * x1;
					txx = tx * x1;
					foundY = false;
					var _g_min = yIter3.start;
					var _g_max = yIter3.max;
					while(_g_min < _g_max) {
						var y1 = _g_min++;
						s = s0 + sxx + sy * y1;
						t = t0 + txx + ty * y1;
						if(s <= 0 || t <= 0) {
							if(foundY) {
								break;
							}
						} else if(s + t < A) {
							var this2 = color;
							var c = this2;
							if((c >> 24 & 255) < 254 && pixelshape.transparent) {
								var location = pixelshape.useVirtualPos ? (y1 - pixelshape.virtualY) * pixelshape.width + x1 - pixelshape.virtualX | 0 : y1 * pixelshape.width + x1 | 0;
								var this3 = pixelshape.image[location];
								var this4 = this3;
								var this5 = pixelimage_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = color >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = color >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = color >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = color & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								pixelshape.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								pixelshape.image[pixelshape.useVirtualPos ? (y1 - pixelshape.virtualY) * pixelshape.width + x1 - pixelshape.virtualX | 0 : y1 * pixelshape.width + x1 | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							}
							foundY = true;
						} else if(foundY) {
							break;
						}
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
			var x1 = x + dx;
			var p = x1 | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x1 + fat | 0;
			var maxY = y + dy | 0;
			while(true) {
				var x1 = p++;
				var this1 = color;
				var c = this1;
				if((c >> 24 & 255) < 254 && pixelshape.transparent) {
					var location = pixelshape.useVirtualPos ? (q - pixelshape.virtualY) * pixelshape.width + x1 - pixelshape.virtualX | 0 : q * pixelshape.width + x1 | 0;
					var this2 = pixelshape.image[location];
					var this3 = this2;
					var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = color >> 24 & 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = color >> 16 & 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = color >> 8 & 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = color & 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					pixelshape.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					pixelshape.image[pixelshape.useVirtualPos ? (q - pixelshape.virtualY) * pixelshape.width + x1 - pixelshape.virtualX | 0 : q * pixelshape.width + x1 | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var cy = y + dy;
			var targetError = 1.05;
			if(targetError == null) {
				targetError = 1.05;
			}
			var targetError1 = targetError;
			if(targetError1 == null) {
				targetError1 = 1.05;
			}
			var rSmall = rightRadius > dy ? dy : rightRadius;
			var targetE = targetError1;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var sides = Math.ceil(noSides / 4) * 4;
			var theta = 2 * Math.PI / sides;
			var omega = 3 * Math.PI / 2;
			var quarter = sides / 4 | 0;
			var lastX = 0.;
			var lastY = 0.;
			lastX = farX + rightRadius * Math.cos(sides * theta + omega);
			lastY = cy + dy * Math.sin(sides * theta + omega);
			var _g = 0;
			var _g1 = quarter + 1;
			while(_g < _g1) {
				var i = _g++;
				var nextX = farX + rightRadius * Math.cos(i * theta + 0.0001 + omega);
				var nextY = cy + dy * Math.sin(i * theta + 0.0001 + omega);
				var bx = lastX;
				var by = lastY;
				var cx = nextX;
				var cy1 = nextY;
				var adjustWinding = farX * by - bx * cy + (bx * cy1 - cx * by) + (cx * cy - farX * cy1) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx;
					by = cy1;
					cx = bx_;
					cy1 = by_;
				}
				var s0 = cy * cx - farX * cy1;
				var sx = cy1 - cy;
				var sy = farX - cx;
				var t0 = farX * by - cy * bx;
				var tx = cy - by;
				var ty = bx - farX;
				var A = -by * cx + cy * (-bx + cx) + farX * (by - cy1) + bx * cy1;
				var ii = cy > by ? cy > cy1 ? new IntIterator(by > cy1 ? Math.floor(cy1) : Math.floor(by),Math.ceil(cy)) : new IntIterator(Math.floor(by),Math.ceil(cy1)) : by > cy1 ? new IntIterator(cy > cy1 ? Math.floor(cy1) : Math.ceil(cy),Math.ceil(by)) : new IntIterator(Math.floor(cy),Math.ceil(cy1));
				var this1 = new pixelimage_iter_IntIterStart(ii.min,ii.max);
				var yIter3 = this1;
				var foundY = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g2 = farX > bx ? farX > cx ? new IntIterator(bx > cx ? Math.floor(cx) : Math.floor(bx),Math.ceil(farX)) : new IntIterator(Math.floor(bx),Math.ceil(cx)) : bx > cx ? new IntIterator(farX > cx ? Math.floor(cx) : Math.ceil(farX),Math.ceil(bx)) : new IntIterator(Math.floor(farX),Math.ceil(cx));
				while(_g2.min < _g2.max) {
					var x1 = _g2.min++;
					sxx = sx * x1;
					txx = tx * x1;
					foundY = false;
					var _g_min = yIter3.start;
					var _g_max = yIter3.max;
					while(_g_min < _g_max) {
						var y1 = _g_min++;
						s = s0 + sxx + sy * y1;
						t = t0 + txx + ty * y1;
						if(s <= 0 || t <= 0) {
							if(foundY) {
								break;
							}
						} else if(s + t < A) {
							var this2 = color;
							var c = this2;
							if((c >> 24 & 255) < 254 && pixelshape.transparent) {
								var location = pixelshape.useVirtualPos ? (y1 - pixelshape.virtualY) * pixelshape.width + x1 - pixelshape.virtualX | 0 : y1 * pixelshape.width + x1 | 0;
								var this3 = pixelshape.image[location];
								var this4 = this3;
								var this5 = pixelimage_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = color >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = color >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = color >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = color & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								pixelshape.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								pixelshape.image[pixelshape.useVirtualPos ? (y1 - pixelshape.virtualY) * pixelshape.width + x1 - pixelshape.virtualX | 0 : y1 * pixelshape.width + x1 | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							}
							foundY = true;
						} else if(foundY) {
							break;
						}
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
			var y1 = y + dy;
			var p = x | 0;
			var xx = p;
			var q = y1 | 0;
			var maxX = x + wid | 0;
			var maxY = y1 + tall | 0;
			while(true) {
				var x1 = p++;
				var this1 = color;
				var c = this1;
				if((c >> 24 & 255) < 254 && pixelshape.transparent) {
					var location = pixelshape.useVirtualPos ? (q - pixelshape.virtualY) * pixelshape.width + x1 - pixelshape.virtualX | 0 : q * pixelshape.width + x1 | 0;
					var this2 = pixelshape.image[location];
					var this3 = this2;
					var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = color >> 24 & 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = color >> 16 & 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = color >> 8 & 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = color & 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					pixelshape.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					pixelshape.image[pixelshape.useVirtualPos ? (q - pixelshape.virtualY) * pixelshape.width + x1 - pixelshape.virtualX | 0 : q * pixelshape.width + x1 | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var cx = x + dx;
			var targetError = 1.05;
			if(targetError == null) {
				targetError = 1.05;
			}
			var targetError1 = targetError;
			if(targetError1 == null) {
				targetError1 = 1.05;
			}
			var rSmall = dx > bottomRadius ? bottomRadius : dx;
			var targetE = targetError1;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var sides = Math.ceil(noSides / 4) * 4;
			var theta = 2 * Math.PI / sides;
			var omega = Math.PI / 2;
			var quarter = sides / 4 | 0;
			var lastX = 0.;
			var lastY = 0.;
			lastX = cx + dx * Math.cos(sides * theta + omega);
			lastY = lowerY + bottomRadius * Math.sin(sides * theta + omega);
			var _g = 0;
			var _g1 = quarter + 1;
			while(_g < _g1) {
				var i = _g++;
				var nextX = cx + dx * Math.cos(i * theta + 0.0001 + omega);
				var nextY = lowerY + bottomRadius * Math.sin(i * theta + 0.0001 + omega);
				var bx = lastX;
				var by = lastY;
				var cx1 = nextX;
				var cy = nextY;
				var adjustWinding = cx * by - bx * lowerY + (bx * cy - cx1 * by) + (cx1 * lowerY - cx * cy) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx1;
					by = cy;
					cx1 = bx_;
					cy = by_;
				}
				var s0 = lowerY * cx1 - cx * cy;
				var sx = cy - lowerY;
				var sy = cx - cx1;
				var t0 = cx * by - lowerY * bx;
				var tx = lowerY - by;
				var ty = bx - cx;
				var A = -by * cx1 + lowerY * (-bx + cx1) + cx * (by - cy) + bx * cy;
				var ii = lowerY > by ? lowerY > cy ? new IntIterator(by > cy ? Math.floor(cy) : Math.floor(by),Math.ceil(lowerY)) : new IntIterator(Math.floor(by),Math.ceil(cy)) : by > cy ? new IntIterator(lowerY > cy ? Math.floor(cy) : Math.ceil(lowerY),Math.ceil(by)) : new IntIterator(Math.floor(lowerY),Math.ceil(cy));
				var this1 = new pixelimage_iter_IntIterStart(ii.min,ii.max);
				var yIter3 = this1;
				var foundY = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g2 = cx > bx ? cx > cx1 ? new IntIterator(bx > cx1 ? Math.floor(cx1) : Math.floor(bx),Math.ceil(cx)) : new IntIterator(Math.floor(bx),Math.ceil(cx1)) : bx > cx1 ? new IntIterator(cx > cx1 ? Math.floor(cx1) : Math.ceil(cx),Math.ceil(bx)) : new IntIterator(Math.floor(cx),Math.ceil(cx1));
				while(_g2.min < _g2.max) {
					var x1 = _g2.min++;
					sxx = sx * x1;
					txx = tx * x1;
					foundY = false;
					var _g_min = yIter3.start;
					var _g_max = yIter3.max;
					while(_g_min < _g_max) {
						var y = _g_min++;
						s = s0 + sxx + sy * y;
						t = t0 + txx + ty * y;
						if(s <= 0 || t <= 0) {
							if(foundY) {
								break;
							}
						} else if(s + t < A) {
							var this2 = color;
							var c = this2;
							if((c >> 24 & 255) < 254 && pixelshape.transparent) {
								var location = pixelshape.useVirtualPos ? (y - pixelshape.virtualY) * pixelshape.width + x1 - pixelshape.virtualX | 0 : y * pixelshape.width + x1 | 0;
								var this3 = pixelshape.image[location];
								var this4 = this3;
								var this5 = pixelimage_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = color >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = color >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = color >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = color & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								pixelshape.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								pixelshape.image[pixelshape.useVirtualPos ? (y - pixelshape.virtualY) * pixelshape.width + x1 - pixelshape.virtualX | 0 : y * pixelshape.width + x1 | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							}
							foundY = true;
						} else if(foundY) {
							break;
						}
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
			var x1 = x + dx;
			var p = x1 | 0;
			var xx = p;
			var q = lowerY | 0;
			var maxX = x1 + fat | 0;
			var maxY = lowerY + bottomRadius | 0;
			while(true) {
				var x = p++;
				var this1 = color;
				var c = this1;
				if((c >> 24 & 255) < 254 && pixelshape.transparent) {
					var location = pixelshape.useVirtualPos ? (q - pixelshape.virtualY) * pixelshape.width + x - pixelshape.virtualX | 0 : q * pixelshape.width + x | 0;
					var this2 = pixelshape.image[location];
					var this3 = this2;
					var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = color >> 24 & 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = color >> 16 & 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = color >> 8 & 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = color & 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					pixelshape.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					pixelshape.image[pixelshape.useVirtualPos ? (q - pixelshape.virtualY) * pixelshape.width + x - pixelshape.virtualX | 0 : q * pixelshape.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var targetError = 1.05;
			if(targetError == null) {
				targetError = 1.05;
			}
			var targetError1 = targetError;
			if(targetError1 == null) {
				targetError1 = 1.05;
			}
			var rSmall = rightRadius > bottomRadius ? bottomRadius : rightRadius;
			var targetE = targetError1;
			if(targetE == null) {
				targetE = 1.05;
			}
			var result = Math.ceil(Math.PI / Math.acos(1 - targetE / rSmall));
			var noSides = result < 12 ? 12 : result > 500 ? 500 : result;
			var sides = Math.ceil(noSides / 4) * 4;
			var theta = 2 * Math.PI / sides;
			var omega = 0.;
			var quarter = sides / 4 | 0;
			var lastX = 0.;
			var lastY = 0.;
			lastX = farX + rightRadius * Math.cos(sides * theta + omega);
			lastY = lowerY + bottomRadius * Math.sin(sides * theta + omega);
			var _g = 0;
			var _g1 = quarter + 1;
			while(_g < _g1) {
				var i = _g++;
				var nextX = farX + rightRadius * Math.cos(i * theta + 0.0001 + omega);
				var nextY = lowerY + bottomRadius * Math.sin(i * theta + 0.0001 + omega);
				var bx = lastX;
				var by = lastY;
				var cx = nextX;
				var cy = nextY;
				var adjustWinding = farX * by - bx * lowerY + (bx * cy - cx * by) + (cx * lowerY - farX * cy) > 0;
				if(!adjustWinding) {
					var bx_ = bx;
					var by_ = by;
					bx = cx;
					by = cy;
					cx = bx_;
					cy = by_;
				}
				var s0 = lowerY * cx - farX * cy;
				var sx = cy - lowerY;
				var sy = farX - cx;
				var t0 = farX * by - lowerY * bx;
				var tx = lowerY - by;
				var ty = bx - farX;
				var A = -by * cx + lowerY * (-bx + cx) + farX * (by - cy) + bx * cy;
				var ii = lowerY > by ? lowerY > cy ? new IntIterator(by > cy ? Math.floor(cy) : Math.floor(by),Math.ceil(lowerY)) : new IntIterator(Math.floor(by),Math.ceil(cy)) : by > cy ? new IntIterator(lowerY > cy ? Math.floor(cy) : Math.ceil(lowerY),Math.ceil(by)) : new IntIterator(Math.floor(lowerY),Math.ceil(cy));
				var this1 = new pixelimage_iter_IntIterStart(ii.min,ii.max);
				var yIter3 = this1;
				var foundY = false;
				var s = 0.;
				var t = 0.;
				var sxx = 0.;
				var txx = 0.;
				var _g2 = farX > bx ? farX > cx ? new IntIterator(bx > cx ? Math.floor(cx) : Math.floor(bx),Math.ceil(farX)) : new IntIterator(Math.floor(bx),Math.ceil(cx)) : bx > cx ? new IntIterator(farX > cx ? Math.floor(cx) : Math.ceil(farX),Math.ceil(bx)) : new IntIterator(Math.floor(farX),Math.ceil(cx));
				while(_g2.min < _g2.max) {
					var x = _g2.min++;
					sxx = sx * x;
					txx = tx * x;
					foundY = false;
					var _g_min = yIter3.start;
					var _g_max = yIter3.max;
					while(_g_min < _g_max) {
						var y = _g_min++;
						s = s0 + sxx + sy * y;
						t = t0 + txx + ty * y;
						if(s <= 0 || t <= 0) {
							if(foundY) {
								break;
							}
						} else if(s + t < A) {
							var this2 = color;
							var c = this2;
							if((c >> 24 & 255) < 254 && pixelshape.transparent) {
								var location = pixelshape.useVirtualPos ? (y - pixelshape.virtualY) * pixelshape.width + x - pixelshape.virtualX | 0 : y * pixelshape.width + x | 0;
								var this3 = pixelshape.image[location];
								var this4 = this3;
								var this5 = pixelimage_Endian_isLittleEndian ? (this4 >> 24 & 255) << 24 | (this4 & 255) << 16 | (this4 >> 8 & 255) << 8 | this4 >> 16 & 255 : this4;
								var this6 = this5 >> 24 & 255;
								var a1 = this6 == 0 ? 0. : this6 / 255;
								var this7 = this5 >> 16 & 255;
								var r1 = this7 == 0 ? 0. : this7 / 255;
								var this8 = this5 >> 8 & 255;
								var g1 = this8 == 0 ? 0. : this8 / 255;
								var this9 = this5 & 255;
								var b1 = this9 == 0 ? 0. : this9 / 255;
								var this10 = color >> 24 & 255;
								var a2 = this10 == 0 ? 0. : this10 / 255;
								var this11 = color >> 16 & 255;
								var r2 = this11 == 0 ? 0. : this11 / 255;
								var this12 = color >> 8 & 255;
								var g2 = this12 == 0 ? 0. : this12 / 255;
								var this13 = color & 255;
								var b2 = this13 == 0 ? 0. : this13 / 255;
								var a3 = a1 * (1 - a2);
								var r = 255 * (r1 * a3 + r2 * a2) | 0;
								var g = 255 * (g1 * a3 + g2 * a2) | 0;
								var b = 255 * (b1 * a3 + b2 * a2) | 0;
								var a = 255 * (a3 + a2) | 0;
								var blended = a << 24 | r << 16 | g << 8 | b;
								pixelshape.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
							} else {
								pixelshape.image[pixelshape.useVirtualPos ? (y - pixelshape.virtualY) * pixelshape.width + x - pixelshape.virtualX | 0 : y * pixelshape.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
							}
							foundY = true;
						} else if(foundY) {
							break;
						}
					}
				}
				lastX = nextX;
				lastY = nextY;
			}
			var x = this.left | 0;
			var y = this.top | 0;
			var _g = 0;
			var _g1 = temp.height;
			while(_g < _g1) {
				var dy = _g++;
				var _g2 = 0;
				var _g3 = temp.width;
				while(_g2 < _g3) {
					var dx = _g2++;
					var c = temp.image[temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0];
					var col = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(temp.useMask && temp.mask != null) {
						var this1 = temp.mask;
						var c1 = this1.image[this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0];
						var this2 = pixelimage_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						var maskPixel = this2;
						var this3 = col;
						var this4 = this3;
						if(maskPixel == 0) {
							var this5 = this4;
							col = this5;
						} else {
							var this6 = maskPixel >> 24 & 255;
							var m0 = this6 == 0 ? 0. : this6 / 255;
							var this7 = maskPixel >> 16 & 255;
							var m1 = this7 == 0 ? 0. : this7 / 255;
							var this8 = maskPixel >> 8 & 255;
							var m2 = this8 == 0 ? 0. : this8 / 255;
							var this9 = maskPixel & 255;
							var m3 = this9 == 0 ? 0. : this9 / 255;
							var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
							var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
							var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
							var ch3 = (1. - m3) * (this4 & 255) | 0;
							col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
						}
					}
					if(col != 0) {
						var x1 = x + dx;
						var y1 = y + dy;
						var this10 = col;
						var c2 = this10;
						if((c2 >> 24 & 255) < 254 && pixelImage.transparent) {
							var location = pixelImage.useVirtualPos ? (y1 - pixelImage.virtualY) * pixelImage.width + x1 - pixelImage.virtualX | 0 : y1 * pixelImage.width + x1 | 0;
							var this11 = pixelImage.image[location];
							var this12 = this11;
							var this13 = pixelimage_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
							var this14 = this13 >> 24 & 255;
							var a1 = this14 == 0 ? 0. : this14 / 255;
							var this15 = this13 >> 16 & 255;
							var r1 = this15 == 0 ? 0. : this15 / 255;
							var this16 = this13 >> 8 & 255;
							var g1 = this16 == 0 ? 0. : this16 / 255;
							var this17 = this13 & 255;
							var b1 = this17 == 0 ? 0. : this17 / 255;
							var this18 = col >> 24 & 255;
							var a2 = this18 == 0 ? 0. : this18 / 255;
							var this19 = col >> 16 & 255;
							var r2 = this19 == 0 ? 0. : this19 / 255;
							var this20 = col >> 8 & 255;
							var g2 = this20 == 0 ? 0. : this20 / 255;
							var this21 = col & 255;
							var b2 = this21 == 0 ? 0. : this21 / 255;
							var a3 = a1 * (1 - a2);
							var r = 255 * (r1 * a3 + r2 * a2) | 0;
							var g = 255 * (g1 * a3 + g2 * a2) | 0;
							var b = 255 * (b1 * a3 + b2 * a2) | 0;
							var a = 255 * (a3 + a2) | 0;
							var blended = a << 24 | r << 16 | g << 8 | b;
							pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
						} else {
							pixelImage.image[pixelImage.useVirtualPos ? (y1 - pixelImage.virtualY) * pixelImage.width + x1 - pixelImage.virtualX | 0 : y1 * pixelImage.width + x1 | 0] = pixelimage_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						}
					}
				}
			}
			temp = null;
		}
	}
	,__class__: pixelimage_shapeStruct_RectangleShape
});
var pixelimage_shapeStruct_SquareShape = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,diameter) {
	if(diameter == null) {
		diameter = 1.;
	}
	if(top == null) {
		top = 0.;
	}
	if(left == null) {
		left = 0.;
	}
	if(fill == null) {
		fill = 0;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = 0;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pixelimage_shapeStruct_FillShape.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill);
	this.left = left;
	this.top = top;
	this.diameter = diameter;
};
pixelimage_shapeStruct_SquareShape.__name__ = "pixelimage.shapeStruct.SquareShape";
pixelimage_shapeStruct_SquareShape.__super__ = pixelimage_shapeStruct_FillShape;
pixelimage_shapeStruct_SquareShape.prototype = $extend(pixelimage_shapeStruct_FillShape.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "diameter":
			this.diameter = parseFloat(value);
			break;
		case "left":
			this.left = parseFloat(value);
			break;
		case "top":
			this.top = parseFloat(value);
			break;
		default:
			pixelimage_shapeStruct_FillShape.prototype.setParameter.call(this,name,value);
		}
	}
	,render: function(pixelImage) {
		var w = Math.ceil(this.diameter);
		var h = Math.ceil(this.diameter);
		var this1 = new Uint32Array(w * h | 0);
		var this2 = new pixelimage_ImageStruct(w,h,this1);
		var temp = this2;
		temp.transparent = false;
		var color = this.strokeColor;
		var p = 0;
		var xx = p;
		var q = 0;
		var maxX = this.diameter | 0;
		var maxY = this.diameter | 0;
		while(true) {
			var x = p++;
			var this1 = color;
			var c = this1;
			if((c >> 24 & 255) < 254 && temp.transparent) {
				var location = temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0;
				var this2 = temp.image[location];
				var this3 = this2;
				var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
				var this5 = this4 >> 24 & 255;
				var a1 = this5 == 0 ? 0. : this5 / 255;
				var this6 = this4 >> 16 & 255;
				var r1 = this6 == 0 ? 0. : this6 / 255;
				var this7 = this4 >> 8 & 255;
				var g1 = this7 == 0 ? 0. : this7 / 255;
				var this8 = this4 & 255;
				var b1 = this8 == 0 ? 0. : this8 / 255;
				var this9 = color >> 24 & 255;
				var a2 = this9 == 0 ? 0. : this9 / 255;
				var this10 = color >> 16 & 255;
				var r2 = this10 == 0 ? 0. : this10 / 255;
				var this11 = color >> 8 & 255;
				var g2 = this11 == 0 ? 0. : this11 / 255;
				var this12 = color & 255;
				var b2 = this12 == 0 ? 0. : this12 / 255;
				var a3 = a1 * (1 - a2);
				var r = 255 * (r1 * a3 + r2 * a2) | 0;
				var g = 255 * (g1 * a3 + g2 * a2) | 0;
				var b = 255 * (b1 * a3 + b2 * a2) | 0;
				var a = 255 * (a3 + a2) | 0;
				var blended = a << 24 | r << 16 | g << 8 | b;
				temp.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
			} else {
				temp.image[temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
			}
			if(p > maxX) {
				p = xx;
				++q;
			}
			if(q > maxY) {
				break;
			}
		}
		var x = this.strokeWidth;
		var y = this.strokeWidth;
		var color = this.fill;
		var p = x | 0;
		var xx = p;
		var q = y | 0;
		var maxX = x + (this.diameter - 2 * this.strokeWidth) | 0;
		var maxY = y + (this.diameter - 2 * this.strokeWidth) | 0;
		while(true) {
			var x = p++;
			var this1 = color;
			var c = this1;
			if((c >> 24 & 255) < 254 && temp.transparent) {
				var location = temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0;
				var this2 = temp.image[location];
				var this3 = this2;
				var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
				var this5 = this4 >> 24 & 255;
				var a1 = this5 == 0 ? 0. : this5 / 255;
				var this6 = this4 >> 16 & 255;
				var r1 = this6 == 0 ? 0. : this6 / 255;
				var this7 = this4 >> 8 & 255;
				var g1 = this7 == 0 ? 0. : this7 / 255;
				var this8 = this4 & 255;
				var b1 = this8 == 0 ? 0. : this8 / 255;
				var this9 = color >> 24 & 255;
				var a2 = this9 == 0 ? 0. : this9 / 255;
				var this10 = color >> 16 & 255;
				var r2 = this10 == 0 ? 0. : this10 / 255;
				var this11 = color >> 8 & 255;
				var g2 = this11 == 0 ? 0. : this11 / 255;
				var this12 = color & 255;
				var b2 = this12 == 0 ? 0. : this12 / 255;
				var a3 = a1 * (1 - a2);
				var r = 255 * (r1 * a3 + r2 * a2) | 0;
				var g = 255 * (g1 * a3 + g2 * a2) | 0;
				var b = 255 * (b1 * a3 + b2 * a2) | 0;
				var a = 255 * (a3 + a2) | 0;
				var blended = a << 24 | r << 16 | g << 8 | b;
				temp.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
			} else {
				temp.image[temp.useVirtualPos ? (q - temp.virtualY) * temp.width + x - temp.virtualX | 0 : q * temp.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
			}
			if(p > maxX) {
				p = xx;
				++q;
			}
			if(q > maxY) {
				break;
			}
		}
		var x = this.left | 0;
		var y = this.top | 0;
		var _g = 0;
		var _g1 = temp.height;
		while(_g < _g1) {
			var dy = _g++;
			var _g2 = 0;
			var _g3 = temp.width;
			while(_g2 < _g3) {
				var dx = _g2++;
				var c = temp.image[temp.useVirtualPos ? (dy - temp.virtualY) * temp.width + dx - temp.virtualX | 0 : dy * temp.width + dx | 0];
				var col = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				if(temp.useMask && temp.mask != null) {
					var this1 = temp.mask;
					var c1 = this1.image[this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0];
					var this2 = pixelimage_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
					var maskPixel = this2;
					var this3 = col;
					var this4 = this3;
					if(maskPixel == 0) {
						var this5 = this4;
						col = this5;
					} else {
						var this6 = maskPixel >> 24 & 255;
						var m0 = this6 == 0 ? 0. : this6 / 255;
						var this7 = maskPixel >> 16 & 255;
						var m1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = maskPixel >> 8 & 255;
						var m2 = this8 == 0 ? 0. : this8 / 255;
						var this9 = maskPixel & 255;
						var m3 = this9 == 0 ? 0. : this9 / 255;
						var ch0 = (1. - m0) * (this4 >> 24 & 255) | 0;
						var ch1 = (1. - m1) * (this4 >> 16 & 255) | 0;
						var ch2 = (1. - m2) * (this4 >> 8 & 255) | 0;
						var ch3 = (1. - m3) * (this4 & 255) | 0;
						col = Math.round(ch0 * 255) << 24 | Math.round(ch1 * 255) << 16 | Math.round(ch2 * 255) << 8 | Math.round(ch3 * 255);
					}
				}
				if(col != 0) {
					var x1 = x + dx;
					var y1 = y + dy;
					var this10 = col;
					var c2 = this10;
					if((c2 >> 24 & 255) < 254 && pixelImage.transparent) {
						var location = pixelImage.useVirtualPos ? (y1 - pixelImage.virtualY) * pixelImage.width + x1 - pixelImage.virtualX | 0 : y1 * pixelImage.width + x1 | 0;
						var this11 = pixelImage.image[location];
						var this12 = this11;
						var this13 = pixelimage_Endian_isLittleEndian ? (this12 >> 24 & 255) << 24 | (this12 & 255) << 16 | (this12 >> 8 & 255) << 8 | this12 >> 16 & 255 : this12;
						var this14 = this13 >> 24 & 255;
						var a1 = this14 == 0 ? 0. : this14 / 255;
						var this15 = this13 >> 16 & 255;
						var r1 = this15 == 0 ? 0. : this15 / 255;
						var this16 = this13 >> 8 & 255;
						var g1 = this16 == 0 ? 0. : this16 / 255;
						var this17 = this13 & 255;
						var b1 = this17 == 0 ? 0. : this17 / 255;
						var this18 = col >> 24 & 255;
						var a2 = this18 == 0 ? 0. : this18 / 255;
						var this19 = col >> 16 & 255;
						var r2 = this19 == 0 ? 0. : this19 / 255;
						var this20 = col >> 8 & 255;
						var g2 = this20 == 0 ? 0. : this20 / 255;
						var this21 = col & 255;
						var b2 = this21 == 0 ? 0. : this21 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelImage.image[pixelImage.useVirtualPos ? (y1 - pixelImage.virtualY) * pixelImage.width + x1 - pixelImage.virtualX | 0 : y1 * pixelImage.width + x1 | 0] = pixelimage_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
					}
				}
			}
		}
		temp = null;
	}
	,__class__: pixelimage_shapeStruct_SquareShape
});
var pixelimage_shapeStruct_TriangleGradient = function(opacity,visibility,aX,aY,bX,bY,cX,cY,colorA,colorB,colorC) {
	if(colorC == null) {
		colorC = -16776961;
	}
	if(colorB == null) {
		colorB = -16711936;
	}
	if(colorA == null) {
		colorA = -65536;
	}
	if(cY == null) {
		cY = 1.;
	}
	if(cX == null) {
		cX = 0.;
	}
	if(bY == null) {
		bY = 0.;
	}
	if(bX == null) {
		bX = 1.;
	}
	if(aY == null) {
		aY = 0.;
	}
	if(aX == null) {
		aX = 0.;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pixelimage_shapeStruct_BasicGradient.call(this,opacity,visibility,[colorA,colorB,colorC]);
	this.aX = aX;
	this.aY = aY;
	this.bX = bX;
	this.bY = bY;
	this.cX = cX;
	this.cY = cY;
};
pixelimage_shapeStruct_TriangleGradient.__name__ = "pixelimage.shapeStruct.TriangleGradient";
pixelimage_shapeStruct_TriangleGradient.__super__ = pixelimage_shapeStruct_BasicGradient;
pixelimage_shapeStruct_TriangleGradient.prototype = $extend(pixelimage_shapeStruct_BasicGradient.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "aX":
			this.aX = parseFloat(value);
			break;
		case "aY":
			this.aY = parseFloat(value);
			break;
		case "bX":
			this.bX = parseFloat(value);
			break;
		case "bY":
			this.bY = parseFloat(value);
			break;
		case "cX":
			this.cX = parseFloat(value);
			break;
		case "cY":
			this.cY = parseFloat(value);
			break;
		case "colorA":
			this.cornerColors[0] = Std.parseInt(value);
			break;
		case "colorB":
			this.cornerColors[1] = Std.parseInt(value);
			break;
		case "colorC":
			this.cornerColors[2] = Std.parseInt(value);
			break;
		default:
			pixelimage_shapeStruct_BasicGradient.prototype.setParameter.call(this,name,value);
		}
	}
	,render: function(pixelImage) {
		var ax = this.aX;
		var ay = this.aY;
		var colA = this.cornerColors[0];
		var bx = this.bX;
		var by = this.bY;
		var colB = this.cornerColors[1];
		var cx = this.cX;
		var cy = this.cY;
		var colC = this.cornerColors[2];
		var aA = colB >> 24 & 255;
		var rA = colB >> 16 & 255;
		var gA = colB >> 8 & 255;
		var bA = colB & 255;
		var aB = colA >> 24 & 255;
		var rB = colA >> 16 & 255;
		var gB = colA >> 8 & 255;
		var bB = colA & 255;
		var aC = colC >> 24 & 255;
		var rC = colC >> 16 & 255;
		var gC = colC >> 8 & 255;
		var bC = colC & 255;
		var bcx = bx - cx;
		var bcy = by - cy;
		var acx = ax - cx;
		var acy = ay - cy;
		var dot11 = bcx * bcx + bcy * bcy;
		var dot12 = bcx * acx + bcy * acy;
		var dot22 = acx * acx + acy * acy;
		var denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
		var _g = cx > bx ? cx > ax ? new IntIterator(bx > ax ? Math.floor(ax) : Math.floor(bx),Math.ceil(cx)) : new IntIterator(Math.floor(bx),Math.ceil(ax)) : bx > ax ? new IntIterator(cx > ax ? Math.floor(ax) : Math.ceil(cx),Math.ceil(bx)) : new IntIterator(Math.floor(cx),Math.ceil(ax));
		while(_g.min < _g.max) {
			var px = _g.min++;
			var pcx = px - cx;
			var _g1 = cy > by ? cy > ay ? new IntIterator(by > ay ? Math.floor(ay) : Math.floor(by),Math.ceil(cy)) : new IntIterator(Math.floor(by),Math.ceil(ay)) : by > ay ? new IntIterator(cy > ay ? Math.floor(ay) : Math.ceil(cy),Math.ceil(by)) : new IntIterator(Math.floor(cy),Math.ceil(ay));
			while(_g1.min < _g1.max) {
				var py = _g1.min++;
				var pcy = py - cy;
				var dot31 = pcx * bcx + pcy * bcy;
				var dot32 = pcx * acx + pcy * acy;
				var ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
				var ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
				var ratioC = 1.0 - ratioB - ratioA;
				if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
					var i = aA * ratioA + aB * ratioB + aC * ratioC | 0;
					if(i > 255) {
						i = 255;
					}
					if(i < 0) {
						i = 0;
					}
					var this1 = i;
					var a = this1;
					var i1 = rA * ratioA + rB * ratioB + rC * ratioC | 0;
					if(i1 > 255) {
						i1 = 255;
					}
					if(i1 < 0) {
						i1 = 0;
					}
					var this2 = i1;
					var r = this2;
					var i2 = gA * ratioA + gB * ratioB + gC * ratioC | 0;
					if(i2 > 255) {
						i2 = 255;
					}
					if(i2 < 0) {
						i2 = 0;
					}
					var this3 = i2;
					var g = this3;
					var i3 = bA * ratioA + bB * ratioB + bC * ratioC | 0;
					if(i3 > 255) {
						i3 = 255;
					}
					if(i3 < 0) {
						i3 = 0;
					}
					var this4 = i3;
					var b = this4;
					var location = pixelImage.useVirtualPos ? (py - pixelImage.virtualY) * pixelImage.width + px - pixelImage.virtualX | 0 : py * pixelImage.width + px | 0;
					if(pixelImage.transparent && a < 254) {
						var this5 = pixelImage.image[location];
						var this6 = this5;
						var old = pixelimage_Endian_isLittleEndian ? (this6 >> 24 & 255) << 24 | (this6 & 255) << 16 | (this6 >> 8 & 255) << 8 | this6 >> 16 & 255 : this6;
						var rhs = a << 24 | r << 16 | g << 8 | b;
						var this7 = old >> 24 & 255;
						var a1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = old >> 16 & 255;
						var r1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = old >> 8 & 255;
						var g1 = this9 == 0 ? 0. : this9 / 255;
						var this10 = old & 255;
						var b1 = this10 == 0 ? 0. : this10 / 255;
						var this11 = rhs >> 24 & 255;
						var a2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = rhs >> 16 & 255;
						var r2 = this12 == 0 ? 0. : this12 / 255;
						var this13 = rhs >> 8 & 255;
						var g2 = this13 == 0 ? 0. : this13 / 255;
						var this14 = rhs & 255;
						var b2 = this14 == 0 ? 0. : this14 / 255;
						var a3 = a1 * (1 - a2);
						var r3 = 255 * (r1 * a3 + r2 * a2) | 0;
						var g3 = 255 * (g1 * a3 + g2 * a2) | 0;
						var b3 = 255 * (b1 * a3 + b2 * a2) | 0;
						var a4 = 255 * (a3 + a2) | 0;
						var blended = a4 << 24 | r3 << 16 | g3 << 8 | b3;
						pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelImage.image[location] = pixelImage.isLittle ? a << 24 | b << 16 | g << 8 | r : a << 24 | r << 16 | g << 8 | b;
					}
				}
			}
		}
	}
	,__class__: pixelimage_shapeStruct_TriangleGradient
});
var pixelimage_shapeStruct_TriangleShape = function(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,x1,y1,x2,y2,x3,y3) {
	if(y3 == null) {
		y3 = 0.;
	}
	if(x3 == null) {
		x3 = 0.;
	}
	if(y2 == null) {
		y2 = 0.;
	}
	if(x2 == null) {
		x2 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	if(fill == null) {
		fill = 0;
	}
	if(strokeWidth == null) {
		strokeWidth = 1.;
	}
	if(strokeColor == null) {
		strokeColor = 0;
	}
	if(visibility == null) {
		visibility = true;
	}
	if(opacity == null) {
		opacity = 1.;
	}
	pixelimage_shapeStruct_FillShape.call(this,opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill);
	this.x1 = x1;
	this.y1 = y1;
	this.x2 = x2;
	this.y2 = y2;
	this.x3 = x3;
	this.y3 = y3;
};
pixelimage_shapeStruct_TriangleShape.__name__ = "pixelimage.shapeStruct.TriangleShape";
pixelimage_shapeStruct_TriangleShape.__super__ = pixelimage_shapeStruct_FillShape;
pixelimage_shapeStruct_TriangleShape.prototype = $extend(pixelimage_shapeStruct_FillShape.prototype,{
	setParameter: function(name,value) {
		switch(name) {
		case "x1":
			this.x1 = parseFloat(value);
			break;
		case "x2":
			this.x2 = parseFloat(value);
			break;
		case "x3":
			this.x3 = parseFloat(value);
			break;
		case "y1":
			this.y1 = parseFloat(value);
			break;
		case "y2":
			this.y2 = parseFloat(value);
			break;
		case "y3":
			this.y3 = parseFloat(value);
			break;
		default:
			pixelimage_shapeStruct_FillShape.prototype.setParameter.call(this,name,value);
		}
	}
	,render: function(pixelImage) {
		var ax = this.x1;
		var ay = this.y1;
		var bx = this.x2;
		var by = this.y2;
		var cx = this.x3;
		var cy = this.y3;
		var color = this.fill;
		var adjustWinding = ax * by - bx * ay + (bx * cy - cx * by) + (cx * ay - ax * cy) > 0;
		if(!adjustWinding) {
			var bx_ = bx;
			var by_ = by;
			bx = cx;
			by = cy;
			cx = bx_;
			cy = by_;
		}
		var s0 = ay * cx - ax * cy;
		var sx = cy - ay;
		var sy = ax - cx;
		var t0 = ax * by - ay * bx;
		var tx = ay - by;
		var ty = bx - ax;
		var A = -by * cx + ay * (-bx + cx) + ax * (by - cy) + bx * cy;
		var ii = ay > by ? ay > cy ? new IntIterator(by > cy ? Math.floor(cy) : Math.floor(by),Math.ceil(ay)) : new IntIterator(Math.floor(by),Math.ceil(cy)) : by > cy ? new IntIterator(ay > cy ? Math.floor(cy) : Math.ceil(ay),Math.ceil(by)) : new IntIterator(Math.floor(ay),Math.ceil(cy));
		var this1 = new pixelimage_iter_IntIterStart(ii.min,ii.max);
		var yIter3 = this1;
		var foundY = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g = ax > bx ? ax > cx ? new IntIterator(bx > cx ? Math.floor(cx) : Math.floor(bx),Math.ceil(ax)) : new IntIterator(Math.floor(bx),Math.ceil(cx)) : bx > cx ? new IntIterator(ax > cx ? Math.floor(cx) : Math.ceil(ax),Math.ceil(bx)) : new IntIterator(Math.floor(ax),Math.ceil(cx));
		while(_g.min < _g.max) {
			var x = _g.min++;
			sxx = sx * x;
			txx = tx * x;
			foundY = false;
			var _g_min = yIter3.start;
			var _g_max = yIter3.max;
			while(_g_min < _g_max) {
				var y = _g_min++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(foundY) {
						break;
					}
				} else if(s + t < A) {
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && pixelImage.transparent) {
						var location = pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0;
						var this2 = pixelImage.image[location];
						var this3 = this2;
						var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelImage.image[pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					foundY = true;
				} else if(foundY) {
					break;
				}
			}
		}
		var px = this.x1;
		var py = this.y1;
		var color = this.strokeColor;
		var o = this.y2 - py;
		var a = this.x2 - py;
		var h = Math.pow(o * o + a * a,0.5);
		var theta = Math.atan2(o,a);
		var debugCorners = false;
		if(debugCorners == null) {
			debugCorners = false;
		}
		var sin = Math.sin(theta);
		var cos = Math.cos(theta);
		var radius = this.strokeWidth / 2;
		var dx = 0.1;
		var dy = radius;
		var cx = h;
		var cy = radius;
		var bx = h;
		var by = -radius;
		var ax = 0.1;
		var ay = -radius;
		var temp = 0.;
		temp = px + (ax * cos - ay * sin);
		ay = py + (ay * cos + ax * sin);
		ax = temp;
		temp = px + (bx * cos - by * sin);
		by = py + (by * cos + bx * sin);
		bx = temp;
		temp = px + (cx * cos - cy * sin);
		cy = py + (cy * cos + cx * sin);
		cx = temp;
		temp = px + (dx * cos - dy * sin);
		dy = py + (dy * cos + dx * sin);
		dx = temp;
		if(debugCorners) {
			var x = ax - 6.;
			var y = ay - 6.;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + 12 | 0;
			var maxY = y + 12 | 0;
			while(true) {
				var x = p++;
				var this1 = -65536;
				var c = this1;
				if((c >> 24 & 255) < 254 && pixelImage.transparent) {
					var location = pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0;
					var this2 = pixelImage.image[location];
					var this3 = this2;
					var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 0;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 0;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					pixelImage.image[pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var x = bx - 6.;
			var y = by - 6.;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + 12 | 0;
			var maxY = y + 12 | 0;
			while(true) {
				var x = p++;
				var this1 = -16711936;
				var c = this1;
				if((c >> 24 & 255) < 254 && pixelImage.transparent) {
					var location = pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0;
					var this2 = pixelImage.image[location];
					var this3 = this2;
					var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = 0;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 0;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					pixelImage.image[pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var x = cx - 6.;
			var y = cy - 6.;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + 12 | 0;
			var maxY = y + 12 | 0;
			while(true) {
				var x = p++;
				var this1 = -16776961;
				var c = this1;
				if((c >> 24 & 255) < 254 && pixelImage.transparent) {
					var location = pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0;
					var this2 = pixelImage.image[location];
					var this3 = this2;
					var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = 0;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 0;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					pixelImage.image[pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var x = dx - 6.;
			var y = dy - 6.;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + 12 | 0;
			var maxY = y + 12 | 0;
			while(true) {
				var x = p++;
				var this1 = -1048336;
				var c = this1;
				if((c >> 24 & 255) < 254 && pixelImage.transparent) {
					var location = pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0;
					var this2 = pixelImage.image[location];
					var this3 = this2;
					var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = 240;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 0;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 240;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					pixelImage.image[pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
		}
		var bx1 = bx;
		var by1 = by;
		var cx1 = dx;
		var cy1 = dy;
		var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy1 - cx1 * by1) + (cx1 * ay - ax * cy1) > 0;
		if(!adjustWinding) {
			var bx_ = bx1;
			var by_ = by1;
			bx1 = cx1;
			by1 = cy1;
			cx1 = bx_;
			cy1 = by_;
		}
		var s0 = ay * cx1 - ax * cy1;
		var sx = cy1 - ay;
		var sy = ax - cx1;
		var t0 = ax * by1 - ay * bx1;
		var tx = ay - by1;
		var ty = bx1 - ax;
		var A = -by1 * cx1 + ay * (-bx1 + cx1) + ax * (by1 - cy1) + bx1 * cy1;
		var ii = ay > by1 ? ay > cy1 ? new IntIterator(by1 > cy1 ? Math.floor(cy1) : Math.floor(by1),Math.ceil(ay)) : new IntIterator(Math.floor(by1),Math.ceil(cy1)) : by1 > cy1 ? new IntIterator(ay > cy1 ? Math.floor(cy1) : Math.ceil(ay),Math.ceil(by1)) : new IntIterator(Math.floor(ay),Math.ceil(cy1));
		var this1 = new pixelimage_iter_IntIterStart(ii.min,ii.max);
		var yIter3 = this1;
		var foundY = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g = ax > bx1 ? ax > cx1 ? new IntIterator(bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1),Math.ceil(ax)) : new IntIterator(Math.floor(bx1),Math.ceil(cx1)) : bx1 > cx1 ? new IntIterator(ax > cx1 ? Math.floor(cx1) : Math.ceil(ax),Math.ceil(bx1)) : new IntIterator(Math.floor(ax),Math.ceil(cx1));
		while(_g.min < _g.max) {
			var x = _g.min++;
			sxx = sx * x;
			txx = tx * x;
			foundY = false;
			var _g_min = yIter3.start;
			var _g_max = yIter3.max;
			while(_g_min < _g_max) {
				var y = _g_min++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(foundY) {
						break;
					}
				} else if(s + t < A) {
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && pixelImage.transparent) {
						var location = pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0;
						var this2 = pixelImage.image[location];
						var this3 = this2;
						var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelImage.image[pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					foundY = true;
				} else if(foundY) {
					break;
				}
			}
		}
		var bx1 = cx;
		var by1 = cy;
		var cx = dx;
		var cy = dy;
		var adjustWinding = bx * by1 - bx1 * by + (bx1 * cy - cx * by1) + (cx * by - bx * cy) > 0;
		if(!adjustWinding) {
			var bx_ = bx1;
			var by_ = by1;
			bx1 = cx;
			by1 = cy;
			cx = bx_;
			cy = by_;
		}
		var s0 = by * cx - bx * cy;
		var sx = cy - by;
		var sy = bx - cx;
		var t0 = bx * by1 - by * bx1;
		var tx = by - by1;
		var ty = bx1 - bx;
		var A = -by1 * cx + by * (-bx1 + cx) + bx * (by1 - cy) + bx1 * cy;
		var ii = by > by1 ? by > cy ? new IntIterator(by1 > cy ? Math.floor(cy) : Math.floor(by1),Math.ceil(by)) : new IntIterator(Math.floor(by1),Math.ceil(cy)) : by1 > cy ? new IntIterator(by > cy ? Math.floor(cy) : Math.ceil(by),Math.ceil(by1)) : new IntIterator(Math.floor(by),Math.ceil(cy));
		var this1 = new pixelimage_iter_IntIterStart(ii.min,ii.max);
		var yIter3 = this1;
		var foundY = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g = bx > bx1 ? bx > cx ? new IntIterator(bx1 > cx ? Math.floor(cx) : Math.floor(bx1),Math.ceil(bx)) : new IntIterator(Math.floor(bx1),Math.ceil(cx)) : bx1 > cx ? new IntIterator(bx > cx ? Math.floor(cx) : Math.ceil(bx),Math.ceil(bx1)) : new IntIterator(Math.floor(bx),Math.ceil(cx));
		while(_g.min < _g.max) {
			var x = _g.min++;
			sxx = sx * x;
			txx = tx * x;
			foundY = false;
			var _g_min = yIter3.start;
			var _g_max = yIter3.max;
			while(_g_min < _g_max) {
				var y = _g_min++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(foundY) {
						break;
					}
				} else if(s + t < A) {
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && pixelImage.transparent) {
						var location = pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0;
						var this2 = pixelImage.image[location];
						var this3 = this2;
						var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelImage.image[pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					foundY = true;
				} else if(foundY) {
					break;
				}
			}
		}
		var px = this.x2;
		var py = this.y2;
		var color = this.strokeColor;
		var o = this.y3 - py;
		var a = this.x3 - py;
		var h = Math.pow(o * o + a * a,0.5);
		var theta = Math.atan2(o,a);
		var debugCorners = false;
		if(debugCorners == null) {
			debugCorners = false;
		}
		var sin = Math.sin(theta);
		var cos = Math.cos(theta);
		var radius = this.strokeWidth / 2;
		var dx = 0.1;
		var dy = radius;
		var cx = h;
		var cy = radius;
		var bx = h;
		var by = -radius;
		var ax = 0.1;
		var ay = -radius;
		var temp = 0.;
		temp = px + (ax * cos - ay * sin);
		ay = py + (ay * cos + ax * sin);
		ax = temp;
		temp = px + (bx * cos - by * sin);
		by = py + (by * cos + bx * sin);
		bx = temp;
		temp = px + (cx * cos - cy * sin);
		cy = py + (cy * cos + cx * sin);
		cx = temp;
		temp = px + (dx * cos - dy * sin);
		dy = py + (dy * cos + dx * sin);
		dx = temp;
		if(debugCorners) {
			var x = ax - 6.;
			var y = ay - 6.;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + 12 | 0;
			var maxY = y + 12 | 0;
			while(true) {
				var x = p++;
				var this1 = -65536;
				var c = this1;
				if((c >> 24 & 255) < 254 && pixelImage.transparent) {
					var location = pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0;
					var this2 = pixelImage.image[location];
					var this3 = this2;
					var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 0;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 0;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					pixelImage.image[pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var x = bx - 6.;
			var y = by - 6.;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + 12 | 0;
			var maxY = y + 12 | 0;
			while(true) {
				var x = p++;
				var this1 = -16711936;
				var c = this1;
				if((c >> 24 & 255) < 254 && pixelImage.transparent) {
					var location = pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0;
					var this2 = pixelImage.image[location];
					var this3 = this2;
					var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = 0;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 0;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					pixelImage.image[pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var x = cx - 6.;
			var y = cy - 6.;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + 12 | 0;
			var maxY = y + 12 | 0;
			while(true) {
				var x = p++;
				var this1 = -16776961;
				var c = this1;
				if((c >> 24 & 255) < 254 && pixelImage.transparent) {
					var location = pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0;
					var this2 = pixelImage.image[location];
					var this3 = this2;
					var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = 0;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 0;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					pixelImage.image[pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var x = dx - 6.;
			var y = dy - 6.;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + 12 | 0;
			var maxY = y + 12 | 0;
			while(true) {
				var x = p++;
				var this1 = -1048336;
				var c = this1;
				if((c >> 24 & 255) < 254 && pixelImage.transparent) {
					var location = pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0;
					var this2 = pixelImage.image[location];
					var this3 = this2;
					var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = 240;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 0;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 240;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					pixelImage.image[pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
		}
		var bx1 = bx;
		var by1 = by;
		var cx1 = dx;
		var cy1 = dy;
		var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy1 - cx1 * by1) + (cx1 * ay - ax * cy1) > 0;
		if(!adjustWinding) {
			var bx_ = bx1;
			var by_ = by1;
			bx1 = cx1;
			by1 = cy1;
			cx1 = bx_;
			cy1 = by_;
		}
		var s0 = ay * cx1 - ax * cy1;
		var sx = cy1 - ay;
		var sy = ax - cx1;
		var t0 = ax * by1 - ay * bx1;
		var tx = ay - by1;
		var ty = bx1 - ax;
		var A = -by1 * cx1 + ay * (-bx1 + cx1) + ax * (by1 - cy1) + bx1 * cy1;
		var ii = ay > by1 ? ay > cy1 ? new IntIterator(by1 > cy1 ? Math.floor(cy1) : Math.floor(by1),Math.ceil(ay)) : new IntIterator(Math.floor(by1),Math.ceil(cy1)) : by1 > cy1 ? new IntIterator(ay > cy1 ? Math.floor(cy1) : Math.ceil(ay),Math.ceil(by1)) : new IntIterator(Math.floor(ay),Math.ceil(cy1));
		var this1 = new pixelimage_iter_IntIterStart(ii.min,ii.max);
		var yIter3 = this1;
		var foundY = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g = ax > bx1 ? ax > cx1 ? new IntIterator(bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1),Math.ceil(ax)) : new IntIterator(Math.floor(bx1),Math.ceil(cx1)) : bx1 > cx1 ? new IntIterator(ax > cx1 ? Math.floor(cx1) : Math.ceil(ax),Math.ceil(bx1)) : new IntIterator(Math.floor(ax),Math.ceil(cx1));
		while(_g.min < _g.max) {
			var x = _g.min++;
			sxx = sx * x;
			txx = tx * x;
			foundY = false;
			var _g_min = yIter3.start;
			var _g_max = yIter3.max;
			while(_g_min < _g_max) {
				var y = _g_min++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(foundY) {
						break;
					}
				} else if(s + t < A) {
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && pixelImage.transparent) {
						var location = pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0;
						var this2 = pixelImage.image[location];
						var this3 = this2;
						var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelImage.image[pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					foundY = true;
				} else if(foundY) {
					break;
				}
			}
		}
		var bx1 = cx;
		var by1 = cy;
		var cx = dx;
		var cy = dy;
		var adjustWinding = bx * by1 - bx1 * by + (bx1 * cy - cx * by1) + (cx * by - bx * cy) > 0;
		if(!adjustWinding) {
			var bx_ = bx1;
			var by_ = by1;
			bx1 = cx;
			by1 = cy;
			cx = bx_;
			cy = by_;
		}
		var s0 = by * cx - bx * cy;
		var sx = cy - by;
		var sy = bx - cx;
		var t0 = bx * by1 - by * bx1;
		var tx = by - by1;
		var ty = bx1 - bx;
		var A = -by1 * cx + by * (-bx1 + cx) + bx * (by1 - cy) + bx1 * cy;
		var ii = by > by1 ? by > cy ? new IntIterator(by1 > cy ? Math.floor(cy) : Math.floor(by1),Math.ceil(by)) : new IntIterator(Math.floor(by1),Math.ceil(cy)) : by1 > cy ? new IntIterator(by > cy ? Math.floor(cy) : Math.ceil(by),Math.ceil(by1)) : new IntIterator(Math.floor(by),Math.ceil(cy));
		var this1 = new pixelimage_iter_IntIterStart(ii.min,ii.max);
		var yIter3 = this1;
		var foundY = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g = bx > bx1 ? bx > cx ? new IntIterator(bx1 > cx ? Math.floor(cx) : Math.floor(bx1),Math.ceil(bx)) : new IntIterator(Math.floor(bx1),Math.ceil(cx)) : bx1 > cx ? new IntIterator(bx > cx ? Math.floor(cx) : Math.ceil(bx),Math.ceil(bx1)) : new IntIterator(Math.floor(bx),Math.ceil(cx));
		while(_g.min < _g.max) {
			var x = _g.min++;
			sxx = sx * x;
			txx = tx * x;
			foundY = false;
			var _g_min = yIter3.start;
			var _g_max = yIter3.max;
			while(_g_min < _g_max) {
				var y = _g_min++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(foundY) {
						break;
					}
				} else if(s + t < A) {
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && pixelImage.transparent) {
						var location = pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0;
						var this2 = pixelImage.image[location];
						var this3 = this2;
						var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelImage.image[pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					foundY = true;
				} else if(foundY) {
					break;
				}
			}
		}
		var px = this.x3;
		var py = this.y3;
		var color = this.strokeColor;
		var o = this.y1 - py;
		var a = this.x1 - py;
		var h = Math.pow(o * o + a * a,0.5);
		var theta = Math.atan2(o,a);
		var debugCorners = false;
		if(debugCorners == null) {
			debugCorners = false;
		}
		var sin = Math.sin(theta);
		var cos = Math.cos(theta);
		var radius = this.strokeWidth / 2;
		var dx = 0.1;
		var dy = radius;
		var cx = h;
		var cy = radius;
		var bx = h;
		var by = -radius;
		var ax = 0.1;
		var ay = -radius;
		var temp = 0.;
		temp = px + (ax * cos - ay * sin);
		ay = py + (ay * cos + ax * sin);
		ax = temp;
		temp = px + (bx * cos - by * sin);
		by = py + (by * cos + bx * sin);
		bx = temp;
		temp = px + (cx * cos - cy * sin);
		cy = py + (cy * cos + cx * sin);
		cx = temp;
		temp = px + (dx * cos - dy * sin);
		dy = py + (dy * cos + dx * sin);
		dx = temp;
		if(debugCorners) {
			var x = ax - 6.;
			var y = ay - 6.;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + 12 | 0;
			var maxY = y + 12 | 0;
			while(true) {
				var x = p++;
				var this1 = -65536;
				var c = this1;
				if((c >> 24 & 255) < 254 && pixelImage.transparent) {
					var location = pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0;
					var this2 = pixelImage.image[location];
					var this3 = this2;
					var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = 255;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 0;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 0;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					pixelImage.image[pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var x = bx - 6.;
			var y = by - 6.;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + 12 | 0;
			var maxY = y + 12 | 0;
			while(true) {
				var x = p++;
				var this1 = -16711936;
				var c = this1;
				if((c >> 24 & 255) < 254 && pixelImage.transparent) {
					var location = pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0;
					var this2 = pixelImage.image[location];
					var this3 = this2;
					var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = 0;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 255;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 0;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					pixelImage.image[pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var x = cx - 6.;
			var y = cy - 6.;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + 12 | 0;
			var maxY = y + 12 | 0;
			while(true) {
				var x = p++;
				var this1 = -16776961;
				var c = this1;
				if((c >> 24 & 255) < 254 && pixelImage.transparent) {
					var location = pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0;
					var this2 = pixelImage.image[location];
					var this3 = this2;
					var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = 0;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 0;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 255;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					pixelImage.image[pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
			var x = dx - 6.;
			var y = dy - 6.;
			var p = x | 0;
			var xx = p;
			var q = y | 0;
			var maxX = x + 12 | 0;
			var maxY = y + 12 | 0;
			while(true) {
				var x = p++;
				var this1 = -1048336;
				var c = this1;
				if((c >> 24 & 255) < 254 && pixelImage.transparent) {
					var location = pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0;
					var this2 = pixelImage.image[location];
					var this3 = this2;
					var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
					var this5 = this4 >> 24 & 255;
					var a1 = this5 == 0 ? 0. : this5 / 255;
					var this6 = this4 >> 16 & 255;
					var r1 = this6 == 0 ? 0. : this6 / 255;
					var this7 = this4 >> 8 & 255;
					var g1 = this7 == 0 ? 0. : this7 / 255;
					var this8 = this4 & 255;
					var b1 = this8 == 0 ? 0. : this8 / 255;
					var this9 = 255;
					var a2 = this9 == 0 ? 0. : this9 / 255;
					var this10 = 240;
					var r2 = this10 == 0 ? 0. : this10 / 255;
					var this11 = 0;
					var g2 = this11 == 0 ? 0. : this11 / 255;
					var this12 = 240;
					var b2 = this12 == 0 ? 0. : this12 / 255;
					var a3 = a1 * (1 - a2);
					var r = 255 * (r1 * a3 + r2 * a2) | 0;
					var g = 255 * (g1 * a3 + g2 * a2) | 0;
					var b = 255 * (b1 * a3 + b2 * a2) | 0;
					var a = 255 * (a3 + a2) | 0;
					var blended = a << 24 | r << 16 | g << 8 | b;
					pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
				} else {
					pixelImage.image[pixelImage.useVirtualPos ? (q - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : q * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				}
				if(p > maxX) {
					p = xx;
					++q;
				}
				if(q > maxY) {
					break;
				}
			}
		}
		var bx1 = bx;
		var by1 = by;
		var cx1 = dx;
		var cy1 = dy;
		var adjustWinding = ax * by1 - bx1 * ay + (bx1 * cy1 - cx1 * by1) + (cx1 * ay - ax * cy1) > 0;
		if(!adjustWinding) {
			var bx_ = bx1;
			var by_ = by1;
			bx1 = cx1;
			by1 = cy1;
			cx1 = bx_;
			cy1 = by_;
		}
		var s0 = ay * cx1 - ax * cy1;
		var sx = cy1 - ay;
		var sy = ax - cx1;
		var t0 = ax * by1 - ay * bx1;
		var tx = ay - by1;
		var ty = bx1 - ax;
		var A = -by1 * cx1 + ay * (-bx1 + cx1) + ax * (by1 - cy1) + bx1 * cy1;
		var ii = ay > by1 ? ay > cy1 ? new IntIterator(by1 > cy1 ? Math.floor(cy1) : Math.floor(by1),Math.ceil(ay)) : new IntIterator(Math.floor(by1),Math.ceil(cy1)) : by1 > cy1 ? new IntIterator(ay > cy1 ? Math.floor(cy1) : Math.ceil(ay),Math.ceil(by1)) : new IntIterator(Math.floor(ay),Math.ceil(cy1));
		var this1 = new pixelimage_iter_IntIterStart(ii.min,ii.max);
		var yIter3 = this1;
		var foundY = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g = ax > bx1 ? ax > cx1 ? new IntIterator(bx1 > cx1 ? Math.floor(cx1) : Math.floor(bx1),Math.ceil(ax)) : new IntIterator(Math.floor(bx1),Math.ceil(cx1)) : bx1 > cx1 ? new IntIterator(ax > cx1 ? Math.floor(cx1) : Math.ceil(ax),Math.ceil(bx1)) : new IntIterator(Math.floor(ax),Math.ceil(cx1));
		while(_g.min < _g.max) {
			var x = _g.min++;
			sxx = sx * x;
			txx = tx * x;
			foundY = false;
			var _g_min = yIter3.start;
			var _g_max = yIter3.max;
			while(_g_min < _g_max) {
				var y = _g_min++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(foundY) {
						break;
					}
				} else if(s + t < A) {
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && pixelImage.transparent) {
						var location = pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0;
						var this2 = pixelImage.image[location];
						var this3 = this2;
						var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelImage.image[pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					foundY = true;
				} else if(foundY) {
					break;
				}
			}
		}
		var bx1 = cx;
		var by1 = cy;
		var cx = dx;
		var cy = dy;
		var adjustWinding = bx * by1 - bx1 * by + (bx1 * cy - cx * by1) + (cx * by - bx * cy) > 0;
		if(!adjustWinding) {
			var bx_ = bx1;
			var by_ = by1;
			bx1 = cx;
			by1 = cy;
			cx = bx_;
			cy = by_;
		}
		var s0 = by * cx - bx * cy;
		var sx = cy - by;
		var sy = bx - cx;
		var t0 = bx * by1 - by * bx1;
		var tx = by - by1;
		var ty = bx1 - bx;
		var A = -by1 * cx + by * (-bx1 + cx) + bx * (by1 - cy) + bx1 * cy;
		var ii = by > by1 ? by > cy ? new IntIterator(by1 > cy ? Math.floor(cy) : Math.floor(by1),Math.ceil(by)) : new IntIterator(Math.floor(by1),Math.ceil(cy)) : by1 > cy ? new IntIterator(by > cy ? Math.floor(cy) : Math.ceil(by),Math.ceil(by1)) : new IntIterator(Math.floor(by),Math.ceil(cy));
		var this1 = new pixelimage_iter_IntIterStart(ii.min,ii.max);
		var yIter3 = this1;
		var foundY = false;
		var s = 0.;
		var t = 0.;
		var sxx = 0.;
		var txx = 0.;
		var _g = bx > bx1 ? bx > cx ? new IntIterator(bx1 > cx ? Math.floor(cx) : Math.floor(bx1),Math.ceil(bx)) : new IntIterator(Math.floor(bx1),Math.ceil(cx)) : bx1 > cx ? new IntIterator(bx > cx ? Math.floor(cx) : Math.ceil(bx),Math.ceil(bx1)) : new IntIterator(Math.floor(bx),Math.ceil(cx));
		while(_g.min < _g.max) {
			var x = _g.min++;
			sxx = sx * x;
			txx = tx * x;
			foundY = false;
			var _g_min = yIter3.start;
			var _g_max = yIter3.max;
			while(_g_min < _g_max) {
				var y = _g_min++;
				s = s0 + sxx + sy * y;
				t = t0 + txx + ty * y;
				if(s <= 0 || t <= 0) {
					if(foundY) {
						break;
					}
				} else if(s + t < A) {
					var this1 = color;
					var c = this1;
					if((c >> 24 & 255) < 254 && pixelImage.transparent) {
						var location = pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0;
						var this2 = pixelImage.image[location];
						var this3 = this2;
						var this4 = pixelimage_Endian_isLittleEndian ? (this3 >> 24 & 255) << 24 | (this3 & 255) << 16 | (this3 >> 8 & 255) << 8 | this3 >> 16 & 255 : this3;
						var this5 = this4 >> 24 & 255;
						var a1 = this5 == 0 ? 0. : this5 / 255;
						var this6 = this4 >> 16 & 255;
						var r1 = this6 == 0 ? 0. : this6 / 255;
						var this7 = this4 >> 8 & 255;
						var g1 = this7 == 0 ? 0. : this7 / 255;
						var this8 = this4 & 255;
						var b1 = this8 == 0 ? 0. : this8 / 255;
						var this9 = color >> 24 & 255;
						var a2 = this9 == 0 ? 0. : this9 / 255;
						var this10 = color >> 16 & 255;
						var r2 = this10 == 0 ? 0. : this10 / 255;
						var this11 = color >> 8 & 255;
						var g2 = this11 == 0 ? 0. : this11 / 255;
						var this12 = color & 255;
						var b2 = this12 == 0 ? 0. : this12 / 255;
						var a3 = a1 * (1 - a2);
						var r = 255 * (r1 * a3 + r2 * a2) | 0;
						var g = 255 * (g1 * a3 + g2 * a2) | 0;
						var b = 255 * (b1 * a3 + b2 * a2) | 0;
						var a = 255 * (a3 + a2) | 0;
						var blended = a << 24 | r << 16 | g << 8 | b;
						pixelImage.image[location] = pixelimage_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended;
					} else {
						pixelImage.image[pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0] = pixelimage_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					}
					foundY = true;
				} else if(foundY) {
					break;
				}
			}
		}
	}
	,__class__: pixelimage_shapeStruct_TriangleShape
});
var pixelimage_shapeStruct_XMLshape = function(pixelImage,xml) {
	this.pixelImage = pixelImage;
	this.xml = xml;
	this.process();
};
pixelimage_shapeStruct_XMLshape.__name__ = "pixelimage.shapeStruct.XMLshape";
pixelimage_shapeStruct_XMLshape.prototype = {
	process: function() {
		var e = this.xml.elements();
		while(e.hasNext()) {
			var e1 = e.next();
			this.processShape(e1);
		}
	}
	,processShape: function(x) {
		if(x.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (x.nodeType == null ? "null" : XmlType.toString(x.nodeType)));
		}
		switch(x.nodeName) {
		case "ChordArcShape":
			var s = new pixelimage_shapeStruct_ChordArcShape();
			var att = x.attributes();
			while(att.hasNext()) {
				var att1 = att.next();
				s.setParameter(att1,x.get(att1));
			}
			s.render(this.pixelImage);
			break;
		case "CircleShape":
			var s = new pixelimage_shapeStruct_CircleShape();
			haxe_Log.trace("circleShape",{ fileName : "src/pixelimage/shapeStruct/XMLshape.hx", lineNumber : 28, className : "pixelimage.shapeStruct.XMLshape", methodName : "processShape"});
			var att = x.attributes();
			while(att.hasNext()) {
				var att1 = att.next();
				haxe_Log.trace(att1,{ fileName : "src/pixelimage/shapeStruct/XMLshape.hx", lineNumber : 30, className : "pixelimage.shapeStruct.XMLshape", methodName : "processShape"});
				s.setParameter(att1,x.get(att1));
			}
			s.render(this.pixelImage);
			break;
		case "ComponentShape":
			var s = new pixelimage_shapeStruct_ComponentShape();
			var att = this.xml.attributes();
			while(att.hasNext()) {
				var att1 = att.next();
				s.setParameter(att1,this.xml.get(att1));
			}
			break;
		case "CubicCurveShape":
			var s = new pixelimage_shapeStruct_CubicCurveShape();
			var att = x.attributes();
			while(att.hasNext()) {
				var att1 = att.next();
				s.setParameter(att1,x.get(att1));
			}
			s.render(this.pixelImage);
			break;
		case "EllipseArcShape":
			var s = new pixelimage_shapeStruct_EllipseArcShape();
			var att = this.xml.attributes();
			while(att.hasNext()) {
				var att1 = att.next();
				s.setParameter(att1,this.xml.get(att1));
			}
			s.render(this.pixelImage);
			break;
		case "LineGradient":
			var s = new pixelimage_shapeStruct_LineGradient();
			var att = this.xml.attributes();
			while(att.hasNext()) {
				var att1 = att.next();
				s.setParameter(att1,this.xml.get(att1));
			}
			s.render(this.pixelImage);
			break;
		case "LineShape":
			var s = new pixelimage_shapeStruct_LineShape();
			var att = this.xml.attributes();
			while(att.hasNext()) {
				var att1 = att.next();
				s.setParameter(att1,this.xml.get(att1));
			}
			s.render(this.pixelImage);
			break;
		case "PathElementShape":
			var s = new pixelimage_shapeStruct_PathElementShape();
			var att = this.xml.attributes();
			while(att.hasNext()) {
				var att1 = att.next();
				s.setParameter(att1,this.xml.get(att1));
			}
			s.render(this.pixelImage);
			break;
		case "PieArcShape":
			var s = new pixelimage_shapeStruct_PieArcShape();
			var att = this.xml.attributes();
			while(att.hasNext()) {
				var att1 = att.next();
				s.setParameter(att1,this.xml.get(att1));
			}
			s.render(this.pixelImage);
			break;
		case "PolyLineGradient":
			var s = new pixelimage_shapeStruct_PolyLineGradient();
			var att = this.xml.attributes();
			while(att.hasNext()) {
				var att1 = att.next();
				s.setParameter(att1,this.xml.get(att1));
			}
			s.render(this.pixelImage);
			break;
		case "PolyLineShape":
			var s = new pixelimage_shapeStruct_PolyLineShape();
			var att = this.xml.attributes();
			while(att.hasNext()) {
				var att1 = att.next();
				s.setParameter(att1,this.xml.get(att1));
			}
			s.render(this.pixelImage);
			break;
		case "QuadCurveShape":
			var s = new pixelimage_shapeStruct_QuadCurveShape();
			var att = this.xml.attributes();
			while(att.hasNext()) {
				var att1 = att.next();
				s.setParameter(att1,this.xml.get(att1));
			}
			s.render(this.pixelImage);
			break;
		case "QuadShape":
			var s = new pixelimage_shapeStruct_QuadShape();
			var att = this.xml.attributes();
			while(att.hasNext()) {
				var att1 = att.next();
				s.setParameter(att1,this.xml.get(att1));
			}
			s.render(this.pixelImage);
			break;
		case "RectangleShape":
			var s = new pixelimage_shapeStruct_RectangleShape();
			var att = this.xml.attributes();
			while(att.hasNext()) {
				var att1 = att.next();
				s.setParameter(att1,this.xml.get(att1));
			}
			s.render(this.pixelImage);
			break;
		case "SquareShape":
			var s = new pixelimage_shapeStruct_SquareShape();
			var att = this.xml.attributes();
			while(att.hasNext()) {
				var att1 = att.next();
				s.setParameter(att1,this.xml.get(att1));
			}
			s.render(this.pixelImage);
			break;
		case "TriangleGradient":
			var s = new pixelimage_shapeStruct_TriangleGradient();
			var att = this.xml.attributes();
			while(att.hasNext()) {
				var att1 = att.next();
				s.setParameter(att1,this.xml.get(att1));
			}
			s.render(this.pixelImage);
			break;
		case "TriangleShape":
			var s = new pixelimage_shapeStruct_TriangleShape();
			var att = this.xml.attributes();
			while(att.hasNext()) {
				var att1 = att.next();
				s.setParameter(att1,this.xml.get(att1));
			}
			s.render(this.pixelImage);
			break;
		default:
			haxe_Log.trace("shape unfound",{ fileName : "src/pixelimage/shapeStruct/XMLshape.hx", lineNumber : 95, className : "pixelimage.shapeStruct.XMLshape", methodName : "processShape"});
		}
	}
	,__class__: pixelimage_shapeStruct_XMLshape
};
var vision_ds_Line2D = function(start,end) {
	this.end = new vision_ds_Point2D(0,0);
	this.start = new vision_ds_Point2D(0,0);
	this.start.x = start.x;
	this.start.y = start.y;
	this.end.x = end.x;
	this.end.y = end.y;
	var x = end.x - start.x;
	var y = end.y - start.y;
	this.radians = Math.atan2(x,y);
	this.slope = Math.tan(this.radians);
	this.degrees = this.radians * 180 / Math.PI;
};
vision_ds_Line2D.__name__ = "vision.ds.Line2D";
vision_ds_Line2D.prototype = {
	toString: function() {
		return "\n (" + Std.string(this.start) + ".x, " + Std.string(this.start) + ".y) --> (" + Std.string(this.end) + ".x, " + Std.string(this.end) + ".y)";
	}
	,__class__: vision_ds_Line2D
};
var vision_ds_Point2D = function(x,y) {
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
};
vision_ds_Point2D.__name__ = "vision.ds.Point2D";
vision_ds_Point2D.prototype = {
	toString: function() {
		return "(" + this.x + ", " + this.y + ")";
	}
	,__class__: vision_ds_Point2D
};
var $_;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
Object.defineProperty(String.prototype,"__class__",{ value : String, enumerable : false});
String.__name__ = "String";
Array.__name__ = "Array";
js_Boot.__toStr = ({ }).toString;
Xml.Element = 0;
Xml.PCData = 1;
Xml.CData = 2;
Xml.Comment = 3;
Xml.DocType = 4;
Xml.ProcessingInstruction = 5;
Xml.Document = 6;
haxe_xml_Parser.escapes = (function($this) {
	var $r;
	var h = new haxe_ds_StringMap();
	h.h["lt"] = "<";
	h.h["gt"] = ">";
	h.h["amp"] = "&";
	h.h["quot"] = "\"";
	h.h["apos"] = "'";
	$r = h;
	return $r;
}(this));
var pixelimage_Endian_isLittleEndian = (function($this) {
	var $r;
	var a8 = new Uint8Array(4);
	var a32 = new Uint32Array(a8.buffer)[0] = -3407855;
	$r = a8[0] != 255;
	return $r;
}(this));
var pixelimage_shapeStruct_XMLshapeSamples_circleTest = "<CircleShape left='100' top='100' diameter='80' strokeColor='0xFF0000' strokeWidth='1' fill='0xFF00FF00'></CircleShape>";
pixelimage_DemoUse_main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
