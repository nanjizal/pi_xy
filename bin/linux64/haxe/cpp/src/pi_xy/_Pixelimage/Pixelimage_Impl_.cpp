// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericCell_Int
#include <haxe/ds/GenericCell_Int.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericStack_Int
#include <haxe/ds/GenericStack_Int.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_iterMagic_ArrIntImg
#include <iterMagic/ArrIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_BytesImg
#include <iterMagic/BytesImg.h>
#endif
#ifndef INCLUDED_iterMagic_Iimg
#include <iterMagic/Iimg.h>
#endif
#ifndef INCLUDED_iterMagic_StackIntImg
#include <iterMagic/StackIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_U32ArrImg
#include <iterMagic/U32ArrImg.h>
#endif
#ifndef INCLUDED_iterMagic_VecIntImg
#include <iterMagic/VecIntImg.h>
#endif
#ifndef INCLUDED_pi_xy_ByteAccessor
#include <pi_xy/ByteAccessor.h>
#endif
#ifndef INCLUDED_pi_xy_ImageStruct
#include <pi_xy/ImageStruct.h>
#endif
#ifndef INCLUDED_pi_xy__Endian_Endian_Fields_
#include <pi_xy/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy__Pixelimage_Pixelimage_Impl_
#include <pi_xy/_Pixelimage/Pixelimage_Impl_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitQuad
#include <pi_xy/algo/HitQuad.h>
#endif
#ifndef INCLUDED_pi_xy_algo_IhitObj
#include <pi_xy/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pi_xy_algo_QuadPoints_
#include <pi_xy/algo/QuadPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_RectangleWindow
#include <pi_xy/algo/RectangleWindow.h>
#endif
#ifndef INCLUDED_pi_xy_iter_IntIterStart
#include <pi_xy/iter/IntIterStart.h>
#endif
#ifndef INCLUDED_pi_xy_transformation__ScaleImage_ScaleImage_Fields_
#include <pi_xy/transformation/_ScaleImage/ScaleImage_Fields_.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_43_get_defaultType,"pi_xy._Pixelimage.Pixelimage_Impl_","get_defaultType",0xc950323a,"pi_xy._Pixelimage.Pixelimage_Impl_.get_defaultType","pi_xy/Pixelimage.hx",43,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_46_set_defaultType,"pi_xy._Pixelimage.Pixelimage_Impl_","set_defaultType",0xc51baf46,"pi_xy._Pixelimage.Pixelimage_Impl_.set_defaultType","pi_xy/Pixelimage.hx",46,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_51__new,"pi_xy._Pixelimage.Pixelimage_Impl_","_new",0x5c4c69d9,"pi_xy._Pixelimage.Pixelimage_Impl_._new","pi_xy/Pixelimage.hx",51,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_70_get_image,"pi_xy._Pixelimage.Pixelimage_Impl_","get_image",0xf5e7f43a,"pi_xy._Pixelimage.Pixelimage_Impl_.get_image","pi_xy/Pixelimage.hx",70,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_84_imageTypeString,"pi_xy._Pixelimage.Pixelimage_Impl_","imageTypeString",0x22b4e8ee,"pi_xy._Pixelimage.Pixelimage_Impl_.imageTypeString","pi_xy/Pixelimage.hx",84,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_93_get_width,"pi_xy._Pixelimage.Pixelimage_Impl_","get_width",0x02e18ae5,"pi_xy._Pixelimage.Pixelimage_Impl_.get_width","pi_xy/Pixelimage.hx",93,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_101_get_height,"pi_xy._Pixelimage.Pixelimage_Impl_","get_height",0x38c77628,"pi_xy._Pixelimage.Pixelimage_Impl_.get_height","pi_xy/Pixelimage.hx",101,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_107_setRelativePosition,"pi_xy._Pixelimage.Pixelimage_Impl_","setRelativePosition",0x104493df,"pi_xy._Pixelimage.Pixelimage_Impl_.setRelativePosition","pi_xy/Pixelimage.hx",107,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_124_get_transparent,"pi_xy._Pixelimage.Pixelimage_Impl_","get_transparent",0xcd427171,"pi_xy._Pixelimage.Pixelimage_Impl_.get_transparent","pi_xy/Pixelimage.hx",124,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_126_set_transparent,"pi_xy._Pixelimage.Pixelimage_Impl_","set_transparent",0xc90dee7d,"pi_xy._Pixelimage.Pixelimage_Impl_.set_transparent","pi_xy/Pixelimage.hx",126,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_137_get_mask,"pi_xy._Pixelimage.Pixelimage_Impl_","get_mask",0x408deced,"pi_xy._Pixelimage.Pixelimage_Impl_.get_mask","pi_xy/Pixelimage.hx",137,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_139_set_mask,"pi_xy._Pixelimage.Pixelimage_Impl_","set_mask",0xeeeb4661,"pi_xy._Pixelimage.Pixelimage_Impl_.set_mask","pi_xy/Pixelimage.hx",139,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_150_set_hasMask,"pi_xy._Pixelimage.Pixelimage_Impl_","set_hasMask",0x978c7311,"pi_xy._Pixelimage.Pixelimage_Impl_.set_hasMask","pi_xy/Pixelimage.hx",150,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_162_get_hasMask,"pi_xy._Pixelimage.Pixelimage_Impl_","get_hasMask",0x8d1f6c05,"pi_xy._Pixelimage.Pixelimage_Impl_.get_hasMask","pi_xy/Pixelimage.hx",162,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_171_get_rectWindow,"pi_xy._Pixelimage.Pixelimage_Impl_","get_rectWindow",0x689aeaf5,"pi_xy._Pixelimage.Pixelimage_Impl_.get_rectWindow","pi_xy/Pixelimage.hx",171,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_180_set_rectWindow,"pi_xy._Pixelimage.Pixelimage_Impl_","set_rectWindow",0x88bad369,"pi_xy._Pixelimage.Pixelimage_Impl_.set_rectWindow","pi_xy/Pixelimage.hx",180,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_204_pos4,"pi_xy._Pixelimage.Pixelimage_Impl_","pos4",0x6789d898,"pi_xy._Pixelimage.Pixelimage_Impl_.pos4","pi_xy/Pixelimage.hx",204,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_210_position,"pi_xy._Pixelimage.Pixelimage_Impl_","position",0x43779121,"pi_xy._Pixelimage.Pixelimage_Impl_.position","pi_xy/Pixelimage.hx",210,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_264_setPixel,"pi_xy._Pixelimage.Pixelimage_Impl_","setPixel",0x49551ffc,"pi_xy._Pixelimage.Pixelimage_Impl_.setPixel","pi_xy/Pixelimage.hx",264,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_271_zeroPixel,"pi_xy._Pixelimage.Pixelimage_Impl_","zeroPixel",0x48c5aec6,"pi_xy._Pixelimage.Pixelimage_Impl_.zeroPixel","pi_xy/Pixelimage.hx",271,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_278_setARGB,"pi_xy._Pixelimage.Pixelimage_Impl_","setARGB",0x78113076,"pi_xy._Pixelimage.Pixelimage_Impl_.setARGB","pi_xy/Pixelimage.hx",278,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_289_getPixel,"pi_xy._Pixelimage.Pixelimage_Impl_","getPixel",0x9af7c688,"pi_xy._Pixelimage.Pixelimage_Impl_.getPixel","pi_xy/Pixelimage.hx",289,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_296_getARGB,"pi_xy._Pixelimage.Pixelimage_Impl_","getARGB",0x850f9f6a,"pi_xy._Pixelimage.Pixelimage_Impl_.getARGB","pi_xy/Pixelimage.hx",296,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_306_set_argbPixel,"pi_xy._Pixelimage.Pixelimage_Impl_","set_argbPixel",0x93b70805,"pi_xy._Pixelimage.Pixelimage_Impl_.set_argbPixel","pi_xy/Pixelimage.hx",306,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_313_argbToPixel,"pi_xy._Pixelimage.Pixelimage_Impl_","argbToPixel",0x85e4d9a7,"pi_xy._Pixelimage.Pixelimage_Impl_.argbToPixel","pi_xy/Pixelimage.hx",313,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_320_channelBlend,"pi_xy._Pixelimage.Pixelimage_Impl_","channelBlend",0x63724106,"pi_xy._Pixelimage.Pixelimage_Impl_.channelBlend","pi_xy/Pixelimage.hx",320,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_330_colorBlend,"pi_xy._Pixelimage.Pixelimage_Impl_","colorBlend",0x1f54fe66,"pi_xy._Pixelimage.Pixelimage_Impl_.colorBlend","pi_xy/Pixelimage.hx",330,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_339_getPixelString,"pi_xy._Pixelimage.Pixelimage_Impl_","getPixelString",0xa53bf979,"pi_xy._Pixelimage.Pixelimage_Impl_.getPixelString","pi_xy/Pixelimage.hx",339,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_344_simpleRect,"pi_xy._Pixelimage.Pixelimage_Impl_","simpleRect",0x44ce7cee,"pi_xy._Pixelimage.Pixelimage_Impl_.simpleRect","pi_xy/Pixelimage.hx",344,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_374_clearRectWindow,"pi_xy._Pixelimage.Pixelimage_Impl_","clearRectWindow",0xc8101ea9,"pi_xy._Pixelimage.Pixelimage_Impl_.clearRectWindow","pi_xy/Pixelimage.hx",374,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_380_clearRect,"pi_xy._Pixelimage.Pixelimage_Impl_","clearRect",0xb43dadd9,"pi_xy._Pixelimage.Pixelimage_Impl_.clearRect","pi_xy/Pixelimage.hx",380,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_416_putPixelImage,"pi_xy._Pixelimage.Pixelimage_Impl_","putPixelImage",0x2ff55f2c,"pi_xy._Pixelimage.Pixelimage_Impl_.putPixelImage","pi_xy/Pixelimage.hx",416,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_435_putPixelImageRect,"pi_xy._Pixelimage.Pixelimage_Impl_","putPixelImageRect",0x6bb2de70,"pi_xy._Pixelimage.Pixelimage_Impl_.putPixelImageRect","pi_xy/Pixelimage.hx",435,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_452_transferClone,"pi_xy._Pixelimage.Pixelimage_Impl_","transferClone",0xa2f154ba,"pi_xy._Pixelimage.Pixelimage_Impl_.transferClone","pi_xy/Pixelimage.hx",452,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_461_transferIn,"pi_xy._Pixelimage.Pixelimage_Impl_","transferIn",0xda8c4e68,"pi_xy._Pixelimage.Pixelimage_Impl_.transferIn","pi_xy/Pixelimage.hx",461,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_472_getBytes,"pi_xy._Pixelimage.Pixelimage_Impl_","getBytes",0x95ec086d,"pi_xy._Pixelimage.Pixelimage_Impl_.getBytes","pi_xy/Pixelimage.hx",472,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_483_fromBytes,"pi_xy._Pixelimage.Pixelimage_Impl_","fromBytes",0x66f66b29,"pi_xy._Pixelimage.Pixelimage_Impl_.fromBytes","pi_xy/Pixelimage.hx",483,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_499_get_raw,"pi_xy._Pixelimage.Pixelimage_Impl_","get_raw",0x98fc6507,"pi_xy._Pixelimage.Pixelimage_Impl_.get_raw","pi_xy/Pixelimage.hx",499,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_505_get_transform,"pi_xy._Pixelimage.Pixelimage_Impl_","get_transform",0xee675dcb,"pi_xy._Pixelimage.Pixelimage_Impl_.get_transform","pi_xy/Pixelimage.hx",505,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_511_get_fillShape,"pi_xy._Pixelimage.Pixelimage_Impl_","get_fillShape",0xf39839fd,"pi_xy._Pixelimage.Pixelimage_Impl_.get_fillShape","pi_xy/Pixelimage.hx",511,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_517_get_softShape,"pi_xy._Pixelimage.Pixelimage_Impl_","get_softShape",0x3a635636,"pi_xy._Pixelimage.Pixelimage_Impl_.get_softShape","pi_xy/Pixelimage.hx",517,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_523_get_lineShape,"pi_xy._Pixelimage.Pixelimage_Impl_","get_lineShape",0x6bec16ec,"pi_xy._Pixelimage.Pixelimage_Impl_.get_lineShape","pi_xy/Pixelimage.hx",523,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_529_get_tileShape,"pi_xy._Pixelimage.Pixelimage_Impl_","get_tileShape",0xb04c7172,"pi_xy._Pixelimage.Pixelimage_Impl_.get_tileShape","pi_xy/Pixelimage.hx",529,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_535_get_imageShape,"pi_xy._Pixelimage.Pixelimage_Impl_","get_imageShape",0x98c0cc87,"pi_xy._Pixelimage.Pixelimage_Impl_.get_imageShape","pi_xy/Pixelimage.hx",535,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_541_get_gradientShape,"pi_xy._Pixelimage.Pixelimage_Impl_","get_gradientShape",0x3fa05ef0,"pi_xy._Pixelimage.Pixelimage_Impl_.get_gradientShape","pi_xy/Pixelimage.hx",541,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_547_get_pattern,"pi_xy._Pixelimage.Pixelimage_Impl_","get_pattern",0x86fc10ef,"pi_xy._Pixelimage.Pixelimage_Impl_.get_pattern","pi_xy/Pixelimage.hx",547,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_553_get_convolution,"pi_xy._Pixelimage.Pixelimage_Impl_","get_convolution",0xc3099537,"pi_xy._Pixelimage.Pixelimage_Impl_.get_convolution","pi_xy/Pixelimage.hx",553,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_559_get_colorform,"pi_xy._Pixelimage.Pixelimage_Impl_","get_colorform",0xdd28f086,"pi_xy._Pixelimage.Pixelimage_Impl_.get_colorform","pi_xy/Pixelimage.hx",559,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_565_get_rectanglePad,"pi_xy._Pixelimage.Pixelimage_Impl_","get_rectanglePad",0xc942d165,"pi_xy._Pixelimage.Pixelimage_Impl_.get_rectanglePad","pi_xy/Pixelimage.hx",565,0x6bc9d621)
HX_LOCAL_STACK_FRAME(_hx_pos_11ce842fed00cba7_578_get_png,"pi_xy._Pixelimage.Pixelimage_Impl_","get_png",0x98faebc8,"pi_xy._Pixelimage.Pixelimage_Impl_.get_png","pi_xy/Pixelimage.hx",578,0x6bc9d621)
namespace pi_xy{
namespace _Pixelimage{

void Pixelimage_Impl__obj::__construct() { }

Dynamic Pixelimage_Impl__obj::__CreateEmpty() { return new Pixelimage_Impl__obj; }

void *Pixelimage_Impl__obj::_hx_vtable = 0;

Dynamic Pixelimage_Impl__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Pixelimage_Impl__obj > _hx_result = new Pixelimage_Impl__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Pixelimage_Impl__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x5c591c26;
}

int Pixelimage_Impl__obj::get_defaultType( ::pi_xy::ImageStruct this1){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_43_get_defaultType)
HXDLIN(  43)		return ::pi_xy::ImageStruct_obj::defaultType;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pixelimage_Impl__obj,get_defaultType,return )

int Pixelimage_Impl__obj::set_defaultType( ::pi_xy::ImageStruct this1,int v){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_46_set_defaultType)
HXLINE(  47)		::pi_xy::ImageStruct_obj::defaultType = v;
HXLINE(  48)		return v;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Pixelimage_Impl__obj,set_defaultType,return )

 ::pi_xy::ImageStruct Pixelimage_Impl__obj::_new(int width,int height, ::Dynamic imageType){
            	HX_GC_STACKFRAME(&_hx_pos_11ce842fed00cba7_51__new)
HXDLIN(  51)		 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXLINE(  53)		if (::hx::IsNull( imageType )) {
HXLINE(  54)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXLINE(  55)		::Dynamic _hx_tmp;
HXDLIN(  55)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE(  55)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  55)				 ::iterMagic::BytesImg b = byt;
HXDLIN(  55)				{
HXLINE(  55)					b->width = width;
HXDLIN(  55)					b->height = height;
HXDLIN(  55)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  55)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  55)					{
HXLINE(  55)						int len = b->length;
HXDLIN(  55)						int w = 0;
HXDLIN(  55)						{
HXLINE(  55)							int _g = 0;
HXDLIN(  55)							int _g1 = b->height;
HXDLIN(  55)							while((_g < _g1)){
HXLINE(  55)								_g = (_g + 1);
HXDLIN(  55)								int y = (_g - 1);
HXDLIN(  55)								{
HXLINE(  55)									int _g2 = 0;
HXDLIN(  55)									int _g3 = b->width;
HXDLIN(  55)									while((_g2 < _g3)){
HXLINE(  55)										_g2 = (_g2 + 1);
HXDLIN(  55)										int x = (_g2 - 1);
HXDLIN(  55)										{
HXLINE(  55)											w = (w + 1);
HXDLIN(  55)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  55)										{
HXLINE(  55)											w = (w + 1);
HXDLIN(  55)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  55)										{
HXLINE(  55)											w = (w + 1);
HXDLIN(  55)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  55)										{
HXLINE(  55)											w = (w + 1);
HXDLIN(  55)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  55)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXLINE(  55)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  55)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  55)				{
HXLINE(  55)					a->width = width;
HXDLIN(  55)					a->height = height;
HXDLIN(  55)					a->data = ::Array_obj< int >::__new(0);
HXDLIN(  55)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  55)					{
HXLINE(  55)						int _g4 = 0;
HXDLIN(  55)						int _g5 = a->length;
HXDLIN(  55)						while((_g4 < _g5)){
HXLINE(  55)							_g4 = (_g4 + 1);
HXDLIN(  55)							int i = (_g4 - 1);
HXDLIN(  55)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN(  55)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXLINE(  55)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  55)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  55)				{
HXLINE(  55)					b1->width = width;
HXDLIN(  55)					b1->height = height;
HXDLIN(  55)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  55)					int size = (b1->length * 4);
HXDLIN(  55)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  55)					{
HXLINE(  55)						int _g6 = 0;
HXDLIN(  55)						int _g7 = b1->length;
HXDLIN(  55)						while((_g6 < _g7)){
HXLINE(  55)							_g6 = (_g6 + 1);
HXDLIN(  55)							int i1 = (_g6 - 1);
HXDLIN(  55)							{
HXLINE(  55)								 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN(  55)								bool _hx_tmp1;
HXDLIN(  55)								if ((i1 >= 0)) {
HXLINE(  55)									_hx_tmp1 = (i1 < (this2->byteLength >> 2));
            								}
            								else {
HXLINE(  55)									_hx_tmp1 = false;
            								}
HXDLIN(  55)								if (_hx_tmp1) {
HXLINE(  55)									 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  55)									int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN(  55)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  55)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  55)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  55)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(  55)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXLINE(  55)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  55)				 ::iterMagic::VecIntImg v = vec;
HXDLIN(  55)				{
HXLINE(  55)					v->width = width;
HXDLIN(  55)					v->height = height;
HXDLIN(  55)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  55)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  55)					{
HXLINE(  55)						int _g8 = 0;
HXDLIN(  55)						int _g9 = v->length;
HXDLIN(  55)						while((_g8 < _g9)){
HXLINE(  55)							_g8 = (_g8 + 1);
HXDLIN(  55)							int i2 = (_g8 - 1);
HXDLIN(  55)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN(  55)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXLINE(  55)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  55)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  55)				{
HXLINE(  55)					b2->width = width;
HXDLIN(  55)					b2->height = height;
HXDLIN(  55)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  55)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  55)					{
HXLINE(  55)						int len1 = b2->length;
HXDLIN(  55)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  55)						if (::hx::IsNull( d->head )) {
HXLINE(  55)							int _g10 = 0;
HXDLIN(  55)							int _g11 = len1;
HXDLIN(  55)							while((_g10 < _g11)){
HXLINE(  55)								_g10 = (_g10 + 1);
HXDLIN(  55)								int i3 = (_g10 - 1);
HXDLIN(  55)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE(  55)							int _g12 = 0;
HXDLIN(  55)							int _g13 = len1;
HXDLIN(  55)							while((_g12 < _g13)){
HXLINE(  55)								_g12 = (_g12 + 1);
HXDLIN(  55)								int i4 = (_g12 - 1);
HXDLIN(  55)								{
HXLINE(  55)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  55)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  55)									{
HXLINE(  55)										int _g14 = 0;
HXDLIN(  55)										int _g15 = i4;
HXDLIN(  55)										while((_g14 < _g15)){
HXLINE(  55)											_g14 = (_g14 + 1);
HXDLIN(  55)											int i5 = (_g14 - 1);
HXDLIN(  55)											prev = l;
HXDLIN(  55)											l = l->next;
            										}
            									}
HXDLIN(  55)									if (::hx::IsNull( prev )) {
HXLINE(  55)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  55)										l = null();
            									}
            									else {
HXLINE(  55)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  55)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  55)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN(  55)		this1->image = _hx_tmp;
HXLINE(  56)		this1->width = width;
HXLINE(  57)		this1->height = height;
HXLINE(  58)		this1->imageType = ( (int)(imageType) );
HXLINE(  51)		return this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Pixelimage_Impl__obj,_new,return )

::Dynamic Pixelimage_Impl__obj::get_image( ::pi_xy::ImageStruct this1){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_70_get_image)
HXDLIN(  70)		return this1->image;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pixelimage_Impl__obj,get_image,return )

 ::Dynamic Pixelimage_Impl__obj::imageTypeString( ::pi_xy::ImageStruct this1){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_84_imageTypeString)
HXDLIN(  84)		::Dynamic this2 = this1->image;
HXDLIN(  84)		 ::Dynamic v;
HXDLIN(  84)		if (::Std_obj::isOfType(this2,::hx::ClassOf< ::iterMagic::ArrIntImg >())) {
HXDLIN(  84)			v = 1;
            		}
            		else {
HXDLIN(  84)			if (::Std_obj::isOfType(this2,::hx::ClassOf< ::iterMagic::VecIntImg >())) {
HXDLIN(  84)				v = 3;
            			}
            			else {
HXDLIN(  84)				if (::Std_obj::isOfType(this2,::hx::ClassOf< ::iterMagic::BytesImg >())) {
HXDLIN(  84)					v = 0;
            				}
            				else {
HXDLIN(  84)					if (::Std_obj::isOfType(this2,::hx::ClassOf< ::iterMagic::U32ArrImg >())) {
HXDLIN(  84)						v = 2;
            					}
            					else {
HXDLIN(  84)						if (::Std_obj::isOfType(this2,::hx::ClassOf< ::iterMagic::StackIntImg >())) {
HXDLIN(  84)							v = 4;
            						}
            						else {
HXDLIN(  84)							v = null();
            						}
            					}
            				}
            			}
            		}
HXDLIN(  84)		return v;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pixelimage_Impl__obj,imageTypeString,return )

int Pixelimage_Impl__obj::get_width( ::pi_xy::ImageStruct this1){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_93_get_width)
HXDLIN(  93)		return this1->width;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pixelimage_Impl__obj,get_width,return )

int Pixelimage_Impl__obj::get_height( ::pi_xy::ImageStruct this1){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_101_get_height)
HXDLIN( 101)		return this1->height;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pixelimage_Impl__obj,get_height,return )

void Pixelimage_Impl__obj::setRelativePosition( ::pi_xy::ImageStruct this1,int x,int y, ::Dynamic __o_update){
            		 ::Dynamic update = __o_update;
            		if (::hx::IsNull(__o_update)) update = false;
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_107_setRelativePosition)
HXLINE( 108)		this1->useVirtualPos = true;
HXLINE( 109)		if ((x < 0)) {
HXLINE( 110)			x = 0;
            		}
HXLINE( 111)		if ((y < 0)) {
HXLINE( 112)			y = 0;
            		}
HXLINE( 113)		this1->virtualX = ( (Float)(x) );
HXLINE( 114)		this1->virtualY = ( (Float)(y) );
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Pixelimage_Impl__obj,setRelativePosition,(void))

bool Pixelimage_Impl__obj::get_transparent( ::pi_xy::ImageStruct this1){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_124_get_transparent)
HXDLIN( 124)		return this1->transparent;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pixelimage_Impl__obj,get_transparent,return )

bool Pixelimage_Impl__obj::set_transparent( ::pi_xy::ImageStruct this1,bool v){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_126_set_transparent)
HXLINE( 127)		this1->transparent = v;
HXLINE( 128)		return v;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Pixelimage_Impl__obj,set_transparent,return )

 ::pi_xy::ImageStruct Pixelimage_Impl__obj::get_mask( ::pi_xy::ImageStruct this1){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_137_get_mask)
HXDLIN( 137)		return this1->mask;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pixelimage_Impl__obj,get_mask,return )

 ::pi_xy::ImageStruct Pixelimage_Impl__obj::set_mask( ::pi_xy::ImageStruct this1, ::pi_xy::ImageStruct v){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_139_set_mask)
HXLINE( 140)		this1->useMask = true;
HXLINE( 141)		this1->mask = v;
HXLINE( 142)		return v;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Pixelimage_Impl__obj,set_mask,return )

bool Pixelimage_Impl__obj::set_hasMask( ::pi_xy::ImageStruct this1,bool v){
            	HX_GC_STACKFRAME(&_hx_pos_11ce842fed00cba7_150_set_hasMask)
HXLINE( 151)		bool _hx_tmp;
HXDLIN( 151)		if (::hx::IsNull( this1->mask )) {
HXLINE( 151)			_hx_tmp = (v == true);
            		}
            		else {
HXLINE( 151)			_hx_tmp = false;
            		}
HXDLIN( 151)		if (_hx_tmp) {
HXLINE( 152)			int width = this1->width;
HXDLIN( 152)			int height = this1->height;
HXDLIN( 152)			 ::Dynamic imageType = null();
HXDLIN( 152)			 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 152)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 152)			::Dynamic _hx_tmp1;
HXDLIN( 152)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXLINE( 152)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 152)					 ::iterMagic::BytesImg b = byt;
HXDLIN( 152)					{
HXLINE( 152)						b->width = width;
HXDLIN( 152)						b->height = height;
HXDLIN( 152)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 152)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 152)						{
HXLINE( 152)							int len = b->length;
HXDLIN( 152)							int w = 0;
HXDLIN( 152)							{
HXLINE( 152)								int _g = 0;
HXDLIN( 152)								int _g1 = b->height;
HXDLIN( 152)								while((_g < _g1)){
HXLINE( 152)									_g = (_g + 1);
HXDLIN( 152)									int y = (_g - 1);
HXDLIN( 152)									{
HXLINE( 152)										int _g2 = 0;
HXDLIN( 152)										int _g3 = b->width;
HXDLIN( 152)										while((_g2 < _g3)){
HXLINE( 152)											_g2 = (_g2 + 1);
HXDLIN( 152)											int x = (_g2 - 1);
HXDLIN( 152)											{
HXLINE( 152)												w = (w + 1);
HXDLIN( 152)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 152)											{
HXLINE( 152)												w = (w + 1);
HXDLIN( 152)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 152)											{
HXLINE( 152)												w = (w + 1);
HXDLIN( 152)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 152)											{
HXLINE( 152)												w = (w + 1);
HXDLIN( 152)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 152)					_hx_tmp1 = b;
            				}
            				break;
            				case (int)1: {
HXLINE( 152)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 152)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 152)					{
HXLINE( 152)						a->width = width;
HXDLIN( 152)						a->height = height;
HXDLIN( 152)						a->data = ::Array_obj< int >::__new(0);
HXDLIN( 152)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 152)						{
HXLINE( 152)							int _g4 = 0;
HXDLIN( 152)							int _g5 = a->length;
HXDLIN( 152)							while((_g4 < _g5)){
HXLINE( 152)								_g4 = (_g4 + 1);
HXDLIN( 152)								int i = (_g4 - 1);
HXDLIN( 152)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN( 152)					_hx_tmp1 = a;
            				}
            				break;
            				case (int)2: {
HXLINE( 152)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 152)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 152)					{
HXLINE( 152)						b1->width = width;
HXDLIN( 152)						b1->height = height;
HXDLIN( 152)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 152)						int size = (b1->length * 4);
HXDLIN( 152)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 152)						{
HXLINE( 152)							int _g6 = 0;
HXDLIN( 152)							int _g7 = b1->length;
HXDLIN( 152)							while((_g6 < _g7)){
HXLINE( 152)								_g6 = (_g6 + 1);
HXDLIN( 152)								int i1 = (_g6 - 1);
HXDLIN( 152)								{
HXLINE( 152)									 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 152)									bool _hx_tmp2;
HXDLIN( 152)									if ((i1 >= 0)) {
HXLINE( 152)										_hx_tmp2 = (i1 < (this3->byteLength >> 2));
            									}
            									else {
HXLINE( 152)										_hx_tmp2 = false;
            									}
HXDLIN( 152)									if (_hx_tmp2) {
HXLINE( 152)										 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 152)										int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 152)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 152)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 152)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 152)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 152)					_hx_tmp1 = b1;
            				}
            				break;
            				case (int)3: {
HXLINE( 152)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 152)					 ::iterMagic::VecIntImg v1 = vec;
HXDLIN( 152)					{
HXLINE( 152)						v1->width = width;
HXDLIN( 152)						v1->height = height;
HXDLIN( 152)						v1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 152)						v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN( 152)						{
HXLINE( 152)							int _g8 = 0;
HXDLIN( 152)							int _g9 = v1->length;
HXDLIN( 152)							while((_g8 < _g9)){
HXLINE( 152)								_g8 = (_g8 + 1);
HXDLIN( 152)								int i2 = (_g8 - 1);
HXDLIN( 152)								v1->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN( 152)					_hx_tmp1 = v1;
            				}
            				break;
            				case (int)4: {
HXLINE( 152)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 152)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 152)					{
HXLINE( 152)						b2->width = width;
HXDLIN( 152)						b2->height = height;
HXDLIN( 152)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 152)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 152)						{
HXLINE( 152)							int len1 = b2->length;
HXDLIN( 152)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 152)							if (::hx::IsNull( d->head )) {
HXLINE( 152)								int _g10 = 0;
HXDLIN( 152)								int _g11 = len1;
HXDLIN( 152)								while((_g10 < _g11)){
HXLINE( 152)									_g10 = (_g10 + 1);
HXDLIN( 152)									int i3 = (_g10 - 1);
HXDLIN( 152)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXLINE( 152)								int _g12 = 0;
HXDLIN( 152)								int _g13 = len1;
HXDLIN( 152)								while((_g12 < _g13)){
HXLINE( 152)									_g12 = (_g12 + 1);
HXDLIN( 152)									int i4 = (_g12 - 1);
HXDLIN( 152)									{
HXLINE( 152)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 152)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 152)										{
HXLINE( 152)											int _g14 = 0;
HXDLIN( 152)											int _g15 = i4;
HXDLIN( 152)											while((_g14 < _g15)){
HXLINE( 152)												_g14 = (_g14 + 1);
HXDLIN( 152)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE( 152)										if (::hx::IsNull( prev )) {
HXLINE( 152)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 152)											l = null();
            										}
            										else {
HXLINE( 152)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 152)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 152)					_hx_tmp1 = b2;
            				}
            				break;
            			}
HXDLIN( 152)			this2->image = _hx_tmp1;
HXDLIN( 152)			this2->width = width;
HXDLIN( 152)			this2->height = height;
HXDLIN( 152)			this2->imageType = ( (int)(imageType) );
HXDLIN( 152)			this1->mask = this2;
HXLINE( 153)			this1->mask->transparent = false;
HXLINE( 155)			{
HXLINE( 155)				 ::pi_xy::ImageStruct this4 = this1->mask;
HXDLIN( 155)				Float h = ( (Float)(this1->height) );
HXDLIN( 155)				int r_x = 0;
HXDLIN( 155)				int r_y = 0;
HXDLIN( 155)				int r_w = ::Std_obj::_hx_int(( (Float)(this1->width) ));
HXDLIN( 155)				int r_h = ::Std_obj::_hx_int(h);
HXDLIN( 155)				int xmax = ((r_x + r_w) + 1);
HXDLIN( 155)				int ymax = ((r_y + r_h) + 1);
HXDLIN( 155)				int ii_min = r_x;
HXDLIN( 155)				int ii_max = xmax;
HXDLIN( 155)				int xRange__start = ii_min;
HXDLIN( 155)				int xRange__max = ii_max;
HXDLIN( 155)				int ii_min1 = r_y;
HXDLIN( 155)				int ii_max1 = ymax;
HXDLIN( 155)				int yRange__start = ii_min1;
HXDLIN( 155)				int yRange__max = ii_max1;
HXDLIN( 155)				int range_x = xRange__start;
HXDLIN( 155)				int range_y = (yRange__start - 1);
HXDLIN( 155)				int range_xReset = range_x;
HXDLIN( 155)				int range_yReset = range_y;
HXDLIN( 155)				int range_xMax = (xRange__max - 2);
HXDLIN( 155)				int range_yMax = (yRange__max - 2);
HXDLIN( 155)				int _this_min = 0;
HXDLIN( 155)				int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXDLIN( 155)				while((_this_min < _this_max)){
HXLINE( 155)					_this_min = (_this_min + 1);
HXDLIN( 155)					int i6 = (_this_min - 1);
HXDLIN( 155)					if ((range_y > range_yMax)) {
HXLINE( 155)						range_y = range_yReset;
HXDLIN( 155)						range_x = (range_x + 1);
            					}
HXDLIN( 155)					range_y = (range_y + 1);
HXDLIN( 155)					int i7 = i6;
HXDLIN( 155)					{
HXLINE( 155)						int x1 = range_x;
HXDLIN( 155)						int y1 = range_y;
HXDLIN( 155)						int c = 0;
HXDLIN( 155)						bool _hx_tmp3;
HXDLIN( 155)						if ((((c >> 24) & 255) < 254)) {
HXLINE( 155)							_hx_tmp3 = this4->transparent;
            						}
            						else {
HXLINE( 155)							_hx_tmp3 = false;
            						}
HXDLIN( 155)						if (_hx_tmp3) {
HXLINE( 155)							int location;
HXDLIN( 155)							if (this4->useVirtualPos) {
HXLINE( 155)								location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this4->virtualY) * ( (Float)(this4->width) )) + x1) - this4->virtualX));
            							}
            							else {
HXLINE( 155)								location = ::Std_obj::_hx_int(( (Float)(((y1 * this4->width) + x1)) ));
            							}
HXDLIN( 155)							int this5 = ::iterMagic::Iimg_obj::get(this4->image,location);
HXDLIN( 155)							int this6;
HXDLIN( 155)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 155)								this6 = ((((((this5 >> 24) & 255) << 24) | ((this5 & 255) << 16)) | (((this5 >> 8) & 255) << 8)) | ((this5 >> 16) & 255));
            							}
            							else {
HXLINE( 155)								this6 = this5;
            							}
HXDLIN( 155)							Float a1;
HXDLIN( 155)							int this7 = ((this6 >> 24) & 255);
HXDLIN( 155)							if ((this7 == 0)) {
HXLINE( 155)								a1 = ((Float)0.);
            							}
            							else {
HXLINE( 155)								a1 = (( (Float)(this7) ) / ( (Float)(255) ));
            							}
HXDLIN( 155)							Float r1;
HXDLIN( 155)							int this8 = ((this6 >> 16) & 255);
HXDLIN( 155)							if ((this8 == 0)) {
HXLINE( 155)								r1 = ((Float)0.);
            							}
            							else {
HXLINE( 155)								r1 = (( (Float)(this8) ) / ( (Float)(255) ));
            							}
HXDLIN( 155)							Float g1;
HXDLIN( 155)							int this9 = ((this6 >> 8) & 255);
HXDLIN( 155)							if ((this9 == 0)) {
HXLINE( 155)								g1 = ((Float)0.);
            							}
            							else {
HXLINE( 155)								g1 = (( (Float)(this9) ) / ( (Float)(255) ));
            							}
HXDLIN( 155)							Float b11;
HXDLIN( 155)							int this10 = (this6 & 255);
HXDLIN( 155)							if ((this10 == 0)) {
HXLINE( 155)								b11 = ((Float)0.);
            							}
            							else {
HXLINE( 155)								b11 = (( (Float)(this10) ) / ( (Float)(255) ));
            							}
HXDLIN( 155)							Float a2;
HXDLIN( 155)							int this11 = ((0 >> 24) & 255);
HXDLIN( 155)							if ((this11 == 0)) {
HXLINE( 155)								a2 = ((Float)0.);
            							}
            							else {
HXLINE( 155)								a2 = (( (Float)(this11) ) / ( (Float)(255) ));
            							}
HXDLIN( 155)							Float r2;
HXDLIN( 155)							int this12 = ((0 >> 16) & 255);
HXDLIN( 155)							if ((this12 == 0)) {
HXLINE( 155)								r2 = ((Float)0.);
            							}
            							else {
HXLINE( 155)								r2 = (( (Float)(this12) ) / ( (Float)(255) ));
            							}
HXDLIN( 155)							Float g2;
HXDLIN( 155)							int this13 = ((0 >> 8) & 255);
HXDLIN( 155)							if ((this13 == 0)) {
HXLINE( 155)								g2 = ((Float)0.);
            							}
            							else {
HXLINE( 155)								g2 = (( (Float)(this13) ) / ( (Float)(255) ));
            							}
HXDLIN( 155)							Float b21;
HXDLIN( 155)							int this14 = (0 & 255);
HXDLIN( 155)							if ((this14 == 0)) {
HXLINE( 155)								b21 = ((Float)0.);
            							}
            							else {
HXLINE( 155)								b21 = (( (Float)(this14) ) / ( (Float)(255) ));
            							}
HXDLIN( 155)							Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 155)							int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 155)							int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 155)							int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 155)							int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 155)							int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 155)							{
HXLINE( 155)								int _hx_tmp4;
HXDLIN( 155)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 155)									_hx_tmp4 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            								}
            								else {
HXLINE( 155)									_hx_tmp4 = blended;
            								}
HXDLIN( 155)								::iterMagic::Iimg_obj::set(this4->image,location,_hx_tmp4);
            							}
            						}
            						else {
HXLINE( 155)							::Dynamic this15 = this4->image;
HXDLIN( 155)							int index;
HXDLIN( 155)							if (this4->useVirtualPos) {
HXLINE( 155)								index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this4->virtualY) * ( (Float)(this4->width) )) + x1) - this4->virtualX));
            							}
            							else {
HXLINE( 155)								index = ::Std_obj::_hx_int(( (Float)(((y1 * this4->width) + x1)) ));
            							}
HXDLIN( 155)							int _hx_tmp5;
HXDLIN( 155)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 155)								_hx_tmp5 = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE( 155)								_hx_tmp5 = c;
            							}
HXDLIN( 155)							::iterMagic::Iimg_obj::set(this15,index,_hx_tmp5);
            						}
            					}
            				}
            			}
            		}
HXLINE( 157)		this1->useMask = v;
HXLINE( 158)		return v;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Pixelimage_Impl__obj,set_hasMask,return )

bool Pixelimage_Impl__obj::get_hasMask( ::pi_xy::ImageStruct this1){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_162_get_hasMask)
HXDLIN( 162)		return this1->useMask;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pixelimage_Impl__obj,get_hasMask,return )

 ::pi_xy::algo::RectangleWindow Pixelimage_Impl__obj::get_rectWindow( ::pi_xy::ImageStruct this1){
            	HX_GC_STACKFRAME(&_hx_pos_11ce842fed00cba7_171_get_rectWindow)
HXDLIN( 171)		return  ::pi_xy::algo::RectangleWindow_obj::__alloc( HX_CTX ,( (Float)(0) ),( (Float)(0) ),( (Float)(this1->width) ),( (Float)(this1->height) ));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pixelimage_Impl__obj,get_rectWindow,return )

 ::pi_xy::algo::RectangleWindow Pixelimage_Impl__obj::set_rectWindow( ::pi_xy::ImageStruct this1, ::pi_xy::algo::RectangleWindow r){
            	HX_GC_STACKFRAME(&_hx_pos_11ce842fed00cba7_180_set_rectWindow)
HXLINE( 181)		if ((r->x != ((Float)0.))) {
HXLINE( 182)			HX_STACK_DO_THROW(HX_("rectangle window must have x = 0",85,68,06,ea));
            		}
HXLINE( 183)		if ((r->y != ((Float)0.))) {
HXLINE( 184)			HX_STACK_DO_THROW(HX_("rectangle window must have y = 0",06,fd,6c,7d));
            		}
HXLINE( 185)		bool _hx_tmp;
HXDLIN( 185)		if ((r->width == this1->width)) {
HXLINE( 185)			_hx_tmp = (r->height == this1->height);
            		}
            		else {
HXLINE( 185)			_hx_tmp = false;
            		}
HXDLIN( 185)		if (!(_hx_tmp)) {
HXLINE( 188)			int sx = ::Std_obj::_hx_int((r->width / ( (Float)(this1->width) )));
HXLINE( 189)			int sy = ::Std_obj::_hx_int((r->height / ( (Float)(this1->height) )));
HXLINE( 190)			bool transparent = this1->transparent;
HXDLIN( 190)			 ::pi_xy::ImageStruct thisImage = this1;
HXDLIN( 190)			int scaleW = ::Std_obj::_hx_int(( (Float)(sx) ));
HXDLIN( 190)			int scaleH = ::Std_obj::_hx_int(( (Float)(sy) ));
HXDLIN( 190)			bool ifScaleUpInt;
HXDLIN( 190)			bool ifScaleUpInt1;
HXDLIN( 190)			bool ifScaleUpInt2;
HXDLIN( 190)			if ((scaleW == sx)) {
HXLINE( 190)				ifScaleUpInt2 = (sx > ((Float)0.));
            			}
            			else {
HXLINE( 190)				ifScaleUpInt2 = false;
            			}
HXDLIN( 190)			if (ifScaleUpInt2) {
HXLINE( 190)				ifScaleUpInt1 = (scaleH == sy);
            			}
            			else {
HXLINE( 190)				ifScaleUpInt1 = false;
            			}
HXDLIN( 190)			if (ifScaleUpInt1) {
HXLINE( 190)				ifScaleUpInt = (sy > ((Float)0.));
            			}
            			else {
HXLINE( 190)				ifScaleUpInt = false;
            			}
HXDLIN( 190)			 ::pi_xy::ImageStruct pixelImage;
HXDLIN( 190)			if (ifScaleUpInt) {
HXLINE( 190)				bool includeMask = false;
HXDLIN( 190)				 ::pi_xy::ImageStruct thisImage1 = thisImage;
HXDLIN( 190)				int p = 0;
HXDLIN( 190)				int xx = p;
HXDLIN( 190)				int q = 0;
HXDLIN( 190)				int wNew = ::Std_obj::_hx_int(( (Float)((thisImage1->width * scaleW)) ));
HXDLIN( 190)				int hNew = ::Std_obj::_hx_int(( (Float)((thisImage1->height * scaleH)) ));
HXDLIN( 190)				 ::Dynamic imageType = null();
HXDLIN( 190)				 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 190)				if (::hx::IsNull( imageType )) {
HXLINE(  54)					imageType = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 190)				::Dynamic pixelImage1;
HXDLIN( 190)				switch((int)(( (int)(imageType) ))){
            					case (int)0: {
HXLINE( 190)						 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 190)						 ::iterMagic::BytesImg b = byt;
HXDLIN( 190)						{
HXLINE( 190)							b->width = wNew;
HXDLIN( 190)							b->height = hNew;
HXDLIN( 190)							b->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN( 190)							b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 190)							{
HXLINE( 190)								int len = b->length;
HXDLIN( 190)								int w = 0;
HXDLIN( 190)								{
HXLINE( 190)									int _g = 0;
HXDLIN( 190)									int _g1 = b->height;
HXDLIN( 190)									while((_g < _g1)){
HXLINE( 190)										_g = (_g + 1);
HXDLIN( 190)										int y = (_g - 1);
HXDLIN( 190)										{
HXLINE( 190)											int _g2 = 0;
HXDLIN( 190)											int _g3 = b->width;
HXDLIN( 190)											while((_g2 < _g3)){
HXLINE( 190)												_g2 = (_g2 + 1);
HXDLIN( 190)												int x = (_g2 - 1);
HXDLIN( 190)												{
HXLINE( 190)													w = (w + 1);
HXDLIN( 190)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 190)												{
HXLINE( 190)													w = (w + 1);
HXDLIN( 190)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 190)												{
HXLINE( 190)													w = (w + 1);
HXDLIN( 190)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 190)												{
HXLINE( 190)													w = (w + 1);
HXDLIN( 190)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 190)						pixelImage1 = b;
            					}
            					break;
            					case (int)1: {
HXLINE( 190)						 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 190)						 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 190)						{
HXLINE( 190)							a->width = wNew;
HXDLIN( 190)							a->height = hNew;
HXDLIN( 190)							a->data = ::Array_obj< int >::__new(0);
HXDLIN( 190)							a->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN( 190)							{
HXLINE( 190)								int _g4 = 0;
HXDLIN( 190)								int _g5 = a->length;
HXDLIN( 190)								while((_g4 < _g5)){
HXLINE( 190)									_g4 = (_g4 + 1);
HXDLIN( 190)									int i = (_g4 - 1);
HXDLIN( 190)									a->data[i] = 0;
            								}
            							}
            						}
HXDLIN( 190)						pixelImage1 = a;
            					}
            					break;
            					case (int)2: {
HXLINE( 190)						 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 190)						 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 190)						{
HXLINE( 190)							b1->width = wNew;
HXDLIN( 190)							b1->height = hNew;
HXDLIN( 190)							b1->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN( 190)							int size = (b1->length * 4);
HXDLIN( 190)							b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 190)							{
HXLINE( 190)								int _g6 = 0;
HXDLIN( 190)								int _g7 = b1->length;
HXDLIN( 190)								while((_g6 < _g7)){
HXLINE( 190)									_g6 = (_g6 + 1);
HXDLIN( 190)									int i1 = (_g6 - 1);
HXDLIN( 190)									{
HXLINE( 190)										 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 190)										bool pixelImage2;
HXDLIN( 190)										if ((i1 >= 0)) {
HXLINE( 190)											pixelImage2 = (i1 < (this3->byteLength >> 2));
            										}
            										else {
HXLINE( 190)											pixelImage2 = false;
            										}
HXDLIN( 190)										if (pixelImage2) {
HXLINE( 190)											 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 190)											int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 190)											_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 190)											_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 190)											_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 190)											_this->b[(pos + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 190)						pixelImage1 = b1;
            					}
            					break;
            					case (int)3: {
HXLINE( 190)						 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 190)						 ::iterMagic::VecIntImg v = vec;
HXDLIN( 190)						{
HXLINE( 190)							v->width = wNew;
HXDLIN( 190)							v->height = hNew;
HXDLIN( 190)							v->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN( 190)							v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 190)							{
HXLINE( 190)								int _g8 = 0;
HXDLIN( 190)								int _g9 = v->length;
HXDLIN( 190)								while((_g8 < _g9)){
HXLINE( 190)									_g8 = (_g8 + 1);
HXDLIN( 190)									int i2 = (_g8 - 1);
HXDLIN( 190)									v->data->__unsafe_set(i2,0);
            								}
            							}
            						}
HXDLIN( 190)						pixelImage1 = v;
            					}
            					break;
            					case (int)4: {
HXLINE( 190)						 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 190)						 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 190)						{
HXLINE( 190)							b2->width = wNew;
HXDLIN( 190)							b2->height = hNew;
HXDLIN( 190)							b2->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN( 190)							b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 190)							{
HXLINE( 190)								int len1 = b2->length;
HXDLIN( 190)								 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 190)								if (::hx::IsNull( d->head )) {
HXLINE( 190)									int _g10 = 0;
HXDLIN( 190)									int _g11 = len1;
HXDLIN( 190)									while((_g10 < _g11)){
HXLINE( 190)										_g10 = (_g10 + 1);
HXDLIN( 190)										int i3 = (_g10 - 1);
HXDLIN( 190)										d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            									}
            								}
            								else {
HXLINE( 190)									int _g12 = 0;
HXDLIN( 190)									int _g13 = len1;
HXDLIN( 190)									while((_g12 < _g13)){
HXLINE( 190)										_g12 = (_g12 + 1);
HXDLIN( 190)										int i4 = (_g12 - 1);
HXDLIN( 190)										{
HXLINE( 190)											 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 190)											 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 190)											{
HXLINE( 190)												int _g14 = 0;
HXDLIN( 190)												int _g15 = i4;
HXDLIN( 190)												while((_g14 < _g15)){
HXLINE( 190)													_g14 = (_g14 + 1);
HXDLIN( 190)													int i5 = (_g14 - 1);
HXLINE( 345)													prev = l;
HXLINE( 346)													l = l->next;
            												}
            											}
HXLINE( 190)											if (::hx::IsNull( prev )) {
HXLINE( 190)												b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 190)												l = null();
            											}
            											else {
HXLINE( 190)												prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 190)												l = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 190)						pixelImage1 = b2;
            					}
            					break;
            				}
HXDLIN( 190)				this2->image = pixelImage1;
HXDLIN( 190)				this2->width = wNew;
HXDLIN( 190)				this2->height = hNew;
HXDLIN( 190)				this2->imageType = ( (int)(imageType) );
HXDLIN( 190)				 ::pi_xy::ImageStruct nextImage = this2;
HXDLIN( 190)				int maxX = wNew;
HXDLIN( 190)				int maxY = hNew;
HXDLIN( 190)				do {
HXLINE( 190)					int x1 = ::Std_obj::_hx_int((( (Float)(p) ) / ( (Float)(scaleW) )));
HXDLIN( 190)					int y1 = ::Std_obj::_hx_int((( (Float)(q) ) / ( (Float)(scaleH) )));
HXDLIN( 190)					::Dynamic this4 = thisImage1->image;
HXDLIN( 190)					int index;
HXDLIN( 190)					if (thisImage1->useVirtualPos) {
HXLINE( 190)						index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - thisImage1->virtualY) * ( (Float)(thisImage1->width) )) + x1) - thisImage1->virtualX));
            					}
            					else {
HXLINE( 190)						index = ::Std_obj::_hx_int(( (Float)(((y1 * thisImage1->width) + x1)) ));
            					}
HXDLIN( 190)					int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN( 190)					int color;
HXDLIN( 190)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 190)						color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            					}
            					else {
HXLINE( 190)						color = c;
            					}
HXDLIN( 190)					{
HXLINE( 190)						p = (p + 1);
HXDLIN( 190)						int x2 = (p - 1);
HXDLIN( 190)						int c1 = color;
HXDLIN( 190)						bool pixelImage3;
HXDLIN( 190)						if ((((c1 >> 24) & 255) < 254)) {
HXLINE( 190)							pixelImage3 = nextImage->transparent;
            						}
            						else {
HXLINE( 190)							pixelImage3 = false;
            						}
HXDLIN( 190)						if (pixelImage3) {
HXLINE( 190)							int location;
HXDLIN( 190)							if (nextImage->useVirtualPos) {
HXLINE( 190)								location = ::Std_obj::_hx_int(((((( (Float)(q) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x2) - nextImage->virtualX));
            							}
            							else {
HXLINE( 190)								location = ::Std_obj::_hx_int(( (Float)(((q * nextImage->width) + x2)) ));
            							}
HXDLIN( 190)							int this5 = ::iterMagic::Iimg_obj::get(nextImage->image,location);
HXDLIN( 190)							int this6;
HXDLIN( 190)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 190)								this6 = ((((((this5 >> 24) & 255) << 24) | ((this5 & 255) << 16)) | (((this5 >> 8) & 255) << 8)) | ((this5 >> 16) & 255));
            							}
            							else {
HXLINE( 190)								this6 = this5;
            							}
HXDLIN( 190)							Float a1;
HXDLIN( 190)							int this7 = ((this6 >> 24) & 255);
HXDLIN( 190)							if ((this7 == 0)) {
HXLINE( 190)								a1 = ((Float)0.);
            							}
            							else {
HXLINE( 190)								a1 = (( (Float)(this7) ) / ( (Float)(255) ));
            							}
HXDLIN( 190)							Float r1;
HXDLIN( 190)							int this8 = ((this6 >> 16) & 255);
HXDLIN( 190)							if ((this8 == 0)) {
HXLINE( 190)								r1 = ((Float)0.);
            							}
            							else {
HXLINE( 190)								r1 = (( (Float)(this8) ) / ( (Float)(255) ));
            							}
HXDLIN( 190)							Float g1;
HXDLIN( 190)							int this9 = ((this6 >> 8) & 255);
HXDLIN( 190)							if ((this9 == 0)) {
HXLINE( 190)								g1 = ((Float)0.);
            							}
            							else {
HXLINE( 190)								g1 = (( (Float)(this9) ) / ( (Float)(255) ));
            							}
HXDLIN( 190)							Float b11;
HXDLIN( 190)							int this10 = (this6 & 255);
HXDLIN( 190)							if ((this10 == 0)) {
HXLINE( 190)								b11 = ((Float)0.);
            							}
            							else {
HXLINE( 190)								b11 = (( (Float)(this10) ) / ( (Float)(255) ));
            							}
HXDLIN( 190)							Float a2;
HXDLIN( 190)							int this11 = ((color >> 24) & 255);
HXDLIN( 190)							if ((this11 == 0)) {
HXLINE( 190)								a2 = ((Float)0.);
            							}
            							else {
HXLINE( 190)								a2 = (( (Float)(this11) ) / ( (Float)(255) ));
            							}
HXDLIN( 190)							Float r2;
HXDLIN( 190)							int this12 = ((color >> 16) & 255);
HXDLIN( 190)							if ((this12 == 0)) {
HXLINE( 190)								r2 = ((Float)0.);
            							}
            							else {
HXLINE( 190)								r2 = (( (Float)(this12) ) / ( (Float)(255) ));
            							}
HXDLIN( 190)							Float g2;
HXDLIN( 190)							int this13 = ((color >> 8) & 255);
HXDLIN( 190)							if ((this13 == 0)) {
HXLINE( 190)								g2 = ((Float)0.);
            							}
            							else {
HXLINE( 190)								g2 = (( (Float)(this13) ) / ( (Float)(255) ));
            							}
HXDLIN( 190)							Float b21;
HXDLIN( 190)							int this14 = (color & 255);
HXDLIN( 190)							if ((this14 == 0)) {
HXLINE( 190)								b21 = ((Float)0.);
            							}
            							else {
HXLINE( 190)								b21 = (( (Float)(this14) ) / ( (Float)(255) ));
            							}
HXDLIN( 190)							Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 190)							int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 190)							int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 190)							int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 190)							int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 190)							int blended = ((((a4 << 24) | (r3 << 16)) | (g << 8)) | b3);
HXDLIN( 190)							{
HXLINE( 190)								int pixelImage4;
HXDLIN( 190)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 190)									pixelImage4 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            								}
            								else {
HXLINE( 190)									pixelImage4 = blended;
            								}
HXDLIN( 190)								::iterMagic::Iimg_obj::set(nextImage->image,location,pixelImage4);
            							}
            						}
            						else {
HXLINE( 190)							::Dynamic this15 = nextImage->image;
HXDLIN( 190)							int index1;
HXDLIN( 190)							if (nextImage->useVirtualPos) {
HXLINE( 190)								index1 = ::Std_obj::_hx_int(((((( (Float)(q) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x2) - nextImage->virtualX));
            							}
            							else {
HXLINE( 190)								index1 = ::Std_obj::_hx_int(( (Float)(((q * nextImage->width) + x2)) ));
            							}
HXDLIN( 190)							int pixelImage5;
HXDLIN( 190)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 190)								pixelImage5 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            							}
            							else {
HXLINE( 190)								pixelImage5 = c1;
            							}
HXDLIN( 190)							::iterMagic::Iimg_obj::set(this15,index1,pixelImage5);
            						}
            					}
HXDLIN( 190)					if ((p > maxX)) {
HXLINE(  22)						p = xx;
HXLINE( 190)						q = (q + 1);
            					}
            				} while((q <= maxY));
;
HXDLIN( 190)				bool pixelImage6;
HXDLIN( 190)				if (::hx::IsNotNull( thisImage1->mask )) {
HXLINE( 190)					pixelImage6 = includeMask;
            				}
            				else {
HXLINE( 190)					pixelImage6 = false;
            				}
HXDLIN( 190)				if (pixelImage6) {
HXLINE( 190)					 ::pi_xy::ImageStruct v1 = ::pi_xy::transformation::_ScaleImage::ScaleImage_Fields__obj::scaleUpInteger(thisImage1->mask,scaleW,scaleH,thisImage1->mask->transparent,includeMask);
HXDLIN( 190)					nextImage->useMask = true;
HXDLIN( 190)					nextImage->mask = v1;
            				}
HXDLIN( 190)				pixelImage = nextImage;
            			}
            			else {
HXLINE( 190)				Float w1 = (( (Float)(thisImage->width) ) * ( (Float)(sx) ));
HXDLIN( 190)				Float h = (( (Float)(thisImage->height) ) * ( (Float)(sy) ));
HXDLIN( 190)				int wid = ::Math_obj::ceil(w1);
HXDLIN( 190)				int hi = ::Math_obj::ceil(h);
HXDLIN( 190)				 ::Dynamic imageType1 = null();
HXDLIN( 190)				 ::pi_xy::ImageStruct this16 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 190)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE( 190)				::Dynamic pixelImage7;
HXDLIN( 190)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXLINE( 190)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 190)						 ::iterMagic::BytesImg b4 = byt1;
HXDLIN( 190)						{
HXLINE( 190)							b4->width = wid;
HXDLIN( 190)							b4->height = hi;
HXDLIN( 190)							b4->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN( 190)							b4->data = ::haxe::io::Bytes_obj::alloc((b4->length * 4));
HXDLIN( 190)							{
HXLINE( 190)								int len2 = b4->length;
HXDLIN( 190)								int w2 = 0;
HXDLIN( 190)								{
HXLINE( 190)									int _g16 = 0;
HXDLIN( 190)									int _g17 = b4->height;
HXDLIN( 190)									while((_g16 < _g17)){
HXLINE( 190)										_g16 = (_g16 + 1);
HXDLIN( 190)										int y2 = (_g16 - 1);
HXDLIN( 190)										{
HXLINE( 190)											int _g18 = 0;
HXDLIN( 190)											int _g19 = b4->width;
HXDLIN( 190)											while((_g18 < _g19)){
HXLINE( 190)												_g18 = (_g18 + 1);
HXDLIN( 190)												int x3 = (_g18 - 1);
HXDLIN( 190)												{
HXLINE( 190)													w2 = (w2 + 1);
HXDLIN( 190)													b4->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 190)												{
HXLINE( 190)													w2 = (w2 + 1);
HXDLIN( 190)													b4->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 190)												{
HXLINE( 190)													w2 = (w2 + 1);
HXDLIN( 190)													b4->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN( 190)												{
HXLINE( 190)													w2 = (w2 + 1);
HXDLIN( 190)													b4->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 190)						pixelImage7 = b4;
            					}
            					break;
            					case (int)1: {
HXLINE( 190)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 190)						 ::iterMagic::ArrIntImg a5 = arrI1;
HXDLIN( 190)						{
HXLINE( 190)							a5->width = wid;
HXDLIN( 190)							a5->height = hi;
HXDLIN( 190)							a5->data = ::Array_obj< int >::__new(0);
HXDLIN( 190)							a5->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN( 190)							{
HXLINE( 190)								int _g20 = 0;
HXDLIN( 190)								int _g21 = a5->length;
HXDLIN( 190)								while((_g20 < _g21)){
HXLINE( 190)									_g20 = (_g20 + 1);
HXDLIN( 190)									int i6 = (_g20 - 1);
HXDLIN( 190)									a5->data[i6] = 0;
            								}
            							}
            						}
HXDLIN( 190)						pixelImage7 = a5;
            					}
            					break;
            					case (int)2: {
HXLINE( 190)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 190)						 ::iterMagic::U32ArrImg b5 = u32a1;
HXDLIN( 190)						{
HXLINE( 190)							b5->width = wid;
HXDLIN( 190)							b5->height = hi;
HXDLIN( 190)							b5->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN( 190)							int size1 = (b5->length * 4);
HXDLIN( 190)							b5->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 190)							{
HXLINE( 190)								int _g22 = 0;
HXDLIN( 190)								int _g23 = b5->length;
HXDLIN( 190)								while((_g22 < _g23)){
HXLINE( 190)									_g22 = (_g22 + 1);
HXDLIN( 190)									int i7 = (_g22 - 1);
HXDLIN( 190)									{
HXLINE( 190)										 ::haxe::io::ArrayBufferViewImpl this17 = b5->data;
HXDLIN( 190)										bool pixelImage8;
HXDLIN( 190)										if ((i7 >= 0)) {
HXLINE( 190)											pixelImage8 = (i7 < (this17->byteLength >> 2));
            										}
            										else {
HXLINE( 190)											pixelImage8 = false;
            										}
HXDLIN( 190)										if (pixelImage8) {
HXLINE( 190)											 ::haxe::io::Bytes _this1 = this17->bytes;
HXDLIN( 190)											int pos1 = ((i7 << 2) + this17->byteOffset);
HXDLIN( 190)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 190)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 190)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 190)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN( 190)						pixelImage7 = b5;
            					}
            					break;
            					case (int)3: {
HXLINE( 190)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 190)						 ::iterMagic::VecIntImg v2 = vec1;
HXDLIN( 190)						{
HXLINE( 190)							v2->width = wid;
HXDLIN( 190)							v2->height = hi;
HXDLIN( 190)							v2->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN( 190)							v2->data = ::Array_obj< int >::__new(v2->length);
HXDLIN( 190)							{
HXLINE( 190)								int _g24 = 0;
HXDLIN( 190)								int _g25 = v2->length;
HXDLIN( 190)								while((_g24 < _g25)){
HXLINE( 190)									_g24 = (_g24 + 1);
HXDLIN( 190)									int i8 = (_g24 - 1);
HXDLIN( 190)									v2->data->__unsafe_set(i8,0);
            								}
            							}
            						}
HXDLIN( 190)						pixelImage7 = v2;
            					}
            					break;
            					case (int)4: {
HXLINE( 190)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 190)						 ::iterMagic::StackIntImg b6 = sInt1;
HXDLIN( 190)						{
HXLINE( 190)							b6->width = wid;
HXDLIN( 190)							b6->height = hi;
HXDLIN( 190)							b6->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN( 190)							b6->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 190)							{
HXLINE( 190)								int len3 = b6->length;
HXDLIN( 190)								 ::haxe::ds::GenericStack_Int d1 = b6->data;
HXDLIN( 190)								if (::hx::IsNull( d1->head )) {
HXLINE( 190)									int _g26 = 0;
HXDLIN( 190)									int _g27 = len3;
HXDLIN( 190)									while((_g26 < _g27)){
HXLINE( 190)										_g26 = (_g26 + 1);
HXDLIN( 190)										int i9 = (_g26 - 1);
HXDLIN( 190)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXLINE( 190)									int _g28 = 0;
HXDLIN( 190)									int _g29 = len3;
HXDLIN( 190)									while((_g28 < _g29)){
HXLINE( 190)										_g28 = (_g28 + 1);
HXDLIN( 190)										int i10 = (_g28 - 1);
HXDLIN( 190)										{
HXLINE( 190)											 ::haxe::ds::GenericCell_Int l1 = b6->data->head;
HXDLIN( 190)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 190)											{
HXLINE( 190)												int _g30 = 0;
HXDLIN( 190)												int _g31 = i10;
HXDLIN( 190)												while((_g30 < _g31)){
HXLINE( 190)													_g30 = (_g30 + 1);
HXDLIN( 190)													int i11 = (_g30 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE( 190)											if (::hx::IsNull( prev1 )) {
HXLINE( 190)												b6->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 190)												l1 = null();
            											}
            											else {
HXLINE( 190)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 190)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 190)						pixelImage7 = b6;
            					}
            					break;
            				}
HXDLIN( 190)				this16->image = pixelImage7;
HXDLIN( 190)				this16->width = wid;
HXDLIN( 190)				this16->height = hi;
HXDLIN( 190)				this16->imageType = ( (int)(imageType1) );
HXDLIN( 190)				 ::pi_xy::ImageStruct nextImage1 = this16;
HXDLIN( 190)				{
HXLINE( 190)					bool v3 = thisImage->transparent;
HXDLIN( 190)					nextImage1->transparent = v3;
            				}
HXDLIN( 190)				{
HXLINE( 190)					 ::pi_xy::ImageStruct this18 = nextImage1;
HXDLIN( 190)					Float win_x = ( (Float)(0) );
HXDLIN( 190)					Float win_y = ( (Float)(0) );
HXDLIN( 190)					Float win_width = ( (Float)(thisImage->width) );
HXDLIN( 190)					Float win_height = ( (Float)(thisImage->height) );
HXDLIN( 190)					{
HXLINE( 190)						Float bu = ((Float)1.);
HXDLIN( 190)						Float bv = ((Float)0.);
HXDLIN( 190)						Float cu = ((Float)1.);
HXDLIN( 190)						Float cv = ((Float)1.);
HXDLIN( 190)						Float du = ((Float)0.);
HXDLIN( 190)						Float dv = ((Float)1.);
HXDLIN( 190)						Float au = ((Float)0.);
HXDLIN( 190)						Float av = ((Float)0.);
HXDLIN( 190)						Float bu1 = bu;
HXDLIN( 190)						Float bv1 = bv;
HXDLIN( 190)						bool hasUndo = false;
HXDLIN( 190)						Float temp = au;
HXLINE( 422)						au = bu1;
HXLINE( 423)						bu1 = temp;
HXLINE( 424)						temp = av;
HXLINE( 425)						av = bv1;
HXLINE( 426)						bv1 = temp;
HXLINE( 190)						Float bcx = w1;
HXDLIN( 190)						Float bcy = (( (Float)(0) ) - h);
HXDLIN( 190)						Float acx = ( (Float)(0) );
HXDLIN( 190)						Float acy = (( (Float)(0) ) - h);
HXDLIN( 190)						Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN( 190)						Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN( 190)						Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN( 190)						Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN( 190)						 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 190)						if ((0 > w1)) {
HXLINE( 190)							int ii_min = ::Math_obj::floor(w1);
HXDLIN( 190)							int ii_max = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN( 190)							xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            						}
            						else {
HXLINE( 190)							if ((w1 > 0)) {
HXLINE( 190)								int ii_min1 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN( 190)								int ii_max1 = ::Math_obj::ceil(w1);
HXDLIN( 190)								xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            							}
            							else {
HXLINE( 190)								int ii_min2 = ::Math_obj::floor(( (Float)(0) ));
HXDLIN( 190)								int ii_max2 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN( 190)								xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            							}
            						}
HXDLIN( 190)						 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 190)						if ((0 > h)) {
HXLINE( 190)							int min;
HXDLIN( 190)							if ((0 > h)) {
HXLINE( 190)								min = ::Math_obj::floor(h);
            							}
            							else {
HXLINE( 190)								min = ::Math_obj::ceil(( (Float)(0) ));
            							}
HXDLIN( 190)							int ii_min3 = min;
HXDLIN( 190)							int ii_max3 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN( 190)							yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            						}
            						else {
HXLINE( 190)							int ii_min4 = ::Math_obj::floor(( (Float)(0) ));
HXDLIN( 190)							int ii_max4 = ::Math_obj::ceil(h);
HXDLIN( 190)							yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            						}
HXDLIN( 190)						 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 190)						if (hasUndo) {
HXLINE( 190)							int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 190)							int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 190)							 ::Dynamic imageType2 = null();
HXDLIN( 190)							 ::pi_xy::ImageStruct this19 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 190)							if (::hx::IsNull( imageType2 )) {
HXLINE(  54)								imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE( 190)							::Dynamic undoImage1;
HXDLIN( 190)							switch((int)(( (int)(imageType2) ))){
            								case (int)0: {
HXLINE( 190)									 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 190)									 ::iterMagic::BytesImg b7 = byt2;
HXDLIN( 190)									{
HXLINE( 190)										b7->width = width;
HXDLIN( 190)										b7->height = height;
HXDLIN( 190)										b7->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 190)										b7->data = ::haxe::io::Bytes_obj::alloc((b7->length * 4));
HXDLIN( 190)										{
HXLINE( 190)											int len4 = b7->length;
HXDLIN( 190)											int w3 = 0;
HXDLIN( 190)											{
HXLINE( 190)												int _g32 = 0;
HXDLIN( 190)												int _g33 = b7->height;
HXDLIN( 190)												while((_g32 < _g33)){
HXLINE( 190)													_g32 = (_g32 + 1);
HXDLIN( 190)													int y3 = (_g32 - 1);
HXDLIN( 190)													{
HXLINE( 190)														int _g34 = 0;
HXDLIN( 190)														int _g35 = b7->width;
HXDLIN( 190)														while((_g34 < _g35)){
HXLINE( 190)															_g34 = (_g34 + 1);
HXDLIN( 190)															int x4 = (_g34 - 1);
HXDLIN( 190)															{
HXLINE( 190)																w3 = (w3 + 1);
HXDLIN( 190)																b7->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 190)															{
HXLINE( 190)																w3 = (w3 + 1);
HXDLIN( 190)																b7->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 190)															{
HXLINE( 190)																w3 = (w3 + 1);
HXDLIN( 190)																b7->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 190)															{
HXLINE( 190)																w3 = (w3 + 1);
HXDLIN( 190)																b7->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 190)									undoImage1 = b7;
            								}
            								break;
            								case (int)1: {
HXLINE( 190)									 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 190)									 ::iterMagic::ArrIntImg a6 = arrI2;
HXDLIN( 190)									{
HXLINE( 190)										a6->width = width;
HXDLIN( 190)										a6->height = height;
HXDLIN( 190)										a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 190)										a6->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 190)										{
HXLINE( 190)											int _g36 = 0;
HXDLIN( 190)											int _g37 = a6->length;
HXDLIN( 190)											while((_g36 < _g37)){
HXLINE( 190)												_g36 = (_g36 + 1);
HXDLIN( 190)												int i12 = (_g36 - 1);
HXDLIN( 190)												a6->data[i12] = 0;
            											}
            										}
            									}
HXDLIN( 190)									undoImage1 = a6;
            								}
            								break;
            								case (int)2: {
HXLINE( 190)									 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 190)									 ::iterMagic::U32ArrImg b8 = u32a2;
HXDLIN( 190)									{
HXLINE( 190)										b8->width = width;
HXDLIN( 190)										b8->height = height;
HXDLIN( 190)										b8->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 190)										int size2 = (b8->length * 4);
HXDLIN( 190)										b8->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN( 190)										{
HXLINE( 190)											int _g38 = 0;
HXDLIN( 190)											int _g39 = b8->length;
HXDLIN( 190)											while((_g38 < _g39)){
HXLINE( 190)												_g38 = (_g38 + 1);
HXDLIN( 190)												int i13 = (_g38 - 1);
HXDLIN( 190)												{
HXLINE( 190)													 ::haxe::io::ArrayBufferViewImpl this20 = b8->data;
HXDLIN( 190)													bool undoImage2;
HXDLIN( 190)													if ((i13 >= 0)) {
HXLINE( 190)														undoImage2 = (i13 < (this20->byteLength >> 2));
            													}
            													else {
HXLINE( 190)														undoImage2 = false;
            													}
HXDLIN( 190)													if (undoImage2) {
HXLINE( 190)														 ::haxe::io::Bytes _this2 = this20->bytes;
HXDLIN( 190)														int pos2 = ((i13 << 2) + this20->byteOffset);
HXDLIN( 190)														_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN( 190)														_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN( 190)														_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN( 190)														_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN( 190)									undoImage1 = b8;
            								}
            								break;
            								case (int)3: {
HXLINE( 190)									 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 190)									 ::iterMagic::VecIntImg v4 = vec2;
HXDLIN( 190)									{
HXLINE( 190)										v4->width = width;
HXDLIN( 190)										v4->height = height;
HXDLIN( 190)										v4->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 190)										v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN( 190)										{
HXLINE( 190)											int _g40 = 0;
HXDLIN( 190)											int _g41 = v4->length;
HXDLIN( 190)											while((_g40 < _g41)){
HXLINE( 190)												_g40 = (_g40 + 1);
HXDLIN( 190)												int i14 = (_g40 - 1);
HXDLIN( 190)												v4->data->__unsafe_set(i14,0);
            											}
            										}
            									}
HXDLIN( 190)									undoImage1 = v4;
            								}
            								break;
            								case (int)4: {
HXLINE( 190)									 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 190)									 ::iterMagic::StackIntImg b9 = sInt2;
HXDLIN( 190)									{
HXLINE( 190)										b9->width = width;
HXDLIN( 190)										b9->height = height;
HXDLIN( 190)										b9->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 190)										b9->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 190)										{
HXLINE( 190)											int len5 = b9->length;
HXDLIN( 190)											 ::haxe::ds::GenericStack_Int d2 = b9->data;
HXDLIN( 190)											if (::hx::IsNull( d2->head )) {
HXLINE( 190)												int _g42 = 0;
HXDLIN( 190)												int _g43 = len5;
HXDLIN( 190)												while((_g42 < _g43)){
HXLINE( 190)													_g42 = (_g42 + 1);
HXDLIN( 190)													int i15 = (_g42 - 1);
HXDLIN( 190)													d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            												}
            											}
            											else {
HXLINE( 190)												int _g44 = 0;
HXDLIN( 190)												int _g45 = len5;
HXDLIN( 190)												while((_g44 < _g45)){
HXLINE( 190)													_g44 = (_g44 + 1);
HXDLIN( 190)													int i16 = (_g44 - 1);
HXDLIN( 190)													{
HXLINE( 190)														 ::haxe::ds::GenericCell_Int l2 = b9->data->head;
HXDLIN( 190)														 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN( 190)														{
HXLINE( 190)															int _g46 = 0;
HXDLIN( 190)															int _g47 = i16;
HXDLIN( 190)															while((_g46 < _g47)){
HXLINE( 190)																_g46 = (_g46 + 1);
HXDLIN( 190)																int i17 = (_g46 - 1);
HXLINE( 345)																prev2 = l2;
HXLINE( 346)																l2 = l2->next;
            															}
            														}
HXLINE( 190)														if (::hx::IsNull( prev2 )) {
HXLINE( 190)															b9->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 190)															l2 = null();
            														}
            														else {
HXLINE( 190)															prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN( 190)															l2 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 190)									undoImage1 = b9;
            								}
            								break;
            							}
HXDLIN( 190)							this19->image = undoImage1;
HXDLIN( 190)							this19->width = width;
HXDLIN( 190)							this19->height = height;
HXDLIN( 190)							this19->imageType = ( (int)(imageType2) );
HXDLIN( 190)							undoImage = this19;
HXDLIN( 190)							{
HXLINE( 190)								int rectLeft = xIter3->start;
HXDLIN( 190)								int rectTop = yIter3->start;
HXDLIN( 190)								int rectRight = xIter3->max;
HXDLIN( 190)								bool forceClear = false;
HXDLIN( 190)								{
HXLINE( 190)									int _g48 = rectTop;
HXDLIN( 190)									int _g49 = yIter3->max;
HXDLIN( 190)									while((_g48 < _g49)){
HXLINE( 190)										_g48 = (_g48 + 1);
HXDLIN( 190)										int dy = (_g48 - 1);
HXDLIN( 190)										{
HXLINE( 190)											int _g50 = rectLeft;
HXDLIN( 190)											int _g51 = rectRight;
HXDLIN( 190)											while((_g50 < _g51)){
HXLINE( 190)												_g50 = (_g50 + 1);
HXDLIN( 190)												int dx = (_g50 - 1);
HXDLIN( 190)												::Dynamic this21 = this18->image;
HXDLIN( 190)												int index2;
HXDLIN( 190)												if (this18->useVirtualPos) {
HXLINE( 190)													index2 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this18->virtualY) * ( (Float)(this18->width) )) + dx) - this18->virtualX));
            												}
            												else {
HXLINE( 190)													index2 = ::Std_obj::_hx_int(( (Float)(((dy * this18->width) + dx)) ));
            												}
HXDLIN( 190)												int c2 = ::iterMagic::Iimg_obj::get(this21,index2);
HXDLIN( 190)												int col;
HXDLIN( 190)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 190)													col = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            												}
            												else {
HXLINE( 190)													col = c2;
            												}
HXDLIN( 190)												bool pixelImage9;
HXDLIN( 190)												if (this18->useMask) {
HXLINE( 190)													pixelImage9 = ::hx::IsNotNull( this18->mask );
            												}
            												else {
HXLINE( 190)													pixelImage9 = false;
            												}
HXDLIN( 190)												if (pixelImage9) {
HXLINE( 190)													 ::pi_xy::ImageStruct this22 = this18->mask;
HXDLIN( 190)													::Dynamic this23 = this22->image;
HXDLIN( 190)													int index3;
HXDLIN( 190)													if (this22->useVirtualPos) {
HXLINE( 190)														index3 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this22->virtualY) * ( (Float)(this22->width) )) + dx) - this22->virtualX));
            													}
            													else {
HXLINE( 190)														index3 = ::Std_obj::_hx_int(( (Float)(((dy * this22->width) + dx)) ));
            													}
HXDLIN( 190)													int c3 = ::iterMagic::Iimg_obj::get(this23,index3);
HXDLIN( 190)													int v5;
HXDLIN( 190)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 190)														v5 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            													}
            													else {
HXLINE( 190)														v5 = c3;
            													}
HXDLIN( 190)													int maskPixel = v5;
HXDLIN( 190)													int this24 = col;
HXDLIN( 190)													if ((maskPixel == 0)) {
HXLINE( 190)														col = this24;
            													}
            													else {
HXLINE( 190)														Float m0;
HXDLIN( 190)														int this25 = ((maskPixel >> 24) & 255);
HXDLIN( 190)														if ((this25 == 0)) {
HXLINE( 190)															m0 = ((Float)0.);
            														}
            														else {
HXLINE( 190)															m0 = (( (Float)(this25) ) / ( (Float)(255) ));
            														}
HXDLIN( 190)														Float m1;
HXDLIN( 190)														int this26 = ((maskPixel >> 16) & 255);
HXDLIN( 190)														if ((this26 == 0)) {
HXLINE( 190)															m1 = ((Float)0.);
            														}
            														else {
HXLINE( 190)															m1 = (( (Float)(this26) ) / ( (Float)(255) ));
            														}
HXDLIN( 190)														Float m2;
HXDLIN( 190)														int this27 = ((maskPixel >> 8) & 255);
HXDLIN( 190)														if ((this27 == 0)) {
HXLINE( 190)															m2 = ((Float)0.);
            														}
            														else {
HXLINE( 190)															m2 = (( (Float)(this27) ) / ( (Float)(255) ));
            														}
HXDLIN( 190)														Float m3;
HXDLIN( 190)														int this28 = (maskPixel & 255);
HXDLIN( 190)														if ((this28 == 0)) {
HXLINE( 190)															m3 = ((Float)0.);
            														}
            														else {
HXLINE( 190)															m3 = (( (Float)(this28) ) / ( (Float)(255) ));
            														}
HXDLIN( 190)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this24 >> 24) & 255)) )));
HXDLIN( 190)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this24 >> 16) & 255)) )));
HXDLIN( 190)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this24 >> 8) & 255)) )));
HXDLIN( 190)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this24 & 255)) )));
HXDLIN( 190)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN( 190)												if ((col != 0)) {
HXLINE( 190)													int x5 = (dx - rectLeft);
HXDLIN( 190)													int y4 = (dy - rectTop);
HXDLIN( 190)													int c4 = col;
HXDLIN( 190)													bool pixelImage10;
HXDLIN( 190)													if ((((c4 >> 24) & 255) < 254)) {
HXLINE( 190)														pixelImage10 = undoImage->transparent;
            													}
            													else {
HXLINE( 190)														pixelImage10 = false;
            													}
HXDLIN( 190)													if (pixelImage10) {
HXLINE( 190)														int location1;
HXDLIN( 190)														if (undoImage->useVirtualPos) {
HXLINE( 190)															location1 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            														}
            														else {
HXLINE( 190)															location1 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage->width) + x5)) ));
            														}
HXDLIN( 190)														int this29 = ::iterMagic::Iimg_obj::get(undoImage->image,location1);
HXDLIN( 190)														int this30;
HXDLIN( 190)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 190)															this30 = ((((((this29 >> 24) & 255) << 24) | ((this29 & 255) << 16)) | (((this29 >> 8) & 255) << 8)) | ((this29 >> 16) & 255));
            														}
            														else {
HXLINE( 190)															this30 = this29;
            														}
HXDLIN( 190)														Float a11;
HXDLIN( 190)														int this31 = ((this30 >> 24) & 255);
HXDLIN( 190)														if ((this31 == 0)) {
HXLINE( 190)															a11 = ((Float)0.);
            														}
            														else {
HXLINE( 190)															a11 = (( (Float)(this31) ) / ( (Float)(255) ));
            														}
HXDLIN( 190)														Float r11;
HXDLIN( 190)														int this32 = ((this30 >> 16) & 255);
HXDLIN( 190)														if ((this32 == 0)) {
HXLINE( 190)															r11 = ((Float)0.);
            														}
            														else {
HXLINE( 190)															r11 = (( (Float)(this32) ) / ( (Float)(255) ));
            														}
HXDLIN( 190)														Float g11;
HXDLIN( 190)														int this33 = ((this30 >> 8) & 255);
HXDLIN( 190)														if ((this33 == 0)) {
HXLINE( 190)															g11 = ((Float)0.);
            														}
            														else {
HXLINE( 190)															g11 = (( (Float)(this33) ) / ( (Float)(255) ));
            														}
HXDLIN( 190)														Float b12;
HXDLIN( 190)														int this34 = (this30 & 255);
HXDLIN( 190)														if ((this34 == 0)) {
HXLINE( 190)															b12 = ((Float)0.);
            														}
            														else {
HXLINE( 190)															b12 = (( (Float)(this34) ) / ( (Float)(255) ));
            														}
HXDLIN( 190)														Float a21;
HXDLIN( 190)														int this35 = ((col >> 24) & 255);
HXDLIN( 190)														if ((this35 == 0)) {
HXLINE( 190)															a21 = ((Float)0.);
            														}
            														else {
HXLINE( 190)															a21 = (( (Float)(this35) ) / ( (Float)(255) ));
            														}
HXDLIN( 190)														Float r21;
HXDLIN( 190)														int this36 = ((col >> 16) & 255);
HXDLIN( 190)														if ((this36 == 0)) {
HXLINE( 190)															r21 = ((Float)0.);
            														}
            														else {
HXLINE( 190)															r21 = (( (Float)(this36) ) / ( (Float)(255) ));
            														}
HXDLIN( 190)														Float g21;
HXDLIN( 190)														int this37 = ((col >> 8) & 255);
HXDLIN( 190)														if ((this37 == 0)) {
HXLINE( 190)															g21 = ((Float)0.);
            														}
            														else {
HXLINE( 190)															g21 = (( (Float)(this37) ) / ( (Float)(255) ));
            														}
HXDLIN( 190)														Float b22;
HXDLIN( 190)														int this38 = (col & 255);
HXDLIN( 190)														if ((this38 == 0)) {
HXLINE( 190)															b22 = ((Float)0.);
            														}
            														else {
HXLINE( 190)															b22 = (( (Float)(this38) ) / ( (Float)(255) ));
            														}
HXDLIN( 190)														Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 190)														int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 190)														int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 190)														int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 190)														int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 190)														int blended1 = ((((a7 << 24) | (r4 << 16)) | (g3 << 8)) | b10);
HXDLIN( 190)														{
HXLINE( 190)															int pixelImage11;
HXDLIN( 190)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 190)																pixelImage11 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            															}
            															else {
HXLINE( 190)																pixelImage11 = blended1;
            															}
HXDLIN( 190)															::iterMagic::Iimg_obj::set(undoImage->image,location1,pixelImage11);
            														}
            													}
            													else {
HXLINE( 190)														::Dynamic this39 = undoImage->image;
HXDLIN( 190)														int index4;
HXDLIN( 190)														if (undoImage->useVirtualPos) {
HXLINE( 190)															index4 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            														}
            														else {
HXLINE( 190)															index4 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage->width) + x5)) ));
            														}
HXDLIN( 190)														int pixelImage12;
HXDLIN( 190)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 190)															pixelImage12 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            														}
            														else {
HXLINE( 190)															pixelImage12 = c4;
            														}
HXDLIN( 190)														::iterMagic::Iimg_obj::set(this39,index4,pixelImage12);
            													}
            												}
            												else {
HXLINE( 190)													if (forceClear) {
HXLINE( 190)														::Dynamic this40 = undoImage->image;
HXDLIN( 190)														int x6 = (dx - rectLeft);
HXDLIN( 190)														int y5 = (dy - rectTop);
HXDLIN( 190)														int index5;
HXDLIN( 190)														if (undoImage->useVirtualPos) {
HXLINE( 190)															index5 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x6) - undoImage->virtualX));
            														}
            														else {
HXLINE( 190)															index5 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage->width) + x6)) ));
            														}
HXDLIN( 190)														::iterMagic::Iimg_obj::set(this40,index5,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 190)						{
HXLINE( 190)							int _g_min = xIter3->start;
HXDLIN( 190)							int _g_max = xIter3->max;
HXDLIN( 190)							while((_g_min < _g_max)){
HXLINE( 190)								_g_min = (_g_min + 1);
HXDLIN( 190)								int px = (_g_min - 1);
HXDLIN( 190)								Float pcx = ( (Float)(px) );
HXDLIN( 190)								{
HXLINE( 190)									int _g_min1 = yIter3->start;
HXDLIN( 190)									int _g_max1 = yIter3->max;
HXDLIN( 190)									while((_g_min1 < _g_max1)){
HXLINE( 190)										_g_min1 = (_g_min1 + 1);
HXDLIN( 190)										int py = (_g_min1 - 1);
HXDLIN( 190)										Float pcy = (( (Float)(py) ) - h);
HXDLIN( 190)										Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN( 190)										Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN( 190)										Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN( 190)										Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN( 190)										Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN( 190)										bool pixelImage13;
HXDLIN( 190)										bool pixelImage14;
HXDLIN( 190)										if ((ratioA >= 0)) {
HXLINE( 190)											pixelImage14 = (ratioB >= 0);
            										}
            										else {
HXLINE( 190)											pixelImage14 = false;
            										}
HXDLIN( 190)										if (pixelImage14) {
HXLINE( 190)											pixelImage13 = (ratioC >= 0);
            										}
            										else {
HXLINE( 190)											pixelImage13 = false;
            										}
HXDLIN( 190)										if (pixelImage13) {
HXLINE( 190)											Float u = (((au * ratioA) + (bu1 * ratioB)) + (du * ratioC));
HXDLIN( 190)											Float v6 = (((av * ratioA) + (bv1 * ratioB)) + (dv * ratioC));
HXDLIN( 190)											int x7 = ::Std_obj::_hx_int(((u * win_width) + win_x));
HXDLIN( 190)											int y6 = ::Std_obj::_hx_int(((v6 * win_height) + win_y));
HXDLIN( 190)											::Dynamic this41 = thisImage->image;
HXDLIN( 190)											int index6;
HXDLIN( 190)											if (thisImage->useVirtualPos) {
HXLINE( 190)												index6 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - thisImage->virtualY) * ( (Float)(thisImage->width) )) + x7) - thisImage->virtualX));
            											}
            											else {
HXLINE( 190)												index6 = ::Std_obj::_hx_int(( (Float)(((y6 * thisImage->width) + x7)) ));
            											}
HXDLIN( 190)											int c5 = ::iterMagic::Iimg_obj::get(this41,index6);
HXDLIN( 190)											int col1;
HXDLIN( 190)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 190)												col1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            											}
            											else {
HXLINE( 190)												col1 = c5;
            											}
HXDLIN( 190)											{
HXLINE( 190)												int c6 = col1;
HXDLIN( 190)												bool pixelImage15;
HXDLIN( 190)												if ((((c6 >> 24) & 255) < 254)) {
HXLINE( 190)													pixelImage15 = this18->transparent;
            												}
            												else {
HXLINE( 190)													pixelImage15 = false;
            												}
HXDLIN( 190)												if (pixelImage15) {
HXLINE( 190)													int location2;
HXDLIN( 190)													if (this18->useVirtualPos) {
HXLINE( 190)														location2 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this18->virtualY) * ( (Float)(this18->width) )) + px) - this18->virtualX));
            													}
            													else {
HXLINE( 190)														location2 = ::Std_obj::_hx_int(( (Float)(((py * this18->width) + px)) ));
            													}
HXDLIN( 190)													int this42 = ::iterMagic::Iimg_obj::get(this18->image,location2);
HXDLIN( 190)													int this43;
HXDLIN( 190)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 190)														this43 = ((((((this42 >> 24) & 255) << 24) | ((this42 & 255) << 16)) | (((this42 >> 8) & 255) << 8)) | ((this42 >> 16) & 255));
            													}
            													else {
HXLINE( 190)														this43 = this42;
            													}
HXDLIN( 190)													Float a12;
HXDLIN( 190)													int this44 = ((this43 >> 24) & 255);
HXDLIN( 190)													if ((this44 == 0)) {
HXLINE( 190)														a12 = ((Float)0.);
            													}
            													else {
HXLINE( 190)														a12 = (( (Float)(this44) ) / ( (Float)(255) ));
            													}
HXDLIN( 190)													Float r12;
HXDLIN( 190)													int this45 = ((this43 >> 16) & 255);
HXDLIN( 190)													if ((this45 == 0)) {
HXLINE( 190)														r12 = ((Float)0.);
            													}
            													else {
HXLINE( 190)														r12 = (( (Float)(this45) ) / ( (Float)(255) ));
            													}
HXDLIN( 190)													Float g12;
HXDLIN( 190)													int this46 = ((this43 >> 8) & 255);
HXDLIN( 190)													if ((this46 == 0)) {
HXLINE( 190)														g12 = ((Float)0.);
            													}
            													else {
HXLINE( 190)														g12 = (( (Float)(this46) ) / ( (Float)(255) ));
            													}
HXDLIN( 190)													Float b13;
HXDLIN( 190)													int this47 = (this43 & 255);
HXDLIN( 190)													if ((this47 == 0)) {
HXLINE( 190)														b13 = ((Float)0.);
            													}
            													else {
HXLINE( 190)														b13 = (( (Float)(this47) ) / ( (Float)(255) ));
            													}
HXDLIN( 190)													Float a22;
HXDLIN( 190)													int this48 = ((col1 >> 24) & 255);
HXDLIN( 190)													if ((this48 == 0)) {
HXLINE( 190)														a22 = ((Float)0.);
            													}
            													else {
HXLINE( 190)														a22 = (( (Float)(this48) ) / ( (Float)(255) ));
            													}
HXDLIN( 190)													Float r22;
HXDLIN( 190)													int this49 = ((col1 >> 16) & 255);
HXDLIN( 190)													if ((this49 == 0)) {
HXLINE( 190)														r22 = ((Float)0.);
            													}
            													else {
HXLINE( 190)														r22 = (( (Float)(this49) ) / ( (Float)(255) ));
            													}
HXDLIN( 190)													Float g22;
HXDLIN( 190)													int this50 = ((col1 >> 8) & 255);
HXDLIN( 190)													if ((this50 == 0)) {
HXLINE( 190)														g22 = ((Float)0.);
            													}
            													else {
HXLINE( 190)														g22 = (( (Float)(this50) ) / ( (Float)(255) ));
            													}
HXDLIN( 190)													Float b23;
HXDLIN( 190)													int this51 = (col1 & 255);
HXDLIN( 190)													if ((this51 == 0)) {
HXLINE( 190)														b23 = ((Float)0.);
            													}
            													else {
HXLINE( 190)														b23 = (( (Float)(this51) ) / ( (Float)(255) ));
            													}
HXDLIN( 190)													Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 190)													int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 190)													int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 190)													int b14 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 190)													int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 190)													int blended2 = ((((a8 << 24) | (r5 << 16)) | (g4 << 8)) | b14);
HXDLIN( 190)													{
HXLINE( 190)														int pixelImage16;
HXDLIN( 190)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 190)															pixelImage16 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            														}
            														else {
HXLINE( 190)															pixelImage16 = blended2;
            														}
HXDLIN( 190)														::iterMagic::Iimg_obj::set(this18->image,location2,pixelImage16);
            													}
            												}
            												else {
HXLINE( 190)													::Dynamic this52 = this18->image;
HXDLIN( 190)													int index7;
HXDLIN( 190)													if (this18->useVirtualPos) {
HXLINE( 190)														index7 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this18->virtualY) * ( (Float)(this18->width) )) + px) - this18->virtualX));
            													}
            													else {
HXLINE( 190)														index7 = ::Std_obj::_hx_int(( (Float)(((py * this18->width) + px)) ));
            													}
HXDLIN( 190)													int pixelImage17;
HXDLIN( 190)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 190)														pixelImage17 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            													}
            													else {
HXLINE( 190)														pixelImage17 = c6;
            													}
HXDLIN( 190)													::iterMagic::Iimg_obj::set(this52,index7,pixelImage17);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 190)						 ::pi_xy::iter::IntIterStart v_yIter3;
HXDLIN( 190)						 ::pi_xy::iter::IntIterStart v_xIter3;
HXDLIN( 190)						int v_undoY;
HXDLIN( 190)						int v_undoX;
HXDLIN( 190)						Float v_ty;
HXDLIN( 190)						Float v_tx;
HXDLIN( 190)						Float v_t0;
HXDLIN( 190)						Float v_sy;
HXDLIN( 190)						Float v_sx;
HXDLIN( 190)						Float v_s0;
HXDLIN( 190)						Float v_A;
HXDLIN( 190)						 ::pi_xy::ImageStruct v_undoImage = null();
HXDLIN( 190)						Float bx = w1;
HXDLIN( 190)						Float by = ( (Float)(0) );
HXDLIN( 190)						Float cx = ( (Float)(0) );
HXDLIN( 190)						Float cy = h;
HXDLIN( 190)						bool adjustWinding = (((((( (Float)(0) ) * by) - (bx * ( (Float)(0) ))) + ((bx * cy) - (cx * by))) + ((cx * ( (Float)(0) )) - (( (Float)(0) ) * cy))) > 0);
HXDLIN( 190)						if (!(adjustWinding)) {
HXLINE( 190)							Float bx_ = bx;
HXDLIN( 190)							Float by_ = by;
HXLINE(  24)							bx = cx;
HXLINE(  25)							by = cy;
HXLINE(  26)							cx = bx_;
HXLINE(  27)							cy = by_;
            						}
HXLINE( 190)						Float v_ax = ( (Float)(0) );
HXDLIN( 190)						Float v_ay = ( (Float)(0) );
HXDLIN( 190)						Float v_bx = bx;
HXDLIN( 190)						Float v_by = by;
HXDLIN( 190)						Float v_cx = cx;
HXDLIN( 190)						Float v_cy = cy;
HXDLIN( 190)						bool v_preCalculated = true;
HXDLIN( 190)						{
HXLINE( 190)							v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN( 190)							v_sx = (v_cy - v_ay);
HXDLIN( 190)							v_sy = (v_ax - v_cx);
HXDLIN( 190)							v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN( 190)							v_tx = (v_ay - v_by);
HXDLIN( 190)							v_ty = (v_bx - v_ax);
HXDLIN( 190)							v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN( 190)							Float a9 = v_ax;
HXDLIN( 190)							Float b15 = v_bx;
HXDLIN( 190)							Float c7 = v_cx;
HXDLIN( 190)							if ((a9 > b15)) {
HXLINE( 190)								if ((a9 > c7)) {
HXLINE( 190)									int min1;
HXDLIN( 190)									if ((b15 > c7)) {
HXLINE( 190)										min1 = ::Math_obj::floor(c7);
            									}
            									else {
HXLINE( 190)										min1 = ::Math_obj::floor(b15);
            									}
HXDLIN( 190)									int ii_min5 = min1;
HXDLIN( 190)									int ii_max5 = ::Math_obj::ceil(a9);
HXDLIN( 190)									v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            								}
            								else {
HXLINE( 190)									int ii_min6 = ::Math_obj::floor(b15);
HXDLIN( 190)									int ii_max6 = ::Math_obj::ceil(c7);
HXDLIN( 190)									v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            								}
            							}
            							else {
HXLINE( 190)								if ((b15 > c7)) {
HXLINE( 190)									int min2;
HXDLIN( 190)									if ((a9 > c7)) {
HXLINE( 190)										min2 = ::Math_obj::floor(c7);
            									}
            									else {
HXLINE( 190)										min2 = ::Math_obj::ceil(a9);
            									}
HXDLIN( 190)									int ii_min7 = min2;
HXDLIN( 190)									int ii_max7 = ::Math_obj::ceil(b15);
HXDLIN( 190)									v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            								}
            								else {
HXLINE( 190)									int ii_min8 = ::Math_obj::floor(a9);
HXDLIN( 190)									int ii_max8 = ::Math_obj::ceil(c7);
HXDLIN( 190)									v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            								}
            							}
HXDLIN( 190)							Float a10 = v_ay;
HXDLIN( 190)							Float b16 = v_by;
HXDLIN( 190)							Float c8 = v_cy;
HXDLIN( 190)							if ((a10 > b16)) {
HXLINE( 190)								if ((a10 > c8)) {
HXLINE( 190)									int min3;
HXDLIN( 190)									if ((b16 > c8)) {
HXLINE( 190)										min3 = ::Math_obj::floor(c8);
            									}
            									else {
HXLINE( 190)										min3 = ::Math_obj::floor(b16);
            									}
HXDLIN( 190)									int ii_min9 = min3;
HXDLIN( 190)									int ii_max9 = ::Math_obj::ceil(a10);
HXDLIN( 190)									v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            								}
            								else {
HXLINE( 190)									int ii_min10 = ::Math_obj::floor(b16);
HXDLIN( 190)									int ii_max10 = ::Math_obj::ceil(c8);
HXDLIN( 190)									v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            								}
            							}
            							else {
HXLINE( 190)								if ((b16 > c8)) {
HXLINE( 190)									int min4;
HXDLIN( 190)									if ((a10 > c8)) {
HXLINE( 190)										min4 = ::Math_obj::floor(c8);
            									}
            									else {
HXLINE( 190)										min4 = ::Math_obj::ceil(a10);
            									}
HXDLIN( 190)									int ii_min11 = min4;
HXDLIN( 190)									int ii_max11 = ::Math_obj::ceil(b16);
HXDLIN( 190)									v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            								}
            								else {
HXLINE( 190)									int ii_min12 = ::Math_obj::floor(a10);
HXDLIN( 190)									int ii_max12 = ::Math_obj::ceil(c8);
HXDLIN( 190)									v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            								}
            							}
            						}
HXDLIN( 190)						if (hasUndo) {
HXLINE( 190)							v_undoImage = undoImage;
HXDLIN( 190)							v_undoX = xIter3->start;
HXDLIN( 190)							v_undoY = yIter3->start;
            						}
HXDLIN( 190)						Float au1 = bu;
HXDLIN( 190)						Float av1 = bv;
HXDLIN( 190)						Float bu2 = cu;
HXDLIN( 190)						Float bv2 = cv;
HXDLIN( 190)						bool hasUndo1 = false;
HXDLIN( 190)						Float temp1 = au1;
HXLINE( 422)						au1 = bu2;
HXLINE( 423)						bu2 = temp1;
HXLINE( 424)						temp1 = av1;
HXLINE( 425)						av1 = bv2;
HXLINE( 426)						bv2 = temp1;
HXLINE( 190)						Float bcx1 = w1;
HXDLIN( 190)						Float bcy1 = (h - h);
HXDLIN( 190)						Float acx1 = w1;
HXDLIN( 190)						Float acy1 = (( (Float)(0) ) - h);
HXDLIN( 190)						Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN( 190)						Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN( 190)						Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN( 190)						Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN( 190)						 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 190)						if ((w1 > w1)) {
HXLINE( 190)							if ((w1 > 0)) {
HXLINE( 190)								int min5;
HXDLIN( 190)								if ((w1 > 0)) {
HXLINE( 190)									min5 = ::Math_obj::floor(( (Float)(0) ));
            								}
            								else {
HXLINE( 190)									min5 = ::Math_obj::floor(w1);
            								}
HXDLIN( 190)								int ii_min13 = min5;
HXDLIN( 190)								int ii_max13 = ::Math_obj::ceil(w1);
HXDLIN( 190)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            							}
            							else {
HXLINE( 190)								int ii_min14 = ::Math_obj::floor(w1);
HXDLIN( 190)								int ii_max14 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN( 190)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            							}
            						}
            						else {
HXLINE( 190)							if ((w1 > 0)) {
HXLINE( 190)								int min6;
HXDLIN( 190)								if ((w1 > 0)) {
HXLINE( 190)									min6 = ::Math_obj::floor(( (Float)(0) ));
            								}
            								else {
HXLINE( 190)									min6 = ::Math_obj::ceil(w1);
            								}
HXDLIN( 190)								int ii_min15 = min6;
HXDLIN( 190)								int ii_max15 = ::Math_obj::ceil(w1);
HXDLIN( 190)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            							}
            							else {
HXLINE( 190)								int ii_min16 = ::Math_obj::floor(w1);
HXDLIN( 190)								int ii_max16 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN( 190)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            							}
            						}
HXDLIN( 190)						 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 190)						if ((0 > h)) {
HXLINE( 190)							if ((0 > h)) {
HXLINE( 190)								int min7;
HXDLIN( 190)								if ((h > h)) {
HXLINE( 190)									min7 = ::Math_obj::floor(h);
            								}
            								else {
HXLINE( 190)									min7 = ::Math_obj::floor(h);
            								}
HXDLIN( 190)								int ii_min17 = min7;
HXDLIN( 190)								int ii_max17 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN( 190)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            							}
            							else {
HXLINE( 190)								int ii_min18 = ::Math_obj::floor(h);
HXDLIN( 190)								int ii_max18 = ::Math_obj::ceil(h);
HXDLIN( 190)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            							}
            						}
            						else {
HXLINE( 190)							if ((h > h)) {
HXLINE( 190)								int min8;
HXDLIN( 190)								if ((0 > h)) {
HXLINE( 190)									min8 = ::Math_obj::floor(h);
            								}
            								else {
HXLINE( 190)									min8 = ::Math_obj::ceil(( (Float)(0) ));
            								}
HXDLIN( 190)								int ii_min19 = min8;
HXDLIN( 190)								int ii_max19 = ::Math_obj::ceil(h);
HXDLIN( 190)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            							}
            							else {
HXLINE( 190)								int ii_min20 = ::Math_obj::floor(( (Float)(0) ));
HXDLIN( 190)								int ii_max20 = ::Math_obj::ceil(h);
HXDLIN( 190)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            							}
            						}
HXDLIN( 190)						 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 190)						if (hasUndo1) {
HXLINE( 190)							int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 190)							int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 190)							 ::Dynamic imageType3 = null();
HXDLIN( 190)							 ::pi_xy::ImageStruct this53 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 190)							if (::hx::IsNull( imageType3 )) {
HXLINE(  54)								imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE( 190)							::Dynamic undoImage4;
HXDLIN( 190)							switch((int)(( (int)(imageType3) ))){
            								case (int)0: {
HXLINE( 190)									 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 190)									 ::iterMagic::BytesImg b17 = byt3;
HXDLIN( 190)									{
HXLINE( 190)										b17->width = width1;
HXDLIN( 190)										b17->height = height1;
HXDLIN( 190)										b17->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 190)										b17->data = ::haxe::io::Bytes_obj::alloc((b17->length * 4));
HXDLIN( 190)										{
HXLINE( 190)											int len6 = b17->length;
HXDLIN( 190)											int w4 = 0;
HXDLIN( 190)											{
HXLINE( 190)												int _g52 = 0;
HXDLIN( 190)												int _g53 = b17->height;
HXDLIN( 190)												while((_g52 < _g53)){
HXLINE( 190)													_g52 = (_g52 + 1);
HXDLIN( 190)													int y7 = (_g52 - 1);
HXDLIN( 190)													{
HXLINE( 190)														int _g54 = 0;
HXDLIN( 190)														int _g55 = b17->width;
HXDLIN( 190)														while((_g54 < _g55)){
HXLINE( 190)															_g54 = (_g54 + 1);
HXDLIN( 190)															int x8 = (_g54 - 1);
HXDLIN( 190)															{
HXLINE( 190)																w4 = (w4 + 1);
HXDLIN( 190)																b17->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 190)															{
HXLINE( 190)																w4 = (w4 + 1);
HXDLIN( 190)																b17->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 190)															{
HXLINE( 190)																w4 = (w4 + 1);
HXDLIN( 190)																b17->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN( 190)															{
HXLINE( 190)																w4 = (w4 + 1);
HXDLIN( 190)																b17->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 190)									undoImage4 = b17;
            								}
            								break;
            								case (int)1: {
HXLINE( 190)									 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 190)									 ::iterMagic::ArrIntImg a13 = arrI3;
HXDLIN( 190)									{
HXLINE( 190)										a13->width = width1;
HXDLIN( 190)										a13->height = height1;
HXDLIN( 190)										a13->data = ::Array_obj< int >::__new(0);
HXDLIN( 190)										a13->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 190)										{
HXLINE( 190)											int _g56 = 0;
HXDLIN( 190)											int _g57 = a13->length;
HXDLIN( 190)											while((_g56 < _g57)){
HXLINE( 190)												_g56 = (_g56 + 1);
HXDLIN( 190)												int i18 = (_g56 - 1);
HXDLIN( 190)												a13->data[i18] = 0;
            											}
            										}
            									}
HXDLIN( 190)									undoImage4 = a13;
            								}
            								break;
            								case (int)2: {
HXLINE( 190)									 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 190)									 ::iterMagic::U32ArrImg b18 = u32a3;
HXDLIN( 190)									{
HXLINE( 190)										b18->width = width1;
HXDLIN( 190)										b18->height = height1;
HXDLIN( 190)										b18->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 190)										int size3 = (b18->length * 4);
HXDLIN( 190)										b18->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN( 190)										{
HXLINE( 190)											int _g58 = 0;
HXDLIN( 190)											int _g59 = b18->length;
HXDLIN( 190)											while((_g58 < _g59)){
HXLINE( 190)												_g58 = (_g58 + 1);
HXDLIN( 190)												int i19 = (_g58 - 1);
HXDLIN( 190)												{
HXLINE( 190)													 ::haxe::io::ArrayBufferViewImpl this54 = b18->data;
HXDLIN( 190)													bool undoImage5;
HXDLIN( 190)													if ((i19 >= 0)) {
HXLINE( 190)														undoImage5 = (i19 < (this54->byteLength >> 2));
            													}
            													else {
HXLINE( 190)														undoImage5 = false;
            													}
HXDLIN( 190)													if (undoImage5) {
HXLINE( 190)														 ::haxe::io::Bytes _this3 = this54->bytes;
HXDLIN( 190)														int pos3 = ((i19 << 2) + this54->byteOffset);
HXDLIN( 190)														_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN( 190)														_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN( 190)														_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN( 190)														_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN( 190)									undoImage4 = b18;
            								}
            								break;
            								case (int)3: {
HXLINE( 190)									 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 190)									 ::iterMagic::VecIntImg v7 = vec3;
HXDLIN( 190)									{
HXLINE( 190)										v7->width = width1;
HXDLIN( 190)										v7->height = height1;
HXDLIN( 190)										v7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 190)										v7->data = ::Array_obj< int >::__new(v7->length);
HXDLIN( 190)										{
HXLINE( 190)											int _g60 = 0;
HXDLIN( 190)											int _g61 = v7->length;
HXDLIN( 190)											while((_g60 < _g61)){
HXLINE( 190)												_g60 = (_g60 + 1);
HXDLIN( 190)												int i20 = (_g60 - 1);
HXDLIN( 190)												v7->data->__unsafe_set(i20,0);
            											}
            										}
            									}
HXDLIN( 190)									undoImage4 = v7;
            								}
            								break;
            								case (int)4: {
HXLINE( 190)									 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 190)									 ::iterMagic::StackIntImg b19 = sInt3;
HXDLIN( 190)									{
HXLINE( 190)										b19->width = width1;
HXDLIN( 190)										b19->height = height1;
HXDLIN( 190)										b19->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 190)										b19->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 190)										{
HXLINE( 190)											int len7 = b19->length;
HXDLIN( 190)											 ::haxe::ds::GenericStack_Int d3 = b19->data;
HXDLIN( 190)											if (::hx::IsNull( d3->head )) {
HXLINE( 190)												int _g62 = 0;
HXDLIN( 190)												int _g63 = len7;
HXDLIN( 190)												while((_g62 < _g63)){
HXLINE( 190)													_g62 = (_g62 + 1);
HXDLIN( 190)													int i21 = (_g62 - 1);
HXDLIN( 190)													d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            												}
            											}
            											else {
HXLINE( 190)												int _g64 = 0;
HXDLIN( 190)												int _g65 = len7;
HXDLIN( 190)												while((_g64 < _g65)){
HXLINE( 190)													_g64 = (_g64 + 1);
HXDLIN( 190)													int i22 = (_g64 - 1);
HXDLIN( 190)													{
HXLINE( 190)														 ::haxe::ds::GenericCell_Int l3 = b19->data->head;
HXDLIN( 190)														 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN( 190)														{
HXLINE( 190)															int _g66 = 0;
HXDLIN( 190)															int _g67 = i22;
HXDLIN( 190)															while((_g66 < _g67)){
HXLINE( 190)																_g66 = (_g66 + 1);
HXDLIN( 190)																int i23 = (_g66 - 1);
HXLINE( 345)																prev3 = l3;
HXLINE( 346)																l3 = l3->next;
            															}
            														}
HXLINE( 190)														if (::hx::IsNull( prev3 )) {
HXLINE( 190)															b19->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 190)															l3 = null();
            														}
            														else {
HXLINE( 190)															prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN( 190)															l3 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 190)									undoImage4 = b19;
            								}
            								break;
            							}
HXDLIN( 190)							this53->image = undoImage4;
HXDLIN( 190)							this53->width = width1;
HXDLIN( 190)							this53->height = height1;
HXDLIN( 190)							this53->imageType = ( (int)(imageType3) );
HXDLIN( 190)							undoImage3 = this53;
HXDLIN( 190)							{
HXLINE( 190)								int rectLeft1 = xIter31->start;
HXDLIN( 190)								int rectTop1 = yIter31->start;
HXDLIN( 190)								int rectRight1 = xIter31->max;
HXDLIN( 190)								bool forceClear1 = false;
HXDLIN( 190)								{
HXLINE( 190)									int _g68 = rectTop1;
HXDLIN( 190)									int _g69 = yIter31->max;
HXDLIN( 190)									while((_g68 < _g69)){
HXLINE( 190)										_g68 = (_g68 + 1);
HXDLIN( 190)										int dy1 = (_g68 - 1);
HXDLIN( 190)										{
HXLINE( 190)											int _g70 = rectLeft1;
HXDLIN( 190)											int _g71 = rectRight1;
HXDLIN( 190)											while((_g70 < _g71)){
HXLINE( 190)												_g70 = (_g70 + 1);
HXDLIN( 190)												int dx1 = (_g70 - 1);
HXDLIN( 190)												::Dynamic this55 = this18->image;
HXDLIN( 190)												int index8;
HXDLIN( 190)												if (this18->useVirtualPos) {
HXLINE( 190)													index8 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this18->virtualY) * ( (Float)(this18->width) )) + dx1) - this18->virtualX));
            												}
            												else {
HXLINE( 190)													index8 = ::Std_obj::_hx_int(( (Float)(((dy1 * this18->width) + dx1)) ));
            												}
HXDLIN( 190)												int c9 = ::iterMagic::Iimg_obj::get(this55,index8);
HXDLIN( 190)												int col2;
HXDLIN( 190)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 190)													col2 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            												}
            												else {
HXLINE( 190)													col2 = c9;
            												}
HXDLIN( 190)												bool pixelImage18;
HXDLIN( 190)												if (this18->useMask) {
HXLINE( 190)													pixelImage18 = ::hx::IsNotNull( this18->mask );
            												}
            												else {
HXLINE( 190)													pixelImage18 = false;
            												}
HXDLIN( 190)												if (pixelImage18) {
HXLINE( 190)													 ::pi_xy::ImageStruct this56 = this18->mask;
HXDLIN( 190)													::Dynamic this57 = this56->image;
HXDLIN( 190)													int index9;
HXDLIN( 190)													if (this56->useVirtualPos) {
HXLINE( 190)														index9 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this56->virtualY) * ( (Float)(this56->width) )) + dx1) - this56->virtualX));
            													}
            													else {
HXLINE( 190)														index9 = ::Std_obj::_hx_int(( (Float)(((dy1 * this56->width) + dx1)) ));
            													}
HXDLIN( 190)													int c10 = ::iterMagic::Iimg_obj::get(this57,index9);
HXDLIN( 190)													int v8;
HXDLIN( 190)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 190)														v8 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            													}
            													else {
HXLINE( 190)														v8 = c10;
            													}
HXDLIN( 190)													int maskPixel1 = v8;
HXDLIN( 190)													int this58 = col2;
HXDLIN( 190)													if ((maskPixel1 == 0)) {
HXLINE( 190)														col2 = this58;
            													}
            													else {
HXLINE( 190)														Float m01;
HXDLIN( 190)														int this59 = ((maskPixel1 >> 24) & 255);
HXDLIN( 190)														if ((this59 == 0)) {
HXLINE( 190)															m01 = ((Float)0.);
            														}
            														else {
HXLINE( 190)															m01 = (( (Float)(this59) ) / ( (Float)(255) ));
            														}
HXDLIN( 190)														Float m11;
HXDLIN( 190)														int this60 = ((maskPixel1 >> 16) & 255);
HXDLIN( 190)														if ((this60 == 0)) {
HXLINE( 190)															m11 = ((Float)0.);
            														}
            														else {
HXLINE( 190)															m11 = (( (Float)(this60) ) / ( (Float)(255) ));
            														}
HXDLIN( 190)														Float m21;
HXDLIN( 190)														int this61 = ((maskPixel1 >> 8) & 255);
HXDLIN( 190)														if ((this61 == 0)) {
HXLINE( 190)															m21 = ((Float)0.);
            														}
            														else {
HXLINE( 190)															m21 = (( (Float)(this61) ) / ( (Float)(255) ));
            														}
HXDLIN( 190)														Float m31;
HXDLIN( 190)														int this62 = (maskPixel1 & 255);
HXDLIN( 190)														if ((this62 == 0)) {
HXLINE( 190)															m31 = ((Float)0.);
            														}
            														else {
HXLINE( 190)															m31 = (( (Float)(this62) ) / ( (Float)(255) ));
            														}
HXDLIN( 190)														int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this58 >> 24) & 255)) )));
HXDLIN( 190)														int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this58 >> 16) & 255)) )));
HXDLIN( 190)														int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this58 >> 8) & 255)) )));
HXDLIN( 190)														int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this58 & 255)) )));
HXDLIN( 190)														col2 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN( 190)												if ((col2 != 0)) {
HXLINE( 190)													int x9 = (dx1 - rectLeft1);
HXDLIN( 190)													int y8 = (dy1 - rectTop1);
HXDLIN( 190)													int c11 = col2;
HXDLIN( 190)													bool pixelImage19;
HXDLIN( 190)													if ((((c11 >> 24) & 255) < 254)) {
HXLINE( 190)														pixelImage19 = undoImage3->transparent;
            													}
            													else {
HXLINE( 190)														pixelImage19 = false;
            													}
HXDLIN( 190)													if (pixelImage19) {
HXLINE( 190)														int location3;
HXDLIN( 190)														if (undoImage3->useVirtualPos) {
HXLINE( 190)															location3 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x9) - undoImage3->virtualX));
            														}
            														else {
HXLINE( 190)															location3 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage3->width) + x9)) ));
            														}
HXDLIN( 190)														int this63 = ::iterMagic::Iimg_obj::get(undoImage3->image,location3);
HXDLIN( 190)														int this64;
HXDLIN( 190)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 190)															this64 = ((((((this63 >> 24) & 255) << 24) | ((this63 & 255) << 16)) | (((this63 >> 8) & 255) << 8)) | ((this63 >> 16) & 255));
            														}
            														else {
HXLINE( 190)															this64 = this63;
            														}
HXDLIN( 190)														Float a14;
HXDLIN( 190)														int this65 = ((this64 >> 24) & 255);
HXDLIN( 190)														if ((this65 == 0)) {
HXLINE( 190)															a14 = ((Float)0.);
            														}
            														else {
HXLINE( 190)															a14 = (( (Float)(this65) ) / ( (Float)(255) ));
            														}
HXDLIN( 190)														Float r13;
HXDLIN( 190)														int this66 = ((this64 >> 16) & 255);
HXDLIN( 190)														if ((this66 == 0)) {
HXLINE( 190)															r13 = ((Float)0.);
            														}
            														else {
HXLINE( 190)															r13 = (( (Float)(this66) ) / ( (Float)(255) ));
            														}
HXDLIN( 190)														Float g13;
HXDLIN( 190)														int this67 = ((this64 >> 8) & 255);
HXDLIN( 190)														if ((this67 == 0)) {
HXLINE( 190)															g13 = ((Float)0.);
            														}
            														else {
HXLINE( 190)															g13 = (( (Float)(this67) ) / ( (Float)(255) ));
            														}
HXDLIN( 190)														Float b110;
HXDLIN( 190)														int this68 = (this64 & 255);
HXDLIN( 190)														if ((this68 == 0)) {
HXLINE( 190)															b110 = ((Float)0.);
            														}
            														else {
HXLINE( 190)															b110 = (( (Float)(this68) ) / ( (Float)(255) ));
            														}
HXDLIN( 190)														Float a23;
HXDLIN( 190)														int this69 = ((col2 >> 24) & 255);
HXDLIN( 190)														if ((this69 == 0)) {
HXLINE( 190)															a23 = ((Float)0.);
            														}
            														else {
HXLINE( 190)															a23 = (( (Float)(this69) ) / ( (Float)(255) ));
            														}
HXDLIN( 190)														Float r23;
HXDLIN( 190)														int this70 = ((col2 >> 16) & 255);
HXDLIN( 190)														if ((this70 == 0)) {
HXLINE( 190)															r23 = ((Float)0.);
            														}
            														else {
HXLINE( 190)															r23 = (( (Float)(this70) ) / ( (Float)(255) ));
            														}
HXDLIN( 190)														Float g23;
HXDLIN( 190)														int this71 = ((col2 >> 8) & 255);
HXDLIN( 190)														if ((this71 == 0)) {
HXLINE( 190)															g23 = ((Float)0.);
            														}
            														else {
HXLINE( 190)															g23 = (( (Float)(this71) ) / ( (Float)(255) ));
            														}
HXDLIN( 190)														Float b24;
HXDLIN( 190)														int this72 = (col2 & 255);
HXDLIN( 190)														if ((this72 == 0)) {
HXLINE( 190)															b24 = ((Float)0.);
            														}
            														else {
HXLINE( 190)															b24 = (( (Float)(this72) ) / ( (Float)(255) ));
            														}
HXDLIN( 190)														Float a33 = (a14 * (( (Float)(1) ) - a23));
HXDLIN( 190)														int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 190)														int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 190)														int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a33) + (b24 * a23))));
HXDLIN( 190)														int a15 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 190)														int blended3 = ((((a15 << 24) | (r6 << 16)) | (g5 << 8)) | b20);
HXDLIN( 190)														{
HXLINE( 190)															int pixelImage20;
HXDLIN( 190)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 190)																pixelImage20 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            															}
            															else {
HXLINE( 190)																pixelImage20 = blended3;
            															}
HXDLIN( 190)															::iterMagic::Iimg_obj::set(undoImage3->image,location3,pixelImage20);
            														}
            													}
            													else {
HXLINE( 190)														::Dynamic this73 = undoImage3->image;
HXDLIN( 190)														int index10;
HXDLIN( 190)														if (undoImage3->useVirtualPos) {
HXLINE( 190)															index10 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x9) - undoImage3->virtualX));
            														}
            														else {
HXLINE( 190)															index10 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage3->width) + x9)) ));
            														}
HXDLIN( 190)														int pixelImage21;
HXDLIN( 190)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 190)															pixelImage21 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            														}
            														else {
HXLINE( 190)															pixelImage21 = c11;
            														}
HXDLIN( 190)														::iterMagic::Iimg_obj::set(this73,index10,pixelImage21);
            													}
            												}
            												else {
HXLINE( 190)													if (forceClear1) {
HXLINE( 190)														::Dynamic this74 = undoImage3->image;
HXDLIN( 190)														int x10 = (dx1 - rectLeft1);
HXDLIN( 190)														int y9 = (dy1 - rectTop1);
HXDLIN( 190)														int index11;
HXDLIN( 190)														if (undoImage3->useVirtualPos) {
HXLINE( 190)															index11 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x10) - undoImage3->virtualX));
            														}
            														else {
HXLINE( 190)															index11 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage3->width) + x10)) ));
            														}
HXDLIN( 190)														::iterMagic::Iimg_obj::set(this74,index11,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 190)						{
HXLINE( 190)							int _g_min2 = xIter31->start;
HXDLIN( 190)							int _g_max2 = xIter31->max;
HXDLIN( 190)							while((_g_min2 < _g_max2)){
HXLINE( 190)								_g_min2 = (_g_min2 + 1);
HXDLIN( 190)								int px1 = (_g_min2 - 1);
HXDLIN( 190)								Float pcx1 = ( (Float)(px1) );
HXDLIN( 190)								{
HXLINE( 190)									int _g_min3 = yIter31->start;
HXDLIN( 190)									int _g_max3 = yIter31->max;
HXDLIN( 190)									while((_g_min3 < _g_max3)){
HXLINE( 190)										_g_min3 = (_g_min3 + 1);
HXDLIN( 190)										int py1 = (_g_min3 - 1);
HXDLIN( 190)										Float pcy1 = (( (Float)(py1) ) - h);
HXDLIN( 190)										Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN( 190)										Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN( 190)										Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN( 190)										Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN( 190)										Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN( 190)										bool pixelImage22;
HXDLIN( 190)										bool pixelImage23;
HXDLIN( 190)										if ((ratioA1 >= 0)) {
HXLINE( 190)											pixelImage23 = (ratioB1 >= 0);
            										}
            										else {
HXLINE( 190)											pixelImage23 = false;
            										}
HXDLIN( 190)										if (pixelImage23) {
HXLINE( 190)											pixelImage22 = (ratioC1 >= 0);
            										}
            										else {
HXLINE( 190)											pixelImage22 = false;
            										}
HXDLIN( 190)										if (pixelImage22) {
HXLINE( 190)											Float u1 = (((au1 * ratioA1) + (bu2 * ratioB1)) + (du * ratioC1));
HXDLIN( 190)											Float v9 = (((av1 * ratioA1) + (bv2 * ratioB1)) + (dv * ratioC1));
HXDLIN( 190)											int x11 = ::Std_obj::_hx_int(((u1 * win_width) + win_x));
HXDLIN( 190)											int y10 = ::Std_obj::_hx_int(((v9 * win_height) + win_y));
HXDLIN( 190)											::Dynamic this75 = thisImage->image;
HXDLIN( 190)											int index12;
HXDLIN( 190)											if (thisImage->useVirtualPos) {
HXLINE( 190)												index12 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - thisImage->virtualY) * ( (Float)(thisImage->width) )) + x11) - thisImage->virtualX));
            											}
            											else {
HXLINE( 190)												index12 = ::Std_obj::_hx_int(( (Float)(((y10 * thisImage->width) + x11)) ));
            											}
HXDLIN( 190)											int c12 = ::iterMagic::Iimg_obj::get(this75,index12);
HXDLIN( 190)											int col3;
HXDLIN( 190)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 190)												col3 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            											}
            											else {
HXLINE( 190)												col3 = c12;
            											}
HXDLIN( 190)											{
HXLINE( 190)												int c13 = col3;
HXDLIN( 190)												bool pixelImage24;
HXDLIN( 190)												if ((((c13 >> 24) & 255) < 254)) {
HXLINE( 190)													pixelImage24 = this18->transparent;
            												}
            												else {
HXLINE( 190)													pixelImage24 = false;
            												}
HXDLIN( 190)												if (pixelImage24) {
HXLINE( 190)													int location4;
HXDLIN( 190)													if (this18->useVirtualPos) {
HXLINE( 190)														location4 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this18->virtualY) * ( (Float)(this18->width) )) + px1) - this18->virtualX));
            													}
            													else {
HXLINE( 190)														location4 = ::Std_obj::_hx_int(( (Float)(((py1 * this18->width) + px1)) ));
            													}
HXDLIN( 190)													int this76 = ::iterMagic::Iimg_obj::get(this18->image,location4);
HXDLIN( 190)													int this77;
HXDLIN( 190)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 190)														this77 = ((((((this76 >> 24) & 255) << 24) | ((this76 & 255) << 16)) | (((this76 >> 8) & 255) << 8)) | ((this76 >> 16) & 255));
            													}
            													else {
HXLINE( 190)														this77 = this76;
            													}
HXDLIN( 190)													Float a16;
HXDLIN( 190)													int this78 = ((this77 >> 24) & 255);
HXDLIN( 190)													if ((this78 == 0)) {
HXLINE( 190)														a16 = ((Float)0.);
            													}
            													else {
HXLINE( 190)														a16 = (( (Float)(this78) ) / ( (Float)(255) ));
            													}
HXDLIN( 190)													Float r14;
HXDLIN( 190)													int this79 = ((this77 >> 16) & 255);
HXDLIN( 190)													if ((this79 == 0)) {
HXLINE( 190)														r14 = ((Float)0.);
            													}
            													else {
HXLINE( 190)														r14 = (( (Float)(this79) ) / ( (Float)(255) ));
            													}
HXDLIN( 190)													Float g14;
HXDLIN( 190)													int this80 = ((this77 >> 8) & 255);
HXDLIN( 190)													if ((this80 == 0)) {
HXLINE( 190)														g14 = ((Float)0.);
            													}
            													else {
HXLINE( 190)														g14 = (( (Float)(this80) ) / ( (Float)(255) ));
            													}
HXDLIN( 190)													Float b111;
HXDLIN( 190)													int this81 = (this77 & 255);
HXDLIN( 190)													if ((this81 == 0)) {
HXLINE( 190)														b111 = ((Float)0.);
            													}
            													else {
HXLINE( 190)														b111 = (( (Float)(this81) ) / ( (Float)(255) ));
            													}
HXDLIN( 190)													Float a24;
HXDLIN( 190)													int this82 = ((col3 >> 24) & 255);
HXDLIN( 190)													if ((this82 == 0)) {
HXLINE( 190)														a24 = ((Float)0.);
            													}
            													else {
HXLINE( 190)														a24 = (( (Float)(this82) ) / ( (Float)(255) ));
            													}
HXDLIN( 190)													Float r24;
HXDLIN( 190)													int this83 = ((col3 >> 16) & 255);
HXDLIN( 190)													if ((this83 == 0)) {
HXLINE( 190)														r24 = ((Float)0.);
            													}
            													else {
HXLINE( 190)														r24 = (( (Float)(this83) ) / ( (Float)(255) ));
            													}
HXDLIN( 190)													Float g24;
HXDLIN( 190)													int this84 = ((col3 >> 8) & 255);
HXDLIN( 190)													if ((this84 == 0)) {
HXLINE( 190)														g24 = ((Float)0.);
            													}
            													else {
HXLINE( 190)														g24 = (( (Float)(this84) ) / ( (Float)(255) ));
            													}
HXDLIN( 190)													Float b25;
HXDLIN( 190)													int this85 = (col3 & 255);
HXDLIN( 190)													if ((this85 == 0)) {
HXLINE( 190)														b25 = ((Float)0.);
            													}
            													else {
HXLINE( 190)														b25 = (( (Float)(this85) ) / ( (Float)(255) ));
            													}
HXDLIN( 190)													Float a34 = (a16 * (( (Float)(1) ) - a24));
HXDLIN( 190)													int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN( 190)													int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN( 190)													int b26 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a34) + (b25 * a24))));
HXDLIN( 190)													int a17 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN( 190)													int blended4 = ((((a17 << 24) | (r7 << 16)) | (g6 << 8)) | b26);
HXDLIN( 190)													{
HXLINE( 190)														int pixelImage25;
HXDLIN( 190)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 190)															pixelImage25 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            														}
            														else {
HXLINE( 190)															pixelImage25 = blended4;
            														}
HXDLIN( 190)														::iterMagic::Iimg_obj::set(this18->image,location4,pixelImage25);
            													}
            												}
            												else {
HXLINE( 190)													::Dynamic this86 = this18->image;
HXDLIN( 190)													int index13;
HXDLIN( 190)													if (this18->useVirtualPos) {
HXLINE( 190)														index13 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this18->virtualY) * ( (Float)(this18->width) )) + px1) - this18->virtualX));
            													}
            													else {
HXLINE( 190)														index13 = ::Std_obj::_hx_int(( (Float)(((py1 * this18->width) + px1)) ));
            													}
HXDLIN( 190)													int pixelImage26;
HXDLIN( 190)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 190)														pixelImage26 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            													}
            													else {
HXLINE( 190)														pixelImage26 = c13;
            													}
HXDLIN( 190)													::iterMagic::Iimg_obj::set(this86,index13,pixelImage26);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN( 190)						 ::pi_xy::iter::IntIterStart v_yIter31;
HXDLIN( 190)						 ::pi_xy::iter::IntIterStart v_xIter31;
HXDLIN( 190)						int v_undoY1;
HXDLIN( 190)						int v_undoX1;
HXDLIN( 190)						Float v_ty1;
HXDLIN( 190)						Float v_tx1;
HXDLIN( 190)						Float v_t01;
HXDLIN( 190)						Float v_sy1;
HXDLIN( 190)						Float v_sx1;
HXDLIN( 190)						Float v_s01;
HXDLIN( 190)						Float v_A1;
HXDLIN( 190)						Float ax = w1;
HXDLIN( 190)						 ::pi_xy::ImageStruct v_undoImage1 = null();
HXDLIN( 190)						Float bx1 = w1;
HXDLIN( 190)						Float by1 = h;
HXDLIN( 190)						Float cx1 = ( (Float)(0) );
HXDLIN( 190)						Float cy1 = h;
HXDLIN( 190)						bool adjustWinding1 = (((((ax * by1) - (bx1 * ( (Float)(0) ))) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ( (Float)(0) )) - (ax * cy1))) > 0);
HXDLIN( 190)						if (!(adjustWinding1)) {
HXLINE( 190)							Float bx_1 = bx1;
HXDLIN( 190)							Float by_1 = by1;
HXLINE(  24)							bx1 = cx1;
HXLINE(  25)							by1 = cy1;
HXLINE(  26)							cx1 = bx_1;
HXLINE(  27)							cy1 = by_1;
            						}
HXLINE( 190)						Float v_ax1 = ax;
HXDLIN( 190)						Float v_ay1 = ( (Float)(0) );
HXDLIN( 190)						Float v_bx1 = bx1;
HXDLIN( 190)						Float v_by1 = by1;
HXDLIN( 190)						Float v_cx1 = cx1;
HXDLIN( 190)						Float v_cy1 = cy1;
HXDLIN( 190)						bool v_preCalculated1 = true;
HXDLIN( 190)						{
HXLINE( 190)							v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN( 190)							v_sx1 = (v_cy1 - v_ay1);
HXDLIN( 190)							v_sy1 = (v_ax1 - v_cx1);
HXDLIN( 190)							v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN( 190)							v_tx1 = (v_ay1 - v_by1);
HXDLIN( 190)							v_ty1 = (v_bx1 - v_ax1);
HXDLIN( 190)							v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN( 190)							Float a18 = v_ax1;
HXDLIN( 190)							Float b27 = v_bx1;
HXDLIN( 190)							Float c14 = v_cx1;
HXDLIN( 190)							if ((a18 > b27)) {
HXLINE( 190)								if ((a18 > c14)) {
HXLINE( 190)									int min9;
HXDLIN( 190)									if ((b27 > c14)) {
HXLINE( 190)										min9 = ::Math_obj::floor(c14);
            									}
            									else {
HXLINE( 190)										min9 = ::Math_obj::floor(b27);
            									}
HXDLIN( 190)									int ii_min21 = min9;
HXDLIN( 190)									int ii_max21 = ::Math_obj::ceil(a18);
HXDLIN( 190)									v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            								}
            								else {
HXLINE( 190)									int ii_min22 = ::Math_obj::floor(b27);
HXDLIN( 190)									int ii_max22 = ::Math_obj::ceil(c14);
HXDLIN( 190)									v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            								}
            							}
            							else {
HXLINE( 190)								if ((b27 > c14)) {
HXLINE( 190)									int min10;
HXDLIN( 190)									if ((a18 > c14)) {
HXLINE( 190)										min10 = ::Math_obj::floor(c14);
            									}
            									else {
HXLINE( 190)										min10 = ::Math_obj::ceil(a18);
            									}
HXDLIN( 190)									int ii_min23 = min10;
HXDLIN( 190)									int ii_max23 = ::Math_obj::ceil(b27);
HXDLIN( 190)									v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            								}
            								else {
HXLINE( 190)									int ii_min24 = ::Math_obj::floor(a18);
HXDLIN( 190)									int ii_max24 = ::Math_obj::ceil(c14);
HXDLIN( 190)									v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            								}
            							}
HXDLIN( 190)							Float a19 = v_ay1;
HXDLIN( 190)							Float b28 = v_by1;
HXDLIN( 190)							Float c15 = v_cy1;
HXDLIN( 190)							if ((a19 > b28)) {
HXLINE( 190)								if ((a19 > c15)) {
HXLINE( 190)									int min11;
HXDLIN( 190)									if ((b28 > c15)) {
HXLINE( 190)										min11 = ::Math_obj::floor(c15);
            									}
            									else {
HXLINE( 190)										min11 = ::Math_obj::floor(b28);
            									}
HXDLIN( 190)									int ii_min25 = min11;
HXDLIN( 190)									int ii_max25 = ::Math_obj::ceil(a19);
HXDLIN( 190)									v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            								}
            								else {
HXLINE( 190)									int ii_min26 = ::Math_obj::floor(b28);
HXDLIN( 190)									int ii_max26 = ::Math_obj::ceil(c15);
HXDLIN( 190)									v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            								}
            							}
            							else {
HXLINE( 190)								if ((b28 > c15)) {
HXLINE( 190)									int min12;
HXDLIN( 190)									if ((a19 > c15)) {
HXLINE( 190)										min12 = ::Math_obj::floor(c15);
            									}
            									else {
HXLINE( 190)										min12 = ::Math_obj::ceil(a19);
            									}
HXDLIN( 190)									int ii_min27 = min12;
HXDLIN( 190)									int ii_max27 = ::Math_obj::ceil(b28);
HXDLIN( 190)									v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            								}
            								else {
HXLINE( 190)									int ii_min28 = ::Math_obj::floor(a19);
HXDLIN( 190)									int ii_max28 = ::Math_obj::ceil(c15);
HXDLIN( 190)									v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            								}
            							}
            						}
HXDLIN( 190)						if (hasUndo1) {
HXLINE( 190)							v_undoImage1 = undoImage3;
HXDLIN( 190)							v_undoX1 = xIter31->start;
HXDLIN( 190)							v_undoY1 = yIter31->start;
            						}
            					}
            				}
HXDLIN( 190)				bool pixelImage27;
HXDLIN( 190)				if (::hx::IsNotNull( thisImage->mask )) {
HXLINE( 190)					pixelImage27 = false;
            				}
            				else {
HXLINE( 190)					pixelImage27 = false;
            				}
HXDLIN( 190)				if (pixelImage27) {
HXLINE( 190)					 ::pi_xy::ImageStruct v10 = ::pi_xy::transformation::_ScaleImage::ScaleImage_Fields__obj::scalingXY(thisImage->mask,( (Float)(sx) ),( (Float)(sy) ),thisImage->mask->transparent,false);
HXDLIN( 190)					nextImage1->useMask = true;
HXDLIN( 190)					nextImage1->mask = v10;
            				}
HXDLIN( 190)				pixelImage = nextImage1;
            			}
HXLINE( 191)			this1->image = pixelImage->image;
HXLINE( 192)			this1->width = pixelImage->width;
HXLINE( 193)			this1->height = pixelImage->height;
HXLINE( 194)			if (::hx::IsNotNull( this1->mask )) {
HXLINE( 195)				::pi_xy::_Pixelimage::Pixelimage_Impl__obj::set_rectWindow(this1->mask,r);
            			}
            		}
HXLINE( 197)		return r;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Pixelimage_Impl__obj,set_rectWindow,return )

int Pixelimage_Impl__obj::pos4( ::pi_xy::ImageStruct this1,int x,int y, ::Dynamic __o_off){
            		 ::Dynamic off = __o_off;
            		if (::hx::IsNull(__o_off)) off = 0;
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_204_pos4)
HXDLIN( 204)		int _hx_tmp;
HXDLIN( 204)		if (this1->useVirtualPos) {
HXDLIN( 204)			_hx_tmp = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            		}
            		else {
HXDLIN( 204)			_hx_tmp = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            		}
HXDLIN( 204)		return (::Std_obj::_hx_int(( (Float)((_hx_tmp * 4)) )) + off);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Pixelimage_Impl__obj,pos4,return )

int Pixelimage_Impl__obj::position( ::pi_xy::ImageStruct this1,int x,int y){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_210_position)
HXDLIN( 210)		if (this1->useVirtualPos) {
HXDLIN( 210)			return ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            		}
            		else {
HXLINE( 211)			return ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            		}
HXLINE( 210)		return 0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Pixelimage_Impl__obj,position,return )

int Pixelimage_Impl__obj::setPixel( ::pi_xy::ImageStruct this1,int x,int y,int color){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_264_setPixel)
HXDLIN( 264)		int c = color;
HXDLIN( 264)		bool _hx_tmp;
HXDLIN( 264)		if ((((c >> 24) & 255) < 254)) {
HXDLIN( 264)			_hx_tmp = this1->transparent;
            		}
            		else {
HXDLIN( 264)			_hx_tmp = false;
            		}
HXDLIN( 264)		if (_hx_tmp) {
HXDLIN( 264)			int location;
HXDLIN( 264)			if (this1->useVirtualPos) {
HXDLIN( 264)				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            			}
            			else {
HXDLIN( 264)				location = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            			}
HXDLIN( 264)			int this2 = ::iterMagic::Iimg_obj::get(this1->image,location);
HXDLIN( 264)			int this3;
HXDLIN( 264)			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 264)				this3 = ((((((this2 >> 24) & 255) << 24) | ((this2 & 255) << 16)) | (((this2 >> 8) & 255) << 8)) | ((this2 >> 16) & 255));
            			}
            			else {
HXDLIN( 264)				this3 = this2;
            			}
HXDLIN( 264)			Float a1;
HXDLIN( 264)			int this4 = ((this3 >> 24) & 255);
HXDLIN( 264)			if ((this4 == 0)) {
HXDLIN( 264)				a1 = ((Float)0.);
            			}
            			else {
HXDLIN( 264)				a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            			}
HXDLIN( 264)			Float r1;
HXDLIN( 264)			int this5 = ((this3 >> 16) & 255);
HXDLIN( 264)			if ((this5 == 0)) {
HXDLIN( 264)				r1 = ((Float)0.);
            			}
            			else {
HXDLIN( 264)				r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            			}
HXDLIN( 264)			Float g1;
HXDLIN( 264)			int this6 = ((this3 >> 8) & 255);
HXDLIN( 264)			if ((this6 == 0)) {
HXDLIN( 264)				g1 = ((Float)0.);
            			}
            			else {
HXDLIN( 264)				g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            			}
HXDLIN( 264)			Float b1;
HXDLIN( 264)			int this7 = (this3 & 255);
HXDLIN( 264)			if ((this7 == 0)) {
HXDLIN( 264)				b1 = ((Float)0.);
            			}
            			else {
HXDLIN( 264)				b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            			}
HXDLIN( 264)			Float a2;
HXDLIN( 264)			int this8 = ((color >> 24) & 255);
HXDLIN( 264)			if ((this8 == 0)) {
HXDLIN( 264)				a2 = ((Float)0.);
            			}
            			else {
HXDLIN( 264)				a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            			}
HXDLIN( 264)			Float r2;
HXDLIN( 264)			int this9 = ((color >> 16) & 255);
HXDLIN( 264)			if ((this9 == 0)) {
HXDLIN( 264)				r2 = ((Float)0.);
            			}
            			else {
HXDLIN( 264)				r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            			}
HXDLIN( 264)			Float g2;
HXDLIN( 264)			int this10 = ((color >> 8) & 255);
HXDLIN( 264)			if ((this10 == 0)) {
HXDLIN( 264)				g2 = ((Float)0.);
            			}
            			else {
HXDLIN( 264)				g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            			}
HXDLIN( 264)			Float b2;
HXDLIN( 264)			int this11 = (color & 255);
HXDLIN( 264)			if ((this11 == 0)) {
HXDLIN( 264)				b2 = ((Float)0.);
            			}
            			else {
HXDLIN( 264)				b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            			}
HXDLIN( 264)			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 264)			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 264)			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 264)			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 264)			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 264)			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 264)			{
HXDLIN( 264)				int _hx_tmp1;
HXDLIN( 264)				if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 264)					_hx_tmp1 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            				}
            				else {
HXDLIN( 264)					_hx_tmp1 = blended;
            				}
HXDLIN( 264)				::iterMagic::Iimg_obj::set(this1->image,location,_hx_tmp1);
            			}
            		}
            		else {
HXDLIN( 264)			::Dynamic this12 = this1->image;
HXDLIN( 264)			int index;
HXDLIN( 264)			if (this1->useVirtualPos) {
HXDLIN( 264)				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            			}
            			else {
HXDLIN( 264)				index = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            			}
HXDLIN( 264)			int _hx_tmp2;
HXDLIN( 264)			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 264)				_hx_tmp2 = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            			}
            			else {
HXDLIN( 264)				_hx_tmp2 = c;
            			}
HXDLIN( 264)			::iterMagic::Iimg_obj::set(this12,index,_hx_tmp2);
            		}
HXDLIN( 264)		return color;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Pixelimage_Impl__obj,setPixel,return )

void Pixelimage_Impl__obj::zeroPixel( ::pi_xy::ImageStruct this1,int x,int y){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_271_zeroPixel)
HXDLIN( 271)		::Dynamic this2 = this1->image;
HXDLIN( 271)		int index;
HXDLIN( 271)		if (this1->useVirtualPos) {
HXDLIN( 271)			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            		}
            		else {
HXDLIN( 271)			index = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            		}
HXDLIN( 271)		::iterMagic::Iimg_obj::set(this2,index,0);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Pixelimage_Impl__obj,zeroPixel,(void))

int Pixelimage_Impl__obj::setARGB( ::pi_xy::ImageStruct this1,int x,int y,int color){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_278_setARGB)
HXLINE( 279)		int c = color;
HXLINE( 280)		bool _hx_tmp;
HXDLIN( 280)		if ((((c >> 24) & 255) < 254)) {
HXLINE( 280)			_hx_tmp = this1->transparent;
            		}
            		else {
HXLINE( 280)			_hx_tmp = false;
            		}
HXDLIN( 280)		if (_hx_tmp) {
HXLINE( 281)			int location;
HXDLIN( 281)			if (this1->useVirtualPos) {
HXLINE( 281)				location = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            			}
            			else {
HXLINE( 281)				location = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            			}
HXDLIN( 281)			int this2 = ::iterMagic::Iimg_obj::get(this1->image,location);
HXDLIN( 281)			int this3;
HXDLIN( 281)			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 281)				this3 = ((((((this2 >> 24) & 255) << 24) | ((this2 & 255) << 16)) | (((this2 >> 8) & 255) << 8)) | ((this2 >> 16) & 255));
            			}
            			else {
HXLINE( 281)				this3 = this2;
            			}
HXDLIN( 281)			Float a1;
HXDLIN( 281)			int this4 = ((this3 >> 24) & 255);
HXDLIN( 281)			if ((this4 == 0)) {
HXLINE( 281)				a1 = ((Float)0.);
            			}
            			else {
HXLINE( 281)				a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            			}
HXDLIN( 281)			Float r1;
HXDLIN( 281)			int this5 = ((this3 >> 16) & 255);
HXDLIN( 281)			if ((this5 == 0)) {
HXLINE( 281)				r1 = ((Float)0.);
            			}
            			else {
HXLINE( 281)				r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            			}
HXDLIN( 281)			Float g1;
HXDLIN( 281)			int this6 = ((this3 >> 8) & 255);
HXDLIN( 281)			if ((this6 == 0)) {
HXLINE( 281)				g1 = ((Float)0.);
            			}
            			else {
HXLINE( 281)				g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            			}
HXDLIN( 281)			Float b1;
HXDLIN( 281)			int this7 = (this3 & 255);
HXDLIN( 281)			if ((this7 == 0)) {
HXLINE( 281)				b1 = ((Float)0.);
            			}
            			else {
HXLINE( 281)				b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            			}
HXDLIN( 281)			Float a2;
HXDLIN( 281)			int this8 = ((color >> 24) & 255);
HXDLIN( 281)			if ((this8 == 0)) {
HXLINE( 281)				a2 = ((Float)0.);
            			}
            			else {
HXLINE( 281)				a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            			}
HXDLIN( 281)			Float r2;
HXDLIN( 281)			int this9 = ((color >> 16) & 255);
HXDLIN( 281)			if ((this9 == 0)) {
HXLINE( 281)				r2 = ((Float)0.);
            			}
            			else {
HXLINE( 281)				r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            			}
HXDLIN( 281)			Float g2;
HXDLIN( 281)			int this10 = ((color >> 8) & 255);
HXDLIN( 281)			if ((this10 == 0)) {
HXLINE( 281)				g2 = ((Float)0.);
            			}
            			else {
HXLINE( 281)				g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            			}
HXDLIN( 281)			Float b2;
HXDLIN( 281)			int this11 = (color & 255);
HXDLIN( 281)			if ((this11 == 0)) {
HXLINE( 281)				b2 = ((Float)0.);
            			}
            			else {
HXLINE( 281)				b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            			}
HXDLIN( 281)			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 281)			int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 281)			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 281)			int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 281)			int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 281)			int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 281)			{
HXLINE( 281)				int _hx_tmp1;
HXDLIN( 281)				if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 281)					_hx_tmp1 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            				}
            				else {
HXLINE( 281)					_hx_tmp1 = blended;
            				}
HXDLIN( 281)				::iterMagic::Iimg_obj::set(this1->image,location,_hx_tmp1);
            			}
            		}
            		else {
HXLINE( 283)			::Dynamic this12 = this1->image;
HXDLIN( 283)			int index;
HXDLIN( 283)			if (this1->useVirtualPos) {
HXLINE( 283)				index = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            			}
            			else {
HXLINE( 283)				index = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            			}
HXDLIN( 283)			int _hx_tmp2;
HXDLIN( 283)			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 283)				_hx_tmp2 = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            			}
            			else {
HXLINE( 283)				_hx_tmp2 = c;
            			}
HXDLIN( 283)			::iterMagic::Iimg_obj::set(this12,index,_hx_tmp2);
            		}
HXLINE( 285)		return color;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Pixelimage_Impl__obj,setARGB,return )

int Pixelimage_Impl__obj::getPixel( ::pi_xy::ImageStruct this1,int x,int y){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_289_getPixel)
HXDLIN( 289)		::Dynamic this2 = this1->image;
HXDLIN( 289)		int index;
HXDLIN( 289)		if (this1->useVirtualPos) {
HXDLIN( 289)			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            		}
            		else {
HXDLIN( 289)			index = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            		}
HXDLIN( 289)		int c = ::iterMagic::Iimg_obj::get(this2,index);
HXDLIN( 289)		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 289)			return ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            		}
            		else {
HXDLIN( 289)			return c;
            		}
HXDLIN( 289)		return 0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Pixelimage_Impl__obj,getPixel,return )

int Pixelimage_Impl__obj::getARGB( ::pi_xy::ImageStruct this1,int x,int y){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_296_getARGB)
HXLINE( 297)		::Dynamic this2 = this1->image;
HXDLIN( 297)		int index;
HXDLIN( 297)		if (this1->useVirtualPos) {
HXLINE( 297)			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            		}
            		else {
HXLINE( 297)			index = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            		}
HXDLIN( 297)		int c = ::iterMagic::Iimg_obj::get(this2,index);
HXLINE( 298)		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 298)			return ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            		}
            		else {
HXLINE( 298)			return c;
            		}
HXDLIN( 298)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Pixelimage_Impl__obj,getARGB,return )

void Pixelimage_Impl__obj::set_argbPixel( ::pi_xy::ImageStruct this1,int a,int r,int g,int b,int location){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_306_set_argbPixel)
HXDLIN( 306)		bool _hx_tmp;
HXDLIN( 306)		if (this1->transparent) {
HXDLIN( 306)			_hx_tmp = (a < 254);
            		}
            		else {
HXDLIN( 306)			_hx_tmp = false;
            		}
HXDLIN( 306)		if (_hx_tmp) {
HXDLIN( 306)			int this2 = ::iterMagic::Iimg_obj::get(this1->image,location);
HXDLIN( 306)			int old;
HXDLIN( 306)			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 306)				old = ((((((this2 >> 24) & 255) << 24) | ((this2 & 255) << 16)) | (((this2 >> 8) & 255) << 8)) | ((this2 >> 16) & 255));
            			}
            			else {
HXDLIN( 306)				old = this2;
            			}
HXDLIN( 306)			int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 306)			Float a1;
HXDLIN( 306)			int this3 = ((old >> 24) & 255);
HXDLIN( 306)			if ((this3 == 0)) {
HXDLIN( 306)				a1 = ((Float)0.);
            			}
            			else {
HXDLIN( 306)				a1 = (( (Float)(this3) ) / ( (Float)(255) ));
            			}
HXDLIN( 306)			Float r1;
HXDLIN( 306)			int this4 = ((old >> 16) & 255);
HXDLIN( 306)			if ((this4 == 0)) {
HXDLIN( 306)				r1 = ((Float)0.);
            			}
            			else {
HXDLIN( 306)				r1 = (( (Float)(this4) ) / ( (Float)(255) ));
            			}
HXDLIN( 306)			Float g1;
HXDLIN( 306)			int this5 = ((old >> 8) & 255);
HXDLIN( 306)			if ((this5 == 0)) {
HXDLIN( 306)				g1 = ((Float)0.);
            			}
            			else {
HXDLIN( 306)				g1 = (( (Float)(this5) ) / ( (Float)(255) ));
            			}
HXDLIN( 306)			Float b1;
HXDLIN( 306)			int this6 = (old & 255);
HXDLIN( 306)			if ((this6 == 0)) {
HXDLIN( 306)				b1 = ((Float)0.);
            			}
            			else {
HXDLIN( 306)				b1 = (( (Float)(this6) ) / ( (Float)(255) ));
            			}
HXDLIN( 306)			Float a2;
HXDLIN( 306)			int this7 = ((rhs >> 24) & 255);
HXDLIN( 306)			if ((this7 == 0)) {
HXDLIN( 306)				a2 = ((Float)0.);
            			}
            			else {
HXDLIN( 306)				a2 = (( (Float)(this7) ) / ( (Float)(255) ));
            			}
HXDLIN( 306)			Float r2;
HXDLIN( 306)			int this8 = ((rhs >> 16) & 255);
HXDLIN( 306)			if ((this8 == 0)) {
HXDLIN( 306)				r2 = ((Float)0.);
            			}
            			else {
HXDLIN( 306)				r2 = (( (Float)(this8) ) / ( (Float)(255) ));
            			}
HXDLIN( 306)			Float g2;
HXDLIN( 306)			int this9 = ((rhs >> 8) & 255);
HXDLIN( 306)			if ((this9 == 0)) {
HXDLIN( 306)				g2 = ((Float)0.);
            			}
            			else {
HXDLIN( 306)				g2 = (( (Float)(this9) ) / ( (Float)(255) ));
            			}
HXDLIN( 306)			Float b2;
HXDLIN( 306)			int this10 = (rhs & 255);
HXDLIN( 306)			if ((this10 == 0)) {
HXDLIN( 306)				b2 = ((Float)0.);
            			}
            			else {
HXDLIN( 306)				b2 = (( (Float)(this10) ) / ( (Float)(255) ));
            			}
HXDLIN( 306)			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 306)			int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 306)			int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 306)			int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 306)			int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 306)			int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN( 306)			{
HXDLIN( 306)				int _hx_tmp1;
HXDLIN( 306)				if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 306)					_hx_tmp1 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            				}
            				else {
HXDLIN( 306)					_hx_tmp1 = blended;
            				}
HXDLIN( 306)				::iterMagic::Iimg_obj::set(this1->image,location,_hx_tmp1);
            			}
            		}
            		else {
HXDLIN( 306)			int value;
HXDLIN( 306)			if (this1->isLittle) {
HXDLIN( 306)				value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            			}
            			else {
HXDLIN( 306)				value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            			}
HXDLIN( 306)			::iterMagic::Iimg_obj::set(this1->image,location,value);
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(Pixelimage_Impl__obj,set_argbPixel,(void))

void Pixelimage_Impl__obj::argbToPixel( ::pi_xy::ImageStruct this1,int a,int r,int g,int b,int location){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_313_argbToPixel)
HXDLIN( 313)		int value;
HXDLIN( 313)		if (this1->isLittle) {
HXDLIN( 313)			value = ((((a << 24) | (b << 16)) | (g << 8)) | r);
            		}
            		else {
HXDLIN( 313)			value = ((((a << 24) | (r << 16)) | (g << 8)) | b);
            		}
HXDLIN( 313)		::iterMagic::Iimg_obj::set(this1->image,location,value);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(Pixelimage_Impl__obj,argbToPixel,(void))

void Pixelimage_Impl__obj::channelBlend( ::pi_xy::ImageStruct this1,int a,int r,int g,int b,int location){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_320_channelBlend)
HXLINE( 321)		int this2 = ::iterMagic::Iimg_obj::get(this1->image,location);
HXDLIN( 321)		int old;
HXDLIN( 321)		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 321)			old = ((((((this2 >> 24) & 255) << 24) | ((this2 & 255) << 16)) | (((this2 >> 8) & 255) << 8)) | ((this2 >> 16) & 255));
            		}
            		else {
HXLINE( 321)			old = this2;
            		}
HXLINE( 322)		int rhs = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 322)		Float a1;
HXDLIN( 322)		int this3 = ((old >> 24) & 255);
HXDLIN( 322)		if ((this3 == 0)) {
HXLINE( 322)			a1 = ((Float)0.);
            		}
            		else {
HXLINE( 322)			a1 = (( (Float)(this3) ) / ( (Float)(255) ));
            		}
HXDLIN( 322)		Float r1;
HXDLIN( 322)		int this4 = ((old >> 16) & 255);
HXDLIN( 322)		if ((this4 == 0)) {
HXLINE( 322)			r1 = ((Float)0.);
            		}
            		else {
HXLINE( 322)			r1 = (( (Float)(this4) ) / ( (Float)(255) ));
            		}
HXDLIN( 322)		Float g1;
HXDLIN( 322)		int this5 = ((old >> 8) & 255);
HXDLIN( 322)		if ((this5 == 0)) {
HXLINE( 322)			g1 = ((Float)0.);
            		}
            		else {
HXLINE( 322)			g1 = (( (Float)(this5) ) / ( (Float)(255) ));
            		}
HXDLIN( 322)		Float b1;
HXDLIN( 322)		int this6 = (old & 255);
HXDLIN( 322)		if ((this6 == 0)) {
HXLINE( 322)			b1 = ((Float)0.);
            		}
            		else {
HXLINE( 322)			b1 = (( (Float)(this6) ) / ( (Float)(255) ));
            		}
HXDLIN( 322)		Float a2;
HXDLIN( 322)		int this7 = ((rhs >> 24) & 255);
HXDLIN( 322)		if ((this7 == 0)) {
HXLINE( 322)			a2 = ((Float)0.);
            		}
            		else {
HXLINE( 322)			a2 = (( (Float)(this7) ) / ( (Float)(255) ));
            		}
HXDLIN( 322)		Float r2;
HXDLIN( 322)		int this8 = ((rhs >> 16) & 255);
HXDLIN( 322)		if ((this8 == 0)) {
HXLINE( 322)			r2 = ((Float)0.);
            		}
            		else {
HXLINE( 322)			r2 = (( (Float)(this8) ) / ( (Float)(255) ));
            		}
HXDLIN( 322)		Float g2;
HXDLIN( 322)		int this9 = ((rhs >> 8) & 255);
HXDLIN( 322)		if ((this9 == 0)) {
HXLINE( 322)			g2 = ((Float)0.);
            		}
            		else {
HXLINE( 322)			g2 = (( (Float)(this9) ) / ( (Float)(255) ));
            		}
HXDLIN( 322)		Float b2;
HXDLIN( 322)		int this10 = (rhs & 255);
HXDLIN( 322)		if ((this10 == 0)) {
HXLINE( 322)			b2 = ((Float)0.);
            		}
            		else {
HXLINE( 322)			b2 = (( (Float)(this10) ) / ( (Float)(255) ));
            		}
HXDLIN( 322)		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 322)		int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 322)		int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 322)		int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 322)		int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 322)		int blended = ((((a4 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXLINE( 323)		{
HXLINE( 323)			int _hx_tmp;
HXDLIN( 323)			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 323)				_hx_tmp = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            			}
            			else {
HXLINE( 323)				_hx_tmp = blended;
            			}
HXDLIN( 323)			::iterMagic::Iimg_obj::set(this1->image,location,_hx_tmp);
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(Pixelimage_Impl__obj,channelBlend,(void))

void Pixelimage_Impl__obj::colorBlend( ::pi_xy::ImageStruct this1,int color,int location){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_330_colorBlend)
HXLINE( 331)		int this2 = ::iterMagic::Iimg_obj::get(this1->image,location);
HXDLIN( 331)		int this3;
HXDLIN( 331)		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 331)			this3 = ((((((this2 >> 24) & 255) << 24) | ((this2 & 255) << 16)) | (((this2 >> 8) & 255) << 8)) | ((this2 >> 16) & 255));
            		}
            		else {
HXLINE( 331)			this3 = this2;
            		}
HXDLIN( 331)		Float a1;
HXDLIN( 331)		int this4 = ((this3 >> 24) & 255);
HXDLIN( 331)		if ((this4 == 0)) {
HXLINE( 331)			a1 = ((Float)0.);
            		}
            		else {
HXLINE( 331)			a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            		}
HXDLIN( 331)		Float r1;
HXDLIN( 331)		int this5 = ((this3 >> 16) & 255);
HXDLIN( 331)		if ((this5 == 0)) {
HXLINE( 331)			r1 = ((Float)0.);
            		}
            		else {
HXLINE( 331)			r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            		}
HXDLIN( 331)		Float g1;
HXDLIN( 331)		int this6 = ((this3 >> 8) & 255);
HXDLIN( 331)		if ((this6 == 0)) {
HXLINE( 331)			g1 = ((Float)0.);
            		}
            		else {
HXLINE( 331)			g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            		}
HXDLIN( 331)		Float b1;
HXDLIN( 331)		int this7 = (this3 & 255);
HXDLIN( 331)		if ((this7 == 0)) {
HXLINE( 331)			b1 = ((Float)0.);
            		}
            		else {
HXLINE( 331)			b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            		}
HXDLIN( 331)		Float a2;
HXDLIN( 331)		int this8 = ((color >> 24) & 255);
HXDLIN( 331)		if ((this8 == 0)) {
HXLINE( 331)			a2 = ((Float)0.);
            		}
            		else {
HXLINE( 331)			a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            		}
HXDLIN( 331)		Float r2;
HXDLIN( 331)		int this9 = ((color >> 16) & 255);
HXDLIN( 331)		if ((this9 == 0)) {
HXLINE( 331)			r2 = ((Float)0.);
            		}
            		else {
HXLINE( 331)			r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            		}
HXDLIN( 331)		Float g2;
HXDLIN( 331)		int this10 = ((color >> 8) & 255);
HXDLIN( 331)		if ((this10 == 0)) {
HXLINE( 331)			g2 = ((Float)0.);
            		}
            		else {
HXLINE( 331)			g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            		}
HXDLIN( 331)		Float b2;
HXDLIN( 331)		int this11 = (color & 255);
HXDLIN( 331)		if ((this11 == 0)) {
HXLINE( 331)			b2 = ((Float)0.);
            		}
            		else {
HXLINE( 331)			b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            		}
HXDLIN( 331)		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 331)		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 331)		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 331)		int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 331)		int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 331)		int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXLINE( 332)		{
HXLINE( 332)			int _hx_tmp;
HXDLIN( 332)			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 332)				_hx_tmp = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            			}
            			else {
HXLINE( 332)				_hx_tmp = blended;
            			}
HXDLIN( 332)			::iterMagic::Iimg_obj::set(this1->image,location,_hx_tmp);
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Pixelimage_Impl__obj,colorBlend,(void))

::String Pixelimage_Impl__obj::getPixelString( ::pi_xy::ImageStruct this1,int x,int y){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_339_getPixelString)
HXDLIN( 339)		::Dynamic this2 = this1->image;
HXDLIN( 339)		int index;
HXDLIN( 339)		if (this1->useVirtualPos) {
HXDLIN( 339)			index = ::Std_obj::_hx_int(((((( (Float)(y) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            		}
            		else {
HXDLIN( 339)			index = ::Std_obj::_hx_int(( (Float)(((y * this1->width) + x)) ));
            		}
HXDLIN( 339)		int c = ::iterMagic::Iimg_obj::get(this2,index);
HXDLIN( 339)		int v;
HXDLIN( 339)		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 339)			v = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            		}
            		else {
HXDLIN( 339)			v = c;
            		}
HXDLIN( 339)		return (HX_("#",23,00,00,00) + ::StringTools_obj::hex(v,8));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Pixelimage_Impl__obj,getPixelString,return )

void Pixelimage_Impl__obj::simpleRect( ::pi_xy::ImageStruct this1,Float x,Float y,Float w,Float h,int color){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_344_simpleRect)
HXLINE( 345)		int r_x = ::Std_obj::_hx_int(x);
HXDLIN( 345)		int r_y = ::Std_obj::_hx_int(y);
HXDLIN( 345)		int r_w = ::Std_obj::_hx_int(w);
HXDLIN( 345)		int r_h = ::Std_obj::_hx_int(h);
HXDLIN( 345)		int xmax = ((r_x + r_w) + 1);
HXDLIN( 345)		int ymax = ((r_y + r_h) + 1);
HXDLIN( 345)		int ii_min = r_x;
HXDLIN( 345)		int ii_max = xmax;
HXDLIN( 345)		int xRange__start = ii_min;
HXDLIN( 345)		int xRange__max = ii_max;
HXDLIN( 345)		int ii_min1 = r_y;
HXDLIN( 345)		int ii_max1 = ymax;
HXDLIN( 345)		int yRange__start = ii_min1;
HXDLIN( 345)		int yRange__max = ii_max1;
HXDLIN( 345)		int range_x = xRange__start;
HXDLIN( 345)		int range_y = (yRange__start - 1);
HXDLIN( 345)		int range_xReset = range_x;
HXDLIN( 345)		int range_yReset = range_y;
HXDLIN( 345)		int range_xMax = (xRange__max - 2);
HXDLIN( 345)		int range_yMax = (yRange__max - 2);
HXDLIN( 345)		int _this_min = 0;
HXDLIN( 345)		int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXLINE( 351)		while((_this_min < _this_max)){
HXLINE( 351)			_this_min = (_this_min + 1);
HXDLIN( 351)			int i = (_this_min - 1);
HXDLIN( 351)			if ((range_y > range_yMax)) {
HXLINE( 351)				range_y = range_yReset;
HXDLIN( 351)				range_x = (range_x + 1);
            			}
HXDLIN( 351)			range_y = (range_y + 1);
HXDLIN( 351)			int i1 = i;
HXLINE( 352)			{
HXLINE( 352)				int x1 = range_x;
HXDLIN( 352)				int y1 = range_y;
HXDLIN( 352)				int c = color;
HXDLIN( 352)				bool _hx_tmp;
HXDLIN( 352)				if ((((c >> 24) & 255) < 254)) {
HXLINE( 352)					_hx_tmp = this1->transparent;
            				}
            				else {
HXLINE( 352)					_hx_tmp = false;
            				}
HXDLIN( 352)				if (_hx_tmp) {
HXLINE( 352)					int location;
HXDLIN( 352)					if (this1->useVirtualPos) {
HXLINE( 352)						location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this1->virtualY) * ( (Float)(this1->width) )) + x1) - this1->virtualX));
            					}
            					else {
HXLINE( 352)						location = ::Std_obj::_hx_int(( (Float)(((y1 * this1->width) + x1)) ));
            					}
HXDLIN( 352)					int this2 = ::iterMagic::Iimg_obj::get(this1->image,location);
HXDLIN( 352)					int this3;
HXDLIN( 352)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 352)						this3 = ((((((this2 >> 24) & 255) << 24) | ((this2 & 255) << 16)) | (((this2 >> 8) & 255) << 8)) | ((this2 >> 16) & 255));
            					}
            					else {
HXLINE( 352)						this3 = this2;
            					}
HXDLIN( 352)					Float a1;
HXDLIN( 352)					int this4 = ((this3 >> 24) & 255);
HXDLIN( 352)					if ((this4 == 0)) {
HXLINE( 352)						a1 = ((Float)0.);
            					}
            					else {
HXLINE( 352)						a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            					}
HXDLIN( 352)					Float r1;
HXDLIN( 352)					int this5 = ((this3 >> 16) & 255);
HXDLIN( 352)					if ((this5 == 0)) {
HXLINE( 352)						r1 = ((Float)0.);
            					}
            					else {
HXLINE( 352)						r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            					}
HXDLIN( 352)					Float g1;
HXDLIN( 352)					int this6 = ((this3 >> 8) & 255);
HXDLIN( 352)					if ((this6 == 0)) {
HXLINE( 352)						g1 = ((Float)0.);
            					}
            					else {
HXLINE( 352)						g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            					}
HXDLIN( 352)					Float b1;
HXDLIN( 352)					int this7 = (this3 & 255);
HXDLIN( 352)					if ((this7 == 0)) {
HXLINE( 352)						b1 = ((Float)0.);
            					}
            					else {
HXLINE( 352)						b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            					}
HXDLIN( 352)					Float a2;
HXDLIN( 352)					int this8 = ((color >> 24) & 255);
HXDLIN( 352)					if ((this8 == 0)) {
HXLINE( 352)						a2 = ((Float)0.);
            					}
            					else {
HXLINE( 352)						a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            					}
HXDLIN( 352)					Float r2;
HXDLIN( 352)					int this9 = ((color >> 16) & 255);
HXDLIN( 352)					if ((this9 == 0)) {
HXLINE( 352)						r2 = ((Float)0.);
            					}
            					else {
HXLINE( 352)						r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            					}
HXDLIN( 352)					Float g2;
HXDLIN( 352)					int this10 = ((color >> 8) & 255);
HXDLIN( 352)					if ((this10 == 0)) {
HXLINE( 352)						g2 = ((Float)0.);
            					}
            					else {
HXLINE( 352)						g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            					}
HXDLIN( 352)					Float b2;
HXDLIN( 352)					int this11 = (color & 255);
HXDLIN( 352)					if ((this11 == 0)) {
HXLINE( 352)						b2 = ((Float)0.);
            					}
            					else {
HXLINE( 352)						b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            					}
HXDLIN( 352)					Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 352)					int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 352)					int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 352)					int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 352)					int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 352)					int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 352)					{
HXLINE( 352)						int _hx_tmp1;
HXDLIN( 352)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 352)							_hx_tmp1 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            						}
            						else {
HXLINE( 352)							_hx_tmp1 = blended;
            						}
HXDLIN( 352)						::iterMagic::Iimg_obj::set(this1->image,location,_hx_tmp1);
            					}
            				}
            				else {
HXLINE( 352)					::Dynamic this12 = this1->image;
HXDLIN( 352)					int index;
HXDLIN( 352)					if (this1->useVirtualPos) {
HXLINE( 352)						index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this1->virtualY) * ( (Float)(this1->width) )) + x1) - this1->virtualX));
            					}
            					else {
HXLINE( 352)						index = ::Std_obj::_hx_int(( (Float)(((y1 * this1->width) + x1)) ));
            					}
HXDLIN( 352)					int _hx_tmp2;
HXDLIN( 352)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 352)						_hx_tmp2 = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            					}
            					else {
HXLINE( 352)						_hx_tmp2 = c;
            					}
HXDLIN( 352)					::iterMagic::Iimg_obj::set(this12,index,_hx_tmp2);
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(Pixelimage_Impl__obj,simpleRect,(void))

void Pixelimage_Impl__obj::clearRectWindow( ::pi_xy::ImageStruct this1, ::pi_xy::algo::RectangleWindow rectangle){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_374_clearRectWindow)
HXDLIN( 374)		Float y = rectangle->y;
HXDLIN( 374)		Float w = rectangle->width;
HXDLIN( 374)		Float h = rectangle->height;
HXDLIN( 374)		int r_x = ::Std_obj::_hx_int(rectangle->x);
HXDLIN( 374)		int r_y = ::Std_obj::_hx_int(y);
HXDLIN( 374)		int r_w = ::Std_obj::_hx_int(w);
HXDLIN( 374)		int r_h = ::Std_obj::_hx_int(h);
HXDLIN( 374)		int xmax = ((r_x + r_w) + 1);
HXDLIN( 374)		int ymax = ((r_y + r_h) + 1);
HXDLIN( 374)		int ii_min = r_x;
HXDLIN( 374)		int ii_max = xmax;
HXDLIN( 374)		int xRange__start = ii_min;
HXDLIN( 374)		int xRange__max = ii_max;
HXDLIN( 374)		int ii_min1 = r_y;
HXDLIN( 374)		int ii_max1 = ymax;
HXDLIN( 374)		int yRange__start = ii_min1;
HXDLIN( 374)		int yRange__max = ii_max1;
HXDLIN( 374)		int range_x = xRange__start;
HXDLIN( 374)		int range_y = (yRange__start - 1);
HXDLIN( 374)		int range_xReset = range_x;
HXDLIN( 374)		int range_yReset = range_y;
HXDLIN( 374)		int range_xMax = (xRange__max - 2);
HXDLIN( 374)		int range_yMax = (yRange__max - 2);
HXDLIN( 374)		int _this_min = 0;
HXDLIN( 374)		int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXDLIN( 374)		while((_this_min < _this_max)){
HXDLIN( 374)			_this_min = (_this_min + 1);
HXDLIN( 374)			int i = (_this_min - 1);
HXDLIN( 374)			if ((range_y > range_yMax)) {
HXDLIN( 374)				range_y = range_yReset;
HXDLIN( 374)				range_x = (range_x + 1);
            			}
HXDLIN( 374)			range_y = (range_y + 1);
HXDLIN( 374)			int i1 = i;
HXDLIN( 374)			{
HXDLIN( 374)				::Dynamic this2 = this1->image;
HXDLIN( 374)				int x = range_x;
HXDLIN( 374)				int y1 = range_y;
HXDLIN( 374)				int index;
HXDLIN( 374)				if (this1->useVirtualPos) {
HXDLIN( 374)					index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            				}
            				else {
HXDLIN( 374)					index = ::Std_obj::_hx_int(( (Float)(((y1 * this1->width) + x)) ));
            				}
HXDLIN( 374)				::iterMagic::Iimg_obj::set(this2,index,0);
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Pixelimage_Impl__obj,clearRectWindow,(void))

void Pixelimage_Impl__obj::clearRect( ::pi_xy::ImageStruct this1,Float x,Float y,Float w,Float h){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_380_clearRect)
HXLINE( 381)		int r_x = ::Std_obj::_hx_int(x);
HXDLIN( 381)		int r_y = ::Std_obj::_hx_int(y);
HXDLIN( 381)		int r_w = ::Std_obj::_hx_int(w);
HXDLIN( 381)		int r_h = ::Std_obj::_hx_int(h);
HXDLIN( 381)		int xmax = ((r_x + r_w) + 1);
HXDLIN( 381)		int ymax = ((r_y + r_h) + 1);
HXDLIN( 381)		int ii_min = r_x;
HXDLIN( 381)		int ii_max = xmax;
HXDLIN( 381)		int xRange__start = ii_min;
HXDLIN( 381)		int xRange__max = ii_max;
HXDLIN( 381)		int ii_min1 = r_y;
HXDLIN( 381)		int ii_max1 = ymax;
HXDLIN( 381)		int yRange__start = ii_min1;
HXDLIN( 381)		int yRange__max = ii_max1;
HXDLIN( 381)		int range_x = xRange__start;
HXDLIN( 381)		int range_y = (yRange__start - 1);
HXDLIN( 381)		int range_xReset = range_x;
HXDLIN( 381)		int range_yReset = range_y;
HXDLIN( 381)		int range_xMax = (xRange__max - 2);
HXDLIN( 381)		int range_yMax = (yRange__max - 2);
HXDLIN( 381)		int _this_min = 0;
HXDLIN( 381)		int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXLINE( 387)		while((_this_min < _this_max)){
HXLINE( 387)			_this_min = (_this_min + 1);
HXDLIN( 387)			int i = (_this_min - 1);
HXDLIN( 387)			if ((range_y > range_yMax)) {
HXLINE( 387)				range_y = range_yReset;
HXDLIN( 387)				range_x = (range_x + 1);
            			}
HXDLIN( 387)			range_y = (range_y + 1);
HXDLIN( 387)			int i1 = i;
HXLINE( 388)			{
HXLINE( 388)				::Dynamic this2 = this1->image;
HXDLIN( 388)				int x1 = range_x;
HXDLIN( 388)				int y1 = range_y;
HXDLIN( 388)				int index;
HXDLIN( 388)				if (this1->useVirtualPos) {
HXLINE( 388)					index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this1->virtualY) * ( (Float)(this1->width) )) + x1) - this1->virtualX));
            				}
            				else {
HXLINE( 388)					index = ::Std_obj::_hx_int(( (Float)(((y1 * this1->width) + x1)) ));
            				}
HXDLIN( 388)				::iterMagic::Iimg_obj::set(this2,index,0);
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(Pixelimage_Impl__obj,clearRect,(void))

void Pixelimage_Impl__obj::putPixelImage( ::pi_xy::ImageStruct this1, ::pi_xy::ImageStruct pixelImage,int x,int y, ::Dynamic __o_useAvaliableMask,::hx::Null< bool >  __o_forceClear){
            		 ::Dynamic useAvaliableMask = __o_useAvaliableMask;
            		if (::hx::IsNull(__o_useAvaliableMask)) useAvaliableMask = true;
            		bool forceClear = __o_forceClear.Default(false);
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_416_putPixelImage)
HXDLIN( 416)		int _g = 0;
HXDLIN( 416)		int _g1 = pixelImage->height;
HXDLIN( 416)		while((_g < _g1)){
HXDLIN( 416)			_g = (_g + 1);
HXDLIN( 416)			int dy = (_g - 1);
HXLINE( 417)			{
HXLINE( 417)				int _g2 = 0;
HXDLIN( 417)				int _g3 = pixelImage->width;
HXDLIN( 417)				while((_g2 < _g3)){
HXLINE( 417)					_g2 = (_g2 + 1);
HXDLIN( 417)					int dx = (_g2 - 1);
HXLINE( 418)					::Dynamic this2 = pixelImage->image;
HXDLIN( 418)					int index;
HXDLIN( 418)					if (pixelImage->useVirtualPos) {
HXLINE( 418)						index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            					}
            					else {
HXLINE( 418)						index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            					}
HXDLIN( 418)					int c = ::iterMagic::Iimg_obj::get(this2,index);
HXDLIN( 418)					int col;
HXDLIN( 418)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 418)						col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            					}
            					else {
HXLINE( 418)						col = c;
            					}
HXLINE( 419)					bool _hx_tmp;
HXDLIN( 419)					bool _hx_tmp1;
HXDLIN( 419)					if (pixelImage->useMask) {
HXLINE( 419)						_hx_tmp1 = ( (bool)(useAvaliableMask) );
            					}
            					else {
HXLINE( 419)						_hx_tmp1 = false;
            					}
HXDLIN( 419)					if (_hx_tmp1) {
HXLINE( 419)						_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            					}
            					else {
HXLINE( 419)						_hx_tmp = false;
            					}
HXDLIN( 419)					if (_hx_tmp) {
HXLINE( 420)						 ::pi_xy::ImageStruct this3 = pixelImage->mask;
HXDLIN( 420)						::Dynamic this4 = this3->image;
HXDLIN( 420)						int index1;
HXDLIN( 420)						if (this3->useVirtualPos) {
HXLINE( 420)							index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this3->virtualY) * ( (Float)(this3->width) )) + dx) - this3->virtualX));
            						}
            						else {
HXLINE( 420)							index1 = ::Std_obj::_hx_int(( (Float)(((dy * this3->width) + dx)) ));
            						}
HXDLIN( 420)						int c1 = ::iterMagic::Iimg_obj::get(this4,index1);
HXDLIN( 420)						int v;
HXDLIN( 420)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 420)							v = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            						}
            						else {
HXLINE( 420)							v = c1;
            						}
HXDLIN( 420)						int maskPixel = v;
HXLINE( 421)						int this5 = col;
HXDLIN( 421)						if ((maskPixel == 0)) {
HXLINE( 421)							col = this5;
            						}
            						else {
HXLINE( 421)							Float m0;
HXDLIN( 421)							int this6 = ((maskPixel >> 24) & 255);
HXDLIN( 421)							if ((this6 == 0)) {
HXLINE( 421)								m0 = ((Float)0.);
            							}
            							else {
HXLINE( 421)								m0 = (( (Float)(this6) ) / ( (Float)(255) ));
            							}
HXDLIN( 421)							Float m1;
HXDLIN( 421)							int this7 = ((maskPixel >> 16) & 255);
HXDLIN( 421)							if ((this7 == 0)) {
HXLINE( 421)								m1 = ((Float)0.);
            							}
            							else {
HXLINE( 421)								m1 = (( (Float)(this7) ) / ( (Float)(255) ));
            							}
HXDLIN( 421)							Float m2;
HXDLIN( 421)							int this8 = ((maskPixel >> 8) & 255);
HXDLIN( 421)							if ((this8 == 0)) {
HXLINE( 421)								m2 = ((Float)0.);
            							}
            							else {
HXLINE( 421)								m2 = (( (Float)(this8) ) / ( (Float)(255) ));
            							}
HXDLIN( 421)							Float m3;
HXDLIN( 421)							int this9 = (maskPixel & 255);
HXDLIN( 421)							if ((this9 == 0)) {
HXLINE( 421)								m3 = ((Float)0.);
            							}
            							else {
HXLINE( 421)								m3 = (( (Float)(this9) ) / ( (Float)(255) ));
            							}
HXDLIN( 421)							int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 421)							int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 421)							int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 421)							int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 421)							col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            						}
            					}
HXLINE( 423)					if ((col != 0)) {
HXLINE( 424)						int x1 = (x + dx);
HXDLIN( 424)						int y1 = (y + dy);
HXDLIN( 424)						int c2 = col;
HXDLIN( 424)						bool _hx_tmp2;
HXDLIN( 424)						if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 424)							_hx_tmp2 = this1->transparent;
            						}
            						else {
HXLINE( 424)							_hx_tmp2 = false;
            						}
HXDLIN( 424)						if (_hx_tmp2) {
HXLINE( 424)							int location;
HXDLIN( 424)							if (this1->useVirtualPos) {
HXLINE( 424)								location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this1->virtualY) * ( (Float)(this1->width) )) + x1) - this1->virtualX));
            							}
            							else {
HXLINE( 424)								location = ::Std_obj::_hx_int(( (Float)(((y1 * this1->width) + x1)) ));
            							}
HXDLIN( 424)							int this10 = ::iterMagic::Iimg_obj::get(this1->image,location);
HXDLIN( 424)							int this11;
HXDLIN( 424)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 424)								this11 = ((((((this10 >> 24) & 255) << 24) | ((this10 & 255) << 16)) | (((this10 >> 8) & 255) << 8)) | ((this10 >> 16) & 255));
            							}
            							else {
HXLINE( 424)								this11 = this10;
            							}
HXDLIN( 424)							Float a1;
HXDLIN( 424)							int this12 = ((this11 >> 24) & 255);
HXDLIN( 424)							if ((this12 == 0)) {
HXLINE( 424)								a1 = ((Float)0.);
            							}
            							else {
HXLINE( 424)								a1 = (( (Float)(this12) ) / ( (Float)(255) ));
            							}
HXDLIN( 424)							Float r1;
HXDLIN( 424)							int this13 = ((this11 >> 16) & 255);
HXDLIN( 424)							if ((this13 == 0)) {
HXLINE( 424)								r1 = ((Float)0.);
            							}
            							else {
HXLINE( 424)								r1 = (( (Float)(this13) ) / ( (Float)(255) ));
            							}
HXDLIN( 424)							Float g1;
HXDLIN( 424)							int this14 = ((this11 >> 8) & 255);
HXDLIN( 424)							if ((this14 == 0)) {
HXLINE( 424)								g1 = ((Float)0.);
            							}
            							else {
HXLINE( 424)								g1 = (( (Float)(this14) ) / ( (Float)(255) ));
            							}
HXDLIN( 424)							Float b1;
HXDLIN( 424)							int this15 = (this11 & 255);
HXDLIN( 424)							if ((this15 == 0)) {
HXLINE( 424)								b1 = ((Float)0.);
            							}
            							else {
HXLINE( 424)								b1 = (( (Float)(this15) ) / ( (Float)(255) ));
            							}
HXDLIN( 424)							Float a2;
HXDLIN( 424)							int this16 = ((col >> 24) & 255);
HXDLIN( 424)							if ((this16 == 0)) {
HXLINE( 424)								a2 = ((Float)0.);
            							}
            							else {
HXLINE( 424)								a2 = (( (Float)(this16) ) / ( (Float)(255) ));
            							}
HXDLIN( 424)							Float r2;
HXDLIN( 424)							int this17 = ((col >> 16) & 255);
HXDLIN( 424)							if ((this17 == 0)) {
HXLINE( 424)								r2 = ((Float)0.);
            							}
            							else {
HXLINE( 424)								r2 = (( (Float)(this17) ) / ( (Float)(255) ));
            							}
HXDLIN( 424)							Float g2;
HXDLIN( 424)							int this18 = ((col >> 8) & 255);
HXDLIN( 424)							if ((this18 == 0)) {
HXLINE( 424)								g2 = ((Float)0.);
            							}
            							else {
HXLINE( 424)								g2 = (( (Float)(this18) ) / ( (Float)(255) ));
            							}
HXDLIN( 424)							Float b2;
HXDLIN( 424)							int this19 = (col & 255);
HXDLIN( 424)							if ((this19 == 0)) {
HXLINE( 424)								b2 = ((Float)0.);
            							}
            							else {
HXLINE( 424)								b2 = (( (Float)(this19) ) / ( (Float)(255) ));
            							}
HXDLIN( 424)							Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 424)							int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 424)							int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 424)							int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 424)							int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 424)							int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 424)							{
HXLINE( 424)								int _hx_tmp3;
HXDLIN( 424)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 424)									_hx_tmp3 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            								}
            								else {
HXLINE( 424)									_hx_tmp3 = blended;
            								}
HXDLIN( 424)								::iterMagic::Iimg_obj::set(this1->image,location,_hx_tmp3);
            							}
            						}
            						else {
HXLINE( 424)							::Dynamic this20 = this1->image;
HXDLIN( 424)							int index2;
HXDLIN( 424)							if (this1->useVirtualPos) {
HXLINE( 424)								index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this1->virtualY) * ( (Float)(this1->width) )) + x1) - this1->virtualX));
            							}
            							else {
HXLINE( 424)								index2 = ::Std_obj::_hx_int(( (Float)(((y1 * this1->width) + x1)) ));
            							}
HXDLIN( 424)							int _hx_tmp4;
HXDLIN( 424)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 424)								_hx_tmp4 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            							}
            							else {
HXLINE( 424)								_hx_tmp4 = c2;
            							}
HXDLIN( 424)							::iterMagic::Iimg_obj::set(this20,index2,_hx_tmp4);
            						}
            					}
            					else {
HXLINE( 426)						if (forceClear) {
HXLINE( 427)							::Dynamic this21 = this1->image;
HXDLIN( 427)							int x2 = (x + dx);
HXDLIN( 427)							int y2 = (y + dy);
HXDLIN( 427)							int index3;
HXDLIN( 427)							if (this1->useVirtualPos) {
HXLINE( 427)								index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - this1->virtualY) * ( (Float)(this1->width) )) + x2) - this1->virtualX));
            							}
            							else {
HXLINE( 427)								index3 = ::Std_obj::_hx_int(( (Float)(((y2 * this1->width) + x2)) ));
            							}
HXDLIN( 427)							::iterMagic::Iimg_obj::set(this21,index3,0);
            						}
            					}
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(Pixelimage_Impl__obj,putPixelImage,(void))

void Pixelimage_Impl__obj::putPixelImageRect( ::pi_xy::ImageStruct this1, ::pi_xy::ImageStruct pixelImage,int x,int y,int rectLeft,int rectTop,int rectRight,int rectBottom, ::Dynamic __o_useAvaliableMask,::hx::Null< bool >  __o_forceClear){
            		 ::Dynamic useAvaliableMask = __o_useAvaliableMask;
            		if (::hx::IsNull(__o_useAvaliableMask)) useAvaliableMask = true;
            		bool forceClear = __o_forceClear.Default(false);
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_435_putPixelImageRect)
HXDLIN( 435)		int _g = rectTop;
HXDLIN( 435)		int _g1 = rectBottom;
HXDLIN( 435)		while((_g < _g1)){
HXDLIN( 435)			_g = (_g + 1);
HXDLIN( 435)			int dy = (_g - 1);
HXLINE( 436)			{
HXLINE( 436)				int _g2 = rectLeft;
HXDLIN( 436)				int _g3 = rectRight;
HXDLIN( 436)				while((_g2 < _g3)){
HXLINE( 436)					_g2 = (_g2 + 1);
HXDLIN( 436)					int dx = (_g2 - 1);
HXLINE( 437)					::Dynamic this2 = pixelImage->image;
HXDLIN( 437)					int index;
HXDLIN( 437)					if (pixelImage->useVirtualPos) {
HXLINE( 437)						index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + dx) - pixelImage->virtualX));
            					}
            					else {
HXLINE( 437)						index = ::Std_obj::_hx_int(( (Float)(((dy * pixelImage->width) + dx)) ));
            					}
HXDLIN( 437)					int c = ::iterMagic::Iimg_obj::get(this2,index);
HXDLIN( 437)					int col;
HXDLIN( 437)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 437)						col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            					}
            					else {
HXLINE( 437)						col = c;
            					}
HXLINE( 438)					bool _hx_tmp;
HXDLIN( 438)					bool _hx_tmp1;
HXDLIN( 438)					if (pixelImage->useMask) {
HXLINE( 438)						_hx_tmp1 = ( (bool)(useAvaliableMask) );
            					}
            					else {
HXLINE( 438)						_hx_tmp1 = false;
            					}
HXDLIN( 438)					if (_hx_tmp1) {
HXLINE( 438)						_hx_tmp = ::hx::IsNotNull( pixelImage->mask );
            					}
            					else {
HXLINE( 438)						_hx_tmp = false;
            					}
HXDLIN( 438)					if (_hx_tmp) {
HXLINE( 439)						 ::pi_xy::ImageStruct this3 = pixelImage->mask;
HXDLIN( 439)						::Dynamic this4 = this3->image;
HXDLIN( 439)						int index1;
HXDLIN( 439)						if (this3->useVirtualPos) {
HXLINE( 439)							index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this3->virtualY) * ( (Float)(this3->width) )) + dx) - this3->virtualX));
            						}
            						else {
HXLINE( 439)							index1 = ::Std_obj::_hx_int(( (Float)(((dy * this3->width) + dx)) ));
            						}
HXDLIN( 439)						int c1 = ::iterMagic::Iimg_obj::get(this4,index1);
HXDLIN( 439)						int v;
HXDLIN( 439)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 439)							v = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            						}
            						else {
HXLINE( 439)							v = c1;
            						}
HXDLIN( 439)						int maskPixel = v;
HXLINE( 440)						int this5 = col;
HXDLIN( 440)						if ((maskPixel == 0)) {
HXLINE( 440)							col = this5;
            						}
            						else {
HXLINE( 440)							Float m0;
HXDLIN( 440)							int this6 = ((maskPixel >> 24) & 255);
HXDLIN( 440)							if ((this6 == 0)) {
HXLINE( 440)								m0 = ((Float)0.);
            							}
            							else {
HXLINE( 440)								m0 = (( (Float)(this6) ) / ( (Float)(255) ));
            							}
HXDLIN( 440)							Float m1;
HXDLIN( 440)							int this7 = ((maskPixel >> 16) & 255);
HXDLIN( 440)							if ((this7 == 0)) {
HXLINE( 440)								m1 = ((Float)0.);
            							}
            							else {
HXLINE( 440)								m1 = (( (Float)(this7) ) / ( (Float)(255) ));
            							}
HXDLIN( 440)							Float m2;
HXDLIN( 440)							int this8 = ((maskPixel >> 8) & 255);
HXDLIN( 440)							if ((this8 == 0)) {
HXLINE( 440)								m2 = ((Float)0.);
            							}
            							else {
HXLINE( 440)								m2 = (( (Float)(this8) ) / ( (Float)(255) ));
            							}
HXDLIN( 440)							Float m3;
HXDLIN( 440)							int this9 = (maskPixel & 255);
HXDLIN( 440)							if ((this9 == 0)) {
HXLINE( 440)								m3 = ((Float)0.);
            							}
            							else {
HXLINE( 440)								m3 = (( (Float)(this9) ) / ( (Float)(255) ));
            							}
HXDLIN( 440)							int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this5 >> 24) & 255)) )));
HXDLIN( 440)							int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this5 >> 16) & 255)) )));
HXDLIN( 440)							int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this5 >> 8) & 255)) )));
HXDLIN( 440)							int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this5 & 255)) )));
HXDLIN( 440)							col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            						}
            					}
HXLINE( 442)					if ((col != 0)) {
HXLINE( 443)						int x1 = ((x + dx) - rectLeft);
HXDLIN( 443)						int y1 = ((y + dy) - rectTop);
HXDLIN( 443)						int c2 = col;
HXDLIN( 443)						bool _hx_tmp2;
HXDLIN( 443)						if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 443)							_hx_tmp2 = this1->transparent;
            						}
            						else {
HXLINE( 443)							_hx_tmp2 = false;
            						}
HXDLIN( 443)						if (_hx_tmp2) {
HXLINE( 443)							int location;
HXDLIN( 443)							if (this1->useVirtualPos) {
HXLINE( 443)								location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this1->virtualY) * ( (Float)(this1->width) )) + x1) - this1->virtualX));
            							}
            							else {
HXLINE( 443)								location = ::Std_obj::_hx_int(( (Float)(((y1 * this1->width) + x1)) ));
            							}
HXDLIN( 443)							int this10 = ::iterMagic::Iimg_obj::get(this1->image,location);
HXDLIN( 443)							int this11;
HXDLIN( 443)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 443)								this11 = ((((((this10 >> 24) & 255) << 24) | ((this10 & 255) << 16)) | (((this10 >> 8) & 255) << 8)) | ((this10 >> 16) & 255));
            							}
            							else {
HXLINE( 443)								this11 = this10;
            							}
HXDLIN( 443)							Float a1;
HXDLIN( 443)							int this12 = ((this11 >> 24) & 255);
HXDLIN( 443)							if ((this12 == 0)) {
HXLINE( 443)								a1 = ((Float)0.);
            							}
            							else {
HXLINE( 443)								a1 = (( (Float)(this12) ) / ( (Float)(255) ));
            							}
HXDLIN( 443)							Float r1;
HXDLIN( 443)							int this13 = ((this11 >> 16) & 255);
HXDLIN( 443)							if ((this13 == 0)) {
HXLINE( 443)								r1 = ((Float)0.);
            							}
            							else {
HXLINE( 443)								r1 = (( (Float)(this13) ) / ( (Float)(255) ));
            							}
HXDLIN( 443)							Float g1;
HXDLIN( 443)							int this14 = ((this11 >> 8) & 255);
HXDLIN( 443)							if ((this14 == 0)) {
HXLINE( 443)								g1 = ((Float)0.);
            							}
            							else {
HXLINE( 443)								g1 = (( (Float)(this14) ) / ( (Float)(255) ));
            							}
HXDLIN( 443)							Float b1;
HXDLIN( 443)							int this15 = (this11 & 255);
HXDLIN( 443)							if ((this15 == 0)) {
HXLINE( 443)								b1 = ((Float)0.);
            							}
            							else {
HXLINE( 443)								b1 = (( (Float)(this15) ) / ( (Float)(255) ));
            							}
HXDLIN( 443)							Float a2;
HXDLIN( 443)							int this16 = ((col >> 24) & 255);
HXDLIN( 443)							if ((this16 == 0)) {
HXLINE( 443)								a2 = ((Float)0.);
            							}
            							else {
HXLINE( 443)								a2 = (( (Float)(this16) ) / ( (Float)(255) ));
            							}
HXDLIN( 443)							Float r2;
HXDLIN( 443)							int this17 = ((col >> 16) & 255);
HXDLIN( 443)							if ((this17 == 0)) {
HXLINE( 443)								r2 = ((Float)0.);
            							}
            							else {
HXLINE( 443)								r2 = (( (Float)(this17) ) / ( (Float)(255) ));
            							}
HXDLIN( 443)							Float g2;
HXDLIN( 443)							int this18 = ((col >> 8) & 255);
HXDLIN( 443)							if ((this18 == 0)) {
HXLINE( 443)								g2 = ((Float)0.);
            							}
            							else {
HXLINE( 443)								g2 = (( (Float)(this18) ) / ( (Float)(255) ));
            							}
HXDLIN( 443)							Float b2;
HXDLIN( 443)							int this19 = (col & 255);
HXDLIN( 443)							if ((this19 == 0)) {
HXLINE( 443)								b2 = ((Float)0.);
            							}
            							else {
HXLINE( 443)								b2 = (( (Float)(this19) ) / ( (Float)(255) ));
            							}
HXDLIN( 443)							Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 443)							int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 443)							int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 443)							int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN( 443)							int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 443)							int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN( 443)							{
HXLINE( 443)								int _hx_tmp3;
HXDLIN( 443)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 443)									_hx_tmp3 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            								}
            								else {
HXLINE( 443)									_hx_tmp3 = blended;
            								}
HXDLIN( 443)								::iterMagic::Iimg_obj::set(this1->image,location,_hx_tmp3);
            							}
            						}
            						else {
HXLINE( 443)							::Dynamic this20 = this1->image;
HXDLIN( 443)							int index2;
HXDLIN( 443)							if (this1->useVirtualPos) {
HXLINE( 443)								index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this1->virtualY) * ( (Float)(this1->width) )) + x1) - this1->virtualX));
            							}
            							else {
HXLINE( 443)								index2 = ::Std_obj::_hx_int(( (Float)(((y1 * this1->width) + x1)) ));
            							}
HXDLIN( 443)							int _hx_tmp4;
HXDLIN( 443)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 443)								_hx_tmp4 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            							}
            							else {
HXLINE( 443)								_hx_tmp4 = c2;
            							}
HXDLIN( 443)							::iterMagic::Iimg_obj::set(this20,index2,_hx_tmp4);
            						}
            					}
            					else {
HXLINE( 445)						if (forceClear) {
HXLINE( 446)							::Dynamic this21 = this1->image;
HXDLIN( 446)							int x2 = ((x + dx) - rectLeft);
HXDLIN( 446)							int y2 = ((y + dy) - rectTop);
HXDLIN( 446)							int index3;
HXDLIN( 446)							if (this1->useVirtualPos) {
HXLINE( 446)								index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - this1->virtualY) * ( (Float)(this1->width) )) + x2) - this1->virtualX));
            							}
            							else {
HXLINE( 446)								index3 = ::Std_obj::_hx_int(( (Float)(((y2 * this1->width) + x2)) ));
            							}
HXDLIN( 446)							::iterMagic::Iimg_obj::set(this21,index3,0);
            						}
            					}
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC10(Pixelimage_Impl__obj,putPixelImageRect,(void))

 ::pi_xy::ImageStruct Pixelimage_Impl__obj::transferClone( ::pi_xy::ImageStruct this1){
            	HX_GC_STACKFRAME(&_hx_pos_11ce842fed00cba7_452_transferClone)
HXLINE( 453)		int width = this1->width;
HXDLIN( 453)		int height = this1->height;
HXDLIN( 453)		 ::Dynamic imageType = null();
HXDLIN( 453)		 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 453)		if (::hx::IsNull( imageType )) {
HXLINE( 453)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXDLIN( 453)		::Dynamic _hx_tmp;
HXDLIN( 453)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE( 453)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 453)				 ::iterMagic::BytesImg b = byt;
HXDLIN( 453)				{
HXLINE( 453)					b->width = width;
HXDLIN( 453)					b->height = height;
HXDLIN( 453)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 453)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 453)					{
HXLINE( 453)						int len = b->length;
HXDLIN( 453)						int w = 0;
HXDLIN( 453)						{
HXLINE( 453)							int _g = 0;
HXDLIN( 453)							int _g1 = b->height;
HXDLIN( 453)							while((_g < _g1)){
HXLINE( 453)								_g = (_g + 1);
HXDLIN( 453)								int y = (_g - 1);
HXDLIN( 453)								{
HXLINE( 453)									int _g2 = 0;
HXDLIN( 453)									int _g3 = b->width;
HXDLIN( 453)									while((_g2 < _g3)){
HXLINE( 453)										_g2 = (_g2 + 1);
HXDLIN( 453)										int x = (_g2 - 1);
HXDLIN( 453)										{
HXLINE( 453)											w = (w + 1);
HXDLIN( 453)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 453)										{
HXLINE( 453)											w = (w + 1);
HXDLIN( 453)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 453)										{
HXLINE( 453)											w = (w + 1);
HXDLIN( 453)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN( 453)										{
HXLINE( 453)											w = (w + 1);
HXDLIN( 453)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 453)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXLINE( 453)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 453)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 453)				{
HXLINE( 453)					a->width = width;
HXDLIN( 453)					a->height = height;
HXDLIN( 453)					a->data = ::Array_obj< int >::__new(0);
HXDLIN( 453)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 453)					{
HXLINE( 453)						int _g4 = 0;
HXDLIN( 453)						int _g5 = a->length;
HXDLIN( 453)						while((_g4 < _g5)){
HXLINE( 453)							_g4 = (_g4 + 1);
HXDLIN( 453)							int i = (_g4 - 1);
HXDLIN( 453)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN( 453)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXLINE( 453)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 453)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 453)				{
HXLINE( 453)					b1->width = width;
HXDLIN( 453)					b1->height = height;
HXDLIN( 453)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 453)					int size = (b1->length * 4);
HXDLIN( 453)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 453)					{
HXLINE( 453)						int _g6 = 0;
HXDLIN( 453)						int _g7 = b1->length;
HXDLIN( 453)						while((_g6 < _g7)){
HXLINE( 453)							_g6 = (_g6 + 1);
HXDLIN( 453)							int i1 = (_g6 - 1);
HXDLIN( 453)							{
HXLINE( 453)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 453)								bool _hx_tmp1;
HXDLIN( 453)								if ((i1 >= 0)) {
HXLINE( 453)									_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXLINE( 453)									_hx_tmp1 = false;
            								}
HXDLIN( 453)								if (_hx_tmp1) {
HXLINE( 453)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 453)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 453)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 453)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 453)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 453)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN( 453)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXLINE( 453)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 453)				 ::iterMagic::VecIntImg v = vec;
HXDLIN( 453)				{
HXLINE( 453)					v->width = width;
HXDLIN( 453)					v->height = height;
HXDLIN( 453)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 453)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 453)					{
HXLINE( 453)						int _g8 = 0;
HXDLIN( 453)						int _g9 = v->length;
HXDLIN( 453)						while((_g8 < _g9)){
HXLINE( 453)							_g8 = (_g8 + 1);
HXDLIN( 453)							int i2 = (_g8 - 1);
HXDLIN( 453)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN( 453)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXLINE( 453)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 453)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 453)				{
HXLINE( 453)					b2->width = width;
HXDLIN( 453)					b2->height = height;
HXDLIN( 453)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 453)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 453)					{
HXLINE( 453)						int len1 = b2->length;
HXDLIN( 453)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 453)						if (::hx::IsNull( d->head )) {
HXLINE( 453)							int _g10 = 0;
HXDLIN( 453)							int _g11 = len1;
HXDLIN( 453)							while((_g10 < _g11)){
HXLINE( 453)								_g10 = (_g10 + 1);
HXDLIN( 453)								int i3 = (_g10 - 1);
HXDLIN( 453)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE( 453)							int _g12 = 0;
HXDLIN( 453)							int _g13 = len1;
HXDLIN( 453)							while((_g12 < _g13)){
HXLINE( 453)								_g12 = (_g12 + 1);
HXDLIN( 453)								int i4 = (_g12 - 1);
HXDLIN( 453)								{
HXLINE( 453)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 453)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 453)									{
HXLINE( 453)										int _g14 = 0;
HXDLIN( 453)										int _g15 = i4;
HXDLIN( 453)										while((_g14 < _g15)){
HXLINE( 453)											_g14 = (_g14 + 1);
HXDLIN( 453)											int i5 = (_g14 - 1);
HXDLIN( 453)											prev = l;
HXDLIN( 453)											l = l->next;
            										}
            									}
HXDLIN( 453)									if (::hx::IsNull( prev )) {
HXLINE( 453)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 453)										l = null();
            									}
            									else {
HXLINE( 453)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 453)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 453)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN( 453)		this2->image = _hx_tmp;
HXDLIN( 453)		this2->width = width;
HXDLIN( 453)		this2->height = height;
HXDLIN( 453)		this2->imageType = ( (int)(imageType) );
HXDLIN( 453)		 ::pi_xy::ImageStruct out = this2;
HXLINE( 454)		{
HXLINE( 454)			int _g16 = 0;
HXDLIN( 454)			int _g17 = ( (int)(this1->image->__Field(HX_("length",e6,94,07,9f),::hx::paccDynamic)) );
HXDLIN( 454)			while((_g16 < _g17)){
HXLINE( 454)				_g16 = (_g16 + 1);
HXDLIN( 454)				int i6 = (_g16 - 1);
HXLINE( 455)				{
HXLINE( 455)					::Dynamic this4 = out->image;
HXDLIN( 455)					int this5 = ::iterMagic::Iimg_obj::get(this1->image,i6);
HXDLIN( 455)					::iterMagic::Iimg_obj::set(this4,i6,((((((this5 >> 24) & 255) << 24) | ((this5 & 255) << 16)) | (((this5 >> 8) & 255) << 8)) | ((this5 >> 16) & 255)));
            				}
            			}
            		}
HXLINE( 457)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pixelimage_Impl__obj,transferClone,return )

void Pixelimage_Impl__obj::transferIn( ::pi_xy::ImageStruct this1, ::pi_xy::ImageStruct p){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_461_transferIn)
HXDLIN( 461)		int _g = 0;
HXDLIN( 461)		int _g1 = ( (int)(p->image->__Field(HX_("length",e6,94,07,9f),::hx::paccDynamic)) );
HXDLIN( 461)		while((_g < _g1)){
HXDLIN( 461)			_g = (_g + 1);
HXDLIN( 461)			int i = (_g - 1);
HXLINE( 462)			{
HXLINE( 462)				::Dynamic this2 = this1->image;
HXDLIN( 462)				int this3 = ::iterMagic::Iimg_obj::get(p->image,i);
HXDLIN( 462)				::iterMagic::Iimg_obj::set(this2,i,((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255)));
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Pixelimage_Impl__obj,transferIn,(void))

 ::haxe::io::Bytes Pixelimage_Impl__obj::getBytes( ::pi_xy::ImageStruct this1){
            	HX_GC_STACKFRAME(&_hx_pos_11ce842fed00cba7_472_getBytes)
HXLINE( 473)		int width = this1->width;
HXDLIN( 473)		int height = this1->height;
HXDLIN( 473)		 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 473)		 ::iterMagic::BytesImg b = byt;
HXDLIN( 473)		{
HXLINE( 473)			b->width = width;
HXDLIN( 473)			b->height = height;
HXDLIN( 473)			b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 473)			b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 473)			{
HXLINE( 473)				int len = b->length;
HXDLIN( 473)				int w = 0;
HXDLIN( 473)				{
HXLINE( 473)					int _g = 0;
HXDLIN( 473)					int _g1 = b->height;
HXDLIN( 473)					while((_g < _g1)){
HXLINE( 473)						_g = (_g + 1);
HXDLIN( 473)						int y = (_g - 1);
HXDLIN( 473)						{
HXLINE( 473)							int _g2 = 0;
HXDLIN( 473)							int _g3 = b->width;
HXDLIN( 473)							while((_g2 < _g3)){
HXLINE( 473)								_g2 = (_g2 + 1);
HXDLIN( 473)								int x = (_g2 - 1);
HXDLIN( 473)								{
HXLINE( 473)									w = (w + 1);
HXDLIN( 473)									b->data->b[(w - 1)] = ( (unsigned char)(0) );
            								}
HXDLIN( 473)								{
HXLINE( 473)									w = (w + 1);
HXDLIN( 473)									b->data->b[(w - 1)] = ( (unsigned char)(0) );
            								}
HXDLIN( 473)								{
HXLINE( 473)									w = (w + 1);
HXDLIN( 473)									b->data->b[(w - 1)] = ( (unsigned char)(0) );
            								}
HXDLIN( 473)								{
HXLINE( 473)									w = (w + 1);
HXDLIN( 473)									b->data->b[(w - 1)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 473)		 ::iterMagic::BytesImg imageBytes = b;
HXLINE( 475)		::Dynamic a = this1->image;
HXDLIN( 475)		{
HXLINE( 475)			int _g4 = 0;
HXDLIN( 475)			int _g5 = imageBytes->length;
HXDLIN( 475)			while((_g4 < _g5)){
HXLINE( 475)				_g4 = (_g4 + 1);
HXDLIN( 475)				int i = (_g4 - 1);
HXDLIN( 475)				{
HXLINE( 475)					int value = ::iterMagic::Iimg_obj::get(a,i);
HXDLIN( 475)					{
HXLINE( 475)						 ::haxe::io::Bytes _this = imageBytes->data;
HXDLIN( 475)						int pos = ::Std_obj::_hx_int(( (Float)((i * 4)) ));
HXDLIN( 475)						_this->b[pos] = ( (unsigned char)(value) );
HXDLIN( 475)						_this->b[(pos + 1)] = ( (unsigned char)((value >> 8)) );
HXDLIN( 475)						_this->b[(pos + 2)] = ( (unsigned char)((value >> 16)) );
HXDLIN( 475)						_this->b[(pos + 3)] = ( (unsigned char)(::hx::UShr(value,24)) );
            					}
            				}
            			}
            		}
HXDLIN( 475)		::Dynamic result = imageBytes;
HXLINE( 477)		 ::haxe::io::Bytes b1 = ( ( ::haxe::io::Bytes)(result->__Field(HX_("data",2a,56,63,42),::hx::paccDynamic)) );
HXLINE( 478)		return b1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pixelimage_Impl__obj,getBytes,return )

 ::pi_xy::ImageStruct Pixelimage_Impl__obj::fromBytes( ::pi_xy::ImageStruct this1, ::haxe::io::Bytes bytes){
            	HX_GC_STACKFRAME(&_hx_pos_11ce842fed00cba7_483_fromBytes)
HXLINE( 484)		int width = this1->width;
HXDLIN( 484)		int height = this1->height;
HXDLIN( 484)		 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 484)		 ::iterMagic::BytesImg b = byt;
HXDLIN( 484)		{
HXLINE( 484)			b->width = width;
HXDLIN( 484)			b->height = height;
HXDLIN( 484)			b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 484)			b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 484)			{
HXLINE( 484)				int len = b->length;
HXDLIN( 484)				int w = 0;
HXDLIN( 484)				{
HXLINE( 484)					int _g = 0;
HXDLIN( 484)					int _g1 = b->height;
HXDLIN( 484)					while((_g < _g1)){
HXLINE( 484)						_g = (_g + 1);
HXDLIN( 484)						int y = (_g - 1);
HXDLIN( 484)						{
HXLINE( 484)							int _g2 = 0;
HXDLIN( 484)							int _g3 = b->width;
HXDLIN( 484)							while((_g2 < _g3)){
HXLINE( 484)								_g2 = (_g2 + 1);
HXDLIN( 484)								int x = (_g2 - 1);
HXDLIN( 484)								{
HXLINE( 484)									w = (w + 1);
HXDLIN( 484)									b->data->b[(w - 1)] = ( (unsigned char)(0) );
            								}
HXDLIN( 484)								{
HXLINE( 484)									w = (w + 1);
HXDLIN( 484)									b->data->b[(w - 1)] = ( (unsigned char)(0) );
            								}
HXDLIN( 484)								{
HXLINE( 484)									w = (w + 1);
HXDLIN( 484)									b->data->b[(w - 1)] = ( (unsigned char)(0) );
            								}
HXDLIN( 484)								{
HXLINE( 484)									w = (w + 1);
HXDLIN( 484)									b->data->b[(w - 1)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 484)		 ::iterMagic::BytesImg imageBytes = b;
HXLINE( 485)		::Dynamic accessorBytes = imageBytes;
HXLINE( 486)		accessorBytes->__SetField(HX_("data",2a,56,63,42),bytes,::hx::paccDynamic);
HXLINE( 487)		{
HXLINE( 487)			int _g4 = 0;
HXDLIN( 487)			int _g5 = imageBytes->length;
HXDLIN( 487)			while((_g4 < _g5)){
HXLINE( 487)				_g4 = (_g4 + 1);
HXDLIN( 487)				int i = (_g4 - 1);
HXLINE( 488)				::haxe::Log_obj::trace(i,::hx::SourceInfo(HX_("src/pi_xy/Pixelimage.hx",36,00,3a,6f),488,HX_("pi_xy._Pixelimage.Pixelimage_Impl_",f6,5e,97,e3),HX_("fromBytes",a1,f2,20,72)));
HXLINE( 489)				{
HXLINE( 489)					::Dynamic this2 = this1->image;
HXDLIN( 489)					 ::haxe::io::Bytes _this = imageBytes->data;
HXDLIN( 489)					int pos = ::Std_obj::_hx_int(( (Float)((i * 4)) ));
HXDLIN( 489)					::iterMagic::Iimg_obj::set(this2,i,(((( (int)(_this->b->__get(pos)) ) | (( (int)(_this->b->__get((pos + 1))) ) << 8)) | (( (int)(_this->b->__get((pos + 2))) ) << 16)) | (( (int)(_this->b->__get((pos + 3))) ) << 24)));
            				}
            			}
            		}
HXLINE( 491)		return this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Pixelimage_Impl__obj,fromBytes,return )

 ::pi_xy::ImageStruct Pixelimage_Impl__obj::get_raw( ::pi_xy::ImageStruct this1){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_499_get_raw)
HXDLIN( 499)		return this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pixelimage_Impl__obj,get_raw,return )

 ::pi_xy::ImageStruct Pixelimage_Impl__obj::get_transform( ::pi_xy::ImageStruct this1){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_505_get_transform)
HXDLIN( 505)		return this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pixelimage_Impl__obj,get_transform,return )

 ::pi_xy::ImageStruct Pixelimage_Impl__obj::get_fillShape( ::pi_xy::ImageStruct this1){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_511_get_fillShape)
HXDLIN( 511)		return this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pixelimage_Impl__obj,get_fillShape,return )

 ::pi_xy::ImageStruct Pixelimage_Impl__obj::get_softShape( ::pi_xy::ImageStruct this1){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_517_get_softShape)
HXDLIN( 517)		return this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pixelimage_Impl__obj,get_softShape,return )

 ::pi_xy::ImageStruct Pixelimage_Impl__obj::get_lineShape( ::pi_xy::ImageStruct this1){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_523_get_lineShape)
HXDLIN( 523)		return this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pixelimage_Impl__obj,get_lineShape,return )

 ::pi_xy::ImageStruct Pixelimage_Impl__obj::get_tileShape( ::pi_xy::ImageStruct this1){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_529_get_tileShape)
HXDLIN( 529)		return this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pixelimage_Impl__obj,get_tileShape,return )

 ::pi_xy::ImageStruct Pixelimage_Impl__obj::get_imageShape( ::pi_xy::ImageStruct this1){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_535_get_imageShape)
HXDLIN( 535)		return this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pixelimage_Impl__obj,get_imageShape,return )

 ::pi_xy::ImageStruct Pixelimage_Impl__obj::get_gradientShape( ::pi_xy::ImageStruct this1){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_541_get_gradientShape)
HXDLIN( 541)		return this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pixelimage_Impl__obj,get_gradientShape,return )

 ::pi_xy::ImageStruct Pixelimage_Impl__obj::get_pattern( ::pi_xy::ImageStruct this1){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_547_get_pattern)
HXDLIN( 547)		return this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pixelimage_Impl__obj,get_pattern,return )

 ::pi_xy::ImageStruct Pixelimage_Impl__obj::get_convolution( ::pi_xy::ImageStruct this1){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_553_get_convolution)
HXDLIN( 553)		return this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pixelimage_Impl__obj,get_convolution,return )

 ::pi_xy::ImageStruct Pixelimage_Impl__obj::get_colorform( ::pi_xy::ImageStruct this1){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_559_get_colorform)
HXDLIN( 559)		return this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pixelimage_Impl__obj,get_colorform,return )

 ::pi_xy::ImageStruct Pixelimage_Impl__obj::get_rectanglePad( ::pi_xy::ImageStruct this1){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_565_get_rectanglePad)
HXDLIN( 565)		return this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pixelimage_Impl__obj,get_rectanglePad,return )

 ::pi_xy::ImageStruct Pixelimage_Impl__obj::get_png( ::pi_xy::ImageStruct this1){
            	HX_STACKFRAME(&_hx_pos_11ce842fed00cba7_578_get_png)
HXDLIN( 578)		return this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pixelimage_Impl__obj,get_png,return )


Pixelimage_Impl__obj::Pixelimage_Impl__obj()
{
}

bool Pixelimage_Impl__obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"_new") ) { outValue = _new_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"pos4") ) { outValue = pos4_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"setARGB") ) { outValue = setARGB_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"getARGB") ) { outValue = getARGB_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"get_raw") ) { outValue = get_raw_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"get_png") ) { outValue = get_png_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"get_mask") ) { outValue = get_mask_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"set_mask") ) { outValue = set_mask_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"position") ) { outValue = position_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"setPixel") ) { outValue = setPixel_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"getPixel") ) { outValue = getPixel_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"getBytes") ) { outValue = getBytes_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"get_image") ) { outValue = get_image_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"get_width") ) { outValue = get_width_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"zeroPixel") ) { outValue = zeroPixel_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"clearRect") ) { outValue = clearRect_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"fromBytes") ) { outValue = fromBytes_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"get_height") ) { outValue = get_height_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"colorBlend") ) { outValue = colorBlend_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"simpleRect") ) { outValue = simpleRect_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"transferIn") ) { outValue = transferIn_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"set_hasMask") ) { outValue = set_hasMask_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"get_hasMask") ) { outValue = get_hasMask_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"argbToPixel") ) { outValue = argbToPixel_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"get_pattern") ) { outValue = get_pattern_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"channelBlend") ) { outValue = channelBlend_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"set_argbPixel") ) { outValue = set_argbPixel_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"putPixelImage") ) { outValue = putPixelImage_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"transferClone") ) { outValue = transferClone_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"get_transform") ) { outValue = get_transform_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"get_fillShape") ) { outValue = get_fillShape_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"get_softShape") ) { outValue = get_softShape_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"get_lineShape") ) { outValue = get_lineShape_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"get_tileShape") ) { outValue = get_tileShape_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"get_colorform") ) { outValue = get_colorform_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"get_rectWindow") ) { outValue = get_rectWindow_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"set_rectWindow") ) { outValue = set_rectWindow_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"getPixelString") ) { outValue = getPixelString_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"get_imageShape") ) { outValue = get_imageShape_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"get_defaultType") ) { outValue = get_defaultType_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"set_defaultType") ) { outValue = set_defaultType_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"imageTypeString") ) { outValue = imageTypeString_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"get_transparent") ) { outValue = get_transparent_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"set_transparent") ) { outValue = set_transparent_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"clearRectWindow") ) { outValue = clearRectWindow_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"get_convolution") ) { outValue = get_convolution_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"get_rectanglePad") ) { outValue = get_rectanglePad_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"putPixelImageRect") ) { outValue = putPixelImageRect_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"get_gradientShape") ) { outValue = get_gradientShape_dyn(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"setRelativePosition") ) { outValue = setRelativePosition_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Pixelimage_Impl__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *Pixelimage_Impl__obj_sStaticStorageInfo = 0;
#endif

::hx::Class Pixelimage_Impl__obj::__mClass;

static ::String Pixelimage_Impl__obj_sStaticFields[] = {
	HX_("get_defaultType",b2,a3,a9,df),
	HX_("set_defaultType",be,20,75,db),
	HX_("_new",61,15,1f,3f),
	HX_("get_image",b2,7b,12,01),
	HX_("imageTypeString",66,5a,0e,39),
	HX_("get_width",5d,12,0c,0e),
	HX_("get_height",b0,77,d3,f2),
	HX_("setRelativePosition",57,21,c0,26),
	HX_("get_transparent",e9,e2,9b,e3),
	HX_("set_transparent",f5,5f,67,df),
	HX_("get_mask",75,fc,10,c8),
	HX_("set_mask",e9,55,6e,76),
	HX_("set_hasMask",89,c8,01,a8),
	HX_("get_hasMask",7d,c1,94,9d),
	HX_("get_rectWindow",7d,50,ba,cd),
	HX_("set_rectWindow",f1,38,da,ed),
	HX_("pos4",20,84,5c,4a),
	HX_("position",a9,a0,fa,ca),
	HX_("setPixel",84,2f,d8,d0),
	HX_("zeroPixel",3e,36,f0,53),
	HX_("setARGB",ee,69,e0,05),
	HX_("getPixel",10,d6,7a,22),
	HX_("getARGB",e2,d8,de,12),
	HX_("set_argbPixel",7d,ab,46,ac),
	HX_("argbToPixel",1f,2f,5a,96),
	HX_("channelBlend",8e,b4,a7,b9),
	HX_("colorBlend",ee,ff,60,d9),
	HX_("getPixelString",01,5f,5b,0a),
	HX_("simpleRect",76,7e,da,fe),
	HX_("clearRectWindow",21,90,69,de),
	HX_("clearRect",51,35,68,bf),
	HX_("putPixelImage",a4,02,85,48),
	HX_("putPixelImageRect",e8,9d,65,e0),
	HX_("transferClone",32,f8,80,bb),
	HX_("transferIn",f0,4f,98,94),
	HX_("getBytes",f5,17,6f,1d),
	HX_("fromBytes",a1,f2,20,72),
	HX_("get_raw",7f,9e,cb,26),
	HX_("get_transform",43,01,f7,06),
	HX_("get_fillShape",75,dd,27,0c),
	HX_("get_softShape",ae,f9,f2,52),
	HX_("get_lineShape",64,ba,7b,84),
	HX_("get_tileShape",ea,14,dc,c8),
	HX_("get_imageShape",0f,32,e0,fd),
	HX_("get_gradientShape",68,1e,53,b4),
	HX_("get_pattern",67,66,71,97),
	HX_("get_convolution",af,06,63,d9),
	HX_("get_colorform",fe,93,b8,f5),
	HX_("get_rectanglePad",ed,a8,2c,41),
	HX_("get_png",40,25,ca,26),
	::String(null())
};

void Pixelimage_Impl__obj::__register()
{
	Pixelimage_Impl__obj _hx_dummy;
	Pixelimage_Impl__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pi_xy._Pixelimage.Pixelimage_Impl_",f6,5e,97,e3);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Pixelimage_Impl__obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Pixelimage_Impl__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Pixelimage_Impl__obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Pixelimage_Impl__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Pixelimage_Impl__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pi_xy
} // end namespace _Pixelimage
