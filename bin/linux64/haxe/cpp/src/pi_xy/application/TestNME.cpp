// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericCell_Int
#include <haxe/ds/GenericCell_Int.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericStack_Int
#include <haxe/ds/GenericStack_Int.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_iterMagic_ArrIntImg
#include <iterMagic/ArrIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_BytesImg
#include <iterMagic/BytesImg.h>
#endif
#ifndef INCLUDED_iterMagic_Iimg
#include <iterMagic/Iimg.h>
#endif
#ifndef INCLUDED_iterMagic_StackIntImg
#include <iterMagic/StackIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_U32ArrImg
#include <iterMagic/U32ArrImg.h>
#endif
#ifndef INCLUDED_iterMagic_VecIntImg
#include <iterMagic/VecIntImg.h>
#endif
#ifndef INCLUDED_nme_Lib
#include <nme/Lib.h>
#endif
#ifndef INCLUDED_nme_app_IAppEventHandler
#include <nme/app/IAppEventHandler.h>
#endif
#ifndef INCLUDED_nme_app_IPollClient
#include <nme/app/IPollClient.h>
#endif
#ifndef INCLUDED_nme_display_Bitmap
#include <nme/display/Bitmap.h>
#endif
#ifndef INCLUDED_nme_display_BitmapData
#include <nme/display/BitmapData.h>
#endif
#ifndef INCLUDED_nme_display_DisplayObject
#include <nme/display/DisplayObject.h>
#endif
#ifndef INCLUDED_nme_display_DisplayObjectContainer
#include <nme/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_nme_display_FPS
#include <nme/display/FPS.h>
#endif
#ifndef INCLUDED_nme_display_Graphics
#include <nme/display/Graphics.h>
#endif
#ifndef INCLUDED_nme_display_IBitmapDrawable
#include <nme/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_nme_display_InteractiveObject
#include <nme/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_nme_display_MovieClip
#include <nme/display/MovieClip.h>
#endif
#ifndef INCLUDED_nme_display_PixelSnapping
#include <nme/display/PixelSnapping.h>
#endif
#ifndef INCLUDED_nme_display_Sprite
#include <nme/display/Sprite.h>
#endif
#ifndef INCLUDED_nme_display_Stage
#include <nme/display/Stage.h>
#endif
#ifndef INCLUDED_nme_events_EventDispatcher
#include <nme/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_nme_events_IEventDispatcher
#include <nme/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_nme_text_TextField
#include <nme/text/TextField.h>
#endif
#ifndef INCLUDED_pi_xy_ImageStruct
#include <pi_xy/ImageStruct.h>
#endif
#ifndef INCLUDED_pi_xy__Endian_Endian_Fields_
#include <pi_xy/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitTri
#include <pi_xy/algo/HitTri.h>
#endif
#ifndef INCLUDED_pi_xy_algo_IhitObj
#include <pi_xy/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pi_xy_algo_TriPoints_
#include <pi_xy/algo/TriPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_application_TestNME
#include <pi_xy/application/TestNME.h>
#endif
#ifndef INCLUDED_pi_xy_formats_NMEbitmapData
#include <pi_xy/formats/NMEbitmapData.h>
#endif
#ifndef INCLUDED_pi_xy_iter_IntIterStart
#include <pi_xy/iter/IntIterStart.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_9ebd4cf390bfead5_15_new,"pi_xy.application.TestNME","new",0x10fb1421,"pi_xy.application.TestNME.new","pi_xy/application/TestNME.hx",15,0x0a53be71)
namespace pi_xy{
namespace application{

void TestNME_obj::__construct(){
            	HX_GC_STACKFRAME(&_hx_pos_9ebd4cf390bfead5_15_new)
HXLINE(  72)		this->aGrid = HX_("<LineGridShape\n        left = \"100\"  top = \"100\"\n        width = \"500\" height = \"768\"\n        delta = \"100\" deltaH = \"100\"\n        strokeColor=\"0x0cF003300\" strokeWidth=\"3\">\n    </LineGridShape>",ff,b5,5b,e9);
HXLINE(  63)		this->backGround = HX_("<RectangleForm\n        left = \"-1\"\n        top = \"-1\"\n        width = \"3073\"\n        height = \"2305\"\n        fill = \"0xFF000203\">\n    </RectangleForm>",be,5c,d5,0a);
HXLINE(  17)		super::__construct();
HXLINE(  18)		::haxe::Log_obj::trace(HX_(" testing TestNME ",1c,06,b6,af),::hx::SourceInfo(HX_("src/pi_xy/application/TestNME.hx",bc,29,aa,16),18,HX_("pi_xy.application.TestNME",af,6f,bc,a6),HX_("new",60,d0,53,00)));
HXLINE(  19)		 ::nme::display::MovieClip current = ::nme::Lib_obj::get_current();
HXLINE(  20)		 ::nme::display::Stage stage = current->get_stage();
HXLINE(  21)		 ::nme::display::Sprite viewSprite =  ::nme::display::Sprite_obj::__alloc( HX_CTX );
HXLINE(  22)		 ::nme::display::Graphics g = viewSprite->get_graphics();
HXLINE(  23)		this->addChild(viewSprite);
HXLINE(  25)		 ::Dynamic imageType = null();
HXDLIN(  25)		 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  25)		if (::hx::IsNull( imageType )) {
HXLINE(  54)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXLINE(  25)		::Dynamic _hx_tmp;
HXDLIN(  25)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE(  25)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  25)				 ::iterMagic::BytesImg b = byt;
HXDLIN(  25)				{
HXLINE(  25)					b->width = 1024;
HXDLIN(  25)					b->height = 768;
HXDLIN(  25)					b->length = 786432;
HXDLIN(  25)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  25)					{
HXLINE(  25)						int len = b->length;
HXDLIN(  25)						int w = 0;
HXDLIN(  25)						{
HXLINE(  25)							int _g = 0;
HXDLIN(  25)							int _g1 = b->height;
HXDLIN(  25)							while((_g < _g1)){
HXLINE(  25)								_g = (_g + 1);
HXDLIN(  25)								int y = (_g - 1);
HXDLIN(  25)								{
HXLINE(  25)									int _g2 = 0;
HXDLIN(  25)									int _g3 = b->width;
HXDLIN(  25)									while((_g2 < _g3)){
HXLINE(  25)										_g2 = (_g2 + 1);
HXDLIN(  25)										int x = (_g2 - 1);
HXDLIN(  25)										{
HXLINE(  25)											w = (w + 1);
HXDLIN(  25)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  25)										{
HXLINE(  25)											w = (w + 1);
HXDLIN(  25)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  25)										{
HXLINE(  25)											w = (w + 1);
HXDLIN(  25)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  25)										{
HXLINE(  25)											w = (w + 1);
HXDLIN(  25)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  25)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXLINE(  25)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  25)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  25)				{
HXLINE(  25)					a->width = 1024;
HXDLIN(  25)					a->height = 768;
HXDLIN(  25)					a->data = ::Array_obj< int >::__new(0);
HXDLIN(  25)					a->length = 786432;
HXDLIN(  25)					{
HXLINE(  25)						int _g4 = 0;
HXDLIN(  25)						int _g5 = a->length;
HXDLIN(  25)						while((_g4 < _g5)){
HXLINE(  25)							_g4 = (_g4 + 1);
HXDLIN(  25)							int i = (_g4 - 1);
HXDLIN(  25)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN(  25)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXLINE(  25)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  25)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  25)				{
HXLINE(  25)					b1->width = 1024;
HXDLIN(  25)					b1->height = 768;
HXDLIN(  25)					b1->length = 786432;
HXDLIN(  25)					int size = (b1->length * 4);
HXDLIN(  25)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  25)					{
HXLINE(  25)						int _g6 = 0;
HXDLIN(  25)						int _g7 = b1->length;
HXDLIN(  25)						while((_g6 < _g7)){
HXLINE(  25)							_g6 = (_g6 + 1);
HXDLIN(  25)							int i1 = (_g6 - 1);
HXDLIN(  25)							{
HXLINE(  25)								 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN(  25)								bool _hx_tmp1;
HXDLIN(  25)								if ((i1 >= 0)) {
HXLINE(  25)									_hx_tmp1 = (i1 < (this2->byteLength >> 2));
            								}
            								else {
HXLINE(  25)									_hx_tmp1 = false;
            								}
HXDLIN(  25)								if (_hx_tmp1) {
HXLINE(  25)									 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  25)									int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN(  25)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  25)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  25)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  25)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(  25)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXLINE(  25)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  25)				 ::iterMagic::VecIntImg v = vec;
HXDLIN(  25)				{
HXLINE(  25)					v->width = 1024;
HXDLIN(  25)					v->height = 768;
HXDLIN(  25)					v->length = 786432;
HXDLIN(  25)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  25)					{
HXLINE(  25)						int _g8 = 0;
HXDLIN(  25)						int _g9 = v->length;
HXDLIN(  25)						while((_g8 < _g9)){
HXLINE(  25)							_g8 = (_g8 + 1);
HXDLIN(  25)							int i2 = (_g8 - 1);
HXDLIN(  25)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN(  25)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXLINE(  25)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  25)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  25)				{
HXLINE(  25)					b2->width = 1024;
HXDLIN(  25)					b2->height = 768;
HXDLIN(  25)					b2->length = 786432;
HXDLIN(  25)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  25)					{
HXLINE(  25)						int len1 = b2->length;
HXDLIN(  25)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  25)						if (::hx::IsNull( d->head )) {
HXLINE(  25)							int _g10 = 0;
HXDLIN(  25)							int _g11 = len1;
HXDLIN(  25)							while((_g10 < _g11)){
HXLINE(  25)								_g10 = (_g10 + 1);
HXDLIN(  25)								int i3 = (_g10 - 1);
HXDLIN(  25)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE(  25)							int _g12 = 0;
HXDLIN(  25)							int _g13 = len1;
HXDLIN(  25)							while((_g12 < _g13)){
HXLINE(  25)								_g12 = (_g12 + 1);
HXDLIN(  25)								int i4 = (_g12 - 1);
HXDLIN(  25)								{
HXLINE(  25)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  25)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  25)									{
HXLINE(  25)										int _g14 = 0;
HXDLIN(  25)										int _g15 = i4;
HXDLIN(  25)										while((_g14 < _g15)){
HXLINE(  25)											_g14 = (_g14 + 1);
HXDLIN(  25)											int i5 = (_g14 - 1);
HXLINE( 345)											prev = l;
HXLINE( 346)											l = l->next;
            										}
            									}
HXLINE(  25)									if (::hx::IsNull( prev )) {
HXLINE(  25)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  25)										l = null();
            									}
            									else {
HXLINE(  25)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  25)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  25)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN(  25)		this1->image = _hx_tmp;
HXDLIN(  25)		this1->width = 1024;
HXDLIN(  25)		this1->height = 768;
HXDLIN(  25)		this1->imageType = ( (int)(imageType) );
HXDLIN(  25)		 ::pi_xy::ImageStruct pixelImage = this1;
HXLINE(  26)		pixelImage->transparent = true;
HXLINE(  27)		{
HXLINE(  27)			Float h = ( (Float)(pixelImage->height) );
HXDLIN(  27)			int r_x = 0;
HXDLIN(  27)			int r_y = 0;
HXDLIN(  27)			int r_w = ::Std_obj::_hx_int(( (Float)(pixelImage->width) ));
HXDLIN(  27)			int r_h = ::Std_obj::_hx_int(h);
HXDLIN(  27)			int xmax = ((r_x + r_w) + 1);
HXDLIN(  27)			int ymax = ((r_y + r_h) + 1);
HXDLIN(  27)			int ii_min = r_x;
HXDLIN(  27)			int ii_max = xmax;
HXDLIN(  27)			int xRange__start = ii_min;
HXDLIN(  27)			int xRange__max = ii_max;
HXDLIN(  27)			int ii_min1 = r_y;
HXDLIN(  27)			int ii_max1 = ymax;
HXDLIN(  27)			int yRange__start = ii_min1;
HXDLIN(  27)			int yRange__max = ii_max1;
HXDLIN(  27)			int range_x = xRange__start;
HXDLIN(  27)			int range_y = (yRange__start - 1);
HXDLIN(  27)			int range_xReset = range_x;
HXDLIN(  27)			int range_yReset = range_y;
HXDLIN(  27)			int range_xMax = (xRange__max - 2);
HXDLIN(  27)			int range_yMax = (yRange__max - 2);
HXDLIN(  27)			int _this_min = 0;
HXDLIN(  27)			int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXDLIN(  27)			while((_this_min < _this_max)){
HXLINE(  27)				_this_min = (_this_min + 1);
HXDLIN(  27)				int i6 = (_this_min - 1);
HXDLIN(  27)				if ((range_y > range_yMax)) {
HXLINE(  27)					range_y = range_yReset;
HXDLIN(  27)					range_x = (range_x + 1);
            				}
HXDLIN(  27)				range_y = (range_y + 1);
HXDLIN(  27)				int i7 = i6;
HXDLIN(  27)				{
HXLINE(  27)					int x1 = range_x;
HXDLIN(  27)					int y1 = range_y;
HXDLIN(  27)					int c = -3554365;
HXDLIN(  27)					bool _hx_tmp2;
HXDLIN(  27)					if ((((c >> 24) & 255) < 254)) {
HXLINE(  27)						_hx_tmp2 = pixelImage->transparent;
            					}
            					else {
HXLINE(  27)						_hx_tmp2 = false;
            					}
HXDLIN(  27)					if (_hx_tmp2) {
HXLINE(  27)						int location;
HXDLIN(  27)						if (pixelImage->useVirtualPos) {
HXLINE(  27)							location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x1) - pixelImage->virtualX));
            						}
            						else {
HXLINE(  27)							location = ::Std_obj::_hx_int(( (Float)(((y1 * pixelImage->width) + x1)) ));
            						}
HXDLIN(  27)						int this3 = ::iterMagic::Iimg_obj::get(pixelImage->image,location);
HXDLIN(  27)						int this4;
HXDLIN(  27)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  27)							this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            						}
            						else {
HXLINE(  27)							this4 = this3;
            						}
HXDLIN(  27)						Float a1;
HXDLIN(  27)						int this5 = ((this4 >> 24) & 255);
HXDLIN(  27)						if ((this5 == 0)) {
HXLINE(  27)							a1 = ((Float)0.);
            						}
            						else {
HXLINE(  27)							a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            						}
HXDLIN(  27)						Float r1;
HXDLIN(  27)						int this6 = ((this4 >> 16) & 255);
HXDLIN(  27)						if ((this6 == 0)) {
HXLINE(  27)							r1 = ((Float)0.);
            						}
            						else {
HXLINE(  27)							r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            						}
HXDLIN(  27)						Float g1;
HXDLIN(  27)						int this7 = ((this4 >> 8) & 255);
HXDLIN(  27)						if ((this7 == 0)) {
HXLINE(  27)							g1 = ((Float)0.);
            						}
            						else {
HXLINE(  27)							g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            						}
HXDLIN(  27)						Float b11;
HXDLIN(  27)						int this8 = (this4 & 255);
HXDLIN(  27)						if ((this8 == 0)) {
HXLINE(  27)							b11 = ((Float)0.);
            						}
            						else {
HXLINE(  27)							b11 = (( (Float)(this8) ) / ( (Float)(255) ));
            						}
HXDLIN(  27)						Float a2;
HXDLIN(  27)						int this9 = ((-3554365 >> 24) & 255);
HXDLIN(  27)						if ((this9 == 0)) {
HXLINE(  27)							a2 = ((Float)0.);
            						}
            						else {
HXLINE(  27)							a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            						}
HXDLIN(  27)						Float r2;
HXDLIN(  27)						int this10 = ((-3554365 >> 16) & 255);
HXDLIN(  27)						if ((this10 == 0)) {
HXLINE(  27)							r2 = ((Float)0.);
            						}
            						else {
HXLINE(  27)							r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            						}
HXDLIN(  27)						Float g2;
HXDLIN(  27)						int this11 = ((-3554365 >> 8) & 255);
HXDLIN(  27)						if ((this11 == 0)) {
HXLINE(  27)							g2 = ((Float)0.);
            						}
            						else {
HXLINE(  27)							g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            						}
HXDLIN(  27)						Float b21;
HXDLIN(  27)						int this12 = (-3554365 & 255);
HXDLIN(  27)						if ((this12 == 0)) {
HXLINE(  27)							b21 = ((Float)0.);
            						}
            						else {
HXLINE(  27)							b21 = (( (Float)(this12) ) / ( (Float)(255) ));
            						}
HXDLIN(  27)						Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  27)						int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  27)						int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  27)						int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  27)						int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  27)						int blended = ((((a4 << 24) | (r << 16)) | (g3 << 8)) | b3);
HXDLIN(  27)						{
HXLINE(  27)							int _hx_tmp3;
HXDLIN(  27)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  27)								_hx_tmp3 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            							}
            							else {
HXLINE(  27)								_hx_tmp3 = blended;
            							}
HXDLIN(  27)							::iterMagic::Iimg_obj::set(pixelImage->image,location,_hx_tmp3);
            						}
            					}
            					else {
HXLINE(  27)						::Dynamic this13 = pixelImage->image;
HXDLIN(  27)						int index;
HXDLIN(  27)						if (pixelImage->useVirtualPos) {
HXLINE(  27)							index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x1) - pixelImage->virtualX));
            						}
            						else {
HXLINE(  27)							index = ::Std_obj::_hx_int(( (Float)(((y1 * pixelImage->width) + x1)) ));
            						}
HXDLIN(  27)						int _hx_tmp4;
HXDLIN(  27)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  27)							_hx_tmp4 = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            						}
            						else {
HXLINE(  27)							_hx_tmp4 = c;
            						}
HXDLIN(  27)						::iterMagic::Iimg_obj::set(this13,index,_hx_tmp4);
            					}
            				}
            			}
            		}
HXLINE(  29)		pixelImage->transparent = true;
HXLINE(  30)		int Violet = -7077677;
HXLINE(  31)		int Indigo = -11861886;
HXLINE(  32)		int Blue = -16776961;
HXLINE(  33)		int Green = -16711936;
HXLINE(  34)		int Yellow = -256;
HXLINE(  35)		int Orange = -33024;
HXLINE(  36)		int Red = -65536;
HXLINE(  37)		int scale = 12;
HXLINE(  38)		int width = (80 * scale);
HXDLIN(  38)		int height = (80 * scale);
HXDLIN(  38)		 ::Dynamic imageType1 = null();
HXDLIN(  38)		 ::pi_xy::ImageStruct this14 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  38)		if (::hx::IsNull( imageType1 )) {
HXLINE(  54)			imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXLINE(  38)		::Dynamic _hx_tmp5;
HXDLIN(  38)		switch((int)(( (int)(imageType1) ))){
            			case (int)0: {
HXLINE(  38)				 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  38)				 ::iterMagic::BytesImg b4 = byt1;
HXDLIN(  38)				{
HXLINE(  38)					b4->width = width;
HXDLIN(  38)					b4->height = height;
HXDLIN(  38)					b4->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  38)					b4->data = ::haxe::io::Bytes_obj::alloc((b4->length * 4));
HXDLIN(  38)					{
HXLINE(  38)						int len2 = b4->length;
HXDLIN(  38)						int w1 = 0;
HXDLIN(  38)						{
HXLINE(  38)							int _g16 = 0;
HXDLIN(  38)							int _g17 = b4->height;
HXDLIN(  38)							while((_g16 < _g17)){
HXLINE(  38)								_g16 = (_g16 + 1);
HXDLIN(  38)								int y2 = (_g16 - 1);
HXDLIN(  38)								{
HXLINE(  38)									int _g18 = 0;
HXDLIN(  38)									int _g19 = b4->width;
HXDLIN(  38)									while((_g18 < _g19)){
HXLINE(  38)										_g18 = (_g18 + 1);
HXDLIN(  38)										int x2 = (_g18 - 1);
HXDLIN(  38)										{
HXLINE(  38)											w1 = (w1 + 1);
HXDLIN(  38)											b4->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  38)										{
HXLINE(  38)											w1 = (w1 + 1);
HXDLIN(  38)											b4->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  38)										{
HXLINE(  38)											w1 = (w1 + 1);
HXDLIN(  38)											b4->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  38)										{
HXLINE(  38)											w1 = (w1 + 1);
HXDLIN(  38)											b4->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  38)				_hx_tmp5 = b4;
            			}
            			break;
            			case (int)1: {
HXLINE(  38)				 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  38)				 ::iterMagic::ArrIntImg a5 = arrI1;
HXDLIN(  38)				{
HXLINE(  38)					a5->width = width;
HXDLIN(  38)					a5->height = height;
HXDLIN(  38)					a5->data = ::Array_obj< int >::__new(0);
HXDLIN(  38)					a5->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  38)					{
HXLINE(  38)						int _g20 = 0;
HXDLIN(  38)						int _g21 = a5->length;
HXDLIN(  38)						while((_g20 < _g21)){
HXLINE(  38)							_g20 = (_g20 + 1);
HXDLIN(  38)							int i8 = (_g20 - 1);
HXDLIN(  38)							a5->data[i8] = 0;
            						}
            					}
            				}
HXDLIN(  38)				_hx_tmp5 = a5;
            			}
            			break;
            			case (int)2: {
HXLINE(  38)				 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  38)				 ::iterMagic::U32ArrImg b5 = u32a1;
HXDLIN(  38)				{
HXLINE(  38)					b5->width = width;
HXDLIN(  38)					b5->height = height;
HXDLIN(  38)					b5->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  38)					int size1 = (b5->length * 4);
HXDLIN(  38)					b5->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  38)					{
HXLINE(  38)						int _g22 = 0;
HXDLIN(  38)						int _g23 = b5->length;
HXDLIN(  38)						while((_g22 < _g23)){
HXLINE(  38)							_g22 = (_g22 + 1);
HXDLIN(  38)							int i9 = (_g22 - 1);
HXDLIN(  38)							{
HXLINE(  38)								 ::haxe::io::ArrayBufferViewImpl this15 = b5->data;
HXDLIN(  38)								bool _hx_tmp6;
HXDLIN(  38)								if ((i9 >= 0)) {
HXLINE(  38)									_hx_tmp6 = (i9 < (this15->byteLength >> 2));
            								}
            								else {
HXLINE(  38)									_hx_tmp6 = false;
            								}
HXDLIN(  38)								if (_hx_tmp6) {
HXLINE(  38)									 ::haxe::io::Bytes _this1 = this15->bytes;
HXDLIN(  38)									int pos1 = ((i9 << 2) + this15->byteOffset);
HXDLIN(  38)									_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  38)									_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  38)									_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  38)									_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(  38)				_hx_tmp5 = b5;
            			}
            			break;
            			case (int)3: {
HXLINE(  38)				 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  38)				 ::iterMagic::VecIntImg v1 = vec1;
HXDLIN(  38)				{
HXLINE(  38)					v1->width = width;
HXDLIN(  38)					v1->height = height;
HXDLIN(  38)					v1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  38)					v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN(  38)					{
HXLINE(  38)						int _g24 = 0;
HXDLIN(  38)						int _g25 = v1->length;
HXDLIN(  38)						while((_g24 < _g25)){
HXLINE(  38)							_g24 = (_g24 + 1);
HXDLIN(  38)							int i10 = (_g24 - 1);
HXDLIN(  38)							v1->data->__unsafe_set(i10,0);
            						}
            					}
            				}
HXDLIN(  38)				_hx_tmp5 = v1;
            			}
            			break;
            			case (int)4: {
HXLINE(  38)				 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  38)				 ::iterMagic::StackIntImg b6 = sInt1;
HXDLIN(  38)				{
HXLINE(  38)					b6->width = width;
HXDLIN(  38)					b6->height = height;
HXDLIN(  38)					b6->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  38)					b6->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  38)					{
HXLINE(  38)						int len3 = b6->length;
HXDLIN(  38)						 ::haxe::ds::GenericStack_Int d1 = b6->data;
HXDLIN(  38)						if (::hx::IsNull( d1->head )) {
HXLINE(  38)							int _g26 = 0;
HXDLIN(  38)							int _g27 = len3;
HXDLIN(  38)							while((_g26 < _g27)){
HXLINE(  38)								_g26 = (_g26 + 1);
HXDLIN(  38)								int i11 = (_g26 - 1);
HXDLIN(  38)								d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            							}
            						}
            						else {
HXLINE(  38)							int _g28 = 0;
HXDLIN(  38)							int _g29 = len3;
HXDLIN(  38)							while((_g28 < _g29)){
HXLINE(  38)								_g28 = (_g28 + 1);
HXDLIN(  38)								int i12 = (_g28 - 1);
HXDLIN(  38)								{
HXLINE(  38)									 ::haxe::ds::GenericCell_Int l1 = b6->data->head;
HXDLIN(  38)									 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  38)									{
HXLINE(  38)										int _g30 = 0;
HXDLIN(  38)										int _g31 = i12;
HXDLIN(  38)										while((_g30 < _g31)){
HXLINE(  38)											_g30 = (_g30 + 1);
HXDLIN(  38)											int i13 = (_g30 - 1);
HXLINE( 345)											prev1 = l1;
HXLINE( 346)											l1 = l1->next;
            										}
            									}
HXLINE(  38)									if (::hx::IsNull( prev1 )) {
HXLINE(  38)										b6->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  38)										l1 = null();
            									}
            									else {
HXLINE(  38)										prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  38)										l1 = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  38)				_hx_tmp5 = b6;
            			}
            			break;
            		}
HXDLIN(  38)		this14->image = _hx_tmp5;
HXDLIN(  38)		this14->width = width;
HXDLIN(  38)		this14->height = height;
HXDLIN(  38)		this14->imageType = ( (int)(imageType1) );
HXDLIN(  38)		 ::pi_xy::ImageStruct pixelTest = this14;
HXLINE(  39)		pixelTest->transparent = true;
HXLINE(  40)		::Array< int > colors = ::Array_obj< int >::__new(7)->init(0,Violet)->init(1,Indigo)->init(2,Blue)->init(3,Green)->init(4,Yellow)->init(5,Orange)->init(6,Red);
HXLINE(  41)		int vertColor = colors->__get(0);
HXLINE(  42)		{
HXLINE(  42)			int _g32 = 0;
HXDLIN(  42)			int _g33 = (70 * scale);
HXDLIN(  42)			while((_g32 < _g33)){
HXLINE(  42)				_g32 = (_g32 + 1);
HXDLIN(  42)				int x3 = (_g32 - 1);
HXLINE(  43)				vertColor = colors->__get(::Math_obj::floor(((( (Float)(x3) ) / ( (Float)(scale) )) / ( (Float)(10) ))));
HXLINE(  44)				{
HXLINE(  44)					int _g34 = 0;
HXDLIN(  44)					int _g35 = 653;
HXDLIN(  44)					while((_g34 < _g35)){
HXLINE(  44)						_g34 = (_g34 + 1);
HXDLIN(  44)						int y3 = (_g34 - 1);
HXDLIN(  44)						{
HXLINE(  44)							int c1 = vertColor;
HXDLIN(  44)							bool _hx_tmp7;
HXDLIN(  44)							if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  44)								_hx_tmp7 = pixelTest->transparent;
            							}
            							else {
HXLINE(  44)								_hx_tmp7 = false;
            							}
HXDLIN(  44)							if (_hx_tmp7) {
HXLINE(  44)								int location1;
HXDLIN(  44)								if (pixelTest->useVirtualPos) {
HXLINE(  44)									location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - pixelTest->virtualY) * ( (Float)(pixelTest->width) )) + x3) - pixelTest->virtualX));
            								}
            								else {
HXLINE(  44)									location1 = ::Std_obj::_hx_int(( (Float)(((y3 * pixelTest->width) + x3)) ));
            								}
HXDLIN(  44)								int this16 = ::iterMagic::Iimg_obj::get(pixelTest->image,location1);
HXDLIN(  44)								int this17;
HXDLIN(  44)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)									this17 = ((((((this16 >> 24) & 255) << 24) | ((this16 & 255) << 16)) | (((this16 >> 8) & 255) << 8)) | ((this16 >> 16) & 255));
            								}
            								else {
HXLINE(  44)									this17 = this16;
            								}
HXDLIN(  44)								Float a11;
HXDLIN(  44)								int this18 = ((this17 >> 24) & 255);
HXDLIN(  44)								if ((this18 == 0)) {
HXLINE(  44)									a11 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									a11 = (( (Float)(this18) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float r11;
HXDLIN(  44)								int this19 = ((this17 >> 16) & 255);
HXDLIN(  44)								if ((this19 == 0)) {
HXLINE(  44)									r11 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									r11 = (( (Float)(this19) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float g11;
HXDLIN(  44)								int this20 = ((this17 >> 8) & 255);
HXDLIN(  44)								if ((this20 == 0)) {
HXLINE(  44)									g11 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									g11 = (( (Float)(this20) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float b12;
HXDLIN(  44)								int this21 = (this17 & 255);
HXDLIN(  44)								if ((this21 == 0)) {
HXLINE(  44)									b12 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									b12 = (( (Float)(this21) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float a21;
HXDLIN(  44)								int this22 = ((vertColor >> 24) & 255);
HXDLIN(  44)								if ((this22 == 0)) {
HXLINE(  44)									a21 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									a21 = (( (Float)(this22) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float r21;
HXDLIN(  44)								int this23 = ((vertColor >> 16) & 255);
HXDLIN(  44)								if ((this23 == 0)) {
HXLINE(  44)									r21 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									r21 = (( (Float)(this23) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float g21;
HXDLIN(  44)								int this24 = ((vertColor >> 8) & 255);
HXDLIN(  44)								if ((this24 == 0)) {
HXLINE(  44)									g21 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									g21 = (( (Float)(this24) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float b22;
HXDLIN(  44)								int this25 = (vertColor & 255);
HXDLIN(  44)								if ((this25 == 0)) {
HXLINE(  44)									b22 = ((Float)0.);
            								}
            								else {
HXLINE(  44)									b22 = (( (Float)(this25) ) / ( (Float)(255) ));
            								}
HXDLIN(  44)								Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  44)								int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  44)								int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  44)								int b7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  44)								int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  44)								int blended1 = ((((a6 << 24) | (r3 << 16)) | (g4 << 8)) | b7);
HXDLIN(  44)								{
HXLINE(  44)									int _hx_tmp8;
HXDLIN(  44)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)										_hx_tmp8 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            									}
            									else {
HXLINE(  44)										_hx_tmp8 = blended1;
            									}
HXDLIN(  44)									::iterMagic::Iimg_obj::set(pixelTest->image,location1,_hx_tmp8);
            								}
            							}
            							else {
HXLINE(  44)								::Dynamic this26 = pixelTest->image;
HXDLIN(  44)								int index1;
HXDLIN(  44)								if (pixelTest->useVirtualPos) {
HXLINE(  44)									index1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - pixelTest->virtualY) * ( (Float)(pixelTest->width) )) + x3) - pixelTest->virtualX));
            								}
            								else {
HXLINE(  44)									index1 = ::Std_obj::_hx_int(( (Float)(((y3 * pixelTest->width) + x3)) ));
            								}
HXDLIN(  44)								int _hx_tmp9;
HXDLIN(  44)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  44)									_hx_tmp9 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            								}
            								else {
HXLINE(  44)									_hx_tmp9 = c1;
            								}
HXDLIN(  44)								::iterMagic::Iimg_obj::set(this26,index1,_hx_tmp9);
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(  46)		{
HXLINE(  46)			 ::pi_xy::ImageStruct this27 = pixelTest;
HXDLIN(  46)			{
HXLINE(  46)				bool hasHit = false;
HXDLIN(  46)				bool hasUndo = false;
HXDLIN(  46)				int aA = 240;
HXDLIN(  46)				int rA = 0;
HXDLIN(  46)				int gA = 207;
HXDLIN(  46)				int bA = 255;
HXDLIN(  46)				int aB = 240;
HXDLIN(  46)				int rB = 255;
HXDLIN(  46)				int gB = 207;
HXDLIN(  46)				int bB = 0;
HXDLIN(  46)				int aC = 240;
HXDLIN(  46)				int rC = 207;
HXDLIN(  46)				int gC = 0;
HXDLIN(  46)				int bC = 255;
HXDLIN(  46)				Float bcx = ( (Float)(180) );
HXDLIN(  46)				Float bcy = ( (Float)(-80) );
HXDLIN(  46)				Float acx = ( (Float)(-20) );
HXDLIN(  46)				Float acy = ( (Float)(-200) );
HXDLIN(  46)				Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  46)				Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  46)				Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  46)				Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  46)				int ii_min2 = ::Math_obj::ceil(( (Float)(100) ));
HXDLIN(  46)				int ii_max2 = ::Math_obj::ceil(( (Float)(300) ));
HXDLIN(  46)				 ::pi_xy::iter::IntIterStart xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
HXDLIN(  46)				int ii_min3 = ::Math_obj::floor(( (Float)(100) ));
HXDLIN(  46)				int ii_max3 = ::Math_obj::ceil(( (Float)(300) ));
HXDLIN(  46)				 ::pi_xy::iter::IntIterStart yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
HXDLIN(  46)				 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  46)				if (hasUndo) {
HXLINE(  46)					int width1 = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  46)					int height1 = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  46)					 ::Dynamic imageType2 = null();
HXDLIN(  46)					 ::pi_xy::ImageStruct this28 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  46)					if (::hx::IsNull( imageType2 )) {
HXLINE(  54)						imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE(  46)					::Dynamic undoImage1;
HXDLIN(  46)					switch((int)(( (int)(imageType2) ))){
            						case (int)0: {
HXLINE(  46)							 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  46)							 ::iterMagic::BytesImg b8 = byt2;
HXDLIN(  46)							{
HXLINE(  46)								b8->width = width1;
HXDLIN(  46)								b8->height = height1;
HXDLIN(  46)								b8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  46)								b8->data = ::haxe::io::Bytes_obj::alloc((b8->length * 4));
HXDLIN(  46)								{
HXLINE(  46)									int len4 = b8->length;
HXDLIN(  46)									int w2 = 0;
HXDLIN(  46)									{
HXLINE(  46)										int _g36 = 0;
HXDLIN(  46)										int _g37 = b8->height;
HXDLIN(  46)										while((_g36 < _g37)){
HXLINE(  46)											_g36 = (_g36 + 1);
HXDLIN(  46)											int y4 = (_g36 - 1);
HXDLIN(  46)											{
HXLINE(  46)												int _g38 = 0;
HXDLIN(  46)												int _g39 = b8->width;
HXDLIN(  46)												while((_g38 < _g39)){
HXLINE(  46)													_g38 = (_g38 + 1);
HXDLIN(  46)													int x4 = (_g38 - 1);
HXDLIN(  46)													{
HXLINE(  46)														w2 = (w2 + 1);
HXDLIN(  46)														b8->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  46)													{
HXLINE(  46)														w2 = (w2 + 1);
HXDLIN(  46)														b8->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  46)													{
HXLINE(  46)														w2 = (w2 + 1);
HXDLIN(  46)														b8->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  46)													{
HXLINE(  46)														w2 = (w2 + 1);
HXDLIN(  46)														b8->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  46)							undoImage1 = b8;
            						}
            						break;
            						case (int)1: {
HXLINE(  46)							 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  46)							 ::iterMagic::ArrIntImg a7 = arrI2;
HXDLIN(  46)							{
HXLINE(  46)								a7->width = width1;
HXDLIN(  46)								a7->height = height1;
HXDLIN(  46)								a7->data = ::Array_obj< int >::__new(0);
HXDLIN(  46)								a7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  46)								{
HXLINE(  46)									int _g40 = 0;
HXDLIN(  46)									int _g41 = a7->length;
HXDLIN(  46)									while((_g40 < _g41)){
HXLINE(  46)										_g40 = (_g40 + 1);
HXDLIN(  46)										int i14 = (_g40 - 1);
HXDLIN(  46)										a7->data[i14] = 0;
            									}
            								}
            							}
HXDLIN(  46)							undoImage1 = a7;
            						}
            						break;
            						case (int)2: {
HXLINE(  46)							 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  46)							 ::iterMagic::U32ArrImg b9 = u32a2;
HXDLIN(  46)							{
HXLINE(  46)								b9->width = width1;
HXDLIN(  46)								b9->height = height1;
HXDLIN(  46)								b9->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  46)								int size2 = (b9->length * 4);
HXDLIN(  46)								b9->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN(  46)								{
HXLINE(  46)									int _g42 = 0;
HXDLIN(  46)									int _g43 = b9->length;
HXDLIN(  46)									while((_g42 < _g43)){
HXLINE(  46)										_g42 = (_g42 + 1);
HXDLIN(  46)										int i15 = (_g42 - 1);
HXDLIN(  46)										{
HXLINE(  46)											 ::haxe::io::ArrayBufferViewImpl this29 = b9->data;
HXDLIN(  46)											bool undoImage2;
HXDLIN(  46)											if ((i15 >= 0)) {
HXLINE(  46)												undoImage2 = (i15 < (this29->byteLength >> 2));
            											}
            											else {
HXLINE(  46)												undoImage2 = false;
            											}
HXDLIN(  46)											if (undoImage2) {
HXLINE(  46)												 ::haxe::io::Bytes _this2 = this29->bytes;
HXDLIN(  46)												int pos2 = ((i15 << 2) + this29->byteOffset);
HXDLIN(  46)												_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN(  46)												_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN(  46)												_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN(  46)												_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN(  46)							undoImage1 = b9;
            						}
            						break;
            						case (int)3: {
HXLINE(  46)							 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  46)							 ::iterMagic::VecIntImg v2 = vec2;
HXDLIN(  46)							{
HXLINE(  46)								v2->width = width1;
HXDLIN(  46)								v2->height = height1;
HXDLIN(  46)								v2->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  46)								v2->data = ::Array_obj< int >::__new(v2->length);
HXDLIN(  46)								{
HXLINE(  46)									int _g44 = 0;
HXDLIN(  46)									int _g45 = v2->length;
HXDLIN(  46)									while((_g44 < _g45)){
HXLINE(  46)										_g44 = (_g44 + 1);
HXDLIN(  46)										int i16 = (_g44 - 1);
HXDLIN(  46)										v2->data->__unsafe_set(i16,0);
            									}
            								}
            							}
HXDLIN(  46)							undoImage1 = v2;
            						}
            						break;
            						case (int)4: {
HXLINE(  46)							 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  46)							 ::iterMagic::StackIntImg b10 = sInt2;
HXDLIN(  46)							{
HXLINE(  46)								b10->width = width1;
HXDLIN(  46)								b10->height = height1;
HXDLIN(  46)								b10->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  46)								b10->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  46)								{
HXLINE(  46)									int len5 = b10->length;
HXDLIN(  46)									 ::haxe::ds::GenericStack_Int d2 = b10->data;
HXDLIN(  46)									if (::hx::IsNull( d2->head )) {
HXLINE(  46)										int _g46 = 0;
HXDLIN(  46)										int _g47 = len5;
HXDLIN(  46)										while((_g46 < _g47)){
HXLINE(  46)											_g46 = (_g46 + 1);
HXDLIN(  46)											int i17 = (_g46 - 1);
HXDLIN(  46)											d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            										}
            									}
            									else {
HXLINE(  46)										int _g48 = 0;
HXDLIN(  46)										int _g49 = len5;
HXDLIN(  46)										while((_g48 < _g49)){
HXLINE(  46)											_g48 = (_g48 + 1);
HXDLIN(  46)											int i18 = (_g48 - 1);
HXDLIN(  46)											{
HXLINE(  46)												 ::haxe::ds::GenericCell_Int l2 = b10->data->head;
HXDLIN(  46)												 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN(  46)												{
HXLINE(  46)													int _g50 = 0;
HXDLIN(  46)													int _g51 = i18;
HXDLIN(  46)													while((_g50 < _g51)){
HXLINE(  46)														_g50 = (_g50 + 1);
HXDLIN(  46)														int i19 = (_g50 - 1);
HXLINE( 345)														prev2 = l2;
HXLINE( 346)														l2 = l2->next;
            													}
            												}
HXLINE(  46)												if (::hx::IsNull( prev2 )) {
HXLINE(  46)													b10->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  46)													l2 = null();
            												}
            												else {
HXLINE(  46)													prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  46)													l2 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  46)							undoImage1 = b10;
            						}
            						break;
            					}
HXDLIN(  46)					this28->image = undoImage1;
HXDLIN(  46)					this28->width = width1;
HXDLIN(  46)					this28->height = height1;
HXDLIN(  46)					this28->imageType = ( (int)(imageType2) );
HXDLIN(  46)					undoImage = this28;
HXDLIN(  46)					{
HXLINE(  46)						int rectLeft = xIter3->start;
HXDLIN(  46)						int rectTop = yIter3->start;
HXDLIN(  46)						int rectRight = xIter3->max;
HXDLIN(  46)						bool forceClear = false;
HXDLIN(  46)						{
HXLINE(  46)							int _g52 = rectTop;
HXDLIN(  46)							int _g53 = yIter3->max;
HXDLIN(  46)							while((_g52 < _g53)){
HXLINE(  46)								_g52 = (_g52 + 1);
HXDLIN(  46)								int dy = (_g52 - 1);
HXDLIN(  46)								{
HXLINE(  46)									int _g54 = rectLeft;
HXDLIN(  46)									int _g55 = rectRight;
HXDLIN(  46)									while((_g54 < _g55)){
HXLINE(  46)										_g54 = (_g54 + 1);
HXDLIN(  46)										int dx = (_g54 - 1);
HXDLIN(  46)										::Dynamic this30 = this27->image;
HXDLIN(  46)										int index2;
HXDLIN(  46)										if (this27->useVirtualPos) {
HXLINE(  46)											index2 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this27->virtualY) * ( (Float)(this27->width) )) + dx) - this27->virtualX));
            										}
            										else {
HXLINE(  46)											index2 = ::Std_obj::_hx_int(( (Float)(((dy * this27->width) + dx)) ));
            										}
HXDLIN(  46)										int c2 = ::iterMagic::Iimg_obj::get(this30,index2);
HXDLIN(  46)										int col;
HXDLIN(  46)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  46)											col = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXLINE(  46)											col = c2;
            										}
HXDLIN(  46)										bool _hx_tmp10;
HXDLIN(  46)										if (this27->useMask) {
HXLINE(  46)											_hx_tmp10 = ::hx::IsNotNull( this27->mask );
            										}
            										else {
HXLINE(  46)											_hx_tmp10 = false;
            										}
HXDLIN(  46)										if (_hx_tmp10) {
HXLINE(  46)											 ::pi_xy::ImageStruct this31 = this27->mask;
HXDLIN(  46)											::Dynamic this32 = this31->image;
HXDLIN(  46)											int index3;
HXDLIN(  46)											if (this31->useVirtualPos) {
HXLINE(  46)												index3 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this31->virtualY) * ( (Float)(this31->width) )) + dx) - this31->virtualX));
            											}
            											else {
HXLINE(  46)												index3 = ::Std_obj::_hx_int(( (Float)(((dy * this31->width) + dx)) ));
            											}
HXDLIN(  46)											int c3 = ::iterMagic::Iimg_obj::get(this32,index3);
HXDLIN(  46)											int v3;
HXDLIN(  46)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  46)												v3 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            											}
            											else {
HXLINE(  46)												v3 = c3;
            											}
HXDLIN(  46)											int maskPixel = v3;
HXDLIN(  46)											int this33 = col;
HXDLIN(  46)											if ((maskPixel == 0)) {
HXLINE(  46)												col = this33;
            											}
            											else {
HXLINE(  46)												Float m0;
HXDLIN(  46)												int this34 = ((maskPixel >> 24) & 255);
HXDLIN(  46)												if ((this34 == 0)) {
HXLINE(  46)													m0 = ((Float)0.);
            												}
            												else {
HXLINE(  46)													m0 = (( (Float)(this34) ) / ( (Float)(255) ));
            												}
HXDLIN(  46)												Float m1;
HXDLIN(  46)												int this35 = ((maskPixel >> 16) & 255);
HXDLIN(  46)												if ((this35 == 0)) {
HXLINE(  46)													m1 = ((Float)0.);
            												}
            												else {
HXLINE(  46)													m1 = (( (Float)(this35) ) / ( (Float)(255) ));
            												}
HXDLIN(  46)												Float m2;
HXDLIN(  46)												int this36 = ((maskPixel >> 8) & 255);
HXDLIN(  46)												if ((this36 == 0)) {
HXLINE(  46)													m2 = ((Float)0.);
            												}
            												else {
HXLINE(  46)													m2 = (( (Float)(this36) ) / ( (Float)(255) ));
            												}
HXDLIN(  46)												Float m3;
HXDLIN(  46)												int this37 = (maskPixel & 255);
HXDLIN(  46)												if ((this37 == 0)) {
HXLINE(  46)													m3 = ((Float)0.);
            												}
            												else {
HXLINE(  46)													m3 = (( (Float)(this37) ) / ( (Float)(255) ));
            												}
HXDLIN(  46)												int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this33 >> 24) & 255)) )));
HXDLIN(  46)												int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this33 >> 16) & 255)) )));
HXDLIN(  46)												int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this33 >> 8) & 255)) )));
HXDLIN(  46)												int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this33 & 255)) )));
HXDLIN(  46)												col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN(  46)										if ((col != 0)) {
HXLINE(  46)											int x5 = (dx - rectLeft);
HXDLIN(  46)											int y5 = (dy - rectTop);
HXDLIN(  46)											int c4 = col;
HXDLIN(  46)											bool _hx_tmp11;
HXDLIN(  46)											if ((((c4 >> 24) & 255) < 254)) {
HXLINE(  46)												_hx_tmp11 = undoImage->transparent;
            											}
            											else {
HXLINE(  46)												_hx_tmp11 = false;
            											}
HXDLIN(  46)											if (_hx_tmp11) {
HXLINE(  46)												int location2;
HXDLIN(  46)												if (undoImage->useVirtualPos) {
HXLINE(  46)													location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            												}
            												else {
HXLINE(  46)													location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage->width) + x5)) ));
            												}
HXDLIN(  46)												int this38 = ::iterMagic::Iimg_obj::get(undoImage->image,location2);
HXDLIN(  46)												int this39;
HXDLIN(  46)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  46)													this39 = ((((((this38 >> 24) & 255) << 24) | ((this38 & 255) << 16)) | (((this38 >> 8) & 255) << 8)) | ((this38 >> 16) & 255));
            												}
            												else {
HXLINE(  46)													this39 = this38;
            												}
HXDLIN(  46)												Float a12;
HXDLIN(  46)												int this40 = ((this39 >> 24) & 255);
HXDLIN(  46)												if ((this40 == 0)) {
HXLINE(  46)													a12 = ((Float)0.);
            												}
            												else {
HXLINE(  46)													a12 = (( (Float)(this40) ) / ( (Float)(255) ));
            												}
HXDLIN(  46)												Float r12;
HXDLIN(  46)												int this41 = ((this39 >> 16) & 255);
HXDLIN(  46)												if ((this41 == 0)) {
HXLINE(  46)													r12 = ((Float)0.);
            												}
            												else {
HXLINE(  46)													r12 = (( (Float)(this41) ) / ( (Float)(255) ));
            												}
HXDLIN(  46)												Float g12;
HXDLIN(  46)												int this42 = ((this39 >> 8) & 255);
HXDLIN(  46)												if ((this42 == 0)) {
HXLINE(  46)													g12 = ((Float)0.);
            												}
            												else {
HXLINE(  46)													g12 = (( (Float)(this42) ) / ( (Float)(255) ));
            												}
HXDLIN(  46)												Float b13;
HXDLIN(  46)												int this43 = (this39 & 255);
HXDLIN(  46)												if ((this43 == 0)) {
HXLINE(  46)													b13 = ((Float)0.);
            												}
            												else {
HXLINE(  46)													b13 = (( (Float)(this43) ) / ( (Float)(255) ));
            												}
HXDLIN(  46)												Float a22;
HXDLIN(  46)												int this44 = ((col >> 24) & 255);
HXDLIN(  46)												if ((this44 == 0)) {
HXLINE(  46)													a22 = ((Float)0.);
            												}
            												else {
HXLINE(  46)													a22 = (( (Float)(this44) ) / ( (Float)(255) ));
            												}
HXDLIN(  46)												Float r22;
HXDLIN(  46)												int this45 = ((col >> 16) & 255);
HXDLIN(  46)												if ((this45 == 0)) {
HXLINE(  46)													r22 = ((Float)0.);
            												}
            												else {
HXLINE(  46)													r22 = (( (Float)(this45) ) / ( (Float)(255) ));
            												}
HXDLIN(  46)												Float g22;
HXDLIN(  46)												int this46 = ((col >> 8) & 255);
HXDLIN(  46)												if ((this46 == 0)) {
HXLINE(  46)													g22 = ((Float)0.);
            												}
            												else {
HXLINE(  46)													g22 = (( (Float)(this46) ) / ( (Float)(255) ));
            												}
HXDLIN(  46)												Float b23;
HXDLIN(  46)												int this47 = (col & 255);
HXDLIN(  46)												if ((this47 == 0)) {
HXLINE(  46)													b23 = ((Float)0.);
            												}
            												else {
HXLINE(  46)													b23 = (( (Float)(this47) ) / ( (Float)(255) ));
            												}
HXDLIN(  46)												Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  46)												int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  46)												int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  46)												int b14 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  46)												int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  46)												int blended2 = ((((a8 << 24) | (r4 << 16)) | (g5 << 8)) | b14);
HXDLIN(  46)												{
HXLINE(  46)													int _hx_tmp12;
HXDLIN(  46)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  46)														_hx_tmp12 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            													}
            													else {
HXLINE(  46)														_hx_tmp12 = blended2;
            													}
HXDLIN(  46)													::iterMagic::Iimg_obj::set(undoImage->image,location2,_hx_tmp12);
            												}
            											}
            											else {
HXLINE(  46)												::Dynamic this48 = undoImage->image;
HXDLIN(  46)												int index4;
HXDLIN(  46)												if (undoImage->useVirtualPos) {
HXLINE(  46)													index4 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            												}
            												else {
HXLINE(  46)													index4 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage->width) + x5)) ));
            												}
HXDLIN(  46)												int _hx_tmp13;
HXDLIN(  46)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  46)													_hx_tmp13 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            												}
            												else {
HXLINE(  46)													_hx_tmp13 = c4;
            												}
HXDLIN(  46)												::iterMagic::Iimg_obj::set(this48,index4,_hx_tmp13);
            											}
            										}
            										else {
HXLINE(  46)											if (forceClear) {
HXLINE(  46)												::Dynamic this49 = undoImage->image;
HXDLIN(  46)												int x6 = (dx - rectLeft);
HXDLIN(  46)												int y6 = (dy - rectTop);
HXDLIN(  46)												int index5;
HXDLIN(  46)												if (undoImage->useVirtualPos) {
HXLINE(  46)													index5 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x6) - undoImage->virtualX));
            												}
            												else {
HXLINE(  46)													index5 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage->width) + x6)) ));
            												}
HXDLIN(  46)												::iterMagic::Iimg_obj::set(this49,index5,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  46)				{
HXLINE(  46)					int _g_min = xIter3->start;
HXDLIN(  46)					int _g_max = xIter3->max;
HXDLIN(  46)					while((_g_min < _g_max)){
HXLINE(  46)						_g_min = (_g_min + 1);
HXDLIN(  46)						int px = (_g_min - 1);
HXDLIN(  46)						Float pcx = (( (Float)(px) ) - ( (Float)(120) ));
HXDLIN(  46)						{
HXLINE(  46)							int _g_min1 = yIter3->start;
HXDLIN(  46)							int _g_max1 = yIter3->max;
HXDLIN(  46)							while((_g_min1 < _g_max1)){
HXLINE(  46)								_g_min1 = (_g_min1 + 1);
HXDLIN(  46)								int py = (_g_min1 - 1);
HXDLIN(  46)								Float pcy = (( (Float)(py) ) - ( (Float)(300) ));
HXDLIN(  46)								Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  46)								Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  46)								Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  46)								Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  46)								Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  46)								bool _hx_tmp14;
HXDLIN(  46)								bool _hx_tmp15;
HXDLIN(  46)								if ((ratioA >= 0)) {
HXLINE(  46)									_hx_tmp15 = (ratioB >= 0);
            								}
            								else {
HXLINE(  46)									_hx_tmp15 = false;
            								}
HXDLIN(  46)								if (_hx_tmp15) {
HXLINE(  46)									_hx_tmp14 = (ratioC >= 0);
            								}
            								else {
HXLINE(  46)									_hx_tmp14 = false;
            								}
HXDLIN(  46)								if (_hx_tmp14) {
HXLINE(  46)									int i20 = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN(  46)									if ((i20 > 255)) {
HXLINE(  24)										i20 = 255;
            									}
HXLINE(  46)									if ((i20 < 0)) {
HXLINE(  25)										i20 = 0;
            									}
HXLINE(  46)									int a9 = i20;
HXDLIN(  46)									int i21 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN(  46)									if ((i21 > 255)) {
HXLINE(  24)										i21 = 255;
            									}
HXLINE(  46)									if ((i21 < 0)) {
HXLINE(  25)										i21 = 0;
            									}
HXLINE(  46)									int r5 = i21;
HXDLIN(  46)									int i22 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN(  46)									if ((i22 > 255)) {
HXLINE(  24)										i22 = 255;
            									}
HXLINE(  46)									if ((i22 < 0)) {
HXLINE(  25)										i22 = 0;
            									}
HXLINE(  46)									int g6 = i22;
HXDLIN(  46)									int i23 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN(  46)									if ((i23 > 255)) {
HXLINE(  24)										i23 = 255;
            									}
HXLINE(  46)									if ((i23 < 0)) {
HXLINE(  25)										i23 = 0;
            									}
HXLINE(  46)									int b15 = i23;
HXDLIN(  46)									{
HXLINE(  46)										int location3;
HXDLIN(  46)										if (this27->useVirtualPos) {
HXLINE(  46)											location3 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this27->virtualY) * ( (Float)(this27->width) )) + px) - this27->virtualX));
            										}
            										else {
HXLINE(  46)											location3 = ::Std_obj::_hx_int(( (Float)(((py * this27->width) + px)) ));
            										}
HXDLIN(  46)										bool _hx_tmp16;
HXDLIN(  46)										if (this27->transparent) {
HXLINE(  46)											_hx_tmp16 = (a9 < 254);
            										}
            										else {
HXLINE(  46)											_hx_tmp16 = false;
            										}
HXDLIN(  46)										if (_hx_tmp16) {
HXLINE(  46)											int this50 = ::iterMagic::Iimg_obj::get(this27->image,location3);
HXDLIN(  46)											int old;
HXDLIN(  46)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  46)												old = ((((((this50 >> 24) & 255) << 24) | ((this50 & 255) << 16)) | (((this50 >> 8) & 255) << 8)) | ((this50 >> 16) & 255));
            											}
            											else {
HXLINE(  46)												old = this50;
            											}
HXDLIN(  46)											int rhs = ((((a9 << 24) | (r5 << 16)) | (g6 << 8)) | b15);
HXDLIN(  46)											Float a13;
HXDLIN(  46)											int this51 = ((old >> 24) & 255);
HXDLIN(  46)											if ((this51 == 0)) {
HXLINE(  46)												a13 = ((Float)0.);
            											}
            											else {
HXLINE(  46)												a13 = (( (Float)(this51) ) / ( (Float)(255) ));
            											}
HXDLIN(  46)											Float r13;
HXDLIN(  46)											int this52 = ((old >> 16) & 255);
HXDLIN(  46)											if ((this52 == 0)) {
HXLINE(  46)												r13 = ((Float)0.);
            											}
            											else {
HXLINE(  46)												r13 = (( (Float)(this52) ) / ( (Float)(255) ));
            											}
HXDLIN(  46)											Float g13;
HXDLIN(  46)											int this53 = ((old >> 8) & 255);
HXDLIN(  46)											if ((this53 == 0)) {
HXLINE(  46)												g13 = ((Float)0.);
            											}
            											else {
HXLINE(  46)												g13 = (( (Float)(this53) ) / ( (Float)(255) ));
            											}
HXDLIN(  46)											Float b16;
HXDLIN(  46)											int this54 = (old & 255);
HXDLIN(  46)											if ((this54 == 0)) {
HXLINE(  46)												b16 = ((Float)0.);
            											}
            											else {
HXLINE(  46)												b16 = (( (Float)(this54) ) / ( (Float)(255) ));
            											}
HXDLIN(  46)											Float a23;
HXDLIN(  46)											int this55 = ((rhs >> 24) & 255);
HXDLIN(  46)											if ((this55 == 0)) {
HXLINE(  46)												a23 = ((Float)0.);
            											}
            											else {
HXLINE(  46)												a23 = (( (Float)(this55) ) / ( (Float)(255) ));
            											}
HXDLIN(  46)											Float r23;
HXDLIN(  46)											int this56 = ((rhs >> 16) & 255);
HXDLIN(  46)											if ((this56 == 0)) {
HXLINE(  46)												r23 = ((Float)0.);
            											}
            											else {
HXLINE(  46)												r23 = (( (Float)(this56) ) / ( (Float)(255) ));
            											}
HXDLIN(  46)											Float g23;
HXDLIN(  46)											int this57 = ((rhs >> 8) & 255);
HXDLIN(  46)											if ((this57 == 0)) {
HXLINE(  46)												g23 = ((Float)0.);
            											}
            											else {
HXLINE(  46)												g23 = (( (Float)(this57) ) / ( (Float)(255) ));
            											}
HXDLIN(  46)											Float b24;
HXDLIN(  46)											int this58 = (rhs & 255);
HXDLIN(  46)											if ((this58 == 0)) {
HXLINE(  46)												b24 = ((Float)0.);
            											}
            											else {
HXLINE(  46)												b24 = (( (Float)(this58) ) / ( (Float)(255) ));
            											}
HXDLIN(  46)											Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  46)											int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  46)											int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  46)											int b17 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b16 * a33) + (b24 * a23))));
HXDLIN(  46)											int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  46)											int blended3 = ((((a10 << 24) | (r6 << 16)) | (g7 << 8)) | b17);
HXDLIN(  46)											{
HXLINE(  46)												int _hx_tmp17;
HXDLIN(  46)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  46)													_hx_tmp17 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            												}
            												else {
HXLINE(  46)													_hx_tmp17 = blended3;
            												}
HXDLIN(  46)												::iterMagic::Iimg_obj::set(this27->image,location3,_hx_tmp17);
            											}
            										}
            										else {
HXLINE(  46)											int value;
HXDLIN(  46)											if (this27->isLittle) {
HXLINE(  46)												value = ((((a9 << 24) | (b15 << 16)) | (g6 << 8)) | r5);
            											}
            											else {
HXLINE(  46)												value = ((((a9 << 24) | (r5 << 16)) | (g6 << 8)) | b15);
            											}
HXDLIN(  46)											::iterMagic::Iimg_obj::set(this27->image,location3,value);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  46)				if ((hasHit == false)) {
HXLINE(  46)					 ::pi_xy::algo::HitTri v4 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,( (Float)(100) ),( (Float)(100) ),( (Float)(300) ),( (Float)(220) ),( (Float)(120) ),( (Float)(300) ),true);
HXDLIN(  46)					if (hasUndo) {
HXLINE(  46)						v4->undoImage = undoImage;
HXDLIN(  46)						v4->undoX = xIter3->start;
HXDLIN(  46)						v4->undoY = yIter3->start;
            					}
            				}
            			}
            		}
HXLINE(  47)		{
HXLINE(  47)			 ::pi_xy::ImageStruct this59 = pixelTest;
HXDLIN(  47)			{
HXLINE(  47)				bool hasHit1 = false;
HXDLIN(  47)				bool hasUndo1 = false;
HXDLIN(  47)				int aA1 = 204;
HXDLIN(  47)				int rA1 = 0;
HXDLIN(  47)				int gA1 = 0;
HXDLIN(  47)				int bA1 = 255;
HXDLIN(  47)				int aB1 = 204;
HXDLIN(  47)				int rB1 = 255;
HXDLIN(  47)				int gB1 = 0;
HXDLIN(  47)				int bB1 = 0;
HXDLIN(  47)				int aC1 = 204;
HXDLIN(  47)				int rC1 = 0;
HXDLIN(  47)				int gC1 = 255;
HXDLIN(  47)				int bC1 = 0;
HXDLIN(  47)				Float bcx1 = ( (Float)(180) );
HXDLIN(  47)				Float bcy1 = ( (Float)(-80) );
HXDLIN(  47)				Float acx1 = ( (Float)(-20) );
HXDLIN(  47)				Float acy1 = ( (Float)(-200) );
HXDLIN(  47)				Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  47)				Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  47)				Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  47)				Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  47)				int ii_min4 = ::Math_obj::ceil(( (Float)(220) ));
HXDLIN(  47)				int ii_max4 = ::Math_obj::ceil(( (Float)(420) ));
HXDLIN(  47)				 ::pi_xy::iter::IntIterStart xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
HXDLIN(  47)				int ii_min5 = ::Math_obj::floor(( (Float)(120) ));
HXDLIN(  47)				int ii_max5 = ::Math_obj::ceil(( (Float)(320) ));
HXDLIN(  47)				 ::pi_xy::iter::IntIterStart yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
HXDLIN(  47)				 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  47)				if (hasUndo1) {
HXLINE(  47)					int width2 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  47)					int height2 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  47)					 ::Dynamic imageType3 = null();
HXDLIN(  47)					 ::pi_xy::ImageStruct this60 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  47)					if (::hx::IsNull( imageType3 )) {
HXLINE(  54)						imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE(  47)					::Dynamic undoImage4;
HXDLIN(  47)					switch((int)(( (int)(imageType3) ))){
            						case (int)0: {
HXLINE(  47)							 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  47)							 ::iterMagic::BytesImg b18 = byt3;
HXDLIN(  47)							{
HXLINE(  47)								b18->width = width2;
HXDLIN(  47)								b18->height = height2;
HXDLIN(  47)								b18->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  47)								b18->data = ::haxe::io::Bytes_obj::alloc((b18->length * 4));
HXDLIN(  47)								{
HXLINE(  47)									int len6 = b18->length;
HXDLIN(  47)									int w3 = 0;
HXDLIN(  47)									{
HXLINE(  47)										int _g56 = 0;
HXDLIN(  47)										int _g57 = b18->height;
HXDLIN(  47)										while((_g56 < _g57)){
HXLINE(  47)											_g56 = (_g56 + 1);
HXDLIN(  47)											int y7 = (_g56 - 1);
HXDLIN(  47)											{
HXLINE(  47)												int _g58 = 0;
HXDLIN(  47)												int _g59 = b18->width;
HXDLIN(  47)												while((_g58 < _g59)){
HXLINE(  47)													_g58 = (_g58 + 1);
HXDLIN(  47)													int x7 = (_g58 - 1);
HXDLIN(  47)													{
HXLINE(  47)														w3 = (w3 + 1);
HXDLIN(  47)														b18->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  47)													{
HXLINE(  47)														w3 = (w3 + 1);
HXDLIN(  47)														b18->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  47)													{
HXLINE(  47)														w3 = (w3 + 1);
HXDLIN(  47)														b18->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  47)													{
HXLINE(  47)														w3 = (w3 + 1);
HXDLIN(  47)														b18->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  47)							undoImage4 = b18;
            						}
            						break;
            						case (int)1: {
HXLINE(  47)							 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  47)							 ::iterMagic::ArrIntImg a14 = arrI3;
HXDLIN(  47)							{
HXLINE(  47)								a14->width = width2;
HXDLIN(  47)								a14->height = height2;
HXDLIN(  47)								a14->data = ::Array_obj< int >::__new(0);
HXDLIN(  47)								a14->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  47)								{
HXLINE(  47)									int _g60 = 0;
HXDLIN(  47)									int _g61 = a14->length;
HXDLIN(  47)									while((_g60 < _g61)){
HXLINE(  47)										_g60 = (_g60 + 1);
HXDLIN(  47)										int i24 = (_g60 - 1);
HXDLIN(  47)										a14->data[i24] = 0;
            									}
            								}
            							}
HXDLIN(  47)							undoImage4 = a14;
            						}
            						break;
            						case (int)2: {
HXLINE(  47)							 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  47)							 ::iterMagic::U32ArrImg b19 = u32a3;
HXDLIN(  47)							{
HXLINE(  47)								b19->width = width2;
HXDLIN(  47)								b19->height = height2;
HXDLIN(  47)								b19->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  47)								int size3 = (b19->length * 4);
HXDLIN(  47)								b19->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN(  47)								{
HXLINE(  47)									int _g62 = 0;
HXDLIN(  47)									int _g63 = b19->length;
HXDLIN(  47)									while((_g62 < _g63)){
HXLINE(  47)										_g62 = (_g62 + 1);
HXDLIN(  47)										int i25 = (_g62 - 1);
HXDLIN(  47)										{
HXLINE(  47)											 ::haxe::io::ArrayBufferViewImpl this61 = b19->data;
HXDLIN(  47)											bool undoImage5;
HXDLIN(  47)											if ((i25 >= 0)) {
HXLINE(  47)												undoImage5 = (i25 < (this61->byteLength >> 2));
            											}
            											else {
HXLINE(  47)												undoImage5 = false;
            											}
HXDLIN(  47)											if (undoImage5) {
HXLINE(  47)												 ::haxe::io::Bytes _this3 = this61->bytes;
HXDLIN(  47)												int pos3 = ((i25 << 2) + this61->byteOffset);
HXDLIN(  47)												_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN(  47)												_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN(  47)												_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN(  47)												_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN(  47)							undoImage4 = b19;
            						}
            						break;
            						case (int)3: {
HXLINE(  47)							 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  47)							 ::iterMagic::VecIntImg v5 = vec3;
HXDLIN(  47)							{
HXLINE(  47)								v5->width = width2;
HXDLIN(  47)								v5->height = height2;
HXDLIN(  47)								v5->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  47)								v5->data = ::Array_obj< int >::__new(v5->length);
HXDLIN(  47)								{
HXLINE(  47)									int _g64 = 0;
HXDLIN(  47)									int _g65 = v5->length;
HXDLIN(  47)									while((_g64 < _g65)){
HXLINE(  47)										_g64 = (_g64 + 1);
HXDLIN(  47)										int i26 = (_g64 - 1);
HXDLIN(  47)										v5->data->__unsafe_set(i26,0);
            									}
            								}
            							}
HXDLIN(  47)							undoImage4 = v5;
            						}
            						break;
            						case (int)4: {
HXLINE(  47)							 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  47)							 ::iterMagic::StackIntImg b20 = sInt3;
HXDLIN(  47)							{
HXLINE(  47)								b20->width = width2;
HXDLIN(  47)								b20->height = height2;
HXDLIN(  47)								b20->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  47)								b20->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  47)								{
HXLINE(  47)									int len7 = b20->length;
HXDLIN(  47)									 ::haxe::ds::GenericStack_Int d3 = b20->data;
HXDLIN(  47)									if (::hx::IsNull( d3->head )) {
HXLINE(  47)										int _g66 = 0;
HXDLIN(  47)										int _g67 = len7;
HXDLIN(  47)										while((_g66 < _g67)){
HXLINE(  47)											_g66 = (_g66 + 1);
HXDLIN(  47)											int i27 = (_g66 - 1);
HXDLIN(  47)											d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            										}
            									}
            									else {
HXLINE(  47)										int _g68 = 0;
HXDLIN(  47)										int _g69 = len7;
HXDLIN(  47)										while((_g68 < _g69)){
HXLINE(  47)											_g68 = (_g68 + 1);
HXDLIN(  47)											int i28 = (_g68 - 1);
HXDLIN(  47)											{
HXLINE(  47)												 ::haxe::ds::GenericCell_Int l3 = b20->data->head;
HXDLIN(  47)												 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN(  47)												{
HXLINE(  47)													int _g70 = 0;
HXDLIN(  47)													int _g71 = i28;
HXDLIN(  47)													while((_g70 < _g71)){
HXLINE(  47)														_g70 = (_g70 + 1);
HXDLIN(  47)														int i29 = (_g70 - 1);
HXLINE( 345)														prev3 = l3;
HXLINE( 346)														l3 = l3->next;
            													}
            												}
HXLINE(  47)												if (::hx::IsNull( prev3 )) {
HXLINE(  47)													b20->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  47)													l3 = null();
            												}
            												else {
HXLINE(  47)													prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  47)													l3 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  47)							undoImage4 = b20;
            						}
            						break;
            					}
HXDLIN(  47)					this60->image = undoImage4;
HXDLIN(  47)					this60->width = width2;
HXDLIN(  47)					this60->height = height2;
HXDLIN(  47)					this60->imageType = ( (int)(imageType3) );
HXDLIN(  47)					undoImage3 = this60;
HXDLIN(  47)					{
HXLINE(  47)						int rectLeft1 = xIter31->start;
HXDLIN(  47)						int rectTop1 = yIter31->start;
HXDLIN(  47)						int rectRight1 = xIter31->max;
HXDLIN(  47)						bool forceClear1 = false;
HXDLIN(  47)						{
HXLINE(  47)							int _g72 = rectTop1;
HXDLIN(  47)							int _g73 = yIter31->max;
HXDLIN(  47)							while((_g72 < _g73)){
HXLINE(  47)								_g72 = (_g72 + 1);
HXDLIN(  47)								int dy1 = (_g72 - 1);
HXDLIN(  47)								{
HXLINE(  47)									int _g74 = rectLeft1;
HXDLIN(  47)									int _g75 = rectRight1;
HXDLIN(  47)									while((_g74 < _g75)){
HXLINE(  47)										_g74 = (_g74 + 1);
HXDLIN(  47)										int dx1 = (_g74 - 1);
HXDLIN(  47)										::Dynamic this62 = this59->image;
HXDLIN(  47)										int index6;
HXDLIN(  47)										if (this59->useVirtualPos) {
HXLINE(  47)											index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this59->virtualY) * ( (Float)(this59->width) )) + dx1) - this59->virtualX));
            										}
            										else {
HXLINE(  47)											index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this59->width) + dx1)) ));
            										}
HXDLIN(  47)										int c5 = ::iterMagic::Iimg_obj::get(this62,index6);
HXDLIN(  47)										int col1;
HXDLIN(  47)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)											col1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            										}
            										else {
HXLINE(  47)											col1 = c5;
            										}
HXDLIN(  47)										bool _hx_tmp18;
HXDLIN(  47)										if (this59->useMask) {
HXLINE(  47)											_hx_tmp18 = ::hx::IsNotNull( this59->mask );
            										}
            										else {
HXLINE(  47)											_hx_tmp18 = false;
            										}
HXDLIN(  47)										if (_hx_tmp18) {
HXLINE(  47)											 ::pi_xy::ImageStruct this63 = this59->mask;
HXDLIN(  47)											::Dynamic this64 = this63->image;
HXDLIN(  47)											int index7;
HXDLIN(  47)											if (this63->useVirtualPos) {
HXLINE(  47)												index7 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this63->virtualY) * ( (Float)(this63->width) )) + dx1) - this63->virtualX));
            											}
            											else {
HXLINE(  47)												index7 = ::Std_obj::_hx_int(( (Float)(((dy1 * this63->width) + dx1)) ));
            											}
HXDLIN(  47)											int c6 = ::iterMagic::Iimg_obj::get(this64,index7);
HXDLIN(  47)											int v6;
HXDLIN(  47)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)												v6 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            											}
            											else {
HXLINE(  47)												v6 = c6;
            											}
HXDLIN(  47)											int maskPixel1 = v6;
HXDLIN(  47)											int this65 = col1;
HXDLIN(  47)											if ((maskPixel1 == 0)) {
HXLINE(  47)												col1 = this65;
            											}
            											else {
HXLINE(  47)												Float m01;
HXDLIN(  47)												int this66 = ((maskPixel1 >> 24) & 255);
HXDLIN(  47)												if ((this66 == 0)) {
HXLINE(  47)													m01 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													m01 = (( (Float)(this66) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float m11;
HXDLIN(  47)												int this67 = ((maskPixel1 >> 16) & 255);
HXDLIN(  47)												if ((this67 == 0)) {
HXLINE(  47)													m11 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													m11 = (( (Float)(this67) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float m21;
HXDLIN(  47)												int this68 = ((maskPixel1 >> 8) & 255);
HXDLIN(  47)												if ((this68 == 0)) {
HXLINE(  47)													m21 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													m21 = (( (Float)(this68) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float m31;
HXDLIN(  47)												int this69 = (maskPixel1 & 255);
HXDLIN(  47)												if ((this69 == 0)) {
HXLINE(  47)													m31 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													m31 = (( (Float)(this69) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this65 >> 24) & 255)) )));
HXDLIN(  47)												int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this65 >> 16) & 255)) )));
HXDLIN(  47)												int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this65 >> 8) & 255)) )));
HXDLIN(  47)												int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this65 & 255)) )));
HXDLIN(  47)												col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN(  47)										if ((col1 != 0)) {
HXLINE(  47)											int x8 = (dx1 - rectLeft1);
HXDLIN(  47)											int y8 = (dy1 - rectTop1);
HXDLIN(  47)											int c7 = col1;
HXDLIN(  47)											bool _hx_tmp19;
HXDLIN(  47)											if ((((c7 >> 24) & 255) < 254)) {
HXLINE(  47)												_hx_tmp19 = undoImage3->transparent;
            											}
            											else {
HXLINE(  47)												_hx_tmp19 = false;
            											}
HXDLIN(  47)											if (_hx_tmp19) {
HXLINE(  47)												int location4;
HXDLIN(  47)												if (undoImage3->useVirtualPos) {
HXLINE(  47)													location4 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x8) - undoImage3->virtualX));
            												}
            												else {
HXLINE(  47)													location4 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage3->width) + x8)) ));
            												}
HXDLIN(  47)												int this70 = ::iterMagic::Iimg_obj::get(undoImage3->image,location4);
HXDLIN(  47)												int this71;
HXDLIN(  47)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)													this71 = ((((((this70 >> 24) & 255) << 24) | ((this70 & 255) << 16)) | (((this70 >> 8) & 255) << 8)) | ((this70 >> 16) & 255));
            												}
            												else {
HXLINE(  47)													this71 = this70;
            												}
HXDLIN(  47)												Float a15;
HXDLIN(  47)												int this72 = ((this71 >> 24) & 255);
HXDLIN(  47)												if ((this72 == 0)) {
HXLINE(  47)													a15 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													a15 = (( (Float)(this72) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float r14;
HXDLIN(  47)												int this73 = ((this71 >> 16) & 255);
HXDLIN(  47)												if ((this73 == 0)) {
HXLINE(  47)													r14 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													r14 = (( (Float)(this73) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float g14;
HXDLIN(  47)												int this74 = ((this71 >> 8) & 255);
HXDLIN(  47)												if ((this74 == 0)) {
HXLINE(  47)													g14 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													g14 = (( (Float)(this74) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float b110;
HXDLIN(  47)												int this75 = (this71 & 255);
HXDLIN(  47)												if ((this75 == 0)) {
HXLINE(  47)													b110 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													b110 = (( (Float)(this75) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float a24;
HXDLIN(  47)												int this76 = ((col1 >> 24) & 255);
HXDLIN(  47)												if ((this76 == 0)) {
HXLINE(  47)													a24 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													a24 = (( (Float)(this76) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float r24;
HXDLIN(  47)												int this77 = ((col1 >> 16) & 255);
HXDLIN(  47)												if ((this77 == 0)) {
HXLINE(  47)													r24 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													r24 = (( (Float)(this77) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float g24;
HXDLIN(  47)												int this78 = ((col1 >> 8) & 255);
HXDLIN(  47)												if ((this78 == 0)) {
HXLINE(  47)													g24 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													g24 = (( (Float)(this78) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float b25;
HXDLIN(  47)												int this79 = (col1 & 255);
HXDLIN(  47)												if ((this79 == 0)) {
HXLINE(  47)													b25 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													b25 = (( (Float)(this79) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float a34 = (a15 * (( (Float)(1) ) - a24));
HXDLIN(  47)												int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN(  47)												int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN(  47)												int b26 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a34) + (b25 * a24))));
HXDLIN(  47)												int a16 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN(  47)												int blended4 = ((((a16 << 24) | (r7 << 16)) | (g8 << 8)) | b26);
HXDLIN(  47)												{
HXLINE(  47)													int _hx_tmp20;
HXDLIN(  47)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)														_hx_tmp20 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            													}
            													else {
HXLINE(  47)														_hx_tmp20 = blended4;
            													}
HXDLIN(  47)													::iterMagic::Iimg_obj::set(undoImage3->image,location4,_hx_tmp20);
            												}
            											}
            											else {
HXLINE(  47)												::Dynamic this80 = undoImage3->image;
HXDLIN(  47)												int index8;
HXDLIN(  47)												if (undoImage3->useVirtualPos) {
HXLINE(  47)													index8 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x8) - undoImage3->virtualX));
            												}
            												else {
HXLINE(  47)													index8 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage3->width) + x8)) ));
            												}
HXDLIN(  47)												int _hx_tmp21;
HXDLIN(  47)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)													_hx_tmp21 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            												}
            												else {
HXLINE(  47)													_hx_tmp21 = c7;
            												}
HXDLIN(  47)												::iterMagic::Iimg_obj::set(this80,index8,_hx_tmp21);
            											}
            										}
            										else {
HXLINE(  47)											if (forceClear1) {
HXLINE(  47)												::Dynamic this81 = undoImage3->image;
HXDLIN(  47)												int x9 = (dx1 - rectLeft1);
HXDLIN(  47)												int y9 = (dy1 - rectTop1);
HXDLIN(  47)												int index9;
HXDLIN(  47)												if (undoImage3->useVirtualPos) {
HXLINE(  47)													index9 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x9) - undoImage3->virtualX));
            												}
            												else {
HXLINE(  47)													index9 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage3->width) + x9)) ));
            												}
HXDLIN(  47)												::iterMagic::Iimg_obj::set(this81,index9,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  47)				{
HXLINE(  47)					int _g_min2 = xIter31->start;
HXDLIN(  47)					int _g_max2 = xIter31->max;
HXDLIN(  47)					while((_g_min2 < _g_max2)){
HXLINE(  47)						_g_min2 = (_g_min2 + 1);
HXDLIN(  47)						int px1 = (_g_min2 - 1);
HXDLIN(  47)						Float pcx1 = (( (Float)(px1) ) - ( (Float)(240) ));
HXDLIN(  47)						{
HXLINE(  47)							int _g_min3 = yIter31->start;
HXDLIN(  47)							int _g_max3 = yIter31->max;
HXDLIN(  47)							while((_g_min3 < _g_max3)){
HXLINE(  47)								_g_min3 = (_g_min3 + 1);
HXDLIN(  47)								int py1 = (_g_min3 - 1);
HXDLIN(  47)								Float pcy1 = (( (Float)(py1) ) - ( (Float)(320) ));
HXDLIN(  47)								Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN(  47)								Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN(  47)								Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN(  47)								Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN(  47)								Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN(  47)								bool _hx_tmp22;
HXDLIN(  47)								bool _hx_tmp23;
HXDLIN(  47)								if ((ratioA1 >= 0)) {
HXLINE(  47)									_hx_tmp23 = (ratioB1 >= 0);
            								}
            								else {
HXLINE(  47)									_hx_tmp23 = false;
            								}
HXDLIN(  47)								if (_hx_tmp23) {
HXLINE(  47)									_hx_tmp22 = (ratioC1 >= 0);
            								}
            								else {
HXLINE(  47)									_hx_tmp22 = false;
            								}
HXDLIN(  47)								if (_hx_tmp22) {
HXLINE(  47)									int i30 = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA1) + (( (Float)(aB1) ) * ratioB1)) + (( (Float)(aC1) ) * ratioC1)));
HXDLIN(  47)									if ((i30 > 255)) {
HXLINE(  24)										i30 = 255;
            									}
HXLINE(  47)									if ((i30 < 0)) {
HXLINE(  25)										i30 = 0;
            									}
HXLINE(  47)									int a17 = i30;
HXDLIN(  47)									int i31 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA1) + (( (Float)(rB1) ) * ratioB1)) + (( (Float)(rC1) ) * ratioC1)));
HXDLIN(  47)									if ((i31 > 255)) {
HXLINE(  24)										i31 = 255;
            									}
HXLINE(  47)									if ((i31 < 0)) {
HXLINE(  25)										i31 = 0;
            									}
HXLINE(  47)									int r8 = i31;
HXDLIN(  47)									int i32 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA1) + (( (Float)(gB1) ) * ratioB1)) + (( (Float)(gC1) ) * ratioC1)));
HXDLIN(  47)									if ((i32 > 255)) {
HXLINE(  24)										i32 = 255;
            									}
HXLINE(  47)									if ((i32 < 0)) {
HXLINE(  25)										i32 = 0;
            									}
HXLINE(  47)									int g9 = i32;
HXDLIN(  47)									int i33 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA1) + (( (Float)(bB1) ) * ratioB1)) + (( (Float)(bC1) ) * ratioC1)));
HXDLIN(  47)									if ((i33 > 255)) {
HXLINE(  24)										i33 = 255;
            									}
HXLINE(  47)									if ((i33 < 0)) {
HXLINE(  25)										i33 = 0;
            									}
HXLINE(  47)									int b27 = i33;
HXDLIN(  47)									{
HXLINE(  47)										int location5;
HXDLIN(  47)										if (this59->useVirtualPos) {
HXLINE(  47)											location5 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this59->virtualY) * ( (Float)(this59->width) )) + px1) - this59->virtualX));
            										}
            										else {
HXLINE(  47)											location5 = ::Std_obj::_hx_int(( (Float)(((py1 * this59->width) + px1)) ));
            										}
HXDLIN(  47)										bool _hx_tmp24;
HXDLIN(  47)										if (this59->transparent) {
HXLINE(  47)											_hx_tmp24 = (a17 < 254);
            										}
            										else {
HXLINE(  47)											_hx_tmp24 = false;
            										}
HXDLIN(  47)										if (_hx_tmp24) {
HXLINE(  47)											int this82 = ::iterMagic::Iimg_obj::get(this59->image,location5);
HXDLIN(  47)											int old1;
HXDLIN(  47)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)												old1 = ((((((this82 >> 24) & 255) << 24) | ((this82 & 255) << 16)) | (((this82 >> 8) & 255) << 8)) | ((this82 >> 16) & 255));
            											}
            											else {
HXLINE(  47)												old1 = this82;
            											}
HXDLIN(  47)											int rhs1 = ((((a17 << 24) | (r8 << 16)) | (g9 << 8)) | b27);
HXDLIN(  47)											Float a18;
HXDLIN(  47)											int this83 = ((old1 >> 24) & 255);
HXDLIN(  47)											if ((this83 == 0)) {
HXLINE(  47)												a18 = ((Float)0.);
            											}
            											else {
HXLINE(  47)												a18 = (( (Float)(this83) ) / ( (Float)(255) ));
            											}
HXDLIN(  47)											Float r15;
HXDLIN(  47)											int this84 = ((old1 >> 16) & 255);
HXDLIN(  47)											if ((this84 == 0)) {
HXLINE(  47)												r15 = ((Float)0.);
            											}
            											else {
HXLINE(  47)												r15 = (( (Float)(this84) ) / ( (Float)(255) ));
            											}
HXDLIN(  47)											Float g15;
HXDLIN(  47)											int this85 = ((old1 >> 8) & 255);
HXDLIN(  47)											if ((this85 == 0)) {
HXLINE(  47)												g15 = ((Float)0.);
            											}
            											else {
HXLINE(  47)												g15 = (( (Float)(this85) ) / ( (Float)(255) ));
            											}
HXDLIN(  47)											Float b111;
HXDLIN(  47)											int this86 = (old1 & 255);
HXDLIN(  47)											if ((this86 == 0)) {
HXLINE(  47)												b111 = ((Float)0.);
            											}
            											else {
HXLINE(  47)												b111 = (( (Float)(this86) ) / ( (Float)(255) ));
            											}
HXDLIN(  47)											Float a25;
HXDLIN(  47)											int this87 = ((rhs1 >> 24) & 255);
HXDLIN(  47)											if ((this87 == 0)) {
HXLINE(  47)												a25 = ((Float)0.);
            											}
            											else {
HXLINE(  47)												a25 = (( (Float)(this87) ) / ( (Float)(255) ));
            											}
HXDLIN(  47)											Float r25;
HXDLIN(  47)											int this88 = ((rhs1 >> 16) & 255);
HXDLIN(  47)											if ((this88 == 0)) {
HXLINE(  47)												r25 = ((Float)0.);
            											}
            											else {
HXLINE(  47)												r25 = (( (Float)(this88) ) / ( (Float)(255) ));
            											}
HXDLIN(  47)											Float g25;
HXDLIN(  47)											int this89 = ((rhs1 >> 8) & 255);
HXDLIN(  47)											if ((this89 == 0)) {
HXLINE(  47)												g25 = ((Float)0.);
            											}
            											else {
HXLINE(  47)												g25 = (( (Float)(this89) ) / ( (Float)(255) ));
            											}
HXDLIN(  47)											Float b28;
HXDLIN(  47)											int this90 = (rhs1 & 255);
HXDLIN(  47)											if ((this90 == 0)) {
HXLINE(  47)												b28 = ((Float)0.);
            											}
            											else {
HXLINE(  47)												b28 = (( (Float)(this90) ) / ( (Float)(255) ));
            											}
HXDLIN(  47)											Float a35 = (a18 * (( (Float)(1) ) - a25));
HXDLIN(  47)											int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN(  47)											int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN(  47)											int b29 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a35) + (b28 * a25))));
HXDLIN(  47)											int a19 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN(  47)											int blended5 = ((((a19 << 24) | (r9 << 16)) | (g10 << 8)) | b29);
HXDLIN(  47)											{
HXLINE(  47)												int _hx_tmp25;
HXDLIN(  47)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)													_hx_tmp25 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            												}
            												else {
HXLINE(  47)													_hx_tmp25 = blended5;
            												}
HXDLIN(  47)												::iterMagic::Iimg_obj::set(this59->image,location5,_hx_tmp25);
            											}
            										}
            										else {
HXLINE(  47)											int value1;
HXDLIN(  47)											if (this59->isLittle) {
HXLINE(  47)												value1 = ((((a17 << 24) | (b27 << 16)) | (g9 << 8)) | r8);
            											}
            											else {
HXLINE(  47)												value1 = ((((a17 << 24) | (r8 << 16)) | (g9 << 8)) | b27);
            											}
HXDLIN(  47)											::iterMagic::Iimg_obj::set(this59->image,location5,value1);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  47)				if ((hasHit1 == false)) {
HXLINE(  47)					 ::pi_xy::algo::HitTri v7 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,( (Float)(220) ),( (Float)(120) ),( (Float)(420) ),( (Float)(240) ),( (Float)(240) ),( (Float)(320) ),true);
HXDLIN(  47)					if (hasUndo1) {
HXLINE(  47)						v7->undoImage = undoImage3;
HXDLIN(  47)						v7->undoX = xIter31->start;
HXDLIN(  47)						v7->undoY = yIter31->start;
            					}
            				}
            			}
            		}
HXLINE(  49)		{
HXLINE(  49)			bool forceClear2 = false;
HXDLIN(  49)			{
HXLINE(  49)				int _g76 = 0;
HXDLIN(  49)				int _g77 = pixelTest->height;
HXDLIN(  49)				while((_g76 < _g77)){
HXLINE(  49)					_g76 = (_g76 + 1);
HXDLIN(  49)					int dy2 = (_g76 - 1);
HXDLIN(  49)					{
HXLINE(  49)						int _g78 = 0;
HXDLIN(  49)						int _g79 = pixelTest->width;
HXDLIN(  49)						while((_g78 < _g79)){
HXLINE(  49)							_g78 = (_g78 + 1);
HXDLIN(  49)							int dx2 = (_g78 - 1);
HXDLIN(  49)							::Dynamic this91 = pixelTest->image;
HXDLIN(  49)							int index10;
HXDLIN(  49)							if (pixelTest->useVirtualPos) {
HXLINE(  49)								index10 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - pixelTest->virtualY) * ( (Float)(pixelTest->width) )) + dx2) - pixelTest->virtualX));
            							}
            							else {
HXLINE(  49)								index10 = ::Std_obj::_hx_int(( (Float)(((dy2 * pixelTest->width) + dx2)) ));
            							}
HXDLIN(  49)							int c8 = ::iterMagic::Iimg_obj::get(this91,index10);
HXDLIN(  49)							int col2;
HXDLIN(  49)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  49)								col2 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            							}
            							else {
HXLINE(  49)								col2 = c8;
            							}
HXDLIN(  49)							bool _hx_tmp26;
HXDLIN(  49)							if (pixelTest->useMask) {
HXLINE(  49)								_hx_tmp26 = ::hx::IsNotNull( pixelTest->mask );
            							}
            							else {
HXLINE(  49)								_hx_tmp26 = false;
            							}
HXDLIN(  49)							if (_hx_tmp26) {
HXLINE(  49)								 ::pi_xy::ImageStruct this92 = pixelTest->mask;
HXDLIN(  49)								::Dynamic this93 = this92->image;
HXDLIN(  49)								int index11;
HXDLIN(  49)								if (this92->useVirtualPos) {
HXLINE(  49)									index11 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this92->virtualY) * ( (Float)(this92->width) )) + dx2) - this92->virtualX));
            								}
            								else {
HXLINE(  49)									index11 = ::Std_obj::_hx_int(( (Float)(((dy2 * this92->width) + dx2)) ));
            								}
HXDLIN(  49)								int c9 = ::iterMagic::Iimg_obj::get(this93,index11);
HXDLIN(  49)								int v8;
HXDLIN(  49)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  49)									v8 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            								}
            								else {
HXLINE(  49)									v8 = c9;
            								}
HXDLIN(  49)								int maskPixel2 = v8;
HXDLIN(  49)								int this94 = col2;
HXDLIN(  49)								if ((maskPixel2 == 0)) {
HXLINE(  49)									col2 = this94;
            								}
            								else {
HXLINE(  49)									Float m02;
HXDLIN(  49)									int this95 = ((maskPixel2 >> 24) & 255);
HXDLIN(  49)									if ((this95 == 0)) {
HXLINE(  49)										m02 = ((Float)0.);
            									}
            									else {
HXLINE(  49)										m02 = (( (Float)(this95) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float m12;
HXDLIN(  49)									int this96 = ((maskPixel2 >> 16) & 255);
HXDLIN(  49)									if ((this96 == 0)) {
HXLINE(  49)										m12 = ((Float)0.);
            									}
            									else {
HXLINE(  49)										m12 = (( (Float)(this96) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float m22;
HXDLIN(  49)									int this97 = ((maskPixel2 >> 8) & 255);
HXDLIN(  49)									if ((this97 == 0)) {
HXLINE(  49)										m22 = ((Float)0.);
            									}
            									else {
HXLINE(  49)										m22 = (( (Float)(this97) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float m32;
HXDLIN(  49)									int this98 = (maskPixel2 & 255);
HXDLIN(  49)									if ((this98 == 0)) {
HXLINE(  49)										m32 = ((Float)0.);
            									}
            									else {
HXLINE(  49)										m32 = (( (Float)(this98) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this94 >> 24) & 255)) )));
HXDLIN(  49)									int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this94 >> 16) & 255)) )));
HXDLIN(  49)									int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this94 >> 8) & 255)) )));
HXDLIN(  49)									int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this94 & 255)) )));
HXDLIN(  49)									col2 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN(  49)							if ((col2 != 0)) {
HXLINE(  49)								int x10 = (45 + dx2);
HXDLIN(  49)								int y10 = (45 + dy2);
HXDLIN(  49)								int c10 = col2;
HXDLIN(  49)								bool _hx_tmp27;
HXDLIN(  49)								if ((((c10 >> 24) & 255) < 254)) {
HXLINE(  49)									_hx_tmp27 = pixelImage->transparent;
            								}
            								else {
HXLINE(  49)									_hx_tmp27 = false;
            								}
HXDLIN(  49)								if (_hx_tmp27) {
HXLINE(  49)									int location6;
HXDLIN(  49)									if (pixelImage->useVirtualPos) {
HXLINE(  49)										location6 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x10) - pixelImage->virtualX));
            									}
            									else {
HXLINE(  49)										location6 = ::Std_obj::_hx_int(( (Float)(((y10 * pixelImage->width) + x10)) ));
            									}
HXDLIN(  49)									int this99 = ::iterMagic::Iimg_obj::get(pixelImage->image,location6);
HXDLIN(  49)									int this100;
HXDLIN(  49)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  49)										this100 = ((((((this99 >> 24) & 255) << 24) | ((this99 & 255) << 16)) | (((this99 >> 8) & 255) << 8)) | ((this99 >> 16) & 255));
            									}
            									else {
HXLINE(  49)										this100 = this99;
            									}
HXDLIN(  49)									Float a110;
HXDLIN(  49)									int this101 = ((this100 >> 24) & 255);
HXDLIN(  49)									if ((this101 == 0)) {
HXLINE(  49)										a110 = ((Float)0.);
            									}
            									else {
HXLINE(  49)										a110 = (( (Float)(this101) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float r16;
HXDLIN(  49)									int this102 = ((this100 >> 16) & 255);
HXDLIN(  49)									if ((this102 == 0)) {
HXLINE(  49)										r16 = ((Float)0.);
            									}
            									else {
HXLINE(  49)										r16 = (( (Float)(this102) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float g16;
HXDLIN(  49)									int this103 = ((this100 >> 8) & 255);
HXDLIN(  49)									if ((this103 == 0)) {
HXLINE(  49)										g16 = ((Float)0.);
            									}
            									else {
HXLINE(  49)										g16 = (( (Float)(this103) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float b112;
HXDLIN(  49)									int this104 = (this100 & 255);
HXDLIN(  49)									if ((this104 == 0)) {
HXLINE(  49)										b112 = ((Float)0.);
            									}
            									else {
HXLINE(  49)										b112 = (( (Float)(this104) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float a26;
HXDLIN(  49)									int this105 = ((col2 >> 24) & 255);
HXDLIN(  49)									if ((this105 == 0)) {
HXLINE(  49)										a26 = ((Float)0.);
            									}
            									else {
HXLINE(  49)										a26 = (( (Float)(this105) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float r26;
HXDLIN(  49)									int this106 = ((col2 >> 16) & 255);
HXDLIN(  49)									if ((this106 == 0)) {
HXLINE(  49)										r26 = ((Float)0.);
            									}
            									else {
HXLINE(  49)										r26 = (( (Float)(this106) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float g26;
HXDLIN(  49)									int this107 = ((col2 >> 8) & 255);
HXDLIN(  49)									if ((this107 == 0)) {
HXLINE(  49)										g26 = ((Float)0.);
            									}
            									else {
HXLINE(  49)										g26 = (( (Float)(this107) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float b210;
HXDLIN(  49)									int this108 = (col2 & 255);
HXDLIN(  49)									if ((this108 == 0)) {
HXLINE(  49)										b210 = ((Float)0.);
            									}
            									else {
HXLINE(  49)										b210 = (( (Float)(this108) ) / ( (Float)(255) ));
            									}
HXDLIN(  49)									Float a36 = (a110 * (( (Float)(1) ) - a26));
HXDLIN(  49)									int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN(  49)									int g17 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN(  49)									int b30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a36) + (b210 * a26))));
HXDLIN(  49)									int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN(  49)									int blended6 = ((((a20 << 24) | (r10 << 16)) | (g17 << 8)) | b30);
HXDLIN(  49)									{
HXLINE(  49)										int _hx_tmp28;
HXDLIN(  49)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  49)											_hx_tmp28 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            										}
            										else {
HXLINE(  49)											_hx_tmp28 = blended6;
            										}
HXDLIN(  49)										::iterMagic::Iimg_obj::set(pixelImage->image,location6,_hx_tmp28);
            									}
            								}
            								else {
HXLINE(  49)									::Dynamic this109 = pixelImage->image;
HXDLIN(  49)									int index12;
HXDLIN(  49)									if (pixelImage->useVirtualPos) {
HXLINE(  49)										index12 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x10) - pixelImage->virtualX));
            									}
            									else {
HXLINE(  49)										index12 = ::Std_obj::_hx_int(( (Float)(((y10 * pixelImage->width) + x10)) ));
            									}
HXDLIN(  49)									int _hx_tmp29;
HXDLIN(  49)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  49)										_hx_tmp29 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            									}
            									else {
HXLINE(  49)										_hx_tmp29 = c10;
            									}
HXDLIN(  49)									::iterMagic::Iimg_obj::set(this109,index12,_hx_tmp29);
            								}
            							}
            							else {
HXLINE(  49)								if (forceClear2) {
HXLINE(  49)									::Dynamic this110 = pixelImage->image;
HXDLIN(  49)									int x11 = (45 + dx2);
HXDLIN(  49)									int y11 = (45 + dy2);
HXDLIN(  49)									int index13;
HXDLIN(  49)									if (pixelImage->useVirtualPos) {
HXLINE(  49)										index13 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x11) - pixelImage->virtualX));
            									}
            									else {
HXLINE(  49)										index13 = ::Std_obj::_hx_int(( (Float)(((y11 * pixelImage->width) + x11)) ));
            									}
HXDLIN(  49)									::iterMagic::Iimg_obj::set(this110,index13,0);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(  50)		 ::nme::display::BitmapData bitmapData = ( ( ::nme::display::BitmapData)(::pi_xy::formats::NMEbitmapData_obj::toNmeBitmapData_(pixelImage)) );
HXLINE(  51)		 ::nme::display::Bitmap bitmap =  ::nme::display::Bitmap_obj::__alloc( HX_CTX ,bitmapData,null(),null());
HXLINE(  52)		this->addChild(bitmap);
HXLINE(  54)		current->get_graphics()->beginFill(-1,((Float)1.));
HXLINE(  55)		current->get_graphics()->drawRect(((Float)0.),((Float)0.),((Float)70.),((Float)40.));
HXLINE(  56)		current->get_graphics()->endFill();
HXLINE(  57)		current->addChild( ::nme::display::FPS_obj::__alloc( HX_CTX ,null(),null(),null()));
            	}

Dynamic TestNME_obj::__CreateEmpty() { return new TestNME_obj; }

void *TestNME_obj::_hx_vtable = 0;

Dynamic TestNME_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< TestNME_obj > _hx_result = new TestNME_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool TestNME_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x169017a6) {
		if (inClassId<=(int)0x0ff07575) {
			if (inClassId<=(int)0x048b25c1) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x048b25c1;
			} else {
				return inClassId==(int)0x0ff07575;
			}
		} else {
			return inClassId==(int)0x169017a6;
		}
	} else {
		if (inClassId<=(int)0x5e732244) {
			return inClassId==(int)0x5a2ce121 || inClassId==(int)0x5e732244;
		} else {
			return inClassId==(int)0x66c9a5eb;
		}
	}
}


::hx::ObjectPtr< TestNME_obj > TestNME_obj::__new() {
	::hx::ObjectPtr< TestNME_obj > __this = new TestNME_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< TestNME_obj > TestNME_obj::__alloc(::hx::Ctx *_hx_ctx) {
	TestNME_obj *__this = (TestNME_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(TestNME_obj), true, "pi_xy.application.TestNME"));
	*(void **)__this = TestNME_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

TestNME_obj::TestNME_obj()
{
}

void TestNME_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(TestNME);
	HX_MARK_MEMBER_NAME(backGround,"backGround");
	HX_MARK_MEMBER_NAME(aGrid,"aGrid");
	 ::nme::display::DisplayObjectContainer_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void TestNME_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(backGround,"backGround");
	HX_VISIT_MEMBER_NAME(aGrid,"aGrid");
	 ::nme::display::DisplayObjectContainer_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val TestNME_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"aGrid") ) { return ::hx::Val( aGrid ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"backGround") ) { return ::hx::Val( backGround ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val TestNME_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"aGrid") ) { aGrid=inValue.Cast< ::String >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"backGround") ) { backGround=inValue.Cast< ::String >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void TestNME_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("backGround",0e,08,b2,5a));
	outFields->push(HX_("aGrid",c7,47,23,09));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo TestNME_obj_sMemberStorageInfo[] = {
	{::hx::fsString,(int)offsetof(TestNME_obj,backGround),HX_("backGround",0e,08,b2,5a)},
	{::hx::fsString,(int)offsetof(TestNME_obj,aGrid),HX_("aGrid",c7,47,23,09)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *TestNME_obj_sStaticStorageInfo = 0;
#endif

static ::String TestNME_obj_sMemberFields[] = {
	HX_("backGround",0e,08,b2,5a),
	HX_("aGrid",c7,47,23,09),
	::String(null()) };

::hx::Class TestNME_obj::__mClass;

void TestNME_obj::__register()
{
	TestNME_obj _hx_dummy;
	TestNME_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pi_xy.application.TestNME",af,6f,bc,a6);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(TestNME_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< TestNME_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = TestNME_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = TestNME_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pi_xy
} // end namespace application
