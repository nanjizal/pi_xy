// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericCell_Int
#include <haxe/ds/GenericCell_Int.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericStack_Int
#include <haxe/ds/GenericStack_Int.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_iterMagic_ArrIntImg
#include <iterMagic/ArrIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_BytesImg
#include <iterMagic/BytesImg.h>
#endif
#ifndef INCLUDED_iterMagic_Iimg
#include <iterMagic/Iimg.h>
#endif
#ifndef INCLUDED_iterMagic_StackIntImg
#include <iterMagic/StackIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_U32ArrImg
#include <iterMagic/U32ArrImg.h>
#endif
#ifndef INCLUDED_iterMagic_VecIntImg
#include <iterMagic/VecIntImg.h>
#endif
#ifndef INCLUDED_pi_xy_ImageStruct
#include <pi_xy/ImageStruct.h>
#endif
#ifndef INCLUDED_pi_xy__Endian_Endian_Fields_
#include <pi_xy/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitQuad
#include <pi_xy/algo/HitQuad.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitTri
#include <pi_xy/algo/HitTri.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitTriArray
#include <pi_xy/algo/HitTriArray.h>
#endif
#ifndef INCLUDED_pi_xy_algo_IhitObj
#include <pi_xy/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pi_xy_algo_QuadPoints_
#include <pi_xy/algo/QuadPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_TriPoints_
#include <pi_xy/algo/TriPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_iter_IntIterStart
#include <pi_xy/iter/IntIterStart.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_ArcForm
#include <pi_xy/triangleGML/ArcForm.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_triGML_BasicShape
#include <pi_xy/triangleGML/triGML/BasicShape.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_triGML_FillForm
#include <pi_xy/triangleGML/triGML/FillForm.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_triGML_GroupShape
#include <pi_xy/triangleGML/triGML/GroupShape.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_triGML_ShapeInterface
#include <pi_xy/triangleGML/triGML/ShapeInterface.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_triGML_shape_form_ArcForm_
#include <pi_xy/triangleGML/triGML/shape/form/ArcForm_.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_9a7b98cd588c0f27_7_new,"pi_xy.triangleGML.ArcForm","new",0xb7706311,"pi_xy.triangleGML.ArcForm.new","pi_xy/triangleGML/ArcForm.hx",7,0xdc019d81)
HX_LOCAL_STACK_FRAME(_hx_pos_9a7b98cd588c0f27_8_render,"pi_xy.triangleGML.ArcForm","render",0x9db2dd45,"pi_xy.triangleGML.ArcForm.render","pi_xy/triangleGML/ArcForm.hx",8,0xdc019d81)
HX_LOCAL_STACK_FRAME(_hx_pos_9a7b98cd588c0f27_23_chord,"pi_xy.triangleGML.ArcForm","chord",0x6b299d4d,"pi_xy.triangleGML.ArcForm.chord","pi_xy/triangleGML/ArcForm.hx",23,0xdc019d81)
HX_LOCAL_STACK_FRAME(_hx_pos_9a7b98cd588c0f27_45_ellipse,"pi_xy.triangleGML.ArcForm","ellipse",0xeb40800f,"pi_xy.triangleGML.ArcForm.ellipse","pi_xy/triangleGML/ArcForm.hx",45,0xdc019d81)
HX_LOCAL_STACK_FRAME(_hx_pos_9a7b98cd588c0f27_49_pie,"pi_xy.triangleGML.ArcForm","pie",0xb771eafd,"pi_xy.triangleGML.ArcForm.pie","pi_xy/triangleGML/ArcForm.hx",49,0xdc019d81)
namespace pi_xy{
namespace triangleGML{

void ArcForm_obj::__construct( ::Dynamic opacity, ::Dynamic visibility, ::Dynamic strokeColor, ::Dynamic strokeWidth,::Array< ::String > strokeDashGapArray, ::Dynamic fill, ::Dynamic left, ::Dynamic top, ::Dynamic width, ::Dynamic height, ::Dynamic startAngle, ::Dynamic sweepAngle,::String __o_arcType){
            		::String arcType = __o_arcType;
            		if (::hx::IsNull(__o_arcType)) arcType = HX_("pie",4c,58,55,00);
            	HX_STACKFRAME(&_hx_pos_9a7b98cd588c0f27_7_new)
HXDLIN(   7)		super::__construct(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,width,height,startAngle,sweepAngle,arcType);
            	}

Dynamic ArcForm_obj::__CreateEmpty() { return new ArcForm_obj; }

void *ArcForm_obj::_hx_vtable = 0;

Dynamic ArcForm_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< ArcForm_obj > _hx_result = new ArcForm_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7],inArgs[8],inArgs[9],inArgs[10],inArgs[11],inArgs[12]);
	return _hx_result;
}

bool ArcForm_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x46fd841c) {
		if (inClassId<=(int)0x1a0bd5c0) {
			if (inClassId<=(int)0x0dcd4ab7) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x0dcd4ab7;
			} else {
				return inClassId==(int)0x1a0bd5c0;
			}
		} else {
			return inClassId==(int)0x46fd841c;
		}
	} else {
		return inClassId==(int)0x4f186619 || inClassId==(int)0x7ff8cec5;
	}
}

 ::Dynamic ArcForm_obj::render( ::Dynamic _tmp_pixelImage){
            	HX_GC_STACKFRAME(&_hx_pos_9a7b98cd588c0f27_8_render)
HXLINE(   9)		 ::pi_xy::ImageStruct pixelImage = ( ( ::pi_xy::ImageStruct)(_tmp_pixelImage) );
HXDLIN(   9)		int width = ::Math_obj::ceil(this->width);
HXDLIN(   9)		int height = ::Math_obj::ceil(this->height);
HXDLIN(   9)		 ::Dynamic imageType = null();
HXDLIN(   9)		 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(   9)		if (::hx::IsNull( imageType )) {
HXLINE(   9)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXDLIN(   9)		::Dynamic _hx_tmp;
HXDLIN(   9)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE(   9)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(   9)				 ::iterMagic::BytesImg b = byt;
HXDLIN(   9)				{
HXLINE(   9)					b->width = width;
HXDLIN(   9)					b->height = height;
HXDLIN(   9)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(   9)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(   9)					{
HXLINE(   9)						int len = b->length;
HXDLIN(   9)						int w = 0;
HXDLIN(   9)						{
HXLINE(   9)							int _g = 0;
HXDLIN(   9)							int _g1 = b->height;
HXDLIN(   9)							while((_g < _g1)){
HXLINE(   9)								_g = (_g + 1);
HXDLIN(   9)								int y = (_g - 1);
HXDLIN(   9)								{
HXLINE(   9)									int _g2 = 0;
HXDLIN(   9)									int _g3 = b->width;
HXDLIN(   9)									while((_g2 < _g3)){
HXLINE(   9)										_g2 = (_g2 + 1);
HXDLIN(   9)										int x = (_g2 - 1);
HXDLIN(   9)										{
HXLINE(   9)											w = (w + 1);
HXDLIN(   9)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(   9)										{
HXLINE(   9)											w = (w + 1);
HXDLIN(   9)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(   9)										{
HXLINE(   9)											w = (w + 1);
HXDLIN(   9)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(   9)										{
HXLINE(   9)											w = (w + 1);
HXDLIN(   9)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(   9)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXLINE(   9)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(   9)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(   9)				{
HXLINE(   9)					a->width = width;
HXDLIN(   9)					a->height = height;
HXDLIN(   9)					a->data = ::Array_obj< int >::__new(0);
HXDLIN(   9)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(   9)					{
HXLINE(   9)						int _g4 = 0;
HXDLIN(   9)						int _g5 = a->length;
HXDLIN(   9)						while((_g4 < _g5)){
HXLINE(   9)							_g4 = (_g4 + 1);
HXDLIN(   9)							int i = (_g4 - 1);
HXDLIN(   9)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN(   9)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXLINE(   9)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(   9)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(   9)				{
HXLINE(   9)					b1->width = width;
HXDLIN(   9)					b1->height = height;
HXDLIN(   9)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(   9)					int size = (b1->length * 4);
HXDLIN(   9)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(   9)					{
HXLINE(   9)						int _g6 = 0;
HXDLIN(   9)						int _g7 = b1->length;
HXDLIN(   9)						while((_g6 < _g7)){
HXLINE(   9)							_g6 = (_g6 + 1);
HXDLIN(   9)							int i1 = (_g6 - 1);
HXDLIN(   9)							{
HXLINE(   9)								 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN(   9)								bool _hx_tmp1;
HXDLIN(   9)								if ((i1 >= 0)) {
HXLINE(   9)									_hx_tmp1 = (i1 < (this2->byteLength >> 2));
            								}
            								else {
HXLINE(   9)									_hx_tmp1 = false;
            								}
HXDLIN(   9)								if (_hx_tmp1) {
HXLINE(   9)									 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN(   9)									int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN(   9)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(   9)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(   9)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(   9)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(   9)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXLINE(   9)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(   9)				 ::iterMagic::VecIntImg v = vec;
HXDLIN(   9)				{
HXLINE(   9)					v->width = width;
HXDLIN(   9)					v->height = height;
HXDLIN(   9)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(   9)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(   9)					{
HXLINE(   9)						int _g8 = 0;
HXDLIN(   9)						int _g9 = v->length;
HXDLIN(   9)						while((_g8 < _g9)){
HXLINE(   9)							_g8 = (_g8 + 1);
HXDLIN(   9)							int i2 = (_g8 - 1);
HXDLIN(   9)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN(   9)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXLINE(   9)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(   9)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(   9)				{
HXLINE(   9)					b2->width = width;
HXDLIN(   9)					b2->height = height;
HXDLIN(   9)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(   9)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(   9)					{
HXLINE(   9)						int len1 = b2->length;
HXDLIN(   9)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(   9)						if (::hx::IsNull( d->head )) {
HXLINE(   9)							int _g10 = 0;
HXDLIN(   9)							int _g11 = len1;
HXDLIN(   9)							while((_g10 < _g11)){
HXLINE(   9)								_g10 = (_g10 + 1);
HXDLIN(   9)								int i3 = (_g10 - 1);
HXDLIN(   9)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE(   9)							int _g12 = 0;
HXDLIN(   9)							int _g13 = len1;
HXDLIN(   9)							while((_g12 < _g13)){
HXLINE(   9)								_g12 = (_g12 + 1);
HXDLIN(   9)								int i4 = (_g12 - 1);
HXDLIN(   9)								{
HXLINE(   9)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(   9)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(   9)									{
HXLINE(   9)										int _g14 = 0;
HXDLIN(   9)										int _g15 = i4;
HXDLIN(   9)										while((_g14 < _g15)){
HXLINE(   9)											_g14 = (_g14 + 1);
HXDLIN(   9)											int i5 = (_g14 - 1);
HXDLIN(   9)											prev = l;
HXDLIN(   9)											l = l->next;
            										}
            									}
HXDLIN(   9)									if (::hx::IsNull( prev )) {
HXLINE(   9)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(   9)										l = null();
            									}
            									else {
HXLINE(   9)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(   9)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(   9)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN(   9)		this1->image = _hx_tmp;
HXDLIN(   9)		this1->width = width;
HXDLIN(   9)		this1->height = height;
HXDLIN(   9)		this1->imageType = ( (int)(imageType) );
HXDLIN(   9)		 ::pi_xy::ImageStruct temp = this1;
HXLINE(  10)		temp->transparent = false;
HXLINE(  11)		::String _hx_switch_0 = this->arcType;
            		if (  (_hx_switch_0==HX_("chord",5c,3c,be,45)) ){
HXLINE(  13)			this->chord(temp);
HXDLIN(  13)			goto _hx_goto_9;
            		}
            		if (  (_hx_switch_0==HX_("ellipse",de,40,86,0b)) ){
HXLINE(  15)			this->ellipse(temp);
HXDLIN(  15)			goto _hx_goto_9;
            		}
            		if (  (_hx_switch_0==HX_("pie",4c,58,55,00)) ){
HXLINE(  17)			this->pie(temp);
HXDLIN(  17)			goto _hx_goto_9;
            		}
            		_hx_goto_9:;
HXLINE(  19)		{
HXLINE(  19)			int x1 = ::Std_obj::_hx_int((this->left + this->offX));
HXDLIN(  19)			int y1 = ::Std_obj::_hx_int((this->top + this->offY));
HXDLIN(  19)			bool forceClear = false;
HXDLIN(  19)			{
HXLINE(  19)				int _g16 = 0;
HXDLIN(  19)				int _g17 = temp->height;
HXDLIN(  19)				while((_g16 < _g17)){
HXLINE(  19)					_g16 = (_g16 + 1);
HXDLIN(  19)					int dy = (_g16 - 1);
HXDLIN(  19)					{
HXLINE(  19)						int _g18 = 0;
HXDLIN(  19)						int _g19 = temp->width;
HXDLIN(  19)						while((_g18 < _g19)){
HXLINE(  19)							_g18 = (_g18 + 1);
HXDLIN(  19)							int dx = (_g18 - 1);
HXDLIN(  19)							::Dynamic this3 = temp->image;
HXDLIN(  19)							int index;
HXDLIN(  19)							if (temp->useVirtualPos) {
HXLINE(  19)								index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            							}
            							else {
HXLINE(  19)								index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            							}
HXDLIN(  19)							int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN(  19)							int col;
HXDLIN(  19)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  19)								col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE(  19)								col = c;
            							}
HXDLIN(  19)							bool _hx_tmp2;
HXDLIN(  19)							if (temp->useMask) {
HXLINE(  19)								_hx_tmp2 = ::hx::IsNotNull( temp->mask );
            							}
            							else {
HXLINE(  19)								_hx_tmp2 = false;
            							}
HXDLIN(  19)							if (_hx_tmp2) {
HXLINE(  19)								 ::pi_xy::ImageStruct this4 = temp->mask;
HXDLIN(  19)								::Dynamic this5 = this4->image;
HXDLIN(  19)								int index1;
HXDLIN(  19)								if (this4->useVirtualPos) {
HXLINE(  19)									index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            								}
            								else {
HXLINE(  19)									index1 = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            								}
HXDLIN(  19)								int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN(  19)								int v1;
HXDLIN(  19)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  19)									v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            								}
            								else {
HXLINE(  19)									v1 = c1;
            								}
HXDLIN(  19)								int maskPixel = v1;
HXDLIN(  19)								int this6 = col;
HXDLIN(  19)								if ((maskPixel == 0)) {
HXLINE(  19)									col = this6;
            								}
            								else {
HXLINE(  19)									Float m0;
HXDLIN(  19)									int this7 = ((maskPixel >> 24) & 255);
HXDLIN(  19)									if ((this7 == 0)) {
HXLINE(  19)										m0 = ((Float)0.);
            									}
            									else {
HXLINE(  19)										m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  19)									Float m1;
HXDLIN(  19)									int this8 = ((maskPixel >> 16) & 255);
HXDLIN(  19)									if ((this8 == 0)) {
HXLINE(  19)										m1 = ((Float)0.);
            									}
            									else {
HXLINE(  19)										m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  19)									Float m2;
HXDLIN(  19)									int this9 = ((maskPixel >> 8) & 255);
HXDLIN(  19)									if ((this9 == 0)) {
HXLINE(  19)										m2 = ((Float)0.);
            									}
            									else {
HXLINE(  19)										m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  19)									Float m3;
HXDLIN(  19)									int this10 = (maskPixel & 255);
HXDLIN(  19)									if ((this10 == 0)) {
HXLINE(  19)										m3 = ((Float)0.);
            									}
            									else {
HXLINE(  19)										m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  19)									int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN(  19)									int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN(  19)									int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN(  19)									int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN(  19)									col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN(  19)							if ((col != 0)) {
HXLINE(  19)								int x2 = (x1 + dx);
HXDLIN(  19)								int y2 = (y1 + dy);
HXDLIN(  19)								int c2 = col;
HXDLIN(  19)								bool _hx_tmp3;
HXDLIN(  19)								if ((((c2 >> 24) & 255) < 254)) {
HXLINE(  19)									_hx_tmp3 = pixelImage->transparent;
            								}
            								else {
HXLINE(  19)									_hx_tmp3 = false;
            								}
HXDLIN(  19)								if (_hx_tmp3) {
HXLINE(  19)									int location;
HXDLIN(  19)									if (pixelImage->useVirtualPos) {
HXLINE(  19)										location = ::Std_obj::_hx_int(((((( (Float)(y2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x2) - pixelImage->virtualX));
            									}
            									else {
HXLINE(  19)										location = ::Std_obj::_hx_int(( (Float)(((y2 * pixelImage->width) + x2)) ));
            									}
HXDLIN(  19)									int this11 = ::iterMagic::Iimg_obj::get(pixelImage->image,location);
HXDLIN(  19)									int this12;
HXDLIN(  19)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  19)										this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            									}
            									else {
HXLINE(  19)										this12 = this11;
            									}
HXDLIN(  19)									Float a1;
HXDLIN(  19)									int this13 = ((this12 >> 24) & 255);
HXDLIN(  19)									if ((this13 == 0)) {
HXLINE(  19)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  19)										a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            									}
HXDLIN(  19)									Float r1;
HXDLIN(  19)									int this14 = ((this12 >> 16) & 255);
HXDLIN(  19)									if ((this14 == 0)) {
HXLINE(  19)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  19)										r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            									}
HXDLIN(  19)									Float g1;
HXDLIN(  19)									int this15 = ((this12 >> 8) & 255);
HXDLIN(  19)									if ((this15 == 0)) {
HXLINE(  19)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  19)										g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            									}
HXDLIN(  19)									Float b11;
HXDLIN(  19)									int this16 = (this12 & 255);
HXDLIN(  19)									if ((this16 == 0)) {
HXLINE(  19)										b11 = ((Float)0.);
            									}
            									else {
HXLINE(  19)										b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            									}
HXDLIN(  19)									Float a2;
HXDLIN(  19)									int this17 = ((col >> 24) & 255);
HXDLIN(  19)									if ((this17 == 0)) {
HXLINE(  19)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  19)										a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            									}
HXDLIN(  19)									Float r2;
HXDLIN(  19)									int this18 = ((col >> 16) & 255);
HXDLIN(  19)									if ((this18 == 0)) {
HXLINE(  19)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  19)										r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            									}
HXDLIN(  19)									Float g2;
HXDLIN(  19)									int this19 = ((col >> 8) & 255);
HXDLIN(  19)									if ((this19 == 0)) {
HXLINE(  19)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  19)										g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            									}
HXDLIN(  19)									Float b21;
HXDLIN(  19)									int this20 = (col & 255);
HXDLIN(  19)									if ((this20 == 0)) {
HXLINE(  19)										b21 = ((Float)0.);
            									}
            									else {
HXLINE(  19)										b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            									}
HXDLIN(  19)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  19)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  19)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  19)									int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  19)									int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  19)									int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  19)									{
HXLINE(  19)										int _hx_tmp4;
HXDLIN(  19)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  19)											_hx_tmp4 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  19)											_hx_tmp4 = blended;
            										}
HXDLIN(  19)										::iterMagic::Iimg_obj::set(pixelImage->image,location,_hx_tmp4);
            									}
            								}
            								else {
HXLINE(  19)									::Dynamic this21 = pixelImage->image;
HXDLIN(  19)									int index2;
HXDLIN(  19)									if (pixelImage->useVirtualPos) {
HXLINE(  19)										index2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x2) - pixelImage->virtualX));
            									}
            									else {
HXLINE(  19)										index2 = ::Std_obj::_hx_int(( (Float)(((y2 * pixelImage->width) + x2)) ));
            									}
HXDLIN(  19)									int _hx_tmp5;
HXDLIN(  19)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  19)										_hx_tmp5 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            									}
            									else {
HXLINE(  19)										_hx_tmp5 = c2;
            									}
HXDLIN(  19)									::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp5);
            								}
            							}
            							else {
HXLINE(  19)								if (forceClear) {
HXLINE(  19)									::Dynamic this22 = pixelImage->image;
HXDLIN(  19)									int x3 = (x1 + dx);
HXDLIN(  19)									int y3 = (y1 + dy);
HXDLIN(  19)									int index3;
HXDLIN(  19)									if (pixelImage->useVirtualPos) {
HXLINE(  19)										index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x3) - pixelImage->virtualX));
            									}
            									else {
HXLINE(  19)										index3 = ::Std_obj::_hx_int(( (Float)(((y3 * pixelImage->width) + x3)) ));
            									}
HXDLIN(  19)									::iterMagic::Iimg_obj::set(this22,index3,0);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(  20)		temp = null();
HXLINE(  21)		return pixelImage;
            	}


void ArcForm_obj::chord( ::pi_xy::ImageStruct temp){
            	HX_GC_STACKFRAME(&_hx_pos_9a7b98cd588c0f27_23_chord)
HXLINE(  24)		this->ellipse(temp);
HXLINE(  26)		Float endAngle = (this->startAngle + this->sweepAngle);
HXLINE(  27)		Float bx = ((this->rx * ::Math_obj::cos(this->startAngle)) + this->rx);
HXLINE(  28)		Float by = ((this->ry * ::Math_obj::sin(this->startAngle)) + this->ry);
HXLINE(  29)		Float cx = ((this->rx * ::Math_obj::cos(endAngle)) + this->rx);
HXLINE(  30)		Float cy = ((this->ry * ::Math_obj::sin(endAngle)) + this->ry);
HXLINE(  31)		if ((this->sweepAngle < ::Math_obj::PI)) {
HXLINE(  32)			Float bxS = (((this->rx - this->strokeWidth) * ::Math_obj::cos(this->startAngle)) + this->rx);
HXLINE(  33)			Float byS = (((this->ry - this->strokeWidth) * ::Math_obj::sin(this->startAngle)) + this->ry);
HXLINE(  34)			Float cxS = (((this->rx - this->strokeWidth) * ::Math_obj::cos((endAngle + ((Float)0.01)))) + this->rx);
HXLINE(  35)			Float cyS = (((this->ry - this->strokeWidth) * ::Math_obj::sin((endAngle + ((Float)0.01)))) + this->ry);
HXLINE(  36)			{
HXLINE(  36)				 ::pi_xy::ImageStruct this1 = temp;
HXDLIN(  36)				Float y = this->ry;
HXDLIN(  36)				Float d = this->strokeWidth;
HXDLIN(  36)				{
HXLINE(  36)					int r_x = ::Std_obj::_hx_int((this->rx - (d / ( (Float)(2) ))));
HXDLIN(  36)					int r_y = ::Std_obj::_hx_int((y - (d / ( (Float)(2) ))));
HXDLIN(  36)					int r_w = ::Std_obj::_hx_int(d);
HXDLIN(  36)					int r_h = ::Std_obj::_hx_int(d);
HXDLIN(  36)					int xmax = ((r_x + r_w) + 1);
HXDLIN(  36)					int ymax = ((r_y + r_h) + 1);
HXDLIN(  36)					int ii_min = r_x;
HXDLIN(  36)					int ii_max = xmax;
HXDLIN(  36)					int xRange__start = ii_min;
HXDLIN(  36)					int xRange__max = ii_max;
HXDLIN(  36)					int ii_min1 = r_y;
HXDLIN(  36)					int ii_max1 = ymax;
HXDLIN(  36)					int yRange__start = ii_min1;
HXDLIN(  36)					int yRange__max = ii_max1;
HXDLIN(  36)					int range_x = xRange__start;
HXDLIN(  36)					int range_y = (yRange__start - 1);
HXDLIN(  36)					int range_xReset = range_x;
HXDLIN(  36)					int range_yReset = range_y;
HXDLIN(  36)					int range_xMax = (xRange__max - 2);
HXDLIN(  36)					int range_yMax = (yRange__max - 2);
HXDLIN(  36)					int _this_min = 0;
HXDLIN(  36)					int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXDLIN(  36)					while((_this_min < _this_max)){
HXLINE(  36)						_this_min = (_this_min + 1);
HXDLIN(  36)						int i = (_this_min - 1);
HXDLIN(  36)						if ((range_y > range_yMax)) {
HXLINE(  36)							range_y = range_yReset;
HXDLIN(  36)							range_x = (range_x + 1);
            						}
HXDLIN(  36)						range_y = (range_y + 1);
HXDLIN(  36)						int i1 = i;
HXDLIN(  36)						{
HXLINE(  36)							int x = range_x;
HXDLIN(  36)							int y1 = range_y;
HXDLIN(  36)							int c = 0;
HXDLIN(  36)							bool _hx_tmp;
HXDLIN(  36)							if ((((c >> 24) & 255) < 254)) {
HXLINE(  36)								_hx_tmp = this1->transparent;
            							}
            							else {
HXLINE(  36)								_hx_tmp = false;
            							}
HXDLIN(  36)							if (_hx_tmp) {
HXLINE(  36)								int location;
HXDLIN(  36)								if (this1->useVirtualPos) {
HXLINE(  36)									location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            								}
            								else {
HXLINE(  36)									location = ::Std_obj::_hx_int(( (Float)(((y1 * this1->width) + x)) ));
            								}
HXDLIN(  36)								int this2 = ::iterMagic::Iimg_obj::get(this1->image,location);
HXDLIN(  36)								int this3;
HXDLIN(  36)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  36)									this3 = ((((((this2 >> 24) & 255) << 24) | ((this2 & 255) << 16)) | (((this2 >> 8) & 255) << 8)) | ((this2 >> 16) & 255));
            								}
            								else {
HXLINE(  36)									this3 = this2;
            								}
HXDLIN(  36)								Float a1;
HXDLIN(  36)								int this4 = ((this3 >> 24) & 255);
HXDLIN(  36)								if ((this4 == 0)) {
HXLINE(  36)									a1 = ((Float)0.);
            								}
            								else {
HXLINE(  36)									a1 = (( (Float)(this4) ) / ( (Float)(255) ));
            								}
HXDLIN(  36)								Float r1;
HXDLIN(  36)								int this5 = ((this3 >> 16) & 255);
HXDLIN(  36)								if ((this5 == 0)) {
HXLINE(  36)									r1 = ((Float)0.);
            								}
            								else {
HXLINE(  36)									r1 = (( (Float)(this5) ) / ( (Float)(255) ));
            								}
HXDLIN(  36)								Float g1;
HXDLIN(  36)								int this6 = ((this3 >> 8) & 255);
HXDLIN(  36)								if ((this6 == 0)) {
HXLINE(  36)									g1 = ((Float)0.);
            								}
            								else {
HXLINE(  36)									g1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN(  36)								Float b1;
HXDLIN(  36)								int this7 = (this3 & 255);
HXDLIN(  36)								if ((this7 == 0)) {
HXLINE(  36)									b1 = ((Float)0.);
            								}
            								else {
HXLINE(  36)									b1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN(  36)								Float a2;
HXDLIN(  36)								int this8 = ((0 >> 24) & 255);
HXDLIN(  36)								if ((this8 == 0)) {
HXLINE(  36)									a2 = ((Float)0.);
            								}
            								else {
HXLINE(  36)									a2 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN(  36)								Float r2;
HXDLIN(  36)								int this9 = ((0 >> 16) & 255);
HXDLIN(  36)								if ((this9 == 0)) {
HXLINE(  36)									r2 = ((Float)0.);
            								}
            								else {
HXLINE(  36)									r2 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN(  36)								Float g2;
HXDLIN(  36)								int this10 = ((0 >> 8) & 255);
HXDLIN(  36)								if ((this10 == 0)) {
HXLINE(  36)									g2 = ((Float)0.);
            								}
            								else {
HXLINE(  36)									g2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN(  36)								Float b2;
HXDLIN(  36)								int this11 = (0 & 255);
HXDLIN(  36)								if ((this11 == 0)) {
HXLINE(  36)									b2 = ((Float)0.);
            								}
            								else {
HXLINE(  36)									b2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN(  36)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  36)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  36)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  36)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  36)								int a = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  36)								int blended = ((((a << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  36)								{
HXLINE(  36)									int _hx_tmp1;
HXDLIN(  36)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  36)										_hx_tmp1 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE(  36)										_hx_tmp1 = blended;
            									}
HXDLIN(  36)									::iterMagic::Iimg_obj::set(this1->image,location,_hx_tmp1);
            								}
            							}
            							else {
HXLINE(  36)								::Dynamic this12 = this1->image;
HXDLIN(  36)								int index;
HXDLIN(  36)								if (this1->useVirtualPos) {
HXLINE(  36)									index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this1->virtualY) * ( (Float)(this1->width) )) + x) - this1->virtualX));
            								}
            								else {
HXLINE(  36)									index = ::Std_obj::_hx_int(( (Float)(((y1 * this1->width) + x)) ));
            								}
HXDLIN(  36)								int _hx_tmp2;
HXDLIN(  36)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  36)									_hx_tmp2 = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  36)									_hx_tmp2 = c;
            								}
HXDLIN(  36)								::iterMagic::Iimg_obj::set(this12,index,_hx_tmp2);
            							}
            						}
            					}
            				}
            			}
HXLINE(  37)			{
HXLINE(  37)				 ::pi_xy::ImageStruct this13 = temp;
HXDLIN(  37)				Float ax = this->rx;
HXDLIN(  37)				Float ay = this->ry;
HXDLIN(  37)				int color = this->strokeColor;
HXDLIN(  37)				bool hasHit = false;
HXDLIN(  37)				bool hasUndo = false;
HXDLIN(  37)				{
HXLINE(  37)					Float bx1 = bx;
HXDLIN(  37)					Float by1 = by;
HXDLIN(  37)					Float cx1 = cx;
HXDLIN(  37)					Float cy1 = cy;
HXDLIN(  37)					bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN(  37)					if (!(adjustWinding)) {
HXLINE(  37)						Float bx_ = bx1;
HXDLIN(  37)						Float by_ = by1;
HXLINE(  25)						bx1 = cx1;
HXLINE(  26)						by1 = cy1;
HXLINE(  27)						cx1 = bx_;
HXLINE(  28)						cy1 = by_;
            					}
HXLINE(  37)					{
HXLINE(  37)						Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN(  37)						Float sx = (cy1 - ay);
HXDLIN(  37)						Float sy = (ax - cx1);
HXDLIN(  37)						Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN(  37)						Float tx = (ay - by1);
HXDLIN(  37)						Float ty = (bx1 - ax);
HXDLIN(  37)						Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN(  37)						 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  37)						if ((ax > bx1)) {
HXLINE(  37)							if ((ax > cx1)) {
HXLINE(  37)								int min;
HXDLIN(  37)								if ((bx1 > cx1)) {
HXLINE(  37)									min = ::Math_obj::floor(cx1);
            								}
            								else {
HXLINE(  37)									min = ::Math_obj::floor(bx1);
            								}
HXDLIN(  37)								int ii_min2 = min;
HXDLIN(  37)								int ii_max2 = ::Math_obj::ceil(ax);
HXDLIN(  37)								xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            							}
            							else {
HXLINE(  37)								int ii_min3 = ::Math_obj::floor(bx1);
HXDLIN(  37)								int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN(  37)								xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            							}
            						}
            						else {
HXLINE(  37)							if ((bx1 > cx1)) {
HXLINE(  37)								int min1;
HXDLIN(  37)								if ((ax > cx1)) {
HXLINE(  37)									min1 = ::Math_obj::floor(cx1);
            								}
            								else {
HXLINE(  37)									min1 = ::Math_obj::ceil(ax);
            								}
HXDLIN(  37)								int ii_min4 = min1;
HXDLIN(  37)								int ii_max4 = ::Math_obj::ceil(bx1);
HXDLIN(  37)								xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            							}
            							else {
HXLINE(  37)								int ii_min5 = ::Math_obj::floor(ax);
HXDLIN(  37)								int ii_max5 = ::Math_obj::ceil(cx1);
HXDLIN(  37)								xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            							}
            						}
HXDLIN(  37)						 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  37)						if ((ay > by1)) {
HXLINE(  37)							if ((ay > cy1)) {
HXLINE(  37)								int min2;
HXDLIN(  37)								if ((by1 > cy1)) {
HXLINE(  37)									min2 = ::Math_obj::floor(cy1);
            								}
            								else {
HXLINE(  37)									min2 = ::Math_obj::floor(by1);
            								}
HXDLIN(  37)								int ii_min6 = min2;
HXDLIN(  37)								int ii_max6 = ::Math_obj::ceil(ay);
HXDLIN(  37)								yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            							}
            							else {
HXLINE(  37)								int ii_min7 = ::Math_obj::floor(by1);
HXDLIN(  37)								int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN(  37)								yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            							}
            						}
            						else {
HXLINE(  37)							if ((by1 > cy1)) {
HXLINE(  37)								int min3;
HXDLIN(  37)								if ((ay > cy1)) {
HXLINE(  37)									min3 = ::Math_obj::floor(cy1);
            								}
            								else {
HXLINE(  37)									min3 = ::Math_obj::ceil(ay);
            								}
HXDLIN(  37)								int ii_min8 = min3;
HXDLIN(  37)								int ii_max8 = ::Math_obj::ceil(by1);
HXDLIN(  37)								yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            							}
            							else {
HXLINE(  37)								int ii_min9 = ::Math_obj::floor(ay);
HXDLIN(  37)								int ii_max9 = ::Math_obj::ceil(cy1);
HXDLIN(  37)								yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            							}
            						}
HXDLIN(  37)						 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  37)						if (hasUndo) {
HXLINE(  37)							int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  37)							int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  37)							 ::Dynamic imageType = null();
HXDLIN(  37)							 ::pi_xy::ImageStruct this14 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  37)							if (::hx::IsNull( imageType )) {
HXLINE(  54)								imageType = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE(  37)							::Dynamic undoImage1;
HXDLIN(  37)							switch((int)(( (int)(imageType) ))){
            								case (int)0: {
HXLINE(  37)									 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  37)									 ::iterMagic::BytesImg b3 = byt;
HXDLIN(  37)									{
HXLINE(  37)										b3->width = width;
HXDLIN(  37)										b3->height = height;
HXDLIN(  37)										b3->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  37)										b3->data = ::haxe::io::Bytes_obj::alloc((b3->length * 4));
HXDLIN(  37)										{
HXLINE(  37)											int len = b3->length;
HXDLIN(  37)											int w = 0;
HXDLIN(  37)											{
HXLINE(  37)												int _g = 0;
HXDLIN(  37)												int _g1 = b3->height;
HXDLIN(  37)												while((_g < _g1)){
HXLINE(  37)													_g = (_g + 1);
HXDLIN(  37)													int y2 = (_g - 1);
HXDLIN(  37)													{
HXLINE(  37)														int _g2 = 0;
HXDLIN(  37)														int _g3 = b3->width;
HXDLIN(  37)														while((_g2 < _g3)){
HXLINE(  37)															_g2 = (_g2 + 1);
HXDLIN(  37)															int x1 = (_g2 - 1);
HXDLIN(  37)															{
HXLINE(  37)																w = (w + 1);
HXDLIN(  37)																b3->data->b[(w - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  37)															{
HXLINE(  37)																w = (w + 1);
HXDLIN(  37)																b3->data->b[(w - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  37)															{
HXLINE(  37)																w = (w + 1);
HXDLIN(  37)																b3->data->b[(w - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  37)															{
HXLINE(  37)																w = (w + 1);
HXDLIN(  37)																b3->data->b[(w - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  37)									undoImage1 = b3;
            								}
            								break;
            								case (int)1: {
HXLINE(  37)									 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  37)									 ::iterMagic::ArrIntImg a4 = arrI;
HXDLIN(  37)									{
HXLINE(  37)										a4->width = width;
HXDLIN(  37)										a4->height = height;
HXDLIN(  37)										a4->data = ::Array_obj< int >::__new(0);
HXDLIN(  37)										a4->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  37)										{
HXLINE(  37)											int _g4 = 0;
HXDLIN(  37)											int _g5 = a4->length;
HXDLIN(  37)											while((_g4 < _g5)){
HXLINE(  37)												_g4 = (_g4 + 1);
HXDLIN(  37)												int i2 = (_g4 - 1);
HXDLIN(  37)												a4->data[i2] = 0;
            											}
            										}
            									}
HXDLIN(  37)									undoImage1 = a4;
            								}
            								break;
            								case (int)2: {
HXLINE(  37)									 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  37)									 ::iterMagic::U32ArrImg b4 = u32a;
HXDLIN(  37)									{
HXLINE(  37)										b4->width = width;
HXDLIN(  37)										b4->height = height;
HXDLIN(  37)										b4->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  37)										int size = (b4->length * 4);
HXDLIN(  37)										b4->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  37)										{
HXLINE(  37)											int _g6 = 0;
HXDLIN(  37)											int _g7 = b4->length;
HXDLIN(  37)											while((_g6 < _g7)){
HXLINE(  37)												_g6 = (_g6 + 1);
HXDLIN(  37)												int i3 = (_g6 - 1);
HXDLIN(  37)												{
HXLINE(  37)													 ::haxe::io::ArrayBufferViewImpl this15 = b4->data;
HXDLIN(  37)													bool undoImage2;
HXDLIN(  37)													if ((i3 >= 0)) {
HXLINE(  37)														undoImage2 = (i3 < (this15->byteLength >> 2));
            													}
            													else {
HXLINE(  37)														undoImage2 = false;
            													}
HXDLIN(  37)													if (undoImage2) {
HXLINE(  37)														 ::haxe::io::Bytes _this = this15->bytes;
HXDLIN(  37)														int pos = ((i3 << 2) + this15->byteOffset);
HXDLIN(  37)														_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  37)														_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  37)														_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  37)														_this->b[(pos + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN(  37)									undoImage1 = b4;
            								}
            								break;
            								case (int)3: {
HXLINE(  37)									 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  37)									 ::iterMagic::VecIntImg v = vec;
HXDLIN(  37)									{
HXLINE(  37)										v->width = width;
HXDLIN(  37)										v->height = height;
HXDLIN(  37)										v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  37)										v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  37)										{
HXLINE(  37)											int _g8 = 0;
HXDLIN(  37)											int _g9 = v->length;
HXDLIN(  37)											while((_g8 < _g9)){
HXLINE(  37)												_g8 = (_g8 + 1);
HXDLIN(  37)												int i4 = (_g8 - 1);
HXDLIN(  37)												v->data->__unsafe_set(i4,0);
            											}
            										}
            									}
HXDLIN(  37)									undoImage1 = v;
            								}
            								break;
            								case (int)4: {
HXLINE(  37)									 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  37)									 ::iterMagic::StackIntImg b5 = sInt;
HXDLIN(  37)									{
HXLINE(  37)										b5->width = width;
HXDLIN(  37)										b5->height = height;
HXDLIN(  37)										b5->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  37)										b5->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  37)										{
HXLINE(  37)											int len1 = b5->length;
HXDLIN(  37)											 ::haxe::ds::GenericStack_Int d1 = b5->data;
HXDLIN(  37)											if (::hx::IsNull( d1->head )) {
HXLINE(  37)												int _g10 = 0;
HXDLIN(  37)												int _g11 = len1;
HXDLIN(  37)												while((_g10 < _g11)){
HXLINE(  37)													_g10 = (_g10 + 1);
HXDLIN(  37)													int i5 = (_g10 - 1);
HXDLIN(  37)													d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            												}
            											}
            											else {
HXLINE(  37)												int _g12 = 0;
HXDLIN(  37)												int _g13 = len1;
HXDLIN(  37)												while((_g12 < _g13)){
HXLINE(  37)													_g12 = (_g12 + 1);
HXDLIN(  37)													int i6 = (_g12 - 1);
HXDLIN(  37)													{
HXLINE(  37)														 ::haxe::ds::GenericCell_Int l = b5->data->head;
HXDLIN(  37)														 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  37)														{
HXLINE(  37)															int _g14 = 0;
HXDLIN(  37)															int _g15 = i6;
HXDLIN(  37)															while((_g14 < _g15)){
HXLINE(  37)																_g14 = (_g14 + 1);
HXDLIN(  37)																int i7 = (_g14 - 1);
HXLINE( 345)																prev = l;
HXLINE( 346)																l = l->next;
            															}
            														}
HXLINE(  37)														if (::hx::IsNull( prev )) {
HXLINE(  37)															b5->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  37)															l = null();
            														}
            														else {
HXLINE(  37)															prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  37)															l = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  37)									undoImage1 = b5;
            								}
            								break;
            							}
HXDLIN(  37)							this14->image = undoImage1;
HXDLIN(  37)							this14->width = width;
HXDLIN(  37)							this14->height = height;
HXDLIN(  37)							this14->imageType = ( (int)(imageType) );
HXDLIN(  37)							undoImage = this14;
HXDLIN(  37)							{
HXLINE(  37)								int rectLeft = xIter3->start;
HXDLIN(  37)								int rectTop = yIter3->start;
HXDLIN(  37)								int rectRight = xIter3->max;
HXDLIN(  37)								bool forceClear = false;
HXDLIN(  37)								{
HXLINE(  37)									int _g16 = rectTop;
HXDLIN(  37)									int _g17 = yIter3->max;
HXDLIN(  37)									while((_g16 < _g17)){
HXLINE(  37)										_g16 = (_g16 + 1);
HXDLIN(  37)										int dy = (_g16 - 1);
HXDLIN(  37)										{
HXLINE(  37)											int _g18 = rectLeft;
HXDLIN(  37)											int _g19 = rectRight;
HXDLIN(  37)											while((_g18 < _g19)){
HXLINE(  37)												_g18 = (_g18 + 1);
HXDLIN(  37)												int dx = (_g18 - 1);
HXDLIN(  37)												::Dynamic this16 = this13->image;
HXDLIN(  37)												int index1;
HXDLIN(  37)												if (this13->useVirtualPos) {
HXLINE(  37)													index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this13->virtualY) * ( (Float)(this13->width) )) + dx) - this13->virtualX));
            												}
            												else {
HXLINE(  37)													index1 = ::Std_obj::_hx_int(( (Float)(((dy * this13->width) + dx)) ));
            												}
HXDLIN(  37)												int c1 = ::iterMagic::Iimg_obj::get(this16,index1);
HXDLIN(  37)												int col;
HXDLIN(  37)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  37)													col = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            												}
            												else {
HXLINE(  37)													col = c1;
            												}
HXDLIN(  37)												bool _hx_tmp3;
HXDLIN(  37)												if (this13->useMask) {
HXLINE(  37)													_hx_tmp3 = ::hx::IsNotNull( this13->mask );
            												}
            												else {
HXLINE(  37)													_hx_tmp3 = false;
            												}
HXDLIN(  37)												if (_hx_tmp3) {
HXLINE(  37)													 ::pi_xy::ImageStruct this17 = this13->mask;
HXDLIN(  37)													::Dynamic this18 = this17->image;
HXDLIN(  37)													int index2;
HXDLIN(  37)													if (this17->useVirtualPos) {
HXLINE(  37)														index2 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this17->virtualY) * ( (Float)(this17->width) )) + dx) - this17->virtualX));
            													}
            													else {
HXLINE(  37)														index2 = ::Std_obj::_hx_int(( (Float)(((dy * this17->width) + dx)) ));
            													}
HXDLIN(  37)													int c2 = ::iterMagic::Iimg_obj::get(this18,index2);
HXDLIN(  37)													int v1;
HXDLIN(  37)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  37)														v1 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            													}
            													else {
HXLINE(  37)														v1 = c2;
            													}
HXDLIN(  37)													int maskPixel = v1;
HXDLIN(  37)													int this19 = col;
HXDLIN(  37)													if ((maskPixel == 0)) {
HXLINE(  37)														col = this19;
            													}
            													else {
HXLINE(  37)														Float m0;
HXDLIN(  37)														int this20 = ((maskPixel >> 24) & 255);
HXDLIN(  37)														if ((this20 == 0)) {
HXLINE(  37)															m0 = ((Float)0.);
            														}
            														else {
HXLINE(  37)															m0 = (( (Float)(this20) ) / ( (Float)(255) ));
            														}
HXDLIN(  37)														Float m1;
HXDLIN(  37)														int this21 = ((maskPixel >> 16) & 255);
HXDLIN(  37)														if ((this21 == 0)) {
HXLINE(  37)															m1 = ((Float)0.);
            														}
            														else {
HXLINE(  37)															m1 = (( (Float)(this21) ) / ( (Float)(255) ));
            														}
HXDLIN(  37)														Float m2;
HXDLIN(  37)														int this22 = ((maskPixel >> 8) & 255);
HXDLIN(  37)														if ((this22 == 0)) {
HXLINE(  37)															m2 = ((Float)0.);
            														}
            														else {
HXLINE(  37)															m2 = (( (Float)(this22) ) / ( (Float)(255) ));
            														}
HXDLIN(  37)														Float m3;
HXDLIN(  37)														int this23 = (maskPixel & 255);
HXDLIN(  37)														if ((this23 == 0)) {
HXLINE(  37)															m3 = ((Float)0.);
            														}
            														else {
HXLINE(  37)															m3 = (( (Float)(this23) ) / ( (Float)(255) ));
            														}
HXDLIN(  37)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this19 >> 24) & 255)) )));
HXDLIN(  37)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this19 >> 16) & 255)) )));
HXDLIN(  37)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this19 >> 8) & 255)) )));
HXDLIN(  37)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this19 & 255)) )));
HXDLIN(  37)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  37)												if ((col != 0)) {
HXLINE(  37)													int x2 = (dx - rectLeft);
HXDLIN(  37)													int y3 = (dy - rectTop);
HXDLIN(  37)													int c3 = col;
HXDLIN(  37)													bool _hx_tmp4;
HXDLIN(  37)													if ((((c3 >> 24) & 255) < 254)) {
HXLINE(  37)														_hx_tmp4 = undoImage->transparent;
            													}
            													else {
HXLINE(  37)														_hx_tmp4 = false;
            													}
HXDLIN(  37)													if (_hx_tmp4) {
HXLINE(  37)														int location1;
HXDLIN(  37)														if (undoImage->useVirtualPos) {
HXLINE(  37)															location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            														}
            														else {
HXLINE(  37)															location1 = ::Std_obj::_hx_int(( (Float)(((y3 * undoImage->width) + x2)) ));
            														}
HXDLIN(  37)														int this24 = ::iterMagic::Iimg_obj::get(undoImage->image,location1);
HXDLIN(  37)														int this25;
HXDLIN(  37)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  37)															this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            														}
            														else {
HXLINE(  37)															this25 = this24;
            														}
HXDLIN(  37)														Float a11;
HXDLIN(  37)														int this26 = ((this25 >> 24) & 255);
HXDLIN(  37)														if ((this26 == 0)) {
HXLINE(  37)															a11 = ((Float)0.);
            														}
            														else {
HXLINE(  37)															a11 = (( (Float)(this26) ) / ( (Float)(255) ));
            														}
HXDLIN(  37)														Float r11;
HXDLIN(  37)														int this27 = ((this25 >> 16) & 255);
HXDLIN(  37)														if ((this27 == 0)) {
HXLINE(  37)															r11 = ((Float)0.);
            														}
            														else {
HXLINE(  37)															r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            														}
HXDLIN(  37)														Float g11;
HXDLIN(  37)														int this28 = ((this25 >> 8) & 255);
HXDLIN(  37)														if ((this28 == 0)) {
HXLINE(  37)															g11 = ((Float)0.);
            														}
            														else {
HXLINE(  37)															g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            														}
HXDLIN(  37)														Float b11;
HXDLIN(  37)														int this29 = (this25 & 255);
HXDLIN(  37)														if ((this29 == 0)) {
HXLINE(  37)															b11 = ((Float)0.);
            														}
            														else {
HXLINE(  37)															b11 = (( (Float)(this29) ) / ( (Float)(255) ));
            														}
HXDLIN(  37)														Float a21;
HXDLIN(  37)														int this30 = ((col >> 24) & 255);
HXDLIN(  37)														if ((this30 == 0)) {
HXLINE(  37)															a21 = ((Float)0.);
            														}
            														else {
HXLINE(  37)															a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            														}
HXDLIN(  37)														Float r21;
HXDLIN(  37)														int this31 = ((col >> 16) & 255);
HXDLIN(  37)														if ((this31 == 0)) {
HXLINE(  37)															r21 = ((Float)0.);
            														}
            														else {
HXLINE(  37)															r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            														}
HXDLIN(  37)														Float g21;
HXDLIN(  37)														int this32 = ((col >> 8) & 255);
HXDLIN(  37)														if ((this32 == 0)) {
HXLINE(  37)															g21 = ((Float)0.);
            														}
            														else {
HXLINE(  37)															g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            														}
HXDLIN(  37)														Float b21;
HXDLIN(  37)														int this33 = (col & 255);
HXDLIN(  37)														if ((this33 == 0)) {
HXLINE(  37)															b21 = ((Float)0.);
            														}
            														else {
HXLINE(  37)															b21 = (( (Float)(this33) ) / ( (Float)(255) ));
            														}
HXDLIN(  37)														Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  37)														int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  37)														int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  37)														int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a31) + (b21 * a21))));
HXDLIN(  37)														int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  37)														int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b6);
HXDLIN(  37)														{
HXLINE(  37)															int _hx_tmp5;
HXDLIN(  37)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  37)																_hx_tmp5 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            															}
            															else {
HXLINE(  37)																_hx_tmp5 = blended1;
            															}
HXDLIN(  37)															::iterMagic::Iimg_obj::set(undoImage->image,location1,_hx_tmp5);
            														}
            													}
            													else {
HXLINE(  37)														::Dynamic this34 = undoImage->image;
HXDLIN(  37)														int index3;
HXDLIN(  37)														if (undoImage->useVirtualPos) {
HXLINE(  37)															index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            														}
            														else {
HXLINE(  37)															index3 = ::Std_obj::_hx_int(( (Float)(((y3 * undoImage->width) + x2)) ));
            														}
HXDLIN(  37)														int _hx_tmp6;
HXDLIN(  37)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  37)															_hx_tmp6 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            														}
            														else {
HXLINE(  37)															_hx_tmp6 = c3;
            														}
HXDLIN(  37)														::iterMagic::Iimg_obj::set(this34,index3,_hx_tmp6);
            													}
            												}
            												else {
HXLINE(  37)													if (forceClear) {
HXLINE(  37)														::Dynamic this35 = undoImage->image;
HXDLIN(  37)														int x3 = (dx - rectLeft);
HXDLIN(  37)														int y4 = (dy - rectTop);
HXDLIN(  37)														int index4;
HXDLIN(  37)														if (undoImage->useVirtualPos) {
HXLINE(  37)															index4 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x3) - undoImage->virtualX));
            														}
            														else {
HXLINE(  37)															index4 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage->width) + x3)) ));
            														}
HXDLIN(  37)														::iterMagic::Iimg_obj::set(this35,index4,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  37)						bool found = false;
HXDLIN(  37)						Float s = ((Float)0.);
HXDLIN(  37)						Float t = ((Float)0.);
HXDLIN(  37)						Float sxx = ((Float)0.);
HXDLIN(  37)						Float txx = ((Float)0.);
HXDLIN(  37)						{
HXLINE(  37)							int _g_min = xIter3->start;
HXDLIN(  37)							int _g_max = xIter3->max;
HXDLIN(  37)							while((_g_min < _g_max)){
HXLINE(  37)								_g_min = (_g_min + 1);
HXDLIN(  37)								int x4 = (_g_min - 1);
HXLINE(  60)								sxx = (sx * ( (Float)(x4) ));
HXLINE(  61)								txx = (tx * ( (Float)(x4) ));
HXLINE(  62)								found = false;
HXLINE(  37)								{
HXLINE(  37)									int _g_min1 = yIter3->start;
HXDLIN(  37)									int _g_max1 = yIter3->max;
HXDLIN(  37)									while((_g_min1 < _g_max1)){
HXLINE(  37)										_g_min1 = (_g_min1 + 1);
HXDLIN(  37)										int y5 = (_g_min1 - 1);
HXLINE(  64)										s = ((s0 + sxx) + (sy * ( (Float)(y5) )));
HXLINE(  65)										t = ((t0 + txx) + (ty * ( (Float)(y5) )));
HXLINE(  37)										bool _hx_tmp7;
HXDLIN(  37)										if (!((s <= 0))) {
HXLINE(  37)											_hx_tmp7 = (t <= 0);
            										}
            										else {
HXLINE(  37)											_hx_tmp7 = true;
            										}
HXDLIN(  37)										if (_hx_tmp7) {
HXLINE(  37)											if (found) {
HXLINE(  37)												goto _hx_goto_25;
            											}
            										}
            										else {
HXLINE(  37)											if (((s + t) < A)) {
HXLINE(  37)												{
HXLINE(  37)													int c4 = color;
HXDLIN(  37)													bool _hx_tmp8;
HXDLIN(  37)													if ((((c4 >> 24) & 255) < 254)) {
HXLINE(  37)														_hx_tmp8 = this13->transparent;
            													}
            													else {
HXLINE(  37)														_hx_tmp8 = false;
            													}
HXDLIN(  37)													if (_hx_tmp8) {
HXLINE(  37)														int location2;
HXDLIN(  37)														if (this13->useVirtualPos) {
HXLINE(  37)															location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - this13->virtualY) * ( (Float)(this13->width) )) + x4) - this13->virtualX));
            														}
            														else {
HXLINE(  37)															location2 = ::Std_obj::_hx_int(( (Float)(((y5 * this13->width) + x4)) ));
            														}
HXDLIN(  37)														int this36 = ::iterMagic::Iimg_obj::get(this13->image,location2);
HXDLIN(  37)														int this37;
HXDLIN(  37)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  37)															this37 = ((((((this36 >> 24) & 255) << 24) | ((this36 & 255) << 16)) | (((this36 >> 8) & 255) << 8)) | ((this36 >> 16) & 255));
            														}
            														else {
HXLINE(  37)															this37 = this36;
            														}
HXDLIN(  37)														Float a12;
HXDLIN(  37)														int this38 = ((this37 >> 24) & 255);
HXDLIN(  37)														if ((this38 == 0)) {
HXLINE(  37)															a12 = ((Float)0.);
            														}
            														else {
HXLINE(  37)															a12 = (( (Float)(this38) ) / ( (Float)(255) ));
            														}
HXDLIN(  37)														Float r12;
HXDLIN(  37)														int this39 = ((this37 >> 16) & 255);
HXDLIN(  37)														if ((this39 == 0)) {
HXLINE(  37)															r12 = ((Float)0.);
            														}
            														else {
HXLINE(  37)															r12 = (( (Float)(this39) ) / ( (Float)(255) ));
            														}
HXDLIN(  37)														Float g12;
HXDLIN(  37)														int this40 = ((this37 >> 8) & 255);
HXDLIN(  37)														if ((this40 == 0)) {
HXLINE(  37)															g12 = ((Float)0.);
            														}
            														else {
HXLINE(  37)															g12 = (( (Float)(this40) ) / ( (Float)(255) ));
            														}
HXDLIN(  37)														Float b12;
HXDLIN(  37)														int this41 = (this37 & 255);
HXDLIN(  37)														if ((this41 == 0)) {
HXLINE(  37)															b12 = ((Float)0.);
            														}
            														else {
HXLINE(  37)															b12 = (( (Float)(this41) ) / ( (Float)(255) ));
            														}
HXDLIN(  37)														Float a22;
HXDLIN(  37)														int this42 = ((color >> 24) & 255);
HXDLIN(  37)														if ((this42 == 0)) {
HXLINE(  37)															a22 = ((Float)0.);
            														}
            														else {
HXLINE(  37)															a22 = (( (Float)(this42) ) / ( (Float)(255) ));
            														}
HXDLIN(  37)														Float r22;
HXDLIN(  37)														int this43 = ((color >> 16) & 255);
HXDLIN(  37)														if ((this43 == 0)) {
HXLINE(  37)															r22 = ((Float)0.);
            														}
            														else {
HXLINE(  37)															r22 = (( (Float)(this43) ) / ( (Float)(255) ));
            														}
HXDLIN(  37)														Float g22;
HXDLIN(  37)														int this44 = ((color >> 8) & 255);
HXDLIN(  37)														if ((this44 == 0)) {
HXLINE(  37)															g22 = ((Float)0.);
            														}
            														else {
HXLINE(  37)															g22 = (( (Float)(this44) ) / ( (Float)(255) ));
            														}
HXDLIN(  37)														Float b22;
HXDLIN(  37)														int this45 = (color & 255);
HXDLIN(  37)														if ((this45 == 0)) {
HXLINE(  37)															b22 = ((Float)0.);
            														}
            														else {
HXLINE(  37)															b22 = (( (Float)(this45) ) / ( (Float)(255) ));
            														}
HXDLIN(  37)														Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  37)														int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  37)														int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  37)														int b7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a32) + (b22 * a22))));
HXDLIN(  37)														int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  37)														int blended2 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b7);
HXDLIN(  37)														{
HXLINE(  37)															int _hx_tmp9;
HXDLIN(  37)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  37)																_hx_tmp9 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            															}
            															else {
HXLINE(  37)																_hx_tmp9 = blended2;
            															}
HXDLIN(  37)															::iterMagic::Iimg_obj::set(this13->image,location2,_hx_tmp9);
            														}
            													}
            													else {
HXLINE(  37)														::Dynamic this46 = this13->image;
HXDLIN(  37)														int index5;
HXDLIN(  37)														if (this13->useVirtualPos) {
HXLINE(  37)															index5 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - this13->virtualY) * ( (Float)(this13->width) )) + x4) - this13->virtualX));
            														}
            														else {
HXLINE(  37)															index5 = ::Std_obj::_hx_int(( (Float)(((y5 * this13->width) + x4)) ));
            														}
HXDLIN(  37)														int _hx_tmp10;
HXDLIN(  37)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  37)															_hx_tmp10 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            														}
            														else {
HXLINE(  37)															_hx_tmp10 = c4;
            														}
HXDLIN(  37)														::iterMagic::Iimg_obj::set(this46,index5,_hx_tmp10);
            													}
            												}
HXLINE(  73)												found = true;
            											}
            											else {
HXLINE(  37)												if (found) {
HXLINE(  37)													goto _hx_goto_25;
            												}
            											}
            										}
            									}
            									_hx_goto_25:;
            								}
            							}
            						}
HXDLIN(  37)						if ((hasHit == true)) {
HXLINE(  37)							 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx1,by1,cx1,cy1,true);
HXDLIN(  37)							if (hasUndo) {
HXLINE(  37)								v2->undoImage = undoImage;
HXDLIN(  37)								v2->undoX = xIter3->start;
HXDLIN(  37)								v2->undoY = yIter3->start;
            							}
            						}
            					}
            				}
            			}
HXLINE(  38)			{
HXLINE(  38)				 ::pi_xy::ImageStruct this47 = temp;
HXDLIN(  38)				Float ax1 = this->rx;
HXDLIN(  38)				Float ay1 = this->ry;
HXDLIN(  38)				bool hasHit1 = false;
HXDLIN(  38)				bool hasUndo1 = false;
HXDLIN(  38)				{
HXLINE(  38)					Float bx2 = bxS;
HXDLIN(  38)					Float by2 = byS;
HXDLIN(  38)					Float cx2 = cxS;
HXDLIN(  38)					Float cy2 = cyS;
HXDLIN(  38)					bool adjustWinding1 = (((((ax1 * by2) - (bx2 * ay1)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ay1) - (ax1 * cy2))) > 0);
HXDLIN(  38)					if (!(adjustWinding1)) {
HXLINE(  38)						Float bx_1 = bx2;
HXDLIN(  38)						Float by_1 = by2;
HXLINE(  25)						bx2 = cx2;
HXLINE(  26)						by2 = cy2;
HXLINE(  27)						cx2 = bx_1;
HXLINE(  28)						cy2 = by_1;
            					}
HXLINE(  38)					{
HXLINE(  38)						Float s01 = ((ay1 * cx2) - (ax1 * cy2));
HXDLIN(  38)						Float sx1 = (cy2 - ay1);
HXDLIN(  38)						Float sy1 = (ax1 - cx2);
HXDLIN(  38)						Float t01 = ((ax1 * by2) - (ay1 * bx2));
HXDLIN(  38)						Float tx1 = (ay1 - by2);
HXDLIN(  38)						Float ty1 = (bx2 - ax1);
HXDLIN(  38)						Float A1 = ((((-(by2) * cx2) + (ay1 * (-(bx2) + cx2))) + (ax1 * (by2 - cy2))) + (bx2 * cy2));
HXDLIN(  38)						 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  38)						if ((ax1 > bx2)) {
HXLINE(  38)							if ((ax1 > cx2)) {
HXLINE(  38)								int min4;
HXDLIN(  38)								if ((bx2 > cx2)) {
HXLINE(  38)									min4 = ::Math_obj::floor(cx2);
            								}
            								else {
HXLINE(  38)									min4 = ::Math_obj::floor(bx2);
            								}
HXDLIN(  38)								int ii_min10 = min4;
HXDLIN(  38)								int ii_max10 = ::Math_obj::ceil(ax1);
HXDLIN(  38)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            							}
            							else {
HXLINE(  38)								int ii_min11 = ::Math_obj::floor(bx2);
HXDLIN(  38)								int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN(  38)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            							}
            						}
            						else {
HXLINE(  38)							if ((bx2 > cx2)) {
HXLINE(  38)								int min5;
HXDLIN(  38)								if ((ax1 > cx2)) {
HXLINE(  38)									min5 = ::Math_obj::floor(cx2);
            								}
            								else {
HXLINE(  38)									min5 = ::Math_obj::ceil(ax1);
            								}
HXDLIN(  38)								int ii_min12 = min5;
HXDLIN(  38)								int ii_max12 = ::Math_obj::ceil(bx2);
HXDLIN(  38)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            							}
            							else {
HXLINE(  38)								int ii_min13 = ::Math_obj::floor(ax1);
HXDLIN(  38)								int ii_max13 = ::Math_obj::ceil(cx2);
HXDLIN(  38)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            							}
            						}
HXDLIN(  38)						 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  38)						if ((ay1 > by2)) {
HXLINE(  38)							if ((ay1 > cy2)) {
HXLINE(  38)								int min6;
HXDLIN(  38)								if ((by2 > cy2)) {
HXLINE(  38)									min6 = ::Math_obj::floor(cy2);
            								}
            								else {
HXLINE(  38)									min6 = ::Math_obj::floor(by2);
            								}
HXDLIN(  38)								int ii_min14 = min6;
HXDLIN(  38)								int ii_max14 = ::Math_obj::ceil(ay1);
HXDLIN(  38)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            							}
            							else {
HXLINE(  38)								int ii_min15 = ::Math_obj::floor(by2);
HXDLIN(  38)								int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN(  38)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            							}
            						}
            						else {
HXLINE(  38)							if ((by2 > cy2)) {
HXLINE(  38)								int min7;
HXDLIN(  38)								if ((ay1 > cy2)) {
HXLINE(  38)									min7 = ::Math_obj::floor(cy2);
            								}
            								else {
HXLINE(  38)									min7 = ::Math_obj::ceil(ay1);
            								}
HXDLIN(  38)								int ii_min16 = min7;
HXDLIN(  38)								int ii_max16 = ::Math_obj::ceil(by2);
HXDLIN(  38)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            							}
            							else {
HXLINE(  38)								int ii_min17 = ::Math_obj::floor(ay1);
HXDLIN(  38)								int ii_max17 = ::Math_obj::ceil(cy2);
HXDLIN(  38)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            							}
            						}
HXDLIN(  38)						 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  38)						if (hasUndo1) {
HXLINE(  38)							int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  38)							int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  38)							 ::Dynamic imageType1 = null();
HXDLIN(  38)							 ::pi_xy::ImageStruct this48 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  38)							if (::hx::IsNull( imageType1 )) {
HXLINE(  54)								imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE(  38)							::Dynamic undoImage4;
HXDLIN(  38)							switch((int)(( (int)(imageType1) ))){
            								case (int)0: {
HXLINE(  38)									 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  38)									 ::iterMagic::BytesImg b8 = byt1;
HXDLIN(  38)									{
HXLINE(  38)										b8->width = width1;
HXDLIN(  38)										b8->height = height1;
HXDLIN(  38)										b8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  38)										b8->data = ::haxe::io::Bytes_obj::alloc((b8->length * 4));
HXDLIN(  38)										{
HXLINE(  38)											int len2 = b8->length;
HXDLIN(  38)											int w1 = 0;
HXDLIN(  38)											{
HXLINE(  38)												int _g20 = 0;
HXDLIN(  38)												int _g21 = b8->height;
HXDLIN(  38)												while((_g20 < _g21)){
HXLINE(  38)													_g20 = (_g20 + 1);
HXDLIN(  38)													int y6 = (_g20 - 1);
HXDLIN(  38)													{
HXLINE(  38)														int _g22 = 0;
HXDLIN(  38)														int _g23 = b8->width;
HXDLIN(  38)														while((_g22 < _g23)){
HXLINE(  38)															_g22 = (_g22 + 1);
HXDLIN(  38)															int x5 = (_g22 - 1);
HXDLIN(  38)															{
HXLINE(  38)																w1 = (w1 + 1);
HXDLIN(  38)																b8->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  38)															{
HXLINE(  38)																w1 = (w1 + 1);
HXDLIN(  38)																b8->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  38)															{
HXLINE(  38)																w1 = (w1 + 1);
HXDLIN(  38)																b8->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  38)															{
HXLINE(  38)																w1 = (w1 + 1);
HXDLIN(  38)																b8->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  38)									undoImage4 = b8;
            								}
            								break;
            								case (int)1: {
HXLINE(  38)									 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  38)									 ::iterMagic::ArrIntImg a7 = arrI1;
HXDLIN(  38)									{
HXLINE(  38)										a7->width = width1;
HXDLIN(  38)										a7->height = height1;
HXDLIN(  38)										a7->data = ::Array_obj< int >::__new(0);
HXDLIN(  38)										a7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  38)										{
HXLINE(  38)											int _g24 = 0;
HXDLIN(  38)											int _g25 = a7->length;
HXDLIN(  38)											while((_g24 < _g25)){
HXLINE(  38)												_g24 = (_g24 + 1);
HXDLIN(  38)												int i8 = (_g24 - 1);
HXDLIN(  38)												a7->data[i8] = 0;
            											}
            										}
            									}
HXDLIN(  38)									undoImage4 = a7;
            								}
            								break;
            								case (int)2: {
HXLINE(  38)									 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  38)									 ::iterMagic::U32ArrImg b9 = u32a1;
HXDLIN(  38)									{
HXLINE(  38)										b9->width = width1;
HXDLIN(  38)										b9->height = height1;
HXDLIN(  38)										b9->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  38)										int size1 = (b9->length * 4);
HXDLIN(  38)										b9->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  38)										{
HXLINE(  38)											int _g26 = 0;
HXDLIN(  38)											int _g27 = b9->length;
HXDLIN(  38)											while((_g26 < _g27)){
HXLINE(  38)												_g26 = (_g26 + 1);
HXDLIN(  38)												int i9 = (_g26 - 1);
HXDLIN(  38)												{
HXLINE(  38)													 ::haxe::io::ArrayBufferViewImpl this49 = b9->data;
HXDLIN(  38)													bool undoImage5;
HXDLIN(  38)													if ((i9 >= 0)) {
HXLINE(  38)														undoImage5 = (i9 < (this49->byteLength >> 2));
            													}
            													else {
HXLINE(  38)														undoImage5 = false;
            													}
HXDLIN(  38)													if (undoImage5) {
HXLINE(  38)														 ::haxe::io::Bytes _this1 = this49->bytes;
HXDLIN(  38)														int pos1 = ((i9 << 2) + this49->byteOffset);
HXDLIN(  38)														_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  38)														_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  38)														_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  38)														_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN(  38)									undoImage4 = b9;
            								}
            								break;
            								case (int)3: {
HXLINE(  38)									 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  38)									 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN(  38)									{
HXLINE(  38)										v3->width = width1;
HXDLIN(  38)										v3->height = height1;
HXDLIN(  38)										v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  38)										v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN(  38)										{
HXLINE(  38)											int _g28 = 0;
HXDLIN(  38)											int _g29 = v3->length;
HXDLIN(  38)											while((_g28 < _g29)){
HXLINE(  38)												_g28 = (_g28 + 1);
HXDLIN(  38)												int i10 = (_g28 - 1);
HXDLIN(  38)												v3->data->__unsafe_set(i10,0);
            											}
            										}
            									}
HXDLIN(  38)									undoImage4 = v3;
            								}
            								break;
            								case (int)4: {
HXLINE(  38)									 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  38)									 ::iterMagic::StackIntImg b10 = sInt1;
HXDLIN(  38)									{
HXLINE(  38)										b10->width = width1;
HXDLIN(  38)										b10->height = height1;
HXDLIN(  38)										b10->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  38)										b10->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  38)										{
HXLINE(  38)											int len3 = b10->length;
HXDLIN(  38)											 ::haxe::ds::GenericStack_Int d2 = b10->data;
HXDLIN(  38)											if (::hx::IsNull( d2->head )) {
HXLINE(  38)												int _g30 = 0;
HXDLIN(  38)												int _g31 = len3;
HXDLIN(  38)												while((_g30 < _g31)){
HXLINE(  38)													_g30 = (_g30 + 1);
HXDLIN(  38)													int i11 = (_g30 - 1);
HXDLIN(  38)													d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            												}
            											}
            											else {
HXLINE(  38)												int _g32 = 0;
HXDLIN(  38)												int _g33 = len3;
HXDLIN(  38)												while((_g32 < _g33)){
HXLINE(  38)													_g32 = (_g32 + 1);
HXDLIN(  38)													int i12 = (_g32 - 1);
HXDLIN(  38)													{
HXLINE(  38)														 ::haxe::ds::GenericCell_Int l1 = b10->data->head;
HXDLIN(  38)														 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  38)														{
HXLINE(  38)															int _g34 = 0;
HXDLIN(  38)															int _g35 = i12;
HXDLIN(  38)															while((_g34 < _g35)){
HXLINE(  38)																_g34 = (_g34 + 1);
HXDLIN(  38)																int i13 = (_g34 - 1);
HXLINE( 345)																prev1 = l1;
HXLINE( 346)																l1 = l1->next;
            															}
            														}
HXLINE(  38)														if (::hx::IsNull( prev1 )) {
HXLINE(  38)															b10->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  38)															l1 = null();
            														}
            														else {
HXLINE(  38)															prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  38)															l1 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  38)									undoImage4 = b10;
            								}
            								break;
            							}
HXDLIN(  38)							this48->image = undoImage4;
HXDLIN(  38)							this48->width = width1;
HXDLIN(  38)							this48->height = height1;
HXDLIN(  38)							this48->imageType = ( (int)(imageType1) );
HXDLIN(  38)							undoImage3 = this48;
HXDLIN(  38)							{
HXLINE(  38)								int rectLeft1 = xIter31->start;
HXDLIN(  38)								int rectTop1 = yIter31->start;
HXDLIN(  38)								int rectRight1 = xIter31->max;
HXDLIN(  38)								bool forceClear1 = false;
HXDLIN(  38)								{
HXLINE(  38)									int _g36 = rectTop1;
HXDLIN(  38)									int _g37 = yIter31->max;
HXDLIN(  38)									while((_g36 < _g37)){
HXLINE(  38)										_g36 = (_g36 + 1);
HXDLIN(  38)										int dy1 = (_g36 - 1);
HXDLIN(  38)										{
HXLINE(  38)											int _g38 = rectLeft1;
HXDLIN(  38)											int _g39 = rectRight1;
HXDLIN(  38)											while((_g38 < _g39)){
HXLINE(  38)												_g38 = (_g38 + 1);
HXDLIN(  38)												int dx1 = (_g38 - 1);
HXDLIN(  38)												::Dynamic this50 = this47->image;
HXDLIN(  38)												int index6;
HXDLIN(  38)												if (this47->useVirtualPos) {
HXLINE(  38)													index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this47->virtualY) * ( (Float)(this47->width) )) + dx1) - this47->virtualX));
            												}
            												else {
HXLINE(  38)													index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this47->width) + dx1)) ));
            												}
HXDLIN(  38)												int c5 = ::iterMagic::Iimg_obj::get(this50,index6);
HXDLIN(  38)												int col1;
HXDLIN(  38)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  38)													col1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            												}
            												else {
HXLINE(  38)													col1 = c5;
            												}
HXDLIN(  38)												bool _hx_tmp11;
HXDLIN(  38)												if (this47->useMask) {
HXLINE(  38)													_hx_tmp11 = ::hx::IsNotNull( this47->mask );
            												}
            												else {
HXLINE(  38)													_hx_tmp11 = false;
            												}
HXDLIN(  38)												if (_hx_tmp11) {
HXLINE(  38)													 ::pi_xy::ImageStruct this51 = this47->mask;
HXDLIN(  38)													::Dynamic this52 = this51->image;
HXDLIN(  38)													int index7;
HXDLIN(  38)													if (this51->useVirtualPos) {
HXLINE(  38)														index7 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this51->virtualY) * ( (Float)(this51->width) )) + dx1) - this51->virtualX));
            													}
            													else {
HXLINE(  38)														index7 = ::Std_obj::_hx_int(( (Float)(((dy1 * this51->width) + dx1)) ));
            													}
HXDLIN(  38)													int c6 = ::iterMagic::Iimg_obj::get(this52,index7);
HXDLIN(  38)													int v4;
HXDLIN(  38)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  38)														v4 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            													}
            													else {
HXLINE(  38)														v4 = c6;
            													}
HXDLIN(  38)													int maskPixel1 = v4;
HXDLIN(  38)													int this53 = col1;
HXDLIN(  38)													if ((maskPixel1 == 0)) {
HXLINE(  38)														col1 = this53;
            													}
            													else {
HXLINE(  38)														Float m01;
HXDLIN(  38)														int this54 = ((maskPixel1 >> 24) & 255);
HXDLIN(  38)														if ((this54 == 0)) {
HXLINE(  38)															m01 = ((Float)0.);
            														}
            														else {
HXLINE(  38)															m01 = (( (Float)(this54) ) / ( (Float)(255) ));
            														}
HXDLIN(  38)														Float m11;
HXDLIN(  38)														int this55 = ((maskPixel1 >> 16) & 255);
HXDLIN(  38)														if ((this55 == 0)) {
HXLINE(  38)															m11 = ((Float)0.);
            														}
            														else {
HXLINE(  38)															m11 = (( (Float)(this55) ) / ( (Float)(255) ));
            														}
HXDLIN(  38)														Float m21;
HXDLIN(  38)														int this56 = ((maskPixel1 >> 8) & 255);
HXDLIN(  38)														if ((this56 == 0)) {
HXLINE(  38)															m21 = ((Float)0.);
            														}
            														else {
HXLINE(  38)															m21 = (( (Float)(this56) ) / ( (Float)(255) ));
            														}
HXDLIN(  38)														Float m31;
HXDLIN(  38)														int this57 = (maskPixel1 & 255);
HXDLIN(  38)														if ((this57 == 0)) {
HXLINE(  38)															m31 = ((Float)0.);
            														}
            														else {
HXLINE(  38)															m31 = (( (Float)(this57) ) / ( (Float)(255) ));
            														}
HXDLIN(  38)														int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this53 >> 24) & 255)) )));
HXDLIN(  38)														int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this53 >> 16) & 255)) )));
HXDLIN(  38)														int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this53 >> 8) & 255)) )));
HXDLIN(  38)														int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this53 & 255)) )));
HXDLIN(  38)														col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  38)												if ((col1 != 0)) {
HXLINE(  38)													int x6 = (dx1 - rectLeft1);
HXDLIN(  38)													int y7 = (dy1 - rectTop1);
HXDLIN(  38)													int c7 = col1;
HXDLIN(  38)													bool _hx_tmp12;
HXDLIN(  38)													if ((((c7 >> 24) & 255) < 254)) {
HXLINE(  38)														_hx_tmp12 = undoImage3->transparent;
            													}
            													else {
HXLINE(  38)														_hx_tmp12 = false;
            													}
HXDLIN(  38)													if (_hx_tmp12) {
HXLINE(  38)														int location3;
HXDLIN(  38)														if (undoImage3->useVirtualPos) {
HXLINE(  38)															location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            														}
            														else {
HXLINE(  38)															location3 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage3->width) + x6)) ));
            														}
HXDLIN(  38)														int this58 = ::iterMagic::Iimg_obj::get(undoImage3->image,location3);
HXDLIN(  38)														int this59;
HXDLIN(  38)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  38)															this59 = ((((((this58 >> 24) & 255) << 24) | ((this58 & 255) << 16)) | (((this58 >> 8) & 255) << 8)) | ((this58 >> 16) & 255));
            														}
            														else {
HXLINE(  38)															this59 = this58;
            														}
HXDLIN(  38)														Float a13;
HXDLIN(  38)														int this60 = ((this59 >> 24) & 255);
HXDLIN(  38)														if ((this60 == 0)) {
HXLINE(  38)															a13 = ((Float)0.);
            														}
            														else {
HXLINE(  38)															a13 = (( (Float)(this60) ) / ( (Float)(255) ));
            														}
HXDLIN(  38)														Float r13;
HXDLIN(  38)														int this61 = ((this59 >> 16) & 255);
HXDLIN(  38)														if ((this61 == 0)) {
HXLINE(  38)															r13 = ((Float)0.);
            														}
            														else {
HXLINE(  38)															r13 = (( (Float)(this61) ) / ( (Float)(255) ));
            														}
HXDLIN(  38)														Float g13;
HXDLIN(  38)														int this62 = ((this59 >> 8) & 255);
HXDLIN(  38)														if ((this62 == 0)) {
HXLINE(  38)															g13 = ((Float)0.);
            														}
            														else {
HXLINE(  38)															g13 = (( (Float)(this62) ) / ( (Float)(255) ));
            														}
HXDLIN(  38)														Float b13;
HXDLIN(  38)														int this63 = (this59 & 255);
HXDLIN(  38)														if ((this63 == 0)) {
HXLINE(  38)															b13 = ((Float)0.);
            														}
            														else {
HXLINE(  38)															b13 = (( (Float)(this63) ) / ( (Float)(255) ));
            														}
HXDLIN(  38)														Float a23;
HXDLIN(  38)														int this64 = ((col1 >> 24) & 255);
HXDLIN(  38)														if ((this64 == 0)) {
HXLINE(  38)															a23 = ((Float)0.);
            														}
            														else {
HXLINE(  38)															a23 = (( (Float)(this64) ) / ( (Float)(255) ));
            														}
HXDLIN(  38)														Float r23;
HXDLIN(  38)														int this65 = ((col1 >> 16) & 255);
HXDLIN(  38)														if ((this65 == 0)) {
HXLINE(  38)															r23 = ((Float)0.);
            														}
            														else {
HXLINE(  38)															r23 = (( (Float)(this65) ) / ( (Float)(255) ));
            														}
HXDLIN(  38)														Float g23;
HXDLIN(  38)														int this66 = ((col1 >> 8) & 255);
HXDLIN(  38)														if ((this66 == 0)) {
HXLINE(  38)															g23 = ((Float)0.);
            														}
            														else {
HXLINE(  38)															g23 = (( (Float)(this66) ) / ( (Float)(255) ));
            														}
HXDLIN(  38)														Float b23;
HXDLIN(  38)														int this67 = (col1 & 255);
HXDLIN(  38)														if ((this67 == 0)) {
HXLINE(  38)															b23 = ((Float)0.);
            														}
            														else {
HXLINE(  38)															b23 = (( (Float)(this67) ) / ( (Float)(255) ));
            														}
HXDLIN(  38)														Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  38)														int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  38)														int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  38)														int b14 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a33) + (b23 * a23))));
HXDLIN(  38)														int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  38)														int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b14);
HXDLIN(  38)														{
HXLINE(  38)															int _hx_tmp13;
HXDLIN(  38)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  38)																_hx_tmp13 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            															}
            															else {
HXLINE(  38)																_hx_tmp13 = blended3;
            															}
HXDLIN(  38)															::iterMagic::Iimg_obj::set(undoImage3->image,location3,_hx_tmp13);
            														}
            													}
            													else {
HXLINE(  38)														::Dynamic this68 = undoImage3->image;
HXDLIN(  38)														int index8;
HXDLIN(  38)														if (undoImage3->useVirtualPos) {
HXLINE(  38)															index8 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            														}
            														else {
HXLINE(  38)															index8 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage3->width) + x6)) ));
            														}
HXDLIN(  38)														int _hx_tmp14;
HXDLIN(  38)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  38)															_hx_tmp14 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            														}
            														else {
HXLINE(  38)															_hx_tmp14 = c7;
            														}
HXDLIN(  38)														::iterMagic::Iimg_obj::set(this68,index8,_hx_tmp14);
            													}
            												}
            												else {
HXLINE(  38)													if (forceClear1) {
HXLINE(  38)														::Dynamic this69 = undoImage3->image;
HXDLIN(  38)														int x7 = (dx1 - rectLeft1);
HXDLIN(  38)														int y8 = (dy1 - rectTop1);
HXDLIN(  38)														int index9;
HXDLIN(  38)														if (undoImage3->useVirtualPos) {
HXLINE(  38)															index9 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x7) - undoImage3->virtualX));
            														}
            														else {
HXLINE(  38)															index9 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage3->width) + x7)) ));
            														}
HXDLIN(  38)														::iterMagic::Iimg_obj::set(this69,index9,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  38)						bool found1 = false;
HXDLIN(  38)						Float s1 = ((Float)0.);
HXDLIN(  38)						Float t1 = ((Float)0.);
HXDLIN(  38)						Float sxx1 = ((Float)0.);
HXDLIN(  38)						Float txx1 = ((Float)0.);
HXDLIN(  38)						{
HXLINE(  38)							int _g_min2 = xIter31->start;
HXDLIN(  38)							int _g_max2 = xIter31->max;
HXDLIN(  38)							while((_g_min2 < _g_max2)){
HXLINE(  38)								_g_min2 = (_g_min2 + 1);
HXDLIN(  38)								int x8 = (_g_min2 - 1);
HXLINE(  60)								sxx1 = (sx1 * ( (Float)(x8) ));
HXLINE(  61)								txx1 = (tx1 * ( (Float)(x8) ));
HXLINE(  62)								found1 = false;
HXLINE(  38)								{
HXLINE(  38)									int _g_min3 = yIter31->start;
HXDLIN(  38)									int _g_max3 = yIter31->max;
HXDLIN(  38)									while((_g_min3 < _g_max3)){
HXLINE(  38)										_g_min3 = (_g_min3 + 1);
HXDLIN(  38)										int y9 = (_g_min3 - 1);
HXLINE(  64)										s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y9) )));
HXLINE(  65)										t1 = ((t01 + txx1) + (ty1 * ( (Float)(y9) )));
HXLINE(  38)										bool _hx_tmp15;
HXDLIN(  38)										if (!((s1 <= 0))) {
HXLINE(  38)											_hx_tmp15 = (t1 <= 0);
            										}
            										else {
HXLINE(  38)											_hx_tmp15 = true;
            										}
HXDLIN(  38)										if (_hx_tmp15) {
HXLINE(  38)											if (found1) {
HXLINE(  38)												goto _hx_goto_37;
            											}
            										}
            										else {
HXLINE(  38)											if (((s1 + t1) < A1)) {
HXLINE(  38)												{
HXLINE(  38)													int c8 = 0;
HXDLIN(  38)													bool _hx_tmp16;
HXDLIN(  38)													if ((((c8 >> 24) & 255) < 254)) {
HXLINE(  38)														_hx_tmp16 = this47->transparent;
            													}
            													else {
HXLINE(  38)														_hx_tmp16 = false;
            													}
HXDLIN(  38)													if (_hx_tmp16) {
HXLINE(  38)														int location4;
HXDLIN(  38)														if (this47->useVirtualPos) {
HXLINE(  38)															location4 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - this47->virtualY) * ( (Float)(this47->width) )) + x8) - this47->virtualX));
            														}
            														else {
HXLINE(  38)															location4 = ::Std_obj::_hx_int(( (Float)(((y9 * this47->width) + x8)) ));
            														}
HXDLIN(  38)														int this70 = ::iterMagic::Iimg_obj::get(this47->image,location4);
HXDLIN(  38)														int this71;
HXDLIN(  38)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  38)															this71 = ((((((this70 >> 24) & 255) << 24) | ((this70 & 255) << 16)) | (((this70 >> 8) & 255) << 8)) | ((this70 >> 16) & 255));
            														}
            														else {
HXLINE(  38)															this71 = this70;
            														}
HXDLIN(  38)														Float a14;
HXDLIN(  38)														int this72 = ((this71 >> 24) & 255);
HXDLIN(  38)														if ((this72 == 0)) {
HXLINE(  38)															a14 = ((Float)0.);
            														}
            														else {
HXLINE(  38)															a14 = (( (Float)(this72) ) / ( (Float)(255) ));
            														}
HXDLIN(  38)														Float r14;
HXDLIN(  38)														int this73 = ((this71 >> 16) & 255);
HXDLIN(  38)														if ((this73 == 0)) {
HXLINE(  38)															r14 = ((Float)0.);
            														}
            														else {
HXLINE(  38)															r14 = (( (Float)(this73) ) / ( (Float)(255) ));
            														}
HXDLIN(  38)														Float g14;
HXDLIN(  38)														int this74 = ((this71 >> 8) & 255);
HXDLIN(  38)														if ((this74 == 0)) {
HXLINE(  38)															g14 = ((Float)0.);
            														}
            														else {
HXLINE(  38)															g14 = (( (Float)(this74) ) / ( (Float)(255) ));
            														}
HXDLIN(  38)														Float b15;
HXDLIN(  38)														int this75 = (this71 & 255);
HXDLIN(  38)														if ((this75 == 0)) {
HXLINE(  38)															b15 = ((Float)0.);
            														}
            														else {
HXLINE(  38)															b15 = (( (Float)(this75) ) / ( (Float)(255) ));
            														}
HXDLIN(  38)														Float a24;
HXDLIN(  38)														int this76 = ((0 >> 24) & 255);
HXDLIN(  38)														if ((this76 == 0)) {
HXLINE(  38)															a24 = ((Float)0.);
            														}
            														else {
HXLINE(  38)															a24 = (( (Float)(this76) ) / ( (Float)(255) ));
            														}
HXDLIN(  38)														Float r24;
HXDLIN(  38)														int this77 = ((0 >> 16) & 255);
HXDLIN(  38)														if ((this77 == 0)) {
HXLINE(  38)															r24 = ((Float)0.);
            														}
            														else {
HXLINE(  38)															r24 = (( (Float)(this77) ) / ( (Float)(255) ));
            														}
HXDLIN(  38)														Float g24;
HXDLIN(  38)														int this78 = ((0 >> 8) & 255);
HXDLIN(  38)														if ((this78 == 0)) {
HXLINE(  38)															g24 = ((Float)0.);
            														}
            														else {
HXLINE(  38)															g24 = (( (Float)(this78) ) / ( (Float)(255) ));
            														}
HXDLIN(  38)														Float b24;
HXDLIN(  38)														int this79 = (0 & 255);
HXDLIN(  38)														if ((this79 == 0)) {
HXLINE(  38)															b24 = ((Float)0.);
            														}
            														else {
HXLINE(  38)															b24 = (( (Float)(this79) ) / ( (Float)(255) ));
            														}
HXDLIN(  38)														Float a34 = (a14 * (( (Float)(1) ) - a24));
HXDLIN(  38)														int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN(  38)														int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN(  38)														int b16 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a34) + (b24 * a24))));
HXDLIN(  38)														int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN(  38)														int blended4 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b16);
HXDLIN(  38)														{
HXLINE(  38)															int _hx_tmp17;
HXDLIN(  38)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  38)																_hx_tmp17 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            															}
            															else {
HXLINE(  38)																_hx_tmp17 = blended4;
            															}
HXDLIN(  38)															::iterMagic::Iimg_obj::set(this47->image,location4,_hx_tmp17);
            														}
            													}
            													else {
HXLINE(  38)														::Dynamic this80 = this47->image;
HXDLIN(  38)														int index10;
HXDLIN(  38)														if (this47->useVirtualPos) {
HXLINE(  38)															index10 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - this47->virtualY) * ( (Float)(this47->width) )) + x8) - this47->virtualX));
            														}
            														else {
HXLINE(  38)															index10 = ::Std_obj::_hx_int(( (Float)(((y9 * this47->width) + x8)) ));
            														}
HXDLIN(  38)														int _hx_tmp18;
HXDLIN(  38)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  38)															_hx_tmp18 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            														}
            														else {
HXLINE(  38)															_hx_tmp18 = c8;
            														}
HXDLIN(  38)														::iterMagic::Iimg_obj::set(this80,index10,_hx_tmp18);
            													}
            												}
HXLINE(  73)												found1 = true;
            											}
            											else {
HXLINE(  38)												if (found1) {
HXLINE(  38)													goto _hx_goto_37;
            												}
            											}
            										}
            									}
            									_hx_goto_37:;
            								}
            							}
            						}
HXDLIN(  38)						if ((hasHit1 == true)) {
HXLINE(  38)							 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax1,ay1,bx2,by2,cx2,cy2,true);
HXDLIN(  38)							if (hasUndo1) {
HXLINE(  38)								v5->undoImage = undoImage3;
HXDLIN(  38)								v5->undoX = xIter31->start;
HXDLIN(  38)								v5->undoY = yIter31->start;
            							}
            						}
            					}
            				}
            			}
            		}
            		else {
HXLINE(  40)			{
HXLINE(  40)				 ::pi_xy::ImageStruct this81 = temp;
HXDLIN(  40)				Float ax2 = this->rx;
HXDLIN(  40)				Float ay2 = this->ry;
HXDLIN(  40)				Float rx = this->rx;
HXDLIN(  40)				Float ry = this->ry;
HXDLIN(  40)				int color1 = this->strokeColor;
HXDLIN(  40)				bool hasHit2 = false;
HXDLIN(  40)				Float currAngle = endAngle;
HXDLIN(  40)				Float bx3 = ((rx * ::Math_obj::cos(currAngle)) + ax2);
HXDLIN(  40)				Float by3 = ((ry * ::Math_obj::sin(currAngle)) + ay2);
HXLINE( 424)				currAngle = (endAngle + (((( (Float)(2) ) * ::Math_obj::PI) - this->sweepAngle) + ((Float)0.01)));
HXLINE(  40)				Float cx3 = ((rx * ::Math_obj::cos(currAngle)) + ax2);
HXDLIN(  40)				Float cy3 = ((ry * ::Math_obj::sin(currAngle)) + ay2);
HXDLIN(  40)				{
HXLINE(  40)					bool hasUndo2 = false;
HXDLIN(  40)					{
HXLINE(  40)						Float bx4 = bx3;
HXDLIN(  40)						Float by4 = by3;
HXDLIN(  40)						Float cx4 = cx3;
HXDLIN(  40)						Float cy4 = cy3;
HXDLIN(  40)						bool adjustWinding2 = (((((ax2 * by4) - (bx4 * ay2)) + ((bx4 * cy4) - (cx4 * by4))) + ((cx4 * ay2) - (ax2 * cy4))) > 0);
HXDLIN(  40)						if (!(adjustWinding2)) {
HXLINE(  40)							Float bx_2 = bx4;
HXDLIN(  40)							Float by_2 = by4;
HXLINE(  25)							bx4 = cx4;
HXLINE(  26)							by4 = cy4;
HXLINE(  27)							cx4 = bx_2;
HXLINE(  28)							cy4 = by_2;
            						}
HXLINE(  40)						{
HXLINE(  40)							Float s02 = ((ay2 * cx4) - (ax2 * cy4));
HXDLIN(  40)							Float sx2 = (cy4 - ay2);
HXDLIN(  40)							Float sy2 = (ax2 - cx4);
HXDLIN(  40)							Float t02 = ((ax2 * by4) - (ay2 * bx4));
HXDLIN(  40)							Float tx2 = (ay2 - by4);
HXDLIN(  40)							Float ty2 = (bx4 - ax2);
HXDLIN(  40)							Float A2 = ((((-(by4) * cx4) + (ay2 * (-(bx4) + cx4))) + (ax2 * (by4 - cy4))) + (bx4 * cy4));
HXDLIN(  40)							 ::pi_xy::iter::IntIterStart xIter32;
HXDLIN(  40)							if ((ax2 > bx4)) {
HXLINE(  40)								if ((ax2 > cx4)) {
HXLINE(  40)									int min8;
HXDLIN(  40)									if ((bx4 > cx4)) {
HXLINE(  40)										min8 = ::Math_obj::floor(cx4);
            									}
            									else {
HXLINE(  40)										min8 = ::Math_obj::floor(bx4);
            									}
HXDLIN(  40)									int ii_min18 = min8;
HXDLIN(  40)									int ii_max18 = ::Math_obj::ceil(ax2);
HXDLIN(  40)									xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            								}
            								else {
HXLINE(  40)									int ii_min19 = ::Math_obj::floor(bx4);
HXDLIN(  40)									int ii_max19 = ::Math_obj::ceil(cx4);
HXDLIN(  40)									xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            								}
            							}
            							else {
HXLINE(  40)								if ((bx4 > cx4)) {
HXLINE(  40)									int min9;
HXDLIN(  40)									if ((ax2 > cx4)) {
HXLINE(  40)										min9 = ::Math_obj::floor(cx4);
            									}
            									else {
HXLINE(  40)										min9 = ::Math_obj::ceil(ax2);
            									}
HXDLIN(  40)									int ii_min20 = min9;
HXDLIN(  40)									int ii_max20 = ::Math_obj::ceil(bx4);
HXDLIN(  40)									xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            								}
            								else {
HXLINE(  40)									int ii_min21 = ::Math_obj::floor(ax2);
HXDLIN(  40)									int ii_max21 = ::Math_obj::ceil(cx4);
HXDLIN(  40)									xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            								}
            							}
HXDLIN(  40)							 ::pi_xy::iter::IntIterStart yIter32;
HXDLIN(  40)							if ((ay2 > by4)) {
HXLINE(  40)								if ((ay2 > cy4)) {
HXLINE(  40)									int min10;
HXDLIN(  40)									if ((by4 > cy4)) {
HXLINE(  40)										min10 = ::Math_obj::floor(cy4);
            									}
            									else {
HXLINE(  40)										min10 = ::Math_obj::floor(by4);
            									}
HXDLIN(  40)									int ii_min22 = min10;
HXDLIN(  40)									int ii_max22 = ::Math_obj::ceil(ay2);
HXDLIN(  40)									yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            								}
            								else {
HXLINE(  40)									int ii_min23 = ::Math_obj::floor(by4);
HXDLIN(  40)									int ii_max23 = ::Math_obj::ceil(cy4);
HXDLIN(  40)									yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            								}
            							}
            							else {
HXLINE(  40)								if ((by4 > cy4)) {
HXLINE(  40)									int min11;
HXDLIN(  40)									if ((ay2 > cy4)) {
HXLINE(  40)										min11 = ::Math_obj::floor(cy4);
            									}
            									else {
HXLINE(  40)										min11 = ::Math_obj::ceil(ay2);
            									}
HXDLIN(  40)									int ii_min24 = min11;
HXDLIN(  40)									int ii_max24 = ::Math_obj::ceil(by4);
HXDLIN(  40)									yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            								}
            								else {
HXLINE(  40)									int ii_min25 = ::Math_obj::floor(ay2);
HXDLIN(  40)									int ii_max25 = ::Math_obj::ceil(cy4);
HXDLIN(  40)									yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            								}
            							}
HXDLIN(  40)							 ::pi_xy::ImageStruct undoImage6 = null();
HXDLIN(  40)							if (hasUndo2) {
HXLINE(  40)								int width2 = ((xIter32->max - xIter32->start) + 1);
HXDLIN(  40)								int height2 = ((yIter32->max - yIter32->start) + 1);
HXDLIN(  40)								 ::Dynamic imageType2 = null();
HXDLIN(  40)								 ::pi_xy::ImageStruct this82 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  40)								if (::hx::IsNull( imageType2 )) {
HXLINE(  54)									imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE(  40)								::Dynamic undoImage7;
HXDLIN(  40)								switch((int)(( (int)(imageType2) ))){
            									case (int)0: {
HXLINE(  40)										 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  40)										 ::iterMagic::BytesImg b17 = byt2;
HXDLIN(  40)										{
HXLINE(  40)											b17->width = width2;
HXDLIN(  40)											b17->height = height2;
HXDLIN(  40)											b17->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  40)											b17->data = ::haxe::io::Bytes_obj::alloc((b17->length * 4));
HXDLIN(  40)											{
HXLINE(  40)												int len4 = b17->length;
HXDLIN(  40)												int w2 = 0;
HXDLIN(  40)												{
HXLINE(  40)													int _g40 = 0;
HXDLIN(  40)													int _g41 = b17->height;
HXDLIN(  40)													while((_g40 < _g41)){
HXLINE(  40)														_g40 = (_g40 + 1);
HXDLIN(  40)														int y10 = (_g40 - 1);
HXDLIN(  40)														{
HXLINE(  40)															int _g42 = 0;
HXDLIN(  40)															int _g43 = b17->width;
HXDLIN(  40)															while((_g42 < _g43)){
HXLINE(  40)																_g42 = (_g42 + 1);
HXDLIN(  40)																int x9 = (_g42 - 1);
HXDLIN(  40)																{
HXLINE(  40)																	w2 = (w2 + 1);
HXDLIN(  40)																	b17->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  40)																{
HXLINE(  40)																	w2 = (w2 + 1);
HXDLIN(  40)																	b17->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  40)																{
HXLINE(  40)																	w2 = (w2 + 1);
HXDLIN(  40)																	b17->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  40)																{
HXLINE(  40)																	w2 = (w2 + 1);
HXDLIN(  40)																	b17->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  40)										undoImage7 = b17;
            									}
            									break;
            									case (int)1: {
HXLINE(  40)										 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  40)										 ::iterMagic::ArrIntImg a10 = arrI2;
HXDLIN(  40)										{
HXLINE(  40)											a10->width = width2;
HXDLIN(  40)											a10->height = height2;
HXDLIN(  40)											a10->data = ::Array_obj< int >::__new(0);
HXDLIN(  40)											a10->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  40)											{
HXLINE(  40)												int _g44 = 0;
HXDLIN(  40)												int _g45 = a10->length;
HXDLIN(  40)												while((_g44 < _g45)){
HXLINE(  40)													_g44 = (_g44 + 1);
HXDLIN(  40)													int i14 = (_g44 - 1);
HXDLIN(  40)													a10->data[i14] = 0;
            												}
            											}
            										}
HXDLIN(  40)										undoImage7 = a10;
            									}
            									break;
            									case (int)2: {
HXLINE(  40)										 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  40)										 ::iterMagic::U32ArrImg b18 = u32a2;
HXDLIN(  40)										{
HXLINE(  40)											b18->width = width2;
HXDLIN(  40)											b18->height = height2;
HXDLIN(  40)											b18->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  40)											int size2 = (b18->length * 4);
HXDLIN(  40)											b18->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN(  40)											{
HXLINE(  40)												int _g46 = 0;
HXDLIN(  40)												int _g47 = b18->length;
HXDLIN(  40)												while((_g46 < _g47)){
HXLINE(  40)													_g46 = (_g46 + 1);
HXDLIN(  40)													int i15 = (_g46 - 1);
HXDLIN(  40)													{
HXLINE(  40)														 ::haxe::io::ArrayBufferViewImpl this83 = b18->data;
HXDLIN(  40)														bool undoImage8;
HXDLIN(  40)														if ((i15 >= 0)) {
HXLINE(  40)															undoImage8 = (i15 < (this83->byteLength >> 2));
            														}
            														else {
HXLINE(  40)															undoImage8 = false;
            														}
HXDLIN(  40)														if (undoImage8) {
HXLINE(  40)															 ::haxe::io::Bytes _this2 = this83->bytes;
HXDLIN(  40)															int pos2 = ((i15 << 2) + this83->byteOffset);
HXDLIN(  40)															_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN(  40)															_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN(  40)															_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN(  40)															_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN(  40)										undoImage7 = b18;
            									}
            									break;
            									case (int)3: {
HXLINE(  40)										 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  40)										 ::iterMagic::VecIntImg v6 = vec2;
HXDLIN(  40)										{
HXLINE(  40)											v6->width = width2;
HXDLIN(  40)											v6->height = height2;
HXDLIN(  40)											v6->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  40)											v6->data = ::Array_obj< int >::__new(v6->length);
HXDLIN(  40)											{
HXLINE(  40)												int _g48 = 0;
HXDLIN(  40)												int _g49 = v6->length;
HXDLIN(  40)												while((_g48 < _g49)){
HXLINE(  40)													_g48 = (_g48 + 1);
HXDLIN(  40)													int i16 = (_g48 - 1);
HXDLIN(  40)													v6->data->__unsafe_set(i16,0);
            												}
            											}
            										}
HXDLIN(  40)										undoImage7 = v6;
            									}
            									break;
            									case (int)4: {
HXLINE(  40)										 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  40)										 ::iterMagic::StackIntImg b19 = sInt2;
HXDLIN(  40)										{
HXLINE(  40)											b19->width = width2;
HXDLIN(  40)											b19->height = height2;
HXDLIN(  40)											b19->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  40)											b19->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  40)											{
HXLINE(  40)												int len5 = b19->length;
HXDLIN(  40)												 ::haxe::ds::GenericStack_Int d3 = b19->data;
HXDLIN(  40)												if (::hx::IsNull( d3->head )) {
HXLINE(  40)													int _g50 = 0;
HXDLIN(  40)													int _g51 = len5;
HXDLIN(  40)													while((_g50 < _g51)){
HXLINE(  40)														_g50 = (_g50 + 1);
HXDLIN(  40)														int i17 = (_g50 - 1);
HXDLIN(  40)														d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            													}
            												}
            												else {
HXLINE(  40)													int _g52 = 0;
HXDLIN(  40)													int _g53 = len5;
HXDLIN(  40)													while((_g52 < _g53)){
HXLINE(  40)														_g52 = (_g52 + 1);
HXDLIN(  40)														int i18 = (_g52 - 1);
HXDLIN(  40)														{
HXLINE(  40)															 ::haxe::ds::GenericCell_Int l2 = b19->data->head;
HXDLIN(  40)															 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN(  40)															{
HXLINE(  40)																int _g54 = 0;
HXDLIN(  40)																int _g55 = i18;
HXDLIN(  40)																while((_g54 < _g55)){
HXLINE(  40)																	_g54 = (_g54 + 1);
HXDLIN(  40)																	int i19 = (_g54 - 1);
HXLINE( 345)																	prev2 = l2;
HXLINE( 346)																	l2 = l2->next;
            																}
            															}
HXLINE(  40)															if (::hx::IsNull( prev2 )) {
HXLINE(  40)																b19->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  40)																l2 = null();
            															}
            															else {
HXLINE(  40)																prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  40)																l2 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  40)										undoImage7 = b19;
            									}
            									break;
            								}
HXDLIN(  40)								this82->image = undoImage7;
HXDLIN(  40)								this82->width = width2;
HXDLIN(  40)								this82->height = height2;
HXDLIN(  40)								this82->imageType = ( (int)(imageType2) );
HXDLIN(  40)								undoImage6 = this82;
HXDLIN(  40)								{
HXLINE(  40)									int rectLeft2 = xIter32->start;
HXDLIN(  40)									int rectTop2 = yIter32->start;
HXDLIN(  40)									int rectRight2 = xIter32->max;
HXDLIN(  40)									bool forceClear2 = false;
HXDLIN(  40)									{
HXLINE(  40)										int _g56 = rectTop2;
HXDLIN(  40)										int _g57 = yIter32->max;
HXDLIN(  40)										while((_g56 < _g57)){
HXLINE(  40)											_g56 = (_g56 + 1);
HXDLIN(  40)											int dy2 = (_g56 - 1);
HXDLIN(  40)											{
HXLINE(  40)												int _g58 = rectLeft2;
HXDLIN(  40)												int _g59 = rectRight2;
HXDLIN(  40)												while((_g58 < _g59)){
HXLINE(  40)													_g58 = (_g58 + 1);
HXDLIN(  40)													int dx2 = (_g58 - 1);
HXDLIN(  40)													::Dynamic this84 = this81->image;
HXDLIN(  40)													int index11;
HXDLIN(  40)													if (this81->useVirtualPos) {
HXLINE(  40)														index11 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this81->virtualY) * ( (Float)(this81->width) )) + dx2) - this81->virtualX));
            													}
            													else {
HXLINE(  40)														index11 = ::Std_obj::_hx_int(( (Float)(((dy2 * this81->width) + dx2)) ));
            													}
HXDLIN(  40)													int c9 = ::iterMagic::Iimg_obj::get(this84,index11);
HXDLIN(  40)													int col2;
HXDLIN(  40)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  40)														col2 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            													}
            													else {
HXLINE(  40)														col2 = c9;
            													}
HXDLIN(  40)													bool _hx_tmp19;
HXDLIN(  40)													if (this81->useMask) {
HXLINE(  40)														_hx_tmp19 = ::hx::IsNotNull( this81->mask );
            													}
            													else {
HXLINE(  40)														_hx_tmp19 = false;
            													}
HXDLIN(  40)													if (_hx_tmp19) {
HXLINE(  40)														 ::pi_xy::ImageStruct this85 = this81->mask;
HXDLIN(  40)														::Dynamic this86 = this85->image;
HXDLIN(  40)														int index12;
HXDLIN(  40)														if (this85->useVirtualPos) {
HXLINE(  40)															index12 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this85->virtualY) * ( (Float)(this85->width) )) + dx2) - this85->virtualX));
            														}
            														else {
HXLINE(  40)															index12 = ::Std_obj::_hx_int(( (Float)(((dy2 * this85->width) + dx2)) ));
            														}
HXDLIN(  40)														int c10 = ::iterMagic::Iimg_obj::get(this86,index12);
HXDLIN(  40)														int v7;
HXDLIN(  40)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  40)															v7 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            														}
            														else {
HXLINE(  40)															v7 = c10;
            														}
HXDLIN(  40)														int maskPixel2 = v7;
HXDLIN(  40)														int this87 = col2;
HXDLIN(  40)														if ((maskPixel2 == 0)) {
HXLINE(  40)															col2 = this87;
            														}
            														else {
HXLINE(  40)															Float m02;
HXDLIN(  40)															int this88 = ((maskPixel2 >> 24) & 255);
HXDLIN(  40)															if ((this88 == 0)) {
HXLINE(  40)																m02 = ((Float)0.);
            															}
            															else {
HXLINE(  40)																m02 = (( (Float)(this88) ) / ( (Float)(255) ));
            															}
HXDLIN(  40)															Float m12;
HXDLIN(  40)															int this89 = ((maskPixel2 >> 16) & 255);
HXDLIN(  40)															if ((this89 == 0)) {
HXLINE(  40)																m12 = ((Float)0.);
            															}
            															else {
HXLINE(  40)																m12 = (( (Float)(this89) ) / ( (Float)(255) ));
            															}
HXDLIN(  40)															Float m22;
HXDLIN(  40)															int this90 = ((maskPixel2 >> 8) & 255);
HXDLIN(  40)															if ((this90 == 0)) {
HXLINE(  40)																m22 = ((Float)0.);
            															}
            															else {
HXLINE(  40)																m22 = (( (Float)(this90) ) / ( (Float)(255) ));
            															}
HXDLIN(  40)															Float m32;
HXDLIN(  40)															int this91 = (maskPixel2 & 255);
HXDLIN(  40)															if ((this91 == 0)) {
HXLINE(  40)																m32 = ((Float)0.);
            															}
            															else {
HXLINE(  40)																m32 = (( (Float)(this91) ) / ( (Float)(255) ));
            															}
HXDLIN(  40)															int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this87 >> 24) & 255)) )));
HXDLIN(  40)															int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this87 >> 16) & 255)) )));
HXDLIN(  40)															int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this87 >> 8) & 255)) )));
HXDLIN(  40)															int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this87 & 255)) )));
HXDLIN(  40)															col2 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  40)													if ((col2 != 0)) {
HXLINE(  40)														int x10 = (dx2 - rectLeft2);
HXDLIN(  40)														int y11 = (dy2 - rectTop2);
HXDLIN(  40)														int c11 = col2;
HXDLIN(  40)														bool _hx_tmp20;
HXDLIN(  40)														if ((((c11 >> 24) & 255) < 254)) {
HXLINE(  40)															_hx_tmp20 = undoImage6->transparent;
            														}
            														else {
HXLINE(  40)															_hx_tmp20 = false;
            														}
HXDLIN(  40)														if (_hx_tmp20) {
HXLINE(  40)															int location5;
HXDLIN(  40)															if (undoImage6->useVirtualPos) {
HXLINE(  40)																location5 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x10) - undoImage6->virtualX));
            															}
            															else {
HXLINE(  40)																location5 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage6->width) + x10)) ));
            															}
HXDLIN(  40)															int this92 = ::iterMagic::Iimg_obj::get(undoImage6->image,location5);
HXDLIN(  40)															int this93;
HXDLIN(  40)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  40)																this93 = ((((((this92 >> 24) & 255) << 24) | ((this92 & 255) << 16)) | (((this92 >> 8) & 255) << 8)) | ((this92 >> 16) & 255));
            															}
            															else {
HXLINE(  40)																this93 = this92;
            															}
HXDLIN(  40)															Float a15;
HXDLIN(  40)															int this94 = ((this93 >> 24) & 255);
HXDLIN(  40)															if ((this94 == 0)) {
HXLINE(  40)																a15 = ((Float)0.);
            															}
            															else {
HXLINE(  40)																a15 = (( (Float)(this94) ) / ( (Float)(255) ));
            															}
HXDLIN(  40)															Float r15;
HXDLIN(  40)															int this95 = ((this93 >> 16) & 255);
HXDLIN(  40)															if ((this95 == 0)) {
HXLINE(  40)																r15 = ((Float)0.);
            															}
            															else {
HXLINE(  40)																r15 = (( (Float)(this95) ) / ( (Float)(255) ));
            															}
HXDLIN(  40)															Float g15;
HXDLIN(  40)															int this96 = ((this93 >> 8) & 255);
HXDLIN(  40)															if ((this96 == 0)) {
HXLINE(  40)																g15 = ((Float)0.);
            															}
            															else {
HXLINE(  40)																g15 = (( (Float)(this96) ) / ( (Float)(255) ));
            															}
HXDLIN(  40)															Float b110;
HXDLIN(  40)															int this97 = (this93 & 255);
HXDLIN(  40)															if ((this97 == 0)) {
HXLINE(  40)																b110 = ((Float)0.);
            															}
            															else {
HXLINE(  40)																b110 = (( (Float)(this97) ) / ( (Float)(255) ));
            															}
HXDLIN(  40)															Float a25;
HXDLIN(  40)															int this98 = ((col2 >> 24) & 255);
HXDLIN(  40)															if ((this98 == 0)) {
HXLINE(  40)																a25 = ((Float)0.);
            															}
            															else {
HXLINE(  40)																a25 = (( (Float)(this98) ) / ( (Float)(255) ));
            															}
HXDLIN(  40)															Float r25;
HXDLIN(  40)															int this99 = ((col2 >> 16) & 255);
HXDLIN(  40)															if ((this99 == 0)) {
HXLINE(  40)																r25 = ((Float)0.);
            															}
            															else {
HXLINE(  40)																r25 = (( (Float)(this99) ) / ( (Float)(255) ));
            															}
HXDLIN(  40)															Float g25;
HXDLIN(  40)															int this100 = ((col2 >> 8) & 255);
HXDLIN(  40)															if ((this100 == 0)) {
HXLINE(  40)																g25 = ((Float)0.);
            															}
            															else {
HXLINE(  40)																g25 = (( (Float)(this100) ) / ( (Float)(255) ));
            															}
HXDLIN(  40)															Float b25;
HXDLIN(  40)															int this101 = (col2 & 255);
HXDLIN(  40)															if ((this101 == 0)) {
HXLINE(  40)																b25 = ((Float)0.);
            															}
            															else {
HXLINE(  40)																b25 = (( (Float)(this101) ) / ( (Float)(255) ));
            															}
HXDLIN(  40)															Float a35 = (a15 * (( (Float)(1) ) - a25));
HXDLIN(  40)															int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN(  40)															int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN(  40)															int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a35) + (b25 * a25))));
HXDLIN(  40)															int a16 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN(  40)															int blended5 = ((((a16 << 24) | (r7 << 16)) | (g7 << 8)) | b20);
HXDLIN(  40)															{
HXLINE(  40)																int _hx_tmp21;
HXDLIN(  40)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  40)																	_hx_tmp21 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            																}
            																else {
HXLINE(  40)																	_hx_tmp21 = blended5;
            																}
HXDLIN(  40)																::iterMagic::Iimg_obj::set(undoImage6->image,location5,_hx_tmp21);
            															}
            														}
            														else {
HXLINE(  40)															::Dynamic this102 = undoImage6->image;
HXDLIN(  40)															int index13;
HXDLIN(  40)															if (undoImage6->useVirtualPos) {
HXLINE(  40)																index13 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x10) - undoImage6->virtualX));
            															}
            															else {
HXLINE(  40)																index13 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage6->width) + x10)) ));
            															}
HXDLIN(  40)															int _hx_tmp22;
HXDLIN(  40)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  40)																_hx_tmp22 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            															}
            															else {
HXLINE(  40)																_hx_tmp22 = c11;
            															}
HXDLIN(  40)															::iterMagic::Iimg_obj::set(this102,index13,_hx_tmp22);
            														}
            													}
            													else {
HXLINE(  40)														if (forceClear2) {
HXLINE(  40)															::Dynamic this103 = undoImage6->image;
HXDLIN(  40)															int x11 = (dx2 - rectLeft2);
HXDLIN(  40)															int y12 = (dy2 - rectTop2);
HXDLIN(  40)															int index14;
HXDLIN(  40)															if (undoImage6->useVirtualPos) {
HXLINE(  40)																index14 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x11) - undoImage6->virtualX));
            															}
            															else {
HXLINE(  40)																index14 = ::Std_obj::_hx_int(( (Float)(((y12 * undoImage6->width) + x11)) ));
            															}
HXDLIN(  40)															::iterMagic::Iimg_obj::set(this103,index14,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  40)							bool found2 = false;
HXDLIN(  40)							Float s2 = ((Float)0.);
HXDLIN(  40)							Float t2 = ((Float)0.);
HXDLIN(  40)							Float sxx2 = ((Float)0.);
HXDLIN(  40)							Float txx2 = ((Float)0.);
HXDLIN(  40)							{
HXLINE(  40)								int _g_min4 = xIter32->start;
HXDLIN(  40)								int _g_max4 = xIter32->max;
HXDLIN(  40)								while((_g_min4 < _g_max4)){
HXLINE(  40)									_g_min4 = (_g_min4 + 1);
HXDLIN(  40)									int x12 = (_g_min4 - 1);
HXLINE(  60)									sxx2 = (sx2 * ( (Float)(x12) ));
HXLINE(  61)									txx2 = (tx2 * ( (Float)(x12) ));
HXLINE(  62)									found2 = false;
HXLINE(  40)									{
HXLINE(  40)										int _g_min5 = yIter32->start;
HXDLIN(  40)										int _g_max5 = yIter32->max;
HXDLIN(  40)										while((_g_min5 < _g_max5)){
HXLINE(  40)											_g_min5 = (_g_min5 + 1);
HXDLIN(  40)											int y13 = (_g_min5 - 1);
HXLINE(  64)											s2 = ((s02 + sxx2) + (sy2 * ( (Float)(y13) )));
HXLINE(  65)											t2 = ((t02 + txx2) + (ty2 * ( (Float)(y13) )));
HXLINE(  40)											bool _hx_tmp23;
HXDLIN(  40)											if (!((s2 <= 0))) {
HXLINE(  40)												_hx_tmp23 = (t2 <= 0);
            											}
            											else {
HXLINE(  40)												_hx_tmp23 = true;
            											}
HXDLIN(  40)											if (_hx_tmp23) {
HXLINE(  40)												if (found2) {
HXLINE(  40)													goto _hx_goto_49;
            												}
            											}
            											else {
HXLINE(  40)												if (((s2 + t2) < A2)) {
HXLINE(  40)													{
HXLINE(  40)														int c12 = color1;
HXDLIN(  40)														bool _hx_tmp24;
HXDLIN(  40)														if ((((c12 >> 24) & 255) < 254)) {
HXLINE(  40)															_hx_tmp24 = this81->transparent;
            														}
            														else {
HXLINE(  40)															_hx_tmp24 = false;
            														}
HXDLIN(  40)														if (_hx_tmp24) {
HXLINE(  40)															int location6;
HXDLIN(  40)															if (this81->useVirtualPos) {
HXLINE(  40)																location6 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - this81->virtualY) * ( (Float)(this81->width) )) + x12) - this81->virtualX));
            															}
            															else {
HXLINE(  40)																location6 = ::Std_obj::_hx_int(( (Float)(((y13 * this81->width) + x12)) ));
            															}
HXDLIN(  40)															int this104 = ::iterMagic::Iimg_obj::get(this81->image,location6);
HXDLIN(  40)															int this105;
HXDLIN(  40)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  40)																this105 = ((((((this104 >> 24) & 255) << 24) | ((this104 & 255) << 16)) | (((this104 >> 8) & 255) << 8)) | ((this104 >> 16) & 255));
            															}
            															else {
HXLINE(  40)																this105 = this104;
            															}
HXDLIN(  40)															Float a17;
HXDLIN(  40)															int this106 = ((this105 >> 24) & 255);
HXDLIN(  40)															if ((this106 == 0)) {
HXLINE(  40)																a17 = ((Float)0.);
            															}
            															else {
HXLINE(  40)																a17 = (( (Float)(this106) ) / ( (Float)(255) ));
            															}
HXDLIN(  40)															Float r16;
HXDLIN(  40)															int this107 = ((this105 >> 16) & 255);
HXDLIN(  40)															if ((this107 == 0)) {
HXLINE(  40)																r16 = ((Float)0.);
            															}
            															else {
HXLINE(  40)																r16 = (( (Float)(this107) ) / ( (Float)(255) ));
            															}
HXDLIN(  40)															Float g16;
HXDLIN(  40)															int this108 = ((this105 >> 8) & 255);
HXDLIN(  40)															if ((this108 == 0)) {
HXLINE(  40)																g16 = ((Float)0.);
            															}
            															else {
HXLINE(  40)																g16 = (( (Float)(this108) ) / ( (Float)(255) ));
            															}
HXDLIN(  40)															Float b111;
HXDLIN(  40)															int this109 = (this105 & 255);
HXDLIN(  40)															if ((this109 == 0)) {
HXLINE(  40)																b111 = ((Float)0.);
            															}
            															else {
HXLINE(  40)																b111 = (( (Float)(this109) ) / ( (Float)(255) ));
            															}
HXDLIN(  40)															Float a26;
HXDLIN(  40)															int this110 = ((color1 >> 24) & 255);
HXDLIN(  40)															if ((this110 == 0)) {
HXLINE(  40)																a26 = ((Float)0.);
            															}
            															else {
HXLINE(  40)																a26 = (( (Float)(this110) ) / ( (Float)(255) ));
            															}
HXDLIN(  40)															Float r26;
HXDLIN(  40)															int this111 = ((color1 >> 16) & 255);
HXDLIN(  40)															if ((this111 == 0)) {
HXLINE(  40)																r26 = ((Float)0.);
            															}
            															else {
HXLINE(  40)																r26 = (( (Float)(this111) ) / ( (Float)(255) ));
            															}
HXDLIN(  40)															Float g26;
HXDLIN(  40)															int this112 = ((color1 >> 8) & 255);
HXDLIN(  40)															if ((this112 == 0)) {
HXLINE(  40)																g26 = ((Float)0.);
            															}
            															else {
HXLINE(  40)																g26 = (( (Float)(this112) ) / ( (Float)(255) ));
            															}
HXDLIN(  40)															Float b26;
HXDLIN(  40)															int this113 = (color1 & 255);
HXDLIN(  40)															if ((this113 == 0)) {
HXLINE(  40)																b26 = ((Float)0.);
            															}
            															else {
HXLINE(  40)																b26 = (( (Float)(this113) ) / ( (Float)(255) ));
            															}
HXDLIN(  40)															Float a36 = (a17 * (( (Float)(1) ) - a26));
HXDLIN(  40)															int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN(  40)															int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN(  40)															int b27 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a36) + (b26 * a26))));
HXDLIN(  40)															int a18 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN(  40)															int blended6 = ((((a18 << 24) | (r8 << 16)) | (g8 << 8)) | b27);
HXDLIN(  40)															{
HXLINE(  40)																int _hx_tmp25;
HXDLIN(  40)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  40)																	_hx_tmp25 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            																}
            																else {
HXLINE(  40)																	_hx_tmp25 = blended6;
            																}
HXDLIN(  40)																::iterMagic::Iimg_obj::set(this81->image,location6,_hx_tmp25);
            															}
            														}
            														else {
HXLINE(  40)															::Dynamic this114 = this81->image;
HXDLIN(  40)															int index15;
HXDLIN(  40)															if (this81->useVirtualPos) {
HXLINE(  40)																index15 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - this81->virtualY) * ( (Float)(this81->width) )) + x12) - this81->virtualX));
            															}
            															else {
HXLINE(  40)																index15 = ::Std_obj::_hx_int(( (Float)(((y13 * this81->width) + x12)) ));
            															}
HXDLIN(  40)															int _hx_tmp26;
HXDLIN(  40)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  40)																_hx_tmp26 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            															}
            															else {
HXLINE(  40)																_hx_tmp26 = c12;
            															}
HXDLIN(  40)															::iterMagic::Iimg_obj::set(this114,index15,_hx_tmp26);
            														}
            													}
HXLINE(  73)													found2 = true;
            												}
            												else {
HXLINE(  40)													if (found2) {
HXLINE(  40)														goto _hx_goto_49;
            													}
            												}
            											}
            										}
            										_hx_goto_49:;
            									}
            								}
            							}
HXDLIN(  40)							if ((hasHit2 == true)) {
HXLINE(  40)								 ::pi_xy::algo::HitTri v8 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax2,ay2,bx4,by4,cx4,cy4,true);
HXDLIN(  40)								if (hasUndo2) {
HXLINE(  40)									v8->undoImage = undoImage6;
HXDLIN(  40)									v8->undoX = xIter32->start;
HXDLIN(  40)									v8->undoY = yIter32->start;
            								}
            							}
            						}
            					}
            				}
            			}
HXLINE(  41)			{
HXLINE(  41)				 ::pi_xy::ImageStruct this115 = temp;
HXDLIN(  41)				Float ax3 = this->rx;
HXDLIN(  41)				Float ay3 = this->ry;
HXDLIN(  41)				Float rx1 = (this->rx - this->strokeWidth);
HXDLIN(  41)				Float ry1 = (this->ry - this->strokeWidth);
HXDLIN(  41)				int color2 = this->fill;
HXDLIN(  41)				bool hasHit3 = false;
HXDLIN(  41)				Float currAngle1 = endAngle;
HXDLIN(  41)				Float bx5 = ((rx1 * ::Math_obj::cos(currAngle1)) + ax3);
HXDLIN(  41)				Float by5 = ((ry1 * ::Math_obj::sin(currAngle1)) + ay3);
HXLINE( 424)				currAngle1 = (endAngle + (((( (Float)(2) ) * ::Math_obj::PI) - this->sweepAngle) + ((Float)0.01)));
HXLINE(  41)				Float cx5 = ((rx1 * ::Math_obj::cos(currAngle1)) + ax3);
HXDLIN(  41)				Float cy5 = ((ry1 * ::Math_obj::sin(currAngle1)) + ay3);
HXDLIN(  41)				{
HXLINE(  41)					bool hasUndo3 = false;
HXDLIN(  41)					{
HXLINE(  41)						Float bx6 = bx5;
HXDLIN(  41)						Float by6 = by5;
HXDLIN(  41)						Float cx6 = cx5;
HXDLIN(  41)						Float cy6 = cy5;
HXDLIN(  41)						bool adjustWinding3 = (((((ax3 * by6) - (bx6 * ay3)) + ((bx6 * cy6) - (cx6 * by6))) + ((cx6 * ay3) - (ax3 * cy6))) > 0);
HXDLIN(  41)						if (!(adjustWinding3)) {
HXLINE(  41)							Float bx_3 = bx6;
HXDLIN(  41)							Float by_3 = by6;
HXLINE(  25)							bx6 = cx6;
HXLINE(  26)							by6 = cy6;
HXLINE(  27)							cx6 = bx_3;
HXLINE(  28)							cy6 = by_3;
            						}
HXLINE(  41)						{
HXLINE(  41)							Float s03 = ((ay3 * cx6) - (ax3 * cy6));
HXDLIN(  41)							Float sx3 = (cy6 - ay3);
HXDLIN(  41)							Float sy3 = (ax3 - cx6);
HXDLIN(  41)							Float t03 = ((ax3 * by6) - (ay3 * bx6));
HXDLIN(  41)							Float tx3 = (ay3 - by6);
HXDLIN(  41)							Float ty3 = (bx6 - ax3);
HXDLIN(  41)							Float A3 = ((((-(by6) * cx6) + (ay3 * (-(bx6) + cx6))) + (ax3 * (by6 - cy6))) + (bx6 * cy6));
HXDLIN(  41)							 ::pi_xy::iter::IntIterStart xIter33;
HXDLIN(  41)							if ((ax3 > bx6)) {
HXLINE(  41)								if ((ax3 > cx6)) {
HXLINE(  41)									int min12;
HXDLIN(  41)									if ((bx6 > cx6)) {
HXLINE(  41)										min12 = ::Math_obj::floor(cx6);
            									}
            									else {
HXLINE(  41)										min12 = ::Math_obj::floor(bx6);
            									}
HXDLIN(  41)									int ii_min26 = min12;
HXDLIN(  41)									int ii_max26 = ::Math_obj::ceil(ax3);
HXDLIN(  41)									xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            								}
            								else {
HXLINE(  41)									int ii_min27 = ::Math_obj::floor(bx6);
HXDLIN(  41)									int ii_max27 = ::Math_obj::ceil(cx6);
HXDLIN(  41)									xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            								}
            							}
            							else {
HXLINE(  41)								if ((bx6 > cx6)) {
HXLINE(  41)									int min13;
HXDLIN(  41)									if ((ax3 > cx6)) {
HXLINE(  41)										min13 = ::Math_obj::floor(cx6);
            									}
            									else {
HXLINE(  41)										min13 = ::Math_obj::ceil(ax3);
            									}
HXDLIN(  41)									int ii_min28 = min13;
HXDLIN(  41)									int ii_max28 = ::Math_obj::ceil(bx6);
HXDLIN(  41)									xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            								}
            								else {
HXLINE(  41)									int ii_min29 = ::Math_obj::floor(ax3);
HXDLIN(  41)									int ii_max29 = ::Math_obj::ceil(cx6);
HXDLIN(  41)									xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            								}
            							}
HXDLIN(  41)							 ::pi_xy::iter::IntIterStart yIter33;
HXDLIN(  41)							if ((ay3 > by6)) {
HXLINE(  41)								if ((ay3 > cy6)) {
HXLINE(  41)									int min14;
HXDLIN(  41)									if ((by6 > cy6)) {
HXLINE(  41)										min14 = ::Math_obj::floor(cy6);
            									}
            									else {
HXLINE(  41)										min14 = ::Math_obj::floor(by6);
            									}
HXDLIN(  41)									int ii_min30 = min14;
HXDLIN(  41)									int ii_max30 = ::Math_obj::ceil(ay3);
HXDLIN(  41)									yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            								}
            								else {
HXLINE(  41)									int ii_min31 = ::Math_obj::floor(by6);
HXDLIN(  41)									int ii_max31 = ::Math_obj::ceil(cy6);
HXDLIN(  41)									yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            								}
            							}
            							else {
HXLINE(  41)								if ((by6 > cy6)) {
HXLINE(  41)									int min15;
HXDLIN(  41)									if ((ay3 > cy6)) {
HXLINE(  41)										min15 = ::Math_obj::floor(cy6);
            									}
            									else {
HXLINE(  41)										min15 = ::Math_obj::ceil(ay3);
            									}
HXDLIN(  41)									int ii_min32 = min15;
HXDLIN(  41)									int ii_max32 = ::Math_obj::ceil(by6);
HXDLIN(  41)									yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min32,ii_max32);
            								}
            								else {
HXLINE(  41)									int ii_min33 = ::Math_obj::floor(ay3);
HXDLIN(  41)									int ii_max33 = ::Math_obj::ceil(cy6);
HXDLIN(  41)									yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min33,ii_max33);
            								}
            							}
HXDLIN(  41)							 ::pi_xy::ImageStruct undoImage9 = null();
HXDLIN(  41)							if (hasUndo3) {
HXLINE(  41)								int width3 = ((xIter33->max - xIter33->start) + 1);
HXDLIN(  41)								int height3 = ((yIter33->max - yIter33->start) + 1);
HXDLIN(  41)								 ::Dynamic imageType3 = null();
HXDLIN(  41)								 ::pi_xy::ImageStruct this116 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  41)								if (::hx::IsNull( imageType3 )) {
HXLINE(  54)									imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE(  41)								::Dynamic undoImage10;
HXDLIN(  41)								switch((int)(( (int)(imageType3) ))){
            									case (int)0: {
HXLINE(  41)										 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  41)										 ::iterMagic::BytesImg b28 = byt3;
HXDLIN(  41)										{
HXLINE(  41)											b28->width = width3;
HXDLIN(  41)											b28->height = height3;
HXDLIN(  41)											b28->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  41)											b28->data = ::haxe::io::Bytes_obj::alloc((b28->length * 4));
HXDLIN(  41)											{
HXLINE(  41)												int len6 = b28->length;
HXDLIN(  41)												int w3 = 0;
HXDLIN(  41)												{
HXLINE(  41)													int _g60 = 0;
HXDLIN(  41)													int _g61 = b28->height;
HXDLIN(  41)													while((_g60 < _g61)){
HXLINE(  41)														_g60 = (_g60 + 1);
HXDLIN(  41)														int y14 = (_g60 - 1);
HXDLIN(  41)														{
HXLINE(  41)															int _g62 = 0;
HXDLIN(  41)															int _g63 = b28->width;
HXDLIN(  41)															while((_g62 < _g63)){
HXLINE(  41)																_g62 = (_g62 + 1);
HXDLIN(  41)																int x13 = (_g62 - 1);
HXDLIN(  41)																{
HXLINE(  41)																	w3 = (w3 + 1);
HXDLIN(  41)																	b28->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  41)																{
HXLINE(  41)																	w3 = (w3 + 1);
HXDLIN(  41)																	b28->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  41)																{
HXLINE(  41)																	w3 = (w3 + 1);
HXDLIN(  41)																	b28->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  41)																{
HXLINE(  41)																	w3 = (w3 + 1);
HXDLIN(  41)																	b28->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  41)										undoImage10 = b28;
            									}
            									break;
            									case (int)1: {
HXLINE(  41)										 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  41)										 ::iterMagic::ArrIntImg a19 = arrI3;
HXDLIN(  41)										{
HXLINE(  41)											a19->width = width3;
HXDLIN(  41)											a19->height = height3;
HXDLIN(  41)											a19->data = ::Array_obj< int >::__new(0);
HXDLIN(  41)											a19->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  41)											{
HXLINE(  41)												int _g64 = 0;
HXDLIN(  41)												int _g65 = a19->length;
HXDLIN(  41)												while((_g64 < _g65)){
HXLINE(  41)													_g64 = (_g64 + 1);
HXDLIN(  41)													int i20 = (_g64 - 1);
HXDLIN(  41)													a19->data[i20] = 0;
            												}
            											}
            										}
HXDLIN(  41)										undoImage10 = a19;
            									}
            									break;
            									case (int)2: {
HXLINE(  41)										 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  41)										 ::iterMagic::U32ArrImg b29 = u32a3;
HXDLIN(  41)										{
HXLINE(  41)											b29->width = width3;
HXDLIN(  41)											b29->height = height3;
HXDLIN(  41)											b29->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  41)											int size3 = (b29->length * 4);
HXDLIN(  41)											b29->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN(  41)											{
HXLINE(  41)												int _g66 = 0;
HXDLIN(  41)												int _g67 = b29->length;
HXDLIN(  41)												while((_g66 < _g67)){
HXLINE(  41)													_g66 = (_g66 + 1);
HXDLIN(  41)													int i21 = (_g66 - 1);
HXDLIN(  41)													{
HXLINE(  41)														 ::haxe::io::ArrayBufferViewImpl this117 = b29->data;
HXDLIN(  41)														bool undoImage11;
HXDLIN(  41)														if ((i21 >= 0)) {
HXLINE(  41)															undoImage11 = (i21 < (this117->byteLength >> 2));
            														}
            														else {
HXLINE(  41)															undoImage11 = false;
            														}
HXDLIN(  41)														if (undoImage11) {
HXLINE(  41)															 ::haxe::io::Bytes _this3 = this117->bytes;
HXDLIN(  41)															int pos3 = ((i21 << 2) + this117->byteOffset);
HXDLIN(  41)															_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN(  41)															_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN(  41)															_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN(  41)															_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN(  41)										undoImage10 = b29;
            									}
            									break;
            									case (int)3: {
HXLINE(  41)										 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  41)										 ::iterMagic::VecIntImg v9 = vec3;
HXDLIN(  41)										{
HXLINE(  41)											v9->width = width3;
HXDLIN(  41)											v9->height = height3;
HXDLIN(  41)											v9->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  41)											v9->data = ::Array_obj< int >::__new(v9->length);
HXDLIN(  41)											{
HXLINE(  41)												int _g68 = 0;
HXDLIN(  41)												int _g69 = v9->length;
HXDLIN(  41)												while((_g68 < _g69)){
HXLINE(  41)													_g68 = (_g68 + 1);
HXDLIN(  41)													int i22 = (_g68 - 1);
HXDLIN(  41)													v9->data->__unsafe_set(i22,0);
            												}
            											}
            										}
HXDLIN(  41)										undoImage10 = v9;
            									}
            									break;
            									case (int)4: {
HXLINE(  41)										 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  41)										 ::iterMagic::StackIntImg b30 = sInt3;
HXDLIN(  41)										{
HXLINE(  41)											b30->width = width3;
HXDLIN(  41)											b30->height = height3;
HXDLIN(  41)											b30->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  41)											b30->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  41)											{
HXLINE(  41)												int len7 = b30->length;
HXDLIN(  41)												 ::haxe::ds::GenericStack_Int d4 = b30->data;
HXDLIN(  41)												if (::hx::IsNull( d4->head )) {
HXLINE(  41)													int _g70 = 0;
HXDLIN(  41)													int _g71 = len7;
HXDLIN(  41)													while((_g70 < _g71)){
HXLINE(  41)														_g70 = (_g70 + 1);
HXDLIN(  41)														int i23 = (_g70 - 1);
HXDLIN(  41)														d4->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d4->head);
            													}
            												}
            												else {
HXLINE(  41)													int _g72 = 0;
HXDLIN(  41)													int _g73 = len7;
HXDLIN(  41)													while((_g72 < _g73)){
HXLINE(  41)														_g72 = (_g72 + 1);
HXDLIN(  41)														int i24 = (_g72 - 1);
HXDLIN(  41)														{
HXLINE(  41)															 ::haxe::ds::GenericCell_Int l3 = b30->data->head;
HXDLIN(  41)															 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN(  41)															{
HXLINE(  41)																int _g74 = 0;
HXDLIN(  41)																int _g75 = i24;
HXDLIN(  41)																while((_g74 < _g75)){
HXLINE(  41)																	_g74 = (_g74 + 1);
HXDLIN(  41)																	int i25 = (_g74 - 1);
HXLINE( 345)																	prev3 = l3;
HXLINE( 346)																	l3 = l3->next;
            																}
            															}
HXLINE(  41)															if (::hx::IsNull( prev3 )) {
HXLINE(  41)																b30->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  41)																l3 = null();
            															}
            															else {
HXLINE(  41)																prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  41)																l3 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  41)										undoImage10 = b30;
            									}
            									break;
            								}
HXDLIN(  41)								this116->image = undoImage10;
HXDLIN(  41)								this116->width = width3;
HXDLIN(  41)								this116->height = height3;
HXDLIN(  41)								this116->imageType = ( (int)(imageType3) );
HXDLIN(  41)								undoImage9 = this116;
HXDLIN(  41)								{
HXLINE(  41)									int rectLeft3 = xIter33->start;
HXDLIN(  41)									int rectTop3 = yIter33->start;
HXDLIN(  41)									int rectRight3 = xIter33->max;
HXDLIN(  41)									bool forceClear3 = false;
HXDLIN(  41)									{
HXLINE(  41)										int _g76 = rectTop3;
HXDLIN(  41)										int _g77 = yIter33->max;
HXDLIN(  41)										while((_g76 < _g77)){
HXLINE(  41)											_g76 = (_g76 + 1);
HXDLIN(  41)											int dy3 = (_g76 - 1);
HXDLIN(  41)											{
HXLINE(  41)												int _g78 = rectLeft3;
HXDLIN(  41)												int _g79 = rectRight3;
HXDLIN(  41)												while((_g78 < _g79)){
HXLINE(  41)													_g78 = (_g78 + 1);
HXDLIN(  41)													int dx3 = (_g78 - 1);
HXDLIN(  41)													::Dynamic this118 = this115->image;
HXDLIN(  41)													int index16;
HXDLIN(  41)													if (this115->useVirtualPos) {
HXLINE(  41)														index16 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - this115->virtualY) * ( (Float)(this115->width) )) + dx3) - this115->virtualX));
            													}
            													else {
HXLINE(  41)														index16 = ::Std_obj::_hx_int(( (Float)(((dy3 * this115->width) + dx3)) ));
            													}
HXDLIN(  41)													int c13 = ::iterMagic::Iimg_obj::get(this118,index16);
HXDLIN(  41)													int col3;
HXDLIN(  41)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  41)														col3 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            													}
            													else {
HXLINE(  41)														col3 = c13;
            													}
HXDLIN(  41)													bool _hx_tmp27;
HXDLIN(  41)													if (this115->useMask) {
HXLINE(  41)														_hx_tmp27 = ::hx::IsNotNull( this115->mask );
            													}
            													else {
HXLINE(  41)														_hx_tmp27 = false;
            													}
HXDLIN(  41)													if (_hx_tmp27) {
HXLINE(  41)														 ::pi_xy::ImageStruct this119 = this115->mask;
HXDLIN(  41)														::Dynamic this120 = this119->image;
HXDLIN(  41)														int index17;
HXDLIN(  41)														if (this119->useVirtualPos) {
HXLINE(  41)															index17 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - this119->virtualY) * ( (Float)(this119->width) )) + dx3) - this119->virtualX));
            														}
            														else {
HXLINE(  41)															index17 = ::Std_obj::_hx_int(( (Float)(((dy3 * this119->width) + dx3)) ));
            														}
HXDLIN(  41)														int c14 = ::iterMagic::Iimg_obj::get(this120,index17);
HXDLIN(  41)														int v10;
HXDLIN(  41)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  41)															v10 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            														}
            														else {
HXLINE(  41)															v10 = c14;
            														}
HXDLIN(  41)														int maskPixel3 = v10;
HXDLIN(  41)														int this121 = col3;
HXDLIN(  41)														if ((maskPixel3 == 0)) {
HXLINE(  41)															col3 = this121;
            														}
            														else {
HXLINE(  41)															Float m03;
HXDLIN(  41)															int this122 = ((maskPixel3 >> 24) & 255);
HXDLIN(  41)															if ((this122 == 0)) {
HXLINE(  41)																m03 = ((Float)0.);
            															}
            															else {
HXLINE(  41)																m03 = (( (Float)(this122) ) / ( (Float)(255) ));
            															}
HXDLIN(  41)															Float m13;
HXDLIN(  41)															int this123 = ((maskPixel3 >> 16) & 255);
HXDLIN(  41)															if ((this123 == 0)) {
HXLINE(  41)																m13 = ((Float)0.);
            															}
            															else {
HXLINE(  41)																m13 = (( (Float)(this123) ) / ( (Float)(255) ));
            															}
HXDLIN(  41)															Float m23;
HXDLIN(  41)															int this124 = ((maskPixel3 >> 8) & 255);
HXDLIN(  41)															if ((this124 == 0)) {
HXLINE(  41)																m23 = ((Float)0.);
            															}
            															else {
HXLINE(  41)																m23 = (( (Float)(this124) ) / ( (Float)(255) ));
            															}
HXDLIN(  41)															Float m33;
HXDLIN(  41)															int this125 = (maskPixel3 & 255);
HXDLIN(  41)															if ((this125 == 0)) {
HXLINE(  41)																m33 = ((Float)0.);
            															}
            															else {
HXLINE(  41)																m33 = (( (Float)(this125) ) / ( (Float)(255) ));
            															}
HXDLIN(  41)															int ch03 = ::Std_obj::_hx_int(((((Float)1.) - m03) * ( (Float)(((this121 >> 24) & 255)) )));
HXDLIN(  41)															int ch13 = ::Std_obj::_hx_int(((((Float)1.) - m13) * ( (Float)(((this121 >> 16) & 255)) )));
HXDLIN(  41)															int ch23 = ::Std_obj::_hx_int(((((Float)1.) - m23) * ( (Float)(((this121 >> 8) & 255)) )));
HXDLIN(  41)															int ch33 = ::Std_obj::_hx_int(((((Float)1.) - m33) * ( (Float)((this121 & 255)) )));
HXDLIN(  41)															col3 = ((((::Math_obj::round((( (Float)(ch03) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch13) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch23) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch33) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  41)													if ((col3 != 0)) {
HXLINE(  41)														int x14 = (dx3 - rectLeft3);
HXDLIN(  41)														int y15 = (dy3 - rectTop3);
HXDLIN(  41)														int c15 = col3;
HXDLIN(  41)														bool _hx_tmp28;
HXDLIN(  41)														if ((((c15 >> 24) & 255) < 254)) {
HXLINE(  41)															_hx_tmp28 = undoImage9->transparent;
            														}
            														else {
HXLINE(  41)															_hx_tmp28 = false;
            														}
HXDLIN(  41)														if (_hx_tmp28) {
HXLINE(  41)															int location7;
HXDLIN(  41)															if (undoImage9->useVirtualPos) {
HXLINE(  41)																location7 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x14) - undoImage9->virtualX));
            															}
            															else {
HXLINE(  41)																location7 = ::Std_obj::_hx_int(( (Float)(((y15 * undoImage9->width) + x14)) ));
            															}
HXDLIN(  41)															int this126 = ::iterMagic::Iimg_obj::get(undoImage9->image,location7);
HXDLIN(  41)															int this127;
HXDLIN(  41)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  41)																this127 = ((((((this126 >> 24) & 255) << 24) | ((this126 & 255) << 16)) | (((this126 >> 8) & 255) << 8)) | ((this126 >> 16) & 255));
            															}
            															else {
HXLINE(  41)																this127 = this126;
            															}
HXDLIN(  41)															Float a110;
HXDLIN(  41)															int this128 = ((this127 >> 24) & 255);
HXDLIN(  41)															if ((this128 == 0)) {
HXLINE(  41)																a110 = ((Float)0.);
            															}
            															else {
HXLINE(  41)																a110 = (( (Float)(this128) ) / ( (Float)(255) ));
            															}
HXDLIN(  41)															Float r17;
HXDLIN(  41)															int this129 = ((this127 >> 16) & 255);
HXDLIN(  41)															if ((this129 == 0)) {
HXLINE(  41)																r17 = ((Float)0.);
            															}
            															else {
HXLINE(  41)																r17 = (( (Float)(this129) ) / ( (Float)(255) ));
            															}
HXDLIN(  41)															Float g17;
HXDLIN(  41)															int this130 = ((this127 >> 8) & 255);
HXDLIN(  41)															if ((this130 == 0)) {
HXLINE(  41)																g17 = ((Float)0.);
            															}
            															else {
HXLINE(  41)																g17 = (( (Float)(this130) ) / ( (Float)(255) ));
            															}
HXDLIN(  41)															Float b112;
HXDLIN(  41)															int this131 = (this127 & 255);
HXDLIN(  41)															if ((this131 == 0)) {
HXLINE(  41)																b112 = ((Float)0.);
            															}
            															else {
HXLINE(  41)																b112 = (( (Float)(this131) ) / ( (Float)(255) ));
            															}
HXDLIN(  41)															Float a27;
HXDLIN(  41)															int this132 = ((col3 >> 24) & 255);
HXDLIN(  41)															if ((this132 == 0)) {
HXLINE(  41)																a27 = ((Float)0.);
            															}
            															else {
HXLINE(  41)																a27 = (( (Float)(this132) ) / ( (Float)(255) ));
            															}
HXDLIN(  41)															Float r27;
HXDLIN(  41)															int this133 = ((col3 >> 16) & 255);
HXDLIN(  41)															if ((this133 == 0)) {
HXLINE(  41)																r27 = ((Float)0.);
            															}
            															else {
HXLINE(  41)																r27 = (( (Float)(this133) ) / ( (Float)(255) ));
            															}
HXDLIN(  41)															Float g27;
HXDLIN(  41)															int this134 = ((col3 >> 8) & 255);
HXDLIN(  41)															if ((this134 == 0)) {
HXLINE(  41)																g27 = ((Float)0.);
            															}
            															else {
HXLINE(  41)																g27 = (( (Float)(this134) ) / ( (Float)(255) ));
            															}
HXDLIN(  41)															Float b210;
HXDLIN(  41)															int this135 = (col3 & 255);
HXDLIN(  41)															if ((this135 == 0)) {
HXLINE(  41)																b210 = ((Float)0.);
            															}
            															else {
HXLINE(  41)																b210 = (( (Float)(this135) ) / ( (Float)(255) ));
            															}
HXDLIN(  41)															Float a37 = (a110 * (( (Float)(1) ) - a27));
HXDLIN(  41)															int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN(  41)															int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN(  41)															int b31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a37) + (b210 * a27))));
HXDLIN(  41)															int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN(  41)															int blended7 = ((((a20 << 24) | (r9 << 16)) | (g9 << 8)) | b31);
HXDLIN(  41)															{
HXLINE(  41)																int _hx_tmp29;
HXDLIN(  41)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  41)																	_hx_tmp29 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            																}
            																else {
HXLINE(  41)																	_hx_tmp29 = blended7;
            																}
HXDLIN(  41)																::iterMagic::Iimg_obj::set(undoImage9->image,location7,_hx_tmp29);
            															}
            														}
            														else {
HXLINE(  41)															::Dynamic this136 = undoImage9->image;
HXDLIN(  41)															int index18;
HXDLIN(  41)															if (undoImage9->useVirtualPos) {
HXLINE(  41)																index18 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x14) - undoImage9->virtualX));
            															}
            															else {
HXLINE(  41)																index18 = ::Std_obj::_hx_int(( (Float)(((y15 * undoImage9->width) + x14)) ));
            															}
HXDLIN(  41)															int _hx_tmp30;
HXDLIN(  41)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  41)																_hx_tmp30 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            															}
            															else {
HXLINE(  41)																_hx_tmp30 = c15;
            															}
HXDLIN(  41)															::iterMagic::Iimg_obj::set(this136,index18,_hx_tmp30);
            														}
            													}
            													else {
HXLINE(  41)														if (forceClear3) {
HXLINE(  41)															::Dynamic this137 = undoImage9->image;
HXDLIN(  41)															int x15 = (dx3 - rectLeft3);
HXDLIN(  41)															int y16 = (dy3 - rectTop3);
HXDLIN(  41)															int index19;
HXDLIN(  41)															if (undoImage9->useVirtualPos) {
HXLINE(  41)																index19 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x15) - undoImage9->virtualX));
            															}
            															else {
HXLINE(  41)																index19 = ::Std_obj::_hx_int(( (Float)(((y16 * undoImage9->width) + x15)) ));
            															}
HXDLIN(  41)															::iterMagic::Iimg_obj::set(this137,index19,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  41)							bool found3 = false;
HXDLIN(  41)							Float s3 = ((Float)0.);
HXDLIN(  41)							Float t3 = ((Float)0.);
HXDLIN(  41)							Float sxx3 = ((Float)0.);
HXDLIN(  41)							Float txx3 = ((Float)0.);
HXDLIN(  41)							{
HXLINE(  41)								int _g_min6 = xIter33->start;
HXDLIN(  41)								int _g_max6 = xIter33->max;
HXDLIN(  41)								while((_g_min6 < _g_max6)){
HXLINE(  41)									_g_min6 = (_g_min6 + 1);
HXDLIN(  41)									int x16 = (_g_min6 - 1);
HXLINE(  60)									sxx3 = (sx3 * ( (Float)(x16) ));
HXLINE(  61)									txx3 = (tx3 * ( (Float)(x16) ));
HXLINE(  62)									found3 = false;
HXLINE(  41)									{
HXLINE(  41)										int _g_min7 = yIter33->start;
HXDLIN(  41)										int _g_max7 = yIter33->max;
HXDLIN(  41)										while((_g_min7 < _g_max7)){
HXLINE(  41)											_g_min7 = (_g_min7 + 1);
HXDLIN(  41)											int y17 = (_g_min7 - 1);
HXLINE(  64)											s3 = ((s03 + sxx3) + (sy3 * ( (Float)(y17) )));
HXLINE(  65)											t3 = ((t03 + txx3) + (ty3 * ( (Float)(y17) )));
HXLINE(  41)											bool _hx_tmp31;
HXDLIN(  41)											if (!((s3 <= 0))) {
HXLINE(  41)												_hx_tmp31 = (t3 <= 0);
            											}
            											else {
HXLINE(  41)												_hx_tmp31 = true;
            											}
HXDLIN(  41)											if (_hx_tmp31) {
HXLINE(  41)												if (found3) {
HXLINE(  41)													goto _hx_goto_61;
            												}
            											}
            											else {
HXLINE(  41)												if (((s3 + t3) < A3)) {
HXLINE(  41)													{
HXLINE(  41)														int c16 = color2;
HXDLIN(  41)														bool _hx_tmp32;
HXDLIN(  41)														if ((((c16 >> 24) & 255) < 254)) {
HXLINE(  41)															_hx_tmp32 = this115->transparent;
            														}
            														else {
HXLINE(  41)															_hx_tmp32 = false;
            														}
HXDLIN(  41)														if (_hx_tmp32) {
HXLINE(  41)															int location8;
HXDLIN(  41)															if (this115->useVirtualPos) {
HXLINE(  41)																location8 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - this115->virtualY) * ( (Float)(this115->width) )) + x16) - this115->virtualX));
            															}
            															else {
HXLINE(  41)																location8 = ::Std_obj::_hx_int(( (Float)(((y17 * this115->width) + x16)) ));
            															}
HXDLIN(  41)															int this138 = ::iterMagic::Iimg_obj::get(this115->image,location8);
HXDLIN(  41)															int this139;
HXDLIN(  41)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  41)																this139 = ((((((this138 >> 24) & 255) << 24) | ((this138 & 255) << 16)) | (((this138 >> 8) & 255) << 8)) | ((this138 >> 16) & 255));
            															}
            															else {
HXLINE(  41)																this139 = this138;
            															}
HXDLIN(  41)															Float a111;
HXDLIN(  41)															int this140 = ((this139 >> 24) & 255);
HXDLIN(  41)															if ((this140 == 0)) {
HXLINE(  41)																a111 = ((Float)0.);
            															}
            															else {
HXLINE(  41)																a111 = (( (Float)(this140) ) / ( (Float)(255) ));
            															}
HXDLIN(  41)															Float r18;
HXDLIN(  41)															int this141 = ((this139 >> 16) & 255);
HXDLIN(  41)															if ((this141 == 0)) {
HXLINE(  41)																r18 = ((Float)0.);
            															}
            															else {
HXLINE(  41)																r18 = (( (Float)(this141) ) / ( (Float)(255) ));
            															}
HXDLIN(  41)															Float g18;
HXDLIN(  41)															int this142 = ((this139 >> 8) & 255);
HXDLIN(  41)															if ((this142 == 0)) {
HXLINE(  41)																g18 = ((Float)0.);
            															}
            															else {
HXLINE(  41)																g18 = (( (Float)(this142) ) / ( (Float)(255) ));
            															}
HXDLIN(  41)															Float b113;
HXDLIN(  41)															int this143 = (this139 & 255);
HXDLIN(  41)															if ((this143 == 0)) {
HXLINE(  41)																b113 = ((Float)0.);
            															}
            															else {
HXLINE(  41)																b113 = (( (Float)(this143) ) / ( (Float)(255) ));
            															}
HXDLIN(  41)															Float a28;
HXDLIN(  41)															int this144 = ((color2 >> 24) & 255);
HXDLIN(  41)															if ((this144 == 0)) {
HXLINE(  41)																a28 = ((Float)0.);
            															}
            															else {
HXLINE(  41)																a28 = (( (Float)(this144) ) / ( (Float)(255) ));
            															}
HXDLIN(  41)															Float r28;
HXDLIN(  41)															int this145 = ((color2 >> 16) & 255);
HXDLIN(  41)															if ((this145 == 0)) {
HXLINE(  41)																r28 = ((Float)0.);
            															}
            															else {
HXLINE(  41)																r28 = (( (Float)(this145) ) / ( (Float)(255) ));
            															}
HXDLIN(  41)															Float g28;
HXDLIN(  41)															int this146 = ((color2 >> 8) & 255);
HXDLIN(  41)															if ((this146 == 0)) {
HXLINE(  41)																g28 = ((Float)0.);
            															}
            															else {
HXLINE(  41)																g28 = (( (Float)(this146) ) / ( (Float)(255) ));
            															}
HXDLIN(  41)															Float b211;
HXDLIN(  41)															int this147 = (color2 & 255);
HXDLIN(  41)															if ((this147 == 0)) {
HXLINE(  41)																b211 = ((Float)0.);
            															}
            															else {
HXLINE(  41)																b211 = (( (Float)(this147) ) / ( (Float)(255) ));
            															}
HXDLIN(  41)															Float a38 = (a111 * (( (Float)(1) ) - a28));
HXDLIN(  41)															int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a38) + (r28 * a28))));
HXDLIN(  41)															int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a38) + (g28 * a28))));
HXDLIN(  41)															int b32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a38) + (b211 * a28))));
HXDLIN(  41)															int a29 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a28)));
HXDLIN(  41)															int blended8 = ((((a29 << 24) | (r10 << 16)) | (g10 << 8)) | b32);
HXDLIN(  41)															{
HXLINE(  41)																int _hx_tmp33;
HXDLIN(  41)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  41)																	_hx_tmp33 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            																}
            																else {
HXLINE(  41)																	_hx_tmp33 = blended8;
            																}
HXDLIN(  41)																::iterMagic::Iimg_obj::set(this115->image,location8,_hx_tmp33);
            															}
            														}
            														else {
HXLINE(  41)															::Dynamic this148 = this115->image;
HXDLIN(  41)															int index20;
HXDLIN(  41)															if (this115->useVirtualPos) {
HXLINE(  41)																index20 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - this115->virtualY) * ( (Float)(this115->width) )) + x16) - this115->virtualX));
            															}
            															else {
HXLINE(  41)																index20 = ::Std_obj::_hx_int(( (Float)(((y17 * this115->width) + x16)) ));
            															}
HXDLIN(  41)															int _hx_tmp34;
HXDLIN(  41)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  41)																_hx_tmp34 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            															}
            															else {
HXLINE(  41)																_hx_tmp34 = c16;
            															}
HXDLIN(  41)															::iterMagic::Iimg_obj::set(this148,index20,_hx_tmp34);
            														}
            													}
HXLINE(  73)													found3 = true;
            												}
            												else {
HXLINE(  41)													if (found3) {
HXLINE(  41)														goto _hx_goto_61;
            													}
            												}
            											}
            										}
            										_hx_goto_61:;
            									}
            								}
            							}
HXDLIN(  41)							if ((hasHit3 == true)) {
HXLINE(  41)								 ::pi_xy::algo::HitTri v11 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax3,ay3,bx6,by6,cx6,cy6,true);
HXDLIN(  41)								if (hasUndo3) {
HXLINE(  41)									v11->undoImage = undoImage9;
HXDLIN(  41)									v11->undoX = xIter33->start;
HXDLIN(  41)									v11->undoY = yIter33->start;
            								}
            							}
            						}
            					}
            				}
            			}
HXLINE(  42)			{
HXLINE(  42)				 ::pi_xy::ImageStruct this149 = temp;
HXDLIN(  42)				int color3 = this->strokeColor;
HXDLIN(  42)				bool hasHit4 = true;
HXDLIN(  42)				Float o = (by - cy);
HXDLIN(  42)				Float a30 = (bx - cx);
HXDLIN(  42)				Float h = ::Math_obj::pow(((o * o) + (a30 * a30)),((Float)0.5));
HXDLIN(  42)				Float theta = ::Math_obj::atan2(o,a30);
HXDLIN(  42)				{
HXLINE(  42)					 ::Dynamic debugCorners = false;
HXDLIN(  42)					if (::hx::IsNull( debugCorners )) {
HXLINE(  75)						debugCorners = false;
            					}
HXLINE(  42)					Float sin = ::Math_obj::sin(theta);
HXDLIN(  42)					Float cos = ::Math_obj::cos(theta);
HXDLIN(  42)					Float radius = (this->strokeWidth / ( (Float)(2) ));
HXDLIN(  42)					Float dx4 = ((Float)0.1);
HXDLIN(  42)					Float dy4 = radius;
HXDLIN(  42)					Float cx7 = h;
HXDLIN(  42)					Float cy7 = radius;
HXDLIN(  42)					Float bx7 = h;
HXDLIN(  42)					Float by7 = -(radius);
HXDLIN(  42)					Float ax4 = ((Float)0.1);
HXDLIN(  42)					Float ay4 = -(radius);
HXDLIN(  42)					Float temp1 = ((Float)0.);
HXLINE(  28)					temp1 = (cx + ((ax4 * cos) - (ay4 * sin)));
HXLINE(  29)					ay4 = (cy + ((ay4 * cos) + (ax4 * sin)));
HXLINE(  30)					ax4 = temp1;
HXLINE(  32)					temp1 = (cx + ((bx7 * cos) - (by7 * sin)));
HXLINE(  33)					by7 = (cy + ((by7 * cos) + (bx7 * sin)));
HXLINE(  34)					bx7 = temp1;
HXLINE(  36)					temp1 = (cx + ((cx7 * cos) - (cy7 * sin)));
HXLINE(  37)					cy7 = (cy + ((cy7 * cos) + (cx7 * sin)));
HXLINE(  38)					cx7 = temp1;
HXLINE(  40)					temp1 = (cx + ((dx4 * cos) - (dy4 * sin)));
HXLINE(  41)					dy4 = (cy + ((dy4 * cos) + (dx4 * sin)));
HXLINE(  42)					dx4 = temp1;
HXDLIN(  42)					if (( (bool)(debugCorners) )) {
HXLINE(  42)						{
HXLINE(  42)							 ::pi_xy::ImageStruct this150 = this149;
HXDLIN(  42)							{
HXLINE(  42)								int r_x1 = ::Std_obj::_hx_int((ax4 - ((Float)6.)));
HXDLIN(  42)								int r_y1 = ::Std_obj::_hx_int((ay4 - ((Float)6.)));
HXDLIN(  42)								int r_w1 = 12;
HXDLIN(  42)								int r_h1 = 12;
HXDLIN(  42)								int xmax1 = ((r_x1 + r_w1) + 1);
HXDLIN(  42)								int ymax1 = ((r_y1 + r_h1) + 1);
HXDLIN(  42)								int ii_min34 = r_x1;
HXDLIN(  42)								int ii_max34 = xmax1;
HXDLIN(  42)								int xRange__start1 = ii_min34;
HXDLIN(  42)								int xRange__max1 = ii_max34;
HXDLIN(  42)								int ii_min35 = r_y1;
HXDLIN(  42)								int ii_max35 = ymax1;
HXDLIN(  42)								int yRange__start1 = ii_min35;
HXDLIN(  42)								int yRange__max1 = ii_max35;
HXDLIN(  42)								int range_x1 = xRange__start1;
HXDLIN(  42)								int range_y1 = (yRange__start1 - 1);
HXDLIN(  42)								int range_xReset1 = range_x1;
HXDLIN(  42)								int range_yReset1 = range_y1;
HXDLIN(  42)								int range_xMax1 = (xRange__max1 - 2);
HXDLIN(  42)								int range_yMax1 = (yRange__max1 - 2);
HXDLIN(  42)								int _this_min1 = 0;
HXDLIN(  42)								int _this_max1 = ::Std_obj::_hx_int(( (Float)(((xRange__max1 - xRange__start1) * (yRange__max1 - yRange__start1))) ));
HXDLIN(  42)								while((_this_min1 < _this_max1)){
HXLINE(  42)									_this_min1 = (_this_min1 + 1);
HXDLIN(  42)									int i26 = (_this_min1 - 1);
HXDLIN(  42)									if ((range_y1 > range_yMax1)) {
HXLINE(  42)										range_y1 = range_yReset1;
HXDLIN(  42)										range_x1 = (range_x1 + 1);
            									}
HXDLIN(  42)									range_y1 = (range_y1 + 1);
HXDLIN(  42)									int i27 = i26;
HXDLIN(  42)									{
HXLINE(  42)										int x17 = range_x1;
HXDLIN(  42)										int y18 = range_y1;
HXDLIN(  42)										int c17 = -65536;
HXDLIN(  42)										bool _hx_tmp35;
HXDLIN(  42)										if ((((c17 >> 24) & 255) < 254)) {
HXLINE(  42)											_hx_tmp35 = this150->transparent;
            										}
            										else {
HXLINE(  42)											_hx_tmp35 = false;
            										}
HXDLIN(  42)										if (_hx_tmp35) {
HXLINE(  42)											int location9;
HXDLIN(  42)											if (this150->useVirtualPos) {
HXLINE(  42)												location9 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - this150->virtualY) * ( (Float)(this150->width) )) + x17) - this150->virtualX));
            											}
            											else {
HXLINE(  42)												location9 = ::Std_obj::_hx_int(( (Float)(((y18 * this150->width) + x17)) ));
            											}
HXDLIN(  42)											int this151 = ::iterMagic::Iimg_obj::get(this150->image,location9);
HXDLIN(  42)											int this152;
HXDLIN(  42)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  42)												this152 = ((((((this151 >> 24) & 255) << 24) | ((this151 & 255) << 16)) | (((this151 >> 8) & 255) << 8)) | ((this151 >> 16) & 255));
            											}
            											else {
HXLINE(  42)												this152 = this151;
            											}
HXDLIN(  42)											Float a112;
HXDLIN(  42)											int this153 = ((this152 >> 24) & 255);
HXDLIN(  42)											if ((this153 == 0)) {
HXLINE(  42)												a112 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												a112 = (( (Float)(this153) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float r19;
HXDLIN(  42)											int this154 = ((this152 >> 16) & 255);
HXDLIN(  42)											if ((this154 == 0)) {
HXLINE(  42)												r19 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												r19 = (( (Float)(this154) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float g19;
HXDLIN(  42)											int this155 = ((this152 >> 8) & 255);
HXDLIN(  42)											if ((this155 == 0)) {
HXLINE(  42)												g19 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												g19 = (( (Float)(this155) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float b114;
HXDLIN(  42)											int this156 = (this152 & 255);
HXDLIN(  42)											if ((this156 == 0)) {
HXLINE(  42)												b114 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												b114 = (( (Float)(this156) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float a210;
HXDLIN(  42)											int this157 = ((-65536 >> 24) & 255);
HXDLIN(  42)											if ((this157 == 0)) {
HXLINE(  42)												a210 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												a210 = (( (Float)(this157) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float r29;
HXDLIN(  42)											int this158 = ((-65536 >> 16) & 255);
HXDLIN(  42)											if ((this158 == 0)) {
HXLINE(  42)												r29 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												r29 = (( (Float)(this158) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float g29;
HXDLIN(  42)											int this159 = ((-65536 >> 8) & 255);
HXDLIN(  42)											if ((this159 == 0)) {
HXLINE(  42)												g29 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												g29 = (( (Float)(this159) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float b212;
HXDLIN(  42)											int this160 = (-65536 & 255);
HXDLIN(  42)											if ((this160 == 0)) {
HXLINE(  42)												b212 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												b212 = (( (Float)(this160) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float a39 = (a112 * (( (Float)(1) ) - a210));
HXDLIN(  42)											int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a39) + (r29 * a210))));
HXDLIN(  42)											int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a39) + (g29 * a210))));
HXDLIN(  42)											int b33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a39) + (b212 * a210))));
HXDLIN(  42)											int a40 = ::Std_obj::_hx_int((( (Float)(255) ) * (a39 + a210)));
HXDLIN(  42)											int blended9 = ((((a40 << 24) | (r20 << 16)) | (g20 << 8)) | b33);
HXDLIN(  42)											{
HXLINE(  42)												int _hx_tmp36;
HXDLIN(  42)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  42)													_hx_tmp36 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            												}
            												else {
HXLINE(  42)													_hx_tmp36 = blended9;
            												}
HXDLIN(  42)												::iterMagic::Iimg_obj::set(this150->image,location9,_hx_tmp36);
            											}
            										}
            										else {
HXLINE(  42)											::Dynamic this161 = this150->image;
HXDLIN(  42)											int index21;
HXDLIN(  42)											if (this150->useVirtualPos) {
HXLINE(  42)												index21 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - this150->virtualY) * ( (Float)(this150->width) )) + x17) - this150->virtualX));
            											}
            											else {
HXLINE(  42)												index21 = ::Std_obj::_hx_int(( (Float)(((y18 * this150->width) + x17)) ));
            											}
HXDLIN(  42)											int _hx_tmp37;
HXDLIN(  42)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  42)												_hx_tmp37 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            											}
            											else {
HXLINE(  42)												_hx_tmp37 = c17;
            											}
HXDLIN(  42)											::iterMagic::Iimg_obj::set(this161,index21,_hx_tmp37);
            										}
            									}
            								}
            							}
            						}
HXDLIN(  42)						{
HXLINE(  42)							 ::pi_xy::ImageStruct this162 = this149;
HXDLIN(  42)							{
HXLINE(  42)								int r_x2 = ::Std_obj::_hx_int((bx7 - ((Float)6.)));
HXDLIN(  42)								int r_y2 = ::Std_obj::_hx_int((by7 - ((Float)6.)));
HXDLIN(  42)								int r_w2 = 12;
HXDLIN(  42)								int r_h2 = 12;
HXDLIN(  42)								int xmax2 = ((r_x2 + r_w2) + 1);
HXDLIN(  42)								int ymax2 = ((r_y2 + r_h2) + 1);
HXDLIN(  42)								int ii_min36 = r_x2;
HXDLIN(  42)								int ii_max36 = xmax2;
HXDLIN(  42)								int xRange__start2 = ii_min36;
HXDLIN(  42)								int xRange__max2 = ii_max36;
HXDLIN(  42)								int ii_min37 = r_y2;
HXDLIN(  42)								int ii_max37 = ymax2;
HXDLIN(  42)								int yRange__start2 = ii_min37;
HXDLIN(  42)								int yRange__max2 = ii_max37;
HXDLIN(  42)								int range_x2 = xRange__start2;
HXDLIN(  42)								int range_y2 = (yRange__start2 - 1);
HXDLIN(  42)								int range_xReset2 = range_x2;
HXDLIN(  42)								int range_yReset2 = range_y2;
HXDLIN(  42)								int range_xMax2 = (xRange__max2 - 2);
HXDLIN(  42)								int range_yMax2 = (yRange__max2 - 2);
HXDLIN(  42)								int _this_min2 = 0;
HXDLIN(  42)								int _this_max2 = ::Std_obj::_hx_int(( (Float)(((xRange__max2 - xRange__start2) * (yRange__max2 - yRange__start2))) ));
HXDLIN(  42)								while((_this_min2 < _this_max2)){
HXLINE(  42)									_this_min2 = (_this_min2 + 1);
HXDLIN(  42)									int i28 = (_this_min2 - 1);
HXDLIN(  42)									if ((range_y2 > range_yMax2)) {
HXLINE(  42)										range_y2 = range_yReset2;
HXDLIN(  42)										range_x2 = (range_x2 + 1);
            									}
HXDLIN(  42)									range_y2 = (range_y2 + 1);
HXDLIN(  42)									int i29 = i28;
HXDLIN(  42)									{
HXLINE(  42)										int x18 = range_x2;
HXDLIN(  42)										int y19 = range_y2;
HXDLIN(  42)										int c18 = -16711936;
HXDLIN(  42)										bool _hx_tmp38;
HXDLIN(  42)										if ((((c18 >> 24) & 255) < 254)) {
HXLINE(  42)											_hx_tmp38 = this162->transparent;
            										}
            										else {
HXLINE(  42)											_hx_tmp38 = false;
            										}
HXDLIN(  42)										if (_hx_tmp38) {
HXLINE(  42)											int location10;
HXDLIN(  42)											if (this162->useVirtualPos) {
HXLINE(  42)												location10 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - this162->virtualY) * ( (Float)(this162->width) )) + x18) - this162->virtualX));
            											}
            											else {
HXLINE(  42)												location10 = ::Std_obj::_hx_int(( (Float)(((y19 * this162->width) + x18)) ));
            											}
HXDLIN(  42)											int this163 = ::iterMagic::Iimg_obj::get(this162->image,location10);
HXDLIN(  42)											int this164;
HXDLIN(  42)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  42)												this164 = ((((((this163 >> 24) & 255) << 24) | ((this163 & 255) << 16)) | (((this163 >> 8) & 255) << 8)) | ((this163 >> 16) & 255));
            											}
            											else {
HXLINE(  42)												this164 = this163;
            											}
HXDLIN(  42)											Float a113;
HXDLIN(  42)											int this165 = ((this164 >> 24) & 255);
HXDLIN(  42)											if ((this165 == 0)) {
HXLINE(  42)												a113 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												a113 = (( (Float)(this165) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float r110;
HXDLIN(  42)											int this166 = ((this164 >> 16) & 255);
HXDLIN(  42)											if ((this166 == 0)) {
HXLINE(  42)												r110 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												r110 = (( (Float)(this166) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float g110;
HXDLIN(  42)											int this167 = ((this164 >> 8) & 255);
HXDLIN(  42)											if ((this167 == 0)) {
HXLINE(  42)												g110 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												g110 = (( (Float)(this167) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float b115;
HXDLIN(  42)											int this168 = (this164 & 255);
HXDLIN(  42)											if ((this168 == 0)) {
HXLINE(  42)												b115 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												b115 = (( (Float)(this168) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float a211;
HXDLIN(  42)											int this169 = ((-16711936 >> 24) & 255);
HXDLIN(  42)											if ((this169 == 0)) {
HXLINE(  42)												a211 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												a211 = (( (Float)(this169) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float r210;
HXDLIN(  42)											int this170 = ((-16711936 >> 16) & 255);
HXDLIN(  42)											if ((this170 == 0)) {
HXLINE(  42)												r210 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												r210 = (( (Float)(this170) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float g210;
HXDLIN(  42)											int this171 = ((-16711936 >> 8) & 255);
HXDLIN(  42)											if ((this171 == 0)) {
HXLINE(  42)												g210 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												g210 = (( (Float)(this171) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float b213;
HXDLIN(  42)											int this172 = (-16711936 & 255);
HXDLIN(  42)											if ((this172 == 0)) {
HXLINE(  42)												b213 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												b213 = (( (Float)(this172) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float a310 = (a113 * (( (Float)(1) ) - a211));
HXDLIN(  42)											int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a310) + (r210 * a211))));
HXDLIN(  42)											int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a310) + (g210 * a211))));
HXDLIN(  42)											int b34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a310) + (b213 * a211))));
HXDLIN(  42)											int a41 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a211)));
HXDLIN(  42)											int blended10 = ((((a41 << 24) | (r30 << 16)) | (g30 << 8)) | b34);
HXDLIN(  42)											{
HXLINE(  42)												int _hx_tmp39;
HXDLIN(  42)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  42)													_hx_tmp39 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            												}
            												else {
HXLINE(  42)													_hx_tmp39 = blended10;
            												}
HXDLIN(  42)												::iterMagic::Iimg_obj::set(this162->image,location10,_hx_tmp39);
            											}
            										}
            										else {
HXLINE(  42)											::Dynamic this173 = this162->image;
HXDLIN(  42)											int index22;
HXDLIN(  42)											if (this162->useVirtualPos) {
HXLINE(  42)												index22 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - this162->virtualY) * ( (Float)(this162->width) )) + x18) - this162->virtualX));
            											}
            											else {
HXLINE(  42)												index22 = ::Std_obj::_hx_int(( (Float)(((y19 * this162->width) + x18)) ));
            											}
HXDLIN(  42)											int _hx_tmp40;
HXDLIN(  42)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  42)												_hx_tmp40 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            											}
            											else {
HXLINE(  42)												_hx_tmp40 = c18;
            											}
HXDLIN(  42)											::iterMagic::Iimg_obj::set(this173,index22,_hx_tmp40);
            										}
            									}
            								}
            							}
            						}
HXDLIN(  42)						{
HXLINE(  42)							 ::pi_xy::ImageStruct this174 = this149;
HXDLIN(  42)							{
HXLINE(  42)								int r_x3 = ::Std_obj::_hx_int((cx7 - ((Float)6.)));
HXDLIN(  42)								int r_y3 = ::Std_obj::_hx_int((cy7 - ((Float)6.)));
HXDLIN(  42)								int r_w3 = 12;
HXDLIN(  42)								int r_h3 = 12;
HXDLIN(  42)								int xmax3 = ((r_x3 + r_w3) + 1);
HXDLIN(  42)								int ymax3 = ((r_y3 + r_h3) + 1);
HXDLIN(  42)								int ii_min38 = r_x3;
HXDLIN(  42)								int ii_max38 = xmax3;
HXDLIN(  42)								int xRange__start3 = ii_min38;
HXDLIN(  42)								int xRange__max3 = ii_max38;
HXDLIN(  42)								int ii_min39 = r_y3;
HXDLIN(  42)								int ii_max39 = ymax3;
HXDLIN(  42)								int yRange__start3 = ii_min39;
HXDLIN(  42)								int yRange__max3 = ii_max39;
HXDLIN(  42)								int range_x3 = xRange__start3;
HXDLIN(  42)								int range_y3 = (yRange__start3 - 1);
HXDLIN(  42)								int range_xReset3 = range_x3;
HXDLIN(  42)								int range_yReset3 = range_y3;
HXDLIN(  42)								int range_xMax3 = (xRange__max3 - 2);
HXDLIN(  42)								int range_yMax3 = (yRange__max3 - 2);
HXDLIN(  42)								int _this_min3 = 0;
HXDLIN(  42)								int _this_max3 = ::Std_obj::_hx_int(( (Float)(((xRange__max3 - xRange__start3) * (yRange__max3 - yRange__start3))) ));
HXDLIN(  42)								while((_this_min3 < _this_max3)){
HXLINE(  42)									_this_min3 = (_this_min3 + 1);
HXDLIN(  42)									int i30 = (_this_min3 - 1);
HXDLIN(  42)									if ((range_y3 > range_yMax3)) {
HXLINE(  42)										range_y3 = range_yReset3;
HXDLIN(  42)										range_x3 = (range_x3 + 1);
            									}
HXDLIN(  42)									range_y3 = (range_y3 + 1);
HXDLIN(  42)									int i31 = i30;
HXDLIN(  42)									{
HXLINE(  42)										int x19 = range_x3;
HXDLIN(  42)										int y20 = range_y3;
HXDLIN(  42)										int c19 = -16776961;
HXDLIN(  42)										bool _hx_tmp41;
HXDLIN(  42)										if ((((c19 >> 24) & 255) < 254)) {
HXLINE(  42)											_hx_tmp41 = this174->transparent;
            										}
            										else {
HXLINE(  42)											_hx_tmp41 = false;
            										}
HXDLIN(  42)										if (_hx_tmp41) {
HXLINE(  42)											int location11;
HXDLIN(  42)											if (this174->useVirtualPos) {
HXLINE(  42)												location11 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - this174->virtualY) * ( (Float)(this174->width) )) + x19) - this174->virtualX));
            											}
            											else {
HXLINE(  42)												location11 = ::Std_obj::_hx_int(( (Float)(((y20 * this174->width) + x19)) ));
            											}
HXDLIN(  42)											int this175 = ::iterMagic::Iimg_obj::get(this174->image,location11);
HXDLIN(  42)											int this176;
HXDLIN(  42)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  42)												this176 = ((((((this175 >> 24) & 255) << 24) | ((this175 & 255) << 16)) | (((this175 >> 8) & 255) << 8)) | ((this175 >> 16) & 255));
            											}
            											else {
HXLINE(  42)												this176 = this175;
            											}
HXDLIN(  42)											Float a114;
HXDLIN(  42)											int this177 = ((this176 >> 24) & 255);
HXDLIN(  42)											if ((this177 == 0)) {
HXLINE(  42)												a114 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												a114 = (( (Float)(this177) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float r111;
HXDLIN(  42)											int this178 = ((this176 >> 16) & 255);
HXDLIN(  42)											if ((this178 == 0)) {
HXLINE(  42)												r111 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												r111 = (( (Float)(this178) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float g111;
HXDLIN(  42)											int this179 = ((this176 >> 8) & 255);
HXDLIN(  42)											if ((this179 == 0)) {
HXLINE(  42)												g111 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												g111 = (( (Float)(this179) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float b116;
HXDLIN(  42)											int this180 = (this176 & 255);
HXDLIN(  42)											if ((this180 == 0)) {
HXLINE(  42)												b116 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												b116 = (( (Float)(this180) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float a212;
HXDLIN(  42)											int this181 = ((-16776961 >> 24) & 255);
HXDLIN(  42)											if ((this181 == 0)) {
HXLINE(  42)												a212 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												a212 = (( (Float)(this181) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float r211;
HXDLIN(  42)											int this182 = ((-16776961 >> 16) & 255);
HXDLIN(  42)											if ((this182 == 0)) {
HXLINE(  42)												r211 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												r211 = (( (Float)(this182) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float g211;
HXDLIN(  42)											int this183 = ((-16776961 >> 8) & 255);
HXDLIN(  42)											if ((this183 == 0)) {
HXLINE(  42)												g211 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												g211 = (( (Float)(this183) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float b214;
HXDLIN(  42)											int this184 = (-16776961 & 255);
HXDLIN(  42)											if ((this184 == 0)) {
HXLINE(  42)												b214 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												b214 = (( (Float)(this184) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float a311 = (a114 * (( (Float)(1) ) - a212));
HXDLIN(  42)											int r31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r111 * a311) + (r211 * a212))));
HXDLIN(  42)											int g31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g111 * a311) + (g211 * a212))));
HXDLIN(  42)											int b35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a311) + (b214 * a212))));
HXDLIN(  42)											int a42 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a212)));
HXDLIN(  42)											int blended11 = ((((a42 << 24) | (r31 << 16)) | (g31 << 8)) | b35);
HXDLIN(  42)											{
HXLINE(  42)												int _hx_tmp42;
HXDLIN(  42)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  42)													_hx_tmp42 = ((((((blended11 >> 24) & 255) << 24) | ((blended11 & 255) << 16)) | (((blended11 >> 8) & 255) << 8)) | ((blended11 >> 16) & 255));
            												}
            												else {
HXLINE(  42)													_hx_tmp42 = blended11;
            												}
HXDLIN(  42)												::iterMagic::Iimg_obj::set(this174->image,location11,_hx_tmp42);
            											}
            										}
            										else {
HXLINE(  42)											::Dynamic this185 = this174->image;
HXDLIN(  42)											int index23;
HXDLIN(  42)											if (this174->useVirtualPos) {
HXLINE(  42)												index23 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - this174->virtualY) * ( (Float)(this174->width) )) + x19) - this174->virtualX));
            											}
            											else {
HXLINE(  42)												index23 = ::Std_obj::_hx_int(( (Float)(((y20 * this174->width) + x19)) ));
            											}
HXDLIN(  42)											int _hx_tmp43;
HXDLIN(  42)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  42)												_hx_tmp43 = ((((((c19 >> 24) & 255) << 24) | ((c19 & 255) << 16)) | (((c19 >> 8) & 255) << 8)) | ((c19 >> 16) & 255));
            											}
            											else {
HXLINE(  42)												_hx_tmp43 = c19;
            											}
HXDLIN(  42)											::iterMagic::Iimg_obj::set(this185,index23,_hx_tmp43);
            										}
            									}
            								}
            							}
            						}
HXDLIN(  42)						{
HXLINE(  42)							 ::pi_xy::ImageStruct this186 = this149;
HXDLIN(  42)							{
HXLINE(  42)								int r_x4 = ::Std_obj::_hx_int((dx4 - ((Float)6.)));
HXDLIN(  42)								int r_y4 = ::Std_obj::_hx_int((dy4 - ((Float)6.)));
HXDLIN(  42)								int r_w4 = 12;
HXDLIN(  42)								int r_h4 = 12;
HXDLIN(  42)								int xmax4 = ((r_x4 + r_w4) + 1);
HXDLIN(  42)								int ymax4 = ((r_y4 + r_h4) + 1);
HXDLIN(  42)								int ii_min40 = r_x4;
HXDLIN(  42)								int ii_max40 = xmax4;
HXDLIN(  42)								int xRange__start4 = ii_min40;
HXDLIN(  42)								int xRange__max4 = ii_max40;
HXDLIN(  42)								int ii_min41 = r_y4;
HXDLIN(  42)								int ii_max41 = ymax4;
HXDLIN(  42)								int yRange__start4 = ii_min41;
HXDLIN(  42)								int yRange__max4 = ii_max41;
HXDLIN(  42)								int range_x4 = xRange__start4;
HXDLIN(  42)								int range_y4 = (yRange__start4 - 1);
HXDLIN(  42)								int range_xReset4 = range_x4;
HXDLIN(  42)								int range_yReset4 = range_y4;
HXDLIN(  42)								int range_xMax4 = (xRange__max4 - 2);
HXDLIN(  42)								int range_yMax4 = (yRange__max4 - 2);
HXDLIN(  42)								int _this_min4 = 0;
HXDLIN(  42)								int _this_max4 = ::Std_obj::_hx_int(( (Float)(((xRange__max4 - xRange__start4) * (yRange__max4 - yRange__start4))) ));
HXDLIN(  42)								while((_this_min4 < _this_max4)){
HXLINE(  42)									_this_min4 = (_this_min4 + 1);
HXDLIN(  42)									int i32 = (_this_min4 - 1);
HXDLIN(  42)									if ((range_y4 > range_yMax4)) {
HXLINE(  42)										range_y4 = range_yReset4;
HXDLIN(  42)										range_x4 = (range_x4 + 1);
            									}
HXDLIN(  42)									range_y4 = (range_y4 + 1);
HXDLIN(  42)									int i33 = i32;
HXDLIN(  42)									{
HXLINE(  42)										int x20 = range_x4;
HXDLIN(  42)										int y21 = range_y4;
HXDLIN(  42)										int c20 = -1048336;
HXDLIN(  42)										bool _hx_tmp44;
HXDLIN(  42)										if ((((c20 >> 24) & 255) < 254)) {
HXLINE(  42)											_hx_tmp44 = this186->transparent;
            										}
            										else {
HXLINE(  42)											_hx_tmp44 = false;
            										}
HXDLIN(  42)										if (_hx_tmp44) {
HXLINE(  42)											int location12;
HXDLIN(  42)											if (this186->useVirtualPos) {
HXLINE(  42)												location12 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - this186->virtualY) * ( (Float)(this186->width) )) + x20) - this186->virtualX));
            											}
            											else {
HXLINE(  42)												location12 = ::Std_obj::_hx_int(( (Float)(((y21 * this186->width) + x20)) ));
            											}
HXDLIN(  42)											int this187 = ::iterMagic::Iimg_obj::get(this186->image,location12);
HXDLIN(  42)											int this188;
HXDLIN(  42)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  42)												this188 = ((((((this187 >> 24) & 255) << 24) | ((this187 & 255) << 16)) | (((this187 >> 8) & 255) << 8)) | ((this187 >> 16) & 255));
            											}
            											else {
HXLINE(  42)												this188 = this187;
            											}
HXDLIN(  42)											Float a115;
HXDLIN(  42)											int this189 = ((this188 >> 24) & 255);
HXDLIN(  42)											if ((this189 == 0)) {
HXLINE(  42)												a115 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												a115 = (( (Float)(this189) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float r112;
HXDLIN(  42)											int this190 = ((this188 >> 16) & 255);
HXDLIN(  42)											if ((this190 == 0)) {
HXLINE(  42)												r112 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												r112 = (( (Float)(this190) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float g112;
HXDLIN(  42)											int this191 = ((this188 >> 8) & 255);
HXDLIN(  42)											if ((this191 == 0)) {
HXLINE(  42)												g112 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												g112 = (( (Float)(this191) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float b117;
HXDLIN(  42)											int this192 = (this188 & 255);
HXDLIN(  42)											if ((this192 == 0)) {
HXLINE(  42)												b117 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												b117 = (( (Float)(this192) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float a213;
HXDLIN(  42)											int this193 = ((-1048336 >> 24) & 255);
HXDLIN(  42)											if ((this193 == 0)) {
HXLINE(  42)												a213 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												a213 = (( (Float)(this193) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float r212;
HXDLIN(  42)											int this194 = ((-1048336 >> 16) & 255);
HXDLIN(  42)											if ((this194 == 0)) {
HXLINE(  42)												r212 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												r212 = (( (Float)(this194) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float g212;
HXDLIN(  42)											int this195 = ((-1048336 >> 8) & 255);
HXDLIN(  42)											if ((this195 == 0)) {
HXLINE(  42)												g212 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												g212 = (( (Float)(this195) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float b215;
HXDLIN(  42)											int this196 = (-1048336 & 255);
HXDLIN(  42)											if ((this196 == 0)) {
HXLINE(  42)												b215 = ((Float)0.);
            											}
            											else {
HXLINE(  42)												b215 = (( (Float)(this196) ) / ( (Float)(255) ));
            											}
HXDLIN(  42)											Float a312 = (a115 * (( (Float)(1) ) - a213));
HXDLIN(  42)											int r32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r112 * a312) + (r212 * a213))));
HXDLIN(  42)											int g32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g112 * a312) + (g212 * a213))));
HXDLIN(  42)											int b36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b117 * a312) + (b215 * a213))));
HXDLIN(  42)											int a43 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a213)));
HXDLIN(  42)											int blended12 = ((((a43 << 24) | (r32 << 16)) | (g32 << 8)) | b36);
HXDLIN(  42)											{
HXLINE(  42)												int _hx_tmp45;
HXDLIN(  42)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  42)													_hx_tmp45 = ((((((blended12 >> 24) & 255) << 24) | ((blended12 & 255) << 16)) | (((blended12 >> 8) & 255) << 8)) | ((blended12 >> 16) & 255));
            												}
            												else {
HXLINE(  42)													_hx_tmp45 = blended12;
            												}
HXDLIN(  42)												::iterMagic::Iimg_obj::set(this186->image,location12,_hx_tmp45);
            											}
            										}
            										else {
HXLINE(  42)											::Dynamic this197 = this186->image;
HXDLIN(  42)											int index24;
HXDLIN(  42)											if (this186->useVirtualPos) {
HXLINE(  42)												index24 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - this186->virtualY) * ( (Float)(this186->width) )) + x20) - this186->virtualX));
            											}
            											else {
HXLINE(  42)												index24 = ::Std_obj::_hx_int(( (Float)(((y21 * this186->width) + x20)) ));
            											}
HXDLIN(  42)											int _hx_tmp46;
HXDLIN(  42)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  42)												_hx_tmp46 = ((((((c20 >> 24) & 255) << 24) | ((c20 & 255) << 16)) | (((c20 >> 8) & 255) << 8)) | ((c20 >> 16) & 255));
            											}
            											else {
HXLINE(  42)												_hx_tmp46 = c20;
            											}
HXDLIN(  42)											::iterMagic::Iimg_obj::set(this197,index24,_hx_tmp46);
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  42)					{
HXLINE(  42)						{
HXLINE(  42)							Float bx8 = bx7;
HXDLIN(  42)							Float by8 = by7;
HXDLIN(  42)							Float cx8 = dx4;
HXDLIN(  42)							Float cy8 = dy4;
HXDLIN(  42)							bool hasUndo4 = false;
HXDLIN(  42)							bool adjustWinding4 = (((((ax4 * by8) - (bx8 * ay4)) + ((bx8 * cy8) - (cx8 * by8))) + ((cx8 * ay4) - (ax4 * cy8))) > 0);
HXDLIN(  42)							if (!(adjustWinding4)) {
HXLINE(  42)								Float bx_4 = bx8;
HXDLIN(  42)								Float by_4 = by8;
HXLINE(  25)								bx8 = cx8;
HXLINE(  26)								by8 = cy8;
HXLINE(  27)								cx8 = bx_4;
HXLINE(  28)								cy8 = by_4;
            							}
HXLINE(  42)							{
HXLINE(  42)								Float s04 = ((ay4 * cx8) - (ax4 * cy8));
HXDLIN(  42)								Float sx4 = (cy8 - ay4);
HXDLIN(  42)								Float sy4 = (ax4 - cx8);
HXDLIN(  42)								Float t04 = ((ax4 * by8) - (ay4 * bx8));
HXDLIN(  42)								Float tx4 = (ay4 - by8);
HXDLIN(  42)								Float ty4 = (bx8 - ax4);
HXDLIN(  42)								Float A4 = ((((-(by8) * cx8) + (ay4 * (-(bx8) + cx8))) + (ax4 * (by8 - cy8))) + (bx8 * cy8));
HXDLIN(  42)								 ::pi_xy::iter::IntIterStart xIter34;
HXDLIN(  42)								if ((ax4 > bx8)) {
HXLINE(  42)									if ((ax4 > cx8)) {
HXLINE(  42)										int min16;
HXDLIN(  42)										if ((bx8 > cx8)) {
HXLINE(  42)											min16 = ::Math_obj::floor(cx8);
            										}
            										else {
HXLINE(  42)											min16 = ::Math_obj::floor(bx8);
            										}
HXDLIN(  42)										int ii_min42 = min16;
HXDLIN(  42)										int ii_max42 = ::Math_obj::ceil(ax4);
HXDLIN(  42)										xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min42,ii_max42);
            									}
            									else {
HXLINE(  42)										int ii_min43 = ::Math_obj::floor(bx8);
HXDLIN(  42)										int ii_max43 = ::Math_obj::ceil(cx8);
HXDLIN(  42)										xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min43,ii_max43);
            									}
            								}
            								else {
HXLINE(  42)									if ((bx8 > cx8)) {
HXLINE(  42)										int min17;
HXDLIN(  42)										if ((ax4 > cx8)) {
HXLINE(  42)											min17 = ::Math_obj::floor(cx8);
            										}
            										else {
HXLINE(  42)											min17 = ::Math_obj::ceil(ax4);
            										}
HXDLIN(  42)										int ii_min44 = min17;
HXDLIN(  42)										int ii_max44 = ::Math_obj::ceil(bx8);
HXDLIN(  42)										xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min44,ii_max44);
            									}
            									else {
HXLINE(  42)										int ii_min45 = ::Math_obj::floor(ax4);
HXDLIN(  42)										int ii_max45 = ::Math_obj::ceil(cx8);
HXDLIN(  42)										xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min45,ii_max45);
            									}
            								}
HXDLIN(  42)								 ::pi_xy::iter::IntIterStart yIter34;
HXDLIN(  42)								if ((ay4 > by8)) {
HXLINE(  42)									if ((ay4 > cy8)) {
HXLINE(  42)										int min18;
HXDLIN(  42)										if ((by8 > cy8)) {
HXLINE(  42)											min18 = ::Math_obj::floor(cy8);
            										}
            										else {
HXLINE(  42)											min18 = ::Math_obj::floor(by8);
            										}
HXDLIN(  42)										int ii_min46 = min18;
HXDLIN(  42)										int ii_max46 = ::Math_obj::ceil(ay4);
HXDLIN(  42)										yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min46,ii_max46);
            									}
            									else {
HXLINE(  42)										int ii_min47 = ::Math_obj::floor(by8);
HXDLIN(  42)										int ii_max47 = ::Math_obj::ceil(cy8);
HXDLIN(  42)										yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min47,ii_max47);
            									}
            								}
            								else {
HXLINE(  42)									if ((by8 > cy8)) {
HXLINE(  42)										int min19;
HXDLIN(  42)										if ((ay4 > cy8)) {
HXLINE(  42)											min19 = ::Math_obj::floor(cy8);
            										}
            										else {
HXLINE(  42)											min19 = ::Math_obj::ceil(ay4);
            										}
HXDLIN(  42)										int ii_min48 = min19;
HXDLIN(  42)										int ii_max48 = ::Math_obj::ceil(by8);
HXDLIN(  42)										yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min48,ii_max48);
            									}
            									else {
HXLINE(  42)										int ii_min49 = ::Math_obj::floor(ay4);
HXDLIN(  42)										int ii_max49 = ::Math_obj::ceil(cy8);
HXDLIN(  42)										yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min49,ii_max49);
            									}
            								}
HXDLIN(  42)								 ::pi_xy::ImageStruct undoImage12 = null();
HXDLIN(  42)								if (hasUndo4) {
HXLINE(  42)									int width4 = ((xIter34->max - xIter34->start) + 1);
HXDLIN(  42)									int height4 = ((yIter34->max - yIter34->start) + 1);
HXDLIN(  42)									 ::Dynamic imageType4 = null();
HXDLIN(  42)									 ::pi_xy::ImageStruct this198 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  42)									if (::hx::IsNull( imageType4 )) {
HXLINE(  54)										imageType4 = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE(  42)									::Dynamic undoImage13;
HXDLIN(  42)									switch((int)(( (int)(imageType4) ))){
            										case (int)0: {
HXLINE(  42)											 ::iterMagic::BytesImg byt4 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  42)											 ::iterMagic::BytesImg b37 = byt4;
HXDLIN(  42)											{
HXLINE(  42)												b37->width = width4;
HXDLIN(  42)												b37->height = height4;
HXDLIN(  42)												b37->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN(  42)												b37->data = ::haxe::io::Bytes_obj::alloc((b37->length * 4));
HXDLIN(  42)												{
HXLINE(  42)													int len8 = b37->length;
HXDLIN(  42)													int w4 = 0;
HXDLIN(  42)													{
HXLINE(  42)														int _g80 = 0;
HXDLIN(  42)														int _g81 = b37->height;
HXDLIN(  42)														while((_g80 < _g81)){
HXLINE(  42)															_g80 = (_g80 + 1);
HXDLIN(  42)															int y22 = (_g80 - 1);
HXDLIN(  42)															{
HXLINE(  42)																int _g82 = 0;
HXDLIN(  42)																int _g83 = b37->width;
HXDLIN(  42)																while((_g82 < _g83)){
HXLINE(  42)																	_g82 = (_g82 + 1);
HXDLIN(  42)																	int x21 = (_g82 - 1);
HXDLIN(  42)																	{
HXLINE(  42)																		w4 = (w4 + 1);
HXDLIN(  42)																		b37->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  42)																	{
HXLINE(  42)																		w4 = (w4 + 1);
HXDLIN(  42)																		b37->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  42)																	{
HXLINE(  42)																		w4 = (w4 + 1);
HXDLIN(  42)																		b37->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  42)																	{
HXLINE(  42)																		w4 = (w4 + 1);
HXDLIN(  42)																		b37->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  42)											undoImage13 = b37;
            										}
            										break;
            										case (int)1: {
HXLINE(  42)											 ::iterMagic::ArrIntImg arrI4 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  42)											 ::iterMagic::ArrIntImg a44 = arrI4;
HXDLIN(  42)											{
HXLINE(  42)												a44->width = width4;
HXDLIN(  42)												a44->height = height4;
HXDLIN(  42)												a44->data = ::Array_obj< int >::__new(0);
HXDLIN(  42)												a44->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN(  42)												{
HXLINE(  42)													int _g84 = 0;
HXDLIN(  42)													int _g85 = a44->length;
HXDLIN(  42)													while((_g84 < _g85)){
HXLINE(  42)														_g84 = (_g84 + 1);
HXDLIN(  42)														int i34 = (_g84 - 1);
HXDLIN(  42)														a44->data[i34] = 0;
            													}
            												}
            											}
HXDLIN(  42)											undoImage13 = a44;
            										}
            										break;
            										case (int)2: {
HXLINE(  42)											 ::iterMagic::U32ArrImg u32a4 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  42)											 ::iterMagic::U32ArrImg b38 = u32a4;
HXDLIN(  42)											{
HXLINE(  42)												b38->width = width4;
HXDLIN(  42)												b38->height = height4;
HXDLIN(  42)												b38->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN(  42)												int size4 = (b38->length * 4);
HXDLIN(  42)												b38->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size4),0,size4);
HXDLIN(  42)												{
HXLINE(  42)													int _g86 = 0;
HXDLIN(  42)													int _g87 = b38->length;
HXDLIN(  42)													while((_g86 < _g87)){
HXLINE(  42)														_g86 = (_g86 + 1);
HXDLIN(  42)														int i35 = (_g86 - 1);
HXDLIN(  42)														{
HXLINE(  42)															 ::haxe::io::ArrayBufferViewImpl this199 = b38->data;
HXDLIN(  42)															bool undoImage14;
HXDLIN(  42)															if ((i35 >= 0)) {
HXLINE(  42)																undoImage14 = (i35 < (this199->byteLength >> 2));
            															}
            															else {
HXLINE(  42)																undoImage14 = false;
            															}
HXDLIN(  42)															if (undoImage14) {
HXLINE(  42)																 ::haxe::io::Bytes _this4 = this199->bytes;
HXDLIN(  42)																int pos4 = ((i35 << 2) + this199->byteOffset);
HXDLIN(  42)																_this4->b[pos4] = ( (unsigned char)(0) );
HXDLIN(  42)																_this4->b[(pos4 + 1)] = ( (unsigned char)(0) );
HXDLIN(  42)																_this4->b[(pos4 + 2)] = ( (unsigned char)(0) );
HXDLIN(  42)																_this4->b[(pos4 + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN(  42)											undoImage13 = b38;
            										}
            										break;
            										case (int)3: {
HXLINE(  42)											 ::iterMagic::VecIntImg vec4 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  42)											 ::iterMagic::VecIntImg v12 = vec4;
HXDLIN(  42)											{
HXLINE(  42)												v12->width = width4;
HXDLIN(  42)												v12->height = height4;
HXDLIN(  42)												v12->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN(  42)												v12->data = ::Array_obj< int >::__new(v12->length);
HXDLIN(  42)												{
HXLINE(  42)													int _g88 = 0;
HXDLIN(  42)													int _g89 = v12->length;
HXDLIN(  42)													while((_g88 < _g89)){
HXLINE(  42)														_g88 = (_g88 + 1);
HXDLIN(  42)														int i36 = (_g88 - 1);
HXDLIN(  42)														v12->data->__unsafe_set(i36,0);
            													}
            												}
            											}
HXDLIN(  42)											undoImage13 = v12;
            										}
            										break;
            										case (int)4: {
HXLINE(  42)											 ::iterMagic::StackIntImg sInt4 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  42)											 ::iterMagic::StackIntImg b39 = sInt4;
HXDLIN(  42)											{
HXLINE(  42)												b39->width = width4;
HXDLIN(  42)												b39->height = height4;
HXDLIN(  42)												b39->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN(  42)												b39->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  42)												{
HXLINE(  42)													int len9 = b39->length;
HXDLIN(  42)													 ::haxe::ds::GenericStack_Int d5 = b39->data;
HXDLIN(  42)													if (::hx::IsNull( d5->head )) {
HXLINE(  42)														int _g90 = 0;
HXDLIN(  42)														int _g91 = len9;
HXDLIN(  42)														while((_g90 < _g91)){
HXLINE(  42)															_g90 = (_g90 + 1);
HXDLIN(  42)															int i37 = (_g90 - 1);
HXDLIN(  42)															d5->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d5->head);
            														}
            													}
            													else {
HXLINE(  42)														int _g92 = 0;
HXDLIN(  42)														int _g93 = len9;
HXDLIN(  42)														while((_g92 < _g93)){
HXLINE(  42)															_g92 = (_g92 + 1);
HXDLIN(  42)															int i38 = (_g92 - 1);
HXDLIN(  42)															{
HXLINE(  42)																 ::haxe::ds::GenericCell_Int l4 = b39->data->head;
HXDLIN(  42)																 ::haxe::ds::GenericCell_Int prev4 = null();
HXDLIN(  42)																{
HXLINE(  42)																	int _g94 = 0;
HXDLIN(  42)																	int _g95 = i38;
HXDLIN(  42)																	while((_g94 < _g95)){
HXLINE(  42)																		_g94 = (_g94 + 1);
HXDLIN(  42)																		int i39 = (_g94 - 1);
HXLINE( 345)																		prev4 = l4;
HXLINE( 346)																		l4 = l4->next;
            																	}
            																}
HXLINE(  42)																if (::hx::IsNull( prev4 )) {
HXLINE(  42)																	b39->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN(  42)																	l4 = null();
            																}
            																else {
HXLINE(  42)																	prev4->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN(  42)																	l4 = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  42)											undoImage13 = b39;
            										}
            										break;
            									}
HXDLIN(  42)									this198->image = undoImage13;
HXDLIN(  42)									this198->width = width4;
HXDLIN(  42)									this198->height = height4;
HXDLIN(  42)									this198->imageType = ( (int)(imageType4) );
HXDLIN(  42)									undoImage12 = this198;
HXDLIN(  42)									{
HXLINE(  42)										int rectLeft4 = xIter34->start;
HXDLIN(  42)										int rectTop4 = yIter34->start;
HXDLIN(  42)										int rectRight4 = xIter34->max;
HXDLIN(  42)										bool forceClear4 = false;
HXDLIN(  42)										{
HXLINE(  42)											int _g96 = rectTop4;
HXDLIN(  42)											int _g97 = yIter34->max;
HXDLIN(  42)											while((_g96 < _g97)){
HXLINE(  42)												_g96 = (_g96 + 1);
HXDLIN(  42)												int dy5 = (_g96 - 1);
HXDLIN(  42)												{
HXLINE(  42)													int _g98 = rectLeft4;
HXDLIN(  42)													int _g99 = rectRight4;
HXDLIN(  42)													while((_g98 < _g99)){
HXLINE(  42)														_g98 = (_g98 + 1);
HXDLIN(  42)														int dx5 = (_g98 - 1);
HXDLIN(  42)														::Dynamic this200 = this149->image;
HXDLIN(  42)														int index25;
HXDLIN(  42)														if (this149->useVirtualPos) {
HXLINE(  42)															index25 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this149->virtualY) * ( (Float)(this149->width) )) + dx5) - this149->virtualX));
            														}
            														else {
HXLINE(  42)															index25 = ::Std_obj::_hx_int(( (Float)(((dy5 * this149->width) + dx5)) ));
            														}
HXDLIN(  42)														int c21 = ::iterMagic::Iimg_obj::get(this200,index25);
HXDLIN(  42)														int col4;
HXDLIN(  42)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  42)															col4 = ((((((c21 >> 24) & 255) << 24) | ((c21 & 255) << 16)) | (((c21 >> 8) & 255) << 8)) | ((c21 >> 16) & 255));
            														}
            														else {
HXLINE(  42)															col4 = c21;
            														}
HXDLIN(  42)														bool _hx_tmp47;
HXDLIN(  42)														if (this149->useMask) {
HXLINE(  42)															_hx_tmp47 = ::hx::IsNotNull( this149->mask );
            														}
            														else {
HXLINE(  42)															_hx_tmp47 = false;
            														}
HXDLIN(  42)														if (_hx_tmp47) {
HXLINE(  42)															 ::pi_xy::ImageStruct this201 = this149->mask;
HXDLIN(  42)															::Dynamic this202 = this201->image;
HXDLIN(  42)															int index26;
HXDLIN(  42)															if (this201->useVirtualPos) {
HXLINE(  42)																index26 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this201->virtualY) * ( (Float)(this201->width) )) + dx5) - this201->virtualX));
            															}
            															else {
HXLINE(  42)																index26 = ::Std_obj::_hx_int(( (Float)(((dy5 * this201->width) + dx5)) ));
            															}
HXDLIN(  42)															int c22 = ::iterMagic::Iimg_obj::get(this202,index26);
HXDLIN(  42)															int v13;
HXDLIN(  42)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  42)																v13 = ((((((c22 >> 24) & 255) << 24) | ((c22 & 255) << 16)) | (((c22 >> 8) & 255) << 8)) | ((c22 >> 16) & 255));
            															}
            															else {
HXLINE(  42)																v13 = c22;
            															}
HXDLIN(  42)															int maskPixel4 = v13;
HXDLIN(  42)															int this203 = col4;
HXDLIN(  42)															if ((maskPixel4 == 0)) {
HXLINE(  42)																col4 = this203;
            															}
            															else {
HXLINE(  42)																Float m04;
HXDLIN(  42)																int this204 = ((maskPixel4 >> 24) & 255);
HXDLIN(  42)																if ((this204 == 0)) {
HXLINE(  42)																	m04 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	m04 = (( (Float)(this204) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float m14;
HXDLIN(  42)																int this205 = ((maskPixel4 >> 16) & 255);
HXDLIN(  42)																if ((this205 == 0)) {
HXLINE(  42)																	m14 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	m14 = (( (Float)(this205) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float m24;
HXDLIN(  42)																int this206 = ((maskPixel4 >> 8) & 255);
HXDLIN(  42)																if ((this206 == 0)) {
HXLINE(  42)																	m24 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	m24 = (( (Float)(this206) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float m34;
HXDLIN(  42)																int this207 = (maskPixel4 & 255);
HXDLIN(  42)																if ((this207 == 0)) {
HXLINE(  42)																	m34 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	m34 = (( (Float)(this207) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																int ch04 = ::Std_obj::_hx_int(((((Float)1.) - m04) * ( (Float)(((this203 >> 24) & 255)) )));
HXDLIN(  42)																int ch14 = ::Std_obj::_hx_int(((((Float)1.) - m14) * ( (Float)(((this203 >> 16) & 255)) )));
HXDLIN(  42)																int ch24 = ::Std_obj::_hx_int(((((Float)1.) - m24) * ( (Float)(((this203 >> 8) & 255)) )));
HXDLIN(  42)																int ch34 = ::Std_obj::_hx_int(((((Float)1.) - m34) * ( (Float)((this203 & 255)) )));
HXDLIN(  42)																col4 = ((((::Math_obj::round((( (Float)(ch04) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch14) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch24) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch34) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  42)														if ((col4 != 0)) {
HXLINE(  42)															int x22 = (dx5 - rectLeft4);
HXDLIN(  42)															int y23 = (dy5 - rectTop4);
HXDLIN(  42)															int c23 = col4;
HXDLIN(  42)															bool _hx_tmp48;
HXDLIN(  42)															if ((((c23 >> 24) & 255) < 254)) {
HXLINE(  42)																_hx_tmp48 = undoImage12->transparent;
            															}
            															else {
HXLINE(  42)																_hx_tmp48 = false;
            															}
HXDLIN(  42)															if (_hx_tmp48) {
HXLINE(  42)																int location13;
HXDLIN(  42)																if (undoImage12->useVirtualPos) {
HXLINE(  42)																	location13 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x22) - undoImage12->virtualX));
            																}
            																else {
HXLINE(  42)																	location13 = ::Std_obj::_hx_int(( (Float)(((y23 * undoImage12->width) + x22)) ));
            																}
HXDLIN(  42)																int this208 = ::iterMagic::Iimg_obj::get(undoImage12->image,location13);
HXDLIN(  42)																int this209;
HXDLIN(  42)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  42)																	this209 = ((((((this208 >> 24) & 255) << 24) | ((this208 & 255) << 16)) | (((this208 >> 8) & 255) << 8)) | ((this208 >> 16) & 255));
            																}
            																else {
HXLINE(  42)																	this209 = this208;
            																}
HXDLIN(  42)																Float a116;
HXDLIN(  42)																int this210 = ((this209 >> 24) & 255);
HXDLIN(  42)																if ((this210 == 0)) {
HXLINE(  42)																	a116 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	a116 = (( (Float)(this210) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float r113;
HXDLIN(  42)																int this211 = ((this209 >> 16) & 255);
HXDLIN(  42)																if ((this211 == 0)) {
HXLINE(  42)																	r113 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	r113 = (( (Float)(this211) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float g113;
HXDLIN(  42)																int this212 = ((this209 >> 8) & 255);
HXDLIN(  42)																if ((this212 == 0)) {
HXLINE(  42)																	g113 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	g113 = (( (Float)(this212) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float b118;
HXDLIN(  42)																int this213 = (this209 & 255);
HXDLIN(  42)																if ((this213 == 0)) {
HXLINE(  42)																	b118 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	b118 = (( (Float)(this213) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float a214;
HXDLIN(  42)																int this214 = ((col4 >> 24) & 255);
HXDLIN(  42)																if ((this214 == 0)) {
HXLINE(  42)																	a214 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	a214 = (( (Float)(this214) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float r213;
HXDLIN(  42)																int this215 = ((col4 >> 16) & 255);
HXDLIN(  42)																if ((this215 == 0)) {
HXLINE(  42)																	r213 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	r213 = (( (Float)(this215) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float g213;
HXDLIN(  42)																int this216 = ((col4 >> 8) & 255);
HXDLIN(  42)																if ((this216 == 0)) {
HXLINE(  42)																	g213 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	g213 = (( (Float)(this216) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float b216;
HXDLIN(  42)																int this217 = (col4 & 255);
HXDLIN(  42)																if ((this217 == 0)) {
HXLINE(  42)																	b216 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	b216 = (( (Float)(this217) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float a313 = (a116 * (( (Float)(1) ) - a214));
HXDLIN(  42)																int r33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r113 * a313) + (r213 * a214))));
HXDLIN(  42)																int g33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g113 * a313) + (g213 * a214))));
HXDLIN(  42)																int b40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b118 * a313) + (b216 * a214))));
HXDLIN(  42)																int a45 = ::Std_obj::_hx_int((( (Float)(255) ) * (a313 + a214)));
HXDLIN(  42)																int blended13 = ((((a45 << 24) | (r33 << 16)) | (g33 << 8)) | b40);
HXDLIN(  42)																{
HXLINE(  42)																	int _hx_tmp49;
HXDLIN(  42)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  42)																		_hx_tmp49 = ((((((blended13 >> 24) & 255) << 24) | ((blended13 & 255) << 16)) | (((blended13 >> 8) & 255) << 8)) | ((blended13 >> 16) & 255));
            																	}
            																	else {
HXLINE(  42)																		_hx_tmp49 = blended13;
            																	}
HXDLIN(  42)																	::iterMagic::Iimg_obj::set(undoImage12->image,location13,_hx_tmp49);
            																}
            															}
            															else {
HXLINE(  42)																::Dynamic this218 = undoImage12->image;
HXDLIN(  42)																int index27;
HXDLIN(  42)																if (undoImage12->useVirtualPos) {
HXLINE(  42)																	index27 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x22) - undoImage12->virtualX));
            																}
            																else {
HXLINE(  42)																	index27 = ::Std_obj::_hx_int(( (Float)(((y23 * undoImage12->width) + x22)) ));
            																}
HXDLIN(  42)																int _hx_tmp50;
HXDLIN(  42)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  42)																	_hx_tmp50 = ((((((c23 >> 24) & 255) << 24) | ((c23 & 255) << 16)) | (((c23 >> 8) & 255) << 8)) | ((c23 >> 16) & 255));
            																}
            																else {
HXLINE(  42)																	_hx_tmp50 = c23;
            																}
HXDLIN(  42)																::iterMagic::Iimg_obj::set(this218,index27,_hx_tmp50);
            															}
            														}
            														else {
HXLINE(  42)															if (forceClear4) {
HXLINE(  42)																::Dynamic this219 = undoImage12->image;
HXDLIN(  42)																int x23 = (dx5 - rectLeft4);
HXDLIN(  42)																int y24 = (dy5 - rectTop4);
HXDLIN(  42)																int index28;
HXDLIN(  42)																if (undoImage12->useVirtualPos) {
HXLINE(  42)																	index28 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x23) - undoImage12->virtualX));
            																}
            																else {
HXLINE(  42)																	index28 = ::Std_obj::_hx_int(( (Float)(((y24 * undoImage12->width) + x23)) ));
            																}
HXDLIN(  42)																::iterMagic::Iimg_obj::set(this219,index28,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  42)								bool found4 = false;
HXDLIN(  42)								Float s4 = ((Float)0.);
HXDLIN(  42)								Float t4 = ((Float)0.);
HXDLIN(  42)								Float sxx4 = ((Float)0.);
HXDLIN(  42)								Float txx4 = ((Float)0.);
HXDLIN(  42)								{
HXLINE(  42)									int _g_min8 = xIter34->start;
HXDLIN(  42)									int _g_max8 = xIter34->max;
HXDLIN(  42)									while((_g_min8 < _g_max8)){
HXLINE(  42)										_g_min8 = (_g_min8 + 1);
HXDLIN(  42)										int x24 = (_g_min8 - 1);
HXLINE(  60)										sxx4 = (sx4 * ( (Float)(x24) ));
HXLINE(  61)										txx4 = (tx4 * ( (Float)(x24) ));
HXLINE(  62)										found4 = false;
HXLINE(  42)										{
HXLINE(  42)											int _g_min9 = yIter34->start;
HXDLIN(  42)											int _g_max9 = yIter34->max;
HXDLIN(  42)											while((_g_min9 < _g_max9)){
HXLINE(  42)												_g_min9 = (_g_min9 + 1);
HXDLIN(  42)												int y25 = (_g_min9 - 1);
HXLINE(  64)												s4 = ((s04 + sxx4) + (sy4 * ( (Float)(y25) )));
HXLINE(  65)												t4 = ((t04 + txx4) + (ty4 * ( (Float)(y25) )));
HXLINE(  42)												bool _hx_tmp51;
HXDLIN(  42)												if (!((s4 <= 0))) {
HXLINE(  42)													_hx_tmp51 = (t4 <= 0);
            												}
            												else {
HXLINE(  42)													_hx_tmp51 = true;
            												}
HXDLIN(  42)												if (_hx_tmp51) {
HXLINE(  42)													if (found4) {
HXLINE(  42)														goto _hx_goto_77;
            													}
            												}
            												else {
HXLINE(  42)													if (((s4 + t4) < A4)) {
HXLINE(  42)														{
HXLINE(  42)															int c24 = color3;
HXDLIN(  42)															bool _hx_tmp52;
HXDLIN(  42)															if ((((c24 >> 24) & 255) < 254)) {
HXLINE(  42)																_hx_tmp52 = this149->transparent;
            															}
            															else {
HXLINE(  42)																_hx_tmp52 = false;
            															}
HXDLIN(  42)															if (_hx_tmp52) {
HXLINE(  42)																int location14;
HXDLIN(  42)																if (this149->useVirtualPos) {
HXLINE(  42)																	location14 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - this149->virtualY) * ( (Float)(this149->width) )) + x24) - this149->virtualX));
            																}
            																else {
HXLINE(  42)																	location14 = ::Std_obj::_hx_int(( (Float)(((y25 * this149->width) + x24)) ));
            																}
HXDLIN(  42)																int this220 = ::iterMagic::Iimg_obj::get(this149->image,location14);
HXDLIN(  42)																int this221;
HXDLIN(  42)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  42)																	this221 = ((((((this220 >> 24) & 255) << 24) | ((this220 & 255) << 16)) | (((this220 >> 8) & 255) << 8)) | ((this220 >> 16) & 255));
            																}
            																else {
HXLINE(  42)																	this221 = this220;
            																}
HXDLIN(  42)																Float a117;
HXDLIN(  42)																int this222 = ((this221 >> 24) & 255);
HXDLIN(  42)																if ((this222 == 0)) {
HXLINE(  42)																	a117 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	a117 = (( (Float)(this222) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float r114;
HXDLIN(  42)																int this223 = ((this221 >> 16) & 255);
HXDLIN(  42)																if ((this223 == 0)) {
HXLINE(  42)																	r114 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	r114 = (( (Float)(this223) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float g114;
HXDLIN(  42)																int this224 = ((this221 >> 8) & 255);
HXDLIN(  42)																if ((this224 == 0)) {
HXLINE(  42)																	g114 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	g114 = (( (Float)(this224) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float b119;
HXDLIN(  42)																int this225 = (this221 & 255);
HXDLIN(  42)																if ((this225 == 0)) {
HXLINE(  42)																	b119 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	b119 = (( (Float)(this225) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float a215;
HXDLIN(  42)																int this226 = ((color3 >> 24) & 255);
HXDLIN(  42)																if ((this226 == 0)) {
HXLINE(  42)																	a215 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	a215 = (( (Float)(this226) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float r214;
HXDLIN(  42)																int this227 = ((color3 >> 16) & 255);
HXDLIN(  42)																if ((this227 == 0)) {
HXLINE(  42)																	r214 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	r214 = (( (Float)(this227) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float g214;
HXDLIN(  42)																int this228 = ((color3 >> 8) & 255);
HXDLIN(  42)																if ((this228 == 0)) {
HXLINE(  42)																	g214 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	g214 = (( (Float)(this228) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float b217;
HXDLIN(  42)																int this229 = (color3 & 255);
HXDLIN(  42)																if ((this229 == 0)) {
HXLINE(  42)																	b217 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	b217 = (( (Float)(this229) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float a314 = (a117 * (( (Float)(1) ) - a215));
HXDLIN(  42)																int r34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r114 * a314) + (r214 * a215))));
HXDLIN(  42)																int g34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g114 * a314) + (g214 * a215))));
HXDLIN(  42)																int b41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b119 * a314) + (b217 * a215))));
HXDLIN(  42)																int a46 = ::Std_obj::_hx_int((( (Float)(255) ) * (a314 + a215)));
HXDLIN(  42)																int blended14 = ((((a46 << 24) | (r34 << 16)) | (g34 << 8)) | b41);
HXDLIN(  42)																{
HXLINE(  42)																	int _hx_tmp53;
HXDLIN(  42)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  42)																		_hx_tmp53 = ((((((blended14 >> 24) & 255) << 24) | ((blended14 & 255) << 16)) | (((blended14 >> 8) & 255) << 8)) | ((blended14 >> 16) & 255));
            																	}
            																	else {
HXLINE(  42)																		_hx_tmp53 = blended14;
            																	}
HXDLIN(  42)																	::iterMagic::Iimg_obj::set(this149->image,location14,_hx_tmp53);
            																}
            															}
            															else {
HXLINE(  42)																::Dynamic this230 = this149->image;
HXDLIN(  42)																int index29;
HXDLIN(  42)																if (this149->useVirtualPos) {
HXLINE(  42)																	index29 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - this149->virtualY) * ( (Float)(this149->width) )) + x24) - this149->virtualX));
            																}
            																else {
HXLINE(  42)																	index29 = ::Std_obj::_hx_int(( (Float)(((y25 * this149->width) + x24)) ));
            																}
HXDLIN(  42)																int _hx_tmp54;
HXDLIN(  42)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  42)																	_hx_tmp54 = ((((((c24 >> 24) & 255) << 24) | ((c24 & 255) << 16)) | (((c24 >> 8) & 255) << 8)) | ((c24 >> 16) & 255));
            																}
            																else {
HXLINE(  42)																	_hx_tmp54 = c24;
            																}
HXDLIN(  42)																::iterMagic::Iimg_obj::set(this230,index29,_hx_tmp54);
            															}
            														}
HXLINE(  73)														found4 = true;
            													}
            													else {
HXLINE(  42)														if (found4) {
HXLINE(  42)															goto _hx_goto_77;
            														}
            													}
            												}
            											}
            											_hx_goto_77:;
            										}
            									}
            								}
HXDLIN(  42)								if ((hasHit4 == true)) {
HXLINE(  42)									 ::pi_xy::algo::HitTri v14 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax4,ay4,bx8,by8,cx8,cy8,true);
HXDLIN(  42)									if (hasUndo4) {
HXLINE(  42)										v14->undoImage = undoImage12;
HXDLIN(  42)										v14->undoX = xIter34->start;
HXDLIN(  42)										v14->undoY = yIter34->start;
            									}
            								}
            							}
            						}
HXDLIN(  42)						{
HXLINE(  42)							Float bx9 = cx7;
HXDLIN(  42)							Float by9 = cy7;
HXDLIN(  42)							Float cx9 = dx4;
HXDLIN(  42)							Float cy9 = dy4;
HXDLIN(  42)							bool hasUndo5 = false;
HXDLIN(  42)							bool adjustWinding5 = (((((bx7 * by9) - (bx9 * by7)) + ((bx9 * cy9) - (cx9 * by9))) + ((cx9 * by7) - (bx7 * cy9))) > 0);
HXDLIN(  42)							if (!(adjustWinding5)) {
HXLINE(  42)								Float bx_5 = bx9;
HXDLIN(  42)								Float by_5 = by9;
HXLINE(  25)								bx9 = cx9;
HXLINE(  26)								by9 = cy9;
HXLINE(  27)								cx9 = bx_5;
HXLINE(  28)								cy9 = by_5;
            							}
HXLINE(  42)							{
HXLINE(  42)								Float s05 = ((by7 * cx9) - (bx7 * cy9));
HXDLIN(  42)								Float sx5 = (cy9 - by7);
HXDLIN(  42)								Float sy5 = (bx7 - cx9);
HXDLIN(  42)								Float t05 = ((bx7 * by9) - (by7 * bx9));
HXDLIN(  42)								Float tx5 = (by7 - by9);
HXDLIN(  42)								Float ty5 = (bx9 - bx7);
HXDLIN(  42)								Float A5 = ((((-(by9) * cx9) + (by7 * (-(bx9) + cx9))) + (bx7 * (by9 - cy9))) + (bx9 * cy9));
HXDLIN(  42)								 ::pi_xy::iter::IntIterStart xIter35;
HXDLIN(  42)								if ((bx7 > bx9)) {
HXLINE(  42)									if ((bx7 > cx9)) {
HXLINE(  42)										int min20;
HXDLIN(  42)										if ((bx9 > cx9)) {
HXLINE(  42)											min20 = ::Math_obj::floor(cx9);
            										}
            										else {
HXLINE(  42)											min20 = ::Math_obj::floor(bx9);
            										}
HXDLIN(  42)										int ii_min50 = min20;
HXDLIN(  42)										int ii_max50 = ::Math_obj::ceil(bx7);
HXDLIN(  42)										xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min50,ii_max50);
            									}
            									else {
HXLINE(  42)										int ii_min51 = ::Math_obj::floor(bx9);
HXDLIN(  42)										int ii_max51 = ::Math_obj::ceil(cx9);
HXDLIN(  42)										xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min51,ii_max51);
            									}
            								}
            								else {
HXLINE(  42)									if ((bx9 > cx9)) {
HXLINE(  42)										int min21;
HXDLIN(  42)										if ((bx7 > cx9)) {
HXLINE(  42)											min21 = ::Math_obj::floor(cx9);
            										}
            										else {
HXLINE(  42)											min21 = ::Math_obj::ceil(bx7);
            										}
HXDLIN(  42)										int ii_min52 = min21;
HXDLIN(  42)										int ii_max52 = ::Math_obj::ceil(bx9);
HXDLIN(  42)										xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min52,ii_max52);
            									}
            									else {
HXLINE(  42)										int ii_min53 = ::Math_obj::floor(bx7);
HXDLIN(  42)										int ii_max53 = ::Math_obj::ceil(cx9);
HXDLIN(  42)										xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min53,ii_max53);
            									}
            								}
HXDLIN(  42)								 ::pi_xy::iter::IntIterStart yIter35;
HXDLIN(  42)								if ((by7 > by9)) {
HXLINE(  42)									if ((by7 > cy9)) {
HXLINE(  42)										int min22;
HXDLIN(  42)										if ((by9 > cy9)) {
HXLINE(  42)											min22 = ::Math_obj::floor(cy9);
            										}
            										else {
HXLINE(  42)											min22 = ::Math_obj::floor(by9);
            										}
HXDLIN(  42)										int ii_min54 = min22;
HXDLIN(  42)										int ii_max54 = ::Math_obj::ceil(by7);
HXDLIN(  42)										yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min54,ii_max54);
            									}
            									else {
HXLINE(  42)										int ii_min55 = ::Math_obj::floor(by9);
HXDLIN(  42)										int ii_max55 = ::Math_obj::ceil(cy9);
HXDLIN(  42)										yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min55,ii_max55);
            									}
            								}
            								else {
HXLINE(  42)									if ((by9 > cy9)) {
HXLINE(  42)										int min23;
HXDLIN(  42)										if ((by7 > cy9)) {
HXLINE(  42)											min23 = ::Math_obj::floor(cy9);
            										}
            										else {
HXLINE(  42)											min23 = ::Math_obj::ceil(by7);
            										}
HXDLIN(  42)										int ii_min56 = min23;
HXDLIN(  42)										int ii_max56 = ::Math_obj::ceil(by9);
HXDLIN(  42)										yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min56,ii_max56);
            									}
            									else {
HXLINE(  42)										int ii_min57 = ::Math_obj::floor(by7);
HXDLIN(  42)										int ii_max57 = ::Math_obj::ceil(cy9);
HXDLIN(  42)										yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min57,ii_max57);
            									}
            								}
HXDLIN(  42)								 ::pi_xy::ImageStruct undoImage15 = null();
HXDLIN(  42)								if (hasUndo5) {
HXLINE(  42)									int width5 = ((xIter35->max - xIter35->start) + 1);
HXDLIN(  42)									int height5 = ((yIter35->max - yIter35->start) + 1);
HXDLIN(  42)									 ::Dynamic imageType5 = null();
HXDLIN(  42)									 ::pi_xy::ImageStruct this231 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  42)									if (::hx::IsNull( imageType5 )) {
HXLINE(  54)										imageType5 = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE(  42)									::Dynamic undoImage16;
HXDLIN(  42)									switch((int)(( (int)(imageType5) ))){
            										case (int)0: {
HXLINE(  42)											 ::iterMagic::BytesImg byt5 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  42)											 ::iterMagic::BytesImg b42 = byt5;
HXDLIN(  42)											{
HXLINE(  42)												b42->width = width5;
HXDLIN(  42)												b42->height = height5;
HXDLIN(  42)												b42->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN(  42)												b42->data = ::haxe::io::Bytes_obj::alloc((b42->length * 4));
HXDLIN(  42)												{
HXLINE(  42)													int len10 = b42->length;
HXDLIN(  42)													int w5 = 0;
HXDLIN(  42)													{
HXLINE(  42)														int _g100 = 0;
HXDLIN(  42)														int _g101 = b42->height;
HXDLIN(  42)														while((_g100 < _g101)){
HXLINE(  42)															_g100 = (_g100 + 1);
HXDLIN(  42)															int y26 = (_g100 - 1);
HXDLIN(  42)															{
HXLINE(  42)																int _g102 = 0;
HXDLIN(  42)																int _g103 = b42->width;
HXDLIN(  42)																while((_g102 < _g103)){
HXLINE(  42)																	_g102 = (_g102 + 1);
HXDLIN(  42)																	int x25 = (_g102 - 1);
HXDLIN(  42)																	{
HXLINE(  42)																		w5 = (w5 + 1);
HXDLIN(  42)																		b42->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  42)																	{
HXLINE(  42)																		w5 = (w5 + 1);
HXDLIN(  42)																		b42->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  42)																	{
HXLINE(  42)																		w5 = (w5 + 1);
HXDLIN(  42)																		b42->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  42)																	{
HXLINE(  42)																		w5 = (w5 + 1);
HXDLIN(  42)																		b42->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  42)											undoImage16 = b42;
            										}
            										break;
            										case (int)1: {
HXLINE(  42)											 ::iterMagic::ArrIntImg arrI5 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  42)											 ::iterMagic::ArrIntImg a47 = arrI5;
HXDLIN(  42)											{
HXLINE(  42)												a47->width = width5;
HXDLIN(  42)												a47->height = height5;
HXDLIN(  42)												a47->data = ::Array_obj< int >::__new(0);
HXDLIN(  42)												a47->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN(  42)												{
HXLINE(  42)													int _g104 = 0;
HXDLIN(  42)													int _g105 = a47->length;
HXDLIN(  42)													while((_g104 < _g105)){
HXLINE(  42)														_g104 = (_g104 + 1);
HXDLIN(  42)														int i40 = (_g104 - 1);
HXDLIN(  42)														a47->data[i40] = 0;
            													}
            												}
            											}
HXDLIN(  42)											undoImage16 = a47;
            										}
            										break;
            										case (int)2: {
HXLINE(  42)											 ::iterMagic::U32ArrImg u32a5 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  42)											 ::iterMagic::U32ArrImg b43 = u32a5;
HXDLIN(  42)											{
HXLINE(  42)												b43->width = width5;
HXDLIN(  42)												b43->height = height5;
HXDLIN(  42)												b43->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN(  42)												int size5 = (b43->length * 4);
HXDLIN(  42)												b43->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size5),0,size5);
HXDLIN(  42)												{
HXLINE(  42)													int _g106 = 0;
HXDLIN(  42)													int _g107 = b43->length;
HXDLIN(  42)													while((_g106 < _g107)){
HXLINE(  42)														_g106 = (_g106 + 1);
HXDLIN(  42)														int i41 = (_g106 - 1);
HXDLIN(  42)														{
HXLINE(  42)															 ::haxe::io::ArrayBufferViewImpl this232 = b43->data;
HXDLIN(  42)															bool undoImage17;
HXDLIN(  42)															if ((i41 >= 0)) {
HXLINE(  42)																undoImage17 = (i41 < (this232->byteLength >> 2));
            															}
            															else {
HXLINE(  42)																undoImage17 = false;
            															}
HXDLIN(  42)															if (undoImage17) {
HXLINE(  42)																 ::haxe::io::Bytes _this5 = this232->bytes;
HXDLIN(  42)																int pos5 = ((i41 << 2) + this232->byteOffset);
HXDLIN(  42)																_this5->b[pos5] = ( (unsigned char)(0) );
HXDLIN(  42)																_this5->b[(pos5 + 1)] = ( (unsigned char)(0) );
HXDLIN(  42)																_this5->b[(pos5 + 2)] = ( (unsigned char)(0) );
HXDLIN(  42)																_this5->b[(pos5 + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN(  42)											undoImage16 = b43;
            										}
            										break;
            										case (int)3: {
HXLINE(  42)											 ::iterMagic::VecIntImg vec5 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  42)											 ::iterMagic::VecIntImg v15 = vec5;
HXDLIN(  42)											{
HXLINE(  42)												v15->width = width5;
HXDLIN(  42)												v15->height = height5;
HXDLIN(  42)												v15->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN(  42)												v15->data = ::Array_obj< int >::__new(v15->length);
HXDLIN(  42)												{
HXLINE(  42)													int _g108 = 0;
HXDLIN(  42)													int _g109 = v15->length;
HXDLIN(  42)													while((_g108 < _g109)){
HXLINE(  42)														_g108 = (_g108 + 1);
HXDLIN(  42)														int i42 = (_g108 - 1);
HXDLIN(  42)														v15->data->__unsafe_set(i42,0);
            													}
            												}
            											}
HXDLIN(  42)											undoImage16 = v15;
            										}
            										break;
            										case (int)4: {
HXLINE(  42)											 ::iterMagic::StackIntImg sInt5 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  42)											 ::iterMagic::StackIntImg b44 = sInt5;
HXDLIN(  42)											{
HXLINE(  42)												b44->width = width5;
HXDLIN(  42)												b44->height = height5;
HXDLIN(  42)												b44->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN(  42)												b44->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  42)												{
HXLINE(  42)													int len11 = b44->length;
HXDLIN(  42)													 ::haxe::ds::GenericStack_Int d6 = b44->data;
HXDLIN(  42)													if (::hx::IsNull( d6->head )) {
HXLINE(  42)														int _g110 = 0;
HXDLIN(  42)														int _g111 = len11;
HXDLIN(  42)														while((_g110 < _g111)){
HXLINE(  42)															_g110 = (_g110 + 1);
HXDLIN(  42)															int i43 = (_g110 - 1);
HXDLIN(  42)															d6->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d6->head);
            														}
            													}
            													else {
HXLINE(  42)														int _g112 = 0;
HXDLIN(  42)														int _g113 = len11;
HXDLIN(  42)														while((_g112 < _g113)){
HXLINE(  42)															_g112 = (_g112 + 1);
HXDLIN(  42)															int i44 = (_g112 - 1);
HXDLIN(  42)															{
HXLINE(  42)																 ::haxe::ds::GenericCell_Int l5 = b44->data->head;
HXDLIN(  42)																 ::haxe::ds::GenericCell_Int prev5 = null();
HXDLIN(  42)																{
HXLINE(  42)																	int _g114 = 0;
HXDLIN(  42)																	int _g115 = i44;
HXDLIN(  42)																	while((_g114 < _g115)){
HXLINE(  42)																		_g114 = (_g114 + 1);
HXDLIN(  42)																		int i45 = (_g114 - 1);
HXLINE( 345)																		prev5 = l5;
HXLINE( 346)																		l5 = l5->next;
            																	}
            																}
HXLINE(  42)																if (::hx::IsNull( prev5 )) {
HXLINE(  42)																	b44->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN(  42)																	l5 = null();
            																}
            																else {
HXLINE(  42)																	prev5->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN(  42)																	l5 = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  42)											undoImage16 = b44;
            										}
            										break;
            									}
HXDLIN(  42)									this231->image = undoImage16;
HXDLIN(  42)									this231->width = width5;
HXDLIN(  42)									this231->height = height5;
HXDLIN(  42)									this231->imageType = ( (int)(imageType5) );
HXDLIN(  42)									undoImage15 = this231;
HXDLIN(  42)									{
HXLINE(  42)										int rectLeft5 = xIter35->start;
HXDLIN(  42)										int rectTop5 = yIter35->start;
HXDLIN(  42)										int rectRight5 = xIter35->max;
HXDLIN(  42)										bool forceClear5 = false;
HXDLIN(  42)										{
HXLINE(  42)											int _g116 = rectTop5;
HXDLIN(  42)											int _g117 = yIter35->max;
HXDLIN(  42)											while((_g116 < _g117)){
HXLINE(  42)												_g116 = (_g116 + 1);
HXDLIN(  42)												int dy6 = (_g116 - 1);
HXDLIN(  42)												{
HXLINE(  42)													int _g118 = rectLeft5;
HXDLIN(  42)													int _g119 = rectRight5;
HXDLIN(  42)													while((_g118 < _g119)){
HXLINE(  42)														_g118 = (_g118 + 1);
HXDLIN(  42)														int dx6 = (_g118 - 1);
HXDLIN(  42)														::Dynamic this233 = this149->image;
HXDLIN(  42)														int index30;
HXDLIN(  42)														if (this149->useVirtualPos) {
HXLINE(  42)															index30 = ::Std_obj::_hx_int(((((( (Float)(dy6) ) - this149->virtualY) * ( (Float)(this149->width) )) + dx6) - this149->virtualX));
            														}
            														else {
HXLINE(  42)															index30 = ::Std_obj::_hx_int(( (Float)(((dy6 * this149->width) + dx6)) ));
            														}
HXDLIN(  42)														int c25 = ::iterMagic::Iimg_obj::get(this233,index30);
HXDLIN(  42)														int col5;
HXDLIN(  42)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  42)															col5 = ((((((c25 >> 24) & 255) << 24) | ((c25 & 255) << 16)) | (((c25 >> 8) & 255) << 8)) | ((c25 >> 16) & 255));
            														}
            														else {
HXLINE(  42)															col5 = c25;
            														}
HXDLIN(  42)														bool _hx_tmp55;
HXDLIN(  42)														if (this149->useMask) {
HXLINE(  42)															_hx_tmp55 = ::hx::IsNotNull( this149->mask );
            														}
            														else {
HXLINE(  42)															_hx_tmp55 = false;
            														}
HXDLIN(  42)														if (_hx_tmp55) {
HXLINE(  42)															 ::pi_xy::ImageStruct this234 = this149->mask;
HXDLIN(  42)															::Dynamic this235 = this234->image;
HXDLIN(  42)															int index31;
HXDLIN(  42)															if (this234->useVirtualPos) {
HXLINE(  42)																index31 = ::Std_obj::_hx_int(((((( (Float)(dy6) ) - this234->virtualY) * ( (Float)(this234->width) )) + dx6) - this234->virtualX));
            															}
            															else {
HXLINE(  42)																index31 = ::Std_obj::_hx_int(( (Float)(((dy6 * this234->width) + dx6)) ));
            															}
HXDLIN(  42)															int c26 = ::iterMagic::Iimg_obj::get(this235,index31);
HXDLIN(  42)															int v16;
HXDLIN(  42)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  42)																v16 = ((((((c26 >> 24) & 255) << 24) | ((c26 & 255) << 16)) | (((c26 >> 8) & 255) << 8)) | ((c26 >> 16) & 255));
            															}
            															else {
HXLINE(  42)																v16 = c26;
            															}
HXDLIN(  42)															int maskPixel5 = v16;
HXDLIN(  42)															int this236 = col5;
HXDLIN(  42)															if ((maskPixel5 == 0)) {
HXLINE(  42)																col5 = this236;
            															}
            															else {
HXLINE(  42)																Float m05;
HXDLIN(  42)																int this237 = ((maskPixel5 >> 24) & 255);
HXDLIN(  42)																if ((this237 == 0)) {
HXLINE(  42)																	m05 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	m05 = (( (Float)(this237) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float m15;
HXDLIN(  42)																int this238 = ((maskPixel5 >> 16) & 255);
HXDLIN(  42)																if ((this238 == 0)) {
HXLINE(  42)																	m15 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	m15 = (( (Float)(this238) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float m25;
HXDLIN(  42)																int this239 = ((maskPixel5 >> 8) & 255);
HXDLIN(  42)																if ((this239 == 0)) {
HXLINE(  42)																	m25 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	m25 = (( (Float)(this239) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float m35;
HXDLIN(  42)																int this240 = (maskPixel5 & 255);
HXDLIN(  42)																if ((this240 == 0)) {
HXLINE(  42)																	m35 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	m35 = (( (Float)(this240) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																int ch05 = ::Std_obj::_hx_int(((((Float)1.) - m05) * ( (Float)(((this236 >> 24) & 255)) )));
HXDLIN(  42)																int ch15 = ::Std_obj::_hx_int(((((Float)1.) - m15) * ( (Float)(((this236 >> 16) & 255)) )));
HXDLIN(  42)																int ch25 = ::Std_obj::_hx_int(((((Float)1.) - m25) * ( (Float)(((this236 >> 8) & 255)) )));
HXDLIN(  42)																int ch35 = ::Std_obj::_hx_int(((((Float)1.) - m35) * ( (Float)((this236 & 255)) )));
HXDLIN(  42)																col5 = ((((::Math_obj::round((( (Float)(ch05) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch15) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch25) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch35) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  42)														if ((col5 != 0)) {
HXLINE(  42)															int x26 = (dx6 - rectLeft5);
HXDLIN(  42)															int y27 = (dy6 - rectTop5);
HXDLIN(  42)															int c27 = col5;
HXDLIN(  42)															bool _hx_tmp56;
HXDLIN(  42)															if ((((c27 >> 24) & 255) < 254)) {
HXLINE(  42)																_hx_tmp56 = undoImage15->transparent;
            															}
            															else {
HXLINE(  42)																_hx_tmp56 = false;
            															}
HXDLIN(  42)															if (_hx_tmp56) {
HXLINE(  42)																int location15;
HXDLIN(  42)																if (undoImage15->useVirtualPos) {
HXLINE(  42)																	location15 = ::Std_obj::_hx_int(((((( (Float)(y27) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x26) - undoImage15->virtualX));
            																}
            																else {
HXLINE(  42)																	location15 = ::Std_obj::_hx_int(( (Float)(((y27 * undoImage15->width) + x26)) ));
            																}
HXDLIN(  42)																int this241 = ::iterMagic::Iimg_obj::get(undoImage15->image,location15);
HXDLIN(  42)																int this242;
HXDLIN(  42)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  42)																	this242 = ((((((this241 >> 24) & 255) << 24) | ((this241 & 255) << 16)) | (((this241 >> 8) & 255) << 8)) | ((this241 >> 16) & 255));
            																}
            																else {
HXLINE(  42)																	this242 = this241;
            																}
HXDLIN(  42)																Float a118;
HXDLIN(  42)																int this243 = ((this242 >> 24) & 255);
HXDLIN(  42)																if ((this243 == 0)) {
HXLINE(  42)																	a118 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	a118 = (( (Float)(this243) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float r115;
HXDLIN(  42)																int this244 = ((this242 >> 16) & 255);
HXDLIN(  42)																if ((this244 == 0)) {
HXLINE(  42)																	r115 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	r115 = (( (Float)(this244) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float g115;
HXDLIN(  42)																int this245 = ((this242 >> 8) & 255);
HXDLIN(  42)																if ((this245 == 0)) {
HXLINE(  42)																	g115 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	g115 = (( (Float)(this245) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float b120;
HXDLIN(  42)																int this246 = (this242 & 255);
HXDLIN(  42)																if ((this246 == 0)) {
HXLINE(  42)																	b120 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	b120 = (( (Float)(this246) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float a216;
HXDLIN(  42)																int this247 = ((col5 >> 24) & 255);
HXDLIN(  42)																if ((this247 == 0)) {
HXLINE(  42)																	a216 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	a216 = (( (Float)(this247) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float r215;
HXDLIN(  42)																int this248 = ((col5 >> 16) & 255);
HXDLIN(  42)																if ((this248 == 0)) {
HXLINE(  42)																	r215 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	r215 = (( (Float)(this248) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float g215;
HXDLIN(  42)																int this249 = ((col5 >> 8) & 255);
HXDLIN(  42)																if ((this249 == 0)) {
HXLINE(  42)																	g215 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	g215 = (( (Float)(this249) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float b218;
HXDLIN(  42)																int this250 = (col5 & 255);
HXDLIN(  42)																if ((this250 == 0)) {
HXLINE(  42)																	b218 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	b218 = (( (Float)(this250) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float a315 = (a118 * (( (Float)(1) ) - a216));
HXDLIN(  42)																int r35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r115 * a315) + (r215 * a216))));
HXDLIN(  42)																int g35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g115 * a315) + (g215 * a216))));
HXDLIN(  42)																int b45 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b120 * a315) + (b218 * a216))));
HXDLIN(  42)																int a48 = ::Std_obj::_hx_int((( (Float)(255) ) * (a315 + a216)));
HXDLIN(  42)																int blended15 = ((((a48 << 24) | (r35 << 16)) | (g35 << 8)) | b45);
HXDLIN(  42)																{
HXLINE(  42)																	int _hx_tmp57;
HXDLIN(  42)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  42)																		_hx_tmp57 = ((((((blended15 >> 24) & 255) << 24) | ((blended15 & 255) << 16)) | (((blended15 >> 8) & 255) << 8)) | ((blended15 >> 16) & 255));
            																	}
            																	else {
HXLINE(  42)																		_hx_tmp57 = blended15;
            																	}
HXDLIN(  42)																	::iterMagic::Iimg_obj::set(undoImage15->image,location15,_hx_tmp57);
            																}
            															}
            															else {
HXLINE(  42)																::Dynamic this251 = undoImage15->image;
HXDLIN(  42)																int index32;
HXDLIN(  42)																if (undoImage15->useVirtualPos) {
HXLINE(  42)																	index32 = ::Std_obj::_hx_int(((((( (Float)(y27) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x26) - undoImage15->virtualX));
            																}
            																else {
HXLINE(  42)																	index32 = ::Std_obj::_hx_int(( (Float)(((y27 * undoImage15->width) + x26)) ));
            																}
HXDLIN(  42)																int _hx_tmp58;
HXDLIN(  42)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  42)																	_hx_tmp58 = ((((((c27 >> 24) & 255) << 24) | ((c27 & 255) << 16)) | (((c27 >> 8) & 255) << 8)) | ((c27 >> 16) & 255));
            																}
            																else {
HXLINE(  42)																	_hx_tmp58 = c27;
            																}
HXDLIN(  42)																::iterMagic::Iimg_obj::set(this251,index32,_hx_tmp58);
            															}
            														}
            														else {
HXLINE(  42)															if (forceClear5) {
HXLINE(  42)																::Dynamic this252 = undoImage15->image;
HXDLIN(  42)																int x27 = (dx6 - rectLeft5);
HXDLIN(  42)																int y28 = (dy6 - rectTop5);
HXDLIN(  42)																int index33;
HXDLIN(  42)																if (undoImage15->useVirtualPos) {
HXLINE(  42)																	index33 = ::Std_obj::_hx_int(((((( (Float)(y28) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x27) - undoImage15->virtualX));
            																}
            																else {
HXLINE(  42)																	index33 = ::Std_obj::_hx_int(( (Float)(((y28 * undoImage15->width) + x27)) ));
            																}
HXDLIN(  42)																::iterMagic::Iimg_obj::set(this252,index33,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  42)								bool found5 = false;
HXDLIN(  42)								Float s5 = ((Float)0.);
HXDLIN(  42)								Float t5 = ((Float)0.);
HXDLIN(  42)								Float sxx5 = ((Float)0.);
HXDLIN(  42)								Float txx5 = ((Float)0.);
HXDLIN(  42)								{
HXLINE(  42)									int _g_min10 = xIter35->start;
HXDLIN(  42)									int _g_max10 = xIter35->max;
HXDLIN(  42)									while((_g_min10 < _g_max10)){
HXLINE(  42)										_g_min10 = (_g_min10 + 1);
HXDLIN(  42)										int x28 = (_g_min10 - 1);
HXLINE(  60)										sxx5 = (sx5 * ( (Float)(x28) ));
HXLINE(  61)										txx5 = (tx5 * ( (Float)(x28) ));
HXLINE(  62)										found5 = false;
HXLINE(  42)										{
HXLINE(  42)											int _g_min11 = yIter35->start;
HXDLIN(  42)											int _g_max11 = yIter35->max;
HXDLIN(  42)											while((_g_min11 < _g_max11)){
HXLINE(  42)												_g_min11 = (_g_min11 + 1);
HXDLIN(  42)												int y29 = (_g_min11 - 1);
HXLINE(  64)												s5 = ((s05 + sxx5) + (sy5 * ( (Float)(y29) )));
HXLINE(  65)												t5 = ((t05 + txx5) + (ty5 * ( (Float)(y29) )));
HXLINE(  42)												bool _hx_tmp59;
HXDLIN(  42)												if (!((s5 <= 0))) {
HXLINE(  42)													_hx_tmp59 = (t5 <= 0);
            												}
            												else {
HXLINE(  42)													_hx_tmp59 = true;
            												}
HXDLIN(  42)												if (_hx_tmp59) {
HXLINE(  42)													if (found5) {
HXLINE(  42)														goto _hx_goto_89;
            													}
            												}
            												else {
HXLINE(  42)													if (((s5 + t5) < A5)) {
HXLINE(  42)														{
HXLINE(  42)															int c28 = color3;
HXDLIN(  42)															bool _hx_tmp60;
HXDLIN(  42)															if ((((c28 >> 24) & 255) < 254)) {
HXLINE(  42)																_hx_tmp60 = this149->transparent;
            															}
            															else {
HXLINE(  42)																_hx_tmp60 = false;
            															}
HXDLIN(  42)															if (_hx_tmp60) {
HXLINE(  42)																int location16;
HXDLIN(  42)																if (this149->useVirtualPos) {
HXLINE(  42)																	location16 = ::Std_obj::_hx_int(((((( (Float)(y29) ) - this149->virtualY) * ( (Float)(this149->width) )) + x28) - this149->virtualX));
            																}
            																else {
HXLINE(  42)																	location16 = ::Std_obj::_hx_int(( (Float)(((y29 * this149->width) + x28)) ));
            																}
HXDLIN(  42)																int this253 = ::iterMagic::Iimg_obj::get(this149->image,location16);
HXDLIN(  42)																int this254;
HXDLIN(  42)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  42)																	this254 = ((((((this253 >> 24) & 255) << 24) | ((this253 & 255) << 16)) | (((this253 >> 8) & 255) << 8)) | ((this253 >> 16) & 255));
            																}
            																else {
HXLINE(  42)																	this254 = this253;
            																}
HXDLIN(  42)																Float a119;
HXDLIN(  42)																int this255 = ((this254 >> 24) & 255);
HXDLIN(  42)																if ((this255 == 0)) {
HXLINE(  42)																	a119 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	a119 = (( (Float)(this255) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float r116;
HXDLIN(  42)																int this256 = ((this254 >> 16) & 255);
HXDLIN(  42)																if ((this256 == 0)) {
HXLINE(  42)																	r116 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	r116 = (( (Float)(this256) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float g116;
HXDLIN(  42)																int this257 = ((this254 >> 8) & 255);
HXDLIN(  42)																if ((this257 == 0)) {
HXLINE(  42)																	g116 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	g116 = (( (Float)(this257) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float b121;
HXDLIN(  42)																int this258 = (this254 & 255);
HXDLIN(  42)																if ((this258 == 0)) {
HXLINE(  42)																	b121 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	b121 = (( (Float)(this258) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float a217;
HXDLIN(  42)																int this259 = ((color3 >> 24) & 255);
HXDLIN(  42)																if ((this259 == 0)) {
HXLINE(  42)																	a217 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	a217 = (( (Float)(this259) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float r216;
HXDLIN(  42)																int this260 = ((color3 >> 16) & 255);
HXDLIN(  42)																if ((this260 == 0)) {
HXLINE(  42)																	r216 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	r216 = (( (Float)(this260) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float g216;
HXDLIN(  42)																int this261 = ((color3 >> 8) & 255);
HXDLIN(  42)																if ((this261 == 0)) {
HXLINE(  42)																	g216 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	g216 = (( (Float)(this261) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float b219;
HXDLIN(  42)																int this262 = (color3 & 255);
HXDLIN(  42)																if ((this262 == 0)) {
HXLINE(  42)																	b219 = ((Float)0.);
            																}
            																else {
HXLINE(  42)																	b219 = (( (Float)(this262) ) / ( (Float)(255) ));
            																}
HXDLIN(  42)																Float a316 = (a119 * (( (Float)(1) ) - a217));
HXDLIN(  42)																int r36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r116 * a316) + (r216 * a217))));
HXDLIN(  42)																int g36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g116 * a316) + (g216 * a217))));
HXDLIN(  42)																int b46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b121 * a316) + (b219 * a217))));
HXDLIN(  42)																int a49 = ::Std_obj::_hx_int((( (Float)(255) ) * (a316 + a217)));
HXDLIN(  42)																int blended16 = ((((a49 << 24) | (r36 << 16)) | (g36 << 8)) | b46);
HXDLIN(  42)																{
HXLINE(  42)																	int _hx_tmp61;
HXDLIN(  42)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  42)																		_hx_tmp61 = ((((((blended16 >> 24) & 255) << 24) | ((blended16 & 255) << 16)) | (((blended16 >> 8) & 255) << 8)) | ((blended16 >> 16) & 255));
            																	}
            																	else {
HXLINE(  42)																		_hx_tmp61 = blended16;
            																	}
HXDLIN(  42)																	::iterMagic::Iimg_obj::set(this149->image,location16,_hx_tmp61);
            																}
            															}
            															else {
HXLINE(  42)																::Dynamic this263 = this149->image;
HXDLIN(  42)																int index34;
HXDLIN(  42)																if (this149->useVirtualPos) {
HXLINE(  42)																	index34 = ::Std_obj::_hx_int(((((( (Float)(y29) ) - this149->virtualY) * ( (Float)(this149->width) )) + x28) - this149->virtualX));
            																}
            																else {
HXLINE(  42)																	index34 = ::Std_obj::_hx_int(( (Float)(((y29 * this149->width) + x28)) ));
            																}
HXDLIN(  42)																int _hx_tmp62;
HXDLIN(  42)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  42)																	_hx_tmp62 = ((((((c28 >> 24) & 255) << 24) | ((c28 & 255) << 16)) | (((c28 >> 8) & 255) << 8)) | ((c28 >> 16) & 255));
            																}
            																else {
HXLINE(  42)																	_hx_tmp62 = c28;
            																}
HXDLIN(  42)																::iterMagic::Iimg_obj::set(this263,index34,_hx_tmp62);
            															}
            														}
HXLINE(  73)														found5 = true;
            													}
            													else {
HXLINE(  42)														if (found5) {
HXLINE(  42)															goto _hx_goto_89;
            														}
            													}
            												}
            											}
            											_hx_goto_89:;
            										}
            									}
            								}
HXDLIN(  42)								if ((hasHit4 == true)) {
HXLINE(  42)									 ::pi_xy::algo::HitTri v17 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx7,by7,bx9,by9,cx9,cy9,true);
HXDLIN(  42)									if (hasUndo5) {
HXLINE(  42)										v17->undoImage = undoImage15;
HXDLIN(  42)										v17->undoX = xIter35->start;
HXDLIN(  42)										v17->undoY = yIter35->start;
            									}
            								}
            							}
            						}
HXDLIN(  42)						if ((hasHit4 == true)) {
HXLINE(  42)							 ::pi_xy::algo::HitQuad v18 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax4,ay4,bx7,by7,cx7,cy7,dx4,dy4,true);
            						}
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(ArcForm_obj,chord,(void))

void ArcForm_obj::ellipse( ::pi_xy::ImageStruct temp){
            	HX_GC_STACKFRAME(&_hx_pos_9a7b98cd588c0f27_45_ellipse)
HXLINE(  46)		{
HXLINE(  46)			 ::pi_xy::ImageStruct this1 = temp;
HXDLIN(  46)			Float ax = this->rx;
HXDLIN(  46)			Float ay = this->ry;
HXDLIN(  46)			Float rx = this->rx;
HXDLIN(  46)			Float ry = this->ry;
HXDLIN(  46)			Float startRadian = this->startAngle;
HXDLIN(  46)			Float sweepRadian = this->sweepAngle;
HXDLIN(  46)			int color = this->strokeColor;
HXDLIN(  46)			bool hasHit = false;
HXDLIN(  46)			Float rSmall;
HXDLIN(  46)			if ((rx > ry)) {
HXLINE(  46)				rSmall = ry;
            			}
            			else {
HXLINE(  46)				rSmall = rx;
            			}
HXDLIN(  46)			 ::Dynamic targetE = ((Float)1.05);
HXDLIN(  46)			if (::hx::IsNull( targetE )) {
HXLINE( 381)				targetE = ((Float)1.05);
            			}
HXLINE(  46)			int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN(  46)			int noSides;
HXDLIN(  46)			if ((result < 12)) {
HXLINE(  46)				noSides = 12;
            			}
            			else {
HXLINE(  46)				if ((result > 500)) {
HXLINE(  46)					noSides = 500;
            				}
            				else {
HXLINE(  46)					noSides = result;
            				}
            			}
HXDLIN(  46)			Float theta = ((((Float)1.41213) * ::Math_obj::PI) / ( (Float)(noSides) ));
HXDLIN(  46)			Float currAngle = startRadian;
HXDLIN(  46)			int tot = ::Math_obj::floor((sweepRadian / theta));
HXDLIN(  46)			theta = (theta + (((sweepRadian / theta) - ( (Float)(tot) )) / ( (Float)(noSides) )));
HXLINE( 386)			tot = ::Math_obj::floor((sweepRadian / theta));
HXLINE(  46)			Float bx = ((rx * ::Math_obj::cos(currAngle)) + ax);
HXDLIN(  46)			Float by = ((ry * ::Math_obj::sin(currAngle)) + ay);
HXDLIN(  46)			Float cx = ((Float)0.);
HXDLIN(  46)			Float cy = ((Float)0.);
HXDLIN(  46)			::Array< ::Dynamic> arrTri = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN(  46)			{
HXLINE(  46)				int _g = 1;
HXDLIN(  46)				int _g1 = (tot + 1);
HXDLIN(  46)				while((_g < _g1)){
HXLINE(  46)					_g = (_g + 1);
HXDLIN(  46)					int i = (_g - 1);
HXLINE( 393)					currAngle = (startRadian + (( (Float)(i) ) * theta));
HXLINE( 394)					cx = ((rx * ::Math_obj::cos(currAngle)) + ax);
HXLINE( 395)					cy = ((ry * ::Math_obj::sin(currAngle)) + ay);
HXLINE(  46)					bool hasUndo = false;
HXDLIN(  46)					Float bx1 = bx;
HXDLIN(  46)					Float by1 = by;
HXDLIN(  46)					Float cx1 = cx;
HXDLIN(  46)					Float cy1 = cy;
HXDLIN(  46)					bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN(  46)					if (!(adjustWinding)) {
HXLINE(  46)						Float bx_ = bx1;
HXDLIN(  46)						Float by_ = by1;
HXLINE(  25)						bx1 = cx1;
HXLINE(  26)						by1 = cy1;
HXLINE(  27)						cx1 = bx_;
HXLINE(  28)						cy1 = by_;
            					}
HXLINE(  46)					Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN(  46)					Float sx = (cy1 - ay);
HXDLIN(  46)					Float sy = (ax - cx1);
HXDLIN(  46)					Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN(  46)					Float tx = (ay - by1);
HXDLIN(  46)					Float ty = (bx1 - ax);
HXDLIN(  46)					Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN(  46)					 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  46)					if ((ax > bx1)) {
HXLINE(  46)						if ((ax > cx1)) {
HXLINE(  46)							int min;
HXDLIN(  46)							if ((bx1 > cx1)) {
HXLINE(  46)								min = ::Math_obj::floor(cx1);
            							}
            							else {
HXLINE(  46)								min = ::Math_obj::floor(bx1);
            							}
HXDLIN(  46)							int ii_min = min;
HXDLIN(  46)							int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  46)							xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            						}
            						else {
HXLINE(  46)							int ii_min1 = ::Math_obj::floor(bx1);
HXDLIN(  46)							int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN(  46)							xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            						}
            					}
            					else {
HXLINE(  46)						if ((bx1 > cx1)) {
HXLINE(  46)							int min1;
HXDLIN(  46)							if ((ax > cx1)) {
HXLINE(  46)								min1 = ::Math_obj::floor(cx1);
            							}
            							else {
HXLINE(  46)								min1 = ::Math_obj::ceil(ax);
            							}
HXDLIN(  46)							int ii_min2 = min1;
HXDLIN(  46)							int ii_max2 = ::Math_obj::ceil(bx1);
HXDLIN(  46)							xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            						}
            						else {
HXLINE(  46)							int ii_min3 = ::Math_obj::floor(ax);
HXDLIN(  46)							int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN(  46)							xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            						}
            					}
HXDLIN(  46)					 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  46)					if ((ay > by1)) {
HXLINE(  46)						if ((ay > cy1)) {
HXLINE(  46)							int min2;
HXDLIN(  46)							if ((by1 > cy1)) {
HXLINE(  46)								min2 = ::Math_obj::floor(cy1);
            							}
            							else {
HXLINE(  46)								min2 = ::Math_obj::floor(by1);
            							}
HXDLIN(  46)							int ii_min4 = min2;
HXDLIN(  46)							int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN(  46)							yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            						}
            						else {
HXLINE(  46)							int ii_min5 = ::Math_obj::floor(by1);
HXDLIN(  46)							int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN(  46)							yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            						}
            					}
            					else {
HXLINE(  46)						if ((by1 > cy1)) {
HXLINE(  46)							int min3;
HXDLIN(  46)							if ((ay > cy1)) {
HXLINE(  46)								min3 = ::Math_obj::floor(cy1);
            							}
            							else {
HXLINE(  46)								min3 = ::Math_obj::ceil(ay);
            							}
HXDLIN(  46)							int ii_min6 = min3;
HXDLIN(  46)							int ii_max6 = ::Math_obj::ceil(by1);
HXDLIN(  46)							yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            						}
            						else {
HXLINE(  46)							int ii_min7 = ::Math_obj::floor(ay);
HXDLIN(  46)							int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN(  46)							yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            						}
            					}
HXDLIN(  46)					 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  46)					if (hasUndo) {
HXLINE(  46)						int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  46)						int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  46)						 ::Dynamic imageType = null();
HXDLIN(  46)						 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  46)						if (::hx::IsNull( imageType )) {
HXLINE(  54)							imageType = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE(  46)						::Dynamic undoImage1;
HXDLIN(  46)						switch((int)(( (int)(imageType) ))){
            							case (int)0: {
HXLINE(  46)								 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  46)								 ::iterMagic::BytesImg b = byt;
HXDLIN(  46)								{
HXLINE(  46)									b->width = width;
HXDLIN(  46)									b->height = height;
HXDLIN(  46)									b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  46)									b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  46)									{
HXLINE(  46)										int len = b->length;
HXDLIN(  46)										int w = 0;
HXDLIN(  46)										{
HXLINE(  46)											int _g2 = 0;
HXDLIN(  46)											int _g3 = b->height;
HXDLIN(  46)											while((_g2 < _g3)){
HXLINE(  46)												_g2 = (_g2 + 1);
HXDLIN(  46)												int y = (_g2 - 1);
HXDLIN(  46)												{
HXLINE(  46)													int _g4 = 0;
HXDLIN(  46)													int _g5 = b->width;
HXDLIN(  46)													while((_g4 < _g5)){
HXLINE(  46)														_g4 = (_g4 + 1);
HXDLIN(  46)														int x = (_g4 - 1);
HXDLIN(  46)														{
HXLINE(  46)															w = (w + 1);
HXDLIN(  46)															b->data->b[(w - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  46)														{
HXLINE(  46)															w = (w + 1);
HXDLIN(  46)															b->data->b[(w - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  46)														{
HXLINE(  46)															w = (w + 1);
HXDLIN(  46)															b->data->b[(w - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  46)														{
HXLINE(  46)															w = (w + 1);
HXDLIN(  46)															b->data->b[(w - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  46)								undoImage1 = b;
            							}
            							break;
            							case (int)1: {
HXLINE(  46)								 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  46)								 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  46)								{
HXLINE(  46)									a->width = width;
HXDLIN(  46)									a->height = height;
HXDLIN(  46)									a->data = ::Array_obj< int >::__new(0);
HXDLIN(  46)									a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  46)									{
HXLINE(  46)										int _g6 = 0;
HXDLIN(  46)										int _g7 = a->length;
HXDLIN(  46)										while((_g6 < _g7)){
HXLINE(  46)											_g6 = (_g6 + 1);
HXDLIN(  46)											int i1 = (_g6 - 1);
HXDLIN(  46)											a->data[i1] = 0;
            										}
            									}
            								}
HXDLIN(  46)								undoImage1 = a;
            							}
            							break;
            							case (int)2: {
HXLINE(  46)								 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  46)								 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  46)								{
HXLINE(  46)									b1->width = width;
HXDLIN(  46)									b1->height = height;
HXDLIN(  46)									b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  46)									int size = (b1->length * 4);
HXDLIN(  46)									b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  46)									{
HXLINE(  46)										int _g8 = 0;
HXDLIN(  46)										int _g9 = b1->length;
HXDLIN(  46)										while((_g8 < _g9)){
HXLINE(  46)											_g8 = (_g8 + 1);
HXDLIN(  46)											int i2 = (_g8 - 1);
HXDLIN(  46)											{
HXLINE(  46)												 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  46)												bool undoImage2;
HXDLIN(  46)												if ((i2 >= 0)) {
HXLINE(  46)													undoImage2 = (i2 < (this3->byteLength >> 2));
            												}
            												else {
HXLINE(  46)													undoImage2 = false;
            												}
HXDLIN(  46)												if (undoImage2) {
HXLINE(  46)													 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  46)													int pos = ((i2 << 2) + this3->byteOffset);
HXDLIN(  46)													_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  46)													_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  46)													_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  46)													_this->b[(pos + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN(  46)								undoImage1 = b1;
            							}
            							break;
            							case (int)3: {
HXLINE(  46)								 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  46)								 ::iterMagic::VecIntImg v = vec;
HXDLIN(  46)								{
HXLINE(  46)									v->width = width;
HXDLIN(  46)									v->height = height;
HXDLIN(  46)									v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  46)									v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  46)									{
HXLINE(  46)										int _g10 = 0;
HXDLIN(  46)										int _g11 = v->length;
HXDLIN(  46)										while((_g10 < _g11)){
HXLINE(  46)											_g10 = (_g10 + 1);
HXDLIN(  46)											int i3 = (_g10 - 1);
HXDLIN(  46)											v->data->__unsafe_set(i3,0);
            										}
            									}
            								}
HXDLIN(  46)								undoImage1 = v;
            							}
            							break;
            							case (int)4: {
HXLINE(  46)								 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  46)								 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  46)								{
HXLINE(  46)									b2->width = width;
HXDLIN(  46)									b2->height = height;
HXDLIN(  46)									b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  46)									b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  46)									{
HXLINE(  46)										int len1 = b2->length;
HXDLIN(  46)										 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  46)										if (::hx::IsNull( d->head )) {
HXLINE(  46)											int _g12 = 0;
HXDLIN(  46)											int _g13 = len1;
HXDLIN(  46)											while((_g12 < _g13)){
HXLINE(  46)												_g12 = (_g12 + 1);
HXDLIN(  46)												int i4 = (_g12 - 1);
HXDLIN(  46)												d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            											}
            										}
            										else {
HXLINE(  46)											int _g14 = 0;
HXDLIN(  46)											int _g15 = len1;
HXDLIN(  46)											while((_g14 < _g15)){
HXLINE(  46)												_g14 = (_g14 + 1);
HXDLIN(  46)												int i5 = (_g14 - 1);
HXDLIN(  46)												{
HXLINE(  46)													 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  46)													 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  46)													{
HXLINE(  46)														int _g16 = 0;
HXDLIN(  46)														int _g17 = i5;
HXDLIN(  46)														while((_g16 < _g17)){
HXLINE(  46)															_g16 = (_g16 + 1);
HXDLIN(  46)															int i6 = (_g16 - 1);
HXLINE( 345)															prev = l;
HXLINE( 346)															l = l->next;
            														}
            													}
HXLINE(  46)													if (::hx::IsNull( prev )) {
HXLINE(  46)														b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  46)														l = null();
            													}
            													else {
HXLINE(  46)														prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  46)														l = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  46)								undoImage1 = b2;
            							}
            							break;
            						}
HXDLIN(  46)						this2->image = undoImage1;
HXDLIN(  46)						this2->width = width;
HXDLIN(  46)						this2->height = height;
HXDLIN(  46)						this2->imageType = ( (int)(imageType) );
HXDLIN(  46)						undoImage = this2;
HXDLIN(  46)						{
HXLINE(  46)							int rectLeft = xIter3->start;
HXDLIN(  46)							int rectTop = yIter3->start;
HXDLIN(  46)							int rectRight = xIter3->max;
HXDLIN(  46)							bool forceClear = false;
HXDLIN(  46)							{
HXLINE(  46)								int _g18 = rectTop;
HXDLIN(  46)								int _g19 = yIter3->max;
HXDLIN(  46)								while((_g18 < _g19)){
HXLINE(  46)									_g18 = (_g18 + 1);
HXDLIN(  46)									int dy = (_g18 - 1);
HXDLIN(  46)									{
HXLINE(  46)										int _g20 = rectLeft;
HXDLIN(  46)										int _g21 = rectRight;
HXDLIN(  46)										while((_g20 < _g21)){
HXLINE(  46)											_g20 = (_g20 + 1);
HXDLIN(  46)											int dx = (_g20 - 1);
HXDLIN(  46)											::Dynamic this4 = this1->image;
HXDLIN(  46)											int index;
HXDLIN(  46)											if (this1->useVirtualPos) {
HXLINE(  46)												index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            											}
            											else {
HXLINE(  46)												index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            											}
HXDLIN(  46)											int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN(  46)											int col;
HXDLIN(  46)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  46)												col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  46)												col = c;
            											}
HXDLIN(  46)											bool _hx_tmp;
HXDLIN(  46)											if (this1->useMask) {
HXLINE(  46)												_hx_tmp = ::hx::IsNotNull( this1->mask );
            											}
            											else {
HXLINE(  46)												_hx_tmp = false;
            											}
HXDLIN(  46)											if (_hx_tmp) {
HXLINE(  46)												 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN(  46)												::Dynamic this6 = this5->image;
HXDLIN(  46)												int index1;
HXDLIN(  46)												if (this5->useVirtualPos) {
HXLINE(  46)													index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx) - this5->virtualX));
            												}
            												else {
HXLINE(  46)													index1 = ::Std_obj::_hx_int(( (Float)(((dy * this5->width) + dx)) ));
            												}
HXDLIN(  46)												int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN(  46)												int v1;
HXDLIN(  46)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  46)													v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            												}
            												else {
HXLINE(  46)													v1 = c1;
            												}
HXDLIN(  46)												int maskPixel = v1;
HXDLIN(  46)												int this7 = col;
HXDLIN(  46)												if ((maskPixel == 0)) {
HXLINE(  46)													col = this7;
            												}
            												else {
HXLINE(  46)													Float m0;
HXDLIN(  46)													int this8 = ((maskPixel >> 24) & 255);
HXDLIN(  46)													if ((this8 == 0)) {
HXLINE(  46)														m0 = ((Float)0.);
            													}
            													else {
HXLINE(  46)														m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  46)													Float m1;
HXDLIN(  46)													int this9 = ((maskPixel >> 16) & 255);
HXDLIN(  46)													if ((this9 == 0)) {
HXLINE(  46)														m1 = ((Float)0.);
            													}
            													else {
HXLINE(  46)														m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  46)													Float m2;
HXDLIN(  46)													int this10 = ((maskPixel >> 8) & 255);
HXDLIN(  46)													if ((this10 == 0)) {
HXLINE(  46)														m2 = ((Float)0.);
            													}
            													else {
HXLINE(  46)														m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  46)													Float m3;
HXDLIN(  46)													int this11 = (maskPixel & 255);
HXDLIN(  46)													if ((this11 == 0)) {
HXLINE(  46)														m3 = ((Float)0.);
            													}
            													else {
HXLINE(  46)														m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  46)													int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN(  46)													int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN(  46)													int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN(  46)													int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN(  46)													col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  46)											if ((col != 0)) {
HXLINE(  46)												int x1 = (dx - rectLeft);
HXDLIN(  46)												int y1 = (dy - rectTop);
HXDLIN(  46)												int c2 = col;
HXDLIN(  46)												bool _hx_tmp1;
HXDLIN(  46)												if ((((c2 >> 24) & 255) < 254)) {
HXLINE(  46)													_hx_tmp1 = undoImage->transparent;
            												}
            												else {
HXLINE(  46)													_hx_tmp1 = false;
            												}
HXDLIN(  46)												if (_hx_tmp1) {
HXLINE(  46)													int location;
HXDLIN(  46)													if (undoImage->useVirtualPos) {
HXLINE(  46)														location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            													}
            													else {
HXLINE(  46)														location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            													}
HXDLIN(  46)													int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN(  46)													int this13;
HXDLIN(  46)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  46)														this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            													}
            													else {
HXLINE(  46)														this13 = this12;
            													}
HXDLIN(  46)													Float a1;
HXDLIN(  46)													int this14 = ((this13 >> 24) & 255);
HXDLIN(  46)													if ((this14 == 0)) {
HXLINE(  46)														a1 = ((Float)0.);
            													}
            													else {
HXLINE(  46)														a1 = (( (Float)(this14) ) / ( (Float)(255) ));
            													}
HXDLIN(  46)													Float r1;
HXDLIN(  46)													int this15 = ((this13 >> 16) & 255);
HXDLIN(  46)													if ((this15 == 0)) {
HXLINE(  46)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  46)														r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            													}
HXDLIN(  46)													Float g1;
HXDLIN(  46)													int this16 = ((this13 >> 8) & 255);
HXDLIN(  46)													if ((this16 == 0)) {
HXLINE(  46)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  46)														g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            													}
HXDLIN(  46)													Float b11;
HXDLIN(  46)													int this17 = (this13 & 255);
HXDLIN(  46)													if ((this17 == 0)) {
HXLINE(  46)														b11 = ((Float)0.);
            													}
            													else {
HXLINE(  46)														b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            													}
HXDLIN(  46)													Float a2;
HXDLIN(  46)													int this18 = ((col >> 24) & 255);
HXDLIN(  46)													if ((this18 == 0)) {
HXLINE(  46)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  46)														a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            													}
HXDLIN(  46)													Float r2;
HXDLIN(  46)													int this19 = ((col >> 16) & 255);
HXDLIN(  46)													if ((this19 == 0)) {
HXLINE(  46)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  46)														r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            													}
HXDLIN(  46)													Float g2;
HXDLIN(  46)													int this20 = ((col >> 8) & 255);
HXDLIN(  46)													if ((this20 == 0)) {
HXLINE(  46)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  46)														g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            													}
HXDLIN(  46)													Float b21;
HXDLIN(  46)													int this21 = (col & 255);
HXDLIN(  46)													if ((this21 == 0)) {
HXLINE(  46)														b21 = ((Float)0.);
            													}
            													else {
HXLINE(  46)														b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            													}
HXDLIN(  46)													Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  46)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  46)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  46)													int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  46)													int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  46)													int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  46)													{
HXLINE(  46)														int _hx_tmp2;
HXDLIN(  46)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  46)															_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  46)															_hx_tmp2 = blended;
            														}
HXDLIN(  46)														::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            													}
            												}
            												else {
HXLINE(  46)													::Dynamic this22 = undoImage->image;
HXDLIN(  46)													int index2;
HXDLIN(  46)													if (undoImage->useVirtualPos) {
HXLINE(  46)														index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            													}
            													else {
HXLINE(  46)														index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            													}
HXDLIN(  46)													int _hx_tmp3;
HXDLIN(  46)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  46)														_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            													}
            													else {
HXLINE(  46)														_hx_tmp3 = c2;
            													}
HXDLIN(  46)													::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp3);
            												}
            											}
            											else {
HXLINE(  46)												if (forceClear) {
HXLINE(  46)													::Dynamic this23 = undoImage->image;
HXDLIN(  46)													int x2 = (dx - rectLeft);
HXDLIN(  46)													int y2 = (dy - rectTop);
HXDLIN(  46)													int index3;
HXDLIN(  46)													if (undoImage->useVirtualPos) {
HXLINE(  46)														index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            													}
            													else {
HXLINE(  46)														index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            													}
HXDLIN(  46)													::iterMagic::Iimg_obj::set(this23,index3,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  46)					bool found = false;
HXDLIN(  46)					Float s = ((Float)0.);
HXDLIN(  46)					Float t = ((Float)0.);
HXDLIN(  46)					Float sxx = ((Float)0.);
HXDLIN(  46)					Float txx = ((Float)0.);
HXDLIN(  46)					{
HXLINE(  46)						int _g_min = xIter3->start;
HXDLIN(  46)						int _g_max = xIter3->max;
HXDLIN(  46)						while((_g_min < _g_max)){
HXLINE(  46)							_g_min = (_g_min + 1);
HXDLIN(  46)							int x3 = (_g_min - 1);
HXLINE(  60)							sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)							txx = (tx * ( (Float)(x3) ));
HXLINE(  62)							found = false;
HXLINE(  46)							{
HXLINE(  46)								int _g_min1 = yIter3->start;
HXDLIN(  46)								int _g_max1 = yIter3->max;
HXDLIN(  46)								while((_g_min1 < _g_max1)){
HXLINE(  46)									_g_min1 = (_g_min1 + 1);
HXDLIN(  46)									int y3 = (_g_min1 - 1);
HXLINE(  64)									s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)									t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE(  46)									bool _hx_tmp4;
HXDLIN(  46)									if (!((s <= 0))) {
HXLINE(  46)										_hx_tmp4 = (t <= 0);
            									}
            									else {
HXLINE(  46)										_hx_tmp4 = true;
            									}
HXDLIN(  46)									if (_hx_tmp4) {
HXLINE(  46)										if (found) {
HXLINE(  46)											goto _hx_goto_103;
            										}
            									}
            									else {
HXLINE(  46)										if (((s + t) < A)) {
HXLINE(  46)											{
HXLINE(  46)												int c3 = color;
HXDLIN(  46)												bool _hx_tmp5;
HXDLIN(  46)												if ((((c3 >> 24) & 255) < 254)) {
HXLINE(  46)													_hx_tmp5 = this1->transparent;
            												}
            												else {
HXLINE(  46)													_hx_tmp5 = false;
            												}
HXDLIN(  46)												if (_hx_tmp5) {
HXLINE(  46)													int location1;
HXDLIN(  46)													if (this1->useVirtualPos) {
HXLINE(  46)														location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            													}
            													else {
HXLINE(  46)														location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            													}
HXDLIN(  46)													int this24 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN(  46)													int this25;
HXDLIN(  46)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  46)														this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            													}
            													else {
HXLINE(  46)														this25 = this24;
            													}
HXDLIN(  46)													Float a11;
HXDLIN(  46)													int this26 = ((this25 >> 24) & 255);
HXDLIN(  46)													if ((this26 == 0)) {
HXLINE(  46)														a11 = ((Float)0.);
            													}
            													else {
HXLINE(  46)														a11 = (( (Float)(this26) ) / ( (Float)(255) ));
            													}
HXDLIN(  46)													Float r11;
HXDLIN(  46)													int this27 = ((this25 >> 16) & 255);
HXDLIN(  46)													if ((this27 == 0)) {
HXLINE(  46)														r11 = ((Float)0.);
            													}
            													else {
HXLINE(  46)														r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            													}
HXDLIN(  46)													Float g11;
HXDLIN(  46)													int this28 = ((this25 >> 8) & 255);
HXDLIN(  46)													if ((this28 == 0)) {
HXLINE(  46)														g11 = ((Float)0.);
            													}
            													else {
HXLINE(  46)														g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            													}
HXDLIN(  46)													Float b12;
HXDLIN(  46)													int this29 = (this25 & 255);
HXDLIN(  46)													if ((this29 == 0)) {
HXLINE(  46)														b12 = ((Float)0.);
            													}
            													else {
HXLINE(  46)														b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            													}
HXDLIN(  46)													Float a21;
HXDLIN(  46)													int this30 = ((color >> 24) & 255);
HXDLIN(  46)													if ((this30 == 0)) {
HXLINE(  46)														a21 = ((Float)0.);
            													}
            													else {
HXLINE(  46)														a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            													}
HXDLIN(  46)													Float r21;
HXDLIN(  46)													int this31 = ((color >> 16) & 255);
HXDLIN(  46)													if ((this31 == 0)) {
HXLINE(  46)														r21 = ((Float)0.);
            													}
            													else {
HXLINE(  46)														r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            													}
HXDLIN(  46)													Float g21;
HXDLIN(  46)													int this32 = ((color >> 8) & 255);
HXDLIN(  46)													if ((this32 == 0)) {
HXLINE(  46)														g21 = ((Float)0.);
            													}
            													else {
HXLINE(  46)														g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            													}
HXDLIN(  46)													Float b22;
HXDLIN(  46)													int this33 = (color & 255);
HXDLIN(  46)													if ((this33 == 0)) {
HXLINE(  46)														b22 = ((Float)0.);
            													}
            													else {
HXLINE(  46)														b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            													}
HXDLIN(  46)													Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  46)													int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  46)													int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  46)													int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  46)													int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  46)													int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  46)													{
HXLINE(  46)														int _hx_tmp6;
HXDLIN(  46)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  46)															_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            														}
            														else {
HXLINE(  46)															_hx_tmp6 = blended1;
            														}
HXDLIN(  46)														::iterMagic::Iimg_obj::set(this1->image,location1,_hx_tmp6);
            													}
            												}
            												else {
HXLINE(  46)													::Dynamic this34 = this1->image;
HXDLIN(  46)													int index4;
HXDLIN(  46)													if (this1->useVirtualPos) {
HXLINE(  46)														index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            													}
            													else {
HXLINE(  46)														index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            													}
HXDLIN(  46)													int _hx_tmp7;
HXDLIN(  46)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  46)														_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            													}
            													else {
HXLINE(  46)														_hx_tmp7 = c3;
            													}
HXDLIN(  46)													::iterMagic::Iimg_obj::set(this34,index4,_hx_tmp7);
            												}
            											}
HXLINE(  73)											found = true;
            										}
            										else {
HXLINE(  46)											if (found) {
HXLINE(  46)												goto _hx_goto_103;
            											}
            										}
            									}
            								}
            								_hx_goto_103:;
            							}
            						}
            					}
HXDLIN(  46)					 ::pi_xy::algo::HitTri triHit;
HXDLIN(  46)					if ((hasHit == true)) {
HXLINE(  46)						 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx1,by1,cx1,cy1,true);
HXDLIN(  46)						if (hasUndo) {
HXLINE(  46)							v2->undoImage = undoImage;
HXDLIN(  46)							v2->undoX = xIter3->start;
HXDLIN(  46)							v2->undoY = yIter3->start;
            						}
HXDLIN(  46)						triHit = v2;
            					}
            					else {
HXLINE(  46)						triHit = null();
            					}
HXDLIN(  46)					if (hasHit) {
HXLINE(  46)						arrTri[arrTri->length] = triHit;
            					}
HXLINE( 398)					bx = cx;
HXLINE( 399)					by = cy;
            				}
            			}
HXLINE( 402)			currAngle = (startRadian + sweepRadian);
HXLINE( 403)			cx = ((rx * ::Math_obj::cos(currAngle)) + ax);
HXLINE( 404)			cy = ((ry * ::Math_obj::sin(currAngle)) + ay);
HXLINE(  46)			bool hasUndo1 = false;
HXDLIN(  46)			Float bx2 = bx;
HXDLIN(  46)			Float by2 = by;
HXDLIN(  46)			Float cx2 = cx;
HXDLIN(  46)			Float cy2 = cy;
HXDLIN(  46)			bool adjustWinding1 = (((((ax * by2) - (bx2 * ay)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ay) - (ax * cy2))) > 0);
HXDLIN(  46)			if (!(adjustWinding1)) {
HXLINE(  46)				Float bx_1 = bx2;
HXDLIN(  46)				Float by_1 = by2;
HXLINE(  25)				bx2 = cx2;
HXLINE(  26)				by2 = cy2;
HXLINE(  27)				cx2 = bx_1;
HXLINE(  28)				cy2 = by_1;
            			}
HXLINE(  46)			Float s01 = ((ay * cx2) - (ax * cy2));
HXDLIN(  46)			Float sx1 = (cy2 - ay);
HXDLIN(  46)			Float sy1 = (ax - cx2);
HXDLIN(  46)			Float t01 = ((ax * by2) - (ay * bx2));
HXDLIN(  46)			Float tx1 = (ay - by2);
HXDLIN(  46)			Float ty1 = (bx2 - ax);
HXDLIN(  46)			Float A1 = ((((-(by2) * cx2) + (ay * (-(bx2) + cx2))) + (ax * (by2 - cy2))) + (bx2 * cy2));
HXDLIN(  46)			 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  46)			if ((ax > bx2)) {
HXLINE(  46)				if ((ax > cx2)) {
HXLINE(  46)					int min4;
HXDLIN(  46)					if ((bx2 > cx2)) {
HXLINE(  46)						min4 = ::Math_obj::floor(cx2);
            					}
            					else {
HXLINE(  46)						min4 = ::Math_obj::floor(bx2);
            					}
HXDLIN(  46)					int ii_min8 = min4;
HXDLIN(  46)					int ii_max8 = ::Math_obj::ceil(ax);
HXDLIN(  46)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            				}
            				else {
HXLINE(  46)					int ii_min9 = ::Math_obj::floor(bx2);
HXDLIN(  46)					int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN(  46)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            				}
            			}
            			else {
HXLINE(  46)				if ((bx2 > cx2)) {
HXLINE(  46)					int min5;
HXDLIN(  46)					if ((ax > cx2)) {
HXLINE(  46)						min5 = ::Math_obj::floor(cx2);
            					}
            					else {
HXLINE(  46)						min5 = ::Math_obj::ceil(ax);
            					}
HXDLIN(  46)					int ii_min10 = min5;
HXDLIN(  46)					int ii_max10 = ::Math_obj::ceil(bx2);
HXDLIN(  46)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            				}
            				else {
HXLINE(  46)					int ii_min11 = ::Math_obj::floor(ax);
HXDLIN(  46)					int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN(  46)					xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            				}
            			}
HXDLIN(  46)			 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  46)			if ((ay > by2)) {
HXLINE(  46)				if ((ay > cy2)) {
HXLINE(  46)					int min6;
HXDLIN(  46)					if ((by2 > cy2)) {
HXLINE(  46)						min6 = ::Math_obj::floor(cy2);
            					}
            					else {
HXLINE(  46)						min6 = ::Math_obj::floor(by2);
            					}
HXDLIN(  46)					int ii_min12 = min6;
HXDLIN(  46)					int ii_max12 = ::Math_obj::ceil(ay);
HXDLIN(  46)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            				}
            				else {
HXLINE(  46)					int ii_min13 = ::Math_obj::floor(by2);
HXDLIN(  46)					int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN(  46)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            				}
            			}
            			else {
HXLINE(  46)				if ((by2 > cy2)) {
HXLINE(  46)					int min7;
HXDLIN(  46)					if ((ay > cy2)) {
HXLINE(  46)						min7 = ::Math_obj::floor(cy2);
            					}
            					else {
HXLINE(  46)						min7 = ::Math_obj::ceil(ay);
            					}
HXDLIN(  46)					int ii_min14 = min7;
HXDLIN(  46)					int ii_max14 = ::Math_obj::ceil(by2);
HXDLIN(  46)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            				}
            				else {
HXLINE(  46)					int ii_min15 = ::Math_obj::floor(ay);
HXDLIN(  46)					int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN(  46)					yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            				}
            			}
HXDLIN(  46)			 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  46)			if (hasUndo1) {
HXLINE(  46)				int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  46)				int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  46)				 ::Dynamic imageType1 = null();
HXDLIN(  46)				 ::pi_xy::ImageStruct this35 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  46)				if (::hx::IsNull( imageType1 )) {
HXLINE(  54)					imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE(  46)				::Dynamic undoImage4;
HXDLIN(  46)				switch((int)(( (int)(imageType1) ))){
            					case (int)0: {
HXLINE(  46)						 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  46)						 ::iterMagic::BytesImg b5 = byt1;
HXDLIN(  46)						{
HXLINE(  46)							b5->width = width1;
HXDLIN(  46)							b5->height = height1;
HXDLIN(  46)							b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  46)							b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN(  46)							{
HXLINE(  46)								int len2 = b5->length;
HXDLIN(  46)								int w1 = 0;
HXDLIN(  46)								{
HXLINE(  46)									int _g22 = 0;
HXDLIN(  46)									int _g23 = b5->height;
HXDLIN(  46)									while((_g22 < _g23)){
HXLINE(  46)										_g22 = (_g22 + 1);
HXDLIN(  46)										int y4 = (_g22 - 1);
HXDLIN(  46)										{
HXLINE(  46)											int _g24 = 0;
HXDLIN(  46)											int _g25 = b5->width;
HXDLIN(  46)											while((_g24 < _g25)){
HXLINE(  46)												_g24 = (_g24 + 1);
HXDLIN(  46)												int x4 = (_g24 - 1);
HXDLIN(  46)												{
HXLINE(  46)													w1 = (w1 + 1);
HXDLIN(  46)													b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  46)												{
HXLINE(  46)													w1 = (w1 + 1);
HXDLIN(  46)													b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  46)												{
HXLINE(  46)													w1 = (w1 + 1);
HXDLIN(  46)													b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  46)												{
HXLINE(  46)													w1 = (w1 + 1);
HXDLIN(  46)													b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  46)						undoImage4 = b5;
            					}
            					break;
            					case (int)1: {
HXLINE(  46)						 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  46)						 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN(  46)						{
HXLINE(  46)							a6->width = width1;
HXDLIN(  46)							a6->height = height1;
HXDLIN(  46)							a6->data = ::Array_obj< int >::__new(0);
HXDLIN(  46)							a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  46)							{
HXLINE(  46)								int _g26 = 0;
HXDLIN(  46)								int _g27 = a6->length;
HXDLIN(  46)								while((_g26 < _g27)){
HXLINE(  46)									_g26 = (_g26 + 1);
HXDLIN(  46)									int i7 = (_g26 - 1);
HXDLIN(  46)									a6->data[i7] = 0;
            								}
            							}
            						}
HXDLIN(  46)						undoImage4 = a6;
            					}
            					break;
            					case (int)2: {
HXLINE(  46)						 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  46)						 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN(  46)						{
HXLINE(  46)							b6->width = width1;
HXDLIN(  46)							b6->height = height1;
HXDLIN(  46)							b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  46)							int size1 = (b6->length * 4);
HXDLIN(  46)							b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  46)							{
HXLINE(  46)								int _g28 = 0;
HXDLIN(  46)								int _g29 = b6->length;
HXDLIN(  46)								while((_g28 < _g29)){
HXLINE(  46)									_g28 = (_g28 + 1);
HXDLIN(  46)									int i8 = (_g28 - 1);
HXDLIN(  46)									{
HXLINE(  46)										 ::haxe::io::ArrayBufferViewImpl this36 = b6->data;
HXDLIN(  46)										bool undoImage5;
HXDLIN(  46)										if ((i8 >= 0)) {
HXLINE(  46)											undoImage5 = (i8 < (this36->byteLength >> 2));
            										}
            										else {
HXLINE(  46)											undoImage5 = false;
            										}
HXDLIN(  46)										if (undoImage5) {
HXLINE(  46)											 ::haxe::io::Bytes _this1 = this36->bytes;
HXDLIN(  46)											int pos1 = ((i8 << 2) + this36->byteOffset);
HXDLIN(  46)											_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  46)											_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  46)											_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  46)											_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN(  46)						undoImage4 = b6;
            					}
            					break;
            					case (int)3: {
HXLINE(  46)						 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  46)						 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN(  46)						{
HXLINE(  46)							v3->width = width1;
HXDLIN(  46)							v3->height = height1;
HXDLIN(  46)							v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  46)							v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN(  46)							{
HXLINE(  46)								int _g30 = 0;
HXDLIN(  46)								int _g31 = v3->length;
HXDLIN(  46)								while((_g30 < _g31)){
HXLINE(  46)									_g30 = (_g30 + 1);
HXDLIN(  46)									int i9 = (_g30 - 1);
HXDLIN(  46)									v3->data->__unsafe_set(i9,0);
            								}
            							}
            						}
HXDLIN(  46)						undoImage4 = v3;
            					}
            					break;
            					case (int)4: {
HXLINE(  46)						 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  46)						 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN(  46)						{
HXLINE(  46)							b7->width = width1;
HXDLIN(  46)							b7->height = height1;
HXDLIN(  46)							b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  46)							b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  46)							{
HXLINE(  46)								int len3 = b7->length;
HXDLIN(  46)								 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN(  46)								if (::hx::IsNull( d1->head )) {
HXLINE(  46)									int _g32 = 0;
HXDLIN(  46)									int _g33 = len3;
HXDLIN(  46)									while((_g32 < _g33)){
HXLINE(  46)										_g32 = (_g32 + 1);
HXDLIN(  46)										int i10 = (_g32 - 1);
HXDLIN(  46)										d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            									}
            								}
            								else {
HXLINE(  46)									int _g34 = 0;
HXDLIN(  46)									int _g35 = len3;
HXDLIN(  46)									while((_g34 < _g35)){
HXLINE(  46)										_g34 = (_g34 + 1);
HXDLIN(  46)										int i11 = (_g34 - 1);
HXDLIN(  46)										{
HXLINE(  46)											 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN(  46)											 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  46)											{
HXLINE(  46)												int _g36 = 0;
HXDLIN(  46)												int _g37 = i11;
HXDLIN(  46)												while((_g36 < _g37)){
HXLINE(  46)													_g36 = (_g36 + 1);
HXDLIN(  46)													int i12 = (_g36 - 1);
HXLINE( 345)													prev1 = l1;
HXLINE( 346)													l1 = l1->next;
            												}
            											}
HXLINE(  46)											if (::hx::IsNull( prev1 )) {
HXLINE(  46)												b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  46)												l1 = null();
            											}
            											else {
HXLINE(  46)												prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  46)												l1 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  46)						undoImage4 = b7;
            					}
            					break;
            				}
HXDLIN(  46)				this35->image = undoImage4;
HXDLIN(  46)				this35->width = width1;
HXDLIN(  46)				this35->height = height1;
HXDLIN(  46)				this35->imageType = ( (int)(imageType1) );
HXDLIN(  46)				undoImage3 = this35;
HXDLIN(  46)				{
HXLINE(  46)					int rectLeft1 = xIter31->start;
HXDLIN(  46)					int rectTop1 = yIter31->start;
HXDLIN(  46)					int rectRight1 = xIter31->max;
HXDLIN(  46)					bool forceClear1 = false;
HXDLIN(  46)					{
HXLINE(  46)						int _g38 = rectTop1;
HXDLIN(  46)						int _g39 = yIter31->max;
HXDLIN(  46)						while((_g38 < _g39)){
HXLINE(  46)							_g38 = (_g38 + 1);
HXDLIN(  46)							int dy1 = (_g38 - 1);
HXDLIN(  46)							{
HXLINE(  46)								int _g40 = rectLeft1;
HXDLIN(  46)								int _g41 = rectRight1;
HXDLIN(  46)								while((_g40 < _g41)){
HXLINE(  46)									_g40 = (_g40 + 1);
HXDLIN(  46)									int dx1 = (_g40 - 1);
HXDLIN(  46)									::Dynamic this37 = this1->image;
HXDLIN(  46)									int index5;
HXDLIN(  46)									if (this1->useVirtualPos) {
HXLINE(  46)										index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx1) - this1->virtualX));
            									}
            									else {
HXLINE(  46)										index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this1->width) + dx1)) ));
            									}
HXDLIN(  46)									int c4 = ::iterMagic::Iimg_obj::get(this37,index5);
HXDLIN(  46)									int col1;
HXDLIN(  46)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  46)										col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            									}
            									else {
HXLINE(  46)										col1 = c4;
            									}
HXDLIN(  46)									bool _hx_tmp8;
HXDLIN(  46)									if (this1->useMask) {
HXLINE(  46)										_hx_tmp8 = ::hx::IsNotNull( this1->mask );
            									}
            									else {
HXLINE(  46)										_hx_tmp8 = false;
            									}
HXDLIN(  46)									if (_hx_tmp8) {
HXLINE(  46)										 ::pi_xy::ImageStruct this38 = this1->mask;
HXDLIN(  46)										::Dynamic this39 = this38->image;
HXDLIN(  46)										int index6;
HXDLIN(  46)										if (this38->useVirtualPos) {
HXLINE(  46)											index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this38->virtualY) * ( (Float)(this38->width) )) + dx1) - this38->virtualX));
            										}
            										else {
HXLINE(  46)											index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this38->width) + dx1)) ));
            										}
HXDLIN(  46)										int c5 = ::iterMagic::Iimg_obj::get(this39,index6);
HXDLIN(  46)										int v4;
HXDLIN(  46)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  46)											v4 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            										}
            										else {
HXLINE(  46)											v4 = c5;
            										}
HXDLIN(  46)										int maskPixel1 = v4;
HXDLIN(  46)										int this40 = col1;
HXDLIN(  46)										if ((maskPixel1 == 0)) {
HXLINE(  46)											col1 = this40;
            										}
            										else {
HXLINE(  46)											Float m01;
HXDLIN(  46)											int this41 = ((maskPixel1 >> 24) & 255);
HXDLIN(  46)											if ((this41 == 0)) {
HXLINE(  46)												m01 = ((Float)0.);
            											}
            											else {
HXLINE(  46)												m01 = (( (Float)(this41) ) / ( (Float)(255) ));
            											}
HXDLIN(  46)											Float m11;
HXDLIN(  46)											int this42 = ((maskPixel1 >> 16) & 255);
HXDLIN(  46)											if ((this42 == 0)) {
HXLINE(  46)												m11 = ((Float)0.);
            											}
            											else {
HXLINE(  46)												m11 = (( (Float)(this42) ) / ( (Float)(255) ));
            											}
HXDLIN(  46)											Float m21;
HXDLIN(  46)											int this43 = ((maskPixel1 >> 8) & 255);
HXDLIN(  46)											if ((this43 == 0)) {
HXLINE(  46)												m21 = ((Float)0.);
            											}
            											else {
HXLINE(  46)												m21 = (( (Float)(this43) ) / ( (Float)(255) ));
            											}
HXDLIN(  46)											Float m31;
HXDLIN(  46)											int this44 = (maskPixel1 & 255);
HXDLIN(  46)											if ((this44 == 0)) {
HXLINE(  46)												m31 = ((Float)0.);
            											}
            											else {
HXLINE(  46)												m31 = (( (Float)(this44) ) / ( (Float)(255) ));
            											}
HXDLIN(  46)											int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this40 >> 24) & 255)) )));
HXDLIN(  46)											int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this40 >> 16) & 255)) )));
HXDLIN(  46)											int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this40 >> 8) & 255)) )));
HXDLIN(  46)											int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this40 & 255)) )));
HXDLIN(  46)											col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN(  46)									if ((col1 != 0)) {
HXLINE(  46)										int x5 = (dx1 - rectLeft1);
HXDLIN(  46)										int y5 = (dy1 - rectTop1);
HXDLIN(  46)										int c6 = col1;
HXDLIN(  46)										bool _hx_tmp9;
HXDLIN(  46)										if ((((c6 >> 24) & 255) < 254)) {
HXLINE(  46)											_hx_tmp9 = undoImage3->transparent;
            										}
            										else {
HXLINE(  46)											_hx_tmp9 = false;
            										}
HXDLIN(  46)										if (_hx_tmp9) {
HXLINE(  46)											int location2;
HXDLIN(  46)											if (undoImage3->useVirtualPos) {
HXLINE(  46)												location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            											}
            											else {
HXLINE(  46)												location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            											}
HXDLIN(  46)											int this45 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN(  46)											int this46;
HXDLIN(  46)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  46)												this46 = ((((((this45 >> 24) & 255) << 24) | ((this45 & 255) << 16)) | (((this45 >> 8) & 255) << 8)) | ((this45 >> 16) & 255));
            											}
            											else {
HXLINE(  46)												this46 = this45;
            											}
HXDLIN(  46)											Float a12;
HXDLIN(  46)											int this47 = ((this46 >> 24) & 255);
HXDLIN(  46)											if ((this47 == 0)) {
HXLINE(  46)												a12 = ((Float)0.);
            											}
            											else {
HXLINE(  46)												a12 = (( (Float)(this47) ) / ( (Float)(255) ));
            											}
HXDLIN(  46)											Float r12;
HXDLIN(  46)											int this48 = ((this46 >> 16) & 255);
HXDLIN(  46)											if ((this48 == 0)) {
HXLINE(  46)												r12 = ((Float)0.);
            											}
            											else {
HXLINE(  46)												r12 = (( (Float)(this48) ) / ( (Float)(255) ));
            											}
HXDLIN(  46)											Float g12;
HXDLIN(  46)											int this49 = ((this46 >> 8) & 255);
HXDLIN(  46)											if ((this49 == 0)) {
HXLINE(  46)												g12 = ((Float)0.);
            											}
            											else {
HXLINE(  46)												g12 = (( (Float)(this49) ) / ( (Float)(255) ));
            											}
HXDLIN(  46)											Float b13;
HXDLIN(  46)											int this50 = (this46 & 255);
HXDLIN(  46)											if ((this50 == 0)) {
HXLINE(  46)												b13 = ((Float)0.);
            											}
            											else {
HXLINE(  46)												b13 = (( (Float)(this50) ) / ( (Float)(255) ));
            											}
HXDLIN(  46)											Float a22;
HXDLIN(  46)											int this51 = ((col1 >> 24) & 255);
HXDLIN(  46)											if ((this51 == 0)) {
HXLINE(  46)												a22 = ((Float)0.);
            											}
            											else {
HXLINE(  46)												a22 = (( (Float)(this51) ) / ( (Float)(255) ));
            											}
HXDLIN(  46)											Float r22;
HXDLIN(  46)											int this52 = ((col1 >> 16) & 255);
HXDLIN(  46)											if ((this52 == 0)) {
HXLINE(  46)												r22 = ((Float)0.);
            											}
            											else {
HXLINE(  46)												r22 = (( (Float)(this52) ) / ( (Float)(255) ));
            											}
HXDLIN(  46)											Float g22;
HXDLIN(  46)											int this53 = ((col1 >> 8) & 255);
HXDLIN(  46)											if ((this53 == 0)) {
HXLINE(  46)												g22 = ((Float)0.);
            											}
            											else {
HXLINE(  46)												g22 = (( (Float)(this53) ) / ( (Float)(255) ));
            											}
HXDLIN(  46)											Float b23;
HXDLIN(  46)											int this54 = (col1 & 255);
HXDLIN(  46)											if ((this54 == 0)) {
HXLINE(  46)												b23 = ((Float)0.);
            											}
            											else {
HXLINE(  46)												b23 = (( (Float)(this54) ) / ( (Float)(255) ));
            											}
HXDLIN(  46)											Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  46)											int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  46)											int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  46)											int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  46)											int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  46)											int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN(  46)											{
HXLINE(  46)												int _hx_tmp10;
HXDLIN(  46)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  46)													_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            												}
            												else {
HXLINE(  46)													_hx_tmp10 = blended2;
            												}
HXDLIN(  46)												::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            											}
            										}
            										else {
HXLINE(  46)											::Dynamic this55 = undoImage3->image;
HXDLIN(  46)											int index7;
HXDLIN(  46)											if (undoImage3->useVirtualPos) {
HXLINE(  46)												index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            											}
            											else {
HXLINE(  46)												index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            											}
HXDLIN(  46)											int _hx_tmp11;
HXDLIN(  46)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  46)												_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            											}
            											else {
HXLINE(  46)												_hx_tmp11 = c6;
            											}
HXDLIN(  46)											::iterMagic::Iimg_obj::set(this55,index7,_hx_tmp11);
            										}
            									}
            									else {
HXLINE(  46)										if (forceClear1) {
HXLINE(  46)											::Dynamic this56 = undoImage3->image;
HXDLIN(  46)											int x6 = (dx1 - rectLeft1);
HXDLIN(  46)											int y6 = (dy1 - rectTop1);
HXDLIN(  46)											int index8;
HXDLIN(  46)											if (undoImage3->useVirtualPos) {
HXLINE(  46)												index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            											}
            											else {
HXLINE(  46)												index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            											}
HXDLIN(  46)											::iterMagic::Iimg_obj::set(this56,index8,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN(  46)			bool found1 = false;
HXDLIN(  46)			Float s1 = ((Float)0.);
HXDLIN(  46)			Float t1 = ((Float)0.);
HXDLIN(  46)			Float sxx1 = ((Float)0.);
HXDLIN(  46)			Float txx1 = ((Float)0.);
HXDLIN(  46)			{
HXLINE(  46)				int _g_min2 = xIter31->start;
HXDLIN(  46)				int _g_max2 = xIter31->max;
HXDLIN(  46)				while((_g_min2 < _g_max2)){
HXLINE(  46)					_g_min2 = (_g_min2 + 1);
HXDLIN(  46)					int x7 = (_g_min2 - 1);
HXLINE(  60)					sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)					txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)					found1 = false;
HXLINE(  46)					{
HXLINE(  46)						int _g_min3 = yIter31->start;
HXDLIN(  46)						int _g_max3 = yIter31->max;
HXDLIN(  46)						while((_g_min3 < _g_max3)){
HXLINE(  46)							_g_min3 = (_g_min3 + 1);
HXDLIN(  46)							int y7 = (_g_min3 - 1);
HXLINE(  64)							s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)							t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE(  46)							bool _hx_tmp12;
HXDLIN(  46)							if (!((s1 <= 0))) {
HXLINE(  46)								_hx_tmp12 = (t1 <= 0);
            							}
            							else {
HXLINE(  46)								_hx_tmp12 = true;
            							}
HXDLIN(  46)							if (_hx_tmp12) {
HXLINE(  46)								if (found1) {
HXLINE(  46)									goto _hx_goto_115;
            								}
            							}
            							else {
HXLINE(  46)								if (((s1 + t1) < A1)) {
HXLINE(  46)									{
HXLINE(  46)										int c7 = color;
HXDLIN(  46)										bool _hx_tmp13;
HXDLIN(  46)										if ((((c7 >> 24) & 255) < 254)) {
HXLINE(  46)											_hx_tmp13 = this1->transparent;
            										}
            										else {
HXLINE(  46)											_hx_tmp13 = false;
            										}
HXDLIN(  46)										if (_hx_tmp13) {
HXLINE(  46)											int location3;
HXDLIN(  46)											if (this1->useVirtualPos) {
HXLINE(  46)												location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this1->virtualY) * ( (Float)(this1->width) )) + x7) - this1->virtualX));
            											}
            											else {
HXLINE(  46)												location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this1->width) + x7)) ));
            											}
HXDLIN(  46)											int this57 = ::iterMagic::Iimg_obj::get(this1->image,location3);
HXDLIN(  46)											int this58;
HXDLIN(  46)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  46)												this58 = ((((((this57 >> 24) & 255) << 24) | ((this57 & 255) << 16)) | (((this57 >> 8) & 255) << 8)) | ((this57 >> 16) & 255));
            											}
            											else {
HXLINE(  46)												this58 = this57;
            											}
HXDLIN(  46)											Float a13;
HXDLIN(  46)											int this59 = ((this58 >> 24) & 255);
HXDLIN(  46)											if ((this59 == 0)) {
HXLINE(  46)												a13 = ((Float)0.);
            											}
            											else {
HXLINE(  46)												a13 = (( (Float)(this59) ) / ( (Float)(255) ));
            											}
HXDLIN(  46)											Float r13;
HXDLIN(  46)											int this60 = ((this58 >> 16) & 255);
HXDLIN(  46)											if ((this60 == 0)) {
HXLINE(  46)												r13 = ((Float)0.);
            											}
            											else {
HXLINE(  46)												r13 = (( (Float)(this60) ) / ( (Float)(255) ));
            											}
HXDLIN(  46)											Float g13;
HXDLIN(  46)											int this61 = ((this58 >> 8) & 255);
HXDLIN(  46)											if ((this61 == 0)) {
HXLINE(  46)												g13 = ((Float)0.);
            											}
            											else {
HXLINE(  46)												g13 = (( (Float)(this61) ) / ( (Float)(255) ));
            											}
HXDLIN(  46)											Float b14;
HXDLIN(  46)											int this62 = (this58 & 255);
HXDLIN(  46)											if ((this62 == 0)) {
HXLINE(  46)												b14 = ((Float)0.);
            											}
            											else {
HXLINE(  46)												b14 = (( (Float)(this62) ) / ( (Float)(255) ));
            											}
HXDLIN(  46)											Float a23;
HXDLIN(  46)											int this63 = ((color >> 24) & 255);
HXDLIN(  46)											if ((this63 == 0)) {
HXLINE(  46)												a23 = ((Float)0.);
            											}
            											else {
HXLINE(  46)												a23 = (( (Float)(this63) ) / ( (Float)(255) ));
            											}
HXDLIN(  46)											Float r23;
HXDLIN(  46)											int this64 = ((color >> 16) & 255);
HXDLIN(  46)											if ((this64 == 0)) {
HXLINE(  46)												r23 = ((Float)0.);
            											}
            											else {
HXLINE(  46)												r23 = (( (Float)(this64) ) / ( (Float)(255) ));
            											}
HXDLIN(  46)											Float g23;
HXDLIN(  46)											int this65 = ((color >> 8) & 255);
HXDLIN(  46)											if ((this65 == 0)) {
HXLINE(  46)												g23 = ((Float)0.);
            											}
            											else {
HXLINE(  46)												g23 = (( (Float)(this65) ) / ( (Float)(255) ));
            											}
HXDLIN(  46)											Float b24;
HXDLIN(  46)											int this66 = (color & 255);
HXDLIN(  46)											if ((this66 == 0)) {
HXLINE(  46)												b24 = ((Float)0.);
            											}
            											else {
HXLINE(  46)												b24 = (( (Float)(this66) ) / ( (Float)(255) ));
            											}
HXDLIN(  46)											Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  46)											int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  46)											int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  46)											int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN(  46)											int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  46)											int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN(  46)											{
HXLINE(  46)												int _hx_tmp14;
HXDLIN(  46)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  46)													_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            												}
            												else {
HXLINE(  46)													_hx_tmp14 = blended3;
            												}
HXDLIN(  46)												::iterMagic::Iimg_obj::set(this1->image,location3,_hx_tmp14);
            											}
            										}
            										else {
HXLINE(  46)											::Dynamic this67 = this1->image;
HXDLIN(  46)											int index9;
HXDLIN(  46)											if (this1->useVirtualPos) {
HXLINE(  46)												index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this1->virtualY) * ( (Float)(this1->width) )) + x7) - this1->virtualX));
            											}
            											else {
HXLINE(  46)												index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this1->width) + x7)) ));
            											}
HXDLIN(  46)											int _hx_tmp15;
HXDLIN(  46)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  46)												_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            											}
            											else {
HXLINE(  46)												_hx_tmp15 = c7;
            											}
HXDLIN(  46)											::iterMagic::Iimg_obj::set(this67,index9,_hx_tmp15);
            										}
            									}
HXLINE(  73)									found1 = true;
            								}
            								else {
HXLINE(  46)									if (found1) {
HXLINE(  46)										goto _hx_goto_115;
            									}
            								}
            							}
            						}
            						_hx_goto_115:;
            					}
            				}
            			}
HXDLIN(  46)			 ::pi_xy::algo::HitTri triHit1;
HXDLIN(  46)			if ((hasHit == true)) {
HXLINE(  46)				 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx2,by2,cx2,cy2,true);
HXDLIN(  46)				if (hasUndo1) {
HXLINE(  46)					v5->undoImage = undoImage3;
HXDLIN(  46)					v5->undoX = xIter31->start;
HXDLIN(  46)					v5->undoY = yIter31->start;
            				}
HXDLIN(  46)				triHit1 = v5;
            			}
            			else {
HXLINE(  46)				triHit1 = null();
            			}
HXDLIN(  46)			if (hasHit) {
HXLINE(  46)				arrTri[arrTri->length] = triHit1;
            			}
HXDLIN(  46)			if (hasHit) {
HXLINE(  46)				 ::pi_xy::algo::HitTriArray_obj::__alloc( HX_CTX ,arrTri);
            			}
            			else {
HXLINE( 410)				arrTri = null();
            			}
            		}
HXLINE(  47)		{
HXLINE(  47)			 ::pi_xy::ImageStruct this68 = temp;
HXDLIN(  47)			Float ax1 = this->rx;
HXDLIN(  47)			Float ay1 = this->ry;
HXDLIN(  47)			Float rx1 = (this->rx - this->strokeWidth);
HXDLIN(  47)			Float ry1 = (this->ry - this->strokeWidth);
HXDLIN(  47)			Float startRadian1 = this->startAngle;
HXDLIN(  47)			Float sweepRadian1 = this->sweepAngle;
HXDLIN(  47)			int color1 = this->fill;
HXDLIN(  47)			bool hasHit1 = false;
HXDLIN(  47)			Float rSmall1;
HXDLIN(  47)			if ((rx1 > ry1)) {
HXLINE(  47)				rSmall1 = ry1;
            			}
            			else {
HXLINE(  47)				rSmall1 = rx1;
            			}
HXDLIN(  47)			 ::Dynamic targetE1 = ((Float)1.05);
HXDLIN(  47)			if (::hx::IsNull( targetE1 )) {
HXLINE( 381)				targetE1 = ((Float)1.05);
            			}
HXLINE(  47)			int result1 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE1) ) / rSmall1)))));
HXDLIN(  47)			int noSides1;
HXDLIN(  47)			if ((result1 < 12)) {
HXLINE(  47)				noSides1 = 12;
            			}
            			else {
HXLINE(  47)				if ((result1 > 500)) {
HXLINE(  47)					noSides1 = 500;
            				}
            				else {
HXLINE(  47)					noSides1 = result1;
            				}
            			}
HXDLIN(  47)			Float theta1 = ((((Float)1.41213) * ::Math_obj::PI) / ( (Float)(noSides1) ));
HXDLIN(  47)			Float currAngle1 = startRadian1;
HXDLIN(  47)			int tot1 = ::Math_obj::floor((sweepRadian1 / theta1));
HXDLIN(  47)			theta1 = (theta1 + (((sweepRadian1 / theta1) - ( (Float)(tot1) )) / ( (Float)(noSides1) )));
HXLINE( 386)			tot1 = ::Math_obj::floor((sweepRadian1 / theta1));
HXLINE(  47)			Float bx3 = ((rx1 * ::Math_obj::cos(currAngle1)) + ax1);
HXDLIN(  47)			Float by3 = ((ry1 * ::Math_obj::sin(currAngle1)) + ay1);
HXDLIN(  47)			Float cx3 = ((Float)0.);
HXDLIN(  47)			Float cy3 = ((Float)0.);
HXDLIN(  47)			::Array< ::Dynamic> arrTri1 = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN(  47)			{
HXLINE(  47)				int _g42 = 1;
HXDLIN(  47)				int _g43 = (tot1 + 1);
HXDLIN(  47)				while((_g42 < _g43)){
HXLINE(  47)					_g42 = (_g42 + 1);
HXDLIN(  47)					int i13 = (_g42 - 1);
HXLINE( 393)					currAngle1 = (startRadian1 + (( (Float)(i13) ) * theta1));
HXLINE( 394)					cx3 = ((rx1 * ::Math_obj::cos(currAngle1)) + ax1);
HXLINE( 395)					cy3 = ((ry1 * ::Math_obj::sin(currAngle1)) + ay1);
HXLINE(  47)					bool hasUndo2 = false;
HXDLIN(  47)					Float bx4 = bx3;
HXDLIN(  47)					Float by4 = by3;
HXDLIN(  47)					Float cx4 = cx3;
HXDLIN(  47)					Float cy4 = cy3;
HXDLIN(  47)					bool adjustWinding2 = (((((ax1 * by4) - (bx4 * ay1)) + ((bx4 * cy4) - (cx4 * by4))) + ((cx4 * ay1) - (ax1 * cy4))) > 0);
HXDLIN(  47)					if (!(adjustWinding2)) {
HXLINE(  47)						Float bx_2 = bx4;
HXDLIN(  47)						Float by_2 = by4;
HXLINE(  25)						bx4 = cx4;
HXLINE(  26)						by4 = cy4;
HXLINE(  27)						cx4 = bx_2;
HXLINE(  28)						cy4 = by_2;
            					}
HXLINE(  47)					Float s02 = ((ay1 * cx4) - (ax1 * cy4));
HXDLIN(  47)					Float sx2 = (cy4 - ay1);
HXDLIN(  47)					Float sy2 = (ax1 - cx4);
HXDLIN(  47)					Float t02 = ((ax1 * by4) - (ay1 * bx4));
HXDLIN(  47)					Float tx2 = (ay1 - by4);
HXDLIN(  47)					Float ty2 = (bx4 - ax1);
HXDLIN(  47)					Float A2 = ((((-(by4) * cx4) + (ay1 * (-(bx4) + cx4))) + (ax1 * (by4 - cy4))) + (bx4 * cy4));
HXDLIN(  47)					 ::pi_xy::iter::IntIterStart xIter32;
HXDLIN(  47)					if ((ax1 > bx4)) {
HXLINE(  47)						if ((ax1 > cx4)) {
HXLINE(  47)							int min8;
HXDLIN(  47)							if ((bx4 > cx4)) {
HXLINE(  47)								min8 = ::Math_obj::floor(cx4);
            							}
            							else {
HXLINE(  47)								min8 = ::Math_obj::floor(bx4);
            							}
HXDLIN(  47)							int ii_min16 = min8;
HXDLIN(  47)							int ii_max16 = ::Math_obj::ceil(ax1);
HXDLIN(  47)							xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            						}
            						else {
HXLINE(  47)							int ii_min17 = ::Math_obj::floor(bx4);
HXDLIN(  47)							int ii_max17 = ::Math_obj::ceil(cx4);
HXDLIN(  47)							xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            						}
            					}
            					else {
HXLINE(  47)						if ((bx4 > cx4)) {
HXLINE(  47)							int min9;
HXDLIN(  47)							if ((ax1 > cx4)) {
HXLINE(  47)								min9 = ::Math_obj::floor(cx4);
            							}
            							else {
HXLINE(  47)								min9 = ::Math_obj::ceil(ax1);
            							}
HXDLIN(  47)							int ii_min18 = min9;
HXDLIN(  47)							int ii_max18 = ::Math_obj::ceil(bx4);
HXDLIN(  47)							xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            						}
            						else {
HXLINE(  47)							int ii_min19 = ::Math_obj::floor(ax1);
HXDLIN(  47)							int ii_max19 = ::Math_obj::ceil(cx4);
HXDLIN(  47)							xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            						}
            					}
HXDLIN(  47)					 ::pi_xy::iter::IntIterStart yIter32;
HXDLIN(  47)					if ((ay1 > by4)) {
HXLINE(  47)						if ((ay1 > cy4)) {
HXLINE(  47)							int min10;
HXDLIN(  47)							if ((by4 > cy4)) {
HXLINE(  47)								min10 = ::Math_obj::floor(cy4);
            							}
            							else {
HXLINE(  47)								min10 = ::Math_obj::floor(by4);
            							}
HXDLIN(  47)							int ii_min20 = min10;
HXDLIN(  47)							int ii_max20 = ::Math_obj::ceil(ay1);
HXDLIN(  47)							yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            						}
            						else {
HXLINE(  47)							int ii_min21 = ::Math_obj::floor(by4);
HXDLIN(  47)							int ii_max21 = ::Math_obj::ceil(cy4);
HXDLIN(  47)							yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            						}
            					}
            					else {
HXLINE(  47)						if ((by4 > cy4)) {
HXLINE(  47)							int min11;
HXDLIN(  47)							if ((ay1 > cy4)) {
HXLINE(  47)								min11 = ::Math_obj::floor(cy4);
            							}
            							else {
HXLINE(  47)								min11 = ::Math_obj::ceil(ay1);
            							}
HXDLIN(  47)							int ii_min22 = min11;
HXDLIN(  47)							int ii_max22 = ::Math_obj::ceil(by4);
HXDLIN(  47)							yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            						}
            						else {
HXLINE(  47)							int ii_min23 = ::Math_obj::floor(ay1);
HXDLIN(  47)							int ii_max23 = ::Math_obj::ceil(cy4);
HXDLIN(  47)							yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            						}
            					}
HXDLIN(  47)					 ::pi_xy::ImageStruct undoImage6 = null();
HXDLIN(  47)					if (hasUndo2) {
HXLINE(  47)						int width2 = ((xIter32->max - xIter32->start) + 1);
HXDLIN(  47)						int height2 = ((yIter32->max - yIter32->start) + 1);
HXDLIN(  47)						 ::Dynamic imageType2 = null();
HXDLIN(  47)						 ::pi_xy::ImageStruct this69 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  47)						if (::hx::IsNull( imageType2 )) {
HXLINE(  54)							imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE(  47)						::Dynamic undoImage7;
HXDLIN(  47)						switch((int)(( (int)(imageType2) ))){
            							case (int)0: {
HXLINE(  47)								 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  47)								 ::iterMagic::BytesImg b10 = byt2;
HXDLIN(  47)								{
HXLINE(  47)									b10->width = width2;
HXDLIN(  47)									b10->height = height2;
HXDLIN(  47)									b10->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  47)									b10->data = ::haxe::io::Bytes_obj::alloc((b10->length * 4));
HXDLIN(  47)									{
HXLINE(  47)										int len4 = b10->length;
HXDLIN(  47)										int w2 = 0;
HXDLIN(  47)										{
HXLINE(  47)											int _g44 = 0;
HXDLIN(  47)											int _g45 = b10->height;
HXDLIN(  47)											while((_g44 < _g45)){
HXLINE(  47)												_g44 = (_g44 + 1);
HXDLIN(  47)												int y8 = (_g44 - 1);
HXDLIN(  47)												{
HXLINE(  47)													int _g46 = 0;
HXDLIN(  47)													int _g47 = b10->width;
HXDLIN(  47)													while((_g46 < _g47)){
HXLINE(  47)														_g46 = (_g46 + 1);
HXDLIN(  47)														int x8 = (_g46 - 1);
HXDLIN(  47)														{
HXLINE(  47)															w2 = (w2 + 1);
HXDLIN(  47)															b10->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  47)														{
HXLINE(  47)															w2 = (w2 + 1);
HXDLIN(  47)															b10->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  47)														{
HXLINE(  47)															w2 = (w2 + 1);
HXDLIN(  47)															b10->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  47)														{
HXLINE(  47)															w2 = (w2 + 1);
HXDLIN(  47)															b10->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  47)								undoImage7 = b10;
            							}
            							break;
            							case (int)1: {
HXLINE(  47)								 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  47)								 ::iterMagic::ArrIntImg a9 = arrI2;
HXDLIN(  47)								{
HXLINE(  47)									a9->width = width2;
HXDLIN(  47)									a9->height = height2;
HXDLIN(  47)									a9->data = ::Array_obj< int >::__new(0);
HXDLIN(  47)									a9->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  47)									{
HXLINE(  47)										int _g48 = 0;
HXDLIN(  47)										int _g49 = a9->length;
HXDLIN(  47)										while((_g48 < _g49)){
HXLINE(  47)											_g48 = (_g48 + 1);
HXDLIN(  47)											int i14 = (_g48 - 1);
HXDLIN(  47)											a9->data[i14] = 0;
            										}
            									}
            								}
HXDLIN(  47)								undoImage7 = a9;
            							}
            							break;
            							case (int)2: {
HXLINE(  47)								 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  47)								 ::iterMagic::U32ArrImg b15 = u32a2;
HXDLIN(  47)								{
HXLINE(  47)									b15->width = width2;
HXDLIN(  47)									b15->height = height2;
HXDLIN(  47)									b15->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  47)									int size2 = (b15->length * 4);
HXDLIN(  47)									b15->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN(  47)									{
HXLINE(  47)										int _g50 = 0;
HXDLIN(  47)										int _g51 = b15->length;
HXDLIN(  47)										while((_g50 < _g51)){
HXLINE(  47)											_g50 = (_g50 + 1);
HXDLIN(  47)											int i15 = (_g50 - 1);
HXDLIN(  47)											{
HXLINE(  47)												 ::haxe::io::ArrayBufferViewImpl this70 = b15->data;
HXDLIN(  47)												bool undoImage8;
HXDLIN(  47)												if ((i15 >= 0)) {
HXLINE(  47)													undoImage8 = (i15 < (this70->byteLength >> 2));
            												}
            												else {
HXLINE(  47)													undoImage8 = false;
            												}
HXDLIN(  47)												if (undoImage8) {
HXLINE(  47)													 ::haxe::io::Bytes _this2 = this70->bytes;
HXDLIN(  47)													int pos2 = ((i15 << 2) + this70->byteOffset);
HXDLIN(  47)													_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN(  47)													_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN(  47)													_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN(  47)													_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN(  47)								undoImage7 = b15;
            							}
            							break;
            							case (int)3: {
HXLINE(  47)								 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  47)								 ::iterMagic::VecIntImg v6 = vec2;
HXDLIN(  47)								{
HXLINE(  47)									v6->width = width2;
HXDLIN(  47)									v6->height = height2;
HXDLIN(  47)									v6->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  47)									v6->data = ::Array_obj< int >::__new(v6->length);
HXDLIN(  47)									{
HXLINE(  47)										int _g52 = 0;
HXDLIN(  47)										int _g53 = v6->length;
HXDLIN(  47)										while((_g52 < _g53)){
HXLINE(  47)											_g52 = (_g52 + 1);
HXDLIN(  47)											int i16 = (_g52 - 1);
HXDLIN(  47)											v6->data->__unsafe_set(i16,0);
            										}
            									}
            								}
HXDLIN(  47)								undoImage7 = v6;
            							}
            							break;
            							case (int)4: {
HXLINE(  47)								 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  47)								 ::iterMagic::StackIntImg b16 = sInt2;
HXDLIN(  47)								{
HXLINE(  47)									b16->width = width2;
HXDLIN(  47)									b16->height = height2;
HXDLIN(  47)									b16->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  47)									b16->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  47)									{
HXLINE(  47)										int len5 = b16->length;
HXDLIN(  47)										 ::haxe::ds::GenericStack_Int d2 = b16->data;
HXDLIN(  47)										if (::hx::IsNull( d2->head )) {
HXLINE(  47)											int _g54 = 0;
HXDLIN(  47)											int _g55 = len5;
HXDLIN(  47)											while((_g54 < _g55)){
HXLINE(  47)												_g54 = (_g54 + 1);
HXDLIN(  47)												int i17 = (_g54 - 1);
HXDLIN(  47)												d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            											}
            										}
            										else {
HXLINE(  47)											int _g56 = 0;
HXDLIN(  47)											int _g57 = len5;
HXDLIN(  47)											while((_g56 < _g57)){
HXLINE(  47)												_g56 = (_g56 + 1);
HXDLIN(  47)												int i18 = (_g56 - 1);
HXDLIN(  47)												{
HXLINE(  47)													 ::haxe::ds::GenericCell_Int l2 = b16->data->head;
HXDLIN(  47)													 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN(  47)													{
HXLINE(  47)														int _g58 = 0;
HXDLIN(  47)														int _g59 = i18;
HXDLIN(  47)														while((_g58 < _g59)){
HXLINE(  47)															_g58 = (_g58 + 1);
HXDLIN(  47)															int i19 = (_g58 - 1);
HXLINE( 345)															prev2 = l2;
HXLINE( 346)															l2 = l2->next;
            														}
            													}
HXLINE(  47)													if (::hx::IsNull( prev2 )) {
HXLINE(  47)														b16->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  47)														l2 = null();
            													}
            													else {
HXLINE(  47)														prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  47)														l2 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  47)								undoImage7 = b16;
            							}
            							break;
            						}
HXDLIN(  47)						this69->image = undoImage7;
HXDLIN(  47)						this69->width = width2;
HXDLIN(  47)						this69->height = height2;
HXDLIN(  47)						this69->imageType = ( (int)(imageType2) );
HXDLIN(  47)						undoImage6 = this69;
HXDLIN(  47)						{
HXLINE(  47)							int rectLeft2 = xIter32->start;
HXDLIN(  47)							int rectTop2 = yIter32->start;
HXDLIN(  47)							int rectRight2 = xIter32->max;
HXDLIN(  47)							bool forceClear2 = false;
HXDLIN(  47)							{
HXLINE(  47)								int _g60 = rectTop2;
HXDLIN(  47)								int _g61 = yIter32->max;
HXDLIN(  47)								while((_g60 < _g61)){
HXLINE(  47)									_g60 = (_g60 + 1);
HXDLIN(  47)									int dy2 = (_g60 - 1);
HXDLIN(  47)									{
HXLINE(  47)										int _g62 = rectLeft2;
HXDLIN(  47)										int _g63 = rectRight2;
HXDLIN(  47)										while((_g62 < _g63)){
HXLINE(  47)											_g62 = (_g62 + 1);
HXDLIN(  47)											int dx2 = (_g62 - 1);
HXDLIN(  47)											::Dynamic this71 = this68->image;
HXDLIN(  47)											int index10;
HXDLIN(  47)											if (this68->useVirtualPos) {
HXLINE(  47)												index10 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this68->virtualY) * ( (Float)(this68->width) )) + dx2) - this68->virtualX));
            											}
            											else {
HXLINE(  47)												index10 = ::Std_obj::_hx_int(( (Float)(((dy2 * this68->width) + dx2)) ));
            											}
HXDLIN(  47)											int c8 = ::iterMagic::Iimg_obj::get(this71,index10);
HXDLIN(  47)											int col2;
HXDLIN(  47)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)												col2 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            											}
            											else {
HXLINE(  47)												col2 = c8;
            											}
HXDLIN(  47)											bool _hx_tmp16;
HXDLIN(  47)											if (this68->useMask) {
HXLINE(  47)												_hx_tmp16 = ::hx::IsNotNull( this68->mask );
            											}
            											else {
HXLINE(  47)												_hx_tmp16 = false;
            											}
HXDLIN(  47)											if (_hx_tmp16) {
HXLINE(  47)												 ::pi_xy::ImageStruct this72 = this68->mask;
HXDLIN(  47)												::Dynamic this73 = this72->image;
HXDLIN(  47)												int index11;
HXDLIN(  47)												if (this72->useVirtualPos) {
HXLINE(  47)													index11 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this72->virtualY) * ( (Float)(this72->width) )) + dx2) - this72->virtualX));
            												}
            												else {
HXLINE(  47)													index11 = ::Std_obj::_hx_int(( (Float)(((dy2 * this72->width) + dx2)) ));
            												}
HXDLIN(  47)												int c9 = ::iterMagic::Iimg_obj::get(this73,index11);
HXDLIN(  47)												int v7;
HXDLIN(  47)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)													v7 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            												}
            												else {
HXLINE(  47)													v7 = c9;
            												}
HXDLIN(  47)												int maskPixel2 = v7;
HXDLIN(  47)												int this74 = col2;
HXDLIN(  47)												if ((maskPixel2 == 0)) {
HXLINE(  47)													col2 = this74;
            												}
            												else {
HXLINE(  47)													Float m02;
HXDLIN(  47)													int this75 = ((maskPixel2 >> 24) & 255);
HXDLIN(  47)													if ((this75 == 0)) {
HXLINE(  47)														m02 = ((Float)0.);
            													}
            													else {
HXLINE(  47)														m02 = (( (Float)(this75) ) / ( (Float)(255) ));
            													}
HXDLIN(  47)													Float m12;
HXDLIN(  47)													int this76 = ((maskPixel2 >> 16) & 255);
HXDLIN(  47)													if ((this76 == 0)) {
HXLINE(  47)														m12 = ((Float)0.);
            													}
            													else {
HXLINE(  47)														m12 = (( (Float)(this76) ) / ( (Float)(255) ));
            													}
HXDLIN(  47)													Float m22;
HXDLIN(  47)													int this77 = ((maskPixel2 >> 8) & 255);
HXDLIN(  47)													if ((this77 == 0)) {
HXLINE(  47)														m22 = ((Float)0.);
            													}
            													else {
HXLINE(  47)														m22 = (( (Float)(this77) ) / ( (Float)(255) ));
            													}
HXDLIN(  47)													Float m32;
HXDLIN(  47)													int this78 = (maskPixel2 & 255);
HXDLIN(  47)													if ((this78 == 0)) {
HXLINE(  47)														m32 = ((Float)0.);
            													}
            													else {
HXLINE(  47)														m32 = (( (Float)(this78) ) / ( (Float)(255) ));
            													}
HXDLIN(  47)													int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this74 >> 24) & 255)) )));
HXDLIN(  47)													int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this74 >> 16) & 255)) )));
HXDLIN(  47)													int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this74 >> 8) & 255)) )));
HXDLIN(  47)													int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this74 & 255)) )));
HXDLIN(  47)													col2 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  47)											if ((col2 != 0)) {
HXLINE(  47)												int x9 = (dx2 - rectLeft2);
HXDLIN(  47)												int y9 = (dy2 - rectTop2);
HXDLIN(  47)												int c10 = col2;
HXDLIN(  47)												bool _hx_tmp17;
HXDLIN(  47)												if ((((c10 >> 24) & 255) < 254)) {
HXLINE(  47)													_hx_tmp17 = undoImage6->transparent;
            												}
            												else {
HXLINE(  47)													_hx_tmp17 = false;
            												}
HXDLIN(  47)												if (_hx_tmp17) {
HXLINE(  47)													int location4;
HXDLIN(  47)													if (undoImage6->useVirtualPos) {
HXLINE(  47)														location4 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x9) - undoImage6->virtualX));
            													}
            													else {
HXLINE(  47)														location4 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage6->width) + x9)) ));
            													}
HXDLIN(  47)													int this79 = ::iterMagic::Iimg_obj::get(undoImage6->image,location4);
HXDLIN(  47)													int this80;
HXDLIN(  47)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)														this80 = ((((((this79 >> 24) & 255) << 24) | ((this79 & 255) << 16)) | (((this79 >> 8) & 255) << 8)) | ((this79 >> 16) & 255));
            													}
            													else {
HXLINE(  47)														this80 = this79;
            													}
HXDLIN(  47)													Float a14;
HXDLIN(  47)													int this81 = ((this80 >> 24) & 255);
HXDLIN(  47)													if ((this81 == 0)) {
HXLINE(  47)														a14 = ((Float)0.);
            													}
            													else {
HXLINE(  47)														a14 = (( (Float)(this81) ) / ( (Float)(255) ));
            													}
HXDLIN(  47)													Float r14;
HXDLIN(  47)													int this82 = ((this80 >> 16) & 255);
HXDLIN(  47)													if ((this82 == 0)) {
HXLINE(  47)														r14 = ((Float)0.);
            													}
            													else {
HXLINE(  47)														r14 = (( (Float)(this82) ) / ( (Float)(255) ));
            													}
HXDLIN(  47)													Float g14;
HXDLIN(  47)													int this83 = ((this80 >> 8) & 255);
HXDLIN(  47)													if ((this83 == 0)) {
HXLINE(  47)														g14 = ((Float)0.);
            													}
            													else {
HXLINE(  47)														g14 = (( (Float)(this83) ) / ( (Float)(255) ));
            													}
HXDLIN(  47)													Float b17;
HXDLIN(  47)													int this84 = (this80 & 255);
HXDLIN(  47)													if ((this84 == 0)) {
HXLINE(  47)														b17 = ((Float)0.);
            													}
            													else {
HXLINE(  47)														b17 = (( (Float)(this84) ) / ( (Float)(255) ));
            													}
HXDLIN(  47)													Float a24;
HXDLIN(  47)													int this85 = ((col2 >> 24) & 255);
HXDLIN(  47)													if ((this85 == 0)) {
HXLINE(  47)														a24 = ((Float)0.);
            													}
            													else {
HXLINE(  47)														a24 = (( (Float)(this85) ) / ( (Float)(255) ));
            													}
HXDLIN(  47)													Float r24;
HXDLIN(  47)													int this86 = ((col2 >> 16) & 255);
HXDLIN(  47)													if ((this86 == 0)) {
HXLINE(  47)														r24 = ((Float)0.);
            													}
            													else {
HXLINE(  47)														r24 = (( (Float)(this86) ) / ( (Float)(255) ));
            													}
HXDLIN(  47)													Float g24;
HXDLIN(  47)													int this87 = ((col2 >> 8) & 255);
HXDLIN(  47)													if ((this87 == 0)) {
HXLINE(  47)														g24 = ((Float)0.);
            													}
            													else {
HXLINE(  47)														g24 = (( (Float)(this87) ) / ( (Float)(255) ));
            													}
HXDLIN(  47)													Float b25;
HXDLIN(  47)													int this88 = (col2 & 255);
HXDLIN(  47)													if ((this88 == 0)) {
HXLINE(  47)														b25 = ((Float)0.);
            													}
            													else {
HXLINE(  47)														b25 = (( (Float)(this88) ) / ( (Float)(255) ));
            													}
HXDLIN(  47)													Float a34 = (a14 * (( (Float)(1) ) - a24));
HXDLIN(  47)													int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN(  47)													int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN(  47)													int b18 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b17 * a34) + (b25 * a24))));
HXDLIN(  47)													int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN(  47)													int blended4 = ((((a10 << 24) | (r6 << 16)) | (g6 << 8)) | b18);
HXDLIN(  47)													{
HXLINE(  47)														int _hx_tmp18;
HXDLIN(  47)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)															_hx_tmp18 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            														}
            														else {
HXLINE(  47)															_hx_tmp18 = blended4;
            														}
HXDLIN(  47)														::iterMagic::Iimg_obj::set(undoImage6->image,location4,_hx_tmp18);
            													}
            												}
            												else {
HXLINE(  47)													::Dynamic this89 = undoImage6->image;
HXDLIN(  47)													int index12;
HXDLIN(  47)													if (undoImage6->useVirtualPos) {
HXLINE(  47)														index12 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x9) - undoImage6->virtualX));
            													}
            													else {
HXLINE(  47)														index12 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage6->width) + x9)) ));
            													}
HXDLIN(  47)													int _hx_tmp19;
HXDLIN(  47)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)														_hx_tmp19 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            													}
            													else {
HXLINE(  47)														_hx_tmp19 = c10;
            													}
HXDLIN(  47)													::iterMagic::Iimg_obj::set(this89,index12,_hx_tmp19);
            												}
            											}
            											else {
HXLINE(  47)												if (forceClear2) {
HXLINE(  47)													::Dynamic this90 = undoImage6->image;
HXDLIN(  47)													int x10 = (dx2 - rectLeft2);
HXDLIN(  47)													int y10 = (dy2 - rectTop2);
HXDLIN(  47)													int index13;
HXDLIN(  47)													if (undoImage6->useVirtualPos) {
HXLINE(  47)														index13 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x10) - undoImage6->virtualX));
            													}
            													else {
HXLINE(  47)														index13 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage6->width) + x10)) ));
            													}
HXDLIN(  47)													::iterMagic::Iimg_obj::set(this90,index13,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  47)					bool found2 = false;
HXDLIN(  47)					Float s2 = ((Float)0.);
HXDLIN(  47)					Float t2 = ((Float)0.);
HXDLIN(  47)					Float sxx2 = ((Float)0.);
HXDLIN(  47)					Float txx2 = ((Float)0.);
HXDLIN(  47)					{
HXLINE(  47)						int _g_min4 = xIter32->start;
HXDLIN(  47)						int _g_max4 = xIter32->max;
HXDLIN(  47)						while((_g_min4 < _g_max4)){
HXLINE(  47)							_g_min4 = (_g_min4 + 1);
HXDLIN(  47)							int x11 = (_g_min4 - 1);
HXLINE(  60)							sxx2 = (sx2 * ( (Float)(x11) ));
HXLINE(  61)							txx2 = (tx2 * ( (Float)(x11) ));
HXLINE(  62)							found2 = false;
HXLINE(  47)							{
HXLINE(  47)								int _g_min5 = yIter32->start;
HXDLIN(  47)								int _g_max5 = yIter32->max;
HXDLIN(  47)								while((_g_min5 < _g_max5)){
HXLINE(  47)									_g_min5 = (_g_min5 + 1);
HXDLIN(  47)									int y11 = (_g_min5 - 1);
HXLINE(  64)									s2 = ((s02 + sxx2) + (sy2 * ( (Float)(y11) )));
HXLINE(  65)									t2 = ((t02 + txx2) + (ty2 * ( (Float)(y11) )));
HXLINE(  47)									bool _hx_tmp20;
HXDLIN(  47)									if (!((s2 <= 0))) {
HXLINE(  47)										_hx_tmp20 = (t2 <= 0);
            									}
            									else {
HXLINE(  47)										_hx_tmp20 = true;
            									}
HXDLIN(  47)									if (_hx_tmp20) {
HXLINE(  47)										if (found2) {
HXLINE(  47)											goto _hx_goto_128;
            										}
            									}
            									else {
HXLINE(  47)										if (((s2 + t2) < A2)) {
HXLINE(  47)											{
HXLINE(  47)												int c11 = color1;
HXDLIN(  47)												bool _hx_tmp21;
HXDLIN(  47)												if ((((c11 >> 24) & 255) < 254)) {
HXLINE(  47)													_hx_tmp21 = this68->transparent;
            												}
            												else {
HXLINE(  47)													_hx_tmp21 = false;
            												}
HXDLIN(  47)												if (_hx_tmp21) {
HXLINE(  47)													int location5;
HXDLIN(  47)													if (this68->useVirtualPos) {
HXLINE(  47)														location5 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - this68->virtualY) * ( (Float)(this68->width) )) + x11) - this68->virtualX));
            													}
            													else {
HXLINE(  47)														location5 = ::Std_obj::_hx_int(( (Float)(((y11 * this68->width) + x11)) ));
            													}
HXDLIN(  47)													int this91 = ::iterMagic::Iimg_obj::get(this68->image,location5);
HXDLIN(  47)													int this92;
HXDLIN(  47)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)														this92 = ((((((this91 >> 24) & 255) << 24) | ((this91 & 255) << 16)) | (((this91 >> 8) & 255) << 8)) | ((this91 >> 16) & 255));
            													}
            													else {
HXLINE(  47)														this92 = this91;
            													}
HXDLIN(  47)													Float a15;
HXDLIN(  47)													int this93 = ((this92 >> 24) & 255);
HXDLIN(  47)													if ((this93 == 0)) {
HXLINE(  47)														a15 = ((Float)0.);
            													}
            													else {
HXLINE(  47)														a15 = (( (Float)(this93) ) / ( (Float)(255) ));
            													}
HXDLIN(  47)													Float r15;
HXDLIN(  47)													int this94 = ((this92 >> 16) & 255);
HXDLIN(  47)													if ((this94 == 0)) {
HXLINE(  47)														r15 = ((Float)0.);
            													}
            													else {
HXLINE(  47)														r15 = (( (Float)(this94) ) / ( (Float)(255) ));
            													}
HXDLIN(  47)													Float g15;
HXDLIN(  47)													int this95 = ((this92 >> 8) & 255);
HXDLIN(  47)													if ((this95 == 0)) {
HXLINE(  47)														g15 = ((Float)0.);
            													}
            													else {
HXLINE(  47)														g15 = (( (Float)(this95) ) / ( (Float)(255) ));
            													}
HXDLIN(  47)													Float b19;
HXDLIN(  47)													int this96 = (this92 & 255);
HXDLIN(  47)													if ((this96 == 0)) {
HXLINE(  47)														b19 = ((Float)0.);
            													}
            													else {
HXLINE(  47)														b19 = (( (Float)(this96) ) / ( (Float)(255) ));
            													}
HXDLIN(  47)													Float a25;
HXDLIN(  47)													int this97 = ((color1 >> 24) & 255);
HXDLIN(  47)													if ((this97 == 0)) {
HXLINE(  47)														a25 = ((Float)0.);
            													}
            													else {
HXLINE(  47)														a25 = (( (Float)(this97) ) / ( (Float)(255) ));
            													}
HXDLIN(  47)													Float r25;
HXDLIN(  47)													int this98 = ((color1 >> 16) & 255);
HXDLIN(  47)													if ((this98 == 0)) {
HXLINE(  47)														r25 = ((Float)0.);
            													}
            													else {
HXLINE(  47)														r25 = (( (Float)(this98) ) / ( (Float)(255) ));
            													}
HXDLIN(  47)													Float g25;
HXDLIN(  47)													int this99 = ((color1 >> 8) & 255);
HXDLIN(  47)													if ((this99 == 0)) {
HXLINE(  47)														g25 = ((Float)0.);
            													}
            													else {
HXLINE(  47)														g25 = (( (Float)(this99) ) / ( (Float)(255) ));
            													}
HXDLIN(  47)													Float b26;
HXDLIN(  47)													int this100 = (color1 & 255);
HXDLIN(  47)													if ((this100 == 0)) {
HXLINE(  47)														b26 = ((Float)0.);
            													}
            													else {
HXLINE(  47)														b26 = (( (Float)(this100) ) / ( (Float)(255) ));
            													}
HXDLIN(  47)													Float a35 = (a15 * (( (Float)(1) ) - a25));
HXDLIN(  47)													int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN(  47)													int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN(  47)													int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b19 * a35) + (b26 * a25))));
HXDLIN(  47)													int a16 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN(  47)													int blended5 = ((((a16 << 24) | (r7 << 16)) | (g7 << 8)) | b20);
HXDLIN(  47)													{
HXLINE(  47)														int _hx_tmp22;
HXDLIN(  47)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)															_hx_tmp22 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            														}
            														else {
HXLINE(  47)															_hx_tmp22 = blended5;
            														}
HXDLIN(  47)														::iterMagic::Iimg_obj::set(this68->image,location5,_hx_tmp22);
            													}
            												}
            												else {
HXLINE(  47)													::Dynamic this101 = this68->image;
HXDLIN(  47)													int index14;
HXDLIN(  47)													if (this68->useVirtualPos) {
HXLINE(  47)														index14 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - this68->virtualY) * ( (Float)(this68->width) )) + x11) - this68->virtualX));
            													}
            													else {
HXLINE(  47)														index14 = ::Std_obj::_hx_int(( (Float)(((y11 * this68->width) + x11)) ));
            													}
HXDLIN(  47)													int _hx_tmp23;
HXDLIN(  47)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)														_hx_tmp23 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            													}
            													else {
HXLINE(  47)														_hx_tmp23 = c11;
            													}
HXDLIN(  47)													::iterMagic::Iimg_obj::set(this101,index14,_hx_tmp23);
            												}
            											}
HXLINE(  73)											found2 = true;
            										}
            										else {
HXLINE(  47)											if (found2) {
HXLINE(  47)												goto _hx_goto_128;
            											}
            										}
            									}
            								}
            								_hx_goto_128:;
            							}
            						}
            					}
HXDLIN(  47)					 ::pi_xy::algo::HitTri triHit2;
HXDLIN(  47)					if ((hasHit1 == true)) {
HXLINE(  47)						 ::pi_xy::algo::HitTri v8 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax1,ay1,bx4,by4,cx4,cy4,true);
HXDLIN(  47)						if (hasUndo2) {
HXLINE(  47)							v8->undoImage = undoImage6;
HXDLIN(  47)							v8->undoX = xIter32->start;
HXDLIN(  47)							v8->undoY = yIter32->start;
            						}
HXDLIN(  47)						triHit2 = v8;
            					}
            					else {
HXLINE(  47)						triHit2 = null();
            					}
HXDLIN(  47)					if (hasHit1) {
HXLINE(  47)						arrTri1[arrTri1->length] = triHit2;
            					}
HXLINE( 398)					bx3 = cx3;
HXLINE( 399)					by3 = cy3;
            				}
            			}
HXLINE( 402)			currAngle1 = (startRadian1 + sweepRadian1);
HXLINE( 403)			cx3 = ((rx1 * ::Math_obj::cos(currAngle1)) + ax1);
HXLINE( 404)			cy3 = ((ry1 * ::Math_obj::sin(currAngle1)) + ay1);
HXLINE(  47)			bool hasUndo3 = false;
HXDLIN(  47)			Float bx5 = bx3;
HXDLIN(  47)			Float by5 = by3;
HXDLIN(  47)			Float cx5 = cx3;
HXDLIN(  47)			Float cy5 = cy3;
HXDLIN(  47)			bool adjustWinding3 = (((((ax1 * by5) - (bx5 * ay1)) + ((bx5 * cy5) - (cx5 * by5))) + ((cx5 * ay1) - (ax1 * cy5))) > 0);
HXDLIN(  47)			if (!(adjustWinding3)) {
HXLINE(  47)				Float bx_3 = bx5;
HXDLIN(  47)				Float by_3 = by5;
HXLINE(  25)				bx5 = cx5;
HXLINE(  26)				by5 = cy5;
HXLINE(  27)				cx5 = bx_3;
HXLINE(  28)				cy5 = by_3;
            			}
HXLINE(  47)			Float s03 = ((ay1 * cx5) - (ax1 * cy5));
HXDLIN(  47)			Float sx3 = (cy5 - ay1);
HXDLIN(  47)			Float sy3 = (ax1 - cx5);
HXDLIN(  47)			Float t03 = ((ax1 * by5) - (ay1 * bx5));
HXDLIN(  47)			Float tx3 = (ay1 - by5);
HXDLIN(  47)			Float ty3 = (bx5 - ax1);
HXDLIN(  47)			Float A3 = ((((-(by5) * cx5) + (ay1 * (-(bx5) + cx5))) + (ax1 * (by5 - cy5))) + (bx5 * cy5));
HXDLIN(  47)			 ::pi_xy::iter::IntIterStart xIter33;
HXDLIN(  47)			if ((ax1 > bx5)) {
HXLINE(  47)				if ((ax1 > cx5)) {
HXLINE(  47)					int min12;
HXDLIN(  47)					if ((bx5 > cx5)) {
HXLINE(  47)						min12 = ::Math_obj::floor(cx5);
            					}
            					else {
HXLINE(  47)						min12 = ::Math_obj::floor(bx5);
            					}
HXDLIN(  47)					int ii_min24 = min12;
HXDLIN(  47)					int ii_max24 = ::Math_obj::ceil(ax1);
HXDLIN(  47)					xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            				}
            				else {
HXLINE(  47)					int ii_min25 = ::Math_obj::floor(bx5);
HXDLIN(  47)					int ii_max25 = ::Math_obj::ceil(cx5);
HXDLIN(  47)					xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            				}
            			}
            			else {
HXLINE(  47)				if ((bx5 > cx5)) {
HXLINE(  47)					int min13;
HXDLIN(  47)					if ((ax1 > cx5)) {
HXLINE(  47)						min13 = ::Math_obj::floor(cx5);
            					}
            					else {
HXLINE(  47)						min13 = ::Math_obj::ceil(ax1);
            					}
HXDLIN(  47)					int ii_min26 = min13;
HXDLIN(  47)					int ii_max26 = ::Math_obj::ceil(bx5);
HXDLIN(  47)					xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            				}
            				else {
HXLINE(  47)					int ii_min27 = ::Math_obj::floor(ax1);
HXDLIN(  47)					int ii_max27 = ::Math_obj::ceil(cx5);
HXDLIN(  47)					xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            				}
            			}
HXDLIN(  47)			 ::pi_xy::iter::IntIterStart yIter33;
HXDLIN(  47)			if ((ay1 > by5)) {
HXLINE(  47)				if ((ay1 > cy5)) {
HXLINE(  47)					int min14;
HXDLIN(  47)					if ((by5 > cy5)) {
HXLINE(  47)						min14 = ::Math_obj::floor(cy5);
            					}
            					else {
HXLINE(  47)						min14 = ::Math_obj::floor(by5);
            					}
HXDLIN(  47)					int ii_min28 = min14;
HXDLIN(  47)					int ii_max28 = ::Math_obj::ceil(ay1);
HXDLIN(  47)					yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            				}
            				else {
HXLINE(  47)					int ii_min29 = ::Math_obj::floor(by5);
HXDLIN(  47)					int ii_max29 = ::Math_obj::ceil(cy5);
HXDLIN(  47)					yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            				}
            			}
            			else {
HXLINE(  47)				if ((by5 > cy5)) {
HXLINE(  47)					int min15;
HXDLIN(  47)					if ((ay1 > cy5)) {
HXLINE(  47)						min15 = ::Math_obj::floor(cy5);
            					}
            					else {
HXLINE(  47)						min15 = ::Math_obj::ceil(ay1);
            					}
HXDLIN(  47)					int ii_min30 = min15;
HXDLIN(  47)					int ii_max30 = ::Math_obj::ceil(by5);
HXDLIN(  47)					yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            				}
            				else {
HXLINE(  47)					int ii_min31 = ::Math_obj::floor(ay1);
HXDLIN(  47)					int ii_max31 = ::Math_obj::ceil(cy5);
HXDLIN(  47)					yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            				}
            			}
HXDLIN(  47)			 ::pi_xy::ImageStruct undoImage9 = null();
HXDLIN(  47)			if (hasUndo3) {
HXLINE(  47)				int width3 = ((xIter33->max - xIter33->start) + 1);
HXDLIN(  47)				int height3 = ((yIter33->max - yIter33->start) + 1);
HXDLIN(  47)				 ::Dynamic imageType3 = null();
HXDLIN(  47)				 ::pi_xy::ImageStruct this102 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  47)				if (::hx::IsNull( imageType3 )) {
HXLINE(  54)					imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE(  47)				::Dynamic undoImage10;
HXDLIN(  47)				switch((int)(( (int)(imageType3) ))){
            					case (int)0: {
HXLINE(  47)						 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  47)						 ::iterMagic::BytesImg b27 = byt3;
HXDLIN(  47)						{
HXLINE(  47)							b27->width = width3;
HXDLIN(  47)							b27->height = height3;
HXDLIN(  47)							b27->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  47)							b27->data = ::haxe::io::Bytes_obj::alloc((b27->length * 4));
HXDLIN(  47)							{
HXLINE(  47)								int len6 = b27->length;
HXDLIN(  47)								int w3 = 0;
HXDLIN(  47)								{
HXLINE(  47)									int _g64 = 0;
HXDLIN(  47)									int _g65 = b27->height;
HXDLIN(  47)									while((_g64 < _g65)){
HXLINE(  47)										_g64 = (_g64 + 1);
HXDLIN(  47)										int y12 = (_g64 - 1);
HXDLIN(  47)										{
HXLINE(  47)											int _g66 = 0;
HXDLIN(  47)											int _g67 = b27->width;
HXDLIN(  47)											while((_g66 < _g67)){
HXLINE(  47)												_g66 = (_g66 + 1);
HXDLIN(  47)												int x12 = (_g66 - 1);
HXDLIN(  47)												{
HXLINE(  47)													w3 = (w3 + 1);
HXDLIN(  47)													b27->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  47)												{
HXLINE(  47)													w3 = (w3 + 1);
HXDLIN(  47)													b27->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  47)												{
HXLINE(  47)													w3 = (w3 + 1);
HXDLIN(  47)													b27->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  47)												{
HXLINE(  47)													w3 = (w3 + 1);
HXDLIN(  47)													b27->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  47)						undoImage10 = b27;
            					}
            					break;
            					case (int)1: {
HXLINE(  47)						 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  47)						 ::iterMagic::ArrIntImg a17 = arrI3;
HXDLIN(  47)						{
HXLINE(  47)							a17->width = width3;
HXDLIN(  47)							a17->height = height3;
HXDLIN(  47)							a17->data = ::Array_obj< int >::__new(0);
HXDLIN(  47)							a17->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  47)							{
HXLINE(  47)								int _g68 = 0;
HXDLIN(  47)								int _g69 = a17->length;
HXDLIN(  47)								while((_g68 < _g69)){
HXLINE(  47)									_g68 = (_g68 + 1);
HXDLIN(  47)									int i20 = (_g68 - 1);
HXDLIN(  47)									a17->data[i20] = 0;
            								}
            							}
            						}
HXDLIN(  47)						undoImage10 = a17;
            					}
            					break;
            					case (int)2: {
HXLINE(  47)						 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  47)						 ::iterMagic::U32ArrImg b28 = u32a3;
HXDLIN(  47)						{
HXLINE(  47)							b28->width = width3;
HXDLIN(  47)							b28->height = height3;
HXDLIN(  47)							b28->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  47)							int size3 = (b28->length * 4);
HXDLIN(  47)							b28->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN(  47)							{
HXLINE(  47)								int _g70 = 0;
HXDLIN(  47)								int _g71 = b28->length;
HXDLIN(  47)								while((_g70 < _g71)){
HXLINE(  47)									_g70 = (_g70 + 1);
HXDLIN(  47)									int i21 = (_g70 - 1);
HXDLIN(  47)									{
HXLINE(  47)										 ::haxe::io::ArrayBufferViewImpl this103 = b28->data;
HXDLIN(  47)										bool undoImage11;
HXDLIN(  47)										if ((i21 >= 0)) {
HXLINE(  47)											undoImage11 = (i21 < (this103->byteLength >> 2));
            										}
            										else {
HXLINE(  47)											undoImage11 = false;
            										}
HXDLIN(  47)										if (undoImage11) {
HXLINE(  47)											 ::haxe::io::Bytes _this3 = this103->bytes;
HXDLIN(  47)											int pos3 = ((i21 << 2) + this103->byteOffset);
HXDLIN(  47)											_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN(  47)											_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN(  47)											_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN(  47)											_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN(  47)						undoImage10 = b28;
            					}
            					break;
            					case (int)3: {
HXLINE(  47)						 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  47)						 ::iterMagic::VecIntImg v9 = vec3;
HXDLIN(  47)						{
HXLINE(  47)							v9->width = width3;
HXDLIN(  47)							v9->height = height3;
HXDLIN(  47)							v9->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  47)							v9->data = ::Array_obj< int >::__new(v9->length);
HXDLIN(  47)							{
HXLINE(  47)								int _g72 = 0;
HXDLIN(  47)								int _g73 = v9->length;
HXDLIN(  47)								while((_g72 < _g73)){
HXLINE(  47)									_g72 = (_g72 + 1);
HXDLIN(  47)									int i22 = (_g72 - 1);
HXDLIN(  47)									v9->data->__unsafe_set(i22,0);
            								}
            							}
            						}
HXDLIN(  47)						undoImage10 = v9;
            					}
            					break;
            					case (int)4: {
HXLINE(  47)						 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  47)						 ::iterMagic::StackIntImg b29 = sInt3;
HXDLIN(  47)						{
HXLINE(  47)							b29->width = width3;
HXDLIN(  47)							b29->height = height3;
HXDLIN(  47)							b29->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  47)							b29->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  47)							{
HXLINE(  47)								int len7 = b29->length;
HXDLIN(  47)								 ::haxe::ds::GenericStack_Int d3 = b29->data;
HXDLIN(  47)								if (::hx::IsNull( d3->head )) {
HXLINE(  47)									int _g74 = 0;
HXDLIN(  47)									int _g75 = len7;
HXDLIN(  47)									while((_g74 < _g75)){
HXLINE(  47)										_g74 = (_g74 + 1);
HXDLIN(  47)										int i23 = (_g74 - 1);
HXDLIN(  47)										d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            									}
            								}
            								else {
HXLINE(  47)									int _g76 = 0;
HXDLIN(  47)									int _g77 = len7;
HXDLIN(  47)									while((_g76 < _g77)){
HXLINE(  47)										_g76 = (_g76 + 1);
HXDLIN(  47)										int i24 = (_g76 - 1);
HXDLIN(  47)										{
HXLINE(  47)											 ::haxe::ds::GenericCell_Int l3 = b29->data->head;
HXDLIN(  47)											 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN(  47)											{
HXLINE(  47)												int _g78 = 0;
HXDLIN(  47)												int _g79 = i24;
HXDLIN(  47)												while((_g78 < _g79)){
HXLINE(  47)													_g78 = (_g78 + 1);
HXDLIN(  47)													int i25 = (_g78 - 1);
HXLINE( 345)													prev3 = l3;
HXLINE( 346)													l3 = l3->next;
            												}
            											}
HXLINE(  47)											if (::hx::IsNull( prev3 )) {
HXLINE(  47)												b29->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  47)												l3 = null();
            											}
            											else {
HXLINE(  47)												prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  47)												l3 = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  47)						undoImage10 = b29;
            					}
            					break;
            				}
HXDLIN(  47)				this102->image = undoImage10;
HXDLIN(  47)				this102->width = width3;
HXDLIN(  47)				this102->height = height3;
HXDLIN(  47)				this102->imageType = ( (int)(imageType3) );
HXDLIN(  47)				undoImage9 = this102;
HXDLIN(  47)				{
HXLINE(  47)					int rectLeft3 = xIter33->start;
HXDLIN(  47)					int rectTop3 = yIter33->start;
HXDLIN(  47)					int rectRight3 = xIter33->max;
HXDLIN(  47)					bool forceClear3 = false;
HXDLIN(  47)					{
HXLINE(  47)						int _g80 = rectTop3;
HXDLIN(  47)						int _g81 = yIter33->max;
HXDLIN(  47)						while((_g80 < _g81)){
HXLINE(  47)							_g80 = (_g80 + 1);
HXDLIN(  47)							int dy3 = (_g80 - 1);
HXDLIN(  47)							{
HXLINE(  47)								int _g82 = rectLeft3;
HXDLIN(  47)								int _g83 = rectRight3;
HXDLIN(  47)								while((_g82 < _g83)){
HXLINE(  47)									_g82 = (_g82 + 1);
HXDLIN(  47)									int dx3 = (_g82 - 1);
HXDLIN(  47)									::Dynamic this104 = this68->image;
HXDLIN(  47)									int index15;
HXDLIN(  47)									if (this68->useVirtualPos) {
HXLINE(  47)										index15 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - this68->virtualY) * ( (Float)(this68->width) )) + dx3) - this68->virtualX));
            									}
            									else {
HXLINE(  47)										index15 = ::Std_obj::_hx_int(( (Float)(((dy3 * this68->width) + dx3)) ));
            									}
HXDLIN(  47)									int c12 = ::iterMagic::Iimg_obj::get(this104,index15);
HXDLIN(  47)									int col3;
HXDLIN(  47)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)										col3 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            									}
            									else {
HXLINE(  47)										col3 = c12;
            									}
HXDLIN(  47)									bool _hx_tmp24;
HXDLIN(  47)									if (this68->useMask) {
HXLINE(  47)										_hx_tmp24 = ::hx::IsNotNull( this68->mask );
            									}
            									else {
HXLINE(  47)										_hx_tmp24 = false;
            									}
HXDLIN(  47)									if (_hx_tmp24) {
HXLINE(  47)										 ::pi_xy::ImageStruct this105 = this68->mask;
HXDLIN(  47)										::Dynamic this106 = this105->image;
HXDLIN(  47)										int index16;
HXDLIN(  47)										if (this105->useVirtualPos) {
HXLINE(  47)											index16 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - this105->virtualY) * ( (Float)(this105->width) )) + dx3) - this105->virtualX));
            										}
            										else {
HXLINE(  47)											index16 = ::Std_obj::_hx_int(( (Float)(((dy3 * this105->width) + dx3)) ));
            										}
HXDLIN(  47)										int c13 = ::iterMagic::Iimg_obj::get(this106,index16);
HXDLIN(  47)										int v10;
HXDLIN(  47)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)											v10 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            										}
            										else {
HXLINE(  47)											v10 = c13;
            										}
HXDLIN(  47)										int maskPixel3 = v10;
HXDLIN(  47)										int this107 = col3;
HXDLIN(  47)										if ((maskPixel3 == 0)) {
HXLINE(  47)											col3 = this107;
            										}
            										else {
HXLINE(  47)											Float m03;
HXDLIN(  47)											int this108 = ((maskPixel3 >> 24) & 255);
HXDLIN(  47)											if ((this108 == 0)) {
HXLINE(  47)												m03 = ((Float)0.);
            											}
            											else {
HXLINE(  47)												m03 = (( (Float)(this108) ) / ( (Float)(255) ));
            											}
HXDLIN(  47)											Float m13;
HXDLIN(  47)											int this109 = ((maskPixel3 >> 16) & 255);
HXDLIN(  47)											if ((this109 == 0)) {
HXLINE(  47)												m13 = ((Float)0.);
            											}
            											else {
HXLINE(  47)												m13 = (( (Float)(this109) ) / ( (Float)(255) ));
            											}
HXDLIN(  47)											Float m23;
HXDLIN(  47)											int this110 = ((maskPixel3 >> 8) & 255);
HXDLIN(  47)											if ((this110 == 0)) {
HXLINE(  47)												m23 = ((Float)0.);
            											}
            											else {
HXLINE(  47)												m23 = (( (Float)(this110) ) / ( (Float)(255) ));
            											}
HXDLIN(  47)											Float m33;
HXDLIN(  47)											int this111 = (maskPixel3 & 255);
HXDLIN(  47)											if ((this111 == 0)) {
HXLINE(  47)												m33 = ((Float)0.);
            											}
            											else {
HXLINE(  47)												m33 = (( (Float)(this111) ) / ( (Float)(255) ));
            											}
HXDLIN(  47)											int ch03 = ::Std_obj::_hx_int(((((Float)1.) - m03) * ( (Float)(((this107 >> 24) & 255)) )));
HXDLIN(  47)											int ch13 = ::Std_obj::_hx_int(((((Float)1.) - m13) * ( (Float)(((this107 >> 16) & 255)) )));
HXDLIN(  47)											int ch23 = ::Std_obj::_hx_int(((((Float)1.) - m23) * ( (Float)(((this107 >> 8) & 255)) )));
HXDLIN(  47)											int ch33 = ::Std_obj::_hx_int(((((Float)1.) - m33) * ( (Float)((this107 & 255)) )));
HXDLIN(  47)											col3 = ((((::Math_obj::round((( (Float)(ch03) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch13) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch23) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch33) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN(  47)									if ((col3 != 0)) {
HXLINE(  47)										int x13 = (dx3 - rectLeft3);
HXDLIN(  47)										int y13 = (dy3 - rectTop3);
HXDLIN(  47)										int c14 = col3;
HXDLIN(  47)										bool _hx_tmp25;
HXDLIN(  47)										if ((((c14 >> 24) & 255) < 254)) {
HXLINE(  47)											_hx_tmp25 = undoImage9->transparent;
            										}
            										else {
HXLINE(  47)											_hx_tmp25 = false;
            										}
HXDLIN(  47)										if (_hx_tmp25) {
HXLINE(  47)											int location6;
HXDLIN(  47)											if (undoImage9->useVirtualPos) {
HXLINE(  47)												location6 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x13) - undoImage9->virtualX));
            											}
            											else {
HXLINE(  47)												location6 = ::Std_obj::_hx_int(( (Float)(((y13 * undoImage9->width) + x13)) ));
            											}
HXDLIN(  47)											int this112 = ::iterMagic::Iimg_obj::get(undoImage9->image,location6);
HXDLIN(  47)											int this113;
HXDLIN(  47)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)												this113 = ((((((this112 >> 24) & 255) << 24) | ((this112 & 255) << 16)) | (((this112 >> 8) & 255) << 8)) | ((this112 >> 16) & 255));
            											}
            											else {
HXLINE(  47)												this113 = this112;
            											}
HXDLIN(  47)											Float a18;
HXDLIN(  47)											int this114 = ((this113 >> 24) & 255);
HXDLIN(  47)											if ((this114 == 0)) {
HXLINE(  47)												a18 = ((Float)0.);
            											}
            											else {
HXLINE(  47)												a18 = (( (Float)(this114) ) / ( (Float)(255) ));
            											}
HXDLIN(  47)											Float r16;
HXDLIN(  47)											int this115 = ((this113 >> 16) & 255);
HXDLIN(  47)											if ((this115 == 0)) {
HXLINE(  47)												r16 = ((Float)0.);
            											}
            											else {
HXLINE(  47)												r16 = (( (Float)(this115) ) / ( (Float)(255) ));
            											}
HXDLIN(  47)											Float g16;
HXDLIN(  47)											int this116 = ((this113 >> 8) & 255);
HXDLIN(  47)											if ((this116 == 0)) {
HXLINE(  47)												g16 = ((Float)0.);
            											}
            											else {
HXLINE(  47)												g16 = (( (Float)(this116) ) / ( (Float)(255) ));
            											}
HXDLIN(  47)											Float b110;
HXDLIN(  47)											int this117 = (this113 & 255);
HXDLIN(  47)											if ((this117 == 0)) {
HXLINE(  47)												b110 = ((Float)0.);
            											}
            											else {
HXLINE(  47)												b110 = (( (Float)(this117) ) / ( (Float)(255) ));
            											}
HXDLIN(  47)											Float a26;
HXDLIN(  47)											int this118 = ((col3 >> 24) & 255);
HXDLIN(  47)											if ((this118 == 0)) {
HXLINE(  47)												a26 = ((Float)0.);
            											}
            											else {
HXLINE(  47)												a26 = (( (Float)(this118) ) / ( (Float)(255) ));
            											}
HXDLIN(  47)											Float r26;
HXDLIN(  47)											int this119 = ((col3 >> 16) & 255);
HXDLIN(  47)											if ((this119 == 0)) {
HXLINE(  47)												r26 = ((Float)0.);
            											}
            											else {
HXLINE(  47)												r26 = (( (Float)(this119) ) / ( (Float)(255) ));
            											}
HXDLIN(  47)											Float g26;
HXDLIN(  47)											int this120 = ((col3 >> 8) & 255);
HXDLIN(  47)											if ((this120 == 0)) {
HXLINE(  47)												g26 = ((Float)0.);
            											}
            											else {
HXLINE(  47)												g26 = (( (Float)(this120) ) / ( (Float)(255) ));
            											}
HXDLIN(  47)											Float b210;
HXDLIN(  47)											int this121 = (col3 & 255);
HXDLIN(  47)											if ((this121 == 0)) {
HXLINE(  47)												b210 = ((Float)0.);
            											}
            											else {
HXLINE(  47)												b210 = (( (Float)(this121) ) / ( (Float)(255) ));
            											}
HXDLIN(  47)											Float a36 = (a18 * (( (Float)(1) ) - a26));
HXDLIN(  47)											int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN(  47)											int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN(  47)											int b30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a36) + (b210 * a26))));
HXDLIN(  47)											int a19 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN(  47)											int blended6 = ((((a19 << 24) | (r8 << 16)) | (g8 << 8)) | b30);
HXDLIN(  47)											{
HXLINE(  47)												int _hx_tmp26;
HXDLIN(  47)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)													_hx_tmp26 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            												}
            												else {
HXLINE(  47)													_hx_tmp26 = blended6;
            												}
HXDLIN(  47)												::iterMagic::Iimg_obj::set(undoImage9->image,location6,_hx_tmp26);
            											}
            										}
            										else {
HXLINE(  47)											::Dynamic this122 = undoImage9->image;
HXDLIN(  47)											int index17;
HXDLIN(  47)											if (undoImage9->useVirtualPos) {
HXLINE(  47)												index17 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x13) - undoImage9->virtualX));
            											}
            											else {
HXLINE(  47)												index17 = ::Std_obj::_hx_int(( (Float)(((y13 * undoImage9->width) + x13)) ));
            											}
HXDLIN(  47)											int _hx_tmp27;
HXDLIN(  47)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)												_hx_tmp27 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            											}
            											else {
HXLINE(  47)												_hx_tmp27 = c14;
            											}
HXDLIN(  47)											::iterMagic::Iimg_obj::set(this122,index17,_hx_tmp27);
            										}
            									}
            									else {
HXLINE(  47)										if (forceClear3) {
HXLINE(  47)											::Dynamic this123 = undoImage9->image;
HXDLIN(  47)											int x14 = (dx3 - rectLeft3);
HXDLIN(  47)											int y14 = (dy3 - rectTop3);
HXDLIN(  47)											int index18;
HXDLIN(  47)											if (undoImage9->useVirtualPos) {
HXLINE(  47)												index18 = ::Std_obj::_hx_int(((((( (Float)(y14) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x14) - undoImage9->virtualX));
            											}
            											else {
HXLINE(  47)												index18 = ::Std_obj::_hx_int(( (Float)(((y14 * undoImage9->width) + x14)) ));
            											}
HXDLIN(  47)											::iterMagic::Iimg_obj::set(this123,index18,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN(  47)			bool found3 = false;
HXDLIN(  47)			Float s3 = ((Float)0.);
HXDLIN(  47)			Float t3 = ((Float)0.);
HXDLIN(  47)			Float sxx3 = ((Float)0.);
HXDLIN(  47)			Float txx3 = ((Float)0.);
HXDLIN(  47)			{
HXLINE(  47)				int _g_min6 = xIter33->start;
HXDLIN(  47)				int _g_max6 = xIter33->max;
HXDLIN(  47)				while((_g_min6 < _g_max6)){
HXLINE(  47)					_g_min6 = (_g_min6 + 1);
HXDLIN(  47)					int x15 = (_g_min6 - 1);
HXLINE(  60)					sxx3 = (sx3 * ( (Float)(x15) ));
HXLINE(  61)					txx3 = (tx3 * ( (Float)(x15) ));
HXLINE(  62)					found3 = false;
HXLINE(  47)					{
HXLINE(  47)						int _g_min7 = yIter33->start;
HXDLIN(  47)						int _g_max7 = yIter33->max;
HXDLIN(  47)						while((_g_min7 < _g_max7)){
HXLINE(  47)							_g_min7 = (_g_min7 + 1);
HXDLIN(  47)							int y15 = (_g_min7 - 1);
HXLINE(  64)							s3 = ((s03 + sxx3) + (sy3 * ( (Float)(y15) )));
HXLINE(  65)							t3 = ((t03 + txx3) + (ty3 * ( (Float)(y15) )));
HXLINE(  47)							bool _hx_tmp28;
HXDLIN(  47)							if (!((s3 <= 0))) {
HXLINE(  47)								_hx_tmp28 = (t3 <= 0);
            							}
            							else {
HXLINE(  47)								_hx_tmp28 = true;
            							}
HXDLIN(  47)							if (_hx_tmp28) {
HXLINE(  47)								if (found3) {
HXLINE(  47)									goto _hx_goto_140;
            								}
            							}
            							else {
HXLINE(  47)								if (((s3 + t3) < A3)) {
HXLINE(  47)									{
HXLINE(  47)										int c15 = color1;
HXDLIN(  47)										bool _hx_tmp29;
HXDLIN(  47)										if ((((c15 >> 24) & 255) < 254)) {
HXLINE(  47)											_hx_tmp29 = this68->transparent;
            										}
            										else {
HXLINE(  47)											_hx_tmp29 = false;
            										}
HXDLIN(  47)										if (_hx_tmp29) {
HXLINE(  47)											int location7;
HXDLIN(  47)											if (this68->useVirtualPos) {
HXLINE(  47)												location7 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - this68->virtualY) * ( (Float)(this68->width) )) + x15) - this68->virtualX));
            											}
            											else {
HXLINE(  47)												location7 = ::Std_obj::_hx_int(( (Float)(((y15 * this68->width) + x15)) ));
            											}
HXDLIN(  47)											int this124 = ::iterMagic::Iimg_obj::get(this68->image,location7);
HXDLIN(  47)											int this125;
HXDLIN(  47)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)												this125 = ((((((this124 >> 24) & 255) << 24) | ((this124 & 255) << 16)) | (((this124 >> 8) & 255) << 8)) | ((this124 >> 16) & 255));
            											}
            											else {
HXLINE(  47)												this125 = this124;
            											}
HXDLIN(  47)											Float a110;
HXDLIN(  47)											int this126 = ((this125 >> 24) & 255);
HXDLIN(  47)											if ((this126 == 0)) {
HXLINE(  47)												a110 = ((Float)0.);
            											}
            											else {
HXLINE(  47)												a110 = (( (Float)(this126) ) / ( (Float)(255) ));
            											}
HXDLIN(  47)											Float r17;
HXDLIN(  47)											int this127 = ((this125 >> 16) & 255);
HXDLIN(  47)											if ((this127 == 0)) {
HXLINE(  47)												r17 = ((Float)0.);
            											}
            											else {
HXLINE(  47)												r17 = (( (Float)(this127) ) / ( (Float)(255) ));
            											}
HXDLIN(  47)											Float g17;
HXDLIN(  47)											int this128 = ((this125 >> 8) & 255);
HXDLIN(  47)											if ((this128 == 0)) {
HXLINE(  47)												g17 = ((Float)0.);
            											}
            											else {
HXLINE(  47)												g17 = (( (Float)(this128) ) / ( (Float)(255) ));
            											}
HXDLIN(  47)											Float b111;
HXDLIN(  47)											int this129 = (this125 & 255);
HXDLIN(  47)											if ((this129 == 0)) {
HXLINE(  47)												b111 = ((Float)0.);
            											}
            											else {
HXLINE(  47)												b111 = (( (Float)(this129) ) / ( (Float)(255) ));
            											}
HXDLIN(  47)											Float a27;
HXDLIN(  47)											int this130 = ((color1 >> 24) & 255);
HXDLIN(  47)											if ((this130 == 0)) {
HXLINE(  47)												a27 = ((Float)0.);
            											}
            											else {
HXLINE(  47)												a27 = (( (Float)(this130) ) / ( (Float)(255) ));
            											}
HXDLIN(  47)											Float r27;
HXDLIN(  47)											int this131 = ((color1 >> 16) & 255);
HXDLIN(  47)											if ((this131 == 0)) {
HXLINE(  47)												r27 = ((Float)0.);
            											}
            											else {
HXLINE(  47)												r27 = (( (Float)(this131) ) / ( (Float)(255) ));
            											}
HXDLIN(  47)											Float g27;
HXDLIN(  47)											int this132 = ((color1 >> 8) & 255);
HXDLIN(  47)											if ((this132 == 0)) {
HXLINE(  47)												g27 = ((Float)0.);
            											}
            											else {
HXLINE(  47)												g27 = (( (Float)(this132) ) / ( (Float)(255) ));
            											}
HXDLIN(  47)											Float b211;
HXDLIN(  47)											int this133 = (color1 & 255);
HXDLIN(  47)											if ((this133 == 0)) {
HXLINE(  47)												b211 = ((Float)0.);
            											}
            											else {
HXLINE(  47)												b211 = (( (Float)(this133) ) / ( (Float)(255) ));
            											}
HXDLIN(  47)											Float a37 = (a110 * (( (Float)(1) ) - a27));
HXDLIN(  47)											int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN(  47)											int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN(  47)											int b31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a37) + (b211 * a27))));
HXDLIN(  47)											int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN(  47)											int blended7 = ((((a20 << 24) | (r9 << 16)) | (g9 << 8)) | b31);
HXDLIN(  47)											{
HXLINE(  47)												int _hx_tmp30;
HXDLIN(  47)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)													_hx_tmp30 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            												}
            												else {
HXLINE(  47)													_hx_tmp30 = blended7;
            												}
HXDLIN(  47)												::iterMagic::Iimg_obj::set(this68->image,location7,_hx_tmp30);
            											}
            										}
            										else {
HXLINE(  47)											::Dynamic this134 = this68->image;
HXDLIN(  47)											int index19;
HXDLIN(  47)											if (this68->useVirtualPos) {
HXLINE(  47)												index19 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - this68->virtualY) * ( (Float)(this68->width) )) + x15) - this68->virtualX));
            											}
            											else {
HXLINE(  47)												index19 = ::Std_obj::_hx_int(( (Float)(((y15 * this68->width) + x15)) ));
            											}
HXDLIN(  47)											int _hx_tmp31;
HXDLIN(  47)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)												_hx_tmp31 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            											}
            											else {
HXLINE(  47)												_hx_tmp31 = c15;
            											}
HXDLIN(  47)											::iterMagic::Iimg_obj::set(this134,index19,_hx_tmp31);
            										}
            									}
HXLINE(  73)									found3 = true;
            								}
            								else {
HXLINE(  47)									if (found3) {
HXLINE(  47)										goto _hx_goto_140;
            									}
            								}
            							}
            						}
            						_hx_goto_140:;
            					}
            				}
            			}
HXDLIN(  47)			 ::pi_xy::algo::HitTri triHit3;
HXDLIN(  47)			if ((hasHit1 == true)) {
HXLINE(  47)				 ::pi_xy::algo::HitTri v11 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax1,ay1,bx5,by5,cx5,cy5,true);
HXDLIN(  47)				if (hasUndo3) {
HXLINE(  47)					v11->undoImage = undoImage9;
HXDLIN(  47)					v11->undoX = xIter33->start;
HXDLIN(  47)					v11->undoY = yIter33->start;
            				}
HXDLIN(  47)				triHit3 = v11;
            			}
            			else {
HXLINE(  47)				triHit3 = null();
            			}
HXDLIN(  47)			if (hasHit1) {
HXLINE(  47)				arrTri1[arrTri1->length] = triHit3;
            			}
HXDLIN(  47)			if (hasHit1) {
HXLINE(  47)				 ::pi_xy::algo::HitTriArray_obj::__alloc( HX_CTX ,arrTri1);
            			}
            			else {
HXLINE( 410)				arrTri1 = null();
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(ArcForm_obj,ellipse,(void))

void ArcForm_obj::pie( ::pi_xy::ImageStruct temp){
            	HX_GC_STACKFRAME(&_hx_pos_9a7b98cd588c0f27_49_pie)
HXLINE(  50)		this->ellipse(temp);
HXLINE(  51)		Float bx = ((this->rx * ::Math_obj::cos(this->startAngle)) + this->rx);
HXLINE(  52)		Float by = ((this->ry * ::Math_obj::sin(this->startAngle)) + this->ry);
HXLINE(  53)		Float currAngle = (this->startAngle + (this->sweepAngle / ( (Float)(2) )));
HXLINE(  54)		Float ax = ((this->strokeWidth * ::Math_obj::cos(currAngle)) + this->rx);
HXLINE(  55)		Float ay = ((this->strokeWidth * ::Math_obj::sin(currAngle)) + this->ry);
HXLINE(  56)		currAngle = (this->startAngle + this->sweepAngle);
HXLINE(  57)		Float cx = ((this->rx * ::Math_obj::cos(currAngle)) + this->rx);
HXLINE(  58)		Float cy = ((this->ry * ::Math_obj::sin(currAngle)) + this->ry);
HXLINE(  59)		{
HXLINE(  59)			 ::pi_xy::ImageStruct this1 = temp;
HXDLIN(  59)			Float px = this->rx;
HXDLIN(  59)			Float py = this->ry;
HXDLIN(  59)			int color = this->strokeColor;
HXDLIN(  59)			bool hasHit = true;
HXDLIN(  59)			Float o = (by - py);
HXDLIN(  59)			Float a = (bx - px);
HXDLIN(  59)			Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN(  59)			Float theta = ::Math_obj::atan2(o,a);
HXDLIN(  59)			{
HXLINE(  59)				 ::Dynamic debugCorners = false;
HXDLIN(  59)				if (::hx::IsNull( debugCorners )) {
HXLINE(  75)					debugCorners = false;
            				}
HXLINE(  59)				Float sin = ::Math_obj::sin(theta);
HXDLIN(  59)				Float cos = ::Math_obj::cos(theta);
HXDLIN(  59)				Float radius = (this->strokeWidth / ( (Float)(2) ));
HXDLIN(  59)				Float dx = ((Float)0.1);
HXDLIN(  59)				Float dy = radius;
HXDLIN(  59)				Float cx1 = h;
HXDLIN(  59)				Float cy1 = radius;
HXDLIN(  59)				Float bx1 = h;
HXDLIN(  59)				Float by1 = -(radius);
HXDLIN(  59)				Float ax1 = ((Float)0.1);
HXDLIN(  59)				Float ay1 = -(radius);
HXDLIN(  59)				Float temp1 = ((Float)0.);
HXLINE(  28)				temp1 = (px + ((ax1 * cos) - (ay1 * sin)));
HXLINE(  29)				ay1 = (py + ((ay1 * cos) + (ax1 * sin)));
HXLINE(  30)				ax1 = temp1;
HXLINE(  32)				temp1 = (px + ((bx1 * cos) - (by1 * sin)));
HXLINE(  33)				by1 = (py + ((by1 * cos) + (bx1 * sin)));
HXLINE(  34)				bx1 = temp1;
HXLINE(  36)				temp1 = (px + ((cx1 * cos) - (cy1 * sin)));
HXLINE(  37)				cy1 = (py + ((cy1 * cos) + (cx1 * sin)));
HXLINE(  38)				cx1 = temp1;
HXLINE(  40)				temp1 = (px + ((dx * cos) - (dy * sin)));
HXLINE(  41)				dy = (py + ((dy * cos) + (dx * sin)));
HXLINE(  42)				dx = temp1;
HXLINE(  59)				if (( (bool)(debugCorners) )) {
HXLINE(  59)					{
HXLINE(  59)						 ::pi_xy::ImageStruct this2 = this1;
HXDLIN(  59)						{
HXLINE(  59)							int r_x = ::Std_obj::_hx_int((ax1 - ((Float)6.)));
HXDLIN(  59)							int r_y = ::Std_obj::_hx_int((ay1 - ((Float)6.)));
HXDLIN(  59)							int r_w = 12;
HXDLIN(  59)							int r_h = 12;
HXDLIN(  59)							int xmax = ((r_x + r_w) + 1);
HXDLIN(  59)							int ymax = ((r_y + r_h) + 1);
HXDLIN(  59)							int ii_min = r_x;
HXDLIN(  59)							int ii_max = xmax;
HXDLIN(  59)							int xRange__start = ii_min;
HXDLIN(  59)							int xRange__max = ii_max;
HXDLIN(  59)							int ii_min1 = r_y;
HXDLIN(  59)							int ii_max1 = ymax;
HXDLIN(  59)							int yRange__start = ii_min1;
HXDLIN(  59)							int yRange__max = ii_max1;
HXDLIN(  59)							int range_x = xRange__start;
HXDLIN(  59)							int range_y = (yRange__start - 1);
HXDLIN(  59)							int range_xReset = range_x;
HXDLIN(  59)							int range_yReset = range_y;
HXDLIN(  59)							int range_xMax = (xRange__max - 2);
HXDLIN(  59)							int range_yMax = (yRange__max - 2);
HXDLIN(  59)							int _this_min = 0;
HXDLIN(  59)							int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXDLIN(  59)							while((_this_min < _this_max)){
HXLINE(  59)								_this_min = (_this_min + 1);
HXDLIN(  59)								int i = (_this_min - 1);
HXDLIN(  59)								if ((range_y > range_yMax)) {
HXLINE(  59)									range_y = range_yReset;
HXDLIN(  59)									range_x = (range_x + 1);
            								}
HXDLIN(  59)								range_y = (range_y + 1);
HXDLIN(  59)								int i1 = i;
HXDLIN(  59)								{
HXLINE(  59)									int x = range_x;
HXDLIN(  59)									int y = range_y;
HXDLIN(  59)									int c = -65536;
HXDLIN(  59)									bool _hx_tmp;
HXDLIN(  59)									if ((((c >> 24) & 255) < 254)) {
HXLINE(  59)										_hx_tmp = this2->transparent;
            									}
            									else {
HXLINE(  59)										_hx_tmp = false;
            									}
HXDLIN(  59)									if (_hx_tmp) {
HXLINE(  59)										int location;
HXDLIN(  59)										if (this2->useVirtualPos) {
HXLINE(  59)											location = ::Std_obj::_hx_int(((((( (Float)(y) ) - this2->virtualY) * ( (Float)(this2->width) )) + x) - this2->virtualX));
            										}
            										else {
HXLINE(  59)											location = ::Std_obj::_hx_int(( (Float)(((y * this2->width) + x)) ));
            										}
HXDLIN(  59)										int this3 = ::iterMagic::Iimg_obj::get(this2->image,location);
HXDLIN(  59)										int this4;
HXDLIN(  59)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)											this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            										}
            										else {
HXLINE(  59)											this4 = this3;
            										}
HXDLIN(  59)										Float a1;
HXDLIN(  59)										int this5 = ((this4 >> 24) & 255);
HXDLIN(  59)										if ((this5 == 0)) {
HXLINE(  59)											a1 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float r1;
HXDLIN(  59)										int this6 = ((this4 >> 16) & 255);
HXDLIN(  59)										if ((this6 == 0)) {
HXLINE(  59)											r1 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float g1;
HXDLIN(  59)										int this7 = ((this4 >> 8) & 255);
HXDLIN(  59)										if ((this7 == 0)) {
HXLINE(  59)											g1 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float b1;
HXDLIN(  59)										int this8 = (this4 & 255);
HXDLIN(  59)										if ((this8 == 0)) {
HXLINE(  59)											b1 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float a2;
HXDLIN(  59)										int this9 = ((-65536 >> 24) & 255);
HXDLIN(  59)										if ((this9 == 0)) {
HXLINE(  59)											a2 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float r2;
HXDLIN(  59)										int this10 = ((-65536 >> 16) & 255);
HXDLIN(  59)										if ((this10 == 0)) {
HXLINE(  59)											r2 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float g2;
HXDLIN(  59)										int this11 = ((-65536 >> 8) & 255);
HXDLIN(  59)										if ((this11 == 0)) {
HXLINE(  59)											g2 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float b2;
HXDLIN(  59)										int this12 = (-65536 & 255);
HXDLIN(  59)										if ((this12 == 0)) {
HXLINE(  59)											b2 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  59)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  59)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  59)										int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  59)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  59)										int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  59)										{
HXLINE(  59)											int _hx_tmp1;
HXDLIN(  59)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)												_hx_tmp1 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE(  59)												_hx_tmp1 = blended;
            											}
HXDLIN(  59)											::iterMagic::Iimg_obj::set(this2->image,location,_hx_tmp1);
            										}
            									}
            									else {
HXLINE(  59)										::Dynamic this13 = this2->image;
HXDLIN(  59)										int index;
HXDLIN(  59)										if (this2->useVirtualPos) {
HXLINE(  59)											index = ::Std_obj::_hx_int(((((( (Float)(y) ) - this2->virtualY) * ( (Float)(this2->width) )) + x) - this2->virtualX));
            										}
            										else {
HXLINE(  59)											index = ::Std_obj::_hx_int(( (Float)(((y * this2->width) + x)) ));
            										}
HXDLIN(  59)										int _hx_tmp2;
HXDLIN(  59)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)											_hx_tmp2 = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE(  59)											_hx_tmp2 = c;
            										}
HXDLIN(  59)										::iterMagic::Iimg_obj::set(this13,index,_hx_tmp2);
            									}
            								}
            							}
            						}
            					}
HXDLIN(  59)					{
HXLINE(  59)						 ::pi_xy::ImageStruct this14 = this1;
HXDLIN(  59)						{
HXLINE(  59)							int r_x1 = ::Std_obj::_hx_int((bx1 - ((Float)6.)));
HXDLIN(  59)							int r_y1 = ::Std_obj::_hx_int((by1 - ((Float)6.)));
HXDLIN(  59)							int r_w1 = 12;
HXDLIN(  59)							int r_h1 = 12;
HXDLIN(  59)							int xmax1 = ((r_x1 + r_w1) + 1);
HXDLIN(  59)							int ymax1 = ((r_y1 + r_h1) + 1);
HXDLIN(  59)							int ii_min2 = r_x1;
HXDLIN(  59)							int ii_max2 = xmax1;
HXDLIN(  59)							int xRange__start1 = ii_min2;
HXDLIN(  59)							int xRange__max1 = ii_max2;
HXDLIN(  59)							int ii_min3 = r_y1;
HXDLIN(  59)							int ii_max3 = ymax1;
HXDLIN(  59)							int yRange__start1 = ii_min3;
HXDLIN(  59)							int yRange__max1 = ii_max3;
HXDLIN(  59)							int range_x1 = xRange__start1;
HXDLIN(  59)							int range_y1 = (yRange__start1 - 1);
HXDLIN(  59)							int range_xReset1 = range_x1;
HXDLIN(  59)							int range_yReset1 = range_y1;
HXDLIN(  59)							int range_xMax1 = (xRange__max1 - 2);
HXDLIN(  59)							int range_yMax1 = (yRange__max1 - 2);
HXDLIN(  59)							int _this_min1 = 0;
HXDLIN(  59)							int _this_max1 = ::Std_obj::_hx_int(( (Float)(((xRange__max1 - xRange__start1) * (yRange__max1 - yRange__start1))) ));
HXDLIN(  59)							while((_this_min1 < _this_max1)){
HXLINE(  59)								_this_min1 = (_this_min1 + 1);
HXDLIN(  59)								int i2 = (_this_min1 - 1);
HXDLIN(  59)								if ((range_y1 > range_yMax1)) {
HXLINE(  59)									range_y1 = range_yReset1;
HXDLIN(  59)									range_x1 = (range_x1 + 1);
            								}
HXDLIN(  59)								range_y1 = (range_y1 + 1);
HXDLIN(  59)								int i3 = i2;
HXDLIN(  59)								{
HXLINE(  59)									int x1 = range_x1;
HXDLIN(  59)									int y1 = range_y1;
HXDLIN(  59)									int c1 = -16711936;
HXDLIN(  59)									bool _hx_tmp3;
HXDLIN(  59)									if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  59)										_hx_tmp3 = this14->transparent;
            									}
            									else {
HXLINE(  59)										_hx_tmp3 = false;
            									}
HXDLIN(  59)									if (_hx_tmp3) {
HXLINE(  59)										int location1;
HXDLIN(  59)										if (this14->useVirtualPos) {
HXLINE(  59)											location1 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this14->virtualY) * ( (Float)(this14->width) )) + x1) - this14->virtualX));
            										}
            										else {
HXLINE(  59)											location1 = ::Std_obj::_hx_int(( (Float)(((y1 * this14->width) + x1)) ));
            										}
HXDLIN(  59)										int this15 = ::iterMagic::Iimg_obj::get(this14->image,location1);
HXDLIN(  59)										int this16;
HXDLIN(  59)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)											this16 = ((((((this15 >> 24) & 255) << 24) | ((this15 & 255) << 16)) | (((this15 >> 8) & 255) << 8)) | ((this15 >> 16) & 255));
            										}
            										else {
HXLINE(  59)											this16 = this15;
            										}
HXDLIN(  59)										Float a11;
HXDLIN(  59)										int this17 = ((this16 >> 24) & 255);
HXDLIN(  59)										if ((this17 == 0)) {
HXLINE(  59)											a11 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											a11 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float r11;
HXDLIN(  59)										int this18 = ((this16 >> 16) & 255);
HXDLIN(  59)										if ((this18 == 0)) {
HXLINE(  59)											r11 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											r11 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float g11;
HXDLIN(  59)										int this19 = ((this16 >> 8) & 255);
HXDLIN(  59)										if ((this19 == 0)) {
HXLINE(  59)											g11 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											g11 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float b11;
HXDLIN(  59)										int this20 = (this16 & 255);
HXDLIN(  59)										if ((this20 == 0)) {
HXLINE(  59)											b11 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											b11 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float a21;
HXDLIN(  59)										int this21 = ((-16711936 >> 24) & 255);
HXDLIN(  59)										if ((this21 == 0)) {
HXLINE(  59)											a21 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											a21 = (( (Float)(this21) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float r21;
HXDLIN(  59)										int this22 = ((-16711936 >> 16) & 255);
HXDLIN(  59)										if ((this22 == 0)) {
HXLINE(  59)											r21 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											r21 = (( (Float)(this22) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float g21;
HXDLIN(  59)										int this23 = ((-16711936 >> 8) & 255);
HXDLIN(  59)										if ((this23 == 0)) {
HXLINE(  59)											g21 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											g21 = (( (Float)(this23) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float b21;
HXDLIN(  59)										int this24 = (-16711936 & 255);
HXDLIN(  59)										if ((this24 == 0)) {
HXLINE(  59)											b21 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											b21 = (( (Float)(this24) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  59)										int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  59)										int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  59)										int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a31) + (b21 * a21))));
HXDLIN(  59)										int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  59)										int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  59)										{
HXLINE(  59)											int _hx_tmp4;
HXDLIN(  59)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)												_hx_tmp4 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXLINE(  59)												_hx_tmp4 = blended1;
            											}
HXDLIN(  59)											::iterMagic::Iimg_obj::set(this14->image,location1,_hx_tmp4);
            										}
            									}
            									else {
HXLINE(  59)										::Dynamic this25 = this14->image;
HXDLIN(  59)										int index1;
HXDLIN(  59)										if (this14->useVirtualPos) {
HXLINE(  59)											index1 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this14->virtualY) * ( (Float)(this14->width) )) + x1) - this14->virtualX));
            										}
            										else {
HXLINE(  59)											index1 = ::Std_obj::_hx_int(( (Float)(((y1 * this14->width) + x1)) ));
            										}
HXDLIN(  59)										int _hx_tmp5;
HXDLIN(  59)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)											_hx_tmp5 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            										}
            										else {
HXLINE(  59)											_hx_tmp5 = c1;
            										}
HXDLIN(  59)										::iterMagic::Iimg_obj::set(this25,index1,_hx_tmp5);
            									}
            								}
            							}
            						}
            					}
HXDLIN(  59)					{
HXLINE(  59)						 ::pi_xy::ImageStruct this26 = this1;
HXDLIN(  59)						{
HXLINE(  59)							int r_x2 = ::Std_obj::_hx_int((cx1 - ((Float)6.)));
HXDLIN(  59)							int r_y2 = ::Std_obj::_hx_int((cy1 - ((Float)6.)));
HXDLIN(  59)							int r_w2 = 12;
HXDLIN(  59)							int r_h2 = 12;
HXDLIN(  59)							int xmax2 = ((r_x2 + r_w2) + 1);
HXDLIN(  59)							int ymax2 = ((r_y2 + r_h2) + 1);
HXDLIN(  59)							int ii_min4 = r_x2;
HXDLIN(  59)							int ii_max4 = xmax2;
HXDLIN(  59)							int xRange__start2 = ii_min4;
HXDLIN(  59)							int xRange__max2 = ii_max4;
HXDLIN(  59)							int ii_min5 = r_y2;
HXDLIN(  59)							int ii_max5 = ymax2;
HXDLIN(  59)							int yRange__start2 = ii_min5;
HXDLIN(  59)							int yRange__max2 = ii_max5;
HXDLIN(  59)							int range_x2 = xRange__start2;
HXDLIN(  59)							int range_y2 = (yRange__start2 - 1);
HXDLIN(  59)							int range_xReset2 = range_x2;
HXDLIN(  59)							int range_yReset2 = range_y2;
HXDLIN(  59)							int range_xMax2 = (xRange__max2 - 2);
HXDLIN(  59)							int range_yMax2 = (yRange__max2 - 2);
HXDLIN(  59)							int _this_min2 = 0;
HXDLIN(  59)							int _this_max2 = ::Std_obj::_hx_int(( (Float)(((xRange__max2 - xRange__start2) * (yRange__max2 - yRange__start2))) ));
HXDLIN(  59)							while((_this_min2 < _this_max2)){
HXLINE(  59)								_this_min2 = (_this_min2 + 1);
HXDLIN(  59)								int i4 = (_this_min2 - 1);
HXDLIN(  59)								if ((range_y2 > range_yMax2)) {
HXLINE(  59)									range_y2 = range_yReset2;
HXDLIN(  59)									range_x2 = (range_x2 + 1);
            								}
HXDLIN(  59)								range_y2 = (range_y2 + 1);
HXDLIN(  59)								int i5 = i4;
HXDLIN(  59)								{
HXLINE(  59)									int x2 = range_x2;
HXDLIN(  59)									int y2 = range_y2;
HXDLIN(  59)									int c2 = -16776961;
HXDLIN(  59)									bool _hx_tmp6;
HXDLIN(  59)									if ((((c2 >> 24) & 255) < 254)) {
HXLINE(  59)										_hx_tmp6 = this26->transparent;
            									}
            									else {
HXLINE(  59)										_hx_tmp6 = false;
            									}
HXDLIN(  59)									if (_hx_tmp6) {
HXLINE(  59)										int location2;
HXDLIN(  59)										if (this26->useVirtualPos) {
HXLINE(  59)											location2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - this26->virtualY) * ( (Float)(this26->width) )) + x2) - this26->virtualX));
            										}
            										else {
HXLINE(  59)											location2 = ::Std_obj::_hx_int(( (Float)(((y2 * this26->width) + x2)) ));
            										}
HXDLIN(  59)										int this27 = ::iterMagic::Iimg_obj::get(this26->image,location2);
HXDLIN(  59)										int this28;
HXDLIN(  59)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)											this28 = ((((((this27 >> 24) & 255) << 24) | ((this27 & 255) << 16)) | (((this27 >> 8) & 255) << 8)) | ((this27 >> 16) & 255));
            										}
            										else {
HXLINE(  59)											this28 = this27;
            										}
HXDLIN(  59)										Float a12;
HXDLIN(  59)										int this29 = ((this28 >> 24) & 255);
HXDLIN(  59)										if ((this29 == 0)) {
HXLINE(  59)											a12 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											a12 = (( (Float)(this29) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float r12;
HXDLIN(  59)										int this30 = ((this28 >> 16) & 255);
HXDLIN(  59)										if ((this30 == 0)) {
HXLINE(  59)											r12 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											r12 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float g12;
HXDLIN(  59)										int this31 = ((this28 >> 8) & 255);
HXDLIN(  59)										if ((this31 == 0)) {
HXLINE(  59)											g12 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											g12 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float b12;
HXDLIN(  59)										int this32 = (this28 & 255);
HXDLIN(  59)										if ((this32 == 0)) {
HXLINE(  59)											b12 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											b12 = (( (Float)(this32) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float a22;
HXDLIN(  59)										int this33 = ((-16776961 >> 24) & 255);
HXDLIN(  59)										if ((this33 == 0)) {
HXLINE(  59)											a22 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											a22 = (( (Float)(this33) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float r22;
HXDLIN(  59)										int this34 = ((-16776961 >> 16) & 255);
HXDLIN(  59)										if ((this34 == 0)) {
HXLINE(  59)											r22 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											r22 = (( (Float)(this34) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float g22;
HXDLIN(  59)										int this35 = ((-16776961 >> 8) & 255);
HXDLIN(  59)										if ((this35 == 0)) {
HXLINE(  59)											g22 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											g22 = (( (Float)(this35) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float b22;
HXDLIN(  59)										int this36 = (-16776961 & 255);
HXDLIN(  59)										if ((this36 == 0)) {
HXLINE(  59)											b22 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											b22 = (( (Float)(this36) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  59)										int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  59)										int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  59)										int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a32) + (b22 * a22))));
HXDLIN(  59)										int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  59)										int blended2 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b4);
HXDLIN(  59)										{
HXLINE(  59)											int _hx_tmp7;
HXDLIN(  59)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)												_hx_tmp7 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            											}
            											else {
HXLINE(  59)												_hx_tmp7 = blended2;
            											}
HXDLIN(  59)											::iterMagic::Iimg_obj::set(this26->image,location2,_hx_tmp7);
            										}
            									}
            									else {
HXLINE(  59)										::Dynamic this37 = this26->image;
HXDLIN(  59)										int index2;
HXDLIN(  59)										if (this26->useVirtualPos) {
HXLINE(  59)											index2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - this26->virtualY) * ( (Float)(this26->width) )) + x2) - this26->virtualX));
            										}
            										else {
HXLINE(  59)											index2 = ::Std_obj::_hx_int(( (Float)(((y2 * this26->width) + x2)) ));
            										}
HXDLIN(  59)										int _hx_tmp8;
HXDLIN(  59)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)											_hx_tmp8 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXLINE(  59)											_hx_tmp8 = c2;
            										}
HXDLIN(  59)										::iterMagic::Iimg_obj::set(this37,index2,_hx_tmp8);
            									}
            								}
            							}
            						}
            					}
HXDLIN(  59)					{
HXLINE(  59)						 ::pi_xy::ImageStruct this38 = this1;
HXDLIN(  59)						{
HXLINE(  59)							int r_x3 = ::Std_obj::_hx_int((dx - ((Float)6.)));
HXDLIN(  59)							int r_y3 = ::Std_obj::_hx_int((dy - ((Float)6.)));
HXDLIN(  59)							int r_w3 = 12;
HXDLIN(  59)							int r_h3 = 12;
HXDLIN(  59)							int xmax3 = ((r_x3 + r_w3) + 1);
HXDLIN(  59)							int ymax3 = ((r_y3 + r_h3) + 1);
HXDLIN(  59)							int ii_min6 = r_x3;
HXDLIN(  59)							int ii_max6 = xmax3;
HXDLIN(  59)							int xRange__start3 = ii_min6;
HXDLIN(  59)							int xRange__max3 = ii_max6;
HXDLIN(  59)							int ii_min7 = r_y3;
HXDLIN(  59)							int ii_max7 = ymax3;
HXDLIN(  59)							int yRange__start3 = ii_min7;
HXDLIN(  59)							int yRange__max3 = ii_max7;
HXDLIN(  59)							int range_x3 = xRange__start3;
HXDLIN(  59)							int range_y3 = (yRange__start3 - 1);
HXDLIN(  59)							int range_xReset3 = range_x3;
HXDLIN(  59)							int range_yReset3 = range_y3;
HXDLIN(  59)							int range_xMax3 = (xRange__max3 - 2);
HXDLIN(  59)							int range_yMax3 = (yRange__max3 - 2);
HXDLIN(  59)							int _this_min3 = 0;
HXDLIN(  59)							int _this_max3 = ::Std_obj::_hx_int(( (Float)(((xRange__max3 - xRange__start3) * (yRange__max3 - yRange__start3))) ));
HXDLIN(  59)							while((_this_min3 < _this_max3)){
HXLINE(  59)								_this_min3 = (_this_min3 + 1);
HXDLIN(  59)								int i6 = (_this_min3 - 1);
HXDLIN(  59)								if ((range_y3 > range_yMax3)) {
HXLINE(  59)									range_y3 = range_yReset3;
HXDLIN(  59)									range_x3 = (range_x3 + 1);
            								}
HXDLIN(  59)								range_y3 = (range_y3 + 1);
HXDLIN(  59)								int i7 = i6;
HXDLIN(  59)								{
HXLINE(  59)									int x3 = range_x3;
HXDLIN(  59)									int y3 = range_y3;
HXDLIN(  59)									int c3 = -1048336;
HXDLIN(  59)									bool _hx_tmp9;
HXDLIN(  59)									if ((((c3 >> 24) & 255) < 254)) {
HXLINE(  59)										_hx_tmp9 = this38->transparent;
            									}
            									else {
HXLINE(  59)										_hx_tmp9 = false;
            									}
HXDLIN(  59)									if (_hx_tmp9) {
HXLINE(  59)										int location3;
HXDLIN(  59)										if (this38->useVirtualPos) {
HXLINE(  59)											location3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this38->virtualY) * ( (Float)(this38->width) )) + x3) - this38->virtualX));
            										}
            										else {
HXLINE(  59)											location3 = ::Std_obj::_hx_int(( (Float)(((y3 * this38->width) + x3)) ));
            										}
HXDLIN(  59)										int this39 = ::iterMagic::Iimg_obj::get(this38->image,location3);
HXDLIN(  59)										int this40;
HXDLIN(  59)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)											this40 = ((((((this39 >> 24) & 255) << 24) | ((this39 & 255) << 16)) | (((this39 >> 8) & 255) << 8)) | ((this39 >> 16) & 255));
            										}
            										else {
HXLINE(  59)											this40 = this39;
            										}
HXDLIN(  59)										Float a13;
HXDLIN(  59)										int this41 = ((this40 >> 24) & 255);
HXDLIN(  59)										if ((this41 == 0)) {
HXLINE(  59)											a13 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											a13 = (( (Float)(this41) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float r13;
HXDLIN(  59)										int this42 = ((this40 >> 16) & 255);
HXDLIN(  59)										if ((this42 == 0)) {
HXLINE(  59)											r13 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											r13 = (( (Float)(this42) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float g13;
HXDLIN(  59)										int this43 = ((this40 >> 8) & 255);
HXDLIN(  59)										if ((this43 == 0)) {
HXLINE(  59)											g13 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											g13 = (( (Float)(this43) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float b13;
HXDLIN(  59)										int this44 = (this40 & 255);
HXDLIN(  59)										if ((this44 == 0)) {
HXLINE(  59)											b13 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											b13 = (( (Float)(this44) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float a23;
HXDLIN(  59)										int this45 = ((-1048336 >> 24) & 255);
HXDLIN(  59)										if ((this45 == 0)) {
HXLINE(  59)											a23 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											a23 = (( (Float)(this45) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float r23;
HXDLIN(  59)										int this46 = ((-1048336 >> 16) & 255);
HXDLIN(  59)										if ((this46 == 0)) {
HXLINE(  59)											r23 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											r23 = (( (Float)(this46) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float g23;
HXDLIN(  59)										int this47 = ((-1048336 >> 8) & 255);
HXDLIN(  59)										if ((this47 == 0)) {
HXLINE(  59)											g23 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											g23 = (( (Float)(this47) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float b23;
HXDLIN(  59)										int this48 = (-1048336 & 255);
HXDLIN(  59)										if ((this48 == 0)) {
HXLINE(  59)											b23 = ((Float)0.);
            										}
            										else {
HXLINE(  59)											b23 = (( (Float)(this48) ) / ( (Float)(255) ));
            										}
HXDLIN(  59)										Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  59)										int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  59)										int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  59)										int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a33) + (b23 * a23))));
HXDLIN(  59)										int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  59)										int blended3 = ((((a7 << 24) | (r5 << 16)) | (g5 << 8)) | b5);
HXDLIN(  59)										{
HXLINE(  59)											int _hx_tmp10;
HXDLIN(  59)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)												_hx_tmp10 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            											}
            											else {
HXLINE(  59)												_hx_tmp10 = blended3;
            											}
HXDLIN(  59)											::iterMagic::Iimg_obj::set(this38->image,location3,_hx_tmp10);
            										}
            									}
            									else {
HXLINE(  59)										::Dynamic this49 = this38->image;
HXDLIN(  59)										int index3;
HXDLIN(  59)										if (this38->useVirtualPos) {
HXLINE(  59)											index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this38->virtualY) * ( (Float)(this38->width) )) + x3) - this38->virtualX));
            										}
            										else {
HXLINE(  59)											index3 = ::Std_obj::_hx_int(( (Float)(((y3 * this38->width) + x3)) ));
            										}
HXDLIN(  59)										int _hx_tmp11;
HXDLIN(  59)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)											_hx_tmp11 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            										}
            										else {
HXLINE(  59)											_hx_tmp11 = c3;
            										}
HXDLIN(  59)										::iterMagic::Iimg_obj::set(this49,index3,_hx_tmp11);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  59)				{
HXLINE(  59)					{
HXLINE(  59)						Float bx2 = bx1;
HXDLIN(  59)						Float by2 = by1;
HXDLIN(  59)						Float cx2 = dx;
HXDLIN(  59)						Float cy2 = dy;
HXDLIN(  59)						bool hasUndo = false;
HXDLIN(  59)						bool adjustWinding = (((((ax1 * by2) - (bx2 * ay1)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ay1) - (ax1 * cy2))) > 0);
HXDLIN(  59)						if (!(adjustWinding)) {
HXLINE(  59)							Float bx_ = bx2;
HXDLIN(  59)							Float by_ = by2;
HXLINE(  25)							bx2 = cx2;
HXLINE(  26)							by2 = cy2;
HXLINE(  27)							cx2 = bx_;
HXLINE(  28)							cy2 = by_;
            						}
HXLINE(  59)						{
HXLINE(  59)							Float s0 = ((ay1 * cx2) - (ax1 * cy2));
HXDLIN(  59)							Float sx = (cy2 - ay1);
HXDLIN(  59)							Float sy = (ax1 - cx2);
HXDLIN(  59)							Float t0 = ((ax1 * by2) - (ay1 * bx2));
HXDLIN(  59)							Float tx = (ay1 - by2);
HXDLIN(  59)							Float ty = (bx2 - ax1);
HXDLIN(  59)							Float A = ((((-(by2) * cx2) + (ay1 * (-(bx2) + cx2))) + (ax1 * (by2 - cy2))) + (bx2 * cy2));
HXDLIN(  59)							 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  59)							if ((ax1 > bx2)) {
HXLINE(  59)								if ((ax1 > cx2)) {
HXLINE(  59)									int min;
HXDLIN(  59)									if ((bx2 > cx2)) {
HXLINE(  59)										min = ::Math_obj::floor(cx2);
            									}
            									else {
HXLINE(  59)										min = ::Math_obj::floor(bx2);
            									}
HXDLIN(  59)									int ii_min8 = min;
HXDLIN(  59)									int ii_max8 = ::Math_obj::ceil(ax1);
HXDLIN(  59)									xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            								}
            								else {
HXLINE(  59)									int ii_min9 = ::Math_obj::floor(bx2);
HXDLIN(  59)									int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN(  59)									xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            								}
            							}
            							else {
HXLINE(  59)								if ((bx2 > cx2)) {
HXLINE(  59)									int min1;
HXDLIN(  59)									if ((ax1 > cx2)) {
HXLINE(  59)										min1 = ::Math_obj::floor(cx2);
            									}
            									else {
HXLINE(  59)										min1 = ::Math_obj::ceil(ax1);
            									}
HXDLIN(  59)									int ii_min10 = min1;
HXDLIN(  59)									int ii_max10 = ::Math_obj::ceil(bx2);
HXDLIN(  59)									xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            								}
            								else {
HXLINE(  59)									int ii_min11 = ::Math_obj::floor(ax1);
HXDLIN(  59)									int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN(  59)									xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            								}
            							}
HXDLIN(  59)							 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  59)							if ((ay1 > by2)) {
HXLINE(  59)								if ((ay1 > cy2)) {
HXLINE(  59)									int min2;
HXDLIN(  59)									if ((by2 > cy2)) {
HXLINE(  59)										min2 = ::Math_obj::floor(cy2);
            									}
            									else {
HXLINE(  59)										min2 = ::Math_obj::floor(by2);
            									}
HXDLIN(  59)									int ii_min12 = min2;
HXDLIN(  59)									int ii_max12 = ::Math_obj::ceil(ay1);
HXDLIN(  59)									yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            								}
            								else {
HXLINE(  59)									int ii_min13 = ::Math_obj::floor(by2);
HXDLIN(  59)									int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN(  59)									yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            								}
            							}
            							else {
HXLINE(  59)								if ((by2 > cy2)) {
HXLINE(  59)									int min3;
HXDLIN(  59)									if ((ay1 > cy2)) {
HXLINE(  59)										min3 = ::Math_obj::floor(cy2);
            									}
            									else {
HXLINE(  59)										min3 = ::Math_obj::ceil(ay1);
            									}
HXDLIN(  59)									int ii_min14 = min3;
HXDLIN(  59)									int ii_max14 = ::Math_obj::ceil(by2);
HXDLIN(  59)									yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            								}
            								else {
HXLINE(  59)									int ii_min15 = ::Math_obj::floor(ay1);
HXDLIN(  59)									int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN(  59)									yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            								}
            							}
HXDLIN(  59)							 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  59)							if (hasUndo) {
HXLINE(  59)								int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  59)								int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  59)								 ::Dynamic imageType = null();
HXDLIN(  59)								 ::pi_xy::ImageStruct this50 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  59)								if (::hx::IsNull( imageType )) {
HXLINE(  54)									imageType = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE(  59)								::Dynamic undoImage1;
HXDLIN(  59)								switch((int)(( (int)(imageType) ))){
            									case (int)0: {
HXLINE(  59)										 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  59)										 ::iterMagic::BytesImg b6 = byt;
HXDLIN(  59)										{
HXLINE(  59)											b6->width = width;
HXDLIN(  59)											b6->height = height;
HXDLIN(  59)											b6->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  59)											b6->data = ::haxe::io::Bytes_obj::alloc((b6->length * 4));
HXDLIN(  59)											{
HXLINE(  59)												int len = b6->length;
HXDLIN(  59)												int w = 0;
HXDLIN(  59)												{
HXLINE(  59)													int _g = 0;
HXDLIN(  59)													int _g1 = b6->height;
HXDLIN(  59)													while((_g < _g1)){
HXLINE(  59)														_g = (_g + 1);
HXDLIN(  59)														int y4 = (_g - 1);
HXDLIN(  59)														{
HXLINE(  59)															int _g2 = 0;
HXDLIN(  59)															int _g3 = b6->width;
HXDLIN(  59)															while((_g2 < _g3)){
HXLINE(  59)																_g2 = (_g2 + 1);
HXDLIN(  59)																int x4 = (_g2 - 1);
HXDLIN(  59)																{
HXLINE(  59)																	w = (w + 1);
HXDLIN(  59)																	b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  59)																{
HXLINE(  59)																	w = (w + 1);
HXDLIN(  59)																	b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  59)																{
HXLINE(  59)																	w = (w + 1);
HXDLIN(  59)																	b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  59)																{
HXLINE(  59)																	w = (w + 1);
HXDLIN(  59)																	b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  59)										undoImage1 = b6;
            									}
            									break;
            									case (int)1: {
HXLINE(  59)										 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  59)										 ::iterMagic::ArrIntImg a8 = arrI;
HXDLIN(  59)										{
HXLINE(  59)											a8->width = width;
HXDLIN(  59)											a8->height = height;
HXDLIN(  59)											a8->data = ::Array_obj< int >::__new(0);
HXDLIN(  59)											a8->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  59)											{
HXLINE(  59)												int _g4 = 0;
HXDLIN(  59)												int _g5 = a8->length;
HXDLIN(  59)												while((_g4 < _g5)){
HXLINE(  59)													_g4 = (_g4 + 1);
HXDLIN(  59)													int i8 = (_g4 - 1);
HXDLIN(  59)													a8->data[i8] = 0;
            												}
            											}
            										}
HXDLIN(  59)										undoImage1 = a8;
            									}
            									break;
            									case (int)2: {
HXLINE(  59)										 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  59)										 ::iterMagic::U32ArrImg b7 = u32a;
HXDLIN(  59)										{
HXLINE(  59)											b7->width = width;
HXDLIN(  59)											b7->height = height;
HXDLIN(  59)											b7->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  59)											int size = (b7->length * 4);
HXDLIN(  59)											b7->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  59)											{
HXLINE(  59)												int _g6 = 0;
HXDLIN(  59)												int _g7 = b7->length;
HXDLIN(  59)												while((_g6 < _g7)){
HXLINE(  59)													_g6 = (_g6 + 1);
HXDLIN(  59)													int i9 = (_g6 - 1);
HXDLIN(  59)													{
HXLINE(  59)														 ::haxe::io::ArrayBufferViewImpl this51 = b7->data;
HXDLIN(  59)														bool undoImage2;
HXDLIN(  59)														if ((i9 >= 0)) {
HXLINE(  59)															undoImage2 = (i9 < (this51->byteLength >> 2));
            														}
            														else {
HXLINE(  59)															undoImage2 = false;
            														}
HXDLIN(  59)														if (undoImage2) {
HXLINE(  59)															 ::haxe::io::Bytes _this = this51->bytes;
HXDLIN(  59)															int pos = ((i9 << 2) + this51->byteOffset);
HXDLIN(  59)															_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  59)															_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  59)															_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  59)															_this->b[(pos + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN(  59)										undoImage1 = b7;
            									}
            									break;
            									case (int)3: {
HXLINE(  59)										 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  59)										 ::iterMagic::VecIntImg v = vec;
HXDLIN(  59)										{
HXLINE(  59)											v->width = width;
HXDLIN(  59)											v->height = height;
HXDLIN(  59)											v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  59)											v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  59)											{
HXLINE(  59)												int _g8 = 0;
HXDLIN(  59)												int _g9 = v->length;
HXDLIN(  59)												while((_g8 < _g9)){
HXLINE(  59)													_g8 = (_g8 + 1);
HXDLIN(  59)													int i10 = (_g8 - 1);
HXDLIN(  59)													v->data->__unsafe_set(i10,0);
            												}
            											}
            										}
HXDLIN(  59)										undoImage1 = v;
            									}
            									break;
            									case (int)4: {
HXLINE(  59)										 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  59)										 ::iterMagic::StackIntImg b8 = sInt;
HXDLIN(  59)										{
HXLINE(  59)											b8->width = width;
HXDLIN(  59)											b8->height = height;
HXDLIN(  59)											b8->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  59)											b8->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  59)											{
HXLINE(  59)												int len1 = b8->length;
HXDLIN(  59)												 ::haxe::ds::GenericStack_Int d = b8->data;
HXDLIN(  59)												if (::hx::IsNull( d->head )) {
HXLINE(  59)													int _g10 = 0;
HXDLIN(  59)													int _g11 = len1;
HXDLIN(  59)													while((_g10 < _g11)){
HXLINE(  59)														_g10 = (_g10 + 1);
HXDLIN(  59)														int i11 = (_g10 - 1);
HXDLIN(  59)														d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            													}
            												}
            												else {
HXLINE(  59)													int _g12 = 0;
HXDLIN(  59)													int _g13 = len1;
HXDLIN(  59)													while((_g12 < _g13)){
HXLINE(  59)														_g12 = (_g12 + 1);
HXDLIN(  59)														int i12 = (_g12 - 1);
HXDLIN(  59)														{
HXLINE(  59)															 ::haxe::ds::GenericCell_Int l = b8->data->head;
HXDLIN(  59)															 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  59)															{
HXLINE(  59)																int _g14 = 0;
HXDLIN(  59)																int _g15 = i12;
HXDLIN(  59)																while((_g14 < _g15)){
HXLINE(  59)																	_g14 = (_g14 + 1);
HXDLIN(  59)																	int i13 = (_g14 - 1);
HXLINE( 345)																	prev = l;
HXLINE( 346)																	l = l->next;
            																}
            															}
HXLINE(  59)															if (::hx::IsNull( prev )) {
HXLINE(  59)																b8->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  59)																l = null();
            															}
            															else {
HXLINE(  59)																prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  59)																l = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  59)										undoImage1 = b8;
            									}
            									break;
            								}
HXDLIN(  59)								this50->image = undoImage1;
HXDLIN(  59)								this50->width = width;
HXDLIN(  59)								this50->height = height;
HXDLIN(  59)								this50->imageType = ( (int)(imageType) );
HXDLIN(  59)								undoImage = this50;
HXDLIN(  59)								{
HXLINE(  59)									int rectLeft = xIter3->start;
HXDLIN(  59)									int rectTop = yIter3->start;
HXDLIN(  59)									int rectRight = xIter3->max;
HXDLIN(  59)									bool forceClear = false;
HXDLIN(  59)									{
HXLINE(  59)										int _g16 = rectTop;
HXDLIN(  59)										int _g17 = yIter3->max;
HXDLIN(  59)										while((_g16 < _g17)){
HXLINE(  59)											_g16 = (_g16 + 1);
HXDLIN(  59)											int dy1 = (_g16 - 1);
HXDLIN(  59)											{
HXLINE(  59)												int _g18 = rectLeft;
HXDLIN(  59)												int _g19 = rectRight;
HXDLIN(  59)												while((_g18 < _g19)){
HXLINE(  59)													_g18 = (_g18 + 1);
HXDLIN(  59)													int dx1 = (_g18 - 1);
HXDLIN(  59)													::Dynamic this52 = this1->image;
HXDLIN(  59)													int index4;
HXDLIN(  59)													if (this1->useVirtualPos) {
HXLINE(  59)														index4 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx1) - this1->virtualX));
            													}
            													else {
HXLINE(  59)														index4 = ::Std_obj::_hx_int(( (Float)(((dy1 * this1->width) + dx1)) ));
            													}
HXDLIN(  59)													int c4 = ::iterMagic::Iimg_obj::get(this52,index4);
HXDLIN(  59)													int col;
HXDLIN(  59)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)														col = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            													}
            													else {
HXLINE(  59)														col = c4;
            													}
HXDLIN(  59)													bool _hx_tmp12;
HXDLIN(  59)													if (this1->useMask) {
HXLINE(  59)														_hx_tmp12 = ::hx::IsNotNull( this1->mask );
            													}
            													else {
HXLINE(  59)														_hx_tmp12 = false;
            													}
HXDLIN(  59)													if (_hx_tmp12) {
HXLINE(  59)														 ::pi_xy::ImageStruct this53 = this1->mask;
HXDLIN(  59)														::Dynamic this54 = this53->image;
HXDLIN(  59)														int index5;
HXDLIN(  59)														if (this53->useVirtualPos) {
HXLINE(  59)															index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this53->virtualY) * ( (Float)(this53->width) )) + dx1) - this53->virtualX));
            														}
            														else {
HXLINE(  59)															index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this53->width) + dx1)) ));
            														}
HXDLIN(  59)														int c5 = ::iterMagic::Iimg_obj::get(this54,index5);
HXDLIN(  59)														int v1;
HXDLIN(  59)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)															v1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            														}
            														else {
HXLINE(  59)															v1 = c5;
            														}
HXDLIN(  59)														int maskPixel = v1;
HXDLIN(  59)														int this55 = col;
HXDLIN(  59)														if ((maskPixel == 0)) {
HXLINE(  59)															col = this55;
            														}
            														else {
HXLINE(  59)															Float m0;
HXDLIN(  59)															int this56 = ((maskPixel >> 24) & 255);
HXDLIN(  59)															if ((this56 == 0)) {
HXLINE(  59)																m0 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																m0 = (( (Float)(this56) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float m1;
HXDLIN(  59)															int this57 = ((maskPixel >> 16) & 255);
HXDLIN(  59)															if ((this57 == 0)) {
HXLINE(  59)																m1 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																m1 = (( (Float)(this57) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float m2;
HXDLIN(  59)															int this58 = ((maskPixel >> 8) & 255);
HXDLIN(  59)															if ((this58 == 0)) {
HXLINE(  59)																m2 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																m2 = (( (Float)(this58) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float m3;
HXDLIN(  59)															int this59 = (maskPixel & 255);
HXDLIN(  59)															if ((this59 == 0)) {
HXLINE(  59)																m3 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																m3 = (( (Float)(this59) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this55 >> 24) & 255)) )));
HXDLIN(  59)															int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this55 >> 16) & 255)) )));
HXDLIN(  59)															int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this55 >> 8) & 255)) )));
HXDLIN(  59)															int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this55 & 255)) )));
HXDLIN(  59)															col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  59)													if ((col != 0)) {
HXLINE(  59)														int x5 = (dx1 - rectLeft);
HXDLIN(  59)														int y5 = (dy1 - rectTop);
HXDLIN(  59)														int c6 = col;
HXDLIN(  59)														bool _hx_tmp13;
HXDLIN(  59)														if ((((c6 >> 24) & 255) < 254)) {
HXLINE(  59)															_hx_tmp13 = undoImage->transparent;
            														}
            														else {
HXLINE(  59)															_hx_tmp13 = false;
            														}
HXDLIN(  59)														if (_hx_tmp13) {
HXLINE(  59)															int location4;
HXDLIN(  59)															if (undoImage->useVirtualPos) {
HXLINE(  59)																location4 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            															}
            															else {
HXLINE(  59)																location4 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage->width) + x5)) ));
            															}
HXDLIN(  59)															int this60 = ::iterMagic::Iimg_obj::get(undoImage->image,location4);
HXDLIN(  59)															int this61;
HXDLIN(  59)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)																this61 = ((((((this60 >> 24) & 255) << 24) | ((this60 & 255) << 16)) | (((this60 >> 8) & 255) << 8)) | ((this60 >> 16) & 255));
            															}
            															else {
HXLINE(  59)																this61 = this60;
            															}
HXDLIN(  59)															Float a14;
HXDLIN(  59)															int this62 = ((this61 >> 24) & 255);
HXDLIN(  59)															if ((this62 == 0)) {
HXLINE(  59)																a14 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																a14 = (( (Float)(this62) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float r14;
HXDLIN(  59)															int this63 = ((this61 >> 16) & 255);
HXDLIN(  59)															if ((this63 == 0)) {
HXLINE(  59)																r14 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																r14 = (( (Float)(this63) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float g14;
HXDLIN(  59)															int this64 = ((this61 >> 8) & 255);
HXDLIN(  59)															if ((this64 == 0)) {
HXLINE(  59)																g14 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																g14 = (( (Float)(this64) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float b14;
HXDLIN(  59)															int this65 = (this61 & 255);
HXDLIN(  59)															if ((this65 == 0)) {
HXLINE(  59)																b14 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																b14 = (( (Float)(this65) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float a24;
HXDLIN(  59)															int this66 = ((col >> 24) & 255);
HXDLIN(  59)															if ((this66 == 0)) {
HXLINE(  59)																a24 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																a24 = (( (Float)(this66) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float r24;
HXDLIN(  59)															int this67 = ((col >> 16) & 255);
HXDLIN(  59)															if ((this67 == 0)) {
HXLINE(  59)																r24 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																r24 = (( (Float)(this67) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float g24;
HXDLIN(  59)															int this68 = ((col >> 8) & 255);
HXDLIN(  59)															if ((this68 == 0)) {
HXLINE(  59)																g24 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																g24 = (( (Float)(this68) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float b24;
HXDLIN(  59)															int this69 = (col & 255);
HXDLIN(  59)															if ((this69 == 0)) {
HXLINE(  59)																b24 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																b24 = (( (Float)(this69) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float a34 = (a14 * (( (Float)(1) ) - a24));
HXDLIN(  59)															int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN(  59)															int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN(  59)															int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a34) + (b24 * a24))));
HXDLIN(  59)															int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN(  59)															int blended4 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b9);
HXDLIN(  59)															{
HXLINE(  59)																int _hx_tmp14;
HXDLIN(  59)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)																	_hx_tmp14 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            																}
            																else {
HXLINE(  59)																	_hx_tmp14 = blended4;
            																}
HXDLIN(  59)																::iterMagic::Iimg_obj::set(undoImage->image,location4,_hx_tmp14);
            															}
            														}
            														else {
HXLINE(  59)															::Dynamic this70 = undoImage->image;
HXDLIN(  59)															int index6;
HXDLIN(  59)															if (undoImage->useVirtualPos) {
HXLINE(  59)																index6 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            															}
            															else {
HXLINE(  59)																index6 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage->width) + x5)) ));
            															}
HXDLIN(  59)															int _hx_tmp15;
HXDLIN(  59)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)																_hx_tmp15 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            															}
            															else {
HXLINE(  59)																_hx_tmp15 = c6;
            															}
HXDLIN(  59)															::iterMagic::Iimg_obj::set(this70,index6,_hx_tmp15);
            														}
            													}
            													else {
HXLINE(  59)														if (forceClear) {
HXLINE(  59)															::Dynamic this71 = undoImage->image;
HXDLIN(  59)															int x6 = (dx1 - rectLeft);
HXDLIN(  59)															int y6 = (dy1 - rectTop);
HXDLIN(  59)															int index7;
HXDLIN(  59)															if (undoImage->useVirtualPos) {
HXLINE(  59)																index7 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x6) - undoImage->virtualX));
            															}
            															else {
HXLINE(  59)																index7 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage->width) + x6)) ));
            															}
HXDLIN(  59)															::iterMagic::Iimg_obj::set(this71,index7,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  59)							bool found = false;
HXDLIN(  59)							Float s = ((Float)0.);
HXDLIN(  59)							Float t = ((Float)0.);
HXDLIN(  59)							Float sxx = ((Float)0.);
HXDLIN(  59)							Float txx = ((Float)0.);
HXDLIN(  59)							{
HXLINE(  59)								int _g_min = xIter3->start;
HXDLIN(  59)								int _g_max = xIter3->max;
HXDLIN(  59)								while((_g_min < _g_max)){
HXLINE(  59)									_g_min = (_g_min + 1);
HXDLIN(  59)									int x7 = (_g_min - 1);
HXLINE(  60)									sxx = (sx * ( (Float)(x7) ));
HXLINE(  61)									txx = (tx * ( (Float)(x7) ));
HXLINE(  62)									found = false;
HXLINE(  59)									{
HXLINE(  59)										int _g_min1 = yIter3->start;
HXDLIN(  59)										int _g_max1 = yIter3->max;
HXDLIN(  59)										while((_g_min1 < _g_max1)){
HXLINE(  59)											_g_min1 = (_g_min1 + 1);
HXDLIN(  59)											int y7 = (_g_min1 - 1);
HXLINE(  64)											s = ((s0 + sxx) + (sy * ( (Float)(y7) )));
HXLINE(  65)											t = ((t0 + txx) + (ty * ( (Float)(y7) )));
HXLINE(  59)											bool _hx_tmp16;
HXDLIN(  59)											if (!((s <= 0))) {
HXLINE(  59)												_hx_tmp16 = (t <= 0);
            											}
            											else {
HXLINE(  59)												_hx_tmp16 = true;
            											}
HXDLIN(  59)											if (_hx_tmp16) {
HXLINE(  59)												if (found) {
HXLINE(  59)													goto _hx_goto_157;
            												}
            											}
            											else {
HXLINE(  59)												if (((s + t) < A)) {
HXLINE(  59)													{
HXLINE(  59)														int c7 = color;
HXDLIN(  59)														bool _hx_tmp17;
HXDLIN(  59)														if ((((c7 >> 24) & 255) < 254)) {
HXLINE(  59)															_hx_tmp17 = this1->transparent;
            														}
            														else {
HXLINE(  59)															_hx_tmp17 = false;
            														}
HXDLIN(  59)														if (_hx_tmp17) {
HXLINE(  59)															int location5;
HXDLIN(  59)															if (this1->useVirtualPos) {
HXLINE(  59)																location5 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this1->virtualY) * ( (Float)(this1->width) )) + x7) - this1->virtualX));
            															}
            															else {
HXLINE(  59)																location5 = ::Std_obj::_hx_int(( (Float)(((y7 * this1->width) + x7)) ));
            															}
HXDLIN(  59)															int this72 = ::iterMagic::Iimg_obj::get(this1->image,location5);
HXDLIN(  59)															int this73;
HXDLIN(  59)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)																this73 = ((((((this72 >> 24) & 255) << 24) | ((this72 & 255) << 16)) | (((this72 >> 8) & 255) << 8)) | ((this72 >> 16) & 255));
            															}
            															else {
HXLINE(  59)																this73 = this72;
            															}
HXDLIN(  59)															Float a15;
HXDLIN(  59)															int this74 = ((this73 >> 24) & 255);
HXDLIN(  59)															if ((this74 == 0)) {
HXLINE(  59)																a15 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																a15 = (( (Float)(this74) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float r15;
HXDLIN(  59)															int this75 = ((this73 >> 16) & 255);
HXDLIN(  59)															if ((this75 == 0)) {
HXLINE(  59)																r15 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																r15 = (( (Float)(this75) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float g15;
HXDLIN(  59)															int this76 = ((this73 >> 8) & 255);
HXDLIN(  59)															if ((this76 == 0)) {
HXLINE(  59)																g15 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																g15 = (( (Float)(this76) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float b15;
HXDLIN(  59)															int this77 = (this73 & 255);
HXDLIN(  59)															if ((this77 == 0)) {
HXLINE(  59)																b15 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																b15 = (( (Float)(this77) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float a25;
HXDLIN(  59)															int this78 = ((color >> 24) & 255);
HXDLIN(  59)															if ((this78 == 0)) {
HXLINE(  59)																a25 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																a25 = (( (Float)(this78) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float r25;
HXDLIN(  59)															int this79 = ((color >> 16) & 255);
HXDLIN(  59)															if ((this79 == 0)) {
HXLINE(  59)																r25 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																r25 = (( (Float)(this79) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float g25;
HXDLIN(  59)															int this80 = ((color >> 8) & 255);
HXDLIN(  59)															if ((this80 == 0)) {
HXLINE(  59)																g25 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																g25 = (( (Float)(this80) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float b25;
HXDLIN(  59)															int this81 = (color & 255);
HXDLIN(  59)															if ((this81 == 0)) {
HXLINE(  59)																b25 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																b25 = (( (Float)(this81) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float a35 = (a15 * (( (Float)(1) ) - a25));
HXDLIN(  59)															int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN(  59)															int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN(  59)															int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a35) + (b25 * a25))));
HXDLIN(  59)															int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN(  59)															int blended5 = ((((a10 << 24) | (r7 << 16)) | (g7 << 8)) | b10);
HXDLIN(  59)															{
HXLINE(  59)																int _hx_tmp18;
HXDLIN(  59)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)																	_hx_tmp18 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            																}
            																else {
HXLINE(  59)																	_hx_tmp18 = blended5;
            																}
HXDLIN(  59)																::iterMagic::Iimg_obj::set(this1->image,location5,_hx_tmp18);
            															}
            														}
            														else {
HXLINE(  59)															::Dynamic this82 = this1->image;
HXDLIN(  59)															int index8;
HXDLIN(  59)															if (this1->useVirtualPos) {
HXLINE(  59)																index8 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this1->virtualY) * ( (Float)(this1->width) )) + x7) - this1->virtualX));
            															}
            															else {
HXLINE(  59)																index8 = ::Std_obj::_hx_int(( (Float)(((y7 * this1->width) + x7)) ));
            															}
HXDLIN(  59)															int _hx_tmp19;
HXDLIN(  59)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)																_hx_tmp19 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            															}
            															else {
HXLINE(  59)																_hx_tmp19 = c7;
            															}
HXDLIN(  59)															::iterMagic::Iimg_obj::set(this82,index8,_hx_tmp19);
            														}
            													}
HXLINE(  73)													found = true;
            												}
            												else {
HXLINE(  59)													if (found) {
HXLINE(  59)														goto _hx_goto_157;
            													}
            												}
            											}
            										}
            										_hx_goto_157:;
            									}
            								}
            							}
HXDLIN(  59)							if ((hasHit == true)) {
HXLINE(  59)								 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax1,ay1,bx2,by2,cx2,cy2,true);
HXDLIN(  59)								if (hasUndo) {
HXLINE(  59)									v2->undoImage = undoImage;
HXDLIN(  59)									v2->undoX = xIter3->start;
HXDLIN(  59)									v2->undoY = yIter3->start;
            								}
            							}
            						}
            					}
HXDLIN(  59)					{
HXLINE(  59)						Float bx3 = cx1;
HXDLIN(  59)						Float by3 = cy1;
HXDLIN(  59)						Float cx3 = dx;
HXDLIN(  59)						Float cy3 = dy;
HXDLIN(  59)						bool hasUndo1 = false;
HXDLIN(  59)						bool adjustWinding1 = (((((bx1 * by3) - (bx3 * by1)) + ((bx3 * cy3) - (cx3 * by3))) + ((cx3 * by1) - (bx1 * cy3))) > 0);
HXDLIN(  59)						if (!(adjustWinding1)) {
HXLINE(  59)							Float bx_1 = bx3;
HXDLIN(  59)							Float by_1 = by3;
HXLINE(  25)							bx3 = cx3;
HXLINE(  26)							by3 = cy3;
HXLINE(  27)							cx3 = bx_1;
HXLINE(  28)							cy3 = by_1;
            						}
HXLINE(  59)						{
HXLINE(  59)							Float s01 = ((by1 * cx3) - (bx1 * cy3));
HXDLIN(  59)							Float sx1 = (cy3 - by1);
HXDLIN(  59)							Float sy1 = (bx1 - cx3);
HXDLIN(  59)							Float t01 = ((bx1 * by3) - (by1 * bx3));
HXDLIN(  59)							Float tx1 = (by1 - by3);
HXDLIN(  59)							Float ty1 = (bx3 - bx1);
HXDLIN(  59)							Float A1 = ((((-(by3) * cx3) + (by1 * (-(bx3) + cx3))) + (bx1 * (by3 - cy3))) + (bx3 * cy3));
HXDLIN(  59)							 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  59)							if ((bx1 > bx3)) {
HXLINE(  59)								if ((bx1 > cx3)) {
HXLINE(  59)									int min4;
HXDLIN(  59)									if ((bx3 > cx3)) {
HXLINE(  59)										min4 = ::Math_obj::floor(cx3);
            									}
            									else {
HXLINE(  59)										min4 = ::Math_obj::floor(bx3);
            									}
HXDLIN(  59)									int ii_min16 = min4;
HXDLIN(  59)									int ii_max16 = ::Math_obj::ceil(bx1);
HXDLIN(  59)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            								}
            								else {
HXLINE(  59)									int ii_min17 = ::Math_obj::floor(bx3);
HXDLIN(  59)									int ii_max17 = ::Math_obj::ceil(cx3);
HXDLIN(  59)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            								}
            							}
            							else {
HXLINE(  59)								if ((bx3 > cx3)) {
HXLINE(  59)									int min5;
HXDLIN(  59)									if ((bx1 > cx3)) {
HXLINE(  59)										min5 = ::Math_obj::floor(cx3);
            									}
            									else {
HXLINE(  59)										min5 = ::Math_obj::ceil(bx1);
            									}
HXDLIN(  59)									int ii_min18 = min5;
HXDLIN(  59)									int ii_max18 = ::Math_obj::ceil(bx3);
HXDLIN(  59)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            								}
            								else {
HXLINE(  59)									int ii_min19 = ::Math_obj::floor(bx1);
HXDLIN(  59)									int ii_max19 = ::Math_obj::ceil(cx3);
HXDLIN(  59)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            								}
            							}
HXDLIN(  59)							 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  59)							if ((by1 > by3)) {
HXLINE(  59)								if ((by1 > cy3)) {
HXLINE(  59)									int min6;
HXDLIN(  59)									if ((by3 > cy3)) {
HXLINE(  59)										min6 = ::Math_obj::floor(cy3);
            									}
            									else {
HXLINE(  59)										min6 = ::Math_obj::floor(by3);
            									}
HXDLIN(  59)									int ii_min20 = min6;
HXDLIN(  59)									int ii_max20 = ::Math_obj::ceil(by1);
HXDLIN(  59)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            								}
            								else {
HXLINE(  59)									int ii_min21 = ::Math_obj::floor(by3);
HXDLIN(  59)									int ii_max21 = ::Math_obj::ceil(cy3);
HXDLIN(  59)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            								}
            							}
            							else {
HXLINE(  59)								if ((by3 > cy3)) {
HXLINE(  59)									int min7;
HXDLIN(  59)									if ((by1 > cy3)) {
HXLINE(  59)										min7 = ::Math_obj::floor(cy3);
            									}
            									else {
HXLINE(  59)										min7 = ::Math_obj::ceil(by1);
            									}
HXDLIN(  59)									int ii_min22 = min7;
HXDLIN(  59)									int ii_max22 = ::Math_obj::ceil(by3);
HXDLIN(  59)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            								}
            								else {
HXLINE(  59)									int ii_min23 = ::Math_obj::floor(by1);
HXDLIN(  59)									int ii_max23 = ::Math_obj::ceil(cy3);
HXDLIN(  59)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            								}
            							}
HXDLIN(  59)							 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  59)							if (hasUndo1) {
HXLINE(  59)								int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  59)								int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  59)								 ::Dynamic imageType1 = null();
HXDLIN(  59)								 ::pi_xy::ImageStruct this83 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  59)								if (::hx::IsNull( imageType1 )) {
HXLINE(  54)									imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE(  59)								::Dynamic undoImage4;
HXDLIN(  59)								switch((int)(( (int)(imageType1) ))){
            									case (int)0: {
HXLINE(  59)										 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  59)										 ::iterMagic::BytesImg b16 = byt1;
HXDLIN(  59)										{
HXLINE(  59)											b16->width = width1;
HXDLIN(  59)											b16->height = height1;
HXDLIN(  59)											b16->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  59)											b16->data = ::haxe::io::Bytes_obj::alloc((b16->length * 4));
HXDLIN(  59)											{
HXLINE(  59)												int len2 = b16->length;
HXDLIN(  59)												int w1 = 0;
HXDLIN(  59)												{
HXLINE(  59)													int _g20 = 0;
HXDLIN(  59)													int _g21 = b16->height;
HXDLIN(  59)													while((_g20 < _g21)){
HXLINE(  59)														_g20 = (_g20 + 1);
HXDLIN(  59)														int y8 = (_g20 - 1);
HXDLIN(  59)														{
HXLINE(  59)															int _g22 = 0;
HXDLIN(  59)															int _g23 = b16->width;
HXDLIN(  59)															while((_g22 < _g23)){
HXLINE(  59)																_g22 = (_g22 + 1);
HXDLIN(  59)																int x8 = (_g22 - 1);
HXDLIN(  59)																{
HXLINE(  59)																	w1 = (w1 + 1);
HXDLIN(  59)																	b16->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  59)																{
HXLINE(  59)																	w1 = (w1 + 1);
HXDLIN(  59)																	b16->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  59)																{
HXLINE(  59)																	w1 = (w1 + 1);
HXDLIN(  59)																	b16->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  59)																{
HXLINE(  59)																	w1 = (w1 + 1);
HXDLIN(  59)																	b16->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  59)										undoImage4 = b16;
            									}
            									break;
            									case (int)1: {
HXLINE(  59)										 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  59)										 ::iterMagic::ArrIntImg a16 = arrI1;
HXDLIN(  59)										{
HXLINE(  59)											a16->width = width1;
HXDLIN(  59)											a16->height = height1;
HXDLIN(  59)											a16->data = ::Array_obj< int >::__new(0);
HXDLIN(  59)											a16->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  59)											{
HXLINE(  59)												int _g24 = 0;
HXDLIN(  59)												int _g25 = a16->length;
HXDLIN(  59)												while((_g24 < _g25)){
HXLINE(  59)													_g24 = (_g24 + 1);
HXDLIN(  59)													int i14 = (_g24 - 1);
HXDLIN(  59)													a16->data[i14] = 0;
            												}
            											}
            										}
HXDLIN(  59)										undoImage4 = a16;
            									}
            									break;
            									case (int)2: {
HXLINE(  59)										 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  59)										 ::iterMagic::U32ArrImg b17 = u32a1;
HXDLIN(  59)										{
HXLINE(  59)											b17->width = width1;
HXDLIN(  59)											b17->height = height1;
HXDLIN(  59)											b17->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  59)											int size1 = (b17->length * 4);
HXDLIN(  59)											b17->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  59)											{
HXLINE(  59)												int _g26 = 0;
HXDLIN(  59)												int _g27 = b17->length;
HXDLIN(  59)												while((_g26 < _g27)){
HXLINE(  59)													_g26 = (_g26 + 1);
HXDLIN(  59)													int i15 = (_g26 - 1);
HXDLIN(  59)													{
HXLINE(  59)														 ::haxe::io::ArrayBufferViewImpl this84 = b17->data;
HXDLIN(  59)														bool undoImage5;
HXDLIN(  59)														if ((i15 >= 0)) {
HXLINE(  59)															undoImage5 = (i15 < (this84->byteLength >> 2));
            														}
            														else {
HXLINE(  59)															undoImage5 = false;
            														}
HXDLIN(  59)														if (undoImage5) {
HXLINE(  59)															 ::haxe::io::Bytes _this1 = this84->bytes;
HXDLIN(  59)															int pos1 = ((i15 << 2) + this84->byteOffset);
HXDLIN(  59)															_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  59)															_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  59)															_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  59)															_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN(  59)										undoImage4 = b17;
            									}
            									break;
            									case (int)3: {
HXLINE(  59)										 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  59)										 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN(  59)										{
HXLINE(  59)											v3->width = width1;
HXDLIN(  59)											v3->height = height1;
HXDLIN(  59)											v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  59)											v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN(  59)											{
HXLINE(  59)												int _g28 = 0;
HXDLIN(  59)												int _g29 = v3->length;
HXDLIN(  59)												while((_g28 < _g29)){
HXLINE(  59)													_g28 = (_g28 + 1);
HXDLIN(  59)													int i16 = (_g28 - 1);
HXDLIN(  59)													v3->data->__unsafe_set(i16,0);
            												}
            											}
            										}
HXDLIN(  59)										undoImage4 = v3;
            									}
            									break;
            									case (int)4: {
HXLINE(  59)										 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  59)										 ::iterMagic::StackIntImg b18 = sInt1;
HXDLIN(  59)										{
HXLINE(  59)											b18->width = width1;
HXDLIN(  59)											b18->height = height1;
HXDLIN(  59)											b18->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  59)											b18->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  59)											{
HXLINE(  59)												int len3 = b18->length;
HXDLIN(  59)												 ::haxe::ds::GenericStack_Int d1 = b18->data;
HXDLIN(  59)												if (::hx::IsNull( d1->head )) {
HXLINE(  59)													int _g30 = 0;
HXDLIN(  59)													int _g31 = len3;
HXDLIN(  59)													while((_g30 < _g31)){
HXLINE(  59)														_g30 = (_g30 + 1);
HXDLIN(  59)														int i17 = (_g30 - 1);
HXDLIN(  59)														d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            													}
            												}
            												else {
HXLINE(  59)													int _g32 = 0;
HXDLIN(  59)													int _g33 = len3;
HXDLIN(  59)													while((_g32 < _g33)){
HXLINE(  59)														_g32 = (_g32 + 1);
HXDLIN(  59)														int i18 = (_g32 - 1);
HXDLIN(  59)														{
HXLINE(  59)															 ::haxe::ds::GenericCell_Int l1 = b18->data->head;
HXDLIN(  59)															 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  59)															{
HXLINE(  59)																int _g34 = 0;
HXDLIN(  59)																int _g35 = i18;
HXDLIN(  59)																while((_g34 < _g35)){
HXLINE(  59)																	_g34 = (_g34 + 1);
HXDLIN(  59)																	int i19 = (_g34 - 1);
HXLINE( 345)																	prev1 = l1;
HXLINE( 346)																	l1 = l1->next;
            																}
            															}
HXLINE(  59)															if (::hx::IsNull( prev1 )) {
HXLINE(  59)																b18->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  59)																l1 = null();
            															}
            															else {
HXLINE(  59)																prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  59)																l1 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  59)										undoImage4 = b18;
            									}
            									break;
            								}
HXDLIN(  59)								this83->image = undoImage4;
HXDLIN(  59)								this83->width = width1;
HXDLIN(  59)								this83->height = height1;
HXDLIN(  59)								this83->imageType = ( (int)(imageType1) );
HXDLIN(  59)								undoImage3 = this83;
HXDLIN(  59)								{
HXLINE(  59)									int rectLeft1 = xIter31->start;
HXDLIN(  59)									int rectTop1 = yIter31->start;
HXDLIN(  59)									int rectRight1 = xIter31->max;
HXDLIN(  59)									bool forceClear1 = false;
HXDLIN(  59)									{
HXLINE(  59)										int _g36 = rectTop1;
HXDLIN(  59)										int _g37 = yIter31->max;
HXDLIN(  59)										while((_g36 < _g37)){
HXLINE(  59)											_g36 = (_g36 + 1);
HXDLIN(  59)											int dy2 = (_g36 - 1);
HXDLIN(  59)											{
HXLINE(  59)												int _g38 = rectLeft1;
HXDLIN(  59)												int _g39 = rectRight1;
HXDLIN(  59)												while((_g38 < _g39)){
HXLINE(  59)													_g38 = (_g38 + 1);
HXDLIN(  59)													int dx2 = (_g38 - 1);
HXDLIN(  59)													::Dynamic this85 = this1->image;
HXDLIN(  59)													int index9;
HXDLIN(  59)													if (this1->useVirtualPos) {
HXLINE(  59)														index9 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx2) - this1->virtualX));
            													}
            													else {
HXLINE(  59)														index9 = ::Std_obj::_hx_int(( (Float)(((dy2 * this1->width) + dx2)) ));
            													}
HXDLIN(  59)													int c8 = ::iterMagic::Iimg_obj::get(this85,index9);
HXDLIN(  59)													int col1;
HXDLIN(  59)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)														col1 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            													}
            													else {
HXLINE(  59)														col1 = c8;
            													}
HXDLIN(  59)													bool _hx_tmp20;
HXDLIN(  59)													if (this1->useMask) {
HXLINE(  59)														_hx_tmp20 = ::hx::IsNotNull( this1->mask );
            													}
            													else {
HXLINE(  59)														_hx_tmp20 = false;
            													}
HXDLIN(  59)													if (_hx_tmp20) {
HXLINE(  59)														 ::pi_xy::ImageStruct this86 = this1->mask;
HXDLIN(  59)														::Dynamic this87 = this86->image;
HXDLIN(  59)														int index10;
HXDLIN(  59)														if (this86->useVirtualPos) {
HXLINE(  59)															index10 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this86->virtualY) * ( (Float)(this86->width) )) + dx2) - this86->virtualX));
            														}
            														else {
HXLINE(  59)															index10 = ::Std_obj::_hx_int(( (Float)(((dy2 * this86->width) + dx2)) ));
            														}
HXDLIN(  59)														int c9 = ::iterMagic::Iimg_obj::get(this87,index10);
HXDLIN(  59)														int v4;
HXDLIN(  59)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)															v4 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            														}
            														else {
HXLINE(  59)															v4 = c9;
            														}
HXDLIN(  59)														int maskPixel1 = v4;
HXDLIN(  59)														int this88 = col1;
HXDLIN(  59)														if ((maskPixel1 == 0)) {
HXLINE(  59)															col1 = this88;
            														}
            														else {
HXLINE(  59)															Float m01;
HXDLIN(  59)															int this89 = ((maskPixel1 >> 24) & 255);
HXDLIN(  59)															if ((this89 == 0)) {
HXLINE(  59)																m01 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																m01 = (( (Float)(this89) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float m11;
HXDLIN(  59)															int this90 = ((maskPixel1 >> 16) & 255);
HXDLIN(  59)															if ((this90 == 0)) {
HXLINE(  59)																m11 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																m11 = (( (Float)(this90) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float m21;
HXDLIN(  59)															int this91 = ((maskPixel1 >> 8) & 255);
HXDLIN(  59)															if ((this91 == 0)) {
HXLINE(  59)																m21 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																m21 = (( (Float)(this91) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float m31;
HXDLIN(  59)															int this92 = (maskPixel1 & 255);
HXDLIN(  59)															if ((this92 == 0)) {
HXLINE(  59)																m31 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																m31 = (( (Float)(this92) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this88 >> 24) & 255)) )));
HXDLIN(  59)															int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this88 >> 16) & 255)) )));
HXDLIN(  59)															int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this88 >> 8) & 255)) )));
HXDLIN(  59)															int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this88 & 255)) )));
HXDLIN(  59)															col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  59)													if ((col1 != 0)) {
HXLINE(  59)														int x9 = (dx2 - rectLeft1);
HXDLIN(  59)														int y9 = (dy2 - rectTop1);
HXDLIN(  59)														int c10 = col1;
HXDLIN(  59)														bool _hx_tmp21;
HXDLIN(  59)														if ((((c10 >> 24) & 255) < 254)) {
HXLINE(  59)															_hx_tmp21 = undoImage3->transparent;
            														}
            														else {
HXLINE(  59)															_hx_tmp21 = false;
            														}
HXDLIN(  59)														if (_hx_tmp21) {
HXLINE(  59)															int location6;
HXDLIN(  59)															if (undoImage3->useVirtualPos) {
HXLINE(  59)																location6 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x9) - undoImage3->virtualX));
            															}
            															else {
HXLINE(  59)																location6 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage3->width) + x9)) ));
            															}
HXDLIN(  59)															int this93 = ::iterMagic::Iimg_obj::get(undoImage3->image,location6);
HXDLIN(  59)															int this94;
HXDLIN(  59)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)																this94 = ((((((this93 >> 24) & 255) << 24) | ((this93 & 255) << 16)) | (((this93 >> 8) & 255) << 8)) | ((this93 >> 16) & 255));
            															}
            															else {
HXLINE(  59)																this94 = this93;
            															}
HXDLIN(  59)															Float a17;
HXDLIN(  59)															int this95 = ((this94 >> 24) & 255);
HXDLIN(  59)															if ((this95 == 0)) {
HXLINE(  59)																a17 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																a17 = (( (Float)(this95) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float r16;
HXDLIN(  59)															int this96 = ((this94 >> 16) & 255);
HXDLIN(  59)															if ((this96 == 0)) {
HXLINE(  59)																r16 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																r16 = (( (Float)(this96) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float g16;
HXDLIN(  59)															int this97 = ((this94 >> 8) & 255);
HXDLIN(  59)															if ((this97 == 0)) {
HXLINE(  59)																g16 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																g16 = (( (Float)(this97) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float b19;
HXDLIN(  59)															int this98 = (this94 & 255);
HXDLIN(  59)															if ((this98 == 0)) {
HXLINE(  59)																b19 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																b19 = (( (Float)(this98) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float a26;
HXDLIN(  59)															int this99 = ((col1 >> 24) & 255);
HXDLIN(  59)															if ((this99 == 0)) {
HXLINE(  59)																a26 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																a26 = (( (Float)(this99) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float r26;
HXDLIN(  59)															int this100 = ((col1 >> 16) & 255);
HXDLIN(  59)															if ((this100 == 0)) {
HXLINE(  59)																r26 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																r26 = (( (Float)(this100) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float g26;
HXDLIN(  59)															int this101 = ((col1 >> 8) & 255);
HXDLIN(  59)															if ((this101 == 0)) {
HXLINE(  59)																g26 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																g26 = (( (Float)(this101) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float b26;
HXDLIN(  59)															int this102 = (col1 & 255);
HXDLIN(  59)															if ((this102 == 0)) {
HXLINE(  59)																b26 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																b26 = (( (Float)(this102) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float a36 = (a17 * (( (Float)(1) ) - a26));
HXDLIN(  59)															int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN(  59)															int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN(  59)															int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b19 * a36) + (b26 * a26))));
HXDLIN(  59)															int a18 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN(  59)															int blended6 = ((((a18 << 24) | (r8 << 16)) | (g8 << 8)) | b20);
HXDLIN(  59)															{
HXLINE(  59)																int _hx_tmp22;
HXDLIN(  59)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)																	_hx_tmp22 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            																}
            																else {
HXLINE(  59)																	_hx_tmp22 = blended6;
            																}
HXDLIN(  59)																::iterMagic::Iimg_obj::set(undoImage3->image,location6,_hx_tmp22);
            															}
            														}
            														else {
HXLINE(  59)															::Dynamic this103 = undoImage3->image;
HXDLIN(  59)															int index11;
HXDLIN(  59)															if (undoImage3->useVirtualPos) {
HXLINE(  59)																index11 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x9) - undoImage3->virtualX));
            															}
            															else {
HXLINE(  59)																index11 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage3->width) + x9)) ));
            															}
HXDLIN(  59)															int _hx_tmp23;
HXDLIN(  59)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)																_hx_tmp23 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            															}
            															else {
HXLINE(  59)																_hx_tmp23 = c10;
            															}
HXDLIN(  59)															::iterMagic::Iimg_obj::set(this103,index11,_hx_tmp23);
            														}
            													}
            													else {
HXLINE(  59)														if (forceClear1) {
HXLINE(  59)															::Dynamic this104 = undoImage3->image;
HXDLIN(  59)															int x10 = (dx2 - rectLeft1);
HXDLIN(  59)															int y10 = (dy2 - rectTop1);
HXDLIN(  59)															int index12;
HXDLIN(  59)															if (undoImage3->useVirtualPos) {
HXLINE(  59)																index12 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x10) - undoImage3->virtualX));
            															}
            															else {
HXLINE(  59)																index12 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage3->width) + x10)) ));
            															}
HXDLIN(  59)															::iterMagic::Iimg_obj::set(this104,index12,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  59)							bool found1 = false;
HXDLIN(  59)							Float s1 = ((Float)0.);
HXDLIN(  59)							Float t1 = ((Float)0.);
HXDLIN(  59)							Float sxx1 = ((Float)0.);
HXDLIN(  59)							Float txx1 = ((Float)0.);
HXDLIN(  59)							{
HXLINE(  59)								int _g_min2 = xIter31->start;
HXDLIN(  59)								int _g_max2 = xIter31->max;
HXDLIN(  59)								while((_g_min2 < _g_max2)){
HXLINE(  59)									_g_min2 = (_g_min2 + 1);
HXDLIN(  59)									int x11 = (_g_min2 - 1);
HXLINE(  60)									sxx1 = (sx1 * ( (Float)(x11) ));
HXLINE(  61)									txx1 = (tx1 * ( (Float)(x11) ));
HXLINE(  62)									found1 = false;
HXLINE(  59)									{
HXLINE(  59)										int _g_min3 = yIter31->start;
HXDLIN(  59)										int _g_max3 = yIter31->max;
HXDLIN(  59)										while((_g_min3 < _g_max3)){
HXLINE(  59)											_g_min3 = (_g_min3 + 1);
HXDLIN(  59)											int y11 = (_g_min3 - 1);
HXLINE(  64)											s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y11) )));
HXLINE(  65)											t1 = ((t01 + txx1) + (ty1 * ( (Float)(y11) )));
HXLINE(  59)											bool _hx_tmp24;
HXDLIN(  59)											if (!((s1 <= 0))) {
HXLINE(  59)												_hx_tmp24 = (t1 <= 0);
            											}
            											else {
HXLINE(  59)												_hx_tmp24 = true;
            											}
HXDLIN(  59)											if (_hx_tmp24) {
HXLINE(  59)												if (found1) {
HXLINE(  59)													goto _hx_goto_169;
            												}
            											}
            											else {
HXLINE(  59)												if (((s1 + t1) < A1)) {
HXLINE(  59)													{
HXLINE(  59)														int c11 = color;
HXDLIN(  59)														bool _hx_tmp25;
HXDLIN(  59)														if ((((c11 >> 24) & 255) < 254)) {
HXLINE(  59)															_hx_tmp25 = this1->transparent;
            														}
            														else {
HXLINE(  59)															_hx_tmp25 = false;
            														}
HXDLIN(  59)														if (_hx_tmp25) {
HXLINE(  59)															int location7;
HXDLIN(  59)															if (this1->useVirtualPos) {
HXLINE(  59)																location7 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - this1->virtualY) * ( (Float)(this1->width) )) + x11) - this1->virtualX));
            															}
            															else {
HXLINE(  59)																location7 = ::Std_obj::_hx_int(( (Float)(((y11 * this1->width) + x11)) ));
            															}
HXDLIN(  59)															int this105 = ::iterMagic::Iimg_obj::get(this1->image,location7);
HXDLIN(  59)															int this106;
HXDLIN(  59)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)																this106 = ((((((this105 >> 24) & 255) << 24) | ((this105 & 255) << 16)) | (((this105 >> 8) & 255) << 8)) | ((this105 >> 16) & 255));
            															}
            															else {
HXLINE(  59)																this106 = this105;
            															}
HXDLIN(  59)															Float a19;
HXDLIN(  59)															int this107 = ((this106 >> 24) & 255);
HXDLIN(  59)															if ((this107 == 0)) {
HXLINE(  59)																a19 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																a19 = (( (Float)(this107) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float r17;
HXDLIN(  59)															int this108 = ((this106 >> 16) & 255);
HXDLIN(  59)															if ((this108 == 0)) {
HXLINE(  59)																r17 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																r17 = (( (Float)(this108) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float g17;
HXDLIN(  59)															int this109 = ((this106 >> 8) & 255);
HXDLIN(  59)															if ((this109 == 0)) {
HXLINE(  59)																g17 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																g17 = (( (Float)(this109) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float b110;
HXDLIN(  59)															int this110 = (this106 & 255);
HXDLIN(  59)															if ((this110 == 0)) {
HXLINE(  59)																b110 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																b110 = (( (Float)(this110) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float a27;
HXDLIN(  59)															int this111 = ((color >> 24) & 255);
HXDLIN(  59)															if ((this111 == 0)) {
HXLINE(  59)																a27 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																a27 = (( (Float)(this111) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float r27;
HXDLIN(  59)															int this112 = ((color >> 16) & 255);
HXDLIN(  59)															if ((this112 == 0)) {
HXLINE(  59)																r27 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																r27 = (( (Float)(this112) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float g27;
HXDLIN(  59)															int this113 = ((color >> 8) & 255);
HXDLIN(  59)															if ((this113 == 0)) {
HXLINE(  59)																g27 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																g27 = (( (Float)(this113) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float b27;
HXDLIN(  59)															int this114 = (color & 255);
HXDLIN(  59)															if ((this114 == 0)) {
HXLINE(  59)																b27 = ((Float)0.);
            															}
            															else {
HXLINE(  59)																b27 = (( (Float)(this114) ) / ( (Float)(255) ));
            															}
HXDLIN(  59)															Float a37 = (a19 * (( (Float)(1) ) - a27));
HXDLIN(  59)															int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN(  59)															int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN(  59)															int b28 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a37) + (b27 * a27))));
HXDLIN(  59)															int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN(  59)															int blended7 = ((((a20 << 24) | (r9 << 16)) | (g9 << 8)) | b28);
HXDLIN(  59)															{
HXLINE(  59)																int _hx_tmp26;
HXDLIN(  59)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)																	_hx_tmp26 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            																}
            																else {
HXLINE(  59)																	_hx_tmp26 = blended7;
            																}
HXDLIN(  59)																::iterMagic::Iimg_obj::set(this1->image,location7,_hx_tmp26);
            															}
            														}
            														else {
HXLINE(  59)															::Dynamic this115 = this1->image;
HXDLIN(  59)															int index13;
HXDLIN(  59)															if (this1->useVirtualPos) {
HXLINE(  59)																index13 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - this1->virtualY) * ( (Float)(this1->width) )) + x11) - this1->virtualX));
            															}
            															else {
HXLINE(  59)																index13 = ::Std_obj::_hx_int(( (Float)(((y11 * this1->width) + x11)) ));
            															}
HXDLIN(  59)															int _hx_tmp27;
HXDLIN(  59)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  59)																_hx_tmp27 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            															}
            															else {
HXLINE(  59)																_hx_tmp27 = c11;
            															}
HXDLIN(  59)															::iterMagic::Iimg_obj::set(this115,index13,_hx_tmp27);
            														}
            													}
HXLINE(  73)													found1 = true;
            												}
            												else {
HXLINE(  59)													if (found1) {
HXLINE(  59)														goto _hx_goto_169;
            													}
            												}
            											}
            										}
            										_hx_goto_169:;
            									}
            								}
            							}
HXDLIN(  59)							if ((hasHit == true)) {
HXLINE(  59)								 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx1,by1,bx3,by3,cx3,cy3,true);
HXDLIN(  59)								if (hasUndo1) {
HXLINE(  59)									v5->undoImage = undoImage3;
HXDLIN(  59)									v5->undoX = xIter31->start;
HXDLIN(  59)									v5->undoY = yIter31->start;
            								}
            							}
            						}
            					}
HXDLIN(  59)					if ((hasHit == true)) {
HXLINE(  59)						 ::pi_xy::algo::HitQuad v6 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax1,ay1,bx1,by1,cx1,cy1,dx,dy,true);
            					}
            				}
            			}
            		}
HXLINE(  60)		{
HXLINE(  60)			 ::pi_xy::ImageStruct this116 = temp;
HXDLIN(  60)			Float px1 = this->rx;
HXDLIN(  60)			Float py1 = this->ry;
HXDLIN(  60)			int color1 = this->strokeColor;
HXDLIN(  60)			bool hasHit1 = true;
HXDLIN(  60)			Float o1 = (cy - py1);
HXDLIN(  60)			Float a28 = (cx - px1);
HXDLIN(  60)			Float h1 = ::Math_obj::pow(((o1 * o1) + (a28 * a28)),((Float)0.5));
HXDLIN(  60)			Float theta1 = ::Math_obj::atan2(o1,a28);
HXDLIN(  60)			{
HXLINE(  60)				 ::Dynamic debugCorners1 = false;
HXDLIN(  60)				if (::hx::IsNull( debugCorners1 )) {
HXLINE(  75)					debugCorners1 = false;
            				}
HXLINE(  60)				Float sin1 = ::Math_obj::sin(theta1);
HXDLIN(  60)				Float cos1 = ::Math_obj::cos(theta1);
HXDLIN(  60)				Float radius1 = (this->strokeWidth / ( (Float)(2) ));
HXDLIN(  60)				Float dx3 = ((Float)0.1);
HXDLIN(  60)				Float dy3 = radius1;
HXDLIN(  60)				Float cx4 = h1;
HXDLIN(  60)				Float cy4 = radius1;
HXDLIN(  60)				Float bx4 = h1;
HXDLIN(  60)				Float by4 = -(radius1);
HXDLIN(  60)				Float ax2 = ((Float)0.1);
HXDLIN(  60)				Float ay2 = -(radius1);
HXDLIN(  60)				Float temp2 = ((Float)0.);
HXLINE(  28)				temp2 = (px1 + ((ax2 * cos1) - (ay2 * sin1)));
HXLINE(  29)				ay2 = (py1 + ((ay2 * cos1) + (ax2 * sin1)));
HXLINE(  30)				ax2 = temp2;
HXLINE(  32)				temp2 = (px1 + ((bx4 * cos1) - (by4 * sin1)));
HXLINE(  33)				by4 = (py1 + ((by4 * cos1) + (bx4 * sin1)));
HXLINE(  34)				bx4 = temp2;
HXLINE(  36)				temp2 = (px1 + ((cx4 * cos1) - (cy4 * sin1)));
HXLINE(  37)				cy4 = (py1 + ((cy4 * cos1) + (cx4 * sin1)));
HXLINE(  38)				cx4 = temp2;
HXLINE(  40)				temp2 = (px1 + ((dx3 * cos1) - (dy3 * sin1)));
HXLINE(  41)				dy3 = (py1 + ((dy3 * cos1) + (dx3 * sin1)));
HXLINE(  42)				dx3 = temp2;
HXLINE(  60)				if (( (bool)(debugCorners1) )) {
HXLINE(  60)					{
HXLINE(  60)						 ::pi_xy::ImageStruct this117 = this116;
HXDLIN(  60)						{
HXLINE(  60)							int r_x4 = ::Std_obj::_hx_int((ax2 - ((Float)6.)));
HXDLIN(  60)							int r_y4 = ::Std_obj::_hx_int((ay2 - ((Float)6.)));
HXDLIN(  60)							int r_w4 = 12;
HXDLIN(  60)							int r_h4 = 12;
HXDLIN(  60)							int xmax4 = ((r_x4 + r_w4) + 1);
HXDLIN(  60)							int ymax4 = ((r_y4 + r_h4) + 1);
HXDLIN(  60)							int ii_min24 = r_x4;
HXDLIN(  60)							int ii_max24 = xmax4;
HXDLIN(  60)							int xRange__start4 = ii_min24;
HXDLIN(  60)							int xRange__max4 = ii_max24;
HXDLIN(  60)							int ii_min25 = r_y4;
HXDLIN(  60)							int ii_max25 = ymax4;
HXDLIN(  60)							int yRange__start4 = ii_min25;
HXDLIN(  60)							int yRange__max4 = ii_max25;
HXDLIN(  60)							int range_x4 = xRange__start4;
HXDLIN(  60)							int range_y4 = (yRange__start4 - 1);
HXDLIN(  60)							int range_xReset4 = range_x4;
HXDLIN(  60)							int range_yReset4 = range_y4;
HXDLIN(  60)							int range_xMax4 = (xRange__max4 - 2);
HXDLIN(  60)							int range_yMax4 = (yRange__max4 - 2);
HXDLIN(  60)							int _this_min4 = 0;
HXDLIN(  60)							int _this_max4 = ::Std_obj::_hx_int(( (Float)(((xRange__max4 - xRange__start4) * (yRange__max4 - yRange__start4))) ));
HXDLIN(  60)							while((_this_min4 < _this_max4)){
HXLINE(  60)								_this_min4 = (_this_min4 + 1);
HXDLIN(  60)								int i20 = (_this_min4 - 1);
HXDLIN(  60)								if ((range_y4 > range_yMax4)) {
HXLINE(  60)									range_y4 = range_yReset4;
HXDLIN(  60)									range_x4 = (range_x4 + 1);
            								}
HXDLIN(  60)								range_y4 = (range_y4 + 1);
HXDLIN(  60)								int i21 = i20;
HXDLIN(  60)								{
HXLINE(  60)									int x12 = range_x4;
HXDLIN(  60)									int y12 = range_y4;
HXDLIN(  60)									int c12 = -65536;
HXDLIN(  60)									bool _hx_tmp28;
HXDLIN(  60)									if ((((c12 >> 24) & 255) < 254)) {
HXLINE(  60)										_hx_tmp28 = this117->transparent;
            									}
            									else {
HXLINE(  60)										_hx_tmp28 = false;
            									}
HXDLIN(  60)									if (_hx_tmp28) {
HXLINE(  60)										int location8;
HXDLIN(  60)										if (this117->useVirtualPos) {
HXLINE(  60)											location8 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - this117->virtualY) * ( (Float)(this117->width) )) + x12) - this117->virtualX));
            										}
            										else {
HXLINE(  60)											location8 = ::Std_obj::_hx_int(( (Float)(((y12 * this117->width) + x12)) ));
            										}
HXDLIN(  60)										int this118 = ::iterMagic::Iimg_obj::get(this117->image,location8);
HXDLIN(  60)										int this119;
HXDLIN(  60)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)											this119 = ((((((this118 >> 24) & 255) << 24) | ((this118 & 255) << 16)) | (((this118 >> 8) & 255) << 8)) | ((this118 >> 16) & 255));
            										}
            										else {
HXLINE(  60)											this119 = this118;
            										}
HXDLIN(  60)										Float a110;
HXDLIN(  60)										int this120 = ((this119 >> 24) & 255);
HXDLIN(  60)										if ((this120 == 0)) {
HXLINE(  60)											a110 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											a110 = (( (Float)(this120) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float r18;
HXDLIN(  60)										int this121 = ((this119 >> 16) & 255);
HXDLIN(  60)										if ((this121 == 0)) {
HXLINE(  60)											r18 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											r18 = (( (Float)(this121) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float g18;
HXDLIN(  60)										int this122 = ((this119 >> 8) & 255);
HXDLIN(  60)										if ((this122 == 0)) {
HXLINE(  60)											g18 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											g18 = (( (Float)(this122) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float b111;
HXDLIN(  60)										int this123 = (this119 & 255);
HXDLIN(  60)										if ((this123 == 0)) {
HXLINE(  60)											b111 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											b111 = (( (Float)(this123) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float a29;
HXDLIN(  60)										int this124 = ((-65536 >> 24) & 255);
HXDLIN(  60)										if ((this124 == 0)) {
HXLINE(  60)											a29 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											a29 = (( (Float)(this124) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float r28;
HXDLIN(  60)										int this125 = ((-65536 >> 16) & 255);
HXDLIN(  60)										if ((this125 == 0)) {
HXLINE(  60)											r28 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											r28 = (( (Float)(this125) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float g28;
HXDLIN(  60)										int this126 = ((-65536 >> 8) & 255);
HXDLIN(  60)										if ((this126 == 0)) {
HXLINE(  60)											g28 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											g28 = (( (Float)(this126) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float b29;
HXDLIN(  60)										int this127 = (-65536 & 255);
HXDLIN(  60)										if ((this127 == 0)) {
HXLINE(  60)											b29 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											b29 = (( (Float)(this127) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float a38 = (a110 * (( (Float)(1) ) - a29));
HXDLIN(  60)										int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a38) + (r28 * a29))));
HXDLIN(  60)										int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a38) + (g28 * a29))));
HXDLIN(  60)										int b30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a38) + (b29 * a29))));
HXDLIN(  60)										int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a29)));
HXDLIN(  60)										int blended8 = ((((a30 << 24) | (r10 << 16)) | (g10 << 8)) | b30);
HXDLIN(  60)										{
HXLINE(  60)											int _hx_tmp29;
HXDLIN(  60)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)												_hx_tmp29 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            											}
            											else {
HXLINE(  60)												_hx_tmp29 = blended8;
            											}
HXDLIN(  60)											::iterMagic::Iimg_obj::set(this117->image,location8,_hx_tmp29);
            										}
            									}
            									else {
HXLINE(  60)										::Dynamic this128 = this117->image;
HXDLIN(  60)										int index14;
HXDLIN(  60)										if (this117->useVirtualPos) {
HXLINE(  60)											index14 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - this117->virtualY) * ( (Float)(this117->width) )) + x12) - this117->virtualX));
            										}
            										else {
HXLINE(  60)											index14 = ::Std_obj::_hx_int(( (Float)(((y12 * this117->width) + x12)) ));
            										}
HXDLIN(  60)										int _hx_tmp30;
HXDLIN(  60)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)											_hx_tmp30 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            										}
            										else {
HXLINE(  60)											_hx_tmp30 = c12;
            										}
HXDLIN(  60)										::iterMagic::Iimg_obj::set(this128,index14,_hx_tmp30);
            									}
            								}
            							}
            						}
            					}
HXDLIN(  60)					{
HXLINE(  60)						 ::pi_xy::ImageStruct this129 = this116;
HXDLIN(  60)						{
HXLINE(  60)							int r_x5 = ::Std_obj::_hx_int((bx4 - ((Float)6.)));
HXDLIN(  60)							int r_y5 = ::Std_obj::_hx_int((by4 - ((Float)6.)));
HXDLIN(  60)							int r_w5 = 12;
HXDLIN(  60)							int r_h5 = 12;
HXDLIN(  60)							int xmax5 = ((r_x5 + r_w5) + 1);
HXDLIN(  60)							int ymax5 = ((r_y5 + r_h5) + 1);
HXDLIN(  60)							int ii_min26 = r_x5;
HXDLIN(  60)							int ii_max26 = xmax5;
HXDLIN(  60)							int xRange__start5 = ii_min26;
HXDLIN(  60)							int xRange__max5 = ii_max26;
HXDLIN(  60)							int ii_min27 = r_y5;
HXDLIN(  60)							int ii_max27 = ymax5;
HXDLIN(  60)							int yRange__start5 = ii_min27;
HXDLIN(  60)							int yRange__max5 = ii_max27;
HXDLIN(  60)							int range_x5 = xRange__start5;
HXDLIN(  60)							int range_y5 = (yRange__start5 - 1);
HXDLIN(  60)							int range_xReset5 = range_x5;
HXDLIN(  60)							int range_yReset5 = range_y5;
HXDLIN(  60)							int range_xMax5 = (xRange__max5 - 2);
HXDLIN(  60)							int range_yMax5 = (yRange__max5 - 2);
HXDLIN(  60)							int _this_min5 = 0;
HXDLIN(  60)							int _this_max5 = ::Std_obj::_hx_int(( (Float)(((xRange__max5 - xRange__start5) * (yRange__max5 - yRange__start5))) ));
HXDLIN(  60)							while((_this_min5 < _this_max5)){
HXLINE(  60)								_this_min5 = (_this_min5 + 1);
HXDLIN(  60)								int i22 = (_this_min5 - 1);
HXDLIN(  60)								if ((range_y5 > range_yMax5)) {
HXLINE(  60)									range_y5 = range_yReset5;
HXDLIN(  60)									range_x5 = (range_x5 + 1);
            								}
HXDLIN(  60)								range_y5 = (range_y5 + 1);
HXDLIN(  60)								int i23 = i22;
HXDLIN(  60)								{
HXLINE(  60)									int x13 = range_x5;
HXDLIN(  60)									int y13 = range_y5;
HXDLIN(  60)									int c13 = -16711936;
HXDLIN(  60)									bool _hx_tmp31;
HXDLIN(  60)									if ((((c13 >> 24) & 255) < 254)) {
HXLINE(  60)										_hx_tmp31 = this129->transparent;
            									}
            									else {
HXLINE(  60)										_hx_tmp31 = false;
            									}
HXDLIN(  60)									if (_hx_tmp31) {
HXLINE(  60)										int location9;
HXDLIN(  60)										if (this129->useVirtualPos) {
HXLINE(  60)											location9 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - this129->virtualY) * ( (Float)(this129->width) )) + x13) - this129->virtualX));
            										}
            										else {
HXLINE(  60)											location9 = ::Std_obj::_hx_int(( (Float)(((y13 * this129->width) + x13)) ));
            										}
HXDLIN(  60)										int this130 = ::iterMagic::Iimg_obj::get(this129->image,location9);
HXDLIN(  60)										int this131;
HXDLIN(  60)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)											this131 = ((((((this130 >> 24) & 255) << 24) | ((this130 & 255) << 16)) | (((this130 >> 8) & 255) << 8)) | ((this130 >> 16) & 255));
            										}
            										else {
HXLINE(  60)											this131 = this130;
            										}
HXDLIN(  60)										Float a111;
HXDLIN(  60)										int this132 = ((this131 >> 24) & 255);
HXDLIN(  60)										if ((this132 == 0)) {
HXLINE(  60)											a111 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											a111 = (( (Float)(this132) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float r19;
HXDLIN(  60)										int this133 = ((this131 >> 16) & 255);
HXDLIN(  60)										if ((this133 == 0)) {
HXLINE(  60)											r19 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											r19 = (( (Float)(this133) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float g19;
HXDLIN(  60)										int this134 = ((this131 >> 8) & 255);
HXDLIN(  60)										if ((this134 == 0)) {
HXLINE(  60)											g19 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											g19 = (( (Float)(this134) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float b112;
HXDLIN(  60)										int this135 = (this131 & 255);
HXDLIN(  60)										if ((this135 == 0)) {
HXLINE(  60)											b112 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											b112 = (( (Float)(this135) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float a210;
HXDLIN(  60)										int this136 = ((-16711936 >> 24) & 255);
HXDLIN(  60)										if ((this136 == 0)) {
HXLINE(  60)											a210 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											a210 = (( (Float)(this136) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float r29;
HXDLIN(  60)										int this137 = ((-16711936 >> 16) & 255);
HXDLIN(  60)										if ((this137 == 0)) {
HXLINE(  60)											r29 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											r29 = (( (Float)(this137) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float g29;
HXDLIN(  60)										int this138 = ((-16711936 >> 8) & 255);
HXDLIN(  60)										if ((this138 == 0)) {
HXLINE(  60)											g29 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											g29 = (( (Float)(this138) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float b210;
HXDLIN(  60)										int this139 = (-16711936 & 255);
HXDLIN(  60)										if ((this139 == 0)) {
HXLINE(  60)											b210 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											b210 = (( (Float)(this139) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float a39 = (a111 * (( (Float)(1) ) - a210));
HXDLIN(  60)										int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a39) + (r29 * a210))));
HXDLIN(  60)										int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a39) + (g29 * a210))));
HXDLIN(  60)										int b31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a39) + (b210 * a210))));
HXDLIN(  60)										int a40 = ::Std_obj::_hx_int((( (Float)(255) ) * (a39 + a210)));
HXDLIN(  60)										int blended9 = ((((a40 << 24) | (r20 << 16)) | (g20 << 8)) | b31);
HXDLIN(  60)										{
HXLINE(  60)											int _hx_tmp32;
HXDLIN(  60)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)												_hx_tmp32 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            											}
            											else {
HXLINE(  60)												_hx_tmp32 = blended9;
            											}
HXDLIN(  60)											::iterMagic::Iimg_obj::set(this129->image,location9,_hx_tmp32);
            										}
            									}
            									else {
HXLINE(  60)										::Dynamic this140 = this129->image;
HXDLIN(  60)										int index15;
HXDLIN(  60)										if (this129->useVirtualPos) {
HXLINE(  60)											index15 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - this129->virtualY) * ( (Float)(this129->width) )) + x13) - this129->virtualX));
            										}
            										else {
HXLINE(  60)											index15 = ::Std_obj::_hx_int(( (Float)(((y13 * this129->width) + x13)) ));
            										}
HXDLIN(  60)										int _hx_tmp33;
HXDLIN(  60)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)											_hx_tmp33 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            										}
            										else {
HXLINE(  60)											_hx_tmp33 = c13;
            										}
HXDLIN(  60)										::iterMagic::Iimg_obj::set(this140,index15,_hx_tmp33);
            									}
            								}
            							}
            						}
            					}
HXDLIN(  60)					{
HXLINE(  60)						 ::pi_xy::ImageStruct this141 = this116;
HXDLIN(  60)						{
HXLINE(  60)							int r_x6 = ::Std_obj::_hx_int((cx4 - ((Float)6.)));
HXDLIN(  60)							int r_y6 = ::Std_obj::_hx_int((cy4 - ((Float)6.)));
HXDLIN(  60)							int r_w6 = 12;
HXDLIN(  60)							int r_h6 = 12;
HXDLIN(  60)							int xmax6 = ((r_x6 + r_w6) + 1);
HXDLIN(  60)							int ymax6 = ((r_y6 + r_h6) + 1);
HXDLIN(  60)							int ii_min28 = r_x6;
HXDLIN(  60)							int ii_max28 = xmax6;
HXDLIN(  60)							int xRange__start6 = ii_min28;
HXDLIN(  60)							int xRange__max6 = ii_max28;
HXDLIN(  60)							int ii_min29 = r_y6;
HXDLIN(  60)							int ii_max29 = ymax6;
HXDLIN(  60)							int yRange__start6 = ii_min29;
HXDLIN(  60)							int yRange__max6 = ii_max29;
HXDLIN(  60)							int range_x6 = xRange__start6;
HXDLIN(  60)							int range_y6 = (yRange__start6 - 1);
HXDLIN(  60)							int range_xReset6 = range_x6;
HXDLIN(  60)							int range_yReset6 = range_y6;
HXDLIN(  60)							int range_xMax6 = (xRange__max6 - 2);
HXDLIN(  60)							int range_yMax6 = (yRange__max6 - 2);
HXDLIN(  60)							int _this_min6 = 0;
HXDLIN(  60)							int _this_max6 = ::Std_obj::_hx_int(( (Float)(((xRange__max6 - xRange__start6) * (yRange__max6 - yRange__start6))) ));
HXDLIN(  60)							while((_this_min6 < _this_max6)){
HXLINE(  60)								_this_min6 = (_this_min6 + 1);
HXDLIN(  60)								int i24 = (_this_min6 - 1);
HXDLIN(  60)								if ((range_y6 > range_yMax6)) {
HXLINE(  60)									range_y6 = range_yReset6;
HXDLIN(  60)									range_x6 = (range_x6 + 1);
            								}
HXDLIN(  60)								range_y6 = (range_y6 + 1);
HXDLIN(  60)								int i25 = i24;
HXDLIN(  60)								{
HXLINE(  60)									int x14 = range_x6;
HXDLIN(  60)									int y14 = range_y6;
HXDLIN(  60)									int c14 = -16776961;
HXDLIN(  60)									bool _hx_tmp34;
HXDLIN(  60)									if ((((c14 >> 24) & 255) < 254)) {
HXLINE(  60)										_hx_tmp34 = this141->transparent;
            									}
            									else {
HXLINE(  60)										_hx_tmp34 = false;
            									}
HXDLIN(  60)									if (_hx_tmp34) {
HXLINE(  60)										int location10;
HXDLIN(  60)										if (this141->useVirtualPos) {
HXLINE(  60)											location10 = ::Std_obj::_hx_int(((((( (Float)(y14) ) - this141->virtualY) * ( (Float)(this141->width) )) + x14) - this141->virtualX));
            										}
            										else {
HXLINE(  60)											location10 = ::Std_obj::_hx_int(( (Float)(((y14 * this141->width) + x14)) ));
            										}
HXDLIN(  60)										int this142 = ::iterMagic::Iimg_obj::get(this141->image,location10);
HXDLIN(  60)										int this143;
HXDLIN(  60)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)											this143 = ((((((this142 >> 24) & 255) << 24) | ((this142 & 255) << 16)) | (((this142 >> 8) & 255) << 8)) | ((this142 >> 16) & 255));
            										}
            										else {
HXLINE(  60)											this143 = this142;
            										}
HXDLIN(  60)										Float a112;
HXDLIN(  60)										int this144 = ((this143 >> 24) & 255);
HXDLIN(  60)										if ((this144 == 0)) {
HXLINE(  60)											a112 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											a112 = (( (Float)(this144) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float r110;
HXDLIN(  60)										int this145 = ((this143 >> 16) & 255);
HXDLIN(  60)										if ((this145 == 0)) {
HXLINE(  60)											r110 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											r110 = (( (Float)(this145) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float g110;
HXDLIN(  60)										int this146 = ((this143 >> 8) & 255);
HXDLIN(  60)										if ((this146 == 0)) {
HXLINE(  60)											g110 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											g110 = (( (Float)(this146) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float b113;
HXDLIN(  60)										int this147 = (this143 & 255);
HXDLIN(  60)										if ((this147 == 0)) {
HXLINE(  60)											b113 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											b113 = (( (Float)(this147) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float a211;
HXDLIN(  60)										int this148 = ((-16776961 >> 24) & 255);
HXDLIN(  60)										if ((this148 == 0)) {
HXLINE(  60)											a211 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											a211 = (( (Float)(this148) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float r210;
HXDLIN(  60)										int this149 = ((-16776961 >> 16) & 255);
HXDLIN(  60)										if ((this149 == 0)) {
HXLINE(  60)											r210 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											r210 = (( (Float)(this149) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float g210;
HXDLIN(  60)										int this150 = ((-16776961 >> 8) & 255);
HXDLIN(  60)										if ((this150 == 0)) {
HXLINE(  60)											g210 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											g210 = (( (Float)(this150) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float b211;
HXDLIN(  60)										int this151 = (-16776961 & 255);
HXDLIN(  60)										if ((this151 == 0)) {
HXLINE(  60)											b211 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											b211 = (( (Float)(this151) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float a310 = (a112 * (( (Float)(1) ) - a211));
HXDLIN(  60)										int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a310) + (r210 * a211))));
HXDLIN(  60)										int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a310) + (g210 * a211))));
HXDLIN(  60)										int b32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a310) + (b211 * a211))));
HXDLIN(  60)										int a41 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a211)));
HXDLIN(  60)										int blended10 = ((((a41 << 24) | (r30 << 16)) | (g30 << 8)) | b32);
HXDLIN(  60)										{
HXLINE(  60)											int _hx_tmp35;
HXDLIN(  60)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)												_hx_tmp35 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            											}
            											else {
HXLINE(  60)												_hx_tmp35 = blended10;
            											}
HXDLIN(  60)											::iterMagic::Iimg_obj::set(this141->image,location10,_hx_tmp35);
            										}
            									}
            									else {
HXLINE(  60)										::Dynamic this152 = this141->image;
HXDLIN(  60)										int index16;
HXDLIN(  60)										if (this141->useVirtualPos) {
HXLINE(  60)											index16 = ::Std_obj::_hx_int(((((( (Float)(y14) ) - this141->virtualY) * ( (Float)(this141->width) )) + x14) - this141->virtualX));
            										}
            										else {
HXLINE(  60)											index16 = ::Std_obj::_hx_int(( (Float)(((y14 * this141->width) + x14)) ));
            										}
HXDLIN(  60)										int _hx_tmp36;
HXDLIN(  60)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)											_hx_tmp36 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            										}
            										else {
HXLINE(  60)											_hx_tmp36 = c14;
            										}
HXDLIN(  60)										::iterMagic::Iimg_obj::set(this152,index16,_hx_tmp36);
            									}
            								}
            							}
            						}
            					}
HXDLIN(  60)					{
HXLINE(  60)						 ::pi_xy::ImageStruct this153 = this116;
HXDLIN(  60)						{
HXLINE(  60)							int r_x7 = ::Std_obj::_hx_int((dx3 - ((Float)6.)));
HXDLIN(  60)							int r_y7 = ::Std_obj::_hx_int((dy3 - ((Float)6.)));
HXDLIN(  60)							int r_w7 = 12;
HXDLIN(  60)							int r_h7 = 12;
HXDLIN(  60)							int xmax7 = ((r_x7 + r_w7) + 1);
HXDLIN(  60)							int ymax7 = ((r_y7 + r_h7) + 1);
HXDLIN(  60)							int ii_min30 = r_x7;
HXDLIN(  60)							int ii_max30 = xmax7;
HXDLIN(  60)							int xRange__start7 = ii_min30;
HXDLIN(  60)							int xRange__max7 = ii_max30;
HXDLIN(  60)							int ii_min31 = r_y7;
HXDLIN(  60)							int ii_max31 = ymax7;
HXDLIN(  60)							int yRange__start7 = ii_min31;
HXDLIN(  60)							int yRange__max7 = ii_max31;
HXDLIN(  60)							int range_x7 = xRange__start7;
HXDLIN(  60)							int range_y7 = (yRange__start7 - 1);
HXDLIN(  60)							int range_xReset7 = range_x7;
HXDLIN(  60)							int range_yReset7 = range_y7;
HXDLIN(  60)							int range_xMax7 = (xRange__max7 - 2);
HXDLIN(  60)							int range_yMax7 = (yRange__max7 - 2);
HXDLIN(  60)							int _this_min7 = 0;
HXDLIN(  60)							int _this_max7 = ::Std_obj::_hx_int(( (Float)(((xRange__max7 - xRange__start7) * (yRange__max7 - yRange__start7))) ));
HXDLIN(  60)							while((_this_min7 < _this_max7)){
HXLINE(  60)								_this_min7 = (_this_min7 + 1);
HXDLIN(  60)								int i26 = (_this_min7 - 1);
HXDLIN(  60)								if ((range_y7 > range_yMax7)) {
HXLINE(  60)									range_y7 = range_yReset7;
HXDLIN(  60)									range_x7 = (range_x7 + 1);
            								}
HXDLIN(  60)								range_y7 = (range_y7 + 1);
HXDLIN(  60)								int i27 = i26;
HXDLIN(  60)								{
HXLINE(  60)									int x15 = range_x7;
HXDLIN(  60)									int y15 = range_y7;
HXDLIN(  60)									int c15 = -1048336;
HXDLIN(  60)									bool _hx_tmp37;
HXDLIN(  60)									if ((((c15 >> 24) & 255) < 254)) {
HXLINE(  60)										_hx_tmp37 = this153->transparent;
            									}
            									else {
HXLINE(  60)										_hx_tmp37 = false;
            									}
HXDLIN(  60)									if (_hx_tmp37) {
HXLINE(  60)										int location11;
HXDLIN(  60)										if (this153->useVirtualPos) {
HXLINE(  60)											location11 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - this153->virtualY) * ( (Float)(this153->width) )) + x15) - this153->virtualX));
            										}
            										else {
HXLINE(  60)											location11 = ::Std_obj::_hx_int(( (Float)(((y15 * this153->width) + x15)) ));
            										}
HXDLIN(  60)										int this154 = ::iterMagic::Iimg_obj::get(this153->image,location11);
HXDLIN(  60)										int this155;
HXDLIN(  60)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)											this155 = ((((((this154 >> 24) & 255) << 24) | ((this154 & 255) << 16)) | (((this154 >> 8) & 255) << 8)) | ((this154 >> 16) & 255));
            										}
            										else {
HXLINE(  60)											this155 = this154;
            										}
HXDLIN(  60)										Float a113;
HXDLIN(  60)										int this156 = ((this155 >> 24) & 255);
HXDLIN(  60)										if ((this156 == 0)) {
HXLINE(  60)											a113 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											a113 = (( (Float)(this156) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float r111;
HXDLIN(  60)										int this157 = ((this155 >> 16) & 255);
HXDLIN(  60)										if ((this157 == 0)) {
HXLINE(  60)											r111 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											r111 = (( (Float)(this157) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float g111;
HXDLIN(  60)										int this158 = ((this155 >> 8) & 255);
HXDLIN(  60)										if ((this158 == 0)) {
HXLINE(  60)											g111 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											g111 = (( (Float)(this158) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float b114;
HXDLIN(  60)										int this159 = (this155 & 255);
HXDLIN(  60)										if ((this159 == 0)) {
HXLINE(  60)											b114 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											b114 = (( (Float)(this159) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float a212;
HXDLIN(  60)										int this160 = ((-1048336 >> 24) & 255);
HXDLIN(  60)										if ((this160 == 0)) {
HXLINE(  60)											a212 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											a212 = (( (Float)(this160) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float r211;
HXDLIN(  60)										int this161 = ((-1048336 >> 16) & 255);
HXDLIN(  60)										if ((this161 == 0)) {
HXLINE(  60)											r211 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											r211 = (( (Float)(this161) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float g211;
HXDLIN(  60)										int this162 = ((-1048336 >> 8) & 255);
HXDLIN(  60)										if ((this162 == 0)) {
HXLINE(  60)											g211 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											g211 = (( (Float)(this162) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float b212;
HXDLIN(  60)										int this163 = (-1048336 & 255);
HXDLIN(  60)										if ((this163 == 0)) {
HXLINE(  60)											b212 = ((Float)0.);
            										}
            										else {
HXLINE(  60)											b212 = (( (Float)(this163) ) / ( (Float)(255) ));
            										}
HXDLIN(  60)										Float a311 = (a113 * (( (Float)(1) ) - a212));
HXDLIN(  60)										int r31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r111 * a311) + (r211 * a212))));
HXDLIN(  60)										int g31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g111 * a311) + (g211 * a212))));
HXDLIN(  60)										int b33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a311) + (b212 * a212))));
HXDLIN(  60)										int a42 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a212)));
HXDLIN(  60)										int blended11 = ((((a42 << 24) | (r31 << 16)) | (g31 << 8)) | b33);
HXDLIN(  60)										{
HXLINE(  60)											int _hx_tmp38;
HXDLIN(  60)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)												_hx_tmp38 = ((((((blended11 >> 24) & 255) << 24) | ((blended11 & 255) << 16)) | (((blended11 >> 8) & 255) << 8)) | ((blended11 >> 16) & 255));
            											}
            											else {
HXLINE(  60)												_hx_tmp38 = blended11;
            											}
HXDLIN(  60)											::iterMagic::Iimg_obj::set(this153->image,location11,_hx_tmp38);
            										}
            									}
            									else {
HXLINE(  60)										::Dynamic this164 = this153->image;
HXDLIN(  60)										int index17;
HXDLIN(  60)										if (this153->useVirtualPos) {
HXLINE(  60)											index17 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - this153->virtualY) * ( (Float)(this153->width) )) + x15) - this153->virtualX));
            										}
            										else {
HXLINE(  60)											index17 = ::Std_obj::_hx_int(( (Float)(((y15 * this153->width) + x15)) ));
            										}
HXDLIN(  60)										int _hx_tmp39;
HXDLIN(  60)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)											_hx_tmp39 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            										}
            										else {
HXLINE(  60)											_hx_tmp39 = c15;
            										}
HXDLIN(  60)										::iterMagic::Iimg_obj::set(this164,index17,_hx_tmp39);
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  60)				{
HXLINE(  60)					{
HXLINE(  60)						Float bx5 = bx4;
HXDLIN(  60)						Float by5 = by4;
HXDLIN(  60)						Float cx5 = dx3;
HXDLIN(  60)						Float cy5 = dy3;
HXDLIN(  60)						bool hasUndo2 = false;
HXDLIN(  60)						bool adjustWinding2 = (((((ax2 * by5) - (bx5 * ay2)) + ((bx5 * cy5) - (cx5 * by5))) + ((cx5 * ay2) - (ax2 * cy5))) > 0);
HXDLIN(  60)						if (!(adjustWinding2)) {
HXLINE(  60)							Float bx_2 = bx5;
HXDLIN(  60)							Float by_2 = by5;
HXLINE(  25)							bx5 = cx5;
HXLINE(  26)							by5 = cy5;
HXLINE(  27)							cx5 = bx_2;
HXLINE(  28)							cy5 = by_2;
            						}
HXLINE(  60)						{
HXLINE(  60)							Float s02 = ((ay2 * cx5) - (ax2 * cy5));
HXDLIN(  60)							Float sx2 = (cy5 - ay2);
HXDLIN(  60)							Float sy2 = (ax2 - cx5);
HXDLIN(  60)							Float t02 = ((ax2 * by5) - (ay2 * bx5));
HXDLIN(  60)							Float tx2 = (ay2 - by5);
HXDLIN(  60)							Float ty2 = (bx5 - ax2);
HXDLIN(  60)							Float A2 = ((((-(by5) * cx5) + (ay2 * (-(bx5) + cx5))) + (ax2 * (by5 - cy5))) + (bx5 * cy5));
HXDLIN(  60)							 ::pi_xy::iter::IntIterStart xIter32;
HXDLIN(  60)							if ((ax2 > bx5)) {
HXLINE(  60)								if ((ax2 > cx5)) {
HXLINE(  60)									int min8;
HXDLIN(  60)									if ((bx5 > cx5)) {
HXLINE(  60)										min8 = ::Math_obj::floor(cx5);
            									}
            									else {
HXLINE(  60)										min8 = ::Math_obj::floor(bx5);
            									}
HXDLIN(  60)									int ii_min32 = min8;
HXDLIN(  60)									int ii_max32 = ::Math_obj::ceil(ax2);
HXDLIN(  60)									xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min32,ii_max32);
            								}
            								else {
HXLINE(  60)									int ii_min33 = ::Math_obj::floor(bx5);
HXDLIN(  60)									int ii_max33 = ::Math_obj::ceil(cx5);
HXDLIN(  60)									xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min33,ii_max33);
            								}
            							}
            							else {
HXLINE(  60)								if ((bx5 > cx5)) {
HXLINE(  60)									int min9;
HXDLIN(  60)									if ((ax2 > cx5)) {
HXLINE(  60)										min9 = ::Math_obj::floor(cx5);
            									}
            									else {
HXLINE(  60)										min9 = ::Math_obj::ceil(ax2);
            									}
HXDLIN(  60)									int ii_min34 = min9;
HXDLIN(  60)									int ii_max34 = ::Math_obj::ceil(bx5);
HXDLIN(  60)									xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min34,ii_max34);
            								}
            								else {
HXLINE(  60)									int ii_min35 = ::Math_obj::floor(ax2);
HXDLIN(  60)									int ii_max35 = ::Math_obj::ceil(cx5);
HXDLIN(  60)									xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min35,ii_max35);
            								}
            							}
HXDLIN(  60)							 ::pi_xy::iter::IntIterStart yIter32;
HXDLIN(  60)							if ((ay2 > by5)) {
HXLINE(  60)								if ((ay2 > cy5)) {
HXLINE(  60)									int min10;
HXDLIN(  60)									if ((by5 > cy5)) {
HXLINE(  60)										min10 = ::Math_obj::floor(cy5);
            									}
            									else {
HXLINE(  60)										min10 = ::Math_obj::floor(by5);
            									}
HXDLIN(  60)									int ii_min36 = min10;
HXDLIN(  60)									int ii_max36 = ::Math_obj::ceil(ay2);
HXDLIN(  60)									yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min36,ii_max36);
            								}
            								else {
HXLINE(  60)									int ii_min37 = ::Math_obj::floor(by5);
HXDLIN(  60)									int ii_max37 = ::Math_obj::ceil(cy5);
HXDLIN(  60)									yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min37,ii_max37);
            								}
            							}
            							else {
HXLINE(  60)								if ((by5 > cy5)) {
HXLINE(  60)									int min11;
HXDLIN(  60)									if ((ay2 > cy5)) {
HXLINE(  60)										min11 = ::Math_obj::floor(cy5);
            									}
            									else {
HXLINE(  60)										min11 = ::Math_obj::ceil(ay2);
            									}
HXDLIN(  60)									int ii_min38 = min11;
HXDLIN(  60)									int ii_max38 = ::Math_obj::ceil(by5);
HXDLIN(  60)									yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min38,ii_max38);
            								}
            								else {
HXLINE(  60)									int ii_min39 = ::Math_obj::floor(ay2);
HXDLIN(  60)									int ii_max39 = ::Math_obj::ceil(cy5);
HXDLIN(  60)									yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min39,ii_max39);
            								}
            							}
HXDLIN(  60)							 ::pi_xy::ImageStruct undoImage6 = null();
HXDLIN(  60)							if (hasUndo2) {
HXLINE(  60)								int width2 = ((xIter32->max - xIter32->start) + 1);
HXDLIN(  60)								int height2 = ((yIter32->max - yIter32->start) + 1);
HXDLIN(  60)								 ::Dynamic imageType2 = null();
HXDLIN(  60)								 ::pi_xy::ImageStruct this165 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  60)								if (::hx::IsNull( imageType2 )) {
HXLINE(  54)									imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE(  60)								::Dynamic undoImage7;
HXDLIN(  60)								switch((int)(( (int)(imageType2) ))){
            									case (int)0: {
HXLINE(  60)										 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  60)										 ::iterMagic::BytesImg b34 = byt2;
HXDLIN(  60)										{
HXLINE(  60)											b34->width = width2;
HXDLIN(  60)											b34->height = height2;
HXDLIN(  60)											b34->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  60)											b34->data = ::haxe::io::Bytes_obj::alloc((b34->length * 4));
HXDLIN(  60)											{
HXLINE(  60)												int len4 = b34->length;
HXDLIN(  60)												int w2 = 0;
HXDLIN(  60)												{
HXLINE(  60)													int _g40 = 0;
HXDLIN(  60)													int _g41 = b34->height;
HXDLIN(  60)													while((_g40 < _g41)){
HXLINE(  60)														_g40 = (_g40 + 1);
HXDLIN(  60)														int y16 = (_g40 - 1);
HXDLIN(  60)														{
HXLINE(  60)															int _g42 = 0;
HXDLIN(  60)															int _g43 = b34->width;
HXDLIN(  60)															while((_g42 < _g43)){
HXLINE(  60)																_g42 = (_g42 + 1);
HXDLIN(  60)																int x16 = (_g42 - 1);
HXDLIN(  60)																{
HXLINE(  60)																	w2 = (w2 + 1);
HXDLIN(  60)																	b34->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  60)																{
HXLINE(  60)																	w2 = (w2 + 1);
HXDLIN(  60)																	b34->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  60)																{
HXLINE(  60)																	w2 = (w2 + 1);
HXDLIN(  60)																	b34->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  60)																{
HXLINE(  60)																	w2 = (w2 + 1);
HXDLIN(  60)																	b34->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  60)										undoImage7 = b34;
            									}
            									break;
            									case (int)1: {
HXLINE(  60)										 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  60)										 ::iterMagic::ArrIntImg a43 = arrI2;
HXDLIN(  60)										{
HXLINE(  60)											a43->width = width2;
HXDLIN(  60)											a43->height = height2;
HXDLIN(  60)											a43->data = ::Array_obj< int >::__new(0);
HXDLIN(  60)											a43->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  60)											{
HXLINE(  60)												int _g44 = 0;
HXDLIN(  60)												int _g45 = a43->length;
HXDLIN(  60)												while((_g44 < _g45)){
HXLINE(  60)													_g44 = (_g44 + 1);
HXDLIN(  60)													int i28 = (_g44 - 1);
HXDLIN(  60)													a43->data[i28] = 0;
            												}
            											}
            										}
HXDLIN(  60)										undoImage7 = a43;
            									}
            									break;
            									case (int)2: {
HXLINE(  60)										 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  60)										 ::iterMagic::U32ArrImg b35 = u32a2;
HXDLIN(  60)										{
HXLINE(  60)											b35->width = width2;
HXDLIN(  60)											b35->height = height2;
HXDLIN(  60)											b35->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  60)											int size2 = (b35->length * 4);
HXDLIN(  60)											b35->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN(  60)											{
HXLINE(  60)												int _g46 = 0;
HXDLIN(  60)												int _g47 = b35->length;
HXDLIN(  60)												while((_g46 < _g47)){
HXLINE(  60)													_g46 = (_g46 + 1);
HXDLIN(  60)													int i29 = (_g46 - 1);
HXDLIN(  60)													{
HXLINE(  60)														 ::haxe::io::ArrayBufferViewImpl this166 = b35->data;
HXDLIN(  60)														bool undoImage8;
HXDLIN(  60)														if ((i29 >= 0)) {
HXLINE(  60)															undoImage8 = (i29 < (this166->byteLength >> 2));
            														}
            														else {
HXLINE(  60)															undoImage8 = false;
            														}
HXDLIN(  60)														if (undoImage8) {
HXLINE(  60)															 ::haxe::io::Bytes _this2 = this166->bytes;
HXDLIN(  60)															int pos2 = ((i29 << 2) + this166->byteOffset);
HXDLIN(  60)															_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN(  60)															_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN(  60)															_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN(  60)															_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN(  60)										undoImage7 = b35;
            									}
            									break;
            									case (int)3: {
HXLINE(  60)										 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  60)										 ::iterMagic::VecIntImg v7 = vec2;
HXDLIN(  60)										{
HXLINE(  60)											v7->width = width2;
HXDLIN(  60)											v7->height = height2;
HXDLIN(  60)											v7->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  60)											v7->data = ::Array_obj< int >::__new(v7->length);
HXDLIN(  60)											{
HXLINE(  60)												int _g48 = 0;
HXDLIN(  60)												int _g49 = v7->length;
HXDLIN(  60)												while((_g48 < _g49)){
HXLINE(  60)													_g48 = (_g48 + 1);
HXDLIN(  60)													int i30 = (_g48 - 1);
HXDLIN(  60)													v7->data->__unsafe_set(i30,0);
            												}
            											}
            										}
HXDLIN(  60)										undoImage7 = v7;
            									}
            									break;
            									case (int)4: {
HXLINE(  60)										 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  60)										 ::iterMagic::StackIntImg b36 = sInt2;
HXDLIN(  60)										{
HXLINE(  60)											b36->width = width2;
HXDLIN(  60)											b36->height = height2;
HXDLIN(  60)											b36->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  60)											b36->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  60)											{
HXLINE(  60)												int len5 = b36->length;
HXDLIN(  60)												 ::haxe::ds::GenericStack_Int d2 = b36->data;
HXDLIN(  60)												if (::hx::IsNull( d2->head )) {
HXLINE(  60)													int _g50 = 0;
HXDLIN(  60)													int _g51 = len5;
HXDLIN(  60)													while((_g50 < _g51)){
HXLINE(  60)														_g50 = (_g50 + 1);
HXDLIN(  60)														int i31 = (_g50 - 1);
HXDLIN(  60)														d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            													}
            												}
            												else {
HXLINE(  60)													int _g52 = 0;
HXDLIN(  60)													int _g53 = len5;
HXDLIN(  60)													while((_g52 < _g53)){
HXLINE(  60)														_g52 = (_g52 + 1);
HXDLIN(  60)														int i32 = (_g52 - 1);
HXDLIN(  60)														{
HXLINE(  60)															 ::haxe::ds::GenericCell_Int l2 = b36->data->head;
HXDLIN(  60)															 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN(  60)															{
HXLINE(  60)																int _g54 = 0;
HXDLIN(  60)																int _g55 = i32;
HXDLIN(  60)																while((_g54 < _g55)){
HXLINE(  60)																	_g54 = (_g54 + 1);
HXDLIN(  60)																	int i33 = (_g54 - 1);
HXLINE( 345)																	prev2 = l2;
HXLINE( 346)																	l2 = l2->next;
            																}
            															}
HXLINE(  60)															if (::hx::IsNull( prev2 )) {
HXLINE(  60)																b36->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  60)																l2 = null();
            															}
            															else {
HXLINE(  60)																prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  60)																l2 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  60)										undoImage7 = b36;
            									}
            									break;
            								}
HXDLIN(  60)								this165->image = undoImage7;
HXDLIN(  60)								this165->width = width2;
HXDLIN(  60)								this165->height = height2;
HXDLIN(  60)								this165->imageType = ( (int)(imageType2) );
HXDLIN(  60)								undoImage6 = this165;
HXDLIN(  60)								{
HXLINE(  60)									int rectLeft2 = xIter32->start;
HXDLIN(  60)									int rectTop2 = yIter32->start;
HXDLIN(  60)									int rectRight2 = xIter32->max;
HXDLIN(  60)									bool forceClear2 = false;
HXDLIN(  60)									{
HXLINE(  60)										int _g56 = rectTop2;
HXDLIN(  60)										int _g57 = yIter32->max;
HXDLIN(  60)										while((_g56 < _g57)){
HXLINE(  60)											_g56 = (_g56 + 1);
HXDLIN(  60)											int dy4 = (_g56 - 1);
HXDLIN(  60)											{
HXLINE(  60)												int _g58 = rectLeft2;
HXDLIN(  60)												int _g59 = rectRight2;
HXDLIN(  60)												while((_g58 < _g59)){
HXLINE(  60)													_g58 = (_g58 + 1);
HXDLIN(  60)													int dx4 = (_g58 - 1);
HXDLIN(  60)													::Dynamic this167 = this116->image;
HXDLIN(  60)													int index18;
HXDLIN(  60)													if (this116->useVirtualPos) {
HXLINE(  60)														index18 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this116->virtualY) * ( (Float)(this116->width) )) + dx4) - this116->virtualX));
            													}
            													else {
HXLINE(  60)														index18 = ::Std_obj::_hx_int(( (Float)(((dy4 * this116->width) + dx4)) ));
            													}
HXDLIN(  60)													int c16 = ::iterMagic::Iimg_obj::get(this167,index18);
HXDLIN(  60)													int col2;
HXDLIN(  60)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)														col2 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            													}
            													else {
HXLINE(  60)														col2 = c16;
            													}
HXDLIN(  60)													bool _hx_tmp40;
HXDLIN(  60)													if (this116->useMask) {
HXLINE(  60)														_hx_tmp40 = ::hx::IsNotNull( this116->mask );
            													}
            													else {
HXLINE(  60)														_hx_tmp40 = false;
            													}
HXDLIN(  60)													if (_hx_tmp40) {
HXLINE(  60)														 ::pi_xy::ImageStruct this168 = this116->mask;
HXDLIN(  60)														::Dynamic this169 = this168->image;
HXDLIN(  60)														int index19;
HXDLIN(  60)														if (this168->useVirtualPos) {
HXLINE(  60)															index19 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this168->virtualY) * ( (Float)(this168->width) )) + dx4) - this168->virtualX));
            														}
            														else {
HXLINE(  60)															index19 = ::Std_obj::_hx_int(( (Float)(((dy4 * this168->width) + dx4)) ));
            														}
HXDLIN(  60)														int c17 = ::iterMagic::Iimg_obj::get(this169,index19);
HXDLIN(  60)														int v8;
HXDLIN(  60)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)															v8 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            														}
            														else {
HXLINE(  60)															v8 = c17;
            														}
HXDLIN(  60)														int maskPixel2 = v8;
HXDLIN(  60)														int this170 = col2;
HXDLIN(  60)														if ((maskPixel2 == 0)) {
HXLINE(  60)															col2 = this170;
            														}
            														else {
HXLINE(  60)															Float m02;
HXDLIN(  60)															int this171 = ((maskPixel2 >> 24) & 255);
HXDLIN(  60)															if ((this171 == 0)) {
HXLINE(  60)																m02 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																m02 = (( (Float)(this171) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float m12;
HXDLIN(  60)															int this172 = ((maskPixel2 >> 16) & 255);
HXDLIN(  60)															if ((this172 == 0)) {
HXLINE(  60)																m12 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																m12 = (( (Float)(this172) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float m22;
HXDLIN(  60)															int this173 = ((maskPixel2 >> 8) & 255);
HXDLIN(  60)															if ((this173 == 0)) {
HXLINE(  60)																m22 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																m22 = (( (Float)(this173) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float m32;
HXDLIN(  60)															int this174 = (maskPixel2 & 255);
HXDLIN(  60)															if ((this174 == 0)) {
HXLINE(  60)																m32 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																m32 = (( (Float)(this174) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this170 >> 24) & 255)) )));
HXDLIN(  60)															int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this170 >> 16) & 255)) )));
HXDLIN(  60)															int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this170 >> 8) & 255)) )));
HXDLIN(  60)															int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this170 & 255)) )));
HXDLIN(  60)															col2 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  60)													if ((col2 != 0)) {
HXLINE(  60)														int x17 = (dx4 - rectLeft2);
HXDLIN(  60)														int y17 = (dy4 - rectTop2);
HXDLIN(  60)														int c18 = col2;
HXDLIN(  60)														bool _hx_tmp41;
HXDLIN(  60)														if ((((c18 >> 24) & 255) < 254)) {
HXLINE(  60)															_hx_tmp41 = undoImage6->transparent;
            														}
            														else {
HXLINE(  60)															_hx_tmp41 = false;
            														}
HXDLIN(  60)														if (_hx_tmp41) {
HXLINE(  60)															int location12;
HXDLIN(  60)															if (undoImage6->useVirtualPos) {
HXLINE(  60)																location12 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x17) - undoImage6->virtualX));
            															}
            															else {
HXLINE(  60)																location12 = ::Std_obj::_hx_int(( (Float)(((y17 * undoImage6->width) + x17)) ));
            															}
HXDLIN(  60)															int this175 = ::iterMagic::Iimg_obj::get(undoImage6->image,location12);
HXDLIN(  60)															int this176;
HXDLIN(  60)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)																this176 = ((((((this175 >> 24) & 255) << 24) | ((this175 & 255) << 16)) | (((this175 >> 8) & 255) << 8)) | ((this175 >> 16) & 255));
            															}
            															else {
HXLINE(  60)																this176 = this175;
            															}
HXDLIN(  60)															Float a114;
HXDLIN(  60)															int this177 = ((this176 >> 24) & 255);
HXDLIN(  60)															if ((this177 == 0)) {
HXLINE(  60)																a114 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																a114 = (( (Float)(this177) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float r112;
HXDLIN(  60)															int this178 = ((this176 >> 16) & 255);
HXDLIN(  60)															if ((this178 == 0)) {
HXLINE(  60)																r112 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																r112 = (( (Float)(this178) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float g112;
HXDLIN(  60)															int this179 = ((this176 >> 8) & 255);
HXDLIN(  60)															if ((this179 == 0)) {
HXLINE(  60)																g112 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																g112 = (( (Float)(this179) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float b115;
HXDLIN(  60)															int this180 = (this176 & 255);
HXDLIN(  60)															if ((this180 == 0)) {
HXLINE(  60)																b115 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																b115 = (( (Float)(this180) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float a213;
HXDLIN(  60)															int this181 = ((col2 >> 24) & 255);
HXDLIN(  60)															if ((this181 == 0)) {
HXLINE(  60)																a213 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																a213 = (( (Float)(this181) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float r212;
HXDLIN(  60)															int this182 = ((col2 >> 16) & 255);
HXDLIN(  60)															if ((this182 == 0)) {
HXLINE(  60)																r212 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																r212 = (( (Float)(this182) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float g212;
HXDLIN(  60)															int this183 = ((col2 >> 8) & 255);
HXDLIN(  60)															if ((this183 == 0)) {
HXLINE(  60)																g212 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																g212 = (( (Float)(this183) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float b213;
HXDLIN(  60)															int this184 = (col2 & 255);
HXDLIN(  60)															if ((this184 == 0)) {
HXLINE(  60)																b213 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																b213 = (( (Float)(this184) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float a312 = (a114 * (( (Float)(1) ) - a213));
HXDLIN(  60)															int r32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r112 * a312) + (r212 * a213))));
HXDLIN(  60)															int g32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g112 * a312) + (g212 * a213))));
HXDLIN(  60)															int b37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a312) + (b213 * a213))));
HXDLIN(  60)															int a44 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a213)));
HXDLIN(  60)															int blended12 = ((((a44 << 24) | (r32 << 16)) | (g32 << 8)) | b37);
HXDLIN(  60)															{
HXLINE(  60)																int _hx_tmp42;
HXDLIN(  60)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)																	_hx_tmp42 = ((((((blended12 >> 24) & 255) << 24) | ((blended12 & 255) << 16)) | (((blended12 >> 8) & 255) << 8)) | ((blended12 >> 16) & 255));
            																}
            																else {
HXLINE(  60)																	_hx_tmp42 = blended12;
            																}
HXDLIN(  60)																::iterMagic::Iimg_obj::set(undoImage6->image,location12,_hx_tmp42);
            															}
            														}
            														else {
HXLINE(  60)															::Dynamic this185 = undoImage6->image;
HXDLIN(  60)															int index20;
HXDLIN(  60)															if (undoImage6->useVirtualPos) {
HXLINE(  60)																index20 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x17) - undoImage6->virtualX));
            															}
            															else {
HXLINE(  60)																index20 = ::Std_obj::_hx_int(( (Float)(((y17 * undoImage6->width) + x17)) ));
            															}
HXDLIN(  60)															int _hx_tmp43;
HXDLIN(  60)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)																_hx_tmp43 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            															}
            															else {
HXLINE(  60)																_hx_tmp43 = c18;
            															}
HXDLIN(  60)															::iterMagic::Iimg_obj::set(this185,index20,_hx_tmp43);
            														}
            													}
            													else {
HXLINE(  60)														if (forceClear2) {
HXLINE(  60)															::Dynamic this186 = undoImage6->image;
HXDLIN(  60)															int x18 = (dx4 - rectLeft2);
HXDLIN(  60)															int y18 = (dy4 - rectTop2);
HXDLIN(  60)															int index21;
HXDLIN(  60)															if (undoImage6->useVirtualPos) {
HXLINE(  60)																index21 = ::Std_obj::_hx_int(((((( (Float)(y18) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x18) - undoImage6->virtualX));
            															}
            															else {
HXLINE(  60)																index21 = ::Std_obj::_hx_int(( (Float)(((y18 * undoImage6->width) + x18)) ));
            															}
HXDLIN(  60)															::iterMagic::Iimg_obj::set(this186,index21,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  60)							bool found2 = false;
HXDLIN(  60)							Float s2 = ((Float)0.);
HXDLIN(  60)							Float t2 = ((Float)0.);
HXDLIN(  60)							Float sxx2 = ((Float)0.);
HXDLIN(  60)							Float txx2 = ((Float)0.);
HXDLIN(  60)							{
HXLINE(  60)								int _g_min4 = xIter32->start;
HXDLIN(  60)								int _g_max4 = xIter32->max;
HXDLIN(  60)								while((_g_min4 < _g_max4)){
HXLINE(  60)									_g_min4 = (_g_min4 + 1);
HXDLIN(  60)									int x19 = (_g_min4 - 1);
HXDLIN(  60)									sxx2 = (sx2 * ( (Float)(x19) ));
HXLINE(  61)									txx2 = (tx2 * ( (Float)(x19) ));
HXLINE(  62)									found2 = false;
HXLINE(  60)									{
HXLINE(  60)										int _g_min5 = yIter32->start;
HXDLIN(  60)										int _g_max5 = yIter32->max;
HXDLIN(  60)										while((_g_min5 < _g_max5)){
HXLINE(  60)											_g_min5 = (_g_min5 + 1);
HXDLIN(  60)											int y19 = (_g_min5 - 1);
HXLINE(  64)											s2 = ((s02 + sxx2) + (sy2 * ( (Float)(y19) )));
HXLINE(  65)											t2 = ((t02 + txx2) + (ty2 * ( (Float)(y19) )));
HXLINE(  60)											bool _hx_tmp44;
HXDLIN(  60)											if (!((s2 <= 0))) {
HXLINE(  60)												_hx_tmp44 = (t2 <= 0);
            											}
            											else {
HXLINE(  60)												_hx_tmp44 = true;
            											}
HXDLIN(  60)											if (_hx_tmp44) {
HXLINE(  60)												if (found2) {
HXLINE(  60)													goto _hx_goto_185;
            												}
            											}
            											else {
HXLINE(  60)												if (((s2 + t2) < A2)) {
HXLINE(  60)													{
HXLINE(  60)														int c19 = color1;
HXDLIN(  60)														bool _hx_tmp45;
HXDLIN(  60)														if ((((c19 >> 24) & 255) < 254)) {
HXLINE(  60)															_hx_tmp45 = this116->transparent;
            														}
            														else {
HXLINE(  60)															_hx_tmp45 = false;
            														}
HXDLIN(  60)														if (_hx_tmp45) {
HXLINE(  60)															int location13;
HXDLIN(  60)															if (this116->useVirtualPos) {
HXLINE(  60)																location13 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - this116->virtualY) * ( (Float)(this116->width) )) + x19) - this116->virtualX));
            															}
            															else {
HXLINE(  60)																location13 = ::Std_obj::_hx_int(( (Float)(((y19 * this116->width) + x19)) ));
            															}
HXDLIN(  60)															int this187 = ::iterMagic::Iimg_obj::get(this116->image,location13);
HXDLIN(  60)															int this188;
HXDLIN(  60)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)																this188 = ((((((this187 >> 24) & 255) << 24) | ((this187 & 255) << 16)) | (((this187 >> 8) & 255) << 8)) | ((this187 >> 16) & 255));
            															}
            															else {
HXLINE(  60)																this188 = this187;
            															}
HXDLIN(  60)															Float a115;
HXDLIN(  60)															int this189 = ((this188 >> 24) & 255);
HXDLIN(  60)															if ((this189 == 0)) {
HXLINE(  60)																a115 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																a115 = (( (Float)(this189) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float r113;
HXDLIN(  60)															int this190 = ((this188 >> 16) & 255);
HXDLIN(  60)															if ((this190 == 0)) {
HXLINE(  60)																r113 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																r113 = (( (Float)(this190) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float g113;
HXDLIN(  60)															int this191 = ((this188 >> 8) & 255);
HXDLIN(  60)															if ((this191 == 0)) {
HXLINE(  60)																g113 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																g113 = (( (Float)(this191) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float b116;
HXDLIN(  60)															int this192 = (this188 & 255);
HXDLIN(  60)															if ((this192 == 0)) {
HXLINE(  60)																b116 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																b116 = (( (Float)(this192) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float a214;
HXDLIN(  60)															int this193 = ((color1 >> 24) & 255);
HXDLIN(  60)															if ((this193 == 0)) {
HXLINE(  60)																a214 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																a214 = (( (Float)(this193) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float r213;
HXDLIN(  60)															int this194 = ((color1 >> 16) & 255);
HXDLIN(  60)															if ((this194 == 0)) {
HXLINE(  60)																r213 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																r213 = (( (Float)(this194) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float g213;
HXDLIN(  60)															int this195 = ((color1 >> 8) & 255);
HXDLIN(  60)															if ((this195 == 0)) {
HXLINE(  60)																g213 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																g213 = (( (Float)(this195) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float b214;
HXDLIN(  60)															int this196 = (color1 & 255);
HXDLIN(  60)															if ((this196 == 0)) {
HXLINE(  60)																b214 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																b214 = (( (Float)(this196) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float a313 = (a115 * (( (Float)(1) ) - a214));
HXDLIN(  60)															int r33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r113 * a313) + (r213 * a214))));
HXDLIN(  60)															int g33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g113 * a313) + (g213 * a214))));
HXDLIN(  60)															int b38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a313) + (b214 * a214))));
HXDLIN(  60)															int a45 = ::Std_obj::_hx_int((( (Float)(255) ) * (a313 + a214)));
HXDLIN(  60)															int blended13 = ((((a45 << 24) | (r33 << 16)) | (g33 << 8)) | b38);
HXDLIN(  60)															{
HXLINE(  60)																int _hx_tmp46;
HXDLIN(  60)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)																	_hx_tmp46 = ((((((blended13 >> 24) & 255) << 24) | ((blended13 & 255) << 16)) | (((blended13 >> 8) & 255) << 8)) | ((blended13 >> 16) & 255));
            																}
            																else {
HXLINE(  60)																	_hx_tmp46 = blended13;
            																}
HXDLIN(  60)																::iterMagic::Iimg_obj::set(this116->image,location13,_hx_tmp46);
            															}
            														}
            														else {
HXLINE(  60)															::Dynamic this197 = this116->image;
HXDLIN(  60)															int index22;
HXDLIN(  60)															if (this116->useVirtualPos) {
HXLINE(  60)																index22 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - this116->virtualY) * ( (Float)(this116->width) )) + x19) - this116->virtualX));
            															}
            															else {
HXLINE(  60)																index22 = ::Std_obj::_hx_int(( (Float)(((y19 * this116->width) + x19)) ));
            															}
HXDLIN(  60)															int _hx_tmp47;
HXDLIN(  60)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)																_hx_tmp47 = ((((((c19 >> 24) & 255) << 24) | ((c19 & 255) << 16)) | (((c19 >> 8) & 255) << 8)) | ((c19 >> 16) & 255));
            															}
            															else {
HXLINE(  60)																_hx_tmp47 = c19;
            															}
HXDLIN(  60)															::iterMagic::Iimg_obj::set(this197,index22,_hx_tmp47);
            														}
            													}
HXLINE(  73)													found2 = true;
            												}
            												else {
HXLINE(  60)													if (found2) {
HXLINE(  60)														goto _hx_goto_185;
            													}
            												}
            											}
            										}
            										_hx_goto_185:;
            									}
            								}
            							}
HXDLIN(  60)							if ((hasHit1 == true)) {
HXLINE(  60)								 ::pi_xy::algo::HitTri v9 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax2,ay2,bx5,by5,cx5,cy5,true);
HXDLIN(  60)								if (hasUndo2) {
HXLINE(  60)									v9->undoImage = undoImage6;
HXDLIN(  60)									v9->undoX = xIter32->start;
HXDLIN(  60)									v9->undoY = yIter32->start;
            								}
            							}
            						}
            					}
HXDLIN(  60)					{
HXLINE(  60)						Float bx6 = cx4;
HXDLIN(  60)						Float by6 = cy4;
HXDLIN(  60)						Float cx6 = dx3;
HXDLIN(  60)						Float cy6 = dy3;
HXDLIN(  60)						bool hasUndo3 = false;
HXDLIN(  60)						bool adjustWinding3 = (((((bx4 * by6) - (bx6 * by4)) + ((bx6 * cy6) - (cx6 * by6))) + ((cx6 * by4) - (bx4 * cy6))) > 0);
HXDLIN(  60)						if (!(adjustWinding3)) {
HXLINE(  60)							Float bx_3 = bx6;
HXDLIN(  60)							Float by_3 = by6;
HXLINE(  25)							bx6 = cx6;
HXLINE(  26)							by6 = cy6;
HXLINE(  27)							cx6 = bx_3;
HXLINE(  28)							cy6 = by_3;
            						}
HXLINE(  60)						{
HXLINE(  60)							Float s03 = ((by4 * cx6) - (bx4 * cy6));
HXDLIN(  60)							Float sx3 = (cy6 - by4);
HXDLIN(  60)							Float sy3 = (bx4 - cx6);
HXDLIN(  60)							Float t03 = ((bx4 * by6) - (by4 * bx6));
HXDLIN(  60)							Float tx3 = (by4 - by6);
HXDLIN(  60)							Float ty3 = (bx6 - bx4);
HXDLIN(  60)							Float A3 = ((((-(by6) * cx6) + (by4 * (-(bx6) + cx6))) + (bx4 * (by6 - cy6))) + (bx6 * cy6));
HXDLIN(  60)							 ::pi_xy::iter::IntIterStart xIter33;
HXDLIN(  60)							if ((bx4 > bx6)) {
HXLINE(  60)								if ((bx4 > cx6)) {
HXLINE(  60)									int min12;
HXDLIN(  60)									if ((bx6 > cx6)) {
HXLINE(  60)										min12 = ::Math_obj::floor(cx6);
            									}
            									else {
HXLINE(  60)										min12 = ::Math_obj::floor(bx6);
            									}
HXDLIN(  60)									int ii_min40 = min12;
HXDLIN(  60)									int ii_max40 = ::Math_obj::ceil(bx4);
HXDLIN(  60)									xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min40,ii_max40);
            								}
            								else {
HXLINE(  60)									int ii_min41 = ::Math_obj::floor(bx6);
HXDLIN(  60)									int ii_max41 = ::Math_obj::ceil(cx6);
HXDLIN(  60)									xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min41,ii_max41);
            								}
            							}
            							else {
HXLINE(  60)								if ((bx6 > cx6)) {
HXLINE(  60)									int min13;
HXDLIN(  60)									if ((bx4 > cx6)) {
HXLINE(  60)										min13 = ::Math_obj::floor(cx6);
            									}
            									else {
HXLINE(  60)										min13 = ::Math_obj::ceil(bx4);
            									}
HXDLIN(  60)									int ii_min42 = min13;
HXDLIN(  60)									int ii_max42 = ::Math_obj::ceil(bx6);
HXDLIN(  60)									xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min42,ii_max42);
            								}
            								else {
HXLINE(  60)									int ii_min43 = ::Math_obj::floor(bx4);
HXDLIN(  60)									int ii_max43 = ::Math_obj::ceil(cx6);
HXDLIN(  60)									xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min43,ii_max43);
            								}
            							}
HXDLIN(  60)							 ::pi_xy::iter::IntIterStart yIter33;
HXDLIN(  60)							if ((by4 > by6)) {
HXLINE(  60)								if ((by4 > cy6)) {
HXLINE(  60)									int min14;
HXDLIN(  60)									if ((by6 > cy6)) {
HXLINE(  60)										min14 = ::Math_obj::floor(cy6);
            									}
            									else {
HXLINE(  60)										min14 = ::Math_obj::floor(by6);
            									}
HXDLIN(  60)									int ii_min44 = min14;
HXDLIN(  60)									int ii_max44 = ::Math_obj::ceil(by4);
HXDLIN(  60)									yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min44,ii_max44);
            								}
            								else {
HXLINE(  60)									int ii_min45 = ::Math_obj::floor(by6);
HXDLIN(  60)									int ii_max45 = ::Math_obj::ceil(cy6);
HXDLIN(  60)									yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min45,ii_max45);
            								}
            							}
            							else {
HXLINE(  60)								if ((by6 > cy6)) {
HXLINE(  60)									int min15;
HXDLIN(  60)									if ((by4 > cy6)) {
HXLINE(  60)										min15 = ::Math_obj::floor(cy6);
            									}
            									else {
HXLINE(  60)										min15 = ::Math_obj::ceil(by4);
            									}
HXDLIN(  60)									int ii_min46 = min15;
HXDLIN(  60)									int ii_max46 = ::Math_obj::ceil(by6);
HXDLIN(  60)									yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min46,ii_max46);
            								}
            								else {
HXLINE(  60)									int ii_min47 = ::Math_obj::floor(by4);
HXDLIN(  60)									int ii_max47 = ::Math_obj::ceil(cy6);
HXDLIN(  60)									yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min47,ii_max47);
            								}
            							}
HXDLIN(  60)							 ::pi_xy::ImageStruct undoImage9 = null();
HXDLIN(  60)							if (hasUndo3) {
HXLINE(  60)								int width3 = ((xIter33->max - xIter33->start) + 1);
HXDLIN(  60)								int height3 = ((yIter33->max - yIter33->start) + 1);
HXDLIN(  60)								 ::Dynamic imageType3 = null();
HXDLIN(  60)								 ::pi_xy::ImageStruct this198 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  60)								if (::hx::IsNull( imageType3 )) {
HXLINE(  54)									imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE(  60)								::Dynamic undoImage10;
HXDLIN(  60)								switch((int)(( (int)(imageType3) ))){
            									case (int)0: {
HXLINE(  60)										 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  60)										 ::iterMagic::BytesImg b39 = byt3;
HXDLIN(  60)										{
HXLINE(  60)											b39->width = width3;
HXDLIN(  60)											b39->height = height3;
HXDLIN(  60)											b39->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  60)											b39->data = ::haxe::io::Bytes_obj::alloc((b39->length * 4));
HXDLIN(  60)											{
HXLINE(  60)												int len6 = b39->length;
HXDLIN(  60)												int w3 = 0;
HXDLIN(  60)												{
HXLINE(  60)													int _g60 = 0;
HXDLIN(  60)													int _g61 = b39->height;
HXDLIN(  60)													while((_g60 < _g61)){
HXLINE(  60)														_g60 = (_g60 + 1);
HXDLIN(  60)														int y20 = (_g60 - 1);
HXDLIN(  60)														{
HXLINE(  60)															int _g62 = 0;
HXDLIN(  60)															int _g63 = b39->width;
HXDLIN(  60)															while((_g62 < _g63)){
HXLINE(  60)																_g62 = (_g62 + 1);
HXDLIN(  60)																int x20 = (_g62 - 1);
HXDLIN(  60)																{
HXLINE(  60)																	w3 = (w3 + 1);
HXDLIN(  60)																	b39->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  60)																{
HXLINE(  60)																	w3 = (w3 + 1);
HXDLIN(  60)																	b39->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  60)																{
HXLINE(  60)																	w3 = (w3 + 1);
HXDLIN(  60)																	b39->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  60)																{
HXLINE(  60)																	w3 = (w3 + 1);
HXDLIN(  60)																	b39->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  60)										undoImage10 = b39;
            									}
            									break;
            									case (int)1: {
HXLINE(  60)										 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  60)										 ::iterMagic::ArrIntImg a46 = arrI3;
HXDLIN(  60)										{
HXLINE(  60)											a46->width = width3;
HXDLIN(  60)											a46->height = height3;
HXDLIN(  60)											a46->data = ::Array_obj< int >::__new(0);
HXDLIN(  60)											a46->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  60)											{
HXLINE(  60)												int _g64 = 0;
HXDLIN(  60)												int _g65 = a46->length;
HXDLIN(  60)												while((_g64 < _g65)){
HXLINE(  60)													_g64 = (_g64 + 1);
HXDLIN(  60)													int i34 = (_g64 - 1);
HXDLIN(  60)													a46->data[i34] = 0;
            												}
            											}
            										}
HXDLIN(  60)										undoImage10 = a46;
            									}
            									break;
            									case (int)2: {
HXLINE(  60)										 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  60)										 ::iterMagic::U32ArrImg b40 = u32a3;
HXDLIN(  60)										{
HXLINE(  60)											b40->width = width3;
HXDLIN(  60)											b40->height = height3;
HXDLIN(  60)											b40->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  60)											int size3 = (b40->length * 4);
HXDLIN(  60)											b40->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN(  60)											{
HXLINE(  60)												int _g66 = 0;
HXDLIN(  60)												int _g67 = b40->length;
HXDLIN(  60)												while((_g66 < _g67)){
HXLINE(  60)													_g66 = (_g66 + 1);
HXDLIN(  60)													int i35 = (_g66 - 1);
HXDLIN(  60)													{
HXLINE(  60)														 ::haxe::io::ArrayBufferViewImpl this199 = b40->data;
HXDLIN(  60)														bool undoImage11;
HXDLIN(  60)														if ((i35 >= 0)) {
HXLINE(  60)															undoImage11 = (i35 < (this199->byteLength >> 2));
            														}
            														else {
HXLINE(  60)															undoImage11 = false;
            														}
HXDLIN(  60)														if (undoImage11) {
HXLINE(  60)															 ::haxe::io::Bytes _this3 = this199->bytes;
HXDLIN(  60)															int pos3 = ((i35 << 2) + this199->byteOffset);
HXDLIN(  60)															_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN(  60)															_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN(  60)															_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN(  60)															_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN(  60)										undoImage10 = b40;
            									}
            									break;
            									case (int)3: {
HXLINE(  60)										 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  60)										 ::iterMagic::VecIntImg v10 = vec3;
HXDLIN(  60)										{
HXLINE(  60)											v10->width = width3;
HXDLIN(  60)											v10->height = height3;
HXDLIN(  60)											v10->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  60)											v10->data = ::Array_obj< int >::__new(v10->length);
HXDLIN(  60)											{
HXLINE(  60)												int _g68 = 0;
HXDLIN(  60)												int _g69 = v10->length;
HXDLIN(  60)												while((_g68 < _g69)){
HXLINE(  60)													_g68 = (_g68 + 1);
HXDLIN(  60)													int i36 = (_g68 - 1);
HXDLIN(  60)													v10->data->__unsafe_set(i36,0);
            												}
            											}
            										}
HXDLIN(  60)										undoImage10 = v10;
            									}
            									break;
            									case (int)4: {
HXLINE(  60)										 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  60)										 ::iterMagic::StackIntImg b41 = sInt3;
HXDLIN(  60)										{
HXLINE(  60)											b41->width = width3;
HXDLIN(  60)											b41->height = height3;
HXDLIN(  60)											b41->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  60)											b41->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  60)											{
HXLINE(  60)												int len7 = b41->length;
HXDLIN(  60)												 ::haxe::ds::GenericStack_Int d3 = b41->data;
HXDLIN(  60)												if (::hx::IsNull( d3->head )) {
HXLINE(  60)													int _g70 = 0;
HXDLIN(  60)													int _g71 = len7;
HXDLIN(  60)													while((_g70 < _g71)){
HXLINE(  60)														_g70 = (_g70 + 1);
HXDLIN(  60)														int i37 = (_g70 - 1);
HXDLIN(  60)														d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            													}
            												}
            												else {
HXLINE(  60)													int _g72 = 0;
HXDLIN(  60)													int _g73 = len7;
HXDLIN(  60)													while((_g72 < _g73)){
HXLINE(  60)														_g72 = (_g72 + 1);
HXDLIN(  60)														int i38 = (_g72 - 1);
HXDLIN(  60)														{
HXLINE(  60)															 ::haxe::ds::GenericCell_Int l3 = b41->data->head;
HXDLIN(  60)															 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN(  60)															{
HXLINE(  60)																int _g74 = 0;
HXDLIN(  60)																int _g75 = i38;
HXDLIN(  60)																while((_g74 < _g75)){
HXLINE(  60)																	_g74 = (_g74 + 1);
HXDLIN(  60)																	int i39 = (_g74 - 1);
HXLINE( 345)																	prev3 = l3;
HXLINE( 346)																	l3 = l3->next;
            																}
            															}
HXLINE(  60)															if (::hx::IsNull( prev3 )) {
HXLINE(  60)																b41->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  60)																l3 = null();
            															}
            															else {
HXLINE(  60)																prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  60)																l3 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  60)										undoImage10 = b41;
            									}
            									break;
            								}
HXDLIN(  60)								this198->image = undoImage10;
HXDLIN(  60)								this198->width = width3;
HXDLIN(  60)								this198->height = height3;
HXDLIN(  60)								this198->imageType = ( (int)(imageType3) );
HXDLIN(  60)								undoImage9 = this198;
HXDLIN(  60)								{
HXLINE(  60)									int rectLeft3 = xIter33->start;
HXDLIN(  60)									int rectTop3 = yIter33->start;
HXDLIN(  60)									int rectRight3 = xIter33->max;
HXDLIN(  60)									bool forceClear3 = false;
HXDLIN(  60)									{
HXLINE(  60)										int _g76 = rectTop3;
HXDLIN(  60)										int _g77 = yIter33->max;
HXDLIN(  60)										while((_g76 < _g77)){
HXLINE(  60)											_g76 = (_g76 + 1);
HXDLIN(  60)											int dy5 = (_g76 - 1);
HXDLIN(  60)											{
HXLINE(  60)												int _g78 = rectLeft3;
HXDLIN(  60)												int _g79 = rectRight3;
HXDLIN(  60)												while((_g78 < _g79)){
HXLINE(  60)													_g78 = (_g78 + 1);
HXDLIN(  60)													int dx5 = (_g78 - 1);
HXDLIN(  60)													::Dynamic this200 = this116->image;
HXDLIN(  60)													int index23;
HXDLIN(  60)													if (this116->useVirtualPos) {
HXLINE(  60)														index23 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this116->virtualY) * ( (Float)(this116->width) )) + dx5) - this116->virtualX));
            													}
            													else {
HXLINE(  60)														index23 = ::Std_obj::_hx_int(( (Float)(((dy5 * this116->width) + dx5)) ));
            													}
HXDLIN(  60)													int c20 = ::iterMagic::Iimg_obj::get(this200,index23);
HXDLIN(  60)													int col3;
HXDLIN(  60)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)														col3 = ((((((c20 >> 24) & 255) << 24) | ((c20 & 255) << 16)) | (((c20 >> 8) & 255) << 8)) | ((c20 >> 16) & 255));
            													}
            													else {
HXLINE(  60)														col3 = c20;
            													}
HXDLIN(  60)													bool _hx_tmp48;
HXDLIN(  60)													if (this116->useMask) {
HXLINE(  60)														_hx_tmp48 = ::hx::IsNotNull( this116->mask );
            													}
            													else {
HXLINE(  60)														_hx_tmp48 = false;
            													}
HXDLIN(  60)													if (_hx_tmp48) {
HXLINE(  60)														 ::pi_xy::ImageStruct this201 = this116->mask;
HXDLIN(  60)														::Dynamic this202 = this201->image;
HXDLIN(  60)														int index24;
HXDLIN(  60)														if (this201->useVirtualPos) {
HXLINE(  60)															index24 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this201->virtualY) * ( (Float)(this201->width) )) + dx5) - this201->virtualX));
            														}
            														else {
HXLINE(  60)															index24 = ::Std_obj::_hx_int(( (Float)(((dy5 * this201->width) + dx5)) ));
            														}
HXDLIN(  60)														int c21 = ::iterMagic::Iimg_obj::get(this202,index24);
HXDLIN(  60)														int v11;
HXDLIN(  60)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)															v11 = ((((((c21 >> 24) & 255) << 24) | ((c21 & 255) << 16)) | (((c21 >> 8) & 255) << 8)) | ((c21 >> 16) & 255));
            														}
            														else {
HXLINE(  60)															v11 = c21;
            														}
HXDLIN(  60)														int maskPixel3 = v11;
HXDLIN(  60)														int this203 = col3;
HXDLIN(  60)														if ((maskPixel3 == 0)) {
HXLINE(  60)															col3 = this203;
            														}
            														else {
HXLINE(  60)															Float m03;
HXDLIN(  60)															int this204 = ((maskPixel3 >> 24) & 255);
HXDLIN(  60)															if ((this204 == 0)) {
HXLINE(  60)																m03 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																m03 = (( (Float)(this204) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float m13;
HXDLIN(  60)															int this205 = ((maskPixel3 >> 16) & 255);
HXDLIN(  60)															if ((this205 == 0)) {
HXLINE(  60)																m13 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																m13 = (( (Float)(this205) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float m23;
HXDLIN(  60)															int this206 = ((maskPixel3 >> 8) & 255);
HXDLIN(  60)															if ((this206 == 0)) {
HXLINE(  60)																m23 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																m23 = (( (Float)(this206) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float m33;
HXDLIN(  60)															int this207 = (maskPixel3 & 255);
HXDLIN(  60)															if ((this207 == 0)) {
HXLINE(  60)																m33 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																m33 = (( (Float)(this207) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															int ch03 = ::Std_obj::_hx_int(((((Float)1.) - m03) * ( (Float)(((this203 >> 24) & 255)) )));
HXDLIN(  60)															int ch13 = ::Std_obj::_hx_int(((((Float)1.) - m13) * ( (Float)(((this203 >> 16) & 255)) )));
HXDLIN(  60)															int ch23 = ::Std_obj::_hx_int(((((Float)1.) - m23) * ( (Float)(((this203 >> 8) & 255)) )));
HXDLIN(  60)															int ch33 = ::Std_obj::_hx_int(((((Float)1.) - m33) * ( (Float)((this203 & 255)) )));
HXDLIN(  60)															col3 = ((((::Math_obj::round((( (Float)(ch03) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch13) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch23) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch33) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  60)													if ((col3 != 0)) {
HXLINE(  60)														int x21 = (dx5 - rectLeft3);
HXDLIN(  60)														int y21 = (dy5 - rectTop3);
HXDLIN(  60)														int c22 = col3;
HXDLIN(  60)														bool _hx_tmp49;
HXDLIN(  60)														if ((((c22 >> 24) & 255) < 254)) {
HXLINE(  60)															_hx_tmp49 = undoImage9->transparent;
            														}
            														else {
HXLINE(  60)															_hx_tmp49 = false;
            														}
HXDLIN(  60)														if (_hx_tmp49) {
HXLINE(  60)															int location14;
HXDLIN(  60)															if (undoImage9->useVirtualPos) {
HXLINE(  60)																location14 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x21) - undoImage9->virtualX));
            															}
            															else {
HXLINE(  60)																location14 = ::Std_obj::_hx_int(( (Float)(((y21 * undoImage9->width) + x21)) ));
            															}
HXDLIN(  60)															int this208 = ::iterMagic::Iimg_obj::get(undoImage9->image,location14);
HXDLIN(  60)															int this209;
HXDLIN(  60)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)																this209 = ((((((this208 >> 24) & 255) << 24) | ((this208 & 255) << 16)) | (((this208 >> 8) & 255) << 8)) | ((this208 >> 16) & 255));
            															}
            															else {
HXLINE(  60)																this209 = this208;
            															}
HXDLIN(  60)															Float a116;
HXDLIN(  60)															int this210 = ((this209 >> 24) & 255);
HXDLIN(  60)															if ((this210 == 0)) {
HXLINE(  60)																a116 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																a116 = (( (Float)(this210) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float r114;
HXDLIN(  60)															int this211 = ((this209 >> 16) & 255);
HXDLIN(  60)															if ((this211 == 0)) {
HXLINE(  60)																r114 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																r114 = (( (Float)(this211) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float g114;
HXDLIN(  60)															int this212 = ((this209 >> 8) & 255);
HXDLIN(  60)															if ((this212 == 0)) {
HXLINE(  60)																g114 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																g114 = (( (Float)(this212) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float b117;
HXDLIN(  60)															int this213 = (this209 & 255);
HXDLIN(  60)															if ((this213 == 0)) {
HXLINE(  60)																b117 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																b117 = (( (Float)(this213) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float a215;
HXDLIN(  60)															int this214 = ((col3 >> 24) & 255);
HXDLIN(  60)															if ((this214 == 0)) {
HXLINE(  60)																a215 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																a215 = (( (Float)(this214) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float r214;
HXDLIN(  60)															int this215 = ((col3 >> 16) & 255);
HXDLIN(  60)															if ((this215 == 0)) {
HXLINE(  60)																r214 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																r214 = (( (Float)(this215) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float g214;
HXDLIN(  60)															int this216 = ((col3 >> 8) & 255);
HXDLIN(  60)															if ((this216 == 0)) {
HXLINE(  60)																g214 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																g214 = (( (Float)(this216) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float b215;
HXDLIN(  60)															int this217 = (col3 & 255);
HXDLIN(  60)															if ((this217 == 0)) {
HXLINE(  60)																b215 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																b215 = (( (Float)(this217) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float a314 = (a116 * (( (Float)(1) ) - a215));
HXDLIN(  60)															int r34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r114 * a314) + (r214 * a215))));
HXDLIN(  60)															int g34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g114 * a314) + (g214 * a215))));
HXDLIN(  60)															int b42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b117 * a314) + (b215 * a215))));
HXDLIN(  60)															int a47 = ::Std_obj::_hx_int((( (Float)(255) ) * (a314 + a215)));
HXDLIN(  60)															int blended14 = ((((a47 << 24) | (r34 << 16)) | (g34 << 8)) | b42);
HXDLIN(  60)															{
HXLINE(  60)																int _hx_tmp50;
HXDLIN(  60)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)																	_hx_tmp50 = ((((((blended14 >> 24) & 255) << 24) | ((blended14 & 255) << 16)) | (((blended14 >> 8) & 255) << 8)) | ((blended14 >> 16) & 255));
            																}
            																else {
HXLINE(  60)																	_hx_tmp50 = blended14;
            																}
HXDLIN(  60)																::iterMagic::Iimg_obj::set(undoImage9->image,location14,_hx_tmp50);
            															}
            														}
            														else {
HXLINE(  60)															::Dynamic this218 = undoImage9->image;
HXDLIN(  60)															int index25;
HXDLIN(  60)															if (undoImage9->useVirtualPos) {
HXLINE(  60)																index25 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x21) - undoImage9->virtualX));
            															}
            															else {
HXLINE(  60)																index25 = ::Std_obj::_hx_int(( (Float)(((y21 * undoImage9->width) + x21)) ));
            															}
HXDLIN(  60)															int _hx_tmp51;
HXDLIN(  60)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)																_hx_tmp51 = ((((((c22 >> 24) & 255) << 24) | ((c22 & 255) << 16)) | (((c22 >> 8) & 255) << 8)) | ((c22 >> 16) & 255));
            															}
            															else {
HXLINE(  60)																_hx_tmp51 = c22;
            															}
HXDLIN(  60)															::iterMagic::Iimg_obj::set(this218,index25,_hx_tmp51);
            														}
            													}
            													else {
HXLINE(  60)														if (forceClear3) {
HXLINE(  60)															::Dynamic this219 = undoImage9->image;
HXDLIN(  60)															int x22 = (dx5 - rectLeft3);
HXDLIN(  60)															int y22 = (dy5 - rectTop3);
HXDLIN(  60)															int index26;
HXDLIN(  60)															if (undoImage9->useVirtualPos) {
HXLINE(  60)																index26 = ::Std_obj::_hx_int(((((( (Float)(y22) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x22) - undoImage9->virtualX));
            															}
            															else {
HXLINE(  60)																index26 = ::Std_obj::_hx_int(( (Float)(((y22 * undoImage9->width) + x22)) ));
            															}
HXDLIN(  60)															::iterMagic::Iimg_obj::set(this219,index26,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  60)							bool found3 = false;
HXDLIN(  60)							Float s3 = ((Float)0.);
HXDLIN(  60)							Float t3 = ((Float)0.);
HXDLIN(  60)							Float sxx3 = ((Float)0.);
HXDLIN(  60)							Float txx3 = ((Float)0.);
HXDLIN(  60)							{
HXLINE(  60)								int _g_min6 = xIter33->start;
HXDLIN(  60)								int _g_max6 = xIter33->max;
HXDLIN(  60)								while((_g_min6 < _g_max6)){
HXLINE(  60)									_g_min6 = (_g_min6 + 1);
HXDLIN(  60)									int x23 = (_g_min6 - 1);
HXDLIN(  60)									sxx3 = (sx3 * ( (Float)(x23) ));
HXLINE(  61)									txx3 = (tx3 * ( (Float)(x23) ));
HXLINE(  62)									found3 = false;
HXLINE(  60)									{
HXLINE(  60)										int _g_min7 = yIter33->start;
HXDLIN(  60)										int _g_max7 = yIter33->max;
HXDLIN(  60)										while((_g_min7 < _g_max7)){
HXLINE(  60)											_g_min7 = (_g_min7 + 1);
HXDLIN(  60)											int y23 = (_g_min7 - 1);
HXLINE(  64)											s3 = ((s03 + sxx3) + (sy3 * ( (Float)(y23) )));
HXLINE(  65)											t3 = ((t03 + txx3) + (ty3 * ( (Float)(y23) )));
HXLINE(  60)											bool _hx_tmp52;
HXDLIN(  60)											if (!((s3 <= 0))) {
HXLINE(  60)												_hx_tmp52 = (t3 <= 0);
            											}
            											else {
HXLINE(  60)												_hx_tmp52 = true;
            											}
HXDLIN(  60)											if (_hx_tmp52) {
HXLINE(  60)												if (found3) {
HXLINE(  60)													goto _hx_goto_197;
            												}
            											}
            											else {
HXLINE(  60)												if (((s3 + t3) < A3)) {
HXLINE(  60)													{
HXLINE(  60)														int c23 = color1;
HXDLIN(  60)														bool _hx_tmp53;
HXDLIN(  60)														if ((((c23 >> 24) & 255) < 254)) {
HXLINE(  60)															_hx_tmp53 = this116->transparent;
            														}
            														else {
HXLINE(  60)															_hx_tmp53 = false;
            														}
HXDLIN(  60)														if (_hx_tmp53) {
HXLINE(  60)															int location15;
HXDLIN(  60)															if (this116->useVirtualPos) {
HXLINE(  60)																location15 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - this116->virtualY) * ( (Float)(this116->width) )) + x23) - this116->virtualX));
            															}
            															else {
HXLINE(  60)																location15 = ::Std_obj::_hx_int(( (Float)(((y23 * this116->width) + x23)) ));
            															}
HXDLIN(  60)															int this220 = ::iterMagic::Iimg_obj::get(this116->image,location15);
HXDLIN(  60)															int this221;
HXDLIN(  60)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)																this221 = ((((((this220 >> 24) & 255) << 24) | ((this220 & 255) << 16)) | (((this220 >> 8) & 255) << 8)) | ((this220 >> 16) & 255));
            															}
            															else {
HXLINE(  60)																this221 = this220;
            															}
HXDLIN(  60)															Float a117;
HXDLIN(  60)															int this222 = ((this221 >> 24) & 255);
HXDLIN(  60)															if ((this222 == 0)) {
HXLINE(  60)																a117 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																a117 = (( (Float)(this222) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float r115;
HXDLIN(  60)															int this223 = ((this221 >> 16) & 255);
HXDLIN(  60)															if ((this223 == 0)) {
HXLINE(  60)																r115 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																r115 = (( (Float)(this223) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float g115;
HXDLIN(  60)															int this224 = ((this221 >> 8) & 255);
HXDLIN(  60)															if ((this224 == 0)) {
HXLINE(  60)																g115 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																g115 = (( (Float)(this224) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float b118;
HXDLIN(  60)															int this225 = (this221 & 255);
HXDLIN(  60)															if ((this225 == 0)) {
HXLINE(  60)																b118 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																b118 = (( (Float)(this225) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float a216;
HXDLIN(  60)															int this226 = ((color1 >> 24) & 255);
HXDLIN(  60)															if ((this226 == 0)) {
HXLINE(  60)																a216 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																a216 = (( (Float)(this226) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float r215;
HXDLIN(  60)															int this227 = ((color1 >> 16) & 255);
HXDLIN(  60)															if ((this227 == 0)) {
HXLINE(  60)																r215 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																r215 = (( (Float)(this227) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float g215;
HXDLIN(  60)															int this228 = ((color1 >> 8) & 255);
HXDLIN(  60)															if ((this228 == 0)) {
HXLINE(  60)																g215 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																g215 = (( (Float)(this228) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float b216;
HXDLIN(  60)															int this229 = (color1 & 255);
HXDLIN(  60)															if ((this229 == 0)) {
HXLINE(  60)																b216 = ((Float)0.);
            															}
            															else {
HXLINE(  60)																b216 = (( (Float)(this229) ) / ( (Float)(255) ));
            															}
HXDLIN(  60)															Float a315 = (a117 * (( (Float)(1) ) - a216));
HXDLIN(  60)															int r35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r115 * a315) + (r215 * a216))));
HXDLIN(  60)															int g35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g115 * a315) + (g215 * a216))));
HXDLIN(  60)															int b43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b118 * a315) + (b216 * a216))));
HXDLIN(  60)															int a48 = ::Std_obj::_hx_int((( (Float)(255) ) * (a315 + a216)));
HXDLIN(  60)															int blended15 = ((((a48 << 24) | (r35 << 16)) | (g35 << 8)) | b43);
HXDLIN(  60)															{
HXLINE(  60)																int _hx_tmp54;
HXDLIN(  60)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)																	_hx_tmp54 = ((((((blended15 >> 24) & 255) << 24) | ((blended15 & 255) << 16)) | (((blended15 >> 8) & 255) << 8)) | ((blended15 >> 16) & 255));
            																}
            																else {
HXLINE(  60)																	_hx_tmp54 = blended15;
            																}
HXDLIN(  60)																::iterMagic::Iimg_obj::set(this116->image,location15,_hx_tmp54);
            															}
            														}
            														else {
HXLINE(  60)															::Dynamic this230 = this116->image;
HXDLIN(  60)															int index27;
HXDLIN(  60)															if (this116->useVirtualPos) {
HXLINE(  60)																index27 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - this116->virtualY) * ( (Float)(this116->width) )) + x23) - this116->virtualX));
            															}
            															else {
HXLINE(  60)																index27 = ::Std_obj::_hx_int(( (Float)(((y23 * this116->width) + x23)) ));
            															}
HXDLIN(  60)															int _hx_tmp55;
HXDLIN(  60)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  60)																_hx_tmp55 = ((((((c23 >> 24) & 255) << 24) | ((c23 & 255) << 16)) | (((c23 >> 8) & 255) << 8)) | ((c23 >> 16) & 255));
            															}
            															else {
HXLINE(  60)																_hx_tmp55 = c23;
            															}
HXDLIN(  60)															::iterMagic::Iimg_obj::set(this230,index27,_hx_tmp55);
            														}
            													}
HXLINE(  73)													found3 = true;
            												}
            												else {
HXLINE(  60)													if (found3) {
HXLINE(  60)														goto _hx_goto_197;
            													}
            												}
            											}
            										}
            										_hx_goto_197:;
            									}
            								}
            							}
HXDLIN(  60)							if ((hasHit1 == true)) {
HXLINE(  60)								 ::pi_xy::algo::HitTri v12 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx4,by4,bx6,by6,cx6,cy6,true);
HXDLIN(  60)								if (hasUndo3) {
HXLINE(  60)									v12->undoImage = undoImage9;
HXDLIN(  60)									v12->undoX = xIter33->start;
HXDLIN(  60)									v12->undoY = yIter33->start;
            								}
            							}
            						}
            					}
HXDLIN(  60)					if ((hasHit1 == true)) {
HXLINE(  60)						 ::pi_xy::algo::HitQuad v13 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax2,ay2,bx4,by4,cx4,cy4,dx3,dy3,true);
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(ArcForm_obj,pie,(void))


::hx::ObjectPtr< ArcForm_obj > ArcForm_obj::__new( ::Dynamic opacity, ::Dynamic visibility, ::Dynamic strokeColor, ::Dynamic strokeWidth,::Array< ::String > strokeDashGapArray, ::Dynamic fill, ::Dynamic left, ::Dynamic top, ::Dynamic width, ::Dynamic height, ::Dynamic startAngle, ::Dynamic sweepAngle,::String __o_arcType) {
	::hx::ObjectPtr< ArcForm_obj > __this = new ArcForm_obj();
	__this->__construct(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,width,height,startAngle,sweepAngle,__o_arcType);
	return __this;
}

::hx::ObjectPtr< ArcForm_obj > ArcForm_obj::__alloc(::hx::Ctx *_hx_ctx, ::Dynamic opacity, ::Dynamic visibility, ::Dynamic strokeColor, ::Dynamic strokeWidth,::Array< ::String > strokeDashGapArray, ::Dynamic fill, ::Dynamic left, ::Dynamic top, ::Dynamic width, ::Dynamic height, ::Dynamic startAngle, ::Dynamic sweepAngle,::String __o_arcType) {
	ArcForm_obj *__this = (ArcForm_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(ArcForm_obj), true, "pi_xy.triangleGML.ArcForm"));
	*(void **)__this = ArcForm_obj::_hx_vtable;
	__this->__construct(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,width,height,startAngle,sweepAngle,__o_arcType);
	return __this;
}

ArcForm_obj::ArcForm_obj()
{
}

::hx::Val ArcForm_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"pie") ) { return ::hx::Val( pie_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"chord") ) { return ::hx::Val( chord_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"ellipse") ) { return ::hx::Val( ellipse_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *ArcForm_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *ArcForm_obj_sStaticStorageInfo = 0;
#endif

static ::String ArcForm_obj_sMemberFields[] = {
	HX_("render",56,6b,29,05),
	HX_("chord",5c,3c,be,45),
	HX_("ellipse",de,40,86,0b),
	HX_("pie",4c,58,55,00),
	::String(null()) };

::hx::Class ArcForm_obj::__mClass;

void ArcForm_obj::__register()
{
	ArcForm_obj _hx_dummy;
	ArcForm_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pi_xy.triangleGML.ArcForm",9f,86,c3,3c);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(ArcForm_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< ArcForm_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ArcForm_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ArcForm_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pi_xy
} // end namespace triangleGML
