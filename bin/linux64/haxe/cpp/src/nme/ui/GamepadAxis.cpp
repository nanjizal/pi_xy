// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_nme_ui_GamepadAxis
#include <nme/ui/GamepadAxis.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_9832052f86bea27f_14_toString,"nme.ui.GamepadAxis","toString",0x7dbdac0a,"nme.ui.GamepadAxis.toString","nme/ui/GamepadAxis.hx",14,0x2869ca8e)
HX_LOCAL_STACK_FRAME(_hx_pos_9832052f86bea27f_8_boot,"nme.ui.GamepadAxis","boot",0x8105d890,"nme.ui.GamepadAxis.boot","nme/ui/GamepadAxis.hx",8,0x2869ca8e)
HX_LOCAL_STACK_FRAME(_hx_pos_9832052f86bea27f_9_boot,"nme.ui.GamepadAxis","boot",0x8105d890,"nme.ui.GamepadAxis.boot","nme/ui/GamepadAxis.hx",9,0x2869ca8e)
HX_LOCAL_STACK_FRAME(_hx_pos_9832052f86bea27f_10_boot,"nme.ui.GamepadAxis","boot",0x8105d890,"nme.ui.GamepadAxis.boot","nme/ui/GamepadAxis.hx",10,0x2869ca8e)
namespace nme{
namespace ui{

void GamepadAxis_obj::__construct() { }

Dynamic GamepadAxis_obj::__CreateEmpty() { return new GamepadAxis_obj; }

void *GamepadAxis_obj::_hx_vtable = 0;

Dynamic GamepadAxis_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< GamepadAxis_obj > _hx_result = new GamepadAxis_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool GamepadAxis_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x46073228;
}

int GamepadAxis_obj::LEFT;

int GamepadAxis_obj::RIGHT;

int GamepadAxis_obj::TRIGGER;

::String GamepadAxis_obj::toString(int id){
            	HX_STACKFRAME(&_hx_pos_9832052f86bea27f_14_toString)
HXDLIN(  14)		switch((int)(id)){
            			case (int)0: {
HXLINE(  16)				return HX_("GamepadAxis.LEFT",33,3a,b7,e6);
            			}
            			break;
            			case (int)2: {
HXLINE(  17)				return HX_("GamepadAxis.RIGHT",10,c0,a8,70);
            			}
            			break;
            			case (int)4: {
HXLINE(  18)				return HX_("GamepadAxis.TRIGGER",6c,62,e0,8e);
            			}
            			break;
            			default:{
HXLINE(  19)				return HX_("AXIS UNKNOWN",eb,28,2e,bf);
            			}
            		}
HXLINE(  14)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(GamepadAxis_obj,toString,return )


GamepadAxis_obj::GamepadAxis_obj()
{
}

bool GamepadAxis_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"toString") ) { outValue = toString_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *GamepadAxis_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo GamepadAxis_obj_sStaticStorageInfo[] = {
	{::hx::fsInt,(void *) &GamepadAxis_obj::LEFT,HX_("LEFT",07,d0,70,32)},
	{::hx::fsInt,(void *) &GamepadAxis_obj::RIGHT,HX_("RIGHT",bc,43,52,67)},
	{::hx::fsInt,(void *) &GamepadAxis_obj::TRIGGER,HX_("TRIGGER",18,29,b3,a5)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static void GamepadAxis_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(GamepadAxis_obj::LEFT,"LEFT");
	HX_MARK_MEMBER_NAME(GamepadAxis_obj::RIGHT,"RIGHT");
	HX_MARK_MEMBER_NAME(GamepadAxis_obj::TRIGGER,"TRIGGER");
};

#ifdef HXCPP_VISIT_ALLOCS
static void GamepadAxis_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(GamepadAxis_obj::LEFT,"LEFT");
	HX_VISIT_MEMBER_NAME(GamepadAxis_obj::RIGHT,"RIGHT");
	HX_VISIT_MEMBER_NAME(GamepadAxis_obj::TRIGGER,"TRIGGER");
};

#endif

::hx::Class GamepadAxis_obj::__mClass;

static ::String GamepadAxis_obj_sStaticFields[] = {
	HX_("LEFT",07,d0,70,32),
	HX_("RIGHT",bc,43,52,67),
	HX_("TRIGGER",18,29,b3,a5),
	HX_("toString",ac,d0,6e,38),
	::String(null())
};

void GamepadAxis_obj::__register()
{
	GamepadAxis_obj _hx_dummy;
	GamepadAxis_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("nme.ui.GamepadAxis",d0,68,86,1e);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &GamepadAxis_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = GamepadAxis_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(GamepadAxis_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< GamepadAxis_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = GamepadAxis_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = GamepadAxis_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = GamepadAxis_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void GamepadAxis_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_9832052f86bea27f_8_boot)
HXDLIN(   8)		LEFT = 0;
            	}
{
            	HX_STACKFRAME(&_hx_pos_9832052f86bea27f_9_boot)
HXDLIN(   9)		RIGHT = 2;
            	}
{
            	HX_STACKFRAME(&_hx_pos_9832052f86bea27f_10_boot)
HXDLIN(  10)		TRIGGER = 4;
            	}
}

} // end namespace nme
} // end namespace ui
