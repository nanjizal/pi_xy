// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericCell_Int
#include <haxe/ds/GenericCell_Int.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericStack_Int
#include <haxe/ds/GenericStack_Int.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_iterMagic_ArrIntImg
#include <iterMagic/ArrIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_BytesImg
#include <iterMagic/BytesImg.h>
#endif
#ifndef INCLUDED_iterMagic_Iimg
#include <iterMagic/Iimg.h>
#endif
#ifndef INCLUDED_iterMagic_StackIntImg
#include <iterMagic/StackIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_U32ArrImg
#include <iterMagic/U32ArrImg.h>
#endif
#ifndef INCLUDED_iterMagic_VecIntImg
#include <iterMagic/VecIntImg.h>
#endif
#ifndef INCLUDED_pi_xy_ImageStruct
#include <pi_xy/ImageStruct.h>
#endif
#ifndef INCLUDED_pi_xy__Endian_Endian_Fields_
#include <pi_xy/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitQuad
#include <pi_xy/algo/HitQuad.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitTri
#include <pi_xy/algo/HitTri.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitTriArray
#include <pi_xy/algo/HitTriArray.h>
#endif
#ifndef INCLUDED_pi_xy_algo_IhitObj
#include <pi_xy/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pi_xy_algo_QuadPoints_
#include <pi_xy/algo/QuadPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_TriPoints_
#include <pi_xy/algo/TriPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_imageAbstracts__TileShape_TileShape_Impl_
#include <pi_xy/imageAbstracts/_TileShape/TileShape_Impl_.h>
#endif
#ifndef INCLUDED_pi_xy_iter_IntIterStart
#include <pi_xy/iter/IntIterStart.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_6e4d7718bf84d356_15__new,"pi_xy.imageAbstracts._TileShape.TileShape_Impl_","_new",0x6b4197a5,"pi_xy.imageAbstracts._TileShape.TileShape_Impl_._new","pi_xy/imageAbstracts/TileShape.hx",15,0xe22daf9c)
HX_LOCAL_STACK_FRAME(_hx_pos_6e4d7718bf84d356_25_triangle,"pi_xy.imageAbstracts._TileShape.TileShape_Impl_","triangle",0xb190b30c,"pi_xy.imageAbstracts._TileShape.TileShape_Impl_.triangle","pi_xy/imageAbstracts/TileShape.hx",25,0xe22daf9c)
HX_LOCAL_STACK_FRAME(_hx_pos_6e4d7718bf84d356_37_quad,"pi_xy.imageAbstracts._TileShape.TileShape_Impl_","quad",0x772cbb0b,"pi_xy.imageAbstracts._TileShape.TileShape_Impl_.quad","pi_xy/imageAbstracts/TileShape.hx",37,0xe22daf9c)
HX_LOCAL_STACK_FRAME(_hx_pos_6e4d7718bf84d356_44_rectangle,"pi_xy.imageAbstracts._TileShape.TileShape_Impl_","rectangle",0x47479b6b,"pi_xy.imageAbstracts._TileShape.TileShape_Impl_.rectangle","pi_xy/imageAbstracts/TileShape.hx",44,0xe22daf9c)
HX_LOCAL_STACK_FRAME(_hx_pos_6e4d7718bf84d356_56_line,"pi_xy.imageAbstracts._TileShape.TileShape_Impl_","line",0x73d59a38,"pi_xy.imageAbstracts._TileShape.TileShape_Impl_.line","pi_xy/imageAbstracts/TileShape.hx",56,0xe22daf9c)
HX_LOCAL_STACK_FRAME(_hx_pos_6e4d7718bf84d356_78_PolyBuild,"pi_xy.imageAbstracts._TileShape.TileShape_Impl_","PolyBuild",0x2070205e,"pi_xy.imageAbstracts._TileShape.TileShape_Impl_.PolyBuild","pi_xy/imageAbstracts/TileShape.hx",78,0xe22daf9c)
HX_LOCAL_STACK_FRAME(_hx_pos_6e4d7718bf84d356_95_quadrant,"pi_xy.imageAbstracts._TileShape.TileShape_Impl_","quadrant",0x0cb2ea40,"pi_xy.imageAbstracts._TileShape.TileShape_Impl_.quadrant","pi_xy/imageAbstracts/TileShape.hx",95,0xe22daf9c)
HX_LOCAL_STACK_FRAME(_hx_pos_6e4d7718bf84d356_110_quadrantI,"pi_xy.imageAbstracts._TileShape.TileShape_Impl_","quadrantI",0x0fda0e09,"pi_xy.imageAbstracts._TileShape.TileShape_Impl_.quadrantI","pi_xy/imageAbstracts/TileShape.hx",110,0xe22daf9c)
HX_LOCAL_STACK_FRAME(_hx_pos_6e4d7718bf84d356_123_quadrantII,"pi_xy.imageAbstracts._TileShape.TileShape_Impl_","quadrantII",0xcef23a20,"pi_xy.imageAbstracts._TileShape.TileShape_Impl_.quadrantII","pi_xy/imageAbstracts/TileShape.hx",123,0xe22daf9c)
HX_LOCAL_STACK_FRAME(_hx_pos_6e4d7718bf84d356_136_quadrantIII,"pi_xy.imageAbstracts._TileShape.TileShape_Impl_","quadrantIII",0x4500a229,"pi_xy.imageAbstracts._TileShape.TileShape_Impl_.quadrantIII","pi_xy/imageAbstracts/TileShape.hx",136,0xe22daf9c)
HX_LOCAL_STACK_FRAME(_hx_pos_6e4d7718bf84d356_149_quadrantIV,"pi_xy.imageAbstracts._TileShape.TileShape_Impl_","quadrantIV",0xcef23a2d,"pi_xy.imageAbstracts._TileShape.TileShape_Impl_.quadrantIV","pi_xy/imageAbstracts/TileShape.hx",149,0xe22daf9c)
HX_LOCAL_STACK_FRAME(_hx_pos_6e4d7718bf84d356_160_sweepTri,"pi_xy.imageAbstracts._TileShape.TileShape_Impl_","sweepTri",0xfdba7ae3,"pi_xy.imageAbstracts._TileShape.TileShape_Impl_.sweepTri","pi_xy/imageAbstracts/TileShape.hx",160,0xe22daf9c)
HX_LOCAL_STACK_FRAME(_hx_pos_6e4d7718bf84d356_177_pie,"pi_xy.imageAbstracts._TileShape.TileShape_Impl_","pie",0xd176ca88,"pi_xy.imageAbstracts._TileShape.TileShape_Impl_.pie","pi_xy/imageAbstracts/TileShape.hx",177,0xe22daf9c)
HX_LOCAL_STACK_FRAME(_hx_pos_6e4d7718bf84d356_219_ellipseTri,"pi_xy.imageAbstracts._TileShape.TileShape_Impl_","ellipseTri",0x3082cc31,"pi_xy.imageAbstracts._TileShape.TileShape_Impl_.ellipseTri","pi_xy/imageAbstracts/TileShape.hx",219,0xe22daf9c)
namespace pi_xy{
namespace imageAbstracts{
namespace _TileShape{

void TileShape_Impl__obj::__construct() { }

Dynamic TileShape_Impl__obj::__CreateEmpty() { return new TileShape_Impl__obj; }

void *TileShape_Impl__obj::_hx_vtable = 0;

Dynamic TileShape_Impl__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< TileShape_Impl__obj > _hx_result = new TileShape_Impl__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool TileShape_Impl__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x2df57026;
}

 ::pi_xy::ImageStruct TileShape_Impl__obj::_new(int w,int h){
            	HX_GC_STACKFRAME(&_hx_pos_6e4d7718bf84d356_15__new)
HXLINE(  17)		 ::Dynamic imageType = null();
HXDLIN(  17)		 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  17)		if (::hx::IsNull( imageType )) {
HXLINE(  17)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXDLIN(  17)		::Dynamic this2;
HXDLIN(  17)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE(  17)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  17)				 ::iterMagic::BytesImg b = byt;
HXDLIN(  17)				{
HXLINE(  17)					b->width = w;
HXDLIN(  17)					b->height = h;
HXDLIN(  17)					b->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  17)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  17)					{
HXLINE(  17)						int len = b->length;
HXDLIN(  17)						int w1 = 0;
HXDLIN(  17)						{
HXLINE(  17)							int _g = 0;
HXDLIN(  17)							int _g1 = b->height;
HXDLIN(  17)							while((_g < _g1)){
HXLINE(  17)								_g = (_g + 1);
HXDLIN(  17)								int y = (_g - 1);
HXDLIN(  17)								{
HXLINE(  17)									int _g2 = 0;
HXDLIN(  17)									int _g3 = b->width;
HXDLIN(  17)									while((_g2 < _g3)){
HXLINE(  17)										_g2 = (_g2 + 1);
HXDLIN(  17)										int x = (_g2 - 1);
HXDLIN(  17)										{
HXLINE(  17)											w1 = (w1 + 1);
HXDLIN(  17)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  17)										{
HXLINE(  17)											w1 = (w1 + 1);
HXDLIN(  17)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  17)										{
HXLINE(  17)											w1 = (w1 + 1);
HXDLIN(  17)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  17)										{
HXLINE(  17)											w1 = (w1 + 1);
HXDLIN(  17)											b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  17)				this2 = b;
            			}
            			break;
            			case (int)1: {
HXLINE(  17)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  17)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  17)				{
HXLINE(  17)					a->width = w;
HXDLIN(  17)					a->height = h;
HXDLIN(  17)					a->data = ::Array_obj< int >::__new(0);
HXDLIN(  17)					a->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  17)					{
HXLINE(  17)						int _g4 = 0;
HXDLIN(  17)						int _g5 = a->length;
HXDLIN(  17)						while((_g4 < _g5)){
HXLINE(  17)							_g4 = (_g4 + 1);
HXDLIN(  17)							int i = (_g4 - 1);
HXDLIN(  17)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN(  17)				this2 = a;
            			}
            			break;
            			case (int)2: {
HXLINE(  17)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  17)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  17)				{
HXLINE(  17)					b1->width = w;
HXDLIN(  17)					b1->height = h;
HXDLIN(  17)					b1->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  17)					int size = (b1->length * 4);
HXDLIN(  17)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  17)					{
HXLINE(  17)						int _g6 = 0;
HXDLIN(  17)						int _g7 = b1->length;
HXDLIN(  17)						while((_g6 < _g7)){
HXLINE(  17)							_g6 = (_g6 + 1);
HXDLIN(  17)							int i1 = (_g6 - 1);
HXDLIN(  17)							{
HXLINE(  17)								 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  17)								bool this4;
HXDLIN(  17)								if ((i1 >= 0)) {
HXLINE(  17)									this4 = (i1 < (this3->byteLength >> 2));
            								}
            								else {
HXLINE(  17)									this4 = false;
            								}
HXDLIN(  17)								if (this4) {
HXLINE(  17)									 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  17)									int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  17)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  17)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  17)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  17)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(  17)				this2 = b1;
            			}
            			break;
            			case (int)3: {
HXLINE(  17)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  17)				 ::iterMagic::VecIntImg v = vec;
HXDLIN(  17)				{
HXLINE(  17)					v->width = w;
HXDLIN(  17)					v->height = h;
HXDLIN(  17)					v->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  17)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  17)					{
HXLINE(  17)						int _g8 = 0;
HXDLIN(  17)						int _g9 = v->length;
HXDLIN(  17)						while((_g8 < _g9)){
HXLINE(  17)							_g8 = (_g8 + 1);
HXDLIN(  17)							int i2 = (_g8 - 1);
HXDLIN(  17)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN(  17)				this2 = v;
            			}
            			break;
            			case (int)4: {
HXLINE(  17)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  17)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  17)				{
HXLINE(  17)					b2->width = w;
HXDLIN(  17)					b2->height = h;
HXDLIN(  17)					b2->length = ::Std_obj::_hx_int(( (Float)((w * h)) ));
HXDLIN(  17)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  17)					{
HXLINE(  17)						int len1 = b2->length;
HXDLIN(  17)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  17)						if (::hx::IsNull( d->head )) {
HXLINE(  17)							int _g10 = 0;
HXDLIN(  17)							int _g11 = len1;
HXDLIN(  17)							while((_g10 < _g11)){
HXLINE(  17)								_g10 = (_g10 + 1);
HXDLIN(  17)								int i3 = (_g10 - 1);
HXDLIN(  17)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE(  17)							int _g12 = 0;
HXDLIN(  17)							int _g13 = len1;
HXDLIN(  17)							while((_g12 < _g13)){
HXLINE(  17)								_g12 = (_g12 + 1);
HXDLIN(  17)								int i4 = (_g12 - 1);
HXDLIN(  17)								{
HXLINE(  17)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  17)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  17)									{
HXLINE(  17)										int _g14 = 0;
HXDLIN(  17)										int _g15 = i4;
HXDLIN(  17)										while((_g14 < _g15)){
HXLINE(  17)											_g14 = (_g14 + 1);
HXDLIN(  17)											int i5 = (_g14 - 1);
HXDLIN(  17)											prev = l;
HXDLIN(  17)											l = l->next;
            										}
            									}
HXDLIN(  17)									if (::hx::IsNull( prev )) {
HXLINE(  17)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  17)										l = null();
            									}
            									else {
HXLINE(  17)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  17)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  17)				this2 = b2;
            			}
            			break;
            		}
HXDLIN(  17)		this1->image = this2;
HXDLIN(  17)		this1->width = w;
HXDLIN(  17)		this1->height = h;
HXDLIN(  17)		this1->imageType = ( (int)(imageType) );
HXLINE(  15)		return this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(TileShape_Impl__obj,_new,return )

 ::pi_xy::algo::HitTri TileShape_Impl__obj::triangle( ::pi_xy::ImageStruct this1,Float ax,Float ay,Float bx,Float by,Float cx,Float cy, ::pi_xy::ImageStruct tileImage,::hx::Null< bool >  __o_hasHit){
            		bool hasHit = __o_hasHit.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_6e4d7718bf84d356_25_triangle)
HXDLIN(  25)		Float bx1 = bx;
HXDLIN(  25)		Float by1 = by;
HXDLIN(  25)		Float cx1 = cx;
HXDLIN(  25)		Float cy1 = cy;
HXDLIN(  25)		bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN(  25)		if (!(adjustWinding)) {
HXDLIN(  25)			Float bx_ = bx1;
HXDLIN(  25)			Float by_ = by1;
HXLINE( 187)			bx1 = cx1;
HXLINE( 188)			by1 = cy1;
HXLINE( 189)			cx1 = bx_;
HXLINE( 190)			cy1 = by_;
            		}
HXLINE(  25)		bool hasUndo = false;
HXDLIN(  25)		Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN(  25)		Float sx = (cy1 - ay);
HXDLIN(  25)		Float sy = (ax - cx1);
HXDLIN(  25)		Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN(  25)		Float tx = (ay - by1);
HXDLIN(  25)		Float ty = (bx1 - ax);
HXDLIN(  25)		Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN(  25)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  25)		if ((ax > bx1)) {
HXDLIN(  25)			if ((ax > cx1)) {
HXDLIN(  25)				int min;
HXDLIN(  25)				if ((bx1 > cx1)) {
HXDLIN(  25)					min = ::Math_obj::floor(cx1);
            				}
            				else {
HXDLIN(  25)					min = ::Math_obj::floor(bx1);
            				}
HXDLIN(  25)				int ii_min = min;
HXDLIN(  25)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  25)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXDLIN(  25)				int ii_min1 = ::Math_obj::floor(bx1);
HXDLIN(  25)				int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN(  25)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXDLIN(  25)			if ((bx1 > cx1)) {
HXDLIN(  25)				int min1;
HXDLIN(  25)				if ((ax > cx1)) {
HXDLIN(  25)					min1 = ::Math_obj::floor(cx1);
            				}
            				else {
HXDLIN(  25)					min1 = ::Math_obj::ceil(ax);
            				}
HXDLIN(  25)				int ii_min2 = min1;
HXDLIN(  25)				int ii_max2 = ::Math_obj::ceil(bx1);
HXDLIN(  25)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXDLIN(  25)				int ii_min3 = ::Math_obj::floor(ax);
HXDLIN(  25)				int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN(  25)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXDLIN(  25)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  25)		if ((ay > by1)) {
HXDLIN(  25)			if ((ay > cy1)) {
HXDLIN(  25)				int min2;
HXDLIN(  25)				if ((by1 > cy1)) {
HXDLIN(  25)					min2 = ::Math_obj::floor(cy1);
            				}
            				else {
HXDLIN(  25)					min2 = ::Math_obj::floor(by1);
            				}
HXDLIN(  25)				int ii_min4 = min2;
HXDLIN(  25)				int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN(  25)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXDLIN(  25)				int ii_min5 = ::Math_obj::floor(by1);
HXDLIN(  25)				int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN(  25)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXDLIN(  25)			if ((by1 > cy1)) {
HXDLIN(  25)				int min3;
HXDLIN(  25)				if ((ay > cy1)) {
HXDLIN(  25)					min3 = ::Math_obj::floor(cy1);
            				}
            				else {
HXDLIN(  25)					min3 = ::Math_obj::ceil(ay);
            				}
HXDLIN(  25)				int ii_min6 = min3;
HXDLIN(  25)				int ii_max6 = ::Math_obj::ceil(by1);
HXDLIN(  25)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXDLIN(  25)				int ii_min7 = ::Math_obj::floor(ay);
HXDLIN(  25)				int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN(  25)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXDLIN(  25)		 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  25)		if (hasUndo) {
HXDLIN(  25)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  25)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  25)			 ::Dynamic imageType = null();
HXDLIN(  25)			 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  25)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE(  25)			::Dynamic undoImage1;
HXDLIN(  25)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXDLIN(  25)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  25)					 ::iterMagic::BytesImg b = byt;
HXDLIN(  25)					{
HXDLIN(  25)						b->width = width;
HXDLIN(  25)						b->height = height;
HXDLIN(  25)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  25)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  25)						{
HXDLIN(  25)							int len = b->length;
HXDLIN(  25)							int w = 0;
HXDLIN(  25)							{
HXDLIN(  25)								int _g = 0;
HXDLIN(  25)								int _g1 = b->height;
HXDLIN(  25)								while((_g < _g1)){
HXDLIN(  25)									_g = (_g + 1);
HXDLIN(  25)									int y = (_g - 1);
HXDLIN(  25)									{
HXDLIN(  25)										int _g2 = 0;
HXDLIN(  25)										int _g3 = b->width;
HXDLIN(  25)										while((_g2 < _g3)){
HXDLIN(  25)											_g2 = (_g2 + 1);
HXDLIN(  25)											int x = (_g2 - 1);
HXDLIN(  25)											{
HXDLIN(  25)												w = (w + 1);
HXDLIN(  25)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  25)											{
HXDLIN(  25)												w = (w + 1);
HXDLIN(  25)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  25)											{
HXDLIN(  25)												w = (w + 1);
HXDLIN(  25)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  25)											{
HXDLIN(  25)												w = (w + 1);
HXDLIN(  25)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  25)					undoImage1 = b;
            				}
            				break;
            				case (int)1: {
HXDLIN(  25)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  25)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  25)					{
HXDLIN(  25)						a->width = width;
HXDLIN(  25)						a->height = height;
HXDLIN(  25)						a->data = ::Array_obj< int >::__new(0);
HXDLIN(  25)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  25)						{
HXDLIN(  25)							int _g4 = 0;
HXDLIN(  25)							int _g5 = a->length;
HXDLIN(  25)							while((_g4 < _g5)){
HXDLIN(  25)								_g4 = (_g4 + 1);
HXDLIN(  25)								int i = (_g4 - 1);
HXDLIN(  25)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN(  25)					undoImage1 = a;
            				}
            				break;
            				case (int)2: {
HXDLIN(  25)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  25)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  25)					{
HXDLIN(  25)						b1->width = width;
HXDLIN(  25)						b1->height = height;
HXDLIN(  25)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  25)						int size = (b1->length * 4);
HXDLIN(  25)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  25)						{
HXDLIN(  25)							int _g6 = 0;
HXDLIN(  25)							int _g7 = b1->length;
HXDLIN(  25)							while((_g6 < _g7)){
HXDLIN(  25)								_g6 = (_g6 + 1);
HXDLIN(  25)								int i1 = (_g6 - 1);
HXDLIN(  25)								{
HXDLIN(  25)									 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  25)									bool undoImage2;
HXDLIN(  25)									if ((i1 >= 0)) {
HXDLIN(  25)										undoImage2 = (i1 < (this3->byteLength >> 2));
            									}
            									else {
HXDLIN(  25)										undoImage2 = false;
            									}
HXDLIN(  25)									if (undoImage2) {
HXDLIN(  25)										 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  25)										int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  25)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  25)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  25)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  25)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN(  25)					undoImage1 = b1;
            				}
            				break;
            				case (int)3: {
HXDLIN(  25)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  25)					 ::iterMagic::VecIntImg v = vec;
HXDLIN(  25)					{
HXDLIN(  25)						v->width = width;
HXDLIN(  25)						v->height = height;
HXDLIN(  25)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  25)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  25)						{
HXDLIN(  25)							int _g8 = 0;
HXDLIN(  25)							int _g9 = v->length;
HXDLIN(  25)							while((_g8 < _g9)){
HXDLIN(  25)								_g8 = (_g8 + 1);
HXDLIN(  25)								int i2 = (_g8 - 1);
HXDLIN(  25)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN(  25)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXDLIN(  25)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  25)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  25)					{
HXDLIN(  25)						b2->width = width;
HXDLIN(  25)						b2->height = height;
HXDLIN(  25)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  25)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  25)						{
HXDLIN(  25)							int len1 = b2->length;
HXDLIN(  25)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  25)							if (::hx::IsNull( d->head )) {
HXDLIN(  25)								int _g10 = 0;
HXDLIN(  25)								int _g11 = len1;
HXDLIN(  25)								while((_g10 < _g11)){
HXDLIN(  25)									_g10 = (_g10 + 1);
HXDLIN(  25)									int i3 = (_g10 - 1);
HXDLIN(  25)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXDLIN(  25)								int _g12 = 0;
HXDLIN(  25)								int _g13 = len1;
HXDLIN(  25)								while((_g12 < _g13)){
HXDLIN(  25)									_g12 = (_g12 + 1);
HXDLIN(  25)									int i4 = (_g12 - 1);
HXDLIN(  25)									{
HXDLIN(  25)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  25)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  25)										{
HXDLIN(  25)											int _g14 = 0;
HXDLIN(  25)											int _g15 = i4;
HXDLIN(  25)											while((_g14 < _g15)){
HXDLIN(  25)												_g14 = (_g14 + 1);
HXDLIN(  25)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE(  25)										if (::hx::IsNull( prev )) {
HXDLIN(  25)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  25)											l = null();
            										}
            										else {
HXDLIN(  25)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  25)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  25)					undoImage1 = b2;
            				}
            				break;
            			}
HXDLIN(  25)			this2->image = undoImage1;
HXDLIN(  25)			this2->width = width;
HXDLIN(  25)			this2->height = height;
HXDLIN(  25)			this2->imageType = ( (int)(imageType) );
HXDLIN(  25)			undoImage = this2;
HXDLIN(  25)			{
HXDLIN(  25)				int rectLeft = xIter3->start;
HXDLIN(  25)				int rectTop = yIter3->start;
HXDLIN(  25)				int rectRight = xIter3->max;
HXDLIN(  25)				bool forceClear = false;
HXDLIN(  25)				{
HXDLIN(  25)					int _g16 = rectTop;
HXDLIN(  25)					int _g17 = yIter3->max;
HXDLIN(  25)					while((_g16 < _g17)){
HXDLIN(  25)						_g16 = (_g16 + 1);
HXDLIN(  25)						int dy = (_g16 - 1);
HXDLIN(  25)						{
HXDLIN(  25)							int _g18 = rectLeft;
HXDLIN(  25)							int _g19 = rectRight;
HXDLIN(  25)							while((_g18 < _g19)){
HXDLIN(  25)								_g18 = (_g18 + 1);
HXDLIN(  25)								int dx = (_g18 - 1);
HXDLIN(  25)								::Dynamic this4 = this1->image;
HXDLIN(  25)								int index;
HXDLIN(  25)								if (this1->useVirtualPos) {
HXDLIN(  25)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            								}
            								else {
HXDLIN(  25)									index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            								}
HXDLIN(  25)								int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN(  25)								int col;
HXDLIN(  25)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  25)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXDLIN(  25)									col = c;
            								}
HXDLIN(  25)								bool _hx_tmp;
HXDLIN(  25)								if (this1->useMask) {
HXDLIN(  25)									_hx_tmp = ::hx::IsNotNull( this1->mask );
            								}
            								else {
HXDLIN(  25)									_hx_tmp = false;
            								}
HXDLIN(  25)								if (_hx_tmp) {
HXDLIN(  25)									 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN(  25)									::Dynamic this6 = this5->image;
HXDLIN(  25)									int index1;
HXDLIN(  25)									if (this5->useVirtualPos) {
HXDLIN(  25)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx) - this5->virtualX));
            									}
            									else {
HXDLIN(  25)										index1 = ::Std_obj::_hx_int(( (Float)(((dy * this5->width) + dx)) ));
            									}
HXDLIN(  25)									int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN(  25)									int v1;
HXDLIN(  25)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  25)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXDLIN(  25)										v1 = c1;
            									}
HXDLIN(  25)									int maskPixel = v1;
HXDLIN(  25)									int this7 = col;
HXDLIN(  25)									if ((maskPixel == 0)) {
HXDLIN(  25)										col = this7;
            									}
            									else {
HXDLIN(  25)										Float m0;
HXDLIN(  25)										int this8 = ((maskPixel >> 24) & 255);
HXDLIN(  25)										if ((this8 == 0)) {
HXDLIN(  25)											m0 = ((Float)0.);
            										}
            										else {
HXDLIN(  25)											m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										Float m1;
HXDLIN(  25)										int this9 = ((maskPixel >> 16) & 255);
HXDLIN(  25)										if ((this9 == 0)) {
HXDLIN(  25)											m1 = ((Float)0.);
            										}
            										else {
HXDLIN(  25)											m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										Float m2;
HXDLIN(  25)										int this10 = ((maskPixel >> 8) & 255);
HXDLIN(  25)										if ((this10 == 0)) {
HXDLIN(  25)											m2 = ((Float)0.);
            										}
            										else {
HXDLIN(  25)											m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										Float m3;
HXDLIN(  25)										int this11 = (maskPixel & 255);
HXDLIN(  25)										if ((this11 == 0)) {
HXDLIN(  25)											m3 = ((Float)0.);
            										}
            										else {
HXDLIN(  25)											m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN(  25)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN(  25)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN(  25)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN(  25)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN(  25)								if ((col != 0)) {
HXDLIN(  25)									int x1 = (dx - rectLeft);
HXDLIN(  25)									int y1 = (dy - rectTop);
HXDLIN(  25)									int c2 = col;
HXDLIN(  25)									bool _hx_tmp1;
HXDLIN(  25)									if ((((c2 >> 24) & 255) < 254)) {
HXDLIN(  25)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXDLIN(  25)										_hx_tmp1 = false;
            									}
HXDLIN(  25)									if (_hx_tmp1) {
HXDLIN(  25)										int location;
HXDLIN(  25)										if (undoImage->useVirtualPos) {
HXDLIN(  25)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXDLIN(  25)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN(  25)										int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN(  25)										int this13;
HXDLIN(  25)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  25)											this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            										}
            										else {
HXDLIN(  25)											this13 = this12;
            										}
HXDLIN(  25)										Float a1;
HXDLIN(  25)										int this14 = ((this13 >> 24) & 255);
HXDLIN(  25)										if ((this14 == 0)) {
HXDLIN(  25)											a1 = ((Float)0.);
            										}
            										else {
HXDLIN(  25)											a1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										Float r1;
HXDLIN(  25)										int this15 = ((this13 >> 16) & 255);
HXDLIN(  25)										if ((this15 == 0)) {
HXDLIN(  25)											r1 = ((Float)0.);
            										}
            										else {
HXDLIN(  25)											r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										Float g1;
HXDLIN(  25)										int this16 = ((this13 >> 8) & 255);
HXDLIN(  25)										if ((this16 == 0)) {
HXDLIN(  25)											g1 = ((Float)0.);
            										}
            										else {
HXDLIN(  25)											g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										Float b11;
HXDLIN(  25)										int this17 = (this13 & 255);
HXDLIN(  25)										if ((this17 == 0)) {
HXDLIN(  25)											b11 = ((Float)0.);
            										}
            										else {
HXDLIN(  25)											b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										Float a2;
HXDLIN(  25)										int this18 = ((col >> 24) & 255);
HXDLIN(  25)										if ((this18 == 0)) {
HXDLIN(  25)											a2 = ((Float)0.);
            										}
            										else {
HXDLIN(  25)											a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										Float r2;
HXDLIN(  25)										int this19 = ((col >> 16) & 255);
HXDLIN(  25)										if ((this19 == 0)) {
HXDLIN(  25)											r2 = ((Float)0.);
            										}
            										else {
HXDLIN(  25)											r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										Float g2;
HXDLIN(  25)										int this20 = ((col >> 8) & 255);
HXDLIN(  25)										if ((this20 == 0)) {
HXDLIN(  25)											g2 = ((Float)0.);
            										}
            										else {
HXDLIN(  25)											g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										Float b21;
HXDLIN(  25)										int this21 = (col & 255);
HXDLIN(  25)										if ((this21 == 0)) {
HXDLIN(  25)											b21 = ((Float)0.);
            										}
            										else {
HXDLIN(  25)											b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  25)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  25)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  25)										int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  25)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  25)										int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  25)										{
HXDLIN(  25)											int _hx_tmp2;
HXDLIN(  25)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  25)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXDLIN(  25)												_hx_tmp2 = blended;
            											}
HXDLIN(  25)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXDLIN(  25)										::Dynamic this22 = undoImage->image;
HXDLIN(  25)										int index2;
HXDLIN(  25)										if (undoImage->useVirtualPos) {
HXDLIN(  25)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXDLIN(  25)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN(  25)										int _hx_tmp3;
HXDLIN(  25)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  25)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXDLIN(  25)											_hx_tmp3 = c2;
            										}
HXDLIN(  25)										::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp3);
            									}
            								}
            								else {
HXDLIN(  25)									if (forceClear) {
HXDLIN(  25)										::Dynamic this23 = undoImage->image;
HXDLIN(  25)										int x2 = (dx - rectLeft);
HXDLIN(  25)										int y2 = (dy - rectTop);
HXDLIN(  25)										int index3;
HXDLIN(  25)										if (undoImage->useVirtualPos) {
HXDLIN(  25)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXDLIN(  25)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN(  25)										::iterMagic::Iimg_obj::set(this23,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN(  25)		bool foundY = false;
HXDLIN(  25)		Float s = ((Float)0.);
HXDLIN(  25)		Float t = ((Float)0.);
HXDLIN(  25)		Float sxx = ((Float)0.);
HXDLIN(  25)		Float txx = ((Float)0.);
HXDLIN(  25)		{
HXDLIN(  25)			int _g_min = xIter3->start;
HXDLIN(  25)			int _g_max = xIter3->max;
HXDLIN(  25)			while((_g_min < _g_max)){
HXDLIN(  25)				_g_min = (_g_min + 1);
HXDLIN(  25)				int x3 = (_g_min - 1);
HXLINE( 222)				sxx = (sx * ( (Float)(x3) ));
HXLINE( 223)				txx = (tx * ( (Float)(x3) ));
HXLINE( 224)				foundY = false;
HXLINE(  25)				{
HXDLIN(  25)					int _g_min1 = yIter3->start;
HXDLIN(  25)					int _g_max1 = yIter3->max;
HXDLIN(  25)					while((_g_min1 < _g_max1)){
HXDLIN(  25)						_g_min1 = (_g_min1 + 1);
HXDLIN(  25)						int y3 = (_g_min1 - 1);
HXLINE( 226)						s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE( 227)						t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE(  25)						bool _hx_tmp4;
HXDLIN(  25)						if (!((s <= 0))) {
HXDLIN(  25)							_hx_tmp4 = (t <= 0);
            						}
            						else {
HXDLIN(  25)							_hx_tmp4 = true;
            						}
HXDLIN(  25)						if (_hx_tmp4) {
HXDLIN(  25)							if (foundY) {
HXDLIN(  25)								goto _hx_goto_20;
            							}
            						}
            						else {
HXDLIN(  25)							if (((s + t) < A)) {
HXDLIN(  25)								int x4 = ::hx::Mod(x3,tileImage->width);
HXDLIN(  25)								int y4 = ::hx::Mod(y3,tileImage->height);
HXDLIN(  25)								::Dynamic this24 = tileImage->image;
HXDLIN(  25)								int index4;
HXDLIN(  25)								if (tileImage->useVirtualPos) {
HXDLIN(  25)									index4 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x4) - tileImage->virtualX));
            								}
            								else {
HXDLIN(  25)									index4 = ::Std_obj::_hx_int(( (Float)(((y4 * tileImage->width) + x4)) ));
            								}
HXDLIN(  25)								int c3 = ::iterMagic::Iimg_obj::get(this24,index4);
HXDLIN(  25)								int color;
HXDLIN(  25)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  25)									color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            								}
            								else {
HXDLIN(  25)									color = c3;
            								}
HXDLIN(  25)								{
HXDLIN(  25)									int c4 = color;
HXDLIN(  25)									bool _hx_tmp5;
HXDLIN(  25)									if ((((c4 >> 24) & 255) < 254)) {
HXDLIN(  25)										_hx_tmp5 = this1->transparent;
            									}
            									else {
HXDLIN(  25)										_hx_tmp5 = false;
            									}
HXDLIN(  25)									if (_hx_tmp5) {
HXDLIN(  25)										int location1;
HXDLIN(  25)										if (this1->useVirtualPos) {
HXDLIN(  25)											location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            										}
            										else {
HXDLIN(  25)											location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            										}
HXDLIN(  25)										int this25 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN(  25)										int this26;
HXDLIN(  25)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  25)											this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            										}
            										else {
HXDLIN(  25)											this26 = this25;
            										}
HXDLIN(  25)										Float a11;
HXDLIN(  25)										int this27 = ((this26 >> 24) & 255);
HXDLIN(  25)										if ((this27 == 0)) {
HXDLIN(  25)											a11 = ((Float)0.);
            										}
            										else {
HXDLIN(  25)											a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										Float r11;
HXDLIN(  25)										int this28 = ((this26 >> 16) & 255);
HXDLIN(  25)										if ((this28 == 0)) {
HXDLIN(  25)											r11 = ((Float)0.);
            										}
            										else {
HXDLIN(  25)											r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										Float g11;
HXDLIN(  25)										int this29 = ((this26 >> 8) & 255);
HXDLIN(  25)										if ((this29 == 0)) {
HXDLIN(  25)											g11 = ((Float)0.);
            										}
            										else {
HXDLIN(  25)											g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										Float b12;
HXDLIN(  25)										int this30 = (this26 & 255);
HXDLIN(  25)										if ((this30 == 0)) {
HXDLIN(  25)											b12 = ((Float)0.);
            										}
            										else {
HXDLIN(  25)											b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										Float a21;
HXDLIN(  25)										int this31 = ((color >> 24) & 255);
HXDLIN(  25)										if ((this31 == 0)) {
HXDLIN(  25)											a21 = ((Float)0.);
            										}
            										else {
HXDLIN(  25)											a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										Float r21;
HXDLIN(  25)										int this32 = ((color >> 16) & 255);
HXDLIN(  25)										if ((this32 == 0)) {
HXDLIN(  25)											r21 = ((Float)0.);
            										}
            										else {
HXDLIN(  25)											r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										Float g21;
HXDLIN(  25)										int this33 = ((color >> 8) & 255);
HXDLIN(  25)										if ((this33 == 0)) {
HXDLIN(  25)											g21 = ((Float)0.);
            										}
            										else {
HXDLIN(  25)											g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										Float b22;
HXDLIN(  25)										int this34 = (color & 255);
HXDLIN(  25)										if ((this34 == 0)) {
HXDLIN(  25)											b22 = ((Float)0.);
            										}
            										else {
HXDLIN(  25)											b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            										}
HXDLIN(  25)										Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  25)										int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  25)										int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  25)										int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  25)										int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  25)										int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  25)										{
HXDLIN(  25)											int _hx_tmp6;
HXDLIN(  25)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  25)												_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXDLIN(  25)												_hx_tmp6 = blended1;
            											}
HXDLIN(  25)											::iterMagic::Iimg_obj::set(this1->image,location1,_hx_tmp6);
            										}
            									}
            									else {
HXDLIN(  25)										::Dynamic this35 = this1->image;
HXDLIN(  25)										int index5;
HXDLIN(  25)										if (this1->useVirtualPos) {
HXDLIN(  25)											index5 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            										}
            										else {
HXDLIN(  25)											index5 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            										}
HXDLIN(  25)										int _hx_tmp7;
HXDLIN(  25)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  25)											_hx_tmp7 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            										}
            										else {
HXDLIN(  25)											_hx_tmp7 = c4;
            										}
HXDLIN(  25)										::iterMagic::Iimg_obj::set(this35,index5,_hx_tmp7);
            									}
            								}
HXLINE( 236)								foundY = true;
            							}
            							else {
HXDLIN(  25)								if (foundY) {
HXDLIN(  25)									goto _hx_goto_20;
            								}
            							}
            						}
            					}
            					_hx_goto_20:;
            				}
            			}
            		}
HXDLIN(  25)		if ((hasHit == false)) {
HXDLIN(  25)			 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx1,by1,cx1,cy1,true);
HXDLIN(  25)			if (hasUndo) {
HXDLIN(  25)				v2->undoImage = undoImage;
HXDLIN(  25)				v2->undoX = xIter3->start;
HXDLIN(  25)				v2->undoY = yIter3->start;
            			}
HXDLIN(  25)			return v2;
            		}
            		else {
HXDLIN(  25)			return null();
            		}
HXDLIN(  25)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(TileShape_Impl__obj,triangle,return )

 ::pi_xy::algo::HitQuad TileShape_Impl__obj::quad( ::pi_xy::ImageStruct this1,Float ax,Float ay,Float bx,Float by,Float cx,Float cy,Float dx,Float dy, ::pi_xy::ImageStruct tileImage,::hx::Null< bool >  __o_hasHit){
            		bool hasHit = __o_hasHit.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_6e4d7718bf84d356_37_quad)
HXDLIN(  37)		{
HXDLIN(  37)			Float bx1 = bx;
HXDLIN(  37)			Float by1 = by;
HXDLIN(  37)			Float cx1 = dx;
HXDLIN(  37)			Float cy1 = dy;
HXDLIN(  37)			bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN(  37)			if (!(adjustWinding)) {
HXDLIN(  37)				Float bx_ = bx1;
HXDLIN(  37)				Float by_ = by1;
HXLINE( 187)				bx1 = cx1;
HXLINE( 188)				by1 = cy1;
HXLINE( 189)				cx1 = bx_;
HXLINE( 190)				cy1 = by_;
            			}
HXLINE(  37)			{
HXDLIN(  37)				bool hasUndo = false;
HXDLIN(  37)				Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN(  37)				Float sx = (cy1 - ay);
HXDLIN(  37)				Float sy = (ax - cx1);
HXDLIN(  37)				Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN(  37)				Float tx = (ay - by1);
HXDLIN(  37)				Float ty = (bx1 - ax);
HXDLIN(  37)				Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN(  37)				 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  37)				if ((ax > bx1)) {
HXDLIN(  37)					if ((ax > cx1)) {
HXDLIN(  37)						int min;
HXDLIN(  37)						if ((bx1 > cx1)) {
HXDLIN(  37)							min = ::Math_obj::floor(cx1);
            						}
            						else {
HXDLIN(  37)							min = ::Math_obj::floor(bx1);
            						}
HXDLIN(  37)						int ii_min = min;
HXDLIN(  37)						int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  37)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            					}
            					else {
HXDLIN(  37)						int ii_min1 = ::Math_obj::floor(bx1);
HXDLIN(  37)						int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN(  37)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            					}
            				}
            				else {
HXDLIN(  37)					if ((bx1 > cx1)) {
HXDLIN(  37)						int min1;
HXDLIN(  37)						if ((ax > cx1)) {
HXDLIN(  37)							min1 = ::Math_obj::floor(cx1);
            						}
            						else {
HXDLIN(  37)							min1 = ::Math_obj::ceil(ax);
            						}
HXDLIN(  37)						int ii_min2 = min1;
HXDLIN(  37)						int ii_max2 = ::Math_obj::ceil(bx1);
HXDLIN(  37)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            					}
            					else {
HXDLIN(  37)						int ii_min3 = ::Math_obj::floor(ax);
HXDLIN(  37)						int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN(  37)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            					}
            				}
HXDLIN(  37)				 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  37)				if ((ay > by1)) {
HXDLIN(  37)					if ((ay > cy1)) {
HXDLIN(  37)						int min2;
HXDLIN(  37)						if ((by1 > cy1)) {
HXDLIN(  37)							min2 = ::Math_obj::floor(cy1);
            						}
            						else {
HXDLIN(  37)							min2 = ::Math_obj::floor(by1);
            						}
HXDLIN(  37)						int ii_min4 = min2;
HXDLIN(  37)						int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN(  37)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            					}
            					else {
HXDLIN(  37)						int ii_min5 = ::Math_obj::floor(by1);
HXDLIN(  37)						int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN(  37)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            					}
            				}
            				else {
HXDLIN(  37)					if ((by1 > cy1)) {
HXDLIN(  37)						int min3;
HXDLIN(  37)						if ((ay > cy1)) {
HXDLIN(  37)							min3 = ::Math_obj::floor(cy1);
            						}
            						else {
HXDLIN(  37)							min3 = ::Math_obj::ceil(ay);
            						}
HXDLIN(  37)						int ii_min6 = min3;
HXDLIN(  37)						int ii_max6 = ::Math_obj::ceil(by1);
HXDLIN(  37)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            					}
            					else {
HXDLIN(  37)						int ii_min7 = ::Math_obj::floor(ay);
HXDLIN(  37)						int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN(  37)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            					}
            				}
HXDLIN(  37)				 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  37)				if (hasUndo) {
HXDLIN(  37)					int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  37)					int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  37)					 ::Dynamic imageType = null();
HXDLIN(  37)					 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  37)					if (::hx::IsNull( imageType )) {
HXLINE(  54)						imageType = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE(  37)					::Dynamic undoImage1;
HXDLIN(  37)					switch((int)(( (int)(imageType) ))){
            						case (int)0: {
HXDLIN(  37)							 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  37)							 ::iterMagic::BytesImg b = byt;
HXDLIN(  37)							{
HXDLIN(  37)								b->width = width;
HXDLIN(  37)								b->height = height;
HXDLIN(  37)								b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  37)								b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  37)								{
HXDLIN(  37)									int len = b->length;
HXDLIN(  37)									int w = 0;
HXDLIN(  37)									{
HXDLIN(  37)										int _g = 0;
HXDLIN(  37)										int _g1 = b->height;
HXDLIN(  37)										while((_g < _g1)){
HXDLIN(  37)											_g = (_g + 1);
HXDLIN(  37)											int y = (_g - 1);
HXDLIN(  37)											{
HXDLIN(  37)												int _g2 = 0;
HXDLIN(  37)												int _g3 = b->width;
HXDLIN(  37)												while((_g2 < _g3)){
HXDLIN(  37)													_g2 = (_g2 + 1);
HXDLIN(  37)													int x = (_g2 - 1);
HXDLIN(  37)													{
HXDLIN(  37)														w = (w + 1);
HXDLIN(  37)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  37)													{
HXDLIN(  37)														w = (w + 1);
HXDLIN(  37)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  37)													{
HXDLIN(  37)														w = (w + 1);
HXDLIN(  37)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  37)													{
HXDLIN(  37)														w = (w + 1);
HXDLIN(  37)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  37)							undoImage1 = b;
            						}
            						break;
            						case (int)1: {
HXDLIN(  37)							 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  37)							 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  37)							{
HXDLIN(  37)								a->width = width;
HXDLIN(  37)								a->height = height;
HXDLIN(  37)								a->data = ::Array_obj< int >::__new(0);
HXDLIN(  37)								a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  37)								{
HXDLIN(  37)									int _g4 = 0;
HXDLIN(  37)									int _g5 = a->length;
HXDLIN(  37)									while((_g4 < _g5)){
HXDLIN(  37)										_g4 = (_g4 + 1);
HXDLIN(  37)										int i = (_g4 - 1);
HXDLIN(  37)										a->data[i] = 0;
            									}
            								}
            							}
HXDLIN(  37)							undoImage1 = a;
            						}
            						break;
            						case (int)2: {
HXDLIN(  37)							 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  37)							 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  37)							{
HXDLIN(  37)								b1->width = width;
HXDLIN(  37)								b1->height = height;
HXDLIN(  37)								b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  37)								int size = (b1->length * 4);
HXDLIN(  37)								b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  37)								{
HXDLIN(  37)									int _g6 = 0;
HXDLIN(  37)									int _g7 = b1->length;
HXDLIN(  37)									while((_g6 < _g7)){
HXDLIN(  37)										_g6 = (_g6 + 1);
HXDLIN(  37)										int i1 = (_g6 - 1);
HXDLIN(  37)										{
HXDLIN(  37)											 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  37)											bool undoImage2;
HXDLIN(  37)											if ((i1 >= 0)) {
HXDLIN(  37)												undoImage2 = (i1 < (this3->byteLength >> 2));
            											}
            											else {
HXDLIN(  37)												undoImage2 = false;
            											}
HXDLIN(  37)											if (undoImage2) {
HXDLIN(  37)												 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  37)												int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  37)												_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  37)												_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  37)												_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  37)												_this->b[(pos + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN(  37)							undoImage1 = b1;
            						}
            						break;
            						case (int)3: {
HXDLIN(  37)							 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  37)							 ::iterMagic::VecIntImg v = vec;
HXDLIN(  37)							{
HXDLIN(  37)								v->width = width;
HXDLIN(  37)								v->height = height;
HXDLIN(  37)								v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  37)								v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  37)								{
HXDLIN(  37)									int _g8 = 0;
HXDLIN(  37)									int _g9 = v->length;
HXDLIN(  37)									while((_g8 < _g9)){
HXDLIN(  37)										_g8 = (_g8 + 1);
HXDLIN(  37)										int i2 = (_g8 - 1);
HXDLIN(  37)										v->data->__unsafe_set(i2,0);
            									}
            								}
            							}
HXDLIN(  37)							undoImage1 = v;
            						}
            						break;
            						case (int)4: {
HXDLIN(  37)							 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  37)							 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  37)							{
HXDLIN(  37)								b2->width = width;
HXDLIN(  37)								b2->height = height;
HXDLIN(  37)								b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  37)								b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  37)								{
HXDLIN(  37)									int len1 = b2->length;
HXDLIN(  37)									 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  37)									if (::hx::IsNull( d->head )) {
HXDLIN(  37)										int _g10 = 0;
HXDLIN(  37)										int _g11 = len1;
HXDLIN(  37)										while((_g10 < _g11)){
HXDLIN(  37)											_g10 = (_g10 + 1);
HXDLIN(  37)											int i3 = (_g10 - 1);
HXDLIN(  37)											d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            										}
            									}
            									else {
HXDLIN(  37)										int _g12 = 0;
HXDLIN(  37)										int _g13 = len1;
HXDLIN(  37)										while((_g12 < _g13)){
HXDLIN(  37)											_g12 = (_g12 + 1);
HXDLIN(  37)											int i4 = (_g12 - 1);
HXDLIN(  37)											{
HXDLIN(  37)												 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  37)												 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  37)												{
HXDLIN(  37)													int _g14 = 0;
HXDLIN(  37)													int _g15 = i4;
HXDLIN(  37)													while((_g14 < _g15)){
HXDLIN(  37)														_g14 = (_g14 + 1);
HXDLIN(  37)														int i5 = (_g14 - 1);
HXLINE( 345)														prev = l;
HXLINE( 346)														l = l->next;
            													}
            												}
HXLINE(  37)												if (::hx::IsNull( prev )) {
HXDLIN(  37)													b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  37)													l = null();
            												}
            												else {
HXDLIN(  37)													prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  37)													l = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  37)							undoImage1 = b2;
            						}
            						break;
            					}
HXDLIN(  37)					this2->image = undoImage1;
HXDLIN(  37)					this2->width = width;
HXDLIN(  37)					this2->height = height;
HXDLIN(  37)					this2->imageType = ( (int)(imageType) );
HXDLIN(  37)					undoImage = this2;
HXDLIN(  37)					{
HXDLIN(  37)						int rectLeft = xIter3->start;
HXDLIN(  37)						int rectTop = yIter3->start;
HXDLIN(  37)						int rectRight = xIter3->max;
HXDLIN(  37)						bool forceClear = false;
HXDLIN(  37)						{
HXDLIN(  37)							int _g16 = rectTop;
HXDLIN(  37)							int _g17 = yIter3->max;
HXDLIN(  37)							while((_g16 < _g17)){
HXDLIN(  37)								_g16 = (_g16 + 1);
HXDLIN(  37)								int dy1 = (_g16 - 1);
HXDLIN(  37)								{
HXDLIN(  37)									int _g18 = rectLeft;
HXDLIN(  37)									int _g19 = rectRight;
HXDLIN(  37)									while((_g18 < _g19)){
HXDLIN(  37)										_g18 = (_g18 + 1);
HXDLIN(  37)										int dx1 = (_g18 - 1);
HXDLIN(  37)										::Dynamic this4 = this1->image;
HXDLIN(  37)										int index;
HXDLIN(  37)										if (this1->useVirtualPos) {
HXDLIN(  37)											index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx1) - this1->virtualX));
            										}
            										else {
HXDLIN(  37)											index = ::Std_obj::_hx_int(( (Float)(((dy1 * this1->width) + dx1)) ));
            										}
HXDLIN(  37)										int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN(  37)										int col;
HXDLIN(  37)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  37)											col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXDLIN(  37)											col = c;
            										}
HXDLIN(  37)										bool _hx_tmp;
HXDLIN(  37)										if (this1->useMask) {
HXDLIN(  37)											_hx_tmp = ::hx::IsNotNull( this1->mask );
            										}
            										else {
HXDLIN(  37)											_hx_tmp = false;
            										}
HXDLIN(  37)										if (_hx_tmp) {
HXDLIN(  37)											 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN(  37)											::Dynamic this6 = this5->image;
HXDLIN(  37)											int index1;
HXDLIN(  37)											if (this5->useVirtualPos) {
HXDLIN(  37)												index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx1) - this5->virtualX));
            											}
            											else {
HXDLIN(  37)												index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this5->width) + dx1)) ));
            											}
HXDLIN(  37)											int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN(  37)											int v1;
HXDLIN(  37)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  37)												v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            											}
            											else {
HXDLIN(  37)												v1 = c1;
            											}
HXDLIN(  37)											int maskPixel = v1;
HXDLIN(  37)											int this7 = col;
HXDLIN(  37)											if ((maskPixel == 0)) {
HXDLIN(  37)												col = this7;
            											}
            											else {
HXDLIN(  37)												Float m0;
HXDLIN(  37)												int this8 = ((maskPixel >> 24) & 255);
HXDLIN(  37)												if ((this8 == 0)) {
HXDLIN(  37)													m0 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float m1;
HXDLIN(  37)												int this9 = ((maskPixel >> 16) & 255);
HXDLIN(  37)												if ((this9 == 0)) {
HXDLIN(  37)													m1 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float m2;
HXDLIN(  37)												int this10 = ((maskPixel >> 8) & 255);
HXDLIN(  37)												if ((this10 == 0)) {
HXDLIN(  37)													m2 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float m3;
HXDLIN(  37)												int this11 = (maskPixel & 255);
HXDLIN(  37)												if ((this11 == 0)) {
HXDLIN(  37)													m3 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN(  37)												int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN(  37)												int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN(  37)												int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN(  37)												col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN(  37)										if ((col != 0)) {
HXDLIN(  37)											int x1 = (dx1 - rectLeft);
HXDLIN(  37)											int y1 = (dy1 - rectTop);
HXDLIN(  37)											int c2 = col;
HXDLIN(  37)											bool _hx_tmp1;
HXDLIN(  37)											if ((((c2 >> 24) & 255) < 254)) {
HXDLIN(  37)												_hx_tmp1 = undoImage->transparent;
            											}
            											else {
HXDLIN(  37)												_hx_tmp1 = false;
            											}
HXDLIN(  37)											if (_hx_tmp1) {
HXDLIN(  37)												int location;
HXDLIN(  37)												if (undoImage->useVirtualPos) {
HXDLIN(  37)													location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            												}
            												else {
HXDLIN(  37)													location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            												}
HXDLIN(  37)												int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN(  37)												int this13;
HXDLIN(  37)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  37)													this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            												}
            												else {
HXDLIN(  37)													this13 = this12;
            												}
HXDLIN(  37)												Float a1;
HXDLIN(  37)												int this14 = ((this13 >> 24) & 255);
HXDLIN(  37)												if ((this14 == 0)) {
HXDLIN(  37)													a1 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													a1 = (( (Float)(this14) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float r1;
HXDLIN(  37)												int this15 = ((this13 >> 16) & 255);
HXDLIN(  37)												if ((this15 == 0)) {
HXDLIN(  37)													r1 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float g1;
HXDLIN(  37)												int this16 = ((this13 >> 8) & 255);
HXDLIN(  37)												if ((this16 == 0)) {
HXDLIN(  37)													g1 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float b11;
HXDLIN(  37)												int this17 = (this13 & 255);
HXDLIN(  37)												if ((this17 == 0)) {
HXDLIN(  37)													b11 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float a2;
HXDLIN(  37)												int this18 = ((col >> 24) & 255);
HXDLIN(  37)												if ((this18 == 0)) {
HXDLIN(  37)													a2 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float r2;
HXDLIN(  37)												int this19 = ((col >> 16) & 255);
HXDLIN(  37)												if ((this19 == 0)) {
HXDLIN(  37)													r2 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float g2;
HXDLIN(  37)												int this20 = ((col >> 8) & 255);
HXDLIN(  37)												if ((this20 == 0)) {
HXDLIN(  37)													g2 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float b21;
HXDLIN(  37)												int this21 = (col & 255);
HXDLIN(  37)												if ((this21 == 0)) {
HXDLIN(  37)													b21 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  37)												int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  37)												int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  37)												int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  37)												int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  37)												int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  37)												{
HXDLIN(  37)													int _hx_tmp2;
HXDLIN(  37)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  37)														_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            													}
            													else {
HXDLIN(  37)														_hx_tmp2 = blended;
            													}
HXDLIN(  37)													::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            												}
            											}
            											else {
HXDLIN(  37)												::Dynamic this22 = undoImage->image;
HXDLIN(  37)												int index2;
HXDLIN(  37)												if (undoImage->useVirtualPos) {
HXDLIN(  37)													index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            												}
            												else {
HXDLIN(  37)													index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            												}
HXDLIN(  37)												int _hx_tmp3;
HXDLIN(  37)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  37)													_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            												}
            												else {
HXDLIN(  37)													_hx_tmp3 = c2;
            												}
HXDLIN(  37)												::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp3);
            											}
            										}
            										else {
HXDLIN(  37)											if (forceClear) {
HXDLIN(  37)												::Dynamic this23 = undoImage->image;
HXDLIN(  37)												int x2 = (dx1 - rectLeft);
HXDLIN(  37)												int y2 = (dy1 - rectTop);
HXDLIN(  37)												int index3;
HXDLIN(  37)												if (undoImage->useVirtualPos) {
HXDLIN(  37)													index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            												}
            												else {
HXDLIN(  37)													index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            												}
HXDLIN(  37)												::iterMagic::Iimg_obj::set(this23,index3,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  37)				bool foundY = false;
HXDLIN(  37)				Float s = ((Float)0.);
HXDLIN(  37)				Float t = ((Float)0.);
HXDLIN(  37)				Float sxx = ((Float)0.);
HXDLIN(  37)				Float txx = ((Float)0.);
HXDLIN(  37)				{
HXDLIN(  37)					int _g_min = xIter3->start;
HXDLIN(  37)					int _g_max = xIter3->max;
HXDLIN(  37)					while((_g_min < _g_max)){
HXDLIN(  37)						_g_min = (_g_min + 1);
HXDLIN(  37)						int x3 = (_g_min - 1);
HXLINE( 222)						sxx = (sx * ( (Float)(x3) ));
HXLINE( 223)						txx = (tx * ( (Float)(x3) ));
HXLINE( 224)						foundY = false;
HXLINE(  37)						{
HXDLIN(  37)							int _g_min1 = yIter3->start;
HXDLIN(  37)							int _g_max1 = yIter3->max;
HXDLIN(  37)							while((_g_min1 < _g_max1)){
HXDLIN(  37)								_g_min1 = (_g_min1 + 1);
HXDLIN(  37)								int y3 = (_g_min1 - 1);
HXLINE( 226)								s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE( 227)								t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE(  37)								bool _hx_tmp4;
HXDLIN(  37)								if (!((s <= 0))) {
HXDLIN(  37)									_hx_tmp4 = (t <= 0);
            								}
            								else {
HXDLIN(  37)									_hx_tmp4 = true;
            								}
HXDLIN(  37)								if (_hx_tmp4) {
HXDLIN(  37)									if (foundY) {
HXDLIN(  37)										goto _hx_goto_33;
            									}
            								}
            								else {
HXDLIN(  37)									if (((s + t) < A)) {
HXDLIN(  37)										int x4 = ::hx::Mod(x3,tileImage->width);
HXDLIN(  37)										int y4 = ::hx::Mod(y3,tileImage->height);
HXDLIN(  37)										::Dynamic this24 = tileImage->image;
HXDLIN(  37)										int index4;
HXDLIN(  37)										if (tileImage->useVirtualPos) {
HXDLIN(  37)											index4 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x4) - tileImage->virtualX));
            										}
            										else {
HXDLIN(  37)											index4 = ::Std_obj::_hx_int(( (Float)(((y4 * tileImage->width) + x4)) ));
            										}
HXDLIN(  37)										int c3 = ::iterMagic::Iimg_obj::get(this24,index4);
HXDLIN(  37)										int color;
HXDLIN(  37)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  37)											color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            										}
            										else {
HXDLIN(  37)											color = c3;
            										}
HXDLIN(  37)										{
HXDLIN(  37)											int c4 = color;
HXDLIN(  37)											bool _hx_tmp5;
HXDLIN(  37)											if ((((c4 >> 24) & 255) < 254)) {
HXDLIN(  37)												_hx_tmp5 = this1->transparent;
            											}
            											else {
HXDLIN(  37)												_hx_tmp5 = false;
            											}
HXDLIN(  37)											if (_hx_tmp5) {
HXDLIN(  37)												int location1;
HXDLIN(  37)												if (this1->useVirtualPos) {
HXDLIN(  37)													location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            												}
            												else {
HXDLIN(  37)													location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            												}
HXDLIN(  37)												int this25 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN(  37)												int this26;
HXDLIN(  37)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  37)													this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            												}
            												else {
HXDLIN(  37)													this26 = this25;
            												}
HXDLIN(  37)												Float a11;
HXDLIN(  37)												int this27 = ((this26 >> 24) & 255);
HXDLIN(  37)												if ((this27 == 0)) {
HXDLIN(  37)													a11 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float r11;
HXDLIN(  37)												int this28 = ((this26 >> 16) & 255);
HXDLIN(  37)												if ((this28 == 0)) {
HXDLIN(  37)													r11 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float g11;
HXDLIN(  37)												int this29 = ((this26 >> 8) & 255);
HXDLIN(  37)												if ((this29 == 0)) {
HXDLIN(  37)													g11 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float b12;
HXDLIN(  37)												int this30 = (this26 & 255);
HXDLIN(  37)												if ((this30 == 0)) {
HXDLIN(  37)													b12 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float a21;
HXDLIN(  37)												int this31 = ((color >> 24) & 255);
HXDLIN(  37)												if ((this31 == 0)) {
HXDLIN(  37)													a21 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float r21;
HXDLIN(  37)												int this32 = ((color >> 16) & 255);
HXDLIN(  37)												if ((this32 == 0)) {
HXDLIN(  37)													r21 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float g21;
HXDLIN(  37)												int this33 = ((color >> 8) & 255);
HXDLIN(  37)												if ((this33 == 0)) {
HXDLIN(  37)													g21 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float b22;
HXDLIN(  37)												int this34 = (color & 255);
HXDLIN(  37)												if ((this34 == 0)) {
HXDLIN(  37)													b22 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  37)												int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  37)												int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  37)												int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  37)												int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  37)												int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  37)												{
HXDLIN(  37)													int _hx_tmp6;
HXDLIN(  37)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  37)														_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            													}
            													else {
HXDLIN(  37)														_hx_tmp6 = blended1;
            													}
HXDLIN(  37)													::iterMagic::Iimg_obj::set(this1->image,location1,_hx_tmp6);
            												}
            											}
            											else {
HXDLIN(  37)												::Dynamic this35 = this1->image;
HXDLIN(  37)												int index5;
HXDLIN(  37)												if (this1->useVirtualPos) {
HXDLIN(  37)													index5 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            												}
            												else {
HXDLIN(  37)													index5 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            												}
HXDLIN(  37)												int _hx_tmp7;
HXDLIN(  37)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  37)													_hx_tmp7 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            												}
            												else {
HXDLIN(  37)													_hx_tmp7 = c4;
            												}
HXDLIN(  37)												::iterMagic::Iimg_obj::set(this35,index5,_hx_tmp7);
            											}
            										}
HXLINE( 236)										foundY = true;
            									}
            									else {
HXDLIN(  37)										if (foundY) {
HXDLIN(  37)											goto _hx_goto_33;
            										}
            									}
            								}
            							}
            							_hx_goto_33:;
            						}
            					}
            				}
HXDLIN(  37)				if ((hasHit == false)) {
HXDLIN(  37)					 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx1,by1,cx1,cy1,true);
HXDLIN(  37)					if (hasUndo) {
HXDLIN(  37)						v2->undoImage = undoImage;
HXDLIN(  37)						v2->undoX = xIter3->start;
HXDLIN(  37)						v2->undoY = yIter3->start;
            					}
            				}
            			}
            		}
HXDLIN(  37)		{
HXDLIN(  37)			Float bx2 = cx;
HXDLIN(  37)			Float by2 = cy;
HXDLIN(  37)			Float cx2 = dx;
HXDLIN(  37)			Float cy2 = dy;
HXDLIN(  37)			bool adjustWinding1 = (((((bx * by2) - (bx2 * by)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * by) - (bx * cy2))) > 0);
HXDLIN(  37)			if (!(adjustWinding1)) {
HXDLIN(  37)				Float bx_1 = bx2;
HXDLIN(  37)				Float by_1 = by2;
HXLINE( 187)				bx2 = cx2;
HXLINE( 188)				by2 = cy2;
HXLINE( 189)				cx2 = bx_1;
HXLINE( 190)				cy2 = by_1;
            			}
HXLINE(  37)			{
HXDLIN(  37)				bool hasUndo1 = false;
HXDLIN(  37)				Float s01 = ((by * cx2) - (bx * cy2));
HXDLIN(  37)				Float sx1 = (cy2 - by);
HXDLIN(  37)				Float sy1 = (bx - cx2);
HXDLIN(  37)				Float t01 = ((bx * by2) - (by * bx2));
HXDLIN(  37)				Float tx1 = (by - by2);
HXDLIN(  37)				Float ty1 = (bx2 - bx);
HXDLIN(  37)				Float A1 = ((((-(by2) * cx2) + (by * (-(bx2) + cx2))) + (bx * (by2 - cy2))) + (bx2 * cy2));
HXDLIN(  37)				 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  37)				if ((bx > bx2)) {
HXDLIN(  37)					if ((bx > cx2)) {
HXDLIN(  37)						int min4;
HXDLIN(  37)						if ((bx2 > cx2)) {
HXDLIN(  37)							min4 = ::Math_obj::floor(cx2);
            						}
            						else {
HXDLIN(  37)							min4 = ::Math_obj::floor(bx2);
            						}
HXDLIN(  37)						int ii_min8 = min4;
HXDLIN(  37)						int ii_max8 = ::Math_obj::ceil(bx);
HXDLIN(  37)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            					}
            					else {
HXDLIN(  37)						int ii_min9 = ::Math_obj::floor(bx2);
HXDLIN(  37)						int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN(  37)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            					}
            				}
            				else {
HXDLIN(  37)					if ((bx2 > cx2)) {
HXDLIN(  37)						int min5;
HXDLIN(  37)						if ((bx > cx2)) {
HXDLIN(  37)							min5 = ::Math_obj::floor(cx2);
            						}
            						else {
HXDLIN(  37)							min5 = ::Math_obj::ceil(bx);
            						}
HXDLIN(  37)						int ii_min10 = min5;
HXDLIN(  37)						int ii_max10 = ::Math_obj::ceil(bx2);
HXDLIN(  37)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            					}
            					else {
HXDLIN(  37)						int ii_min11 = ::Math_obj::floor(bx);
HXDLIN(  37)						int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN(  37)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            					}
            				}
HXDLIN(  37)				 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  37)				if ((by > by2)) {
HXDLIN(  37)					if ((by > cy2)) {
HXDLIN(  37)						int min6;
HXDLIN(  37)						if ((by2 > cy2)) {
HXDLIN(  37)							min6 = ::Math_obj::floor(cy2);
            						}
            						else {
HXDLIN(  37)							min6 = ::Math_obj::floor(by2);
            						}
HXDLIN(  37)						int ii_min12 = min6;
HXDLIN(  37)						int ii_max12 = ::Math_obj::ceil(by);
HXDLIN(  37)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            					}
            					else {
HXDLIN(  37)						int ii_min13 = ::Math_obj::floor(by2);
HXDLIN(  37)						int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN(  37)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            					}
            				}
            				else {
HXDLIN(  37)					if ((by2 > cy2)) {
HXDLIN(  37)						int min7;
HXDLIN(  37)						if ((by > cy2)) {
HXDLIN(  37)							min7 = ::Math_obj::floor(cy2);
            						}
            						else {
HXDLIN(  37)							min7 = ::Math_obj::ceil(by);
            						}
HXDLIN(  37)						int ii_min14 = min7;
HXDLIN(  37)						int ii_max14 = ::Math_obj::ceil(by2);
HXDLIN(  37)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            					}
            					else {
HXDLIN(  37)						int ii_min15 = ::Math_obj::floor(by);
HXDLIN(  37)						int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN(  37)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            					}
            				}
HXDLIN(  37)				 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  37)				if (hasUndo1) {
HXDLIN(  37)					int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  37)					int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  37)					 ::Dynamic imageType1 = null();
HXDLIN(  37)					 ::pi_xy::ImageStruct this36 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  37)					if (::hx::IsNull( imageType1 )) {
HXLINE(  54)						imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE(  37)					::Dynamic undoImage4;
HXDLIN(  37)					switch((int)(( (int)(imageType1) ))){
            						case (int)0: {
HXDLIN(  37)							 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  37)							 ::iterMagic::BytesImg b5 = byt1;
HXDLIN(  37)							{
HXDLIN(  37)								b5->width = width1;
HXDLIN(  37)								b5->height = height1;
HXDLIN(  37)								b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  37)								b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN(  37)								{
HXDLIN(  37)									int len2 = b5->length;
HXDLIN(  37)									int w1 = 0;
HXDLIN(  37)									{
HXDLIN(  37)										int _g20 = 0;
HXDLIN(  37)										int _g21 = b5->height;
HXDLIN(  37)										while((_g20 < _g21)){
HXDLIN(  37)											_g20 = (_g20 + 1);
HXDLIN(  37)											int y5 = (_g20 - 1);
HXDLIN(  37)											{
HXDLIN(  37)												int _g22 = 0;
HXDLIN(  37)												int _g23 = b5->width;
HXDLIN(  37)												while((_g22 < _g23)){
HXDLIN(  37)													_g22 = (_g22 + 1);
HXDLIN(  37)													int x5 = (_g22 - 1);
HXDLIN(  37)													{
HXDLIN(  37)														w1 = (w1 + 1);
HXDLIN(  37)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  37)													{
HXDLIN(  37)														w1 = (w1 + 1);
HXDLIN(  37)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  37)													{
HXDLIN(  37)														w1 = (w1 + 1);
HXDLIN(  37)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  37)													{
HXDLIN(  37)														w1 = (w1 + 1);
HXDLIN(  37)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  37)							undoImage4 = b5;
            						}
            						break;
            						case (int)1: {
HXDLIN(  37)							 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  37)							 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN(  37)							{
HXDLIN(  37)								a6->width = width1;
HXDLIN(  37)								a6->height = height1;
HXDLIN(  37)								a6->data = ::Array_obj< int >::__new(0);
HXDLIN(  37)								a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  37)								{
HXDLIN(  37)									int _g24 = 0;
HXDLIN(  37)									int _g25 = a6->length;
HXDLIN(  37)									while((_g24 < _g25)){
HXDLIN(  37)										_g24 = (_g24 + 1);
HXDLIN(  37)										int i6 = (_g24 - 1);
HXDLIN(  37)										a6->data[i6] = 0;
            									}
            								}
            							}
HXDLIN(  37)							undoImage4 = a6;
            						}
            						break;
            						case (int)2: {
HXDLIN(  37)							 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  37)							 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN(  37)							{
HXDLIN(  37)								b6->width = width1;
HXDLIN(  37)								b6->height = height1;
HXDLIN(  37)								b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  37)								int size1 = (b6->length * 4);
HXDLIN(  37)								b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  37)								{
HXDLIN(  37)									int _g26 = 0;
HXDLIN(  37)									int _g27 = b6->length;
HXDLIN(  37)									while((_g26 < _g27)){
HXDLIN(  37)										_g26 = (_g26 + 1);
HXDLIN(  37)										int i7 = (_g26 - 1);
HXDLIN(  37)										{
HXDLIN(  37)											 ::haxe::io::ArrayBufferViewImpl this37 = b6->data;
HXDLIN(  37)											bool undoImage5;
HXDLIN(  37)											if ((i7 >= 0)) {
HXDLIN(  37)												undoImage5 = (i7 < (this37->byteLength >> 2));
            											}
            											else {
HXDLIN(  37)												undoImage5 = false;
            											}
HXDLIN(  37)											if (undoImage5) {
HXDLIN(  37)												 ::haxe::io::Bytes _this1 = this37->bytes;
HXDLIN(  37)												int pos1 = ((i7 << 2) + this37->byteOffset);
HXDLIN(  37)												_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  37)												_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  37)												_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  37)												_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN(  37)							undoImage4 = b6;
            						}
            						break;
            						case (int)3: {
HXDLIN(  37)							 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  37)							 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN(  37)							{
HXDLIN(  37)								v3->width = width1;
HXDLIN(  37)								v3->height = height1;
HXDLIN(  37)								v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  37)								v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN(  37)								{
HXDLIN(  37)									int _g28 = 0;
HXDLIN(  37)									int _g29 = v3->length;
HXDLIN(  37)									while((_g28 < _g29)){
HXDLIN(  37)										_g28 = (_g28 + 1);
HXDLIN(  37)										int i8 = (_g28 - 1);
HXDLIN(  37)										v3->data->__unsafe_set(i8,0);
            									}
            								}
            							}
HXDLIN(  37)							undoImage4 = v3;
            						}
            						break;
            						case (int)4: {
HXDLIN(  37)							 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  37)							 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN(  37)							{
HXDLIN(  37)								b7->width = width1;
HXDLIN(  37)								b7->height = height1;
HXDLIN(  37)								b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  37)								b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  37)								{
HXDLIN(  37)									int len3 = b7->length;
HXDLIN(  37)									 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN(  37)									if (::hx::IsNull( d1->head )) {
HXDLIN(  37)										int _g30 = 0;
HXDLIN(  37)										int _g31 = len3;
HXDLIN(  37)										while((_g30 < _g31)){
HXDLIN(  37)											_g30 = (_g30 + 1);
HXDLIN(  37)											int i9 = (_g30 - 1);
HXDLIN(  37)											d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            										}
            									}
            									else {
HXDLIN(  37)										int _g32 = 0;
HXDLIN(  37)										int _g33 = len3;
HXDLIN(  37)										while((_g32 < _g33)){
HXDLIN(  37)											_g32 = (_g32 + 1);
HXDLIN(  37)											int i10 = (_g32 - 1);
HXDLIN(  37)											{
HXDLIN(  37)												 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN(  37)												 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  37)												{
HXDLIN(  37)													int _g34 = 0;
HXDLIN(  37)													int _g35 = i10;
HXDLIN(  37)													while((_g34 < _g35)){
HXDLIN(  37)														_g34 = (_g34 + 1);
HXDLIN(  37)														int i11 = (_g34 - 1);
HXLINE( 345)														prev1 = l1;
HXLINE( 346)														l1 = l1->next;
            													}
            												}
HXLINE(  37)												if (::hx::IsNull( prev1 )) {
HXDLIN(  37)													b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  37)													l1 = null();
            												}
            												else {
HXDLIN(  37)													prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  37)													l1 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  37)							undoImage4 = b7;
            						}
            						break;
            					}
HXDLIN(  37)					this36->image = undoImage4;
HXDLIN(  37)					this36->width = width1;
HXDLIN(  37)					this36->height = height1;
HXDLIN(  37)					this36->imageType = ( (int)(imageType1) );
HXDLIN(  37)					undoImage3 = this36;
HXDLIN(  37)					{
HXDLIN(  37)						int rectLeft1 = xIter31->start;
HXDLIN(  37)						int rectTop1 = yIter31->start;
HXDLIN(  37)						int rectRight1 = xIter31->max;
HXDLIN(  37)						bool forceClear1 = false;
HXDLIN(  37)						{
HXDLIN(  37)							int _g36 = rectTop1;
HXDLIN(  37)							int _g37 = yIter31->max;
HXDLIN(  37)							while((_g36 < _g37)){
HXDLIN(  37)								_g36 = (_g36 + 1);
HXDLIN(  37)								int dy2 = (_g36 - 1);
HXDLIN(  37)								{
HXDLIN(  37)									int _g38 = rectLeft1;
HXDLIN(  37)									int _g39 = rectRight1;
HXDLIN(  37)									while((_g38 < _g39)){
HXDLIN(  37)										_g38 = (_g38 + 1);
HXDLIN(  37)										int dx2 = (_g38 - 1);
HXDLIN(  37)										::Dynamic this38 = this1->image;
HXDLIN(  37)										int index6;
HXDLIN(  37)										if (this1->useVirtualPos) {
HXDLIN(  37)											index6 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx2) - this1->virtualX));
            										}
            										else {
HXDLIN(  37)											index6 = ::Std_obj::_hx_int(( (Float)(((dy2 * this1->width) + dx2)) ));
            										}
HXDLIN(  37)										int c5 = ::iterMagic::Iimg_obj::get(this38,index6);
HXDLIN(  37)										int col1;
HXDLIN(  37)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  37)											col1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            										}
            										else {
HXDLIN(  37)											col1 = c5;
            										}
HXDLIN(  37)										bool _hx_tmp8;
HXDLIN(  37)										if (this1->useMask) {
HXDLIN(  37)											_hx_tmp8 = ::hx::IsNotNull( this1->mask );
            										}
            										else {
HXDLIN(  37)											_hx_tmp8 = false;
            										}
HXDLIN(  37)										if (_hx_tmp8) {
HXDLIN(  37)											 ::pi_xy::ImageStruct this39 = this1->mask;
HXDLIN(  37)											::Dynamic this40 = this39->image;
HXDLIN(  37)											int index7;
HXDLIN(  37)											if (this39->useVirtualPos) {
HXDLIN(  37)												index7 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this39->virtualY) * ( (Float)(this39->width) )) + dx2) - this39->virtualX));
            											}
            											else {
HXDLIN(  37)												index7 = ::Std_obj::_hx_int(( (Float)(((dy2 * this39->width) + dx2)) ));
            											}
HXDLIN(  37)											int c6 = ::iterMagic::Iimg_obj::get(this40,index7);
HXDLIN(  37)											int v4;
HXDLIN(  37)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  37)												v4 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            											}
            											else {
HXDLIN(  37)												v4 = c6;
            											}
HXDLIN(  37)											int maskPixel1 = v4;
HXDLIN(  37)											int this41 = col1;
HXDLIN(  37)											if ((maskPixel1 == 0)) {
HXDLIN(  37)												col1 = this41;
            											}
            											else {
HXDLIN(  37)												Float m01;
HXDLIN(  37)												int this42 = ((maskPixel1 >> 24) & 255);
HXDLIN(  37)												if ((this42 == 0)) {
HXDLIN(  37)													m01 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													m01 = (( (Float)(this42) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float m11;
HXDLIN(  37)												int this43 = ((maskPixel1 >> 16) & 255);
HXDLIN(  37)												if ((this43 == 0)) {
HXDLIN(  37)													m11 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													m11 = (( (Float)(this43) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float m21;
HXDLIN(  37)												int this44 = ((maskPixel1 >> 8) & 255);
HXDLIN(  37)												if ((this44 == 0)) {
HXDLIN(  37)													m21 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													m21 = (( (Float)(this44) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float m31;
HXDLIN(  37)												int this45 = (maskPixel1 & 255);
HXDLIN(  37)												if ((this45 == 0)) {
HXDLIN(  37)													m31 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													m31 = (( (Float)(this45) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this41 >> 24) & 255)) )));
HXDLIN(  37)												int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this41 >> 16) & 255)) )));
HXDLIN(  37)												int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this41 >> 8) & 255)) )));
HXDLIN(  37)												int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this41 & 255)) )));
HXDLIN(  37)												col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN(  37)										if ((col1 != 0)) {
HXDLIN(  37)											int x6 = (dx2 - rectLeft1);
HXDLIN(  37)											int y6 = (dy2 - rectTop1);
HXDLIN(  37)											int c7 = col1;
HXDLIN(  37)											bool _hx_tmp9;
HXDLIN(  37)											if ((((c7 >> 24) & 255) < 254)) {
HXDLIN(  37)												_hx_tmp9 = undoImage3->transparent;
            											}
            											else {
HXDLIN(  37)												_hx_tmp9 = false;
            											}
HXDLIN(  37)											if (_hx_tmp9) {
HXDLIN(  37)												int location2;
HXDLIN(  37)												if (undoImage3->useVirtualPos) {
HXDLIN(  37)													location2 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            												}
            												else {
HXDLIN(  37)													location2 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            												}
HXDLIN(  37)												int this46 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN(  37)												int this47;
HXDLIN(  37)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  37)													this47 = ((((((this46 >> 24) & 255) << 24) | ((this46 & 255) << 16)) | (((this46 >> 8) & 255) << 8)) | ((this46 >> 16) & 255));
            												}
            												else {
HXDLIN(  37)													this47 = this46;
            												}
HXDLIN(  37)												Float a12;
HXDLIN(  37)												int this48 = ((this47 >> 24) & 255);
HXDLIN(  37)												if ((this48 == 0)) {
HXDLIN(  37)													a12 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													a12 = (( (Float)(this48) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float r12;
HXDLIN(  37)												int this49 = ((this47 >> 16) & 255);
HXDLIN(  37)												if ((this49 == 0)) {
HXDLIN(  37)													r12 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													r12 = (( (Float)(this49) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float g12;
HXDLIN(  37)												int this50 = ((this47 >> 8) & 255);
HXDLIN(  37)												if ((this50 == 0)) {
HXDLIN(  37)													g12 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													g12 = (( (Float)(this50) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float b13;
HXDLIN(  37)												int this51 = (this47 & 255);
HXDLIN(  37)												if ((this51 == 0)) {
HXDLIN(  37)													b13 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													b13 = (( (Float)(this51) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float a22;
HXDLIN(  37)												int this52 = ((col1 >> 24) & 255);
HXDLIN(  37)												if ((this52 == 0)) {
HXDLIN(  37)													a22 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													a22 = (( (Float)(this52) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float r22;
HXDLIN(  37)												int this53 = ((col1 >> 16) & 255);
HXDLIN(  37)												if ((this53 == 0)) {
HXDLIN(  37)													r22 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													r22 = (( (Float)(this53) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float g22;
HXDLIN(  37)												int this54 = ((col1 >> 8) & 255);
HXDLIN(  37)												if ((this54 == 0)) {
HXDLIN(  37)													g22 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													g22 = (( (Float)(this54) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float b23;
HXDLIN(  37)												int this55 = (col1 & 255);
HXDLIN(  37)												if ((this55 == 0)) {
HXDLIN(  37)													b23 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													b23 = (( (Float)(this55) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  37)												int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  37)												int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  37)												int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  37)												int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  37)												int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN(  37)												{
HXDLIN(  37)													int _hx_tmp10;
HXDLIN(  37)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  37)														_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            													}
            													else {
HXDLIN(  37)														_hx_tmp10 = blended2;
            													}
HXDLIN(  37)													::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            												}
            											}
            											else {
HXDLIN(  37)												::Dynamic this56 = undoImage3->image;
HXDLIN(  37)												int index8;
HXDLIN(  37)												if (undoImage3->useVirtualPos) {
HXDLIN(  37)													index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            												}
            												else {
HXDLIN(  37)													index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            												}
HXDLIN(  37)												int _hx_tmp11;
HXDLIN(  37)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  37)													_hx_tmp11 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            												}
            												else {
HXDLIN(  37)													_hx_tmp11 = c7;
            												}
HXDLIN(  37)												::iterMagic::Iimg_obj::set(this56,index8,_hx_tmp11);
            											}
            										}
            										else {
HXDLIN(  37)											if (forceClear1) {
HXDLIN(  37)												::Dynamic this57 = undoImage3->image;
HXDLIN(  37)												int x7 = (dx2 - rectLeft1);
HXDLIN(  37)												int y7 = (dy2 - rectTop1);
HXDLIN(  37)												int index9;
HXDLIN(  37)												if (undoImage3->useVirtualPos) {
HXDLIN(  37)													index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x7) - undoImage3->virtualX));
            												}
            												else {
HXDLIN(  37)													index9 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage3->width) + x7)) ));
            												}
HXDLIN(  37)												::iterMagic::Iimg_obj::set(this57,index9,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  37)				bool foundY1 = false;
HXDLIN(  37)				Float s1 = ((Float)0.);
HXDLIN(  37)				Float t1 = ((Float)0.);
HXDLIN(  37)				Float sxx1 = ((Float)0.);
HXDLIN(  37)				Float txx1 = ((Float)0.);
HXDLIN(  37)				{
HXDLIN(  37)					int _g_min2 = xIter31->start;
HXDLIN(  37)					int _g_max2 = xIter31->max;
HXDLIN(  37)					while((_g_min2 < _g_max2)){
HXDLIN(  37)						_g_min2 = (_g_min2 + 1);
HXDLIN(  37)						int x8 = (_g_min2 - 1);
HXLINE( 222)						sxx1 = (sx1 * ( (Float)(x8) ));
HXLINE( 223)						txx1 = (tx1 * ( (Float)(x8) ));
HXLINE( 224)						foundY1 = false;
HXLINE(  37)						{
HXDLIN(  37)							int _g_min3 = yIter31->start;
HXDLIN(  37)							int _g_max3 = yIter31->max;
HXDLIN(  37)							while((_g_min3 < _g_max3)){
HXDLIN(  37)								_g_min3 = (_g_min3 + 1);
HXDLIN(  37)								int y8 = (_g_min3 - 1);
HXLINE( 226)								s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y8) )));
HXLINE( 227)								t1 = ((t01 + txx1) + (ty1 * ( (Float)(y8) )));
HXLINE(  37)								bool _hx_tmp12;
HXDLIN(  37)								if (!((s1 <= 0))) {
HXDLIN(  37)									_hx_tmp12 = (t1 <= 0);
            								}
            								else {
HXDLIN(  37)									_hx_tmp12 = true;
            								}
HXDLIN(  37)								if (_hx_tmp12) {
HXDLIN(  37)									if (foundY1) {
HXDLIN(  37)										goto _hx_goto_45;
            									}
            								}
            								else {
HXDLIN(  37)									if (((s1 + t1) < A1)) {
HXDLIN(  37)										int x9 = ::hx::Mod(x8,tileImage->width);
HXDLIN(  37)										int y9 = ::hx::Mod(y8,tileImage->height);
HXDLIN(  37)										::Dynamic this58 = tileImage->image;
HXDLIN(  37)										int index10;
HXDLIN(  37)										if (tileImage->useVirtualPos) {
HXDLIN(  37)											index10 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x9) - tileImage->virtualX));
            										}
            										else {
HXDLIN(  37)											index10 = ::Std_obj::_hx_int(( (Float)(((y9 * tileImage->width) + x9)) ));
            										}
HXDLIN(  37)										int c8 = ::iterMagic::Iimg_obj::get(this58,index10);
HXDLIN(  37)										int color1;
HXDLIN(  37)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  37)											color1 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            										}
            										else {
HXDLIN(  37)											color1 = c8;
            										}
HXDLIN(  37)										{
HXDLIN(  37)											int c9 = color1;
HXDLIN(  37)											bool _hx_tmp13;
HXDLIN(  37)											if ((((c9 >> 24) & 255) < 254)) {
HXDLIN(  37)												_hx_tmp13 = this1->transparent;
            											}
            											else {
HXDLIN(  37)												_hx_tmp13 = false;
            											}
HXDLIN(  37)											if (_hx_tmp13) {
HXDLIN(  37)												int location3;
HXDLIN(  37)												if (this1->useVirtualPos) {
HXDLIN(  37)													location3 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - this1->virtualY) * ( (Float)(this1->width) )) + x8) - this1->virtualX));
            												}
            												else {
HXDLIN(  37)													location3 = ::Std_obj::_hx_int(( (Float)(((y8 * this1->width) + x8)) ));
            												}
HXDLIN(  37)												int this59 = ::iterMagic::Iimg_obj::get(this1->image,location3);
HXDLIN(  37)												int this60;
HXDLIN(  37)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  37)													this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            												}
            												else {
HXDLIN(  37)													this60 = this59;
            												}
HXDLIN(  37)												Float a13;
HXDLIN(  37)												int this61 = ((this60 >> 24) & 255);
HXDLIN(  37)												if ((this61 == 0)) {
HXDLIN(  37)													a13 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													a13 = (( (Float)(this61) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float r13;
HXDLIN(  37)												int this62 = ((this60 >> 16) & 255);
HXDLIN(  37)												if ((this62 == 0)) {
HXDLIN(  37)													r13 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													r13 = (( (Float)(this62) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float g13;
HXDLIN(  37)												int this63 = ((this60 >> 8) & 255);
HXDLIN(  37)												if ((this63 == 0)) {
HXDLIN(  37)													g13 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													g13 = (( (Float)(this63) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float b14;
HXDLIN(  37)												int this64 = (this60 & 255);
HXDLIN(  37)												if ((this64 == 0)) {
HXDLIN(  37)													b14 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float a23;
HXDLIN(  37)												int this65 = ((color1 >> 24) & 255);
HXDLIN(  37)												if ((this65 == 0)) {
HXDLIN(  37)													a23 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													a23 = (( (Float)(this65) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float r23;
HXDLIN(  37)												int this66 = ((color1 >> 16) & 255);
HXDLIN(  37)												if ((this66 == 0)) {
HXDLIN(  37)													r23 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													r23 = (( (Float)(this66) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float g23;
HXDLIN(  37)												int this67 = ((color1 >> 8) & 255);
HXDLIN(  37)												if ((this67 == 0)) {
HXDLIN(  37)													g23 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													g23 = (( (Float)(this67) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float b24;
HXDLIN(  37)												int this68 = (color1 & 255);
HXDLIN(  37)												if ((this68 == 0)) {
HXDLIN(  37)													b24 = ((Float)0.);
            												}
            												else {
HXDLIN(  37)													b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            												}
HXDLIN(  37)												Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  37)												int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  37)												int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  37)												int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN(  37)												int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  37)												int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN(  37)												{
HXDLIN(  37)													int _hx_tmp14;
HXDLIN(  37)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  37)														_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            													}
            													else {
HXDLIN(  37)														_hx_tmp14 = blended3;
            													}
HXDLIN(  37)													::iterMagic::Iimg_obj::set(this1->image,location3,_hx_tmp14);
            												}
            											}
            											else {
HXDLIN(  37)												::Dynamic this69 = this1->image;
HXDLIN(  37)												int index11;
HXDLIN(  37)												if (this1->useVirtualPos) {
HXDLIN(  37)													index11 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - this1->virtualY) * ( (Float)(this1->width) )) + x8) - this1->virtualX));
            												}
            												else {
HXDLIN(  37)													index11 = ::Std_obj::_hx_int(( (Float)(((y8 * this1->width) + x8)) ));
            												}
HXDLIN(  37)												int _hx_tmp15;
HXDLIN(  37)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  37)													_hx_tmp15 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            												}
            												else {
HXDLIN(  37)													_hx_tmp15 = c9;
            												}
HXDLIN(  37)												::iterMagic::Iimg_obj::set(this69,index11,_hx_tmp15);
            											}
            										}
HXLINE( 236)										foundY1 = true;
            									}
            									else {
HXDLIN(  37)										if (foundY1) {
HXDLIN(  37)											goto _hx_goto_45;
            										}
            									}
            								}
            							}
            							_hx_goto_45:;
            						}
            					}
            				}
HXDLIN(  37)				if ((hasHit == false)) {
HXDLIN(  37)					 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,bx2,by2,cx2,cy2,true);
HXDLIN(  37)					if (hasUndo1) {
HXDLIN(  37)						v5->undoImage = undoImage3;
HXDLIN(  37)						v5->undoX = xIter31->start;
HXDLIN(  37)						v5->undoY = yIter31->start;
            					}
            				}
            			}
            		}
HXDLIN(  37)		if ((hasHit == true)) {
HXDLIN(  37)			 ::pi_xy::algo::HitQuad v6 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  37)			return v6;
            		}
            		else {
HXDLIN(  37)			return null();
            		}
HXDLIN(  37)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC11(TileShape_Impl__obj,quad,return )

 ::pi_xy::algo::HitQuad TileShape_Impl__obj::rectangle( ::pi_xy::ImageStruct this1,Float x,Float y,Float wid,Float hi, ::pi_xy::ImageStruct tileImage,::hx::Null< bool >  __o_hasHit){
            		bool hasHit = __o_hasHit.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_6e4d7718bf84d356_44_rectangle)
HXLINE(  45)		Float bx = (x + wid);
HXLINE(  46)		Float cy = (y + hi);
HXLINE(  47)		{
HXLINE(  47)			Float bx1 = bx;
HXDLIN(  47)			Float by = y;
HXDLIN(  47)			Float cx = x;
HXDLIN(  47)			Float cy1 = cy;
HXDLIN(  47)			bool adjustWinding = (((((x * by) - (bx1 * y)) + ((bx1 * cy1) - (cx * by))) + ((cx * y) - (x * cy1))) > 0);
HXDLIN(  47)			if (!(adjustWinding)) {
HXLINE(  47)				Float bx_ = bx1;
HXDLIN(  47)				Float by_ = by;
HXLINE( 187)				bx1 = cx;
HXLINE( 188)				by = cy1;
HXLINE( 189)				cx = bx_;
HXLINE( 190)				cy1 = by_;
            			}
HXLINE(  47)			{
HXLINE(  47)				bool hasUndo = false;
HXDLIN(  47)				Float s0 = ((y * cx) - (x * cy1));
HXDLIN(  47)				Float sx = (cy1 - y);
HXDLIN(  47)				Float sy = (x - cx);
HXDLIN(  47)				Float t0 = ((x * by) - (y * bx1));
HXDLIN(  47)				Float tx = (y - by);
HXDLIN(  47)				Float ty = (bx1 - x);
HXDLIN(  47)				Float A = ((((-(by) * cx) + (y * (-(bx1) + cx))) + (x * (by - cy1))) + (bx1 * cy1));
HXDLIN(  47)				 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  47)				if ((x > bx1)) {
HXLINE(  47)					if ((x > cx)) {
HXLINE(  47)						int min;
HXDLIN(  47)						if ((bx1 > cx)) {
HXLINE(  47)							min = ::Math_obj::floor(cx);
            						}
            						else {
HXLINE(  47)							min = ::Math_obj::floor(bx1);
            						}
HXDLIN(  47)						int ii_min = min;
HXDLIN(  47)						int ii_max = ::Math_obj::ceil(x);
HXDLIN(  47)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            					}
            					else {
HXLINE(  47)						int ii_min1 = ::Math_obj::floor(bx1);
HXDLIN(  47)						int ii_max1 = ::Math_obj::ceil(cx);
HXDLIN(  47)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            					}
            				}
            				else {
HXLINE(  47)					if ((bx1 > cx)) {
HXLINE(  47)						int min1;
HXDLIN(  47)						if ((x > cx)) {
HXLINE(  47)							min1 = ::Math_obj::floor(cx);
            						}
            						else {
HXLINE(  47)							min1 = ::Math_obj::ceil(x);
            						}
HXDLIN(  47)						int ii_min2 = min1;
HXDLIN(  47)						int ii_max2 = ::Math_obj::ceil(bx1);
HXDLIN(  47)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            					}
            					else {
HXLINE(  47)						int ii_min3 = ::Math_obj::floor(x);
HXDLIN(  47)						int ii_max3 = ::Math_obj::ceil(cx);
HXDLIN(  47)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            					}
            				}
HXDLIN(  47)				 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  47)				if ((y > by)) {
HXLINE(  47)					if ((y > cy1)) {
HXLINE(  47)						int min2;
HXDLIN(  47)						if ((by > cy1)) {
HXLINE(  47)							min2 = ::Math_obj::floor(cy1);
            						}
            						else {
HXLINE(  47)							min2 = ::Math_obj::floor(by);
            						}
HXDLIN(  47)						int ii_min4 = min2;
HXDLIN(  47)						int ii_max4 = ::Math_obj::ceil(y);
HXDLIN(  47)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            					}
            					else {
HXLINE(  47)						int ii_min5 = ::Math_obj::floor(by);
HXDLIN(  47)						int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN(  47)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            					}
            				}
            				else {
HXLINE(  47)					if ((by > cy1)) {
HXLINE(  47)						int min3;
HXDLIN(  47)						if ((y > cy1)) {
HXLINE(  47)							min3 = ::Math_obj::floor(cy1);
            						}
            						else {
HXLINE(  47)							min3 = ::Math_obj::ceil(y);
            						}
HXDLIN(  47)						int ii_min6 = min3;
HXDLIN(  47)						int ii_max6 = ::Math_obj::ceil(by);
HXDLIN(  47)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            					}
            					else {
HXLINE(  47)						int ii_min7 = ::Math_obj::floor(y);
HXDLIN(  47)						int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN(  47)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            					}
            				}
HXDLIN(  47)				 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  47)				if (hasUndo) {
HXLINE(  47)					int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  47)					int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  47)					 ::Dynamic imageType = null();
HXDLIN(  47)					 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  47)					if (::hx::IsNull( imageType )) {
HXLINE(  54)						imageType = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE(  47)					::Dynamic undoImage1;
HXDLIN(  47)					switch((int)(( (int)(imageType) ))){
            						case (int)0: {
HXLINE(  47)							 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  47)							 ::iterMagic::BytesImg b = byt;
HXDLIN(  47)							{
HXLINE(  47)								b->width = width;
HXDLIN(  47)								b->height = height;
HXDLIN(  47)								b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  47)								b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  47)								{
HXLINE(  47)									int len = b->length;
HXDLIN(  47)									int w = 0;
HXDLIN(  47)									{
HXLINE(  47)										int _g = 0;
HXDLIN(  47)										int _g1 = b->height;
HXDLIN(  47)										while((_g < _g1)){
HXLINE(  47)											_g = (_g + 1);
HXDLIN(  47)											int y1 = (_g - 1);
HXDLIN(  47)											{
HXLINE(  47)												int _g2 = 0;
HXDLIN(  47)												int _g3 = b->width;
HXDLIN(  47)												while((_g2 < _g3)){
HXLINE(  47)													_g2 = (_g2 + 1);
HXDLIN(  47)													int x1 = (_g2 - 1);
HXDLIN(  47)													{
HXLINE(  47)														w = (w + 1);
HXDLIN(  47)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  47)													{
HXLINE(  47)														w = (w + 1);
HXDLIN(  47)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  47)													{
HXLINE(  47)														w = (w + 1);
HXDLIN(  47)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  47)													{
HXLINE(  47)														w = (w + 1);
HXDLIN(  47)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  47)							undoImage1 = b;
            						}
            						break;
            						case (int)1: {
HXLINE(  47)							 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  47)							 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  47)							{
HXLINE(  47)								a->width = width;
HXDLIN(  47)								a->height = height;
HXDLIN(  47)								a->data = ::Array_obj< int >::__new(0);
HXDLIN(  47)								a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  47)								{
HXLINE(  47)									int _g4 = 0;
HXDLIN(  47)									int _g5 = a->length;
HXDLIN(  47)									while((_g4 < _g5)){
HXLINE(  47)										_g4 = (_g4 + 1);
HXDLIN(  47)										int i = (_g4 - 1);
HXDLIN(  47)										a->data[i] = 0;
            									}
            								}
            							}
HXDLIN(  47)							undoImage1 = a;
            						}
            						break;
            						case (int)2: {
HXLINE(  47)							 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  47)							 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  47)							{
HXLINE(  47)								b1->width = width;
HXDLIN(  47)								b1->height = height;
HXDLIN(  47)								b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  47)								int size = (b1->length * 4);
HXDLIN(  47)								b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  47)								{
HXLINE(  47)									int _g6 = 0;
HXDLIN(  47)									int _g7 = b1->length;
HXDLIN(  47)									while((_g6 < _g7)){
HXLINE(  47)										_g6 = (_g6 + 1);
HXDLIN(  47)										int i1 = (_g6 - 1);
HXDLIN(  47)										{
HXLINE(  47)											 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  47)											bool undoImage2;
HXDLIN(  47)											if ((i1 >= 0)) {
HXLINE(  47)												undoImage2 = (i1 < (this3->byteLength >> 2));
            											}
            											else {
HXLINE(  47)												undoImage2 = false;
            											}
HXDLIN(  47)											if (undoImage2) {
HXLINE(  47)												 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  47)												int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  47)												_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  47)												_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  47)												_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  47)												_this->b[(pos + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN(  47)							undoImage1 = b1;
            						}
            						break;
            						case (int)3: {
HXLINE(  47)							 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  47)							 ::iterMagic::VecIntImg v = vec;
HXDLIN(  47)							{
HXLINE(  47)								v->width = width;
HXDLIN(  47)								v->height = height;
HXDLIN(  47)								v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  47)								v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  47)								{
HXLINE(  47)									int _g8 = 0;
HXDLIN(  47)									int _g9 = v->length;
HXDLIN(  47)									while((_g8 < _g9)){
HXLINE(  47)										_g8 = (_g8 + 1);
HXDLIN(  47)										int i2 = (_g8 - 1);
HXDLIN(  47)										v->data->__unsafe_set(i2,0);
            									}
            								}
            							}
HXDLIN(  47)							undoImage1 = v;
            						}
            						break;
            						case (int)4: {
HXLINE(  47)							 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  47)							 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  47)							{
HXLINE(  47)								b2->width = width;
HXDLIN(  47)								b2->height = height;
HXDLIN(  47)								b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  47)								b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  47)								{
HXLINE(  47)									int len1 = b2->length;
HXDLIN(  47)									 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  47)									if (::hx::IsNull( d->head )) {
HXLINE(  47)										int _g10 = 0;
HXDLIN(  47)										int _g11 = len1;
HXDLIN(  47)										while((_g10 < _g11)){
HXLINE(  47)											_g10 = (_g10 + 1);
HXDLIN(  47)											int i3 = (_g10 - 1);
HXDLIN(  47)											d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            										}
            									}
            									else {
HXLINE(  47)										int _g12 = 0;
HXDLIN(  47)										int _g13 = len1;
HXDLIN(  47)										while((_g12 < _g13)){
HXLINE(  47)											_g12 = (_g12 + 1);
HXDLIN(  47)											int i4 = (_g12 - 1);
HXDLIN(  47)											{
HXLINE(  47)												 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  47)												 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  47)												{
HXLINE(  47)													int _g14 = 0;
HXDLIN(  47)													int _g15 = i4;
HXDLIN(  47)													while((_g14 < _g15)){
HXLINE(  47)														_g14 = (_g14 + 1);
HXDLIN(  47)														int i5 = (_g14 - 1);
HXLINE( 345)														prev = l;
HXLINE( 346)														l = l->next;
            													}
            												}
HXLINE(  47)												if (::hx::IsNull( prev )) {
HXLINE(  47)													b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  47)													l = null();
            												}
            												else {
HXLINE(  47)													prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  47)													l = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  47)							undoImage1 = b2;
            						}
            						break;
            					}
HXDLIN(  47)					this2->image = undoImage1;
HXDLIN(  47)					this2->width = width;
HXDLIN(  47)					this2->height = height;
HXDLIN(  47)					this2->imageType = ( (int)(imageType) );
HXDLIN(  47)					undoImage = this2;
HXDLIN(  47)					{
HXLINE(  47)						int rectLeft = xIter3->start;
HXDLIN(  47)						int rectTop = yIter3->start;
HXDLIN(  47)						int rectRight = xIter3->max;
HXDLIN(  47)						bool forceClear = false;
HXDLIN(  47)						{
HXLINE(  47)							int _g16 = rectTop;
HXDLIN(  47)							int _g17 = yIter3->max;
HXDLIN(  47)							while((_g16 < _g17)){
HXLINE(  47)								_g16 = (_g16 + 1);
HXDLIN(  47)								int dy = (_g16 - 1);
HXDLIN(  47)								{
HXLINE(  47)									int _g18 = rectLeft;
HXDLIN(  47)									int _g19 = rectRight;
HXDLIN(  47)									while((_g18 < _g19)){
HXLINE(  47)										_g18 = (_g18 + 1);
HXDLIN(  47)										int dx = (_g18 - 1);
HXDLIN(  47)										::Dynamic this4 = this1->image;
HXDLIN(  47)										int index;
HXDLIN(  47)										if (this1->useVirtualPos) {
HXLINE(  47)											index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            										}
            										else {
HXLINE(  47)											index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            										}
HXDLIN(  47)										int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN(  47)										int col;
HXDLIN(  47)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)											col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE(  47)											col = c;
            										}
HXDLIN(  47)										bool _hx_tmp;
HXDLIN(  47)										if (this1->useMask) {
HXLINE(  47)											_hx_tmp = ::hx::IsNotNull( this1->mask );
            										}
            										else {
HXLINE(  47)											_hx_tmp = false;
            										}
HXDLIN(  47)										if (_hx_tmp) {
HXLINE(  47)											 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN(  47)											::Dynamic this6 = this5->image;
HXDLIN(  47)											int index1;
HXDLIN(  47)											if (this5->useVirtualPos) {
HXLINE(  47)												index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx) - this5->virtualX));
            											}
            											else {
HXLINE(  47)												index1 = ::Std_obj::_hx_int(( (Float)(((dy * this5->width) + dx)) ));
            											}
HXDLIN(  47)											int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN(  47)											int v1;
HXDLIN(  47)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)												v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            											}
            											else {
HXLINE(  47)												v1 = c1;
            											}
HXDLIN(  47)											int maskPixel = v1;
HXDLIN(  47)											int this7 = col;
HXDLIN(  47)											if ((maskPixel == 0)) {
HXLINE(  47)												col = this7;
            											}
            											else {
HXLINE(  47)												Float m0;
HXDLIN(  47)												int this8 = ((maskPixel >> 24) & 255);
HXDLIN(  47)												if ((this8 == 0)) {
HXLINE(  47)													m0 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float m1;
HXDLIN(  47)												int this9 = ((maskPixel >> 16) & 255);
HXDLIN(  47)												if ((this9 == 0)) {
HXLINE(  47)													m1 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float m2;
HXDLIN(  47)												int this10 = ((maskPixel >> 8) & 255);
HXDLIN(  47)												if ((this10 == 0)) {
HXLINE(  47)													m2 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float m3;
HXDLIN(  47)												int this11 = (maskPixel & 255);
HXDLIN(  47)												if ((this11 == 0)) {
HXLINE(  47)													m3 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN(  47)												int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN(  47)												int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN(  47)												int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN(  47)												col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN(  47)										if ((col != 0)) {
HXLINE(  47)											int x2 = (dx - rectLeft);
HXDLIN(  47)											int y2 = (dy - rectTop);
HXDLIN(  47)											int c2 = col;
HXDLIN(  47)											bool _hx_tmp1;
HXDLIN(  47)											if ((((c2 >> 24) & 255) < 254)) {
HXLINE(  47)												_hx_tmp1 = undoImage->transparent;
            											}
            											else {
HXLINE(  47)												_hx_tmp1 = false;
            											}
HXDLIN(  47)											if (_hx_tmp1) {
HXLINE(  47)												int location;
HXDLIN(  47)												if (undoImage->useVirtualPos) {
HXLINE(  47)													location = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            												}
            												else {
HXLINE(  47)													location = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            												}
HXDLIN(  47)												int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN(  47)												int this13;
HXDLIN(  47)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)													this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            												}
            												else {
HXLINE(  47)													this13 = this12;
            												}
HXDLIN(  47)												Float a1;
HXDLIN(  47)												int this14 = ((this13 >> 24) & 255);
HXDLIN(  47)												if ((this14 == 0)) {
HXLINE(  47)													a1 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													a1 = (( (Float)(this14) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float r1;
HXDLIN(  47)												int this15 = ((this13 >> 16) & 255);
HXDLIN(  47)												if ((this15 == 0)) {
HXLINE(  47)													r1 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float g1;
HXDLIN(  47)												int this16 = ((this13 >> 8) & 255);
HXDLIN(  47)												if ((this16 == 0)) {
HXLINE(  47)													g1 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float b11;
HXDLIN(  47)												int this17 = (this13 & 255);
HXDLIN(  47)												if ((this17 == 0)) {
HXLINE(  47)													b11 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float a2;
HXDLIN(  47)												int this18 = ((col >> 24) & 255);
HXDLIN(  47)												if ((this18 == 0)) {
HXLINE(  47)													a2 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float r2;
HXDLIN(  47)												int this19 = ((col >> 16) & 255);
HXDLIN(  47)												if ((this19 == 0)) {
HXLINE(  47)													r2 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float g2;
HXDLIN(  47)												int this20 = ((col >> 8) & 255);
HXDLIN(  47)												if ((this20 == 0)) {
HXLINE(  47)													g2 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float b21;
HXDLIN(  47)												int this21 = (col & 255);
HXDLIN(  47)												if ((this21 == 0)) {
HXLINE(  47)													b21 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  47)												int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  47)												int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  47)												int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  47)												int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  47)												int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  47)												{
HXLINE(  47)													int _hx_tmp2;
HXDLIN(  47)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)														_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            													}
            													else {
HXLINE(  47)														_hx_tmp2 = blended;
            													}
HXDLIN(  47)													::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            												}
            											}
            											else {
HXLINE(  47)												::Dynamic this22 = undoImage->image;
HXDLIN(  47)												int index2;
HXDLIN(  47)												if (undoImage->useVirtualPos) {
HXLINE(  47)													index2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            												}
            												else {
HXLINE(  47)													index2 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            												}
HXDLIN(  47)												int _hx_tmp3;
HXDLIN(  47)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)													_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            												}
            												else {
HXLINE(  47)													_hx_tmp3 = c2;
            												}
HXDLIN(  47)												::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp3);
            											}
            										}
            										else {
HXLINE(  47)											if (forceClear) {
HXLINE(  47)												::Dynamic this23 = undoImage->image;
HXDLIN(  47)												int x3 = (dx - rectLeft);
HXDLIN(  47)												int y3 = (dy - rectTop);
HXDLIN(  47)												int index3;
HXDLIN(  47)												if (undoImage->useVirtualPos) {
HXLINE(  47)													index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x3) - undoImage->virtualX));
            												}
            												else {
HXLINE(  47)													index3 = ::Std_obj::_hx_int(( (Float)(((y3 * undoImage->width) + x3)) ));
            												}
HXDLIN(  47)												::iterMagic::Iimg_obj::set(this23,index3,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  47)				bool foundY = false;
HXDLIN(  47)				Float s = ((Float)0.);
HXDLIN(  47)				Float t = ((Float)0.);
HXDLIN(  47)				Float sxx = ((Float)0.);
HXDLIN(  47)				Float txx = ((Float)0.);
HXDLIN(  47)				{
HXLINE(  47)					int _g_min = xIter3->start;
HXDLIN(  47)					int _g_max = xIter3->max;
HXDLIN(  47)					while((_g_min < _g_max)){
HXLINE(  47)						_g_min = (_g_min + 1);
HXDLIN(  47)						int x4 = (_g_min - 1);
HXLINE( 222)						sxx = (sx * ( (Float)(x4) ));
HXLINE( 223)						txx = (tx * ( (Float)(x4) ));
HXLINE( 224)						foundY = false;
HXLINE(  47)						{
HXLINE(  47)							int _g_min1 = yIter3->start;
HXDLIN(  47)							int _g_max1 = yIter3->max;
HXDLIN(  47)							while((_g_min1 < _g_max1)){
HXLINE(  47)								_g_min1 = (_g_min1 + 1);
HXDLIN(  47)								int y4 = (_g_min1 - 1);
HXLINE( 226)								s = ((s0 + sxx) + (sy * ( (Float)(y4) )));
HXLINE( 227)								t = ((t0 + txx) + (ty * ( (Float)(y4) )));
HXLINE(  47)								bool _hx_tmp4;
HXDLIN(  47)								if (!((s <= 0))) {
HXLINE(  47)									_hx_tmp4 = (t <= 0);
            								}
            								else {
HXLINE(  47)									_hx_tmp4 = true;
            								}
HXDLIN(  47)								if (_hx_tmp4) {
HXLINE(  47)									if (foundY) {
HXLINE(  47)										goto _hx_goto_58;
            									}
            								}
            								else {
HXLINE(  47)									if (((s + t) < A)) {
HXLINE(  47)										int x5 = ::hx::Mod(x4,tileImage->width);
HXDLIN(  47)										int y5 = ::hx::Mod(y4,tileImage->height);
HXDLIN(  47)										::Dynamic this24 = tileImage->image;
HXDLIN(  47)										int index4;
HXDLIN(  47)										if (tileImage->useVirtualPos) {
HXLINE(  47)											index4 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x5) - tileImage->virtualX));
            										}
            										else {
HXLINE(  47)											index4 = ::Std_obj::_hx_int(( (Float)(((y5 * tileImage->width) + x5)) ));
            										}
HXDLIN(  47)										int c3 = ::iterMagic::Iimg_obj::get(this24,index4);
HXDLIN(  47)										int color;
HXDLIN(  47)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)											color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            										}
            										else {
HXLINE(  47)											color = c3;
            										}
HXDLIN(  47)										{
HXLINE(  47)											int c4 = color;
HXDLIN(  47)											bool _hx_tmp5;
HXDLIN(  47)											if ((((c4 >> 24) & 255) < 254)) {
HXLINE(  47)												_hx_tmp5 = this1->transparent;
            											}
            											else {
HXLINE(  47)												_hx_tmp5 = false;
            											}
HXDLIN(  47)											if (_hx_tmp5) {
HXLINE(  47)												int location1;
HXDLIN(  47)												if (this1->useVirtualPos) {
HXLINE(  47)													location1 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - this1->virtualY) * ( (Float)(this1->width) )) + x4) - this1->virtualX));
            												}
            												else {
HXLINE(  47)													location1 = ::Std_obj::_hx_int(( (Float)(((y4 * this1->width) + x4)) ));
            												}
HXDLIN(  47)												int this25 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN(  47)												int this26;
HXDLIN(  47)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)													this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            												}
            												else {
HXLINE(  47)													this26 = this25;
            												}
HXDLIN(  47)												Float a11;
HXDLIN(  47)												int this27 = ((this26 >> 24) & 255);
HXDLIN(  47)												if ((this27 == 0)) {
HXLINE(  47)													a11 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float r11;
HXDLIN(  47)												int this28 = ((this26 >> 16) & 255);
HXDLIN(  47)												if ((this28 == 0)) {
HXLINE(  47)													r11 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float g11;
HXDLIN(  47)												int this29 = ((this26 >> 8) & 255);
HXDLIN(  47)												if ((this29 == 0)) {
HXLINE(  47)													g11 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float b12;
HXDLIN(  47)												int this30 = (this26 & 255);
HXDLIN(  47)												if ((this30 == 0)) {
HXLINE(  47)													b12 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float a21;
HXDLIN(  47)												int this31 = ((color >> 24) & 255);
HXDLIN(  47)												if ((this31 == 0)) {
HXLINE(  47)													a21 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float r21;
HXDLIN(  47)												int this32 = ((color >> 16) & 255);
HXDLIN(  47)												if ((this32 == 0)) {
HXLINE(  47)													r21 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float g21;
HXDLIN(  47)												int this33 = ((color >> 8) & 255);
HXDLIN(  47)												if ((this33 == 0)) {
HXLINE(  47)													g21 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float b22;
HXDLIN(  47)												int this34 = (color & 255);
HXDLIN(  47)												if ((this34 == 0)) {
HXLINE(  47)													b22 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  47)												int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  47)												int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  47)												int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  47)												int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  47)												int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  47)												{
HXLINE(  47)													int _hx_tmp6;
HXDLIN(  47)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)														_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            													}
            													else {
HXLINE(  47)														_hx_tmp6 = blended1;
            													}
HXDLIN(  47)													::iterMagic::Iimg_obj::set(this1->image,location1,_hx_tmp6);
            												}
            											}
            											else {
HXLINE(  47)												::Dynamic this35 = this1->image;
HXDLIN(  47)												int index5;
HXDLIN(  47)												if (this1->useVirtualPos) {
HXLINE(  47)													index5 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - this1->virtualY) * ( (Float)(this1->width) )) + x4) - this1->virtualX));
            												}
            												else {
HXLINE(  47)													index5 = ::Std_obj::_hx_int(( (Float)(((y4 * this1->width) + x4)) ));
            												}
HXDLIN(  47)												int _hx_tmp7;
HXDLIN(  47)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)													_hx_tmp7 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            												}
            												else {
HXLINE(  47)													_hx_tmp7 = c4;
            												}
HXDLIN(  47)												::iterMagic::Iimg_obj::set(this35,index5,_hx_tmp7);
            											}
            										}
HXLINE( 236)										foundY = true;
            									}
            									else {
HXLINE(  47)										if (foundY) {
HXLINE(  47)											goto _hx_goto_58;
            										}
            									}
            								}
            							}
            							_hx_goto_58:;
            						}
            					}
            				}
HXDLIN(  47)				if ((hasHit == false)) {
HXLINE(  47)					 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,x,y,bx1,by,cx,cy1,true);
HXDLIN(  47)					if (hasUndo) {
HXLINE(  47)						v2->undoImage = undoImage;
HXDLIN(  47)						v2->undoX = xIter3->start;
HXDLIN(  47)						v2->undoY = yIter3->start;
            					}
            				}
            			}
            		}
HXDLIN(  47)		{
HXLINE(  47)			Float bx2 = bx;
HXDLIN(  47)			Float by1 = cy;
HXDLIN(  47)			Float cx1 = x;
HXDLIN(  47)			Float cy2 = cy;
HXDLIN(  47)			bool adjustWinding1 = (((((bx * by1) - (bx2 * y)) + ((bx2 * cy2) - (cx1 * by1))) + ((cx1 * y) - (bx * cy2))) > 0);
HXDLIN(  47)			if (!(adjustWinding1)) {
HXLINE(  47)				Float bx_1 = bx2;
HXDLIN(  47)				Float by_1 = by1;
HXLINE( 187)				bx2 = cx1;
HXLINE( 188)				by1 = cy2;
HXLINE( 189)				cx1 = bx_1;
HXLINE( 190)				cy2 = by_1;
            			}
HXLINE(  47)			{
HXLINE(  47)				bool hasUndo1 = false;
HXDLIN(  47)				Float s01 = ((y * cx1) - (bx * cy2));
HXDLIN(  47)				Float sx1 = (cy2 - y);
HXDLIN(  47)				Float sy1 = (bx - cx1);
HXDLIN(  47)				Float t01 = ((bx * by1) - (y * bx2));
HXDLIN(  47)				Float tx1 = (y - by1);
HXDLIN(  47)				Float ty1 = (bx2 - bx);
HXDLIN(  47)				Float A1 = ((((-(by1) * cx1) + (y * (-(bx2) + cx1))) + (bx * (by1 - cy2))) + (bx2 * cy2));
HXDLIN(  47)				 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  47)				if ((bx > bx2)) {
HXLINE(  47)					if ((bx > cx1)) {
HXLINE(  47)						int min4;
HXDLIN(  47)						if ((bx2 > cx1)) {
HXLINE(  47)							min4 = ::Math_obj::floor(cx1);
            						}
            						else {
HXLINE(  47)							min4 = ::Math_obj::floor(bx2);
            						}
HXDLIN(  47)						int ii_min8 = min4;
HXDLIN(  47)						int ii_max8 = ::Math_obj::ceil(bx);
HXDLIN(  47)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            					}
            					else {
HXLINE(  47)						int ii_min9 = ::Math_obj::floor(bx2);
HXDLIN(  47)						int ii_max9 = ::Math_obj::ceil(cx1);
HXDLIN(  47)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            					}
            				}
            				else {
HXLINE(  47)					if ((bx2 > cx1)) {
HXLINE(  47)						int min5;
HXDLIN(  47)						if ((bx > cx1)) {
HXLINE(  47)							min5 = ::Math_obj::floor(cx1);
            						}
            						else {
HXLINE(  47)							min5 = ::Math_obj::ceil(bx);
            						}
HXDLIN(  47)						int ii_min10 = min5;
HXDLIN(  47)						int ii_max10 = ::Math_obj::ceil(bx2);
HXDLIN(  47)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            					}
            					else {
HXLINE(  47)						int ii_min11 = ::Math_obj::floor(bx);
HXDLIN(  47)						int ii_max11 = ::Math_obj::ceil(cx1);
HXDLIN(  47)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            					}
            				}
HXDLIN(  47)				 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  47)				if ((y > by1)) {
HXLINE(  47)					if ((y > cy2)) {
HXLINE(  47)						int min6;
HXDLIN(  47)						if ((by1 > cy2)) {
HXLINE(  47)							min6 = ::Math_obj::floor(cy2);
            						}
            						else {
HXLINE(  47)							min6 = ::Math_obj::floor(by1);
            						}
HXDLIN(  47)						int ii_min12 = min6;
HXDLIN(  47)						int ii_max12 = ::Math_obj::ceil(y);
HXDLIN(  47)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            					}
            					else {
HXLINE(  47)						int ii_min13 = ::Math_obj::floor(by1);
HXDLIN(  47)						int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN(  47)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            					}
            				}
            				else {
HXLINE(  47)					if ((by1 > cy2)) {
HXLINE(  47)						int min7;
HXDLIN(  47)						if ((y > cy2)) {
HXLINE(  47)							min7 = ::Math_obj::floor(cy2);
            						}
            						else {
HXLINE(  47)							min7 = ::Math_obj::ceil(y);
            						}
HXDLIN(  47)						int ii_min14 = min7;
HXDLIN(  47)						int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN(  47)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            					}
            					else {
HXLINE(  47)						int ii_min15 = ::Math_obj::floor(y);
HXDLIN(  47)						int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN(  47)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            					}
            				}
HXDLIN(  47)				 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  47)				if (hasUndo1) {
HXLINE(  47)					int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  47)					int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  47)					 ::Dynamic imageType1 = null();
HXDLIN(  47)					 ::pi_xy::ImageStruct this36 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  47)					if (::hx::IsNull( imageType1 )) {
HXLINE(  54)						imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE(  47)					::Dynamic undoImage4;
HXDLIN(  47)					switch((int)(( (int)(imageType1) ))){
            						case (int)0: {
HXLINE(  47)							 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  47)							 ::iterMagic::BytesImg b5 = byt1;
HXDLIN(  47)							{
HXLINE(  47)								b5->width = width1;
HXDLIN(  47)								b5->height = height1;
HXDLIN(  47)								b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  47)								b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN(  47)								{
HXLINE(  47)									int len2 = b5->length;
HXDLIN(  47)									int w1 = 0;
HXDLIN(  47)									{
HXLINE(  47)										int _g20 = 0;
HXDLIN(  47)										int _g21 = b5->height;
HXDLIN(  47)										while((_g20 < _g21)){
HXLINE(  47)											_g20 = (_g20 + 1);
HXDLIN(  47)											int y6 = (_g20 - 1);
HXDLIN(  47)											{
HXLINE(  47)												int _g22 = 0;
HXDLIN(  47)												int _g23 = b5->width;
HXDLIN(  47)												while((_g22 < _g23)){
HXLINE(  47)													_g22 = (_g22 + 1);
HXDLIN(  47)													int x6 = (_g22 - 1);
HXDLIN(  47)													{
HXLINE(  47)														w1 = (w1 + 1);
HXDLIN(  47)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  47)													{
HXLINE(  47)														w1 = (w1 + 1);
HXDLIN(  47)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  47)													{
HXLINE(  47)														w1 = (w1 + 1);
HXDLIN(  47)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  47)													{
HXLINE(  47)														w1 = (w1 + 1);
HXDLIN(  47)														b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  47)							undoImage4 = b5;
            						}
            						break;
            						case (int)1: {
HXLINE(  47)							 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  47)							 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN(  47)							{
HXLINE(  47)								a6->width = width1;
HXDLIN(  47)								a6->height = height1;
HXDLIN(  47)								a6->data = ::Array_obj< int >::__new(0);
HXDLIN(  47)								a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  47)								{
HXLINE(  47)									int _g24 = 0;
HXDLIN(  47)									int _g25 = a6->length;
HXDLIN(  47)									while((_g24 < _g25)){
HXLINE(  47)										_g24 = (_g24 + 1);
HXDLIN(  47)										int i6 = (_g24 - 1);
HXDLIN(  47)										a6->data[i6] = 0;
            									}
            								}
            							}
HXDLIN(  47)							undoImage4 = a6;
            						}
            						break;
            						case (int)2: {
HXLINE(  47)							 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  47)							 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN(  47)							{
HXLINE(  47)								b6->width = width1;
HXDLIN(  47)								b6->height = height1;
HXDLIN(  47)								b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  47)								int size1 = (b6->length * 4);
HXDLIN(  47)								b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  47)								{
HXLINE(  47)									int _g26 = 0;
HXDLIN(  47)									int _g27 = b6->length;
HXDLIN(  47)									while((_g26 < _g27)){
HXLINE(  47)										_g26 = (_g26 + 1);
HXDLIN(  47)										int i7 = (_g26 - 1);
HXDLIN(  47)										{
HXLINE(  47)											 ::haxe::io::ArrayBufferViewImpl this37 = b6->data;
HXDLIN(  47)											bool undoImage5;
HXDLIN(  47)											if ((i7 >= 0)) {
HXLINE(  47)												undoImage5 = (i7 < (this37->byteLength >> 2));
            											}
            											else {
HXLINE(  47)												undoImage5 = false;
            											}
HXDLIN(  47)											if (undoImage5) {
HXLINE(  47)												 ::haxe::io::Bytes _this1 = this37->bytes;
HXDLIN(  47)												int pos1 = ((i7 << 2) + this37->byteOffset);
HXDLIN(  47)												_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  47)												_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  47)												_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  47)												_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN(  47)							undoImage4 = b6;
            						}
            						break;
            						case (int)3: {
HXLINE(  47)							 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  47)							 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN(  47)							{
HXLINE(  47)								v3->width = width1;
HXDLIN(  47)								v3->height = height1;
HXDLIN(  47)								v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  47)								v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN(  47)								{
HXLINE(  47)									int _g28 = 0;
HXDLIN(  47)									int _g29 = v3->length;
HXDLIN(  47)									while((_g28 < _g29)){
HXLINE(  47)										_g28 = (_g28 + 1);
HXDLIN(  47)										int i8 = (_g28 - 1);
HXDLIN(  47)										v3->data->__unsafe_set(i8,0);
            									}
            								}
            							}
HXDLIN(  47)							undoImage4 = v3;
            						}
            						break;
            						case (int)4: {
HXLINE(  47)							 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  47)							 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN(  47)							{
HXLINE(  47)								b7->width = width1;
HXDLIN(  47)								b7->height = height1;
HXDLIN(  47)								b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  47)								b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  47)								{
HXLINE(  47)									int len3 = b7->length;
HXDLIN(  47)									 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN(  47)									if (::hx::IsNull( d1->head )) {
HXLINE(  47)										int _g30 = 0;
HXDLIN(  47)										int _g31 = len3;
HXDLIN(  47)										while((_g30 < _g31)){
HXLINE(  47)											_g30 = (_g30 + 1);
HXDLIN(  47)											int i9 = (_g30 - 1);
HXDLIN(  47)											d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            										}
            									}
            									else {
HXLINE(  47)										int _g32 = 0;
HXDLIN(  47)										int _g33 = len3;
HXDLIN(  47)										while((_g32 < _g33)){
HXLINE(  47)											_g32 = (_g32 + 1);
HXDLIN(  47)											int i10 = (_g32 - 1);
HXDLIN(  47)											{
HXLINE(  47)												 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN(  47)												 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  47)												{
HXLINE(  47)													int _g34 = 0;
HXDLIN(  47)													int _g35 = i10;
HXDLIN(  47)													while((_g34 < _g35)){
HXLINE(  47)														_g34 = (_g34 + 1);
HXDLIN(  47)														int i11 = (_g34 - 1);
HXLINE( 345)														prev1 = l1;
HXLINE( 346)														l1 = l1->next;
            													}
            												}
HXLINE(  47)												if (::hx::IsNull( prev1 )) {
HXLINE(  47)													b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  47)													l1 = null();
            												}
            												else {
HXLINE(  47)													prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  47)													l1 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  47)							undoImage4 = b7;
            						}
            						break;
            					}
HXDLIN(  47)					this36->image = undoImage4;
HXDLIN(  47)					this36->width = width1;
HXDLIN(  47)					this36->height = height1;
HXDLIN(  47)					this36->imageType = ( (int)(imageType1) );
HXDLIN(  47)					undoImage3 = this36;
HXDLIN(  47)					{
HXLINE(  47)						int rectLeft1 = xIter31->start;
HXDLIN(  47)						int rectTop1 = yIter31->start;
HXDLIN(  47)						int rectRight1 = xIter31->max;
HXDLIN(  47)						bool forceClear1 = false;
HXDLIN(  47)						{
HXLINE(  47)							int _g36 = rectTop1;
HXDLIN(  47)							int _g37 = yIter31->max;
HXDLIN(  47)							while((_g36 < _g37)){
HXLINE(  47)								_g36 = (_g36 + 1);
HXDLIN(  47)								int dy1 = (_g36 - 1);
HXDLIN(  47)								{
HXLINE(  47)									int _g38 = rectLeft1;
HXDLIN(  47)									int _g39 = rectRight1;
HXDLIN(  47)									while((_g38 < _g39)){
HXLINE(  47)										_g38 = (_g38 + 1);
HXDLIN(  47)										int dx1 = (_g38 - 1);
HXDLIN(  47)										::Dynamic this38 = this1->image;
HXDLIN(  47)										int index6;
HXDLIN(  47)										if (this1->useVirtualPos) {
HXLINE(  47)											index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx1) - this1->virtualX));
            										}
            										else {
HXLINE(  47)											index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this1->width) + dx1)) ));
            										}
HXDLIN(  47)										int c5 = ::iterMagic::Iimg_obj::get(this38,index6);
HXDLIN(  47)										int col1;
HXDLIN(  47)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)											col1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            										}
            										else {
HXLINE(  47)											col1 = c5;
            										}
HXDLIN(  47)										bool _hx_tmp8;
HXDLIN(  47)										if (this1->useMask) {
HXLINE(  47)											_hx_tmp8 = ::hx::IsNotNull( this1->mask );
            										}
            										else {
HXLINE(  47)											_hx_tmp8 = false;
            										}
HXDLIN(  47)										if (_hx_tmp8) {
HXLINE(  47)											 ::pi_xy::ImageStruct this39 = this1->mask;
HXDLIN(  47)											::Dynamic this40 = this39->image;
HXDLIN(  47)											int index7;
HXDLIN(  47)											if (this39->useVirtualPos) {
HXLINE(  47)												index7 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this39->virtualY) * ( (Float)(this39->width) )) + dx1) - this39->virtualX));
            											}
            											else {
HXLINE(  47)												index7 = ::Std_obj::_hx_int(( (Float)(((dy1 * this39->width) + dx1)) ));
            											}
HXDLIN(  47)											int c6 = ::iterMagic::Iimg_obj::get(this40,index7);
HXDLIN(  47)											int v4;
HXDLIN(  47)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)												v4 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            											}
            											else {
HXLINE(  47)												v4 = c6;
            											}
HXDLIN(  47)											int maskPixel1 = v4;
HXDLIN(  47)											int this41 = col1;
HXDLIN(  47)											if ((maskPixel1 == 0)) {
HXLINE(  47)												col1 = this41;
            											}
            											else {
HXLINE(  47)												Float m01;
HXDLIN(  47)												int this42 = ((maskPixel1 >> 24) & 255);
HXDLIN(  47)												if ((this42 == 0)) {
HXLINE(  47)													m01 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													m01 = (( (Float)(this42) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float m11;
HXDLIN(  47)												int this43 = ((maskPixel1 >> 16) & 255);
HXDLIN(  47)												if ((this43 == 0)) {
HXLINE(  47)													m11 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													m11 = (( (Float)(this43) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float m21;
HXDLIN(  47)												int this44 = ((maskPixel1 >> 8) & 255);
HXDLIN(  47)												if ((this44 == 0)) {
HXLINE(  47)													m21 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													m21 = (( (Float)(this44) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float m31;
HXDLIN(  47)												int this45 = (maskPixel1 & 255);
HXDLIN(  47)												if ((this45 == 0)) {
HXLINE(  47)													m31 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													m31 = (( (Float)(this45) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this41 >> 24) & 255)) )));
HXDLIN(  47)												int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this41 >> 16) & 255)) )));
HXDLIN(  47)												int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this41 >> 8) & 255)) )));
HXDLIN(  47)												int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this41 & 255)) )));
HXDLIN(  47)												col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN(  47)										if ((col1 != 0)) {
HXLINE(  47)											int x7 = (dx1 - rectLeft1);
HXDLIN(  47)											int y7 = (dy1 - rectTop1);
HXDLIN(  47)											int c7 = col1;
HXDLIN(  47)											bool _hx_tmp9;
HXDLIN(  47)											if ((((c7 >> 24) & 255) < 254)) {
HXLINE(  47)												_hx_tmp9 = undoImage3->transparent;
            											}
            											else {
HXLINE(  47)												_hx_tmp9 = false;
            											}
HXDLIN(  47)											if (_hx_tmp9) {
HXLINE(  47)												int location2;
HXDLIN(  47)												if (undoImage3->useVirtualPos) {
HXLINE(  47)													location2 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x7) - undoImage3->virtualX));
            												}
            												else {
HXLINE(  47)													location2 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage3->width) + x7)) ));
            												}
HXDLIN(  47)												int this46 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN(  47)												int this47;
HXDLIN(  47)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)													this47 = ((((((this46 >> 24) & 255) << 24) | ((this46 & 255) << 16)) | (((this46 >> 8) & 255) << 8)) | ((this46 >> 16) & 255));
            												}
            												else {
HXLINE(  47)													this47 = this46;
            												}
HXDLIN(  47)												Float a12;
HXDLIN(  47)												int this48 = ((this47 >> 24) & 255);
HXDLIN(  47)												if ((this48 == 0)) {
HXLINE(  47)													a12 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													a12 = (( (Float)(this48) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float r12;
HXDLIN(  47)												int this49 = ((this47 >> 16) & 255);
HXDLIN(  47)												if ((this49 == 0)) {
HXLINE(  47)													r12 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													r12 = (( (Float)(this49) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float g12;
HXDLIN(  47)												int this50 = ((this47 >> 8) & 255);
HXDLIN(  47)												if ((this50 == 0)) {
HXLINE(  47)													g12 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													g12 = (( (Float)(this50) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float b13;
HXDLIN(  47)												int this51 = (this47 & 255);
HXDLIN(  47)												if ((this51 == 0)) {
HXLINE(  47)													b13 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													b13 = (( (Float)(this51) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float a22;
HXDLIN(  47)												int this52 = ((col1 >> 24) & 255);
HXDLIN(  47)												if ((this52 == 0)) {
HXLINE(  47)													a22 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													a22 = (( (Float)(this52) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float r22;
HXDLIN(  47)												int this53 = ((col1 >> 16) & 255);
HXDLIN(  47)												if ((this53 == 0)) {
HXLINE(  47)													r22 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													r22 = (( (Float)(this53) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float g22;
HXDLIN(  47)												int this54 = ((col1 >> 8) & 255);
HXDLIN(  47)												if ((this54 == 0)) {
HXLINE(  47)													g22 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													g22 = (( (Float)(this54) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float b23;
HXDLIN(  47)												int this55 = (col1 & 255);
HXDLIN(  47)												if ((this55 == 0)) {
HXLINE(  47)													b23 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													b23 = (( (Float)(this55) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  47)												int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  47)												int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  47)												int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  47)												int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  47)												int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN(  47)												{
HXLINE(  47)													int _hx_tmp10;
HXDLIN(  47)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)														_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            													}
            													else {
HXLINE(  47)														_hx_tmp10 = blended2;
            													}
HXDLIN(  47)													::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            												}
            											}
            											else {
HXLINE(  47)												::Dynamic this56 = undoImage3->image;
HXDLIN(  47)												int index8;
HXDLIN(  47)												if (undoImage3->useVirtualPos) {
HXLINE(  47)													index8 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x7) - undoImage3->virtualX));
            												}
            												else {
HXLINE(  47)													index8 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage3->width) + x7)) ));
            												}
HXDLIN(  47)												int _hx_tmp11;
HXDLIN(  47)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)													_hx_tmp11 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            												}
            												else {
HXLINE(  47)													_hx_tmp11 = c7;
            												}
HXDLIN(  47)												::iterMagic::Iimg_obj::set(this56,index8,_hx_tmp11);
            											}
            										}
            										else {
HXLINE(  47)											if (forceClear1) {
HXLINE(  47)												::Dynamic this57 = undoImage3->image;
HXDLIN(  47)												int x8 = (dx1 - rectLeft1);
HXDLIN(  47)												int y8 = (dy1 - rectTop1);
HXDLIN(  47)												int index9;
HXDLIN(  47)												if (undoImage3->useVirtualPos) {
HXLINE(  47)													index9 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x8) - undoImage3->virtualX));
            												}
            												else {
HXLINE(  47)													index9 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage3->width) + x8)) ));
            												}
HXDLIN(  47)												::iterMagic::Iimg_obj::set(this57,index9,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  47)				bool foundY1 = false;
HXDLIN(  47)				Float s1 = ((Float)0.);
HXDLIN(  47)				Float t1 = ((Float)0.);
HXDLIN(  47)				Float sxx1 = ((Float)0.);
HXDLIN(  47)				Float txx1 = ((Float)0.);
HXDLIN(  47)				{
HXLINE(  47)					int _g_min2 = xIter31->start;
HXDLIN(  47)					int _g_max2 = xIter31->max;
HXDLIN(  47)					while((_g_min2 < _g_max2)){
HXLINE(  47)						_g_min2 = (_g_min2 + 1);
HXDLIN(  47)						int x9 = (_g_min2 - 1);
HXLINE( 222)						sxx1 = (sx1 * ( (Float)(x9) ));
HXLINE( 223)						txx1 = (tx1 * ( (Float)(x9) ));
HXLINE( 224)						foundY1 = false;
HXLINE(  47)						{
HXLINE(  47)							int _g_min3 = yIter31->start;
HXDLIN(  47)							int _g_max3 = yIter31->max;
HXDLIN(  47)							while((_g_min3 < _g_max3)){
HXLINE(  47)								_g_min3 = (_g_min3 + 1);
HXDLIN(  47)								int y9 = (_g_min3 - 1);
HXLINE( 226)								s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y9) )));
HXLINE( 227)								t1 = ((t01 + txx1) + (ty1 * ( (Float)(y9) )));
HXLINE(  47)								bool _hx_tmp12;
HXDLIN(  47)								if (!((s1 <= 0))) {
HXLINE(  47)									_hx_tmp12 = (t1 <= 0);
            								}
            								else {
HXLINE(  47)									_hx_tmp12 = true;
            								}
HXDLIN(  47)								if (_hx_tmp12) {
HXLINE(  47)									if (foundY1) {
HXLINE(  47)										goto _hx_goto_70;
            									}
            								}
            								else {
HXLINE(  47)									if (((s1 + t1) < A1)) {
HXLINE(  47)										int x10 = ::hx::Mod(x9,tileImage->width);
HXDLIN(  47)										int y10 = ::hx::Mod(y9,tileImage->height);
HXDLIN(  47)										::Dynamic this58 = tileImage->image;
HXDLIN(  47)										int index10;
HXDLIN(  47)										if (tileImage->useVirtualPos) {
HXLINE(  47)											index10 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x10) - tileImage->virtualX));
            										}
            										else {
HXLINE(  47)											index10 = ::Std_obj::_hx_int(( (Float)(((y10 * tileImage->width) + x10)) ));
            										}
HXDLIN(  47)										int c8 = ::iterMagic::Iimg_obj::get(this58,index10);
HXDLIN(  47)										int color1;
HXDLIN(  47)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)											color1 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            										}
            										else {
HXLINE(  47)											color1 = c8;
            										}
HXDLIN(  47)										{
HXLINE(  47)											int c9 = color1;
HXDLIN(  47)											bool _hx_tmp13;
HXDLIN(  47)											if ((((c9 >> 24) & 255) < 254)) {
HXLINE(  47)												_hx_tmp13 = this1->transparent;
            											}
            											else {
HXLINE(  47)												_hx_tmp13 = false;
            											}
HXDLIN(  47)											if (_hx_tmp13) {
HXLINE(  47)												int location3;
HXDLIN(  47)												if (this1->useVirtualPos) {
HXLINE(  47)													location3 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - this1->virtualY) * ( (Float)(this1->width) )) + x9) - this1->virtualX));
            												}
            												else {
HXLINE(  47)													location3 = ::Std_obj::_hx_int(( (Float)(((y9 * this1->width) + x9)) ));
            												}
HXDLIN(  47)												int this59 = ::iterMagic::Iimg_obj::get(this1->image,location3);
HXDLIN(  47)												int this60;
HXDLIN(  47)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)													this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            												}
            												else {
HXLINE(  47)													this60 = this59;
            												}
HXDLIN(  47)												Float a13;
HXDLIN(  47)												int this61 = ((this60 >> 24) & 255);
HXDLIN(  47)												if ((this61 == 0)) {
HXLINE(  47)													a13 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													a13 = (( (Float)(this61) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float r13;
HXDLIN(  47)												int this62 = ((this60 >> 16) & 255);
HXDLIN(  47)												if ((this62 == 0)) {
HXLINE(  47)													r13 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													r13 = (( (Float)(this62) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float g13;
HXDLIN(  47)												int this63 = ((this60 >> 8) & 255);
HXDLIN(  47)												if ((this63 == 0)) {
HXLINE(  47)													g13 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													g13 = (( (Float)(this63) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float b14;
HXDLIN(  47)												int this64 = (this60 & 255);
HXDLIN(  47)												if ((this64 == 0)) {
HXLINE(  47)													b14 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float a23;
HXDLIN(  47)												int this65 = ((color1 >> 24) & 255);
HXDLIN(  47)												if ((this65 == 0)) {
HXLINE(  47)													a23 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													a23 = (( (Float)(this65) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float r23;
HXDLIN(  47)												int this66 = ((color1 >> 16) & 255);
HXDLIN(  47)												if ((this66 == 0)) {
HXLINE(  47)													r23 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													r23 = (( (Float)(this66) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float g23;
HXDLIN(  47)												int this67 = ((color1 >> 8) & 255);
HXDLIN(  47)												if ((this67 == 0)) {
HXLINE(  47)													g23 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													g23 = (( (Float)(this67) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float b24;
HXDLIN(  47)												int this68 = (color1 & 255);
HXDLIN(  47)												if ((this68 == 0)) {
HXLINE(  47)													b24 = ((Float)0.);
            												}
            												else {
HXLINE(  47)													b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            												}
HXDLIN(  47)												Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  47)												int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  47)												int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  47)												int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN(  47)												int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  47)												int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN(  47)												{
HXLINE(  47)													int _hx_tmp14;
HXDLIN(  47)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)														_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            													}
            													else {
HXLINE(  47)														_hx_tmp14 = blended3;
            													}
HXDLIN(  47)													::iterMagic::Iimg_obj::set(this1->image,location3,_hx_tmp14);
            												}
            											}
            											else {
HXLINE(  47)												::Dynamic this69 = this1->image;
HXDLIN(  47)												int index11;
HXDLIN(  47)												if (this1->useVirtualPos) {
HXLINE(  47)													index11 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - this1->virtualY) * ( (Float)(this1->width) )) + x9) - this1->virtualX));
            												}
            												else {
HXLINE(  47)													index11 = ::Std_obj::_hx_int(( (Float)(((y9 * this1->width) + x9)) ));
            												}
HXDLIN(  47)												int _hx_tmp15;
HXDLIN(  47)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  47)													_hx_tmp15 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            												}
            												else {
HXLINE(  47)													_hx_tmp15 = c9;
            												}
HXDLIN(  47)												::iterMagic::Iimg_obj::set(this69,index11,_hx_tmp15);
            											}
            										}
HXLINE( 236)										foundY1 = true;
            									}
            									else {
HXLINE(  47)										if (foundY1) {
HXLINE(  47)											goto _hx_goto_70;
            										}
            									}
            								}
            							}
            							_hx_goto_70:;
            						}
            					}
            				}
HXDLIN(  47)				if ((hasHit == false)) {
HXLINE(  47)					 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx,y,bx2,by1,cx1,cy2,true);
HXDLIN(  47)					if (hasUndo1) {
HXLINE(  47)						v5->undoImage = undoImage3;
HXDLIN(  47)						v5->undoX = xIter31->start;
HXDLIN(  47)						v5->undoY = yIter31->start;
            					}
            				}
            			}
            		}
HXDLIN(  47)		 ::pi_xy::algo::HitQuad _hx_tmp16;
HXDLIN(  47)		if ((hasHit == true)) {
HXLINE(  47)			 ::pi_xy::algo::HitQuad v6 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,x,y,bx,y,bx,cy,x,cy,true);
HXDLIN(  47)			_hx_tmp16 = v6;
            		}
            		else {
HXLINE(  47)			_hx_tmp16 = null();
            		}
HXDLIN(  47)		return _hx_tmp16;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(TileShape_Impl__obj,rectangle,return )

 ::pi_xy::algo::HitQuad TileShape_Impl__obj::line( ::pi_xy::ImageStruct this1,Float px,Float py,Float qx,Float qy,Float thick, ::pi_xy::ImageStruct tileImage,::hx::Null< bool >  __o_hasHit, ::Dynamic __o_debugCorners){
            		bool hasHit = __o_hasHit.Default(false);
            		 ::Dynamic debugCorners = __o_debugCorners;
            		if (::hx::IsNull(__o_debugCorners)) debugCorners = false;
            	HX_GC_STACKFRAME(&_hx_pos_6e4d7718bf84d356_56_line)
HXLINE(  57)		Float o = (qy - py);
HXLINE(  58)		Float a = (qx - px);
HXLINE(  59)		Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXLINE(  60)		Float theta = ::Math_obj::atan2(o,a);
HXLINE(  61)		 ::Dynamic debugCorners1 = debugCorners;
HXLINE(  62)		if (::hx::IsNull( debugCorners1 )) {
HXLINE(  62)			debugCorners1 = false;
            		}
HXLINE(  61)		Float sin = ::Math_obj::sin(theta);
HXDLIN(  61)		Float cos = ::Math_obj::cos(theta);
HXDLIN(  61)		Float radius = (thick / ( (Float)(2) ));
HXDLIN(  61)		Float dx = ((Float)0.1);
HXDLIN(  61)		Float dy = radius;
HXDLIN(  61)		Float cx = h;
HXDLIN(  61)		Float cy = radius;
HXDLIN(  61)		Float bx = h;
HXDLIN(  61)		Float by = -(radius);
HXDLIN(  61)		Float ax = ((Float)0.1);
HXDLIN(  61)		Float ay = -(radius);
HXDLIN(  61)		Float temp = ((Float)0.);
HXLINE( 380)		temp = (px + ((ax * cos) - (ay * sin)));
HXLINE( 381)		ay = (py + ((ay * cos) + (ax * sin)));
HXLINE( 382)		ax = temp;
HXLINE( 384)		temp = (px + ((bx * cos) - (by * sin)));
HXLINE( 385)		by = (py + ((by * cos) + (bx * sin)));
HXLINE( 386)		bx = temp;
HXLINE( 388)		temp = (px + ((cx * cos) - (cy * sin)));
HXLINE( 389)		cy = (py + ((cy * cos) + (cx * sin)));
HXLINE( 390)		cx = temp;
HXLINE( 392)		temp = (px + ((dx * cos) - (dy * sin)));
HXLINE( 393)		dy = (py + ((dy * cos) + (dx * sin)));
HXLINE( 394)		dx = temp;
HXLINE(  61)		if (( (bool)(debugCorners1) )) {
HXLINE(  61)			{
HXLINE(  61)				 ::pi_xy::ImageStruct this2 = this1;
HXDLIN(  61)				{
HXLINE(  61)					int r_x = ::Std_obj::_hx_int((ax - ((Float)6.)));
HXDLIN(  61)					int r_y = ::Std_obj::_hx_int((ay - ((Float)6.)));
HXDLIN(  61)					int r_w = 12;
HXDLIN(  61)					int r_h = 12;
HXDLIN(  61)					int xmax = ((r_x + r_w) + 1);
HXDLIN(  61)					int ymax = ((r_y + r_h) + 1);
HXDLIN(  61)					int ii_min = r_x;
HXDLIN(  61)					int ii_max = xmax;
HXDLIN(  61)					int xRange__start = ii_min;
HXDLIN(  61)					int xRange__max = ii_max;
HXDLIN(  61)					int ii_min1 = r_y;
HXDLIN(  61)					int ii_max1 = ymax;
HXDLIN(  61)					int yRange__start = ii_min1;
HXDLIN(  61)					int yRange__max = ii_max1;
HXDLIN(  61)					int range_x = xRange__start;
HXDLIN(  61)					int range_y = (yRange__start - 1);
HXDLIN(  61)					int range_xReset = range_x;
HXDLIN(  61)					int range_yReset = range_y;
HXDLIN(  61)					int range_xMax = (xRange__max - 2);
HXDLIN(  61)					int range_yMax = (yRange__max - 2);
HXDLIN(  61)					int _this_min = 0;
HXDLIN(  61)					int _this_max = ::Std_obj::_hx_int(( (Float)(((xRange__max - xRange__start) * (yRange__max - yRange__start))) ));
HXDLIN(  61)					while((_this_min < _this_max)){
HXLINE(  61)						_this_min = (_this_min + 1);
HXDLIN(  61)						int i = (_this_min - 1);
HXDLIN(  61)						if ((range_y > range_yMax)) {
HXLINE(  61)							range_y = range_yReset;
HXDLIN(  61)							range_x = (range_x + 1);
            						}
HXDLIN(  61)						range_y = (range_y + 1);
HXDLIN(  61)						int i1 = i;
HXDLIN(  61)						{
HXLINE(  61)							int x = range_x;
HXDLIN(  61)							int y = range_y;
HXDLIN(  61)							int c = -65536;
HXDLIN(  61)							bool _hx_tmp;
HXDLIN(  61)							if ((((c >> 24) & 255) < 254)) {
HXLINE(  61)								_hx_tmp = this2->transparent;
            							}
            							else {
HXLINE(  61)								_hx_tmp = false;
            							}
HXDLIN(  61)							if (_hx_tmp) {
HXLINE(  61)								int location;
HXDLIN(  61)								if (this2->useVirtualPos) {
HXLINE(  61)									location = ::Std_obj::_hx_int(((((( (Float)(y) ) - this2->virtualY) * ( (Float)(this2->width) )) + x) - this2->virtualX));
            								}
            								else {
HXLINE(  61)									location = ::Std_obj::_hx_int(( (Float)(((y * this2->width) + x)) ));
            								}
HXDLIN(  61)								int this3 = ::iterMagic::Iimg_obj::get(this2->image,location);
HXDLIN(  61)								int this4;
HXDLIN(  61)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)									this4 = ((((((this3 >> 24) & 255) << 24) | ((this3 & 255) << 16)) | (((this3 >> 8) & 255) << 8)) | ((this3 >> 16) & 255));
            								}
            								else {
HXLINE(  61)									this4 = this3;
            								}
HXDLIN(  61)								Float a1;
HXDLIN(  61)								int this5 = ((this4 >> 24) & 255);
HXDLIN(  61)								if ((this5 == 0)) {
HXLINE(  61)									a1 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									a1 = (( (Float)(this5) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float r1;
HXDLIN(  61)								int this6 = ((this4 >> 16) & 255);
HXDLIN(  61)								if ((this6 == 0)) {
HXLINE(  61)									r1 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									r1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float g1;
HXDLIN(  61)								int this7 = ((this4 >> 8) & 255);
HXDLIN(  61)								if ((this7 == 0)) {
HXLINE(  61)									g1 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									g1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float b1;
HXDLIN(  61)								int this8 = (this4 & 255);
HXDLIN(  61)								if ((this8 == 0)) {
HXLINE(  61)									b1 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									b1 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float a2;
HXDLIN(  61)								int this9 = ((-65536 >> 24) & 255);
HXDLIN(  61)								if ((this9 == 0)) {
HXLINE(  61)									a2 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									a2 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float r2;
HXDLIN(  61)								int this10 = ((-65536 >> 16) & 255);
HXDLIN(  61)								if ((this10 == 0)) {
HXLINE(  61)									r2 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									r2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float g2;
HXDLIN(  61)								int this11 = ((-65536 >> 8) & 255);
HXDLIN(  61)								if ((this11 == 0)) {
HXLINE(  61)									g2 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									g2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float b2;
HXDLIN(  61)								int this12 = (-65536 & 255);
HXDLIN(  61)								if ((this12 == 0)) {
HXLINE(  61)									b2 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									b2 = (( (Float)(this12) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  61)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  61)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  61)								int b = ::Std_obj::_hx_int((( (Float)(255) ) * ((b1 * a3) + (b2 * a2))));
HXDLIN(  61)								int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  61)								int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b);
HXDLIN(  61)								{
HXLINE(  61)									int _hx_tmp1;
HXDLIN(  61)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)										_hx_tmp1 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE(  61)										_hx_tmp1 = blended;
            									}
HXDLIN(  61)									::iterMagic::Iimg_obj::set(this2->image,location,_hx_tmp1);
            								}
            							}
            							else {
HXLINE(  61)								::Dynamic this13 = this2->image;
HXDLIN(  61)								int index;
HXDLIN(  61)								if (this2->useVirtualPos) {
HXLINE(  61)									index = ::Std_obj::_hx_int(((((( (Float)(y) ) - this2->virtualY) * ( (Float)(this2->width) )) + x) - this2->virtualX));
            								}
            								else {
HXLINE(  61)									index = ::Std_obj::_hx_int(( (Float)(((y * this2->width) + x)) ));
            								}
HXDLIN(  61)								int _hx_tmp2;
HXDLIN(  61)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)									_hx_tmp2 = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  61)									_hx_tmp2 = c;
            								}
HXDLIN(  61)								::iterMagic::Iimg_obj::set(this13,index,_hx_tmp2);
            							}
            						}
            					}
            				}
            			}
HXDLIN(  61)			{
HXLINE(  61)				 ::pi_xy::ImageStruct this14 = this1;
HXDLIN(  61)				{
HXLINE(  61)					int r_x1 = ::Std_obj::_hx_int((bx - ((Float)6.)));
HXDLIN(  61)					int r_y1 = ::Std_obj::_hx_int((by - ((Float)6.)));
HXDLIN(  61)					int r_w1 = 12;
HXDLIN(  61)					int r_h1 = 12;
HXDLIN(  61)					int xmax1 = ((r_x1 + r_w1) + 1);
HXDLIN(  61)					int ymax1 = ((r_y1 + r_h1) + 1);
HXDLIN(  61)					int ii_min2 = r_x1;
HXDLIN(  61)					int ii_max2 = xmax1;
HXDLIN(  61)					int xRange__start1 = ii_min2;
HXDLIN(  61)					int xRange__max1 = ii_max2;
HXDLIN(  61)					int ii_min3 = r_y1;
HXDLIN(  61)					int ii_max3 = ymax1;
HXDLIN(  61)					int yRange__start1 = ii_min3;
HXDLIN(  61)					int yRange__max1 = ii_max3;
HXDLIN(  61)					int range_x1 = xRange__start1;
HXDLIN(  61)					int range_y1 = (yRange__start1 - 1);
HXDLIN(  61)					int range_xReset1 = range_x1;
HXDLIN(  61)					int range_yReset1 = range_y1;
HXDLIN(  61)					int range_xMax1 = (xRange__max1 - 2);
HXDLIN(  61)					int range_yMax1 = (yRange__max1 - 2);
HXDLIN(  61)					int _this_min1 = 0;
HXDLIN(  61)					int _this_max1 = ::Std_obj::_hx_int(( (Float)(((xRange__max1 - xRange__start1) * (yRange__max1 - yRange__start1))) ));
HXDLIN(  61)					while((_this_min1 < _this_max1)){
HXLINE(  61)						_this_min1 = (_this_min1 + 1);
HXDLIN(  61)						int i2 = (_this_min1 - 1);
HXDLIN(  61)						if ((range_y1 > range_yMax1)) {
HXLINE(  61)							range_y1 = range_yReset1;
HXDLIN(  61)							range_x1 = (range_x1 + 1);
            						}
HXDLIN(  61)						range_y1 = (range_y1 + 1);
HXDLIN(  61)						int i3 = i2;
HXDLIN(  61)						{
HXLINE(  61)							int x1 = range_x1;
HXDLIN(  61)							int y1 = range_y1;
HXDLIN(  61)							int c1 = -16711936;
HXDLIN(  61)							bool _hx_tmp3;
HXDLIN(  61)							if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  61)								_hx_tmp3 = this14->transparent;
            							}
            							else {
HXLINE(  61)								_hx_tmp3 = false;
            							}
HXDLIN(  61)							if (_hx_tmp3) {
HXLINE(  61)								int location1;
HXDLIN(  61)								if (this14->useVirtualPos) {
HXLINE(  61)									location1 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this14->virtualY) * ( (Float)(this14->width) )) + x1) - this14->virtualX));
            								}
            								else {
HXLINE(  61)									location1 = ::Std_obj::_hx_int(( (Float)(((y1 * this14->width) + x1)) ));
            								}
HXDLIN(  61)								int this15 = ::iterMagic::Iimg_obj::get(this14->image,location1);
HXDLIN(  61)								int this16;
HXDLIN(  61)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)									this16 = ((((((this15 >> 24) & 255) << 24) | ((this15 & 255) << 16)) | (((this15 >> 8) & 255) << 8)) | ((this15 >> 16) & 255));
            								}
            								else {
HXLINE(  61)									this16 = this15;
            								}
HXDLIN(  61)								Float a11;
HXDLIN(  61)								int this17 = ((this16 >> 24) & 255);
HXDLIN(  61)								if ((this17 == 0)) {
HXLINE(  61)									a11 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									a11 = (( (Float)(this17) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float r11;
HXDLIN(  61)								int this18 = ((this16 >> 16) & 255);
HXDLIN(  61)								if ((this18 == 0)) {
HXLINE(  61)									r11 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									r11 = (( (Float)(this18) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float g11;
HXDLIN(  61)								int this19 = ((this16 >> 8) & 255);
HXDLIN(  61)								if ((this19 == 0)) {
HXLINE(  61)									g11 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									g11 = (( (Float)(this19) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float b11;
HXDLIN(  61)								int this20 = (this16 & 255);
HXDLIN(  61)								if ((this20 == 0)) {
HXLINE(  61)									b11 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									b11 = (( (Float)(this20) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float a21;
HXDLIN(  61)								int this21 = ((-16711936 >> 24) & 255);
HXDLIN(  61)								if ((this21 == 0)) {
HXLINE(  61)									a21 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									a21 = (( (Float)(this21) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float r21;
HXDLIN(  61)								int this22 = ((-16711936 >> 16) & 255);
HXDLIN(  61)								if ((this22 == 0)) {
HXLINE(  61)									r21 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									r21 = (( (Float)(this22) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float g21;
HXDLIN(  61)								int this23 = ((-16711936 >> 8) & 255);
HXDLIN(  61)								if ((this23 == 0)) {
HXLINE(  61)									g21 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									g21 = (( (Float)(this23) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float b21;
HXDLIN(  61)								int this24 = (-16711936 & 255);
HXDLIN(  61)								if ((this24 == 0)) {
HXLINE(  61)									b21 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									b21 = (( (Float)(this24) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  61)								int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  61)								int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  61)								int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a31) + (b21 * a21))));
HXDLIN(  61)								int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  61)								int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b3);
HXDLIN(  61)								{
HXLINE(  61)									int _hx_tmp4;
HXDLIN(  61)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)										_hx_tmp4 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            									}
            									else {
HXLINE(  61)										_hx_tmp4 = blended1;
            									}
HXDLIN(  61)									::iterMagic::Iimg_obj::set(this14->image,location1,_hx_tmp4);
            								}
            							}
            							else {
HXLINE(  61)								::Dynamic this25 = this14->image;
HXDLIN(  61)								int index1;
HXDLIN(  61)								if (this14->useVirtualPos) {
HXLINE(  61)									index1 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - this14->virtualY) * ( (Float)(this14->width) )) + x1) - this14->virtualX));
            								}
            								else {
HXLINE(  61)									index1 = ::Std_obj::_hx_int(( (Float)(((y1 * this14->width) + x1)) ));
            								}
HXDLIN(  61)								int _hx_tmp5;
HXDLIN(  61)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)									_hx_tmp5 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            								}
            								else {
HXLINE(  61)									_hx_tmp5 = c1;
            								}
HXDLIN(  61)								::iterMagic::Iimg_obj::set(this25,index1,_hx_tmp5);
            							}
            						}
            					}
            				}
            			}
HXDLIN(  61)			{
HXLINE(  61)				 ::pi_xy::ImageStruct this26 = this1;
HXDLIN(  61)				{
HXLINE(  61)					int r_x2 = ::Std_obj::_hx_int((cx - ((Float)6.)));
HXDLIN(  61)					int r_y2 = ::Std_obj::_hx_int((cy - ((Float)6.)));
HXDLIN(  61)					int r_w2 = 12;
HXDLIN(  61)					int r_h2 = 12;
HXDLIN(  61)					int xmax2 = ((r_x2 + r_w2) + 1);
HXDLIN(  61)					int ymax2 = ((r_y2 + r_h2) + 1);
HXDLIN(  61)					int ii_min4 = r_x2;
HXDLIN(  61)					int ii_max4 = xmax2;
HXDLIN(  61)					int xRange__start2 = ii_min4;
HXDLIN(  61)					int xRange__max2 = ii_max4;
HXDLIN(  61)					int ii_min5 = r_y2;
HXDLIN(  61)					int ii_max5 = ymax2;
HXDLIN(  61)					int yRange__start2 = ii_min5;
HXDLIN(  61)					int yRange__max2 = ii_max5;
HXDLIN(  61)					int range_x2 = xRange__start2;
HXDLIN(  61)					int range_y2 = (yRange__start2 - 1);
HXDLIN(  61)					int range_xReset2 = range_x2;
HXDLIN(  61)					int range_yReset2 = range_y2;
HXDLIN(  61)					int range_xMax2 = (xRange__max2 - 2);
HXDLIN(  61)					int range_yMax2 = (yRange__max2 - 2);
HXDLIN(  61)					int _this_min2 = 0;
HXDLIN(  61)					int _this_max2 = ::Std_obj::_hx_int(( (Float)(((xRange__max2 - xRange__start2) * (yRange__max2 - yRange__start2))) ));
HXDLIN(  61)					while((_this_min2 < _this_max2)){
HXLINE(  61)						_this_min2 = (_this_min2 + 1);
HXDLIN(  61)						int i4 = (_this_min2 - 1);
HXDLIN(  61)						if ((range_y2 > range_yMax2)) {
HXLINE(  61)							range_y2 = range_yReset2;
HXDLIN(  61)							range_x2 = (range_x2 + 1);
            						}
HXDLIN(  61)						range_y2 = (range_y2 + 1);
HXDLIN(  61)						int i5 = i4;
HXDLIN(  61)						{
HXLINE(  61)							int x2 = range_x2;
HXDLIN(  61)							int y2 = range_y2;
HXDLIN(  61)							int c2 = -16776961;
HXDLIN(  61)							bool _hx_tmp6;
HXDLIN(  61)							if ((((c2 >> 24) & 255) < 254)) {
HXLINE(  61)								_hx_tmp6 = this26->transparent;
            							}
            							else {
HXLINE(  61)								_hx_tmp6 = false;
            							}
HXDLIN(  61)							if (_hx_tmp6) {
HXLINE(  61)								int location2;
HXDLIN(  61)								if (this26->useVirtualPos) {
HXLINE(  61)									location2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - this26->virtualY) * ( (Float)(this26->width) )) + x2) - this26->virtualX));
            								}
            								else {
HXLINE(  61)									location2 = ::Std_obj::_hx_int(( (Float)(((y2 * this26->width) + x2)) ));
            								}
HXDLIN(  61)								int this27 = ::iterMagic::Iimg_obj::get(this26->image,location2);
HXDLIN(  61)								int this28;
HXDLIN(  61)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)									this28 = ((((((this27 >> 24) & 255) << 24) | ((this27 & 255) << 16)) | (((this27 >> 8) & 255) << 8)) | ((this27 >> 16) & 255));
            								}
            								else {
HXLINE(  61)									this28 = this27;
            								}
HXDLIN(  61)								Float a12;
HXDLIN(  61)								int this29 = ((this28 >> 24) & 255);
HXDLIN(  61)								if ((this29 == 0)) {
HXLINE(  61)									a12 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									a12 = (( (Float)(this29) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float r12;
HXDLIN(  61)								int this30 = ((this28 >> 16) & 255);
HXDLIN(  61)								if ((this30 == 0)) {
HXLINE(  61)									r12 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									r12 = (( (Float)(this30) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float g12;
HXDLIN(  61)								int this31 = ((this28 >> 8) & 255);
HXDLIN(  61)								if ((this31 == 0)) {
HXLINE(  61)									g12 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									g12 = (( (Float)(this31) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float b12;
HXDLIN(  61)								int this32 = (this28 & 255);
HXDLIN(  61)								if ((this32 == 0)) {
HXLINE(  61)									b12 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									b12 = (( (Float)(this32) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float a22;
HXDLIN(  61)								int this33 = ((-16776961 >> 24) & 255);
HXDLIN(  61)								if ((this33 == 0)) {
HXLINE(  61)									a22 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									a22 = (( (Float)(this33) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float r22;
HXDLIN(  61)								int this34 = ((-16776961 >> 16) & 255);
HXDLIN(  61)								if ((this34 == 0)) {
HXLINE(  61)									r22 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									r22 = (( (Float)(this34) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float g22;
HXDLIN(  61)								int this35 = ((-16776961 >> 8) & 255);
HXDLIN(  61)								if ((this35 == 0)) {
HXLINE(  61)									g22 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									g22 = (( (Float)(this35) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float b22;
HXDLIN(  61)								int this36 = (-16776961 & 255);
HXDLIN(  61)								if ((this36 == 0)) {
HXLINE(  61)									b22 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									b22 = (( (Float)(this36) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  61)								int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  61)								int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  61)								int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a32) + (b22 * a22))));
HXDLIN(  61)								int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  61)								int blended2 = ((((a6 << 24) | (r4 << 16)) | (g4 << 8)) | b4);
HXDLIN(  61)								{
HXLINE(  61)									int _hx_tmp7;
HXDLIN(  61)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)										_hx_tmp7 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            									}
            									else {
HXLINE(  61)										_hx_tmp7 = blended2;
            									}
HXDLIN(  61)									::iterMagic::Iimg_obj::set(this26->image,location2,_hx_tmp7);
            								}
            							}
            							else {
HXLINE(  61)								::Dynamic this37 = this26->image;
HXDLIN(  61)								int index2;
HXDLIN(  61)								if (this26->useVirtualPos) {
HXLINE(  61)									index2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - this26->virtualY) * ( (Float)(this26->width) )) + x2) - this26->virtualX));
            								}
            								else {
HXLINE(  61)									index2 = ::Std_obj::_hx_int(( (Float)(((y2 * this26->width) + x2)) ));
            								}
HXDLIN(  61)								int _hx_tmp8;
HXDLIN(  61)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)									_hx_tmp8 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            								}
            								else {
HXLINE(  61)									_hx_tmp8 = c2;
            								}
HXDLIN(  61)								::iterMagic::Iimg_obj::set(this37,index2,_hx_tmp8);
            							}
            						}
            					}
            				}
            			}
HXDLIN(  61)			{
HXLINE(  61)				 ::pi_xy::ImageStruct this38 = this1;
HXDLIN(  61)				{
HXLINE(  61)					int r_x3 = ::Std_obj::_hx_int((dx - ((Float)6.)));
HXDLIN(  61)					int r_y3 = ::Std_obj::_hx_int((dy - ((Float)6.)));
HXDLIN(  61)					int r_w3 = 12;
HXDLIN(  61)					int r_h3 = 12;
HXDLIN(  61)					int xmax3 = ((r_x3 + r_w3) + 1);
HXDLIN(  61)					int ymax3 = ((r_y3 + r_h3) + 1);
HXDLIN(  61)					int ii_min6 = r_x3;
HXDLIN(  61)					int ii_max6 = xmax3;
HXDLIN(  61)					int xRange__start3 = ii_min6;
HXDLIN(  61)					int xRange__max3 = ii_max6;
HXDLIN(  61)					int ii_min7 = r_y3;
HXDLIN(  61)					int ii_max7 = ymax3;
HXDLIN(  61)					int yRange__start3 = ii_min7;
HXDLIN(  61)					int yRange__max3 = ii_max7;
HXDLIN(  61)					int range_x3 = xRange__start3;
HXDLIN(  61)					int range_y3 = (yRange__start3 - 1);
HXDLIN(  61)					int range_xReset3 = range_x3;
HXDLIN(  61)					int range_yReset3 = range_y3;
HXDLIN(  61)					int range_xMax3 = (xRange__max3 - 2);
HXDLIN(  61)					int range_yMax3 = (yRange__max3 - 2);
HXDLIN(  61)					int _this_min3 = 0;
HXDLIN(  61)					int _this_max3 = ::Std_obj::_hx_int(( (Float)(((xRange__max3 - xRange__start3) * (yRange__max3 - yRange__start3))) ));
HXDLIN(  61)					while((_this_min3 < _this_max3)){
HXLINE(  61)						_this_min3 = (_this_min3 + 1);
HXDLIN(  61)						int i6 = (_this_min3 - 1);
HXDLIN(  61)						if ((range_y3 > range_yMax3)) {
HXLINE(  61)							range_y3 = range_yReset3;
HXDLIN(  61)							range_x3 = (range_x3 + 1);
            						}
HXDLIN(  61)						range_y3 = (range_y3 + 1);
HXDLIN(  61)						int i7 = i6;
HXDLIN(  61)						{
HXLINE(  61)							int x3 = range_x3;
HXDLIN(  61)							int y3 = range_y3;
HXDLIN(  61)							int c3 = -1048336;
HXDLIN(  61)							bool _hx_tmp9;
HXDLIN(  61)							if ((((c3 >> 24) & 255) < 254)) {
HXLINE(  61)								_hx_tmp9 = this38->transparent;
            							}
            							else {
HXLINE(  61)								_hx_tmp9 = false;
            							}
HXDLIN(  61)							if (_hx_tmp9) {
HXLINE(  61)								int location3;
HXDLIN(  61)								if (this38->useVirtualPos) {
HXLINE(  61)									location3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this38->virtualY) * ( (Float)(this38->width) )) + x3) - this38->virtualX));
            								}
            								else {
HXLINE(  61)									location3 = ::Std_obj::_hx_int(( (Float)(((y3 * this38->width) + x3)) ));
            								}
HXDLIN(  61)								int this39 = ::iterMagic::Iimg_obj::get(this38->image,location3);
HXDLIN(  61)								int this40;
HXDLIN(  61)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)									this40 = ((((((this39 >> 24) & 255) << 24) | ((this39 & 255) << 16)) | (((this39 >> 8) & 255) << 8)) | ((this39 >> 16) & 255));
            								}
            								else {
HXLINE(  61)									this40 = this39;
            								}
HXDLIN(  61)								Float a13;
HXDLIN(  61)								int this41 = ((this40 >> 24) & 255);
HXDLIN(  61)								if ((this41 == 0)) {
HXLINE(  61)									a13 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									a13 = (( (Float)(this41) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float r13;
HXDLIN(  61)								int this42 = ((this40 >> 16) & 255);
HXDLIN(  61)								if ((this42 == 0)) {
HXLINE(  61)									r13 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									r13 = (( (Float)(this42) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float g13;
HXDLIN(  61)								int this43 = ((this40 >> 8) & 255);
HXDLIN(  61)								if ((this43 == 0)) {
HXLINE(  61)									g13 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									g13 = (( (Float)(this43) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float b13;
HXDLIN(  61)								int this44 = (this40 & 255);
HXDLIN(  61)								if ((this44 == 0)) {
HXLINE(  61)									b13 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									b13 = (( (Float)(this44) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float a23;
HXDLIN(  61)								int this45 = ((-1048336 >> 24) & 255);
HXDLIN(  61)								if ((this45 == 0)) {
HXLINE(  61)									a23 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									a23 = (( (Float)(this45) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float r23;
HXDLIN(  61)								int this46 = ((-1048336 >> 16) & 255);
HXDLIN(  61)								if ((this46 == 0)) {
HXLINE(  61)									r23 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									r23 = (( (Float)(this46) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float g23;
HXDLIN(  61)								int this47 = ((-1048336 >> 8) & 255);
HXDLIN(  61)								if ((this47 == 0)) {
HXLINE(  61)									g23 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									g23 = (( (Float)(this47) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float b23;
HXDLIN(  61)								int this48 = (-1048336 & 255);
HXDLIN(  61)								if ((this48 == 0)) {
HXLINE(  61)									b23 = ((Float)0.);
            								}
            								else {
HXLINE(  61)									b23 = (( (Float)(this48) ) / ( (Float)(255) ));
            								}
HXDLIN(  61)								Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  61)								int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  61)								int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  61)								int b5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a33) + (b23 * a23))));
HXDLIN(  61)								int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  61)								int blended3 = ((((a7 << 24) | (r5 << 16)) | (g5 << 8)) | b5);
HXDLIN(  61)								{
HXLINE(  61)									int _hx_tmp10;
HXDLIN(  61)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)										_hx_tmp10 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            									}
            									else {
HXLINE(  61)										_hx_tmp10 = blended3;
            									}
HXDLIN(  61)									::iterMagic::Iimg_obj::set(this38->image,location3,_hx_tmp10);
            								}
            							}
            							else {
HXLINE(  61)								::Dynamic this49 = this38->image;
HXDLIN(  61)								int index3;
HXDLIN(  61)								if (this38->useVirtualPos) {
HXLINE(  61)									index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this38->virtualY) * ( (Float)(this38->width) )) + x3) - this38->virtualX));
            								}
            								else {
HXLINE(  61)									index3 = ::Std_obj::_hx_int(( (Float)(((y3 * this38->width) + x3)) ));
            								}
HXDLIN(  61)								int _hx_tmp11;
HXDLIN(  61)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)									_hx_tmp11 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            								}
            								else {
HXLINE(  61)									_hx_tmp11 = c3;
            								}
HXDLIN(  61)								::iterMagic::Iimg_obj::set(this49,index3,_hx_tmp11);
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN(  61)		{
HXLINE(  61)			Float bx1 = bx;
HXDLIN(  61)			Float by1 = by;
HXDLIN(  61)			Float cx1 = dx;
HXDLIN(  61)			Float cy1 = dy;
HXDLIN(  61)			bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN(  61)			if (!(adjustWinding)) {
HXLINE(  61)				Float bx_ = bx1;
HXDLIN(  61)				Float by_ = by1;
HXLINE( 187)				bx1 = cx1;
HXLINE( 188)				by1 = cy1;
HXLINE( 189)				cx1 = bx_;
HXLINE( 190)				cy1 = by_;
            			}
HXLINE(  61)			{
HXLINE(  61)				bool hasUndo = false;
HXDLIN(  61)				Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN(  61)				Float sx = (cy1 - ay);
HXDLIN(  61)				Float sy = (ax - cx1);
HXDLIN(  61)				Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN(  61)				Float tx = (ay - by1);
HXDLIN(  61)				Float ty = (bx1 - ax);
HXDLIN(  61)				Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN(  61)				 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  61)				if ((ax > bx1)) {
HXLINE(  61)					if ((ax > cx1)) {
HXLINE(  61)						int min;
HXDLIN(  61)						if ((bx1 > cx1)) {
HXLINE(  61)							min = ::Math_obj::floor(cx1);
            						}
            						else {
HXLINE(  61)							min = ::Math_obj::floor(bx1);
            						}
HXDLIN(  61)						int ii_min8 = min;
HXDLIN(  61)						int ii_max8 = ::Math_obj::ceil(ax);
HXDLIN(  61)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            					}
            					else {
HXLINE(  61)						int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN(  61)						int ii_max9 = ::Math_obj::ceil(cx1);
HXDLIN(  61)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            					}
            				}
            				else {
HXLINE(  61)					if ((bx1 > cx1)) {
HXLINE(  61)						int min1;
HXDLIN(  61)						if ((ax > cx1)) {
HXLINE(  61)							min1 = ::Math_obj::floor(cx1);
            						}
            						else {
HXLINE(  61)							min1 = ::Math_obj::ceil(ax);
            						}
HXDLIN(  61)						int ii_min10 = min1;
HXDLIN(  61)						int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN(  61)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            					}
            					else {
HXLINE(  61)						int ii_min11 = ::Math_obj::floor(ax);
HXDLIN(  61)						int ii_max11 = ::Math_obj::ceil(cx1);
HXDLIN(  61)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            					}
            				}
HXDLIN(  61)				 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  61)				if ((ay > by1)) {
HXLINE(  61)					if ((ay > cy1)) {
HXLINE(  61)						int min2;
HXDLIN(  61)						if ((by1 > cy1)) {
HXLINE(  61)							min2 = ::Math_obj::floor(cy1);
            						}
            						else {
HXLINE(  61)							min2 = ::Math_obj::floor(by1);
            						}
HXDLIN(  61)						int ii_min12 = min2;
HXDLIN(  61)						int ii_max12 = ::Math_obj::ceil(ay);
HXDLIN(  61)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            					}
            					else {
HXLINE(  61)						int ii_min13 = ::Math_obj::floor(by1);
HXDLIN(  61)						int ii_max13 = ::Math_obj::ceil(cy1);
HXDLIN(  61)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            					}
            				}
            				else {
HXLINE(  61)					if ((by1 > cy1)) {
HXLINE(  61)						int min3;
HXDLIN(  61)						if ((ay > cy1)) {
HXLINE(  61)							min3 = ::Math_obj::floor(cy1);
            						}
            						else {
HXLINE(  61)							min3 = ::Math_obj::ceil(ay);
            						}
HXDLIN(  61)						int ii_min14 = min3;
HXDLIN(  61)						int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN(  61)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            					}
            					else {
HXLINE(  61)						int ii_min15 = ::Math_obj::floor(ay);
HXDLIN(  61)						int ii_max15 = ::Math_obj::ceil(cy1);
HXDLIN(  61)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            					}
            				}
HXDLIN(  61)				 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  61)				if (hasUndo) {
HXLINE(  61)					int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  61)					int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  61)					 ::Dynamic imageType = null();
HXDLIN(  61)					 ::pi_xy::ImageStruct this50 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  61)					if (::hx::IsNull( imageType )) {
HXLINE(  54)						imageType = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE(  61)					::Dynamic undoImage1;
HXDLIN(  61)					switch((int)(( (int)(imageType) ))){
            						case (int)0: {
HXLINE(  61)							 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  61)							 ::iterMagic::BytesImg b6 = byt;
HXDLIN(  61)							{
HXLINE(  61)								b6->width = width;
HXDLIN(  61)								b6->height = height;
HXDLIN(  61)								b6->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  61)								b6->data = ::haxe::io::Bytes_obj::alloc((b6->length * 4));
HXDLIN(  61)								{
HXLINE(  61)									int len = b6->length;
HXDLIN(  61)									int w = 0;
HXDLIN(  61)									{
HXLINE(  61)										int _g = 0;
HXDLIN(  61)										int _g1 = b6->height;
HXDLIN(  61)										while((_g < _g1)){
HXLINE(  61)											_g = (_g + 1);
HXDLIN(  61)											int y4 = (_g - 1);
HXDLIN(  61)											{
HXLINE(  61)												int _g2 = 0;
HXDLIN(  61)												int _g3 = b6->width;
HXDLIN(  61)												while((_g2 < _g3)){
HXLINE(  61)													_g2 = (_g2 + 1);
HXDLIN(  61)													int x4 = (_g2 - 1);
HXDLIN(  61)													{
HXLINE(  61)														w = (w + 1);
HXDLIN(  61)														b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  61)													{
HXLINE(  61)														w = (w + 1);
HXDLIN(  61)														b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  61)													{
HXLINE(  61)														w = (w + 1);
HXDLIN(  61)														b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  61)													{
HXLINE(  61)														w = (w + 1);
HXDLIN(  61)														b6->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  61)							undoImage1 = b6;
            						}
            						break;
            						case (int)1: {
HXLINE(  61)							 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  61)							 ::iterMagic::ArrIntImg a8 = arrI;
HXDLIN(  61)							{
HXLINE(  61)								a8->width = width;
HXDLIN(  61)								a8->height = height;
HXDLIN(  61)								a8->data = ::Array_obj< int >::__new(0);
HXDLIN(  61)								a8->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  61)								{
HXLINE(  61)									int _g4 = 0;
HXDLIN(  61)									int _g5 = a8->length;
HXDLIN(  61)									while((_g4 < _g5)){
HXLINE(  61)										_g4 = (_g4 + 1);
HXDLIN(  61)										int i8 = (_g4 - 1);
HXDLIN(  61)										a8->data[i8] = 0;
            									}
            								}
            							}
HXDLIN(  61)							undoImage1 = a8;
            						}
            						break;
            						case (int)2: {
HXLINE(  61)							 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  61)							 ::iterMagic::U32ArrImg b7 = u32a;
HXDLIN(  61)							{
HXLINE(  61)								b7->width = width;
HXDLIN(  61)								b7->height = height;
HXDLIN(  61)								b7->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  61)								int size = (b7->length * 4);
HXDLIN(  61)								b7->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  61)								{
HXLINE(  61)									int _g6 = 0;
HXDLIN(  61)									int _g7 = b7->length;
HXDLIN(  61)									while((_g6 < _g7)){
HXLINE(  61)										_g6 = (_g6 + 1);
HXDLIN(  61)										int i9 = (_g6 - 1);
HXDLIN(  61)										{
HXLINE(  61)											 ::haxe::io::ArrayBufferViewImpl this51 = b7->data;
HXDLIN(  61)											bool undoImage2;
HXDLIN(  61)											if ((i9 >= 0)) {
HXLINE(  61)												undoImage2 = (i9 < (this51->byteLength >> 2));
            											}
            											else {
HXLINE(  61)												undoImage2 = false;
            											}
HXDLIN(  61)											if (undoImage2) {
HXLINE(  61)												 ::haxe::io::Bytes _this = this51->bytes;
HXDLIN(  61)												int pos = ((i9 << 2) + this51->byteOffset);
HXDLIN(  61)												_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  61)												_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  61)												_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  61)												_this->b[(pos + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN(  61)							undoImage1 = b7;
            						}
            						break;
            						case (int)3: {
HXLINE(  61)							 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  61)							 ::iterMagic::VecIntImg v = vec;
HXDLIN(  61)							{
HXLINE(  61)								v->width = width;
HXDLIN(  61)								v->height = height;
HXDLIN(  61)								v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  61)								v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  61)								{
HXLINE(  61)									int _g8 = 0;
HXDLIN(  61)									int _g9 = v->length;
HXDLIN(  61)									while((_g8 < _g9)){
HXLINE(  61)										_g8 = (_g8 + 1);
HXDLIN(  61)										int i10 = (_g8 - 1);
HXDLIN(  61)										v->data->__unsafe_set(i10,0);
            									}
            								}
            							}
HXDLIN(  61)							undoImage1 = v;
            						}
            						break;
            						case (int)4: {
HXLINE(  61)							 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  61)							 ::iterMagic::StackIntImg b8 = sInt;
HXDLIN(  61)							{
HXLINE(  61)								b8->width = width;
HXDLIN(  61)								b8->height = height;
HXDLIN(  61)								b8->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  61)								b8->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  61)								{
HXLINE(  61)									int len1 = b8->length;
HXDLIN(  61)									 ::haxe::ds::GenericStack_Int d = b8->data;
HXDLIN(  61)									if (::hx::IsNull( d->head )) {
HXLINE(  61)										int _g10 = 0;
HXDLIN(  61)										int _g11 = len1;
HXDLIN(  61)										while((_g10 < _g11)){
HXLINE(  61)											_g10 = (_g10 + 1);
HXDLIN(  61)											int i11 = (_g10 - 1);
HXDLIN(  61)											d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            										}
            									}
            									else {
HXLINE(  61)										int _g12 = 0;
HXDLIN(  61)										int _g13 = len1;
HXDLIN(  61)										while((_g12 < _g13)){
HXLINE(  61)											_g12 = (_g12 + 1);
HXDLIN(  61)											int i12 = (_g12 - 1);
HXDLIN(  61)											{
HXLINE(  61)												 ::haxe::ds::GenericCell_Int l = b8->data->head;
HXDLIN(  61)												 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  61)												{
HXLINE(  61)													int _g14 = 0;
HXDLIN(  61)													int _g15 = i12;
HXDLIN(  61)													while((_g14 < _g15)){
HXLINE(  61)														_g14 = (_g14 + 1);
HXDLIN(  61)														int i13 = (_g14 - 1);
HXLINE( 345)														prev = l;
HXLINE( 346)														l = l->next;
            													}
            												}
HXLINE(  61)												if (::hx::IsNull( prev )) {
HXLINE(  61)													b8->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  61)													l = null();
            												}
            												else {
HXLINE(  61)													prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  61)													l = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  61)							undoImage1 = b8;
            						}
            						break;
            					}
HXDLIN(  61)					this50->image = undoImage1;
HXDLIN(  61)					this50->width = width;
HXDLIN(  61)					this50->height = height;
HXDLIN(  61)					this50->imageType = ( (int)(imageType) );
HXDLIN(  61)					undoImage = this50;
HXDLIN(  61)					{
HXLINE(  61)						int rectLeft = xIter3->start;
HXDLIN(  61)						int rectTop = yIter3->start;
HXDLIN(  61)						int rectRight = xIter3->max;
HXDLIN(  61)						bool forceClear = false;
HXDLIN(  61)						{
HXLINE(  61)							int _g16 = rectTop;
HXDLIN(  61)							int _g17 = yIter3->max;
HXDLIN(  61)							while((_g16 < _g17)){
HXLINE(  61)								_g16 = (_g16 + 1);
HXDLIN(  61)								int dy1 = (_g16 - 1);
HXDLIN(  61)								{
HXLINE(  61)									int _g18 = rectLeft;
HXDLIN(  61)									int _g19 = rectRight;
HXDLIN(  61)									while((_g18 < _g19)){
HXLINE(  61)										_g18 = (_g18 + 1);
HXDLIN(  61)										int dx1 = (_g18 - 1);
HXDLIN(  61)										::Dynamic this52 = this1->image;
HXDLIN(  61)										int index4;
HXDLIN(  61)										if (this1->useVirtualPos) {
HXLINE(  61)											index4 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx1) - this1->virtualX));
            										}
            										else {
HXLINE(  61)											index4 = ::Std_obj::_hx_int(( (Float)(((dy1 * this1->width) + dx1)) ));
            										}
HXDLIN(  61)										int c4 = ::iterMagic::Iimg_obj::get(this52,index4);
HXDLIN(  61)										int col;
HXDLIN(  61)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)											col = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            										}
            										else {
HXLINE(  61)											col = c4;
            										}
HXDLIN(  61)										bool _hx_tmp12;
HXDLIN(  61)										if (this1->useMask) {
HXLINE(  61)											_hx_tmp12 = ::hx::IsNotNull( this1->mask );
            										}
            										else {
HXLINE(  61)											_hx_tmp12 = false;
            										}
HXDLIN(  61)										if (_hx_tmp12) {
HXLINE(  61)											 ::pi_xy::ImageStruct this53 = this1->mask;
HXDLIN(  61)											::Dynamic this54 = this53->image;
HXDLIN(  61)											int index5;
HXDLIN(  61)											if (this53->useVirtualPos) {
HXLINE(  61)												index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this53->virtualY) * ( (Float)(this53->width) )) + dx1) - this53->virtualX));
            											}
            											else {
HXLINE(  61)												index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this53->width) + dx1)) ));
            											}
HXDLIN(  61)											int c5 = ::iterMagic::Iimg_obj::get(this54,index5);
HXDLIN(  61)											int v1;
HXDLIN(  61)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)												v1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            											}
            											else {
HXLINE(  61)												v1 = c5;
            											}
HXDLIN(  61)											int maskPixel = v1;
HXDLIN(  61)											int this55 = col;
HXDLIN(  61)											if ((maskPixel == 0)) {
HXLINE(  61)												col = this55;
            											}
            											else {
HXLINE(  61)												Float m0;
HXDLIN(  61)												int this56 = ((maskPixel >> 24) & 255);
HXDLIN(  61)												if ((this56 == 0)) {
HXLINE(  61)													m0 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													m0 = (( (Float)(this56) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float m1;
HXDLIN(  61)												int this57 = ((maskPixel >> 16) & 255);
HXDLIN(  61)												if ((this57 == 0)) {
HXLINE(  61)													m1 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													m1 = (( (Float)(this57) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float m2;
HXDLIN(  61)												int this58 = ((maskPixel >> 8) & 255);
HXDLIN(  61)												if ((this58 == 0)) {
HXLINE(  61)													m2 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													m2 = (( (Float)(this58) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float m3;
HXDLIN(  61)												int this59 = (maskPixel & 255);
HXDLIN(  61)												if ((this59 == 0)) {
HXLINE(  61)													m3 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													m3 = (( (Float)(this59) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this55 >> 24) & 255)) )));
HXDLIN(  61)												int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this55 >> 16) & 255)) )));
HXDLIN(  61)												int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this55 >> 8) & 255)) )));
HXDLIN(  61)												int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this55 & 255)) )));
HXDLIN(  61)												col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN(  61)										if ((col != 0)) {
HXLINE(  61)											int x5 = (dx1 - rectLeft);
HXDLIN(  61)											int y5 = (dy1 - rectTop);
HXDLIN(  61)											int c6 = col;
HXDLIN(  61)											bool _hx_tmp13;
HXDLIN(  61)											if ((((c6 >> 24) & 255) < 254)) {
HXLINE(  61)												_hx_tmp13 = undoImage->transparent;
            											}
            											else {
HXLINE(  61)												_hx_tmp13 = false;
            											}
HXDLIN(  61)											if (_hx_tmp13) {
HXLINE(  61)												int location4;
HXDLIN(  61)												if (undoImage->useVirtualPos) {
HXLINE(  61)													location4 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            												}
            												else {
HXLINE(  61)													location4 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage->width) + x5)) ));
            												}
HXDLIN(  61)												int this60 = ::iterMagic::Iimg_obj::get(undoImage->image,location4);
HXDLIN(  61)												int this61;
HXDLIN(  61)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)													this61 = ((((((this60 >> 24) & 255) << 24) | ((this60 & 255) << 16)) | (((this60 >> 8) & 255) << 8)) | ((this60 >> 16) & 255));
            												}
            												else {
HXLINE(  61)													this61 = this60;
            												}
HXDLIN(  61)												Float a14;
HXDLIN(  61)												int this62 = ((this61 >> 24) & 255);
HXDLIN(  61)												if ((this62 == 0)) {
HXLINE(  61)													a14 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													a14 = (( (Float)(this62) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float r14;
HXDLIN(  61)												int this63 = ((this61 >> 16) & 255);
HXDLIN(  61)												if ((this63 == 0)) {
HXLINE(  61)													r14 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													r14 = (( (Float)(this63) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float g14;
HXDLIN(  61)												int this64 = ((this61 >> 8) & 255);
HXDLIN(  61)												if ((this64 == 0)) {
HXLINE(  61)													g14 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													g14 = (( (Float)(this64) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float b14;
HXDLIN(  61)												int this65 = (this61 & 255);
HXDLIN(  61)												if ((this65 == 0)) {
HXLINE(  61)													b14 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													b14 = (( (Float)(this65) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float a24;
HXDLIN(  61)												int this66 = ((col >> 24) & 255);
HXDLIN(  61)												if ((this66 == 0)) {
HXLINE(  61)													a24 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													a24 = (( (Float)(this66) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float r24;
HXDLIN(  61)												int this67 = ((col >> 16) & 255);
HXDLIN(  61)												if ((this67 == 0)) {
HXLINE(  61)													r24 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													r24 = (( (Float)(this67) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float g24;
HXDLIN(  61)												int this68 = ((col >> 8) & 255);
HXDLIN(  61)												if ((this68 == 0)) {
HXLINE(  61)													g24 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													g24 = (( (Float)(this68) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float b24;
HXDLIN(  61)												int this69 = (col & 255);
HXDLIN(  61)												if ((this69 == 0)) {
HXLINE(  61)													b24 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													b24 = (( (Float)(this69) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float a34 = (a14 * (( (Float)(1) ) - a24));
HXDLIN(  61)												int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN(  61)												int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN(  61)												int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a34) + (b24 * a24))));
HXDLIN(  61)												int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN(  61)												int blended4 = ((((a9 << 24) | (r6 << 16)) | (g6 << 8)) | b9);
HXDLIN(  61)												{
HXLINE(  61)													int _hx_tmp14;
HXDLIN(  61)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)														_hx_tmp14 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            													}
            													else {
HXLINE(  61)														_hx_tmp14 = blended4;
            													}
HXDLIN(  61)													::iterMagic::Iimg_obj::set(undoImage->image,location4,_hx_tmp14);
            												}
            											}
            											else {
HXLINE(  61)												::Dynamic this70 = undoImage->image;
HXDLIN(  61)												int index6;
HXDLIN(  61)												if (undoImage->useVirtualPos) {
HXLINE(  61)													index6 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            												}
            												else {
HXLINE(  61)													index6 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage->width) + x5)) ));
            												}
HXDLIN(  61)												int _hx_tmp15;
HXDLIN(  61)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)													_hx_tmp15 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            												}
            												else {
HXLINE(  61)													_hx_tmp15 = c6;
            												}
HXDLIN(  61)												::iterMagic::Iimg_obj::set(this70,index6,_hx_tmp15);
            											}
            										}
            										else {
HXLINE(  61)											if (forceClear) {
HXLINE(  61)												::Dynamic this71 = undoImage->image;
HXDLIN(  61)												int x6 = (dx1 - rectLeft);
HXDLIN(  61)												int y6 = (dy1 - rectTop);
HXDLIN(  61)												int index7;
HXDLIN(  61)												if (undoImage->useVirtualPos) {
HXLINE(  61)													index7 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x6) - undoImage->virtualX));
            												}
            												else {
HXLINE(  61)													index7 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage->width) + x6)) ));
            												}
HXDLIN(  61)												::iterMagic::Iimg_obj::set(this71,index7,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  61)				bool foundY = false;
HXDLIN(  61)				Float s = ((Float)0.);
HXDLIN(  61)				Float t = ((Float)0.);
HXDLIN(  61)				Float sxx = ((Float)0.);
HXDLIN(  61)				Float txx = ((Float)0.);
HXDLIN(  61)				{
HXLINE(  61)					int _g_min = xIter3->start;
HXDLIN(  61)					int _g_max = xIter3->max;
HXDLIN(  61)					while((_g_min < _g_max)){
HXLINE(  61)						_g_min = (_g_min + 1);
HXDLIN(  61)						int x7 = (_g_min - 1);
HXLINE( 222)						sxx = (sx * ( (Float)(x7) ));
HXLINE( 223)						txx = (tx * ( (Float)(x7) ));
HXLINE( 224)						foundY = false;
HXLINE(  61)						{
HXLINE(  61)							int _g_min1 = yIter3->start;
HXDLIN(  61)							int _g_max1 = yIter3->max;
HXDLIN(  61)							while((_g_min1 < _g_max1)){
HXLINE(  61)								_g_min1 = (_g_min1 + 1);
HXDLIN(  61)								int y7 = (_g_min1 - 1);
HXLINE( 226)								s = ((s0 + sxx) + (sy * ( (Float)(y7) )));
HXLINE( 227)								t = ((t0 + txx) + (ty * ( (Float)(y7) )));
HXLINE(  61)								bool _hx_tmp16;
HXDLIN(  61)								if (!((s <= 0))) {
HXLINE(  61)									_hx_tmp16 = (t <= 0);
            								}
            								else {
HXLINE(  61)									_hx_tmp16 = true;
            								}
HXDLIN(  61)								if (_hx_tmp16) {
HXLINE(  61)									if (foundY) {
HXLINE(  61)										goto _hx_goto_87;
            									}
            								}
            								else {
HXLINE(  61)									if (((s + t) < A)) {
HXLINE(  61)										int x8 = ::hx::Mod(x7,tileImage->width);
HXDLIN(  61)										int y8 = ::hx::Mod(y7,tileImage->height);
HXDLIN(  61)										::Dynamic this72 = tileImage->image;
HXDLIN(  61)										int index8;
HXDLIN(  61)										if (tileImage->useVirtualPos) {
HXLINE(  61)											index8 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x8) - tileImage->virtualX));
            										}
            										else {
HXLINE(  61)											index8 = ::Std_obj::_hx_int(( (Float)(((y8 * tileImage->width) + x8)) ));
            										}
HXDLIN(  61)										int c7 = ::iterMagic::Iimg_obj::get(this72,index8);
HXDLIN(  61)										int color;
HXDLIN(  61)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)											color = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            										}
            										else {
HXLINE(  61)											color = c7;
            										}
HXDLIN(  61)										{
HXLINE(  61)											int c8 = color;
HXDLIN(  61)											bool _hx_tmp17;
HXDLIN(  61)											if ((((c8 >> 24) & 255) < 254)) {
HXLINE(  61)												_hx_tmp17 = this1->transparent;
            											}
            											else {
HXLINE(  61)												_hx_tmp17 = false;
            											}
HXDLIN(  61)											if (_hx_tmp17) {
HXLINE(  61)												int location5;
HXDLIN(  61)												if (this1->useVirtualPos) {
HXLINE(  61)													location5 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this1->virtualY) * ( (Float)(this1->width) )) + x7) - this1->virtualX));
            												}
            												else {
HXLINE(  61)													location5 = ::Std_obj::_hx_int(( (Float)(((y7 * this1->width) + x7)) ));
            												}
HXDLIN(  61)												int this73 = ::iterMagic::Iimg_obj::get(this1->image,location5);
HXDLIN(  61)												int this74;
HXDLIN(  61)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)													this74 = ((((((this73 >> 24) & 255) << 24) | ((this73 & 255) << 16)) | (((this73 >> 8) & 255) << 8)) | ((this73 >> 16) & 255));
            												}
            												else {
HXLINE(  61)													this74 = this73;
            												}
HXDLIN(  61)												Float a15;
HXDLIN(  61)												int this75 = ((this74 >> 24) & 255);
HXDLIN(  61)												if ((this75 == 0)) {
HXLINE(  61)													a15 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													a15 = (( (Float)(this75) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float r15;
HXDLIN(  61)												int this76 = ((this74 >> 16) & 255);
HXDLIN(  61)												if ((this76 == 0)) {
HXLINE(  61)													r15 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													r15 = (( (Float)(this76) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float g15;
HXDLIN(  61)												int this77 = ((this74 >> 8) & 255);
HXDLIN(  61)												if ((this77 == 0)) {
HXLINE(  61)													g15 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													g15 = (( (Float)(this77) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float b15;
HXDLIN(  61)												int this78 = (this74 & 255);
HXDLIN(  61)												if ((this78 == 0)) {
HXLINE(  61)													b15 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													b15 = (( (Float)(this78) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float a25;
HXDLIN(  61)												int this79 = ((color >> 24) & 255);
HXDLIN(  61)												if ((this79 == 0)) {
HXLINE(  61)													a25 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													a25 = (( (Float)(this79) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float r25;
HXDLIN(  61)												int this80 = ((color >> 16) & 255);
HXDLIN(  61)												if ((this80 == 0)) {
HXLINE(  61)													r25 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													r25 = (( (Float)(this80) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float g25;
HXDLIN(  61)												int this81 = ((color >> 8) & 255);
HXDLIN(  61)												if ((this81 == 0)) {
HXLINE(  61)													g25 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													g25 = (( (Float)(this81) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float b25;
HXDLIN(  61)												int this82 = (color & 255);
HXDLIN(  61)												if ((this82 == 0)) {
HXLINE(  61)													b25 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													b25 = (( (Float)(this82) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float a35 = (a15 * (( (Float)(1) ) - a25));
HXDLIN(  61)												int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN(  61)												int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN(  61)												int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a35) + (b25 * a25))));
HXDLIN(  61)												int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN(  61)												int blended5 = ((((a10 << 24) | (r7 << 16)) | (g7 << 8)) | b10);
HXDLIN(  61)												{
HXLINE(  61)													int _hx_tmp18;
HXDLIN(  61)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)														_hx_tmp18 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            													}
            													else {
HXLINE(  61)														_hx_tmp18 = blended5;
            													}
HXDLIN(  61)													::iterMagic::Iimg_obj::set(this1->image,location5,_hx_tmp18);
            												}
            											}
            											else {
HXLINE(  61)												::Dynamic this83 = this1->image;
HXDLIN(  61)												int index9;
HXDLIN(  61)												if (this1->useVirtualPos) {
HXLINE(  61)													index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this1->virtualY) * ( (Float)(this1->width) )) + x7) - this1->virtualX));
            												}
            												else {
HXLINE(  61)													index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this1->width) + x7)) ));
            												}
HXDLIN(  61)												int _hx_tmp19;
HXDLIN(  61)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)													_hx_tmp19 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            												}
            												else {
HXLINE(  61)													_hx_tmp19 = c8;
            												}
HXDLIN(  61)												::iterMagic::Iimg_obj::set(this83,index9,_hx_tmp19);
            											}
            										}
HXLINE( 236)										foundY = true;
            									}
            									else {
HXLINE(  61)										if (foundY) {
HXLINE(  61)											goto _hx_goto_87;
            										}
            									}
            								}
            							}
            							_hx_goto_87:;
            						}
            					}
            				}
HXDLIN(  61)				if ((hasHit == false)) {
HXLINE(  61)					 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx1,by1,cx1,cy1,true);
HXDLIN(  61)					if (hasUndo) {
HXLINE(  61)						v2->undoImage = undoImage;
HXDLIN(  61)						v2->undoX = xIter3->start;
HXDLIN(  61)						v2->undoY = yIter3->start;
            					}
            				}
            			}
            		}
HXDLIN(  61)		{
HXLINE(  61)			Float bx2 = cx;
HXDLIN(  61)			Float by2 = cy;
HXDLIN(  61)			Float cx2 = dx;
HXDLIN(  61)			Float cy2 = dy;
HXDLIN(  61)			bool adjustWinding1 = (((((bx * by2) - (bx2 * by)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * by) - (bx * cy2))) > 0);
HXDLIN(  61)			if (!(adjustWinding1)) {
HXLINE(  61)				Float bx_1 = bx2;
HXDLIN(  61)				Float by_1 = by2;
HXLINE( 187)				bx2 = cx2;
HXLINE( 188)				by2 = cy2;
HXLINE( 189)				cx2 = bx_1;
HXLINE( 190)				cy2 = by_1;
            			}
HXLINE(  61)			{
HXLINE(  61)				bool hasUndo1 = false;
HXDLIN(  61)				Float s01 = ((by * cx2) - (bx * cy2));
HXDLIN(  61)				Float sx1 = (cy2 - by);
HXDLIN(  61)				Float sy1 = (bx - cx2);
HXDLIN(  61)				Float t01 = ((bx * by2) - (by * bx2));
HXDLIN(  61)				Float tx1 = (by - by2);
HXDLIN(  61)				Float ty1 = (bx2 - bx);
HXDLIN(  61)				Float A1 = ((((-(by2) * cx2) + (by * (-(bx2) + cx2))) + (bx * (by2 - cy2))) + (bx2 * cy2));
HXDLIN(  61)				 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  61)				if ((bx > bx2)) {
HXLINE(  61)					if ((bx > cx2)) {
HXLINE(  61)						int min4;
HXDLIN(  61)						if ((bx2 > cx2)) {
HXLINE(  61)							min4 = ::Math_obj::floor(cx2);
            						}
            						else {
HXLINE(  61)							min4 = ::Math_obj::floor(bx2);
            						}
HXDLIN(  61)						int ii_min16 = min4;
HXDLIN(  61)						int ii_max16 = ::Math_obj::ceil(bx);
HXDLIN(  61)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            					}
            					else {
HXLINE(  61)						int ii_min17 = ::Math_obj::floor(bx2);
HXDLIN(  61)						int ii_max17 = ::Math_obj::ceil(cx2);
HXDLIN(  61)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            					}
            				}
            				else {
HXLINE(  61)					if ((bx2 > cx2)) {
HXLINE(  61)						int min5;
HXDLIN(  61)						if ((bx > cx2)) {
HXLINE(  61)							min5 = ::Math_obj::floor(cx2);
            						}
            						else {
HXLINE(  61)							min5 = ::Math_obj::ceil(bx);
            						}
HXDLIN(  61)						int ii_min18 = min5;
HXDLIN(  61)						int ii_max18 = ::Math_obj::ceil(bx2);
HXDLIN(  61)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            					}
            					else {
HXLINE(  61)						int ii_min19 = ::Math_obj::floor(bx);
HXDLIN(  61)						int ii_max19 = ::Math_obj::ceil(cx2);
HXDLIN(  61)						xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            					}
            				}
HXDLIN(  61)				 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  61)				if ((by > by2)) {
HXLINE(  61)					if ((by > cy2)) {
HXLINE(  61)						int min6;
HXDLIN(  61)						if ((by2 > cy2)) {
HXLINE(  61)							min6 = ::Math_obj::floor(cy2);
            						}
            						else {
HXLINE(  61)							min6 = ::Math_obj::floor(by2);
            						}
HXDLIN(  61)						int ii_min20 = min6;
HXDLIN(  61)						int ii_max20 = ::Math_obj::ceil(by);
HXDLIN(  61)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            					}
            					else {
HXLINE(  61)						int ii_min21 = ::Math_obj::floor(by2);
HXDLIN(  61)						int ii_max21 = ::Math_obj::ceil(cy2);
HXDLIN(  61)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            					}
            				}
            				else {
HXLINE(  61)					if ((by2 > cy2)) {
HXLINE(  61)						int min7;
HXDLIN(  61)						if ((by > cy2)) {
HXLINE(  61)							min7 = ::Math_obj::floor(cy2);
            						}
            						else {
HXLINE(  61)							min7 = ::Math_obj::ceil(by);
            						}
HXDLIN(  61)						int ii_min22 = min7;
HXDLIN(  61)						int ii_max22 = ::Math_obj::ceil(by2);
HXDLIN(  61)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            					}
            					else {
HXLINE(  61)						int ii_min23 = ::Math_obj::floor(by);
HXDLIN(  61)						int ii_max23 = ::Math_obj::ceil(cy2);
HXDLIN(  61)						yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            					}
            				}
HXDLIN(  61)				 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  61)				if (hasUndo1) {
HXLINE(  61)					int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  61)					int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  61)					 ::Dynamic imageType1 = null();
HXDLIN(  61)					 ::pi_xy::ImageStruct this84 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  61)					if (::hx::IsNull( imageType1 )) {
HXLINE(  54)						imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE(  61)					::Dynamic undoImage4;
HXDLIN(  61)					switch((int)(( (int)(imageType1) ))){
            						case (int)0: {
HXLINE(  61)							 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  61)							 ::iterMagic::BytesImg b16 = byt1;
HXDLIN(  61)							{
HXLINE(  61)								b16->width = width1;
HXDLIN(  61)								b16->height = height1;
HXDLIN(  61)								b16->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  61)								b16->data = ::haxe::io::Bytes_obj::alloc((b16->length * 4));
HXDLIN(  61)								{
HXLINE(  61)									int len2 = b16->length;
HXDLIN(  61)									int w1 = 0;
HXDLIN(  61)									{
HXLINE(  61)										int _g20 = 0;
HXDLIN(  61)										int _g21 = b16->height;
HXDLIN(  61)										while((_g20 < _g21)){
HXLINE(  61)											_g20 = (_g20 + 1);
HXDLIN(  61)											int y9 = (_g20 - 1);
HXDLIN(  61)											{
HXLINE(  61)												int _g22 = 0;
HXDLIN(  61)												int _g23 = b16->width;
HXDLIN(  61)												while((_g22 < _g23)){
HXLINE(  61)													_g22 = (_g22 + 1);
HXDLIN(  61)													int x9 = (_g22 - 1);
HXDLIN(  61)													{
HXLINE(  61)														w1 = (w1 + 1);
HXDLIN(  61)														b16->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  61)													{
HXLINE(  61)														w1 = (w1 + 1);
HXDLIN(  61)														b16->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  61)													{
HXLINE(  61)														w1 = (w1 + 1);
HXDLIN(  61)														b16->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  61)													{
HXLINE(  61)														w1 = (w1 + 1);
HXDLIN(  61)														b16->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  61)							undoImage4 = b16;
            						}
            						break;
            						case (int)1: {
HXLINE(  61)							 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  61)							 ::iterMagic::ArrIntImg a16 = arrI1;
HXDLIN(  61)							{
HXLINE(  61)								a16->width = width1;
HXDLIN(  61)								a16->height = height1;
HXDLIN(  61)								a16->data = ::Array_obj< int >::__new(0);
HXDLIN(  61)								a16->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  61)								{
HXLINE(  61)									int _g24 = 0;
HXDLIN(  61)									int _g25 = a16->length;
HXDLIN(  61)									while((_g24 < _g25)){
HXLINE(  61)										_g24 = (_g24 + 1);
HXDLIN(  61)										int i14 = (_g24 - 1);
HXDLIN(  61)										a16->data[i14] = 0;
            									}
            								}
            							}
HXDLIN(  61)							undoImage4 = a16;
            						}
            						break;
            						case (int)2: {
HXLINE(  61)							 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  61)							 ::iterMagic::U32ArrImg b17 = u32a1;
HXDLIN(  61)							{
HXLINE(  61)								b17->width = width1;
HXDLIN(  61)								b17->height = height1;
HXDLIN(  61)								b17->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  61)								int size1 = (b17->length * 4);
HXDLIN(  61)								b17->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  61)								{
HXLINE(  61)									int _g26 = 0;
HXDLIN(  61)									int _g27 = b17->length;
HXDLIN(  61)									while((_g26 < _g27)){
HXLINE(  61)										_g26 = (_g26 + 1);
HXDLIN(  61)										int i15 = (_g26 - 1);
HXDLIN(  61)										{
HXLINE(  61)											 ::haxe::io::ArrayBufferViewImpl this85 = b17->data;
HXDLIN(  61)											bool undoImage5;
HXDLIN(  61)											if ((i15 >= 0)) {
HXLINE(  61)												undoImage5 = (i15 < (this85->byteLength >> 2));
            											}
            											else {
HXLINE(  61)												undoImage5 = false;
            											}
HXDLIN(  61)											if (undoImage5) {
HXLINE(  61)												 ::haxe::io::Bytes _this1 = this85->bytes;
HXDLIN(  61)												int pos1 = ((i15 << 2) + this85->byteOffset);
HXDLIN(  61)												_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  61)												_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  61)												_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  61)												_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN(  61)							undoImage4 = b17;
            						}
            						break;
            						case (int)3: {
HXLINE(  61)							 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  61)							 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN(  61)							{
HXLINE(  61)								v3->width = width1;
HXDLIN(  61)								v3->height = height1;
HXDLIN(  61)								v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  61)								v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN(  61)								{
HXLINE(  61)									int _g28 = 0;
HXDLIN(  61)									int _g29 = v3->length;
HXDLIN(  61)									while((_g28 < _g29)){
HXLINE(  61)										_g28 = (_g28 + 1);
HXDLIN(  61)										int i16 = (_g28 - 1);
HXDLIN(  61)										v3->data->__unsafe_set(i16,0);
            									}
            								}
            							}
HXDLIN(  61)							undoImage4 = v3;
            						}
            						break;
            						case (int)4: {
HXLINE(  61)							 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  61)							 ::iterMagic::StackIntImg b18 = sInt1;
HXDLIN(  61)							{
HXLINE(  61)								b18->width = width1;
HXDLIN(  61)								b18->height = height1;
HXDLIN(  61)								b18->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  61)								b18->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  61)								{
HXLINE(  61)									int len3 = b18->length;
HXDLIN(  61)									 ::haxe::ds::GenericStack_Int d1 = b18->data;
HXDLIN(  61)									if (::hx::IsNull( d1->head )) {
HXLINE(  61)										int _g30 = 0;
HXDLIN(  61)										int _g31 = len3;
HXDLIN(  61)										while((_g30 < _g31)){
HXLINE(  61)											_g30 = (_g30 + 1);
HXDLIN(  61)											int i17 = (_g30 - 1);
HXDLIN(  61)											d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            										}
            									}
            									else {
HXLINE(  61)										int _g32 = 0;
HXDLIN(  61)										int _g33 = len3;
HXDLIN(  61)										while((_g32 < _g33)){
HXLINE(  61)											_g32 = (_g32 + 1);
HXDLIN(  61)											int i18 = (_g32 - 1);
HXDLIN(  61)											{
HXLINE(  61)												 ::haxe::ds::GenericCell_Int l1 = b18->data->head;
HXDLIN(  61)												 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  61)												{
HXLINE(  61)													int _g34 = 0;
HXDLIN(  61)													int _g35 = i18;
HXDLIN(  61)													while((_g34 < _g35)){
HXLINE(  61)														_g34 = (_g34 + 1);
HXDLIN(  61)														int i19 = (_g34 - 1);
HXLINE( 345)														prev1 = l1;
HXLINE( 346)														l1 = l1->next;
            													}
            												}
HXLINE(  61)												if (::hx::IsNull( prev1 )) {
HXLINE(  61)													b18->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  61)													l1 = null();
            												}
            												else {
HXLINE(  61)													prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  61)													l1 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  61)							undoImage4 = b18;
            						}
            						break;
            					}
HXDLIN(  61)					this84->image = undoImage4;
HXDLIN(  61)					this84->width = width1;
HXDLIN(  61)					this84->height = height1;
HXDLIN(  61)					this84->imageType = ( (int)(imageType1) );
HXDLIN(  61)					undoImage3 = this84;
HXDLIN(  61)					{
HXLINE(  61)						int rectLeft1 = xIter31->start;
HXDLIN(  61)						int rectTop1 = yIter31->start;
HXDLIN(  61)						int rectRight1 = xIter31->max;
HXDLIN(  61)						bool forceClear1 = false;
HXDLIN(  61)						{
HXLINE(  61)							int _g36 = rectTop1;
HXDLIN(  61)							int _g37 = yIter31->max;
HXDLIN(  61)							while((_g36 < _g37)){
HXLINE(  61)								_g36 = (_g36 + 1);
HXDLIN(  61)								int dy2 = (_g36 - 1);
HXDLIN(  61)								{
HXLINE(  61)									int _g38 = rectLeft1;
HXDLIN(  61)									int _g39 = rectRight1;
HXDLIN(  61)									while((_g38 < _g39)){
HXLINE(  61)										_g38 = (_g38 + 1);
HXDLIN(  61)										int dx2 = (_g38 - 1);
HXDLIN(  61)										::Dynamic this86 = this1->image;
HXDLIN(  61)										int index10;
HXDLIN(  61)										if (this1->useVirtualPos) {
HXLINE(  61)											index10 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx2) - this1->virtualX));
            										}
            										else {
HXLINE(  61)											index10 = ::Std_obj::_hx_int(( (Float)(((dy2 * this1->width) + dx2)) ));
            										}
HXDLIN(  61)										int c9 = ::iterMagic::Iimg_obj::get(this86,index10);
HXDLIN(  61)										int col1;
HXDLIN(  61)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)											col1 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            										}
            										else {
HXLINE(  61)											col1 = c9;
            										}
HXDLIN(  61)										bool _hx_tmp20;
HXDLIN(  61)										if (this1->useMask) {
HXLINE(  61)											_hx_tmp20 = ::hx::IsNotNull( this1->mask );
            										}
            										else {
HXLINE(  61)											_hx_tmp20 = false;
            										}
HXDLIN(  61)										if (_hx_tmp20) {
HXLINE(  61)											 ::pi_xy::ImageStruct this87 = this1->mask;
HXDLIN(  61)											::Dynamic this88 = this87->image;
HXDLIN(  61)											int index11;
HXDLIN(  61)											if (this87->useVirtualPos) {
HXLINE(  61)												index11 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this87->virtualY) * ( (Float)(this87->width) )) + dx2) - this87->virtualX));
            											}
            											else {
HXLINE(  61)												index11 = ::Std_obj::_hx_int(( (Float)(((dy2 * this87->width) + dx2)) ));
            											}
HXDLIN(  61)											int c10 = ::iterMagic::Iimg_obj::get(this88,index11);
HXDLIN(  61)											int v4;
HXDLIN(  61)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)												v4 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            											}
            											else {
HXLINE(  61)												v4 = c10;
            											}
HXDLIN(  61)											int maskPixel1 = v4;
HXDLIN(  61)											int this89 = col1;
HXDLIN(  61)											if ((maskPixel1 == 0)) {
HXLINE(  61)												col1 = this89;
            											}
            											else {
HXLINE(  61)												Float m01;
HXDLIN(  61)												int this90 = ((maskPixel1 >> 24) & 255);
HXDLIN(  61)												if ((this90 == 0)) {
HXLINE(  61)													m01 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													m01 = (( (Float)(this90) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float m11;
HXDLIN(  61)												int this91 = ((maskPixel1 >> 16) & 255);
HXDLIN(  61)												if ((this91 == 0)) {
HXLINE(  61)													m11 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													m11 = (( (Float)(this91) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float m21;
HXDLIN(  61)												int this92 = ((maskPixel1 >> 8) & 255);
HXDLIN(  61)												if ((this92 == 0)) {
HXLINE(  61)													m21 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													m21 = (( (Float)(this92) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float m31;
HXDLIN(  61)												int this93 = (maskPixel1 & 255);
HXDLIN(  61)												if ((this93 == 0)) {
HXLINE(  61)													m31 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													m31 = (( (Float)(this93) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this89 >> 24) & 255)) )));
HXDLIN(  61)												int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this89 >> 16) & 255)) )));
HXDLIN(  61)												int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this89 >> 8) & 255)) )));
HXDLIN(  61)												int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this89 & 255)) )));
HXDLIN(  61)												col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN(  61)										if ((col1 != 0)) {
HXLINE(  61)											int x10 = (dx2 - rectLeft1);
HXDLIN(  61)											int y10 = (dy2 - rectTop1);
HXDLIN(  61)											int c11 = col1;
HXDLIN(  61)											bool _hx_tmp21;
HXDLIN(  61)											if ((((c11 >> 24) & 255) < 254)) {
HXLINE(  61)												_hx_tmp21 = undoImage3->transparent;
            											}
            											else {
HXLINE(  61)												_hx_tmp21 = false;
            											}
HXDLIN(  61)											if (_hx_tmp21) {
HXLINE(  61)												int location6;
HXDLIN(  61)												if (undoImage3->useVirtualPos) {
HXLINE(  61)													location6 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x10) - undoImage3->virtualX));
            												}
            												else {
HXLINE(  61)													location6 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage3->width) + x10)) ));
            												}
HXDLIN(  61)												int this94 = ::iterMagic::Iimg_obj::get(undoImage3->image,location6);
HXDLIN(  61)												int this95;
HXDLIN(  61)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)													this95 = ((((((this94 >> 24) & 255) << 24) | ((this94 & 255) << 16)) | (((this94 >> 8) & 255) << 8)) | ((this94 >> 16) & 255));
            												}
            												else {
HXLINE(  61)													this95 = this94;
            												}
HXDLIN(  61)												Float a17;
HXDLIN(  61)												int this96 = ((this95 >> 24) & 255);
HXDLIN(  61)												if ((this96 == 0)) {
HXLINE(  61)													a17 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													a17 = (( (Float)(this96) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float r16;
HXDLIN(  61)												int this97 = ((this95 >> 16) & 255);
HXDLIN(  61)												if ((this97 == 0)) {
HXLINE(  61)													r16 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													r16 = (( (Float)(this97) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float g16;
HXDLIN(  61)												int this98 = ((this95 >> 8) & 255);
HXDLIN(  61)												if ((this98 == 0)) {
HXLINE(  61)													g16 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													g16 = (( (Float)(this98) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float b19;
HXDLIN(  61)												int this99 = (this95 & 255);
HXDLIN(  61)												if ((this99 == 0)) {
HXLINE(  61)													b19 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													b19 = (( (Float)(this99) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float a26;
HXDLIN(  61)												int this100 = ((col1 >> 24) & 255);
HXDLIN(  61)												if ((this100 == 0)) {
HXLINE(  61)													a26 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													a26 = (( (Float)(this100) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float r26;
HXDLIN(  61)												int this101 = ((col1 >> 16) & 255);
HXDLIN(  61)												if ((this101 == 0)) {
HXLINE(  61)													r26 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													r26 = (( (Float)(this101) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float g26;
HXDLIN(  61)												int this102 = ((col1 >> 8) & 255);
HXDLIN(  61)												if ((this102 == 0)) {
HXLINE(  61)													g26 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													g26 = (( (Float)(this102) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float b26;
HXDLIN(  61)												int this103 = (col1 & 255);
HXDLIN(  61)												if ((this103 == 0)) {
HXLINE(  61)													b26 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													b26 = (( (Float)(this103) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float a36 = (a17 * (( (Float)(1) ) - a26));
HXDLIN(  61)												int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN(  61)												int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN(  61)												int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b19 * a36) + (b26 * a26))));
HXDLIN(  61)												int a18 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN(  61)												int blended6 = ((((a18 << 24) | (r8 << 16)) | (g8 << 8)) | b20);
HXDLIN(  61)												{
HXLINE(  61)													int _hx_tmp22;
HXDLIN(  61)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)														_hx_tmp22 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            													}
            													else {
HXLINE(  61)														_hx_tmp22 = blended6;
            													}
HXDLIN(  61)													::iterMagic::Iimg_obj::set(undoImage3->image,location6,_hx_tmp22);
            												}
            											}
            											else {
HXLINE(  61)												::Dynamic this104 = undoImage3->image;
HXDLIN(  61)												int index12;
HXDLIN(  61)												if (undoImage3->useVirtualPos) {
HXLINE(  61)													index12 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x10) - undoImage3->virtualX));
            												}
            												else {
HXLINE(  61)													index12 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage3->width) + x10)) ));
            												}
HXDLIN(  61)												int _hx_tmp23;
HXDLIN(  61)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)													_hx_tmp23 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            												}
            												else {
HXLINE(  61)													_hx_tmp23 = c11;
            												}
HXDLIN(  61)												::iterMagic::Iimg_obj::set(this104,index12,_hx_tmp23);
            											}
            										}
            										else {
HXLINE(  61)											if (forceClear1) {
HXLINE(  61)												::Dynamic this105 = undoImage3->image;
HXDLIN(  61)												int x11 = (dx2 - rectLeft1);
HXDLIN(  61)												int y11 = (dy2 - rectTop1);
HXDLIN(  61)												int index13;
HXDLIN(  61)												if (undoImage3->useVirtualPos) {
HXLINE(  61)													index13 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x11) - undoImage3->virtualX));
            												}
            												else {
HXLINE(  61)													index13 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage3->width) + x11)) ));
            												}
HXDLIN(  61)												::iterMagic::Iimg_obj::set(this105,index13,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  61)				bool foundY1 = false;
HXDLIN(  61)				Float s1 = ((Float)0.);
HXDLIN(  61)				Float t1 = ((Float)0.);
HXDLIN(  61)				Float sxx1 = ((Float)0.);
HXDLIN(  61)				Float txx1 = ((Float)0.);
HXDLIN(  61)				{
HXLINE(  61)					int _g_min2 = xIter31->start;
HXDLIN(  61)					int _g_max2 = xIter31->max;
HXDLIN(  61)					while((_g_min2 < _g_max2)){
HXLINE(  61)						_g_min2 = (_g_min2 + 1);
HXDLIN(  61)						int x12 = (_g_min2 - 1);
HXLINE( 222)						sxx1 = (sx1 * ( (Float)(x12) ));
HXLINE( 223)						txx1 = (tx1 * ( (Float)(x12) ));
HXLINE( 224)						foundY1 = false;
HXLINE(  61)						{
HXLINE(  61)							int _g_min3 = yIter31->start;
HXDLIN(  61)							int _g_max3 = yIter31->max;
HXDLIN(  61)							while((_g_min3 < _g_max3)){
HXLINE(  61)								_g_min3 = (_g_min3 + 1);
HXDLIN(  61)								int y12 = (_g_min3 - 1);
HXLINE( 226)								s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y12) )));
HXLINE( 227)								t1 = ((t01 + txx1) + (ty1 * ( (Float)(y12) )));
HXLINE(  61)								bool _hx_tmp24;
HXDLIN(  61)								if (!((s1 <= 0))) {
HXLINE(  61)									_hx_tmp24 = (t1 <= 0);
            								}
            								else {
HXLINE(  61)									_hx_tmp24 = true;
            								}
HXDLIN(  61)								if (_hx_tmp24) {
HXLINE(  61)									if (foundY1) {
HXLINE(  61)										goto _hx_goto_99;
            									}
            								}
            								else {
HXLINE(  61)									if (((s1 + t1) < A1)) {
HXLINE(  61)										int x13 = ::hx::Mod(x12,tileImage->width);
HXDLIN(  61)										int y13 = ::hx::Mod(y12,tileImage->height);
HXDLIN(  61)										::Dynamic this106 = tileImage->image;
HXDLIN(  61)										int index14;
HXDLIN(  61)										if (tileImage->useVirtualPos) {
HXLINE(  61)											index14 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x13) - tileImage->virtualX));
            										}
            										else {
HXLINE(  61)											index14 = ::Std_obj::_hx_int(( (Float)(((y13 * tileImage->width) + x13)) ));
            										}
HXDLIN(  61)										int c12 = ::iterMagic::Iimg_obj::get(this106,index14);
HXDLIN(  61)										int color1;
HXDLIN(  61)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)											color1 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            										}
            										else {
HXLINE(  61)											color1 = c12;
            										}
HXDLIN(  61)										{
HXLINE(  61)											int c13 = color1;
HXDLIN(  61)											bool _hx_tmp25;
HXDLIN(  61)											if ((((c13 >> 24) & 255) < 254)) {
HXLINE(  61)												_hx_tmp25 = this1->transparent;
            											}
            											else {
HXLINE(  61)												_hx_tmp25 = false;
            											}
HXDLIN(  61)											if (_hx_tmp25) {
HXLINE(  61)												int location7;
HXDLIN(  61)												if (this1->useVirtualPos) {
HXLINE(  61)													location7 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - this1->virtualY) * ( (Float)(this1->width) )) + x12) - this1->virtualX));
            												}
            												else {
HXLINE(  61)													location7 = ::Std_obj::_hx_int(( (Float)(((y12 * this1->width) + x12)) ));
            												}
HXDLIN(  61)												int this107 = ::iterMagic::Iimg_obj::get(this1->image,location7);
HXDLIN(  61)												int this108;
HXDLIN(  61)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)													this108 = ((((((this107 >> 24) & 255) << 24) | ((this107 & 255) << 16)) | (((this107 >> 8) & 255) << 8)) | ((this107 >> 16) & 255));
            												}
            												else {
HXLINE(  61)													this108 = this107;
            												}
HXDLIN(  61)												Float a19;
HXDLIN(  61)												int this109 = ((this108 >> 24) & 255);
HXDLIN(  61)												if ((this109 == 0)) {
HXLINE(  61)													a19 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													a19 = (( (Float)(this109) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float r17;
HXDLIN(  61)												int this110 = ((this108 >> 16) & 255);
HXDLIN(  61)												if ((this110 == 0)) {
HXLINE(  61)													r17 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													r17 = (( (Float)(this110) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float g17;
HXDLIN(  61)												int this111 = ((this108 >> 8) & 255);
HXDLIN(  61)												if ((this111 == 0)) {
HXLINE(  61)													g17 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													g17 = (( (Float)(this111) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float b110;
HXDLIN(  61)												int this112 = (this108 & 255);
HXDLIN(  61)												if ((this112 == 0)) {
HXLINE(  61)													b110 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													b110 = (( (Float)(this112) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float a27;
HXDLIN(  61)												int this113 = ((color1 >> 24) & 255);
HXDLIN(  61)												if ((this113 == 0)) {
HXLINE(  61)													a27 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													a27 = (( (Float)(this113) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float r27;
HXDLIN(  61)												int this114 = ((color1 >> 16) & 255);
HXDLIN(  61)												if ((this114 == 0)) {
HXLINE(  61)													r27 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													r27 = (( (Float)(this114) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float g27;
HXDLIN(  61)												int this115 = ((color1 >> 8) & 255);
HXDLIN(  61)												if ((this115 == 0)) {
HXLINE(  61)													g27 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													g27 = (( (Float)(this115) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float b27;
HXDLIN(  61)												int this116 = (color1 & 255);
HXDLIN(  61)												if ((this116 == 0)) {
HXLINE(  61)													b27 = ((Float)0.);
            												}
            												else {
HXLINE(  61)													b27 = (( (Float)(this116) ) / ( (Float)(255) ));
            												}
HXDLIN(  61)												Float a37 = (a19 * (( (Float)(1) ) - a27));
HXDLIN(  61)												int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN(  61)												int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN(  61)												int b28 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a37) + (b27 * a27))));
HXDLIN(  61)												int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN(  61)												int blended7 = ((((a20 << 24) | (r9 << 16)) | (g9 << 8)) | b28);
HXDLIN(  61)												{
HXLINE(  61)													int _hx_tmp26;
HXDLIN(  61)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)														_hx_tmp26 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            													}
            													else {
HXLINE(  61)														_hx_tmp26 = blended7;
            													}
HXDLIN(  61)													::iterMagic::Iimg_obj::set(this1->image,location7,_hx_tmp26);
            												}
            											}
            											else {
HXLINE(  61)												::Dynamic this117 = this1->image;
HXDLIN(  61)												int index15;
HXDLIN(  61)												if (this1->useVirtualPos) {
HXLINE(  61)													index15 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - this1->virtualY) * ( (Float)(this1->width) )) + x12) - this1->virtualX));
            												}
            												else {
HXLINE(  61)													index15 = ::Std_obj::_hx_int(( (Float)(((y12 * this1->width) + x12)) ));
            												}
HXDLIN(  61)												int _hx_tmp27;
HXDLIN(  61)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  61)													_hx_tmp27 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            												}
            												else {
HXLINE(  61)													_hx_tmp27 = c13;
            												}
HXDLIN(  61)												::iterMagic::Iimg_obj::set(this117,index15,_hx_tmp27);
            											}
            										}
HXLINE( 236)										foundY1 = true;
            									}
            									else {
HXLINE(  61)										if (foundY1) {
HXLINE(  61)											goto _hx_goto_99;
            										}
            									}
            								}
            							}
            							_hx_goto_99:;
            						}
            					}
            				}
HXDLIN(  61)				if ((hasHit == false)) {
HXLINE(  61)					 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx,by,bx2,by2,cx2,cy2,true);
HXDLIN(  61)					if (hasUndo1) {
HXLINE(  61)						v5->undoImage = undoImage3;
HXDLIN(  61)						v5->undoX = xIter31->start;
HXDLIN(  61)						v5->undoY = yIter31->start;
            					}
            				}
            			}
            		}
HXDLIN(  61)		if ((hasHit == true)) {
HXLINE(  61)			 ::pi_xy::algo::HitQuad v6 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  61)			return v6;
            		}
            		else {
HXLINE(  61)			return null();
            		}
HXDLIN(  61)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(TileShape_Impl__obj,line,return )

void TileShape_Impl__obj::PolyBuild( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float rx,Float ry, ::pi_xy::ImageStruct tileImage, ::Dynamic __o_phi, ::Dynamic __o_sides,::hx::Null< bool >  __o_cornerUp){
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = ((Float)0.);
            		 ::Dynamic sides = __o_sides;
            		if (::hx::IsNull(__o_sides)) sides = 36;
            		bool cornerUp = __o_cornerUp.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_6e4d7718bf84d356_78_PolyBuild)
HXDLIN(  78)		 ::Dynamic phi1 = phi;
HXDLIN(  78)		 ::Dynamic sides1 = sides;
HXLINE(  83)		if (::hx::IsNull( sides1 )) {
HXLINE(  83)			sides1 = 36;
            		}
HXLINE(  82)		if (::hx::IsNull( phi1 )) {
HXLINE(  82)			phi1 = ((Float)0.);
            		}
HXLINE(  78)		Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN(  78)		Float omega;
HXDLIN(  78)		if (cornerUp) {
HXDLIN(  78)			omega = ((Float)0.);
            		}
            		else {
HXDLIN(  78)			if ((::Std_obj::_hx_int((( (Float)(sides1) ) / ( (Float)(2) ))) == (( (Float)(sides1) ) / ( (Float)(2) )))) {
HXDLIN(  78)				omega = (::Math_obj::PI / ( (Float)(sides1) ));
            			}
            			else {
HXDLIN(  78)				Float v = ((( (Float)(sides1) ) / ( (Float)(2) )) - ((Float)0.5));
HXDLIN(  78)				if ((::Std_obj::_hx_int((v / ( (Float)(2) ))) == (v / ( (Float)(2) )))) {
HXDLIN(  78)					omega = (((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides1) )) - ::Math_obj::PI);
            				}
            				else {
HXDLIN(  78)					omega = ((((Float)0.5) * ::Math_obj::PI) / ( (Float)(sides1) ));
            				}
            			}
            		}
HXDLIN(  78)		Float lastX = ((Float)0.);
HXDLIN(  78)		Float lastY = ((Float)0.);
HXDLIN(  78)		if (::hx::IsNotEq( phi1,0 )) {
HXLINE( 154)			lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi1) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi1) )))) + cx);
HXLINE( 155)			lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi1) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi1) )))) + cy);
            		}
            		else {
HXLINE( 157)			lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))));
HXLINE( 158)			lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))));
            		}
HXLINE(  78)		if (::hx::IsNotEq( phi1,0 )) {
HXDLIN(  78)			Float cphi = ::Math_obj::cos(( (Float)(phi1) ));
HXDLIN(  78)			Float sphi = ::Math_obj::sin(( (Float)(phi1) ));
HXDLIN(  78)			{
HXDLIN(  78)				int _g = 0;
HXDLIN(  78)				int _g1 = (sides1 + 1);
HXDLIN(  78)				while((_g < _g1)){
HXDLIN(  78)					_g = (_g + 1);
HXDLIN(  78)					int i = (_g - 1);
HXDLIN(  78)					Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN(  78)					Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN(  78)					Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXDLIN(  78)					Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXDLIN(  78)					{
HXDLIN(  78)						 ::pi_xy::ImageStruct this2 = this1;
HXDLIN(  78)						bool hasHit = false;
HXDLIN(  78)						{
HXDLIN(  78)							Float bx = lastX;
HXDLIN(  78)							Float by = lastY;
HXDLIN(  78)							Float cx1 = nextX;
HXDLIN(  78)							Float cy1 = nextY;
HXDLIN(  78)							bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN(  78)							if (!(adjustWinding)) {
HXDLIN(  78)								Float bx_ = bx;
HXDLIN(  78)								Float by_ = by;
HXLINE( 187)								bx = cx1;
HXLINE( 188)								by = cy1;
HXLINE( 189)								cx1 = bx_;
HXLINE( 190)								cy1 = by_;
            							}
HXLINE(  78)							{
HXDLIN(  78)								bool hasUndo = false;
HXDLIN(  78)								Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN(  78)								Float sx = (cy1 - cy);
HXDLIN(  78)								Float sy = (cx - cx1);
HXDLIN(  78)								Float t0 = ((cx * by) - (cy * bx));
HXDLIN(  78)								Float tx = (cy - by);
HXDLIN(  78)								Float ty = (bx - cx);
HXDLIN(  78)								Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN(  78)								 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  78)								if ((cx > bx)) {
HXDLIN(  78)									if ((cx > cx1)) {
HXDLIN(  78)										int min;
HXDLIN(  78)										if ((bx > cx1)) {
HXDLIN(  78)											min = ::Math_obj::floor(cx1);
            										}
            										else {
HXDLIN(  78)											min = ::Math_obj::floor(bx);
            										}
HXDLIN(  78)										int ii_min = min;
HXDLIN(  78)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  78)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            									}
            									else {
HXDLIN(  78)										int ii_min1 = ::Math_obj::floor(bx);
HXDLIN(  78)										int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN(  78)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            									}
            								}
            								else {
HXDLIN(  78)									if ((bx > cx1)) {
HXDLIN(  78)										int min1;
HXDLIN(  78)										if ((cx > cx1)) {
HXDLIN(  78)											min1 = ::Math_obj::floor(cx1);
            										}
            										else {
HXDLIN(  78)											min1 = ::Math_obj::ceil(cx);
            										}
HXDLIN(  78)										int ii_min2 = min1;
HXDLIN(  78)										int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN(  78)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            									}
            									else {
HXDLIN(  78)										int ii_min3 = ::Math_obj::floor(cx);
HXDLIN(  78)										int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN(  78)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            									}
            								}
HXDLIN(  78)								 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  78)								if ((cy > by)) {
HXDLIN(  78)									if ((cy > cy1)) {
HXDLIN(  78)										int min2;
HXDLIN(  78)										if ((by > cy1)) {
HXDLIN(  78)											min2 = ::Math_obj::floor(cy1);
            										}
            										else {
HXDLIN(  78)											min2 = ::Math_obj::floor(by);
            										}
HXDLIN(  78)										int ii_min4 = min2;
HXDLIN(  78)										int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN(  78)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            									}
            									else {
HXDLIN(  78)										int ii_min5 = ::Math_obj::floor(by);
HXDLIN(  78)										int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN(  78)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            									}
            								}
            								else {
HXDLIN(  78)									if ((by > cy1)) {
HXDLIN(  78)										int min3;
HXDLIN(  78)										if ((cy > cy1)) {
HXDLIN(  78)											min3 = ::Math_obj::floor(cy1);
            										}
            										else {
HXDLIN(  78)											min3 = ::Math_obj::ceil(cy);
            										}
HXDLIN(  78)										int ii_min6 = min3;
HXDLIN(  78)										int ii_max6 = ::Math_obj::ceil(by);
HXDLIN(  78)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            									}
            									else {
HXDLIN(  78)										int ii_min7 = ::Math_obj::floor(cy);
HXDLIN(  78)										int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN(  78)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            									}
            								}
HXDLIN(  78)								 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  78)								if (hasUndo) {
HXDLIN(  78)									int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  78)									int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  78)									 ::Dynamic imageType = null();
HXDLIN(  78)									 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  78)									if (::hx::IsNull( imageType )) {
HXLINE(  54)										imageType = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE(  78)									::Dynamic undoImage1;
HXDLIN(  78)									switch((int)(( (int)(imageType) ))){
            										case (int)0: {
HXDLIN(  78)											 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  78)											 ::iterMagic::BytesImg b = byt;
HXDLIN(  78)											{
HXDLIN(  78)												b->width = width;
HXDLIN(  78)												b->height = height;
HXDLIN(  78)												b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  78)												b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  78)												{
HXDLIN(  78)													int len = b->length;
HXDLIN(  78)													int w = 0;
HXDLIN(  78)													{
HXDLIN(  78)														int _g2 = 0;
HXDLIN(  78)														int _g3 = b->height;
HXDLIN(  78)														while((_g2 < _g3)){
HXDLIN(  78)															_g2 = (_g2 + 1);
HXDLIN(  78)															int y = (_g2 - 1);
HXDLIN(  78)															{
HXDLIN(  78)																int _g4 = 0;
HXDLIN(  78)																int _g5 = b->width;
HXDLIN(  78)																while((_g4 < _g5)){
HXDLIN(  78)																	_g4 = (_g4 + 1);
HXDLIN(  78)																	int x = (_g4 - 1);
HXDLIN(  78)																	{
HXDLIN(  78)																		w = (w + 1);
HXDLIN(  78)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  78)																	{
HXDLIN(  78)																		w = (w + 1);
HXDLIN(  78)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  78)																	{
HXDLIN(  78)																		w = (w + 1);
HXDLIN(  78)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  78)																	{
HXDLIN(  78)																		w = (w + 1);
HXDLIN(  78)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  78)											undoImage1 = b;
            										}
            										break;
            										case (int)1: {
HXDLIN(  78)											 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)											 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  78)											{
HXDLIN(  78)												a->width = width;
HXDLIN(  78)												a->height = height;
HXDLIN(  78)												a->data = ::Array_obj< int >::__new(0);
HXDLIN(  78)												a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  78)												{
HXDLIN(  78)													int _g6 = 0;
HXDLIN(  78)													int _g7 = a->length;
HXDLIN(  78)													while((_g6 < _g7)){
HXDLIN(  78)														_g6 = (_g6 + 1);
HXDLIN(  78)														int i1 = (_g6 - 1);
HXDLIN(  78)														a->data[i1] = 0;
            													}
            												}
            											}
HXDLIN(  78)											undoImage1 = a;
            										}
            										break;
            										case (int)2: {
HXDLIN(  78)											 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  78)											 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  78)											{
HXDLIN(  78)												b1->width = width;
HXDLIN(  78)												b1->height = height;
HXDLIN(  78)												b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  78)												int size = (b1->length * 4);
HXDLIN(  78)												b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  78)												{
HXDLIN(  78)													int _g8 = 0;
HXDLIN(  78)													int _g9 = b1->length;
HXDLIN(  78)													while((_g8 < _g9)){
HXDLIN(  78)														_g8 = (_g8 + 1);
HXDLIN(  78)														int i2 = (_g8 - 1);
HXDLIN(  78)														{
HXDLIN(  78)															 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN(  78)															bool undoImage2;
HXDLIN(  78)															if ((i2 >= 0)) {
HXDLIN(  78)																undoImage2 = (i2 < (this4->byteLength >> 2));
            															}
            															else {
HXDLIN(  78)																undoImage2 = false;
            															}
HXDLIN(  78)															if (undoImage2) {
HXDLIN(  78)																 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN(  78)																int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN(  78)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  78)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  78)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  78)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN(  78)											undoImage1 = b1;
            										}
            										break;
            										case (int)3: {
HXDLIN(  78)											 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)											 ::iterMagic::VecIntImg v1 = vec;
HXDLIN(  78)											{
HXDLIN(  78)												v1->width = width;
HXDLIN(  78)												v1->height = height;
HXDLIN(  78)												v1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  78)												v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN(  78)												{
HXDLIN(  78)													int _g10 = 0;
HXDLIN(  78)													int _g11 = v1->length;
HXDLIN(  78)													while((_g10 < _g11)){
HXDLIN(  78)														_g10 = (_g10 + 1);
HXDLIN(  78)														int i3 = (_g10 - 1);
HXDLIN(  78)														v1->data->__unsafe_set(i3,0);
            													}
            												}
            											}
HXDLIN(  78)											undoImage1 = v1;
            										}
            										break;
            										case (int)4: {
HXDLIN(  78)											 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)											 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  78)											{
HXDLIN(  78)												b2->width = width;
HXDLIN(  78)												b2->height = height;
HXDLIN(  78)												b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  78)												b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  78)												{
HXDLIN(  78)													int len1 = b2->length;
HXDLIN(  78)													 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  78)													if (::hx::IsNull( d->head )) {
HXDLIN(  78)														int _g12 = 0;
HXDLIN(  78)														int _g13 = len1;
HXDLIN(  78)														while((_g12 < _g13)){
HXDLIN(  78)															_g12 = (_g12 + 1);
HXDLIN(  78)															int i4 = (_g12 - 1);
HXDLIN(  78)															d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            														}
            													}
            													else {
HXDLIN(  78)														int _g14 = 0;
HXDLIN(  78)														int _g15 = len1;
HXDLIN(  78)														while((_g14 < _g15)){
HXDLIN(  78)															_g14 = (_g14 + 1);
HXDLIN(  78)															int i5 = (_g14 - 1);
HXDLIN(  78)															{
HXDLIN(  78)																 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  78)																 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  78)																{
HXDLIN(  78)																	int _g16 = 0;
HXDLIN(  78)																	int _g17 = i5;
HXDLIN(  78)																	while((_g16 < _g17)){
HXDLIN(  78)																		_g16 = (_g16 + 1);
HXDLIN(  78)																		int i6 = (_g16 - 1);
HXLINE( 345)																		prev = l;
HXLINE( 346)																		l = l->next;
            																	}
            																}
HXLINE(  78)																if (::hx::IsNull( prev )) {
HXDLIN(  78)																	b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  78)																	l = null();
            																}
            																else {
HXDLIN(  78)																	prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  78)																	l = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  78)											undoImage1 = b2;
            										}
            										break;
            									}
HXDLIN(  78)									this3->image = undoImage1;
HXDLIN(  78)									this3->width = width;
HXDLIN(  78)									this3->height = height;
HXDLIN(  78)									this3->imageType = ( (int)(imageType) );
HXDLIN(  78)									undoImage = this3;
HXDLIN(  78)									{
HXDLIN(  78)										int rectLeft = xIter3->start;
HXDLIN(  78)										int rectTop = yIter3->start;
HXDLIN(  78)										int rectRight = xIter3->max;
HXDLIN(  78)										bool forceClear = false;
HXDLIN(  78)										{
HXDLIN(  78)											int _g18 = rectTop;
HXDLIN(  78)											int _g19 = yIter3->max;
HXDLIN(  78)											while((_g18 < _g19)){
HXDLIN(  78)												_g18 = (_g18 + 1);
HXDLIN(  78)												int dy = (_g18 - 1);
HXDLIN(  78)												{
HXDLIN(  78)													int _g20 = rectLeft;
HXDLIN(  78)													int _g21 = rectRight;
HXDLIN(  78)													while((_g20 < _g21)){
HXDLIN(  78)														_g20 = (_g20 + 1);
HXDLIN(  78)														int dx = (_g20 - 1);
HXDLIN(  78)														::Dynamic this5 = this2->image;
HXDLIN(  78)														int index;
HXDLIN(  78)														if (this2->useVirtualPos) {
HXDLIN(  78)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            														}
            														else {
HXDLIN(  78)															index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            														}
HXDLIN(  78)														int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN(  78)														int col;
HXDLIN(  78)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXDLIN(  78)															col = c;
            														}
HXDLIN(  78)														bool _hx_tmp;
HXDLIN(  78)														if (this2->useMask) {
HXDLIN(  78)															_hx_tmp = ::hx::IsNotNull( this2->mask );
            														}
            														else {
HXDLIN(  78)															_hx_tmp = false;
            														}
HXDLIN(  78)														if (_hx_tmp) {
HXDLIN(  78)															 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN(  78)															::Dynamic this7 = this6->image;
HXDLIN(  78)															int index1;
HXDLIN(  78)															if (this6->useVirtualPos) {
HXDLIN(  78)																index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            															}
            															else {
HXDLIN(  78)																index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            															}
HXDLIN(  78)															int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN(  78)															int v2;
HXDLIN(  78)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            															}
            															else {
HXDLIN(  78)																v2 = c1;
            															}
HXDLIN(  78)															int maskPixel = v2;
HXDLIN(  78)															int this8 = col;
HXDLIN(  78)															if ((maskPixel == 0)) {
HXDLIN(  78)																col = this8;
            															}
            															else {
HXDLIN(  78)																Float m0;
HXDLIN(  78)																int this9 = ((maskPixel >> 24) & 255);
HXDLIN(  78)																if ((this9 == 0)) {
HXDLIN(  78)																	m0 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float m1;
HXDLIN(  78)																int this10 = ((maskPixel >> 16) & 255);
HXDLIN(  78)																if ((this10 == 0)) {
HXDLIN(  78)																	m1 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float m2;
HXDLIN(  78)																int this11 = ((maskPixel >> 8) & 255);
HXDLIN(  78)																if ((this11 == 0)) {
HXDLIN(  78)																	m2 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float m3;
HXDLIN(  78)																int this12 = (maskPixel & 255);
HXDLIN(  78)																if ((this12 == 0)) {
HXDLIN(  78)																	m3 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN(  78)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN(  78)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN(  78)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN(  78)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  78)														if ((col != 0)) {
HXDLIN(  78)															int x1 = (dx - rectLeft);
HXDLIN(  78)															int y1 = (dy - rectTop);
HXDLIN(  78)															int c2 = col;
HXDLIN(  78)															bool _hx_tmp1;
HXDLIN(  78)															if ((((c2 >> 24) & 255) < 254)) {
HXDLIN(  78)																_hx_tmp1 = undoImage->transparent;
            															}
            															else {
HXDLIN(  78)																_hx_tmp1 = false;
            															}
HXDLIN(  78)															if (_hx_tmp1) {
HXDLIN(  78)																int location;
HXDLIN(  78)																if (undoImage->useVirtualPos) {
HXDLIN(  78)																	location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXDLIN(  78)																	location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN(  78)																int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN(  78)																int this14;
HXDLIN(  78)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																	this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																}
            																else {
HXDLIN(  78)																	this14 = this13;
            																}
HXDLIN(  78)																Float a1;
HXDLIN(  78)																int this15 = ((this14 >> 24) & 255);
HXDLIN(  78)																if ((this15 == 0)) {
HXDLIN(  78)																	a1 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float r1;
HXDLIN(  78)																int this16 = ((this14 >> 16) & 255);
HXDLIN(  78)																if ((this16 == 0)) {
HXDLIN(  78)																	r1 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float g1;
HXDLIN(  78)																int this17 = ((this14 >> 8) & 255);
HXDLIN(  78)																if ((this17 == 0)) {
HXDLIN(  78)																	g1 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float b11;
HXDLIN(  78)																int this18 = (this14 & 255);
HXDLIN(  78)																if ((this18 == 0)) {
HXDLIN(  78)																	b11 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float a2;
HXDLIN(  78)																int this19 = ((col >> 24) & 255);
HXDLIN(  78)																if ((this19 == 0)) {
HXDLIN(  78)																	a2 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float r2;
HXDLIN(  78)																int this20 = ((col >> 16) & 255);
HXDLIN(  78)																if ((this20 == 0)) {
HXDLIN(  78)																	r2 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float g2;
HXDLIN(  78)																int this21 = ((col >> 8) & 255);
HXDLIN(  78)																if ((this21 == 0)) {
HXDLIN(  78)																	g2 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float b21;
HXDLIN(  78)																int this22 = (col & 255);
HXDLIN(  78)																if ((this22 == 0)) {
HXDLIN(  78)																	b21 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  78)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  78)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  78)																int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  78)																int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  78)																int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  78)																{
HXDLIN(  78)																	int _hx_tmp2;
HXDLIN(  78)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																		_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXDLIN(  78)																		_hx_tmp2 = blended;
            																	}
HXDLIN(  78)																	::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																}
            															}
            															else {
HXDLIN(  78)																::Dynamic this23 = undoImage->image;
HXDLIN(  78)																int index2;
HXDLIN(  78)																if (undoImage->useVirtualPos) {
HXDLIN(  78)																	index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXDLIN(  78)																	index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN(  78)																int _hx_tmp3;
HXDLIN(  78)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																	_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																}
            																else {
HXDLIN(  78)																	_hx_tmp3 = c2;
            																}
HXDLIN(  78)																::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            															}
            														}
            														else {
HXDLIN(  78)															if (forceClear) {
HXDLIN(  78)																::Dynamic this24 = undoImage->image;
HXDLIN(  78)																int x2 = (dx - rectLeft);
HXDLIN(  78)																int y2 = (dy - rectTop);
HXDLIN(  78)																int index3;
HXDLIN(  78)																if (undoImage->useVirtualPos) {
HXDLIN(  78)																	index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																}
            																else {
HXDLIN(  78)																	index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																}
HXDLIN(  78)																::iterMagic::Iimg_obj::set(this24,index3,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  78)								bool foundY = false;
HXDLIN(  78)								Float s = ((Float)0.);
HXDLIN(  78)								Float t = ((Float)0.);
HXDLIN(  78)								Float sxx = ((Float)0.);
HXDLIN(  78)								Float txx = ((Float)0.);
HXDLIN(  78)								{
HXDLIN(  78)									int _g_min = xIter3->start;
HXDLIN(  78)									int _g_max = xIter3->max;
HXDLIN(  78)									while((_g_min < _g_max)){
HXDLIN(  78)										_g_min = (_g_min + 1);
HXDLIN(  78)										int x3 = (_g_min - 1);
HXLINE( 222)										sxx = (sx * ( (Float)(x3) ));
HXLINE( 223)										txx = (tx * ( (Float)(x3) ));
HXLINE( 224)										foundY = false;
HXLINE(  78)										{
HXDLIN(  78)											int _g_min1 = yIter3->start;
HXDLIN(  78)											int _g_max1 = yIter3->max;
HXDLIN(  78)											while((_g_min1 < _g_max1)){
HXDLIN(  78)												_g_min1 = (_g_min1 + 1);
HXDLIN(  78)												int y3 = (_g_min1 - 1);
HXLINE( 226)												s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE( 227)												t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE(  78)												bool _hx_tmp4;
HXDLIN(  78)												if (!((s <= 0))) {
HXDLIN(  78)													_hx_tmp4 = (t <= 0);
            												}
            												else {
HXDLIN(  78)													_hx_tmp4 = true;
            												}
HXDLIN(  78)												if (_hx_tmp4) {
HXDLIN(  78)													if (foundY) {
HXDLIN(  78)														goto _hx_goto_113;
            													}
            												}
            												else {
HXDLIN(  78)													if (((s + t) < A)) {
HXDLIN(  78)														int x4 = ::hx::Mod(x3,tileImage->width);
HXDLIN(  78)														int y4 = ::hx::Mod(y3,tileImage->height);
HXDLIN(  78)														::Dynamic this25 = tileImage->image;
HXDLIN(  78)														int index4;
HXDLIN(  78)														if (tileImage->useVirtualPos) {
HXDLIN(  78)															index4 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x4) - tileImage->virtualX));
            														}
            														else {
HXDLIN(  78)															index4 = ::Std_obj::_hx_int(( (Float)(((y4 * tileImage->width) + x4)) ));
            														}
HXDLIN(  78)														int c3 = ::iterMagic::Iimg_obj::get(this25,index4);
HXDLIN(  78)														int color;
HXDLIN(  78)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)															color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            														}
            														else {
HXDLIN(  78)															color = c3;
            														}
HXDLIN(  78)														{
HXDLIN(  78)															int c4 = color;
HXDLIN(  78)															bool _hx_tmp5;
HXDLIN(  78)															if ((((c4 >> 24) & 255) < 254)) {
HXDLIN(  78)																_hx_tmp5 = this2->transparent;
            															}
            															else {
HXDLIN(  78)																_hx_tmp5 = false;
            															}
HXDLIN(  78)															if (_hx_tmp5) {
HXDLIN(  78)																int location1;
HXDLIN(  78)																if (this2->useVirtualPos) {
HXDLIN(  78)																	location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																}
            																else {
HXDLIN(  78)																	location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																}
HXDLIN(  78)																int this26 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN(  78)																int this27;
HXDLIN(  78)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																	this27 = ((((((this26 >> 24) & 255) << 24) | ((this26 & 255) << 16)) | (((this26 >> 8) & 255) << 8)) | ((this26 >> 16) & 255));
            																}
            																else {
HXDLIN(  78)																	this27 = this26;
            																}
HXDLIN(  78)																Float a11;
HXDLIN(  78)																int this28 = ((this27 >> 24) & 255);
HXDLIN(  78)																if ((this28 == 0)) {
HXDLIN(  78)																	a11 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	a11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float r11;
HXDLIN(  78)																int this29 = ((this27 >> 16) & 255);
HXDLIN(  78)																if ((this29 == 0)) {
HXDLIN(  78)																	r11 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	r11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float g11;
HXDLIN(  78)																int this30 = ((this27 >> 8) & 255);
HXDLIN(  78)																if ((this30 == 0)) {
HXDLIN(  78)																	g11 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	g11 = (( (Float)(this30) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float b12;
HXDLIN(  78)																int this31 = (this27 & 255);
HXDLIN(  78)																if ((this31 == 0)) {
HXDLIN(  78)																	b12 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	b12 = (( (Float)(this31) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float a21;
HXDLIN(  78)																int this32 = ((color >> 24) & 255);
HXDLIN(  78)																if ((this32 == 0)) {
HXDLIN(  78)																	a21 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	a21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float r21;
HXDLIN(  78)																int this33 = ((color >> 16) & 255);
HXDLIN(  78)																if ((this33 == 0)) {
HXDLIN(  78)																	r21 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	r21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float g21;
HXDLIN(  78)																int this34 = ((color >> 8) & 255);
HXDLIN(  78)																if ((this34 == 0)) {
HXDLIN(  78)																	g21 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	g21 = (( (Float)(this34) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float b22;
HXDLIN(  78)																int this35 = (color & 255);
HXDLIN(  78)																if ((this35 == 0)) {
HXDLIN(  78)																	b22 = ((Float)0.);
            																}
            																else {
HXDLIN(  78)																	b22 = (( (Float)(this35) ) / ( (Float)(255) ));
            																}
HXDLIN(  78)																Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  78)																int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  78)																int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  78)																int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  78)																int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  78)																int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  78)																{
HXDLIN(  78)																	int _hx_tmp6;
HXDLIN(  78)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																		_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																	}
            																	else {
HXDLIN(  78)																		_hx_tmp6 = blended1;
            																	}
HXDLIN(  78)																	::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp6);
            																}
            															}
            															else {
HXDLIN(  78)																::Dynamic this36 = this2->image;
HXDLIN(  78)																int index5;
HXDLIN(  78)																if (this2->useVirtualPos) {
HXDLIN(  78)																	index5 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																}
            																else {
HXDLIN(  78)																	index5 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																}
HXDLIN(  78)																int _hx_tmp7;
HXDLIN(  78)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																	_hx_tmp7 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            																}
            																else {
HXDLIN(  78)																	_hx_tmp7 = c4;
            																}
HXDLIN(  78)																::iterMagic::Iimg_obj::set(this36,index5,_hx_tmp7);
            															}
            														}
HXLINE( 236)														foundY = true;
            													}
            													else {
HXDLIN(  78)														if (foundY) {
HXDLIN(  78)															goto _hx_goto_113;
            														}
            													}
            												}
            											}
            											_hx_goto_113:;
            										}
            									}
            								}
HXDLIN(  78)								if ((hasHit == false)) {
HXDLIN(  78)									 ::pi_xy::algo::HitTri v3 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN(  78)									if (hasUndo) {
HXDLIN(  78)										v3->undoImage = undoImage;
HXDLIN(  78)										v3->undoX = xIter3->start;
HXDLIN(  78)										v3->undoY = yIter3->start;
            									}
            								}
            							}
            						}
            					}
HXLINE( 169)					lastX = nextX;
HXLINE( 170)					lastY = nextY;
            				}
            			}
            		}
            		else {
HXDLIN(  78)			int _g22 = 0;
HXDLIN(  78)			int _g23 = (sides1 + 1);
HXDLIN(  78)			while((_g22 < _g23)){
HXDLIN(  78)				_g22 = (_g22 + 1);
HXDLIN(  78)				int i7 = (_g22 - 1);
HXDLIN(  78)				Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN(  78)				Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN(  78)				{
HXDLIN(  78)					 ::pi_xy::ImageStruct this37 = this1;
HXDLIN(  78)					bool hasHit1 = false;
HXDLIN(  78)					{
HXDLIN(  78)						Float bx1 = lastX;
HXDLIN(  78)						Float by1 = lastY;
HXDLIN(  78)						Float cx2 = nextX1;
HXDLIN(  78)						Float cy2 = nextY1;
HXDLIN(  78)						bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN(  78)						if (!(adjustWinding1)) {
HXDLIN(  78)							Float bx_1 = bx1;
HXDLIN(  78)							Float by_1 = by1;
HXLINE( 187)							bx1 = cx2;
HXLINE( 188)							by1 = cy2;
HXLINE( 189)							cx2 = bx_1;
HXLINE( 190)							cy2 = by_1;
            						}
HXLINE(  78)						{
HXDLIN(  78)							bool hasUndo1 = false;
HXDLIN(  78)							Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN(  78)							Float sx1 = (cy2 - cy);
HXDLIN(  78)							Float sy1 = (cx - cx2);
HXDLIN(  78)							Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN(  78)							Float tx1 = (cy - by1);
HXDLIN(  78)							Float ty1 = (bx1 - cx);
HXDLIN(  78)							Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN(  78)							 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  78)							if ((cx > bx1)) {
HXDLIN(  78)								if ((cx > cx2)) {
HXDLIN(  78)									int min4;
HXDLIN(  78)									if ((bx1 > cx2)) {
HXDLIN(  78)										min4 = ::Math_obj::floor(cx2);
            									}
            									else {
HXDLIN(  78)										min4 = ::Math_obj::floor(bx1);
            									}
HXDLIN(  78)									int ii_min8 = min4;
HXDLIN(  78)									int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN(  78)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            								}
            								else {
HXDLIN(  78)									int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN(  78)									int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN(  78)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            								}
            							}
            							else {
HXDLIN(  78)								if ((bx1 > cx2)) {
HXDLIN(  78)									int min5;
HXDLIN(  78)									if ((cx > cx2)) {
HXDLIN(  78)										min5 = ::Math_obj::floor(cx2);
            									}
            									else {
HXDLIN(  78)										min5 = ::Math_obj::ceil(cx);
            									}
HXDLIN(  78)									int ii_min10 = min5;
HXDLIN(  78)									int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN(  78)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            								}
            								else {
HXDLIN(  78)									int ii_min11 = ::Math_obj::floor(cx);
HXDLIN(  78)									int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN(  78)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            								}
            							}
HXDLIN(  78)							 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  78)							if ((cy > by1)) {
HXDLIN(  78)								if ((cy > cy2)) {
HXDLIN(  78)									int min6;
HXDLIN(  78)									if ((by1 > cy2)) {
HXDLIN(  78)										min6 = ::Math_obj::floor(cy2);
            									}
            									else {
HXDLIN(  78)										min6 = ::Math_obj::floor(by1);
            									}
HXDLIN(  78)									int ii_min12 = min6;
HXDLIN(  78)									int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN(  78)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            								}
            								else {
HXDLIN(  78)									int ii_min13 = ::Math_obj::floor(by1);
HXDLIN(  78)									int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN(  78)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            								}
            							}
            							else {
HXDLIN(  78)								if ((by1 > cy2)) {
HXDLIN(  78)									int min7;
HXDLIN(  78)									if ((cy > cy2)) {
HXDLIN(  78)										min7 = ::Math_obj::floor(cy2);
            									}
            									else {
HXDLIN(  78)										min7 = ::Math_obj::ceil(cy);
            									}
HXDLIN(  78)									int ii_min14 = min7;
HXDLIN(  78)									int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN(  78)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            								}
            								else {
HXDLIN(  78)									int ii_min15 = ::Math_obj::floor(cy);
HXDLIN(  78)									int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN(  78)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            								}
            							}
HXDLIN(  78)							 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  78)							if (hasUndo1) {
HXDLIN(  78)								int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  78)								int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  78)								 ::Dynamic imageType1 = null();
HXDLIN(  78)								 ::pi_xy::ImageStruct this38 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  78)								if (::hx::IsNull( imageType1 )) {
HXLINE(  54)									imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE(  78)								::Dynamic undoImage4;
HXDLIN(  78)								switch((int)(( (int)(imageType1) ))){
            									case (int)0: {
HXDLIN(  78)										 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  78)										 ::iterMagic::BytesImg b5 = byt1;
HXDLIN(  78)										{
HXDLIN(  78)											b5->width = width1;
HXDLIN(  78)											b5->height = height1;
HXDLIN(  78)											b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  78)											b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN(  78)											{
HXDLIN(  78)												int len2 = b5->length;
HXDLIN(  78)												int w1 = 0;
HXDLIN(  78)												{
HXDLIN(  78)													int _g24 = 0;
HXDLIN(  78)													int _g25 = b5->height;
HXDLIN(  78)													while((_g24 < _g25)){
HXDLIN(  78)														_g24 = (_g24 + 1);
HXDLIN(  78)														int y5 = (_g24 - 1);
HXDLIN(  78)														{
HXDLIN(  78)															int _g26 = 0;
HXDLIN(  78)															int _g27 = b5->width;
HXDLIN(  78)															while((_g26 < _g27)){
HXDLIN(  78)																_g26 = (_g26 + 1);
HXDLIN(  78)																int x5 = (_g26 - 1);
HXDLIN(  78)																{
HXDLIN(  78)																	w1 = (w1 + 1);
HXDLIN(  78)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  78)																{
HXDLIN(  78)																	w1 = (w1 + 1);
HXDLIN(  78)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  78)																{
HXDLIN(  78)																	w1 = (w1 + 1);
HXDLIN(  78)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  78)																{
HXDLIN(  78)																	w1 = (w1 + 1);
HXDLIN(  78)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  78)										undoImage4 = b5;
            									}
            									break;
            									case (int)1: {
HXDLIN(  78)										 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)										 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN(  78)										{
HXDLIN(  78)											a6->width = width1;
HXDLIN(  78)											a6->height = height1;
HXDLIN(  78)											a6->data = ::Array_obj< int >::__new(0);
HXDLIN(  78)											a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  78)											{
HXDLIN(  78)												int _g28 = 0;
HXDLIN(  78)												int _g29 = a6->length;
HXDLIN(  78)												while((_g28 < _g29)){
HXDLIN(  78)													_g28 = (_g28 + 1);
HXDLIN(  78)													int i8 = (_g28 - 1);
HXDLIN(  78)													a6->data[i8] = 0;
            												}
            											}
            										}
HXDLIN(  78)										undoImage4 = a6;
            									}
            									break;
            									case (int)2: {
HXDLIN(  78)										 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  78)										 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN(  78)										{
HXDLIN(  78)											b6->width = width1;
HXDLIN(  78)											b6->height = height1;
HXDLIN(  78)											b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  78)											int size1 = (b6->length * 4);
HXDLIN(  78)											b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  78)											{
HXDLIN(  78)												int _g30 = 0;
HXDLIN(  78)												int _g31 = b6->length;
HXDLIN(  78)												while((_g30 < _g31)){
HXDLIN(  78)													_g30 = (_g30 + 1);
HXDLIN(  78)													int i9 = (_g30 - 1);
HXDLIN(  78)													{
HXDLIN(  78)														 ::haxe::io::ArrayBufferViewImpl this39 = b6->data;
HXDLIN(  78)														bool undoImage5;
HXDLIN(  78)														if ((i9 >= 0)) {
HXDLIN(  78)															undoImage5 = (i9 < (this39->byteLength >> 2));
            														}
            														else {
HXDLIN(  78)															undoImage5 = false;
            														}
HXDLIN(  78)														if (undoImage5) {
HXDLIN(  78)															 ::haxe::io::Bytes _this1 = this39->bytes;
HXDLIN(  78)															int pos1 = ((i9 << 2) + this39->byteOffset);
HXDLIN(  78)															_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  78)															_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  78)															_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  78)															_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN(  78)										undoImage4 = b6;
            									}
            									break;
            									case (int)3: {
HXDLIN(  78)										 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)										 ::iterMagic::VecIntImg v4 = vec1;
HXDLIN(  78)										{
HXDLIN(  78)											v4->width = width1;
HXDLIN(  78)											v4->height = height1;
HXDLIN(  78)											v4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  78)											v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN(  78)											{
HXDLIN(  78)												int _g32 = 0;
HXDLIN(  78)												int _g33 = v4->length;
HXDLIN(  78)												while((_g32 < _g33)){
HXDLIN(  78)													_g32 = (_g32 + 1);
HXDLIN(  78)													int i10 = (_g32 - 1);
HXDLIN(  78)													v4->data->__unsafe_set(i10,0);
            												}
            											}
            										}
HXDLIN(  78)										undoImage4 = v4;
            									}
            									break;
            									case (int)4: {
HXDLIN(  78)										 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  78)										 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN(  78)										{
HXDLIN(  78)											b7->width = width1;
HXDLIN(  78)											b7->height = height1;
HXDLIN(  78)											b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  78)											b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  78)											{
HXDLIN(  78)												int len3 = b7->length;
HXDLIN(  78)												 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN(  78)												if (::hx::IsNull( d1->head )) {
HXDLIN(  78)													int _g34 = 0;
HXDLIN(  78)													int _g35 = len3;
HXDLIN(  78)													while((_g34 < _g35)){
HXDLIN(  78)														_g34 = (_g34 + 1);
HXDLIN(  78)														int i11 = (_g34 - 1);
HXDLIN(  78)														d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            													}
            												}
            												else {
HXDLIN(  78)													int _g36 = 0;
HXDLIN(  78)													int _g37 = len3;
HXDLIN(  78)													while((_g36 < _g37)){
HXDLIN(  78)														_g36 = (_g36 + 1);
HXDLIN(  78)														int i12 = (_g36 - 1);
HXDLIN(  78)														{
HXDLIN(  78)															 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN(  78)															 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  78)															{
HXDLIN(  78)																int _g38 = 0;
HXDLIN(  78)																int _g39 = i12;
HXDLIN(  78)																while((_g38 < _g39)){
HXDLIN(  78)																	_g38 = (_g38 + 1);
HXDLIN(  78)																	int i13 = (_g38 - 1);
HXLINE( 345)																	prev1 = l1;
HXLINE( 346)																	l1 = l1->next;
            																}
            															}
HXLINE(  78)															if (::hx::IsNull( prev1 )) {
HXDLIN(  78)																b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  78)																l1 = null();
            															}
            															else {
HXDLIN(  78)																prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  78)																l1 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  78)										undoImage4 = b7;
            									}
            									break;
            								}
HXDLIN(  78)								this38->image = undoImage4;
HXDLIN(  78)								this38->width = width1;
HXDLIN(  78)								this38->height = height1;
HXDLIN(  78)								this38->imageType = ( (int)(imageType1) );
HXDLIN(  78)								undoImage3 = this38;
HXDLIN(  78)								{
HXDLIN(  78)									int rectLeft1 = xIter31->start;
HXDLIN(  78)									int rectTop1 = yIter31->start;
HXDLIN(  78)									int rectRight1 = xIter31->max;
HXDLIN(  78)									bool forceClear1 = false;
HXDLIN(  78)									{
HXDLIN(  78)										int _g40 = rectTop1;
HXDLIN(  78)										int _g41 = yIter31->max;
HXDLIN(  78)										while((_g40 < _g41)){
HXDLIN(  78)											_g40 = (_g40 + 1);
HXDLIN(  78)											int dy1 = (_g40 - 1);
HXDLIN(  78)											{
HXDLIN(  78)												int _g42 = rectLeft1;
HXDLIN(  78)												int _g43 = rectRight1;
HXDLIN(  78)												while((_g42 < _g43)){
HXDLIN(  78)													_g42 = (_g42 + 1);
HXDLIN(  78)													int dx1 = (_g42 - 1);
HXDLIN(  78)													::Dynamic this40 = this37->image;
HXDLIN(  78)													int index6;
HXDLIN(  78)													if (this37->useVirtualPos) {
HXDLIN(  78)														index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this37->virtualY) * ( (Float)(this37->width) )) + dx1) - this37->virtualX));
            													}
            													else {
HXDLIN(  78)														index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this37->width) + dx1)) ));
            													}
HXDLIN(  78)													int c5 = ::iterMagic::Iimg_obj::get(this40,index6);
HXDLIN(  78)													int col1;
HXDLIN(  78)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)														col1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            													}
            													else {
HXDLIN(  78)														col1 = c5;
            													}
HXDLIN(  78)													bool _hx_tmp8;
HXDLIN(  78)													if (this37->useMask) {
HXDLIN(  78)														_hx_tmp8 = ::hx::IsNotNull( this37->mask );
            													}
            													else {
HXDLIN(  78)														_hx_tmp8 = false;
            													}
HXDLIN(  78)													if (_hx_tmp8) {
HXDLIN(  78)														 ::pi_xy::ImageStruct this41 = this37->mask;
HXDLIN(  78)														::Dynamic this42 = this41->image;
HXDLIN(  78)														int index7;
HXDLIN(  78)														if (this41->useVirtualPos) {
HXDLIN(  78)															index7 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this41->virtualY) * ( (Float)(this41->width) )) + dx1) - this41->virtualX));
            														}
            														else {
HXDLIN(  78)															index7 = ::Std_obj::_hx_int(( (Float)(((dy1 * this41->width) + dx1)) ));
            														}
HXDLIN(  78)														int c6 = ::iterMagic::Iimg_obj::get(this42,index7);
HXDLIN(  78)														int v5;
HXDLIN(  78)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)															v5 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            														}
            														else {
HXDLIN(  78)															v5 = c6;
            														}
HXDLIN(  78)														int maskPixel1 = v5;
HXDLIN(  78)														int this43 = col1;
HXDLIN(  78)														if ((maskPixel1 == 0)) {
HXDLIN(  78)															col1 = this43;
            														}
            														else {
HXDLIN(  78)															Float m01;
HXDLIN(  78)															int this44 = ((maskPixel1 >> 24) & 255);
HXDLIN(  78)															if ((this44 == 0)) {
HXDLIN(  78)																m01 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																m01 = (( (Float)(this44) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float m11;
HXDLIN(  78)															int this45 = ((maskPixel1 >> 16) & 255);
HXDLIN(  78)															if ((this45 == 0)) {
HXDLIN(  78)																m11 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																m11 = (( (Float)(this45) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float m21;
HXDLIN(  78)															int this46 = ((maskPixel1 >> 8) & 255);
HXDLIN(  78)															if ((this46 == 0)) {
HXDLIN(  78)																m21 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																m21 = (( (Float)(this46) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float m31;
HXDLIN(  78)															int this47 = (maskPixel1 & 255);
HXDLIN(  78)															if ((this47 == 0)) {
HXDLIN(  78)																m31 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																m31 = (( (Float)(this47) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this43 >> 24) & 255)) )));
HXDLIN(  78)															int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this43 >> 16) & 255)) )));
HXDLIN(  78)															int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this43 >> 8) & 255)) )));
HXDLIN(  78)															int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this43 & 255)) )));
HXDLIN(  78)															col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  78)													if ((col1 != 0)) {
HXDLIN(  78)														int x6 = (dx1 - rectLeft1);
HXDLIN(  78)														int y6 = (dy1 - rectTop1);
HXDLIN(  78)														int c7 = col1;
HXDLIN(  78)														bool _hx_tmp9;
HXDLIN(  78)														if ((((c7 >> 24) & 255) < 254)) {
HXDLIN(  78)															_hx_tmp9 = undoImage3->transparent;
            														}
            														else {
HXDLIN(  78)															_hx_tmp9 = false;
            														}
HXDLIN(  78)														if (_hx_tmp9) {
HXDLIN(  78)															int location2;
HXDLIN(  78)															if (undoImage3->useVirtualPos) {
HXDLIN(  78)																location2 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            															}
            															else {
HXDLIN(  78)																location2 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            															}
HXDLIN(  78)															int this48 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN(  78)															int this49;
HXDLIN(  78)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																this49 = ((((((this48 >> 24) & 255) << 24) | ((this48 & 255) << 16)) | (((this48 >> 8) & 255) << 8)) | ((this48 >> 16) & 255));
            															}
            															else {
HXDLIN(  78)																this49 = this48;
            															}
HXDLIN(  78)															Float a12;
HXDLIN(  78)															int this50 = ((this49 >> 24) & 255);
HXDLIN(  78)															if ((this50 == 0)) {
HXDLIN(  78)																a12 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																a12 = (( (Float)(this50) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float r12;
HXDLIN(  78)															int this51 = ((this49 >> 16) & 255);
HXDLIN(  78)															if ((this51 == 0)) {
HXDLIN(  78)																r12 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																r12 = (( (Float)(this51) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float g12;
HXDLIN(  78)															int this52 = ((this49 >> 8) & 255);
HXDLIN(  78)															if ((this52 == 0)) {
HXDLIN(  78)																g12 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																g12 = (( (Float)(this52) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float b13;
HXDLIN(  78)															int this53 = (this49 & 255);
HXDLIN(  78)															if ((this53 == 0)) {
HXDLIN(  78)																b13 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																b13 = (( (Float)(this53) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float a22;
HXDLIN(  78)															int this54 = ((col1 >> 24) & 255);
HXDLIN(  78)															if ((this54 == 0)) {
HXDLIN(  78)																a22 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																a22 = (( (Float)(this54) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float r22;
HXDLIN(  78)															int this55 = ((col1 >> 16) & 255);
HXDLIN(  78)															if ((this55 == 0)) {
HXDLIN(  78)																r22 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																r22 = (( (Float)(this55) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float g22;
HXDLIN(  78)															int this56 = ((col1 >> 8) & 255);
HXDLIN(  78)															if ((this56 == 0)) {
HXDLIN(  78)																g22 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																g22 = (( (Float)(this56) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float b23;
HXDLIN(  78)															int this57 = (col1 & 255);
HXDLIN(  78)															if ((this57 == 0)) {
HXDLIN(  78)																b23 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																b23 = (( (Float)(this57) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  78)															int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  78)															int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  78)															int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  78)															int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  78)															int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN(  78)															{
HXDLIN(  78)																int _hx_tmp10;
HXDLIN(  78)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																	_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																}
            																else {
HXDLIN(  78)																	_hx_tmp10 = blended2;
            																}
HXDLIN(  78)																::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            															}
            														}
            														else {
HXDLIN(  78)															::Dynamic this58 = undoImage3->image;
HXDLIN(  78)															int index8;
HXDLIN(  78)															if (undoImage3->useVirtualPos) {
HXDLIN(  78)																index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            															}
            															else {
HXDLIN(  78)																index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            															}
HXDLIN(  78)															int _hx_tmp11;
HXDLIN(  78)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																_hx_tmp11 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            															}
            															else {
HXDLIN(  78)																_hx_tmp11 = c7;
            															}
HXDLIN(  78)															::iterMagic::Iimg_obj::set(this58,index8,_hx_tmp11);
            														}
            													}
            													else {
HXDLIN(  78)														if (forceClear1) {
HXDLIN(  78)															::Dynamic this59 = undoImage3->image;
HXDLIN(  78)															int x7 = (dx1 - rectLeft1);
HXDLIN(  78)															int y7 = (dy1 - rectTop1);
HXDLIN(  78)															int index9;
HXDLIN(  78)															if (undoImage3->useVirtualPos) {
HXDLIN(  78)																index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x7) - undoImage3->virtualX));
            															}
            															else {
HXDLIN(  78)																index9 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage3->width) + x7)) ));
            															}
HXDLIN(  78)															::iterMagic::Iimg_obj::set(this59,index9,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  78)							bool foundY1 = false;
HXDLIN(  78)							Float s1 = ((Float)0.);
HXDLIN(  78)							Float t1 = ((Float)0.);
HXDLIN(  78)							Float sxx1 = ((Float)0.);
HXDLIN(  78)							Float txx1 = ((Float)0.);
HXDLIN(  78)							{
HXDLIN(  78)								int _g_min2 = xIter31->start;
HXDLIN(  78)								int _g_max2 = xIter31->max;
HXDLIN(  78)								while((_g_min2 < _g_max2)){
HXDLIN(  78)									_g_min2 = (_g_min2 + 1);
HXDLIN(  78)									int x8 = (_g_min2 - 1);
HXLINE( 222)									sxx1 = (sx1 * ( (Float)(x8) ));
HXLINE( 223)									txx1 = (tx1 * ( (Float)(x8) ));
HXLINE( 224)									foundY1 = false;
HXLINE(  78)									{
HXDLIN(  78)										int _g_min3 = yIter31->start;
HXDLIN(  78)										int _g_max3 = yIter31->max;
HXDLIN(  78)										while((_g_min3 < _g_max3)){
HXDLIN(  78)											_g_min3 = (_g_min3 + 1);
HXDLIN(  78)											int y8 = (_g_min3 - 1);
HXLINE( 226)											s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y8) )));
HXLINE( 227)											t1 = ((t01 + txx1) + (ty1 * ( (Float)(y8) )));
HXLINE(  78)											bool _hx_tmp12;
HXDLIN(  78)											if (!((s1 <= 0))) {
HXDLIN(  78)												_hx_tmp12 = (t1 <= 0);
            											}
            											else {
HXDLIN(  78)												_hx_tmp12 = true;
            											}
HXDLIN(  78)											if (_hx_tmp12) {
HXDLIN(  78)												if (foundY1) {
HXDLIN(  78)													goto _hx_goto_126;
            												}
            											}
            											else {
HXDLIN(  78)												if (((s1 + t1) < A1)) {
HXDLIN(  78)													int x9 = ::hx::Mod(x8,tileImage->width);
HXDLIN(  78)													int y9 = ::hx::Mod(y8,tileImage->height);
HXDLIN(  78)													::Dynamic this60 = tileImage->image;
HXDLIN(  78)													int index10;
HXDLIN(  78)													if (tileImage->useVirtualPos) {
HXDLIN(  78)														index10 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x9) - tileImage->virtualX));
            													}
            													else {
HXDLIN(  78)														index10 = ::Std_obj::_hx_int(( (Float)(((y9 * tileImage->width) + x9)) ));
            													}
HXDLIN(  78)													int c8 = ::iterMagic::Iimg_obj::get(this60,index10);
HXDLIN(  78)													int color1;
HXDLIN(  78)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)														color1 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            													}
            													else {
HXDLIN(  78)														color1 = c8;
            													}
HXDLIN(  78)													{
HXDLIN(  78)														int c9 = color1;
HXDLIN(  78)														bool _hx_tmp13;
HXDLIN(  78)														if ((((c9 >> 24) & 255) < 254)) {
HXDLIN(  78)															_hx_tmp13 = this37->transparent;
            														}
            														else {
HXDLIN(  78)															_hx_tmp13 = false;
            														}
HXDLIN(  78)														if (_hx_tmp13) {
HXDLIN(  78)															int location3;
HXDLIN(  78)															if (this37->useVirtualPos) {
HXDLIN(  78)																location3 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - this37->virtualY) * ( (Float)(this37->width) )) + x8) - this37->virtualX));
            															}
            															else {
HXDLIN(  78)																location3 = ::Std_obj::_hx_int(( (Float)(((y8 * this37->width) + x8)) ));
            															}
HXDLIN(  78)															int this61 = ::iterMagic::Iimg_obj::get(this37->image,location3);
HXDLIN(  78)															int this62;
HXDLIN(  78)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																this62 = ((((((this61 >> 24) & 255) << 24) | ((this61 & 255) << 16)) | (((this61 >> 8) & 255) << 8)) | ((this61 >> 16) & 255));
            															}
            															else {
HXDLIN(  78)																this62 = this61;
            															}
HXDLIN(  78)															Float a13;
HXDLIN(  78)															int this63 = ((this62 >> 24) & 255);
HXDLIN(  78)															if ((this63 == 0)) {
HXDLIN(  78)																a13 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																a13 = (( (Float)(this63) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float r13;
HXDLIN(  78)															int this64 = ((this62 >> 16) & 255);
HXDLIN(  78)															if ((this64 == 0)) {
HXDLIN(  78)																r13 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																r13 = (( (Float)(this64) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float g13;
HXDLIN(  78)															int this65 = ((this62 >> 8) & 255);
HXDLIN(  78)															if ((this65 == 0)) {
HXDLIN(  78)																g13 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																g13 = (( (Float)(this65) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float b14;
HXDLIN(  78)															int this66 = (this62 & 255);
HXDLIN(  78)															if ((this66 == 0)) {
HXDLIN(  78)																b14 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																b14 = (( (Float)(this66) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float a23;
HXDLIN(  78)															int this67 = ((color1 >> 24) & 255);
HXDLIN(  78)															if ((this67 == 0)) {
HXDLIN(  78)																a23 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																a23 = (( (Float)(this67) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float r23;
HXDLIN(  78)															int this68 = ((color1 >> 16) & 255);
HXDLIN(  78)															if ((this68 == 0)) {
HXDLIN(  78)																r23 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																r23 = (( (Float)(this68) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float g23;
HXDLIN(  78)															int this69 = ((color1 >> 8) & 255);
HXDLIN(  78)															if ((this69 == 0)) {
HXDLIN(  78)																g23 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																g23 = (( (Float)(this69) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float b24;
HXDLIN(  78)															int this70 = (color1 & 255);
HXDLIN(  78)															if ((this70 == 0)) {
HXDLIN(  78)																b24 = ((Float)0.);
            															}
            															else {
HXDLIN(  78)																b24 = (( (Float)(this70) ) / ( (Float)(255) ));
            															}
HXDLIN(  78)															Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  78)															int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  78)															int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  78)															int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN(  78)															int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  78)															int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN(  78)															{
HXDLIN(  78)																int _hx_tmp14;
HXDLIN(  78)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																	_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																}
            																else {
HXDLIN(  78)																	_hx_tmp14 = blended3;
            																}
HXDLIN(  78)																::iterMagic::Iimg_obj::set(this37->image,location3,_hx_tmp14);
            															}
            														}
            														else {
HXDLIN(  78)															::Dynamic this71 = this37->image;
HXDLIN(  78)															int index11;
HXDLIN(  78)															if (this37->useVirtualPos) {
HXDLIN(  78)																index11 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - this37->virtualY) * ( (Float)(this37->width) )) + x8) - this37->virtualX));
            															}
            															else {
HXDLIN(  78)																index11 = ::Std_obj::_hx_int(( (Float)(((y8 * this37->width) + x8)) ));
            															}
HXDLIN(  78)															int _hx_tmp15;
HXDLIN(  78)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  78)																_hx_tmp15 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            															}
            															else {
HXDLIN(  78)																_hx_tmp15 = c9;
            															}
HXDLIN(  78)															::iterMagic::Iimg_obj::set(this71,index11,_hx_tmp15);
            														}
            													}
HXLINE( 236)													foundY1 = true;
            												}
            												else {
HXDLIN(  78)													if (foundY1) {
HXDLIN(  78)														goto _hx_goto_126;
            													}
            												}
            											}
            										}
            										_hx_goto_126:;
            									}
            								}
            							}
HXDLIN(  78)							if ((hasHit1 == false)) {
HXDLIN(  78)								 ::pi_xy::algo::HitTri v6 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN(  78)								if (hasUndo1) {
HXDLIN(  78)									v6->undoImage = undoImage3;
HXDLIN(  78)									v6->undoX = xIter31->start;
HXDLIN(  78)									v6->undoY = yIter31->start;
            								}
            							}
            						}
            					}
            				}
HXLINE( 177)				lastX = nextX1;
HXLINE( 178)				lastY = nextY1;
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(TileShape_Impl__obj,PolyBuild,(void))

void TileShape_Impl__obj::quadrant( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float rx,Float ry,Float startAngle, ::pi_xy::ImageStruct tileImage, ::Dynamic phi, ::Dynamic __o_targetError){
            		 ::Dynamic targetError = __o_targetError;
            		if (::hx::IsNull(__o_targetError)) targetError = ((Float)1.05);
            	HX_GC_STACKFRAME(&_hx_pos_6e4d7718bf84d356_95_quadrant)
HXDLIN(  95)		 ::Dynamic targetError1 = targetError;
HXLINE( 101)		if (::hx::IsNull( targetError1 )) {
HXLINE( 101)			targetError1 = ((Float)1.05);
            		}
HXLINE(  95)		Float rSmall;
HXDLIN(  95)		if ((rx > ry)) {
HXDLIN(  95)			rSmall = ry;
            		}
            		else {
HXDLIN(  95)			rSmall = rx;
            		}
HXDLIN(  95)		 ::Dynamic targetE = ( (Float)(targetError1) );
HXDLIN(  95)		if (::hx::IsNull( targetE )) {
HXLINE(  20)			targetE = ((Float)1.05);
            		}
HXLINE(  95)		int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN(  95)		int noSides;
HXDLIN(  95)		if ((result < 12)) {
HXDLIN(  95)			noSides = 12;
            		}
            		else {
HXDLIN(  95)			if ((result > 500)) {
HXDLIN(  95)				noSides = 500;
            			}
            			else {
HXDLIN(  95)				noSides = result;
            			}
            		}
HXDLIN(  95)		int sides = (::Math_obj::ceil((( (Float)(noSides) ) / ( (Float)(4) ))) * 4);
HXDLIN(  95)		Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides) ));
HXDLIN(  95)		Float omega = startAngle;
HXDLIN(  95)		int quarter = ::Std_obj::_hx_int((( (Float)(sides) ) / ( (Float)(4) )));
HXDLIN(  95)		Float lastX = ((Float)0.);
HXDLIN(  95)		Float lastY = ((Float)0.);
HXDLIN(  95)		if (::hx::IsNotEq( phi,0 )) {
HXLINE(  70)			lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) )))) + cx);
HXLINE(  71)			lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) )))) + cy);
            		}
            		else {
HXLINE(  73)			lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))));
HXLINE(  74)			lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))));
            		}
HXLINE(  95)		if (::hx::IsNotEq( phi,0 )) {
HXDLIN(  95)			Float cphi = ::Math_obj::cos(( (Float)(phi) ));
HXDLIN(  95)			Float sphi = ::Math_obj::sin(( (Float)(phi) ));
HXDLIN(  95)			{
HXDLIN(  95)				int _g = 0;
HXDLIN(  95)				int _g1 = (quarter + 1);
HXDLIN(  95)				while((_g < _g1)){
HXDLIN(  95)					_g = (_g + 1);
HXDLIN(  95)					int i = (_g - 1);
HXDLIN(  95)					Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega));
HXDLIN(  95)					Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega));
HXDLIN(  95)					Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXDLIN(  95)					Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXDLIN(  95)					{
HXDLIN(  95)						 ::pi_xy::ImageStruct this2 = this1;
HXDLIN(  95)						bool hasHit = false;
HXDLIN(  95)						{
HXDLIN(  95)							Float bx = lastX;
HXDLIN(  95)							Float by = lastY;
HXDLIN(  95)							Float cx1 = nextX;
HXDLIN(  95)							Float cy1 = nextY;
HXDLIN(  95)							bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN(  95)							if (!(adjustWinding)) {
HXDLIN(  95)								Float bx_ = bx;
HXDLIN(  95)								Float by_ = by;
HXLINE( 187)								bx = cx1;
HXLINE( 188)								by = cy1;
HXLINE( 189)								cx1 = bx_;
HXLINE( 190)								cy1 = by_;
            							}
HXLINE(  95)							{
HXDLIN(  95)								bool hasUndo = false;
HXDLIN(  95)								Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN(  95)								Float sx = (cy1 - cy);
HXDLIN(  95)								Float sy = (cx - cx1);
HXDLIN(  95)								Float t0 = ((cx * by) - (cy * bx));
HXDLIN(  95)								Float tx = (cy - by);
HXDLIN(  95)								Float ty = (bx - cx);
HXDLIN(  95)								Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN(  95)								 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  95)								if ((cx > bx)) {
HXDLIN(  95)									if ((cx > cx1)) {
HXDLIN(  95)										int min;
HXDLIN(  95)										if ((bx > cx1)) {
HXDLIN(  95)											min = ::Math_obj::floor(cx1);
            										}
            										else {
HXDLIN(  95)											min = ::Math_obj::floor(bx);
            										}
HXDLIN(  95)										int ii_min = min;
HXDLIN(  95)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  95)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            									}
            									else {
HXDLIN(  95)										int ii_min1 = ::Math_obj::floor(bx);
HXDLIN(  95)										int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN(  95)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            									}
            								}
            								else {
HXDLIN(  95)									if ((bx > cx1)) {
HXDLIN(  95)										int min1;
HXDLIN(  95)										if ((cx > cx1)) {
HXDLIN(  95)											min1 = ::Math_obj::floor(cx1);
            										}
            										else {
HXDLIN(  95)											min1 = ::Math_obj::ceil(cx);
            										}
HXDLIN(  95)										int ii_min2 = min1;
HXDLIN(  95)										int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN(  95)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            									}
            									else {
HXDLIN(  95)										int ii_min3 = ::Math_obj::floor(cx);
HXDLIN(  95)										int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN(  95)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            									}
            								}
HXDLIN(  95)								 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  95)								if ((cy > by)) {
HXDLIN(  95)									if ((cy > cy1)) {
HXDLIN(  95)										int min2;
HXDLIN(  95)										if ((by > cy1)) {
HXDLIN(  95)											min2 = ::Math_obj::floor(cy1);
            										}
            										else {
HXDLIN(  95)											min2 = ::Math_obj::floor(by);
            										}
HXDLIN(  95)										int ii_min4 = min2;
HXDLIN(  95)										int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN(  95)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            									}
            									else {
HXDLIN(  95)										int ii_min5 = ::Math_obj::floor(by);
HXDLIN(  95)										int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN(  95)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            									}
            								}
            								else {
HXDLIN(  95)									if ((by > cy1)) {
HXDLIN(  95)										int min3;
HXDLIN(  95)										if ((cy > cy1)) {
HXDLIN(  95)											min3 = ::Math_obj::floor(cy1);
            										}
            										else {
HXDLIN(  95)											min3 = ::Math_obj::ceil(cy);
            										}
HXDLIN(  95)										int ii_min6 = min3;
HXDLIN(  95)										int ii_max6 = ::Math_obj::ceil(by);
HXDLIN(  95)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            									}
            									else {
HXDLIN(  95)										int ii_min7 = ::Math_obj::floor(cy);
HXDLIN(  95)										int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN(  95)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            									}
            								}
HXDLIN(  95)								 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  95)								if (hasUndo) {
HXDLIN(  95)									int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  95)									int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  95)									 ::Dynamic imageType = null();
HXDLIN(  95)									 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  95)									if (::hx::IsNull( imageType )) {
HXLINE(  54)										imageType = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE(  95)									::Dynamic undoImage1;
HXDLIN(  95)									switch((int)(( (int)(imageType) ))){
            										case (int)0: {
HXDLIN(  95)											 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  95)											 ::iterMagic::BytesImg b = byt;
HXDLIN(  95)											{
HXDLIN(  95)												b->width = width;
HXDLIN(  95)												b->height = height;
HXDLIN(  95)												b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  95)												b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  95)												{
HXDLIN(  95)													int len = b->length;
HXDLIN(  95)													int w = 0;
HXDLIN(  95)													{
HXDLIN(  95)														int _g2 = 0;
HXDLIN(  95)														int _g3 = b->height;
HXDLIN(  95)														while((_g2 < _g3)){
HXDLIN(  95)															_g2 = (_g2 + 1);
HXDLIN(  95)															int y = (_g2 - 1);
HXDLIN(  95)															{
HXDLIN(  95)																int _g4 = 0;
HXDLIN(  95)																int _g5 = b->width;
HXDLIN(  95)																while((_g4 < _g5)){
HXDLIN(  95)																	_g4 = (_g4 + 1);
HXDLIN(  95)																	int x = (_g4 - 1);
HXDLIN(  95)																	{
HXDLIN(  95)																		w = (w + 1);
HXDLIN(  95)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  95)																	{
HXDLIN(  95)																		w = (w + 1);
HXDLIN(  95)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  95)																	{
HXDLIN(  95)																		w = (w + 1);
HXDLIN(  95)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  95)																	{
HXDLIN(  95)																		w = (w + 1);
HXDLIN(  95)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  95)											undoImage1 = b;
            										}
            										break;
            										case (int)1: {
HXDLIN(  95)											 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  95)											 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  95)											{
HXDLIN(  95)												a->width = width;
HXDLIN(  95)												a->height = height;
HXDLIN(  95)												a->data = ::Array_obj< int >::__new(0);
HXDLIN(  95)												a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  95)												{
HXDLIN(  95)													int _g6 = 0;
HXDLIN(  95)													int _g7 = a->length;
HXDLIN(  95)													while((_g6 < _g7)){
HXDLIN(  95)														_g6 = (_g6 + 1);
HXDLIN(  95)														int i1 = (_g6 - 1);
HXDLIN(  95)														a->data[i1] = 0;
            													}
            												}
            											}
HXDLIN(  95)											undoImage1 = a;
            										}
            										break;
            										case (int)2: {
HXDLIN(  95)											 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  95)											 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  95)											{
HXDLIN(  95)												b1->width = width;
HXDLIN(  95)												b1->height = height;
HXDLIN(  95)												b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  95)												int size = (b1->length * 4);
HXDLIN(  95)												b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  95)												{
HXDLIN(  95)													int _g8 = 0;
HXDLIN(  95)													int _g9 = b1->length;
HXDLIN(  95)													while((_g8 < _g9)){
HXDLIN(  95)														_g8 = (_g8 + 1);
HXDLIN(  95)														int i2 = (_g8 - 1);
HXDLIN(  95)														{
HXDLIN(  95)															 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN(  95)															bool undoImage2;
HXDLIN(  95)															if ((i2 >= 0)) {
HXDLIN(  95)																undoImage2 = (i2 < (this4->byteLength >> 2));
            															}
            															else {
HXDLIN(  95)																undoImage2 = false;
            															}
HXDLIN(  95)															if (undoImage2) {
HXDLIN(  95)																 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN(  95)																int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN(  95)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  95)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  95)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  95)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN(  95)											undoImage1 = b1;
            										}
            										break;
            										case (int)3: {
HXDLIN(  95)											 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  95)											 ::iterMagic::VecIntImg v = vec;
HXDLIN(  95)											{
HXDLIN(  95)												v->width = width;
HXDLIN(  95)												v->height = height;
HXDLIN(  95)												v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  95)												v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  95)												{
HXDLIN(  95)													int _g10 = 0;
HXDLIN(  95)													int _g11 = v->length;
HXDLIN(  95)													while((_g10 < _g11)){
HXDLIN(  95)														_g10 = (_g10 + 1);
HXDLIN(  95)														int i3 = (_g10 - 1);
HXDLIN(  95)														v->data->__unsafe_set(i3,0);
            													}
            												}
            											}
HXDLIN(  95)											undoImage1 = v;
            										}
            										break;
            										case (int)4: {
HXDLIN(  95)											 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  95)											 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  95)											{
HXDLIN(  95)												b2->width = width;
HXDLIN(  95)												b2->height = height;
HXDLIN(  95)												b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  95)												b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  95)												{
HXDLIN(  95)													int len1 = b2->length;
HXDLIN(  95)													 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  95)													if (::hx::IsNull( d->head )) {
HXDLIN(  95)														int _g12 = 0;
HXDLIN(  95)														int _g13 = len1;
HXDLIN(  95)														while((_g12 < _g13)){
HXDLIN(  95)															_g12 = (_g12 + 1);
HXDLIN(  95)															int i4 = (_g12 - 1);
HXDLIN(  95)															d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            														}
            													}
            													else {
HXDLIN(  95)														int _g14 = 0;
HXDLIN(  95)														int _g15 = len1;
HXDLIN(  95)														while((_g14 < _g15)){
HXDLIN(  95)															_g14 = (_g14 + 1);
HXDLIN(  95)															int i5 = (_g14 - 1);
HXDLIN(  95)															{
HXDLIN(  95)																 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  95)																 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  95)																{
HXDLIN(  95)																	int _g16 = 0;
HXDLIN(  95)																	int _g17 = i5;
HXDLIN(  95)																	while((_g16 < _g17)){
HXDLIN(  95)																		_g16 = (_g16 + 1);
HXDLIN(  95)																		int i6 = (_g16 - 1);
HXLINE( 345)																		prev = l;
HXLINE( 346)																		l = l->next;
            																	}
            																}
HXLINE(  95)																if (::hx::IsNull( prev )) {
HXDLIN(  95)																	b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  95)																	l = null();
            																}
            																else {
HXDLIN(  95)																	prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  95)																	l = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  95)											undoImage1 = b2;
            										}
            										break;
            									}
HXDLIN(  95)									this3->image = undoImage1;
HXDLIN(  95)									this3->width = width;
HXDLIN(  95)									this3->height = height;
HXDLIN(  95)									this3->imageType = ( (int)(imageType) );
HXDLIN(  95)									undoImage = this3;
HXDLIN(  95)									{
HXDLIN(  95)										int rectLeft = xIter3->start;
HXDLIN(  95)										int rectTop = yIter3->start;
HXDLIN(  95)										int rectRight = xIter3->max;
HXDLIN(  95)										bool forceClear = false;
HXDLIN(  95)										{
HXDLIN(  95)											int _g18 = rectTop;
HXDLIN(  95)											int _g19 = yIter3->max;
HXDLIN(  95)											while((_g18 < _g19)){
HXDLIN(  95)												_g18 = (_g18 + 1);
HXDLIN(  95)												int dy = (_g18 - 1);
HXDLIN(  95)												{
HXDLIN(  95)													int _g20 = rectLeft;
HXDLIN(  95)													int _g21 = rectRight;
HXDLIN(  95)													while((_g20 < _g21)){
HXDLIN(  95)														_g20 = (_g20 + 1);
HXDLIN(  95)														int dx = (_g20 - 1);
HXDLIN(  95)														::Dynamic this5 = this2->image;
HXDLIN(  95)														int index;
HXDLIN(  95)														if (this2->useVirtualPos) {
HXDLIN(  95)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            														}
            														else {
HXDLIN(  95)															index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            														}
HXDLIN(  95)														int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN(  95)														int col;
HXDLIN(  95)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  95)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXDLIN(  95)															col = c;
            														}
HXDLIN(  95)														bool _hx_tmp;
HXDLIN(  95)														if (this2->useMask) {
HXDLIN(  95)															_hx_tmp = ::hx::IsNotNull( this2->mask );
            														}
            														else {
HXDLIN(  95)															_hx_tmp = false;
            														}
HXDLIN(  95)														if (_hx_tmp) {
HXDLIN(  95)															 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN(  95)															::Dynamic this7 = this6->image;
HXDLIN(  95)															int index1;
HXDLIN(  95)															if (this6->useVirtualPos) {
HXDLIN(  95)																index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            															}
            															else {
HXDLIN(  95)																index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            															}
HXDLIN(  95)															int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN(  95)															int v1;
HXDLIN(  95)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  95)																v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            															}
            															else {
HXDLIN(  95)																v1 = c1;
            															}
HXDLIN(  95)															int maskPixel = v1;
HXDLIN(  95)															int this8 = col;
HXDLIN(  95)															if ((maskPixel == 0)) {
HXDLIN(  95)																col = this8;
            															}
            															else {
HXDLIN(  95)																Float m0;
HXDLIN(  95)																int this9 = ((maskPixel >> 24) & 255);
HXDLIN(  95)																if ((this9 == 0)) {
HXDLIN(  95)																	m0 = ((Float)0.);
            																}
            																else {
HXDLIN(  95)																	m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  95)																Float m1;
HXDLIN(  95)																int this10 = ((maskPixel >> 16) & 255);
HXDLIN(  95)																if ((this10 == 0)) {
HXDLIN(  95)																	m1 = ((Float)0.);
            																}
            																else {
HXDLIN(  95)																	m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  95)																Float m2;
HXDLIN(  95)																int this11 = ((maskPixel >> 8) & 255);
HXDLIN(  95)																if ((this11 == 0)) {
HXDLIN(  95)																	m2 = ((Float)0.);
            																}
            																else {
HXDLIN(  95)																	m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  95)																Float m3;
HXDLIN(  95)																int this12 = (maskPixel & 255);
HXDLIN(  95)																if ((this12 == 0)) {
HXDLIN(  95)																	m3 = ((Float)0.);
            																}
            																else {
HXDLIN(  95)																	m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN(  95)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN(  95)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN(  95)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN(  95)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN(  95)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  95)														if ((col != 0)) {
HXDLIN(  95)															int x1 = (dx - rectLeft);
HXDLIN(  95)															int y1 = (dy - rectTop);
HXDLIN(  95)															int c2 = col;
HXDLIN(  95)															bool _hx_tmp1;
HXDLIN(  95)															if ((((c2 >> 24) & 255) < 254)) {
HXDLIN(  95)																_hx_tmp1 = undoImage->transparent;
            															}
            															else {
HXDLIN(  95)																_hx_tmp1 = false;
            															}
HXDLIN(  95)															if (_hx_tmp1) {
HXDLIN(  95)																int location;
HXDLIN(  95)																if (undoImage->useVirtualPos) {
HXDLIN(  95)																	location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXDLIN(  95)																	location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN(  95)																int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN(  95)																int this14;
HXDLIN(  95)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  95)																	this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																}
            																else {
HXDLIN(  95)																	this14 = this13;
            																}
HXDLIN(  95)																Float a1;
HXDLIN(  95)																int this15 = ((this14 >> 24) & 255);
HXDLIN(  95)																if ((this15 == 0)) {
HXDLIN(  95)																	a1 = ((Float)0.);
            																}
            																else {
HXDLIN(  95)																	a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																}
HXDLIN(  95)																Float r1;
HXDLIN(  95)																int this16 = ((this14 >> 16) & 255);
HXDLIN(  95)																if ((this16 == 0)) {
HXDLIN(  95)																	r1 = ((Float)0.);
            																}
            																else {
HXDLIN(  95)																	r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																}
HXDLIN(  95)																Float g1;
HXDLIN(  95)																int this17 = ((this14 >> 8) & 255);
HXDLIN(  95)																if ((this17 == 0)) {
HXDLIN(  95)																	g1 = ((Float)0.);
            																}
            																else {
HXDLIN(  95)																	g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																}
HXDLIN(  95)																Float b11;
HXDLIN(  95)																int this18 = (this14 & 255);
HXDLIN(  95)																if ((this18 == 0)) {
HXDLIN(  95)																	b11 = ((Float)0.);
            																}
            																else {
HXDLIN(  95)																	b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																}
HXDLIN(  95)																Float a2;
HXDLIN(  95)																int this19 = ((col >> 24) & 255);
HXDLIN(  95)																if ((this19 == 0)) {
HXDLIN(  95)																	a2 = ((Float)0.);
            																}
            																else {
HXDLIN(  95)																	a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																}
HXDLIN(  95)																Float r2;
HXDLIN(  95)																int this20 = ((col >> 16) & 255);
HXDLIN(  95)																if ((this20 == 0)) {
HXDLIN(  95)																	r2 = ((Float)0.);
            																}
            																else {
HXDLIN(  95)																	r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																}
HXDLIN(  95)																Float g2;
HXDLIN(  95)																int this21 = ((col >> 8) & 255);
HXDLIN(  95)																if ((this21 == 0)) {
HXDLIN(  95)																	g2 = ((Float)0.);
            																}
            																else {
HXDLIN(  95)																	g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																}
HXDLIN(  95)																Float b21;
HXDLIN(  95)																int this22 = (col & 255);
HXDLIN(  95)																if ((this22 == 0)) {
HXDLIN(  95)																	b21 = ((Float)0.);
            																}
            																else {
HXDLIN(  95)																	b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																}
HXDLIN(  95)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  95)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  95)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  95)																int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  95)																int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  95)																int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  95)																{
HXDLIN(  95)																	int _hx_tmp2;
HXDLIN(  95)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  95)																		_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXDLIN(  95)																		_hx_tmp2 = blended;
            																	}
HXDLIN(  95)																	::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																}
            															}
            															else {
HXDLIN(  95)																::Dynamic this23 = undoImage->image;
HXDLIN(  95)																int index2;
HXDLIN(  95)																if (undoImage->useVirtualPos) {
HXDLIN(  95)																	index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXDLIN(  95)																	index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN(  95)																int _hx_tmp3;
HXDLIN(  95)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  95)																	_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																}
            																else {
HXDLIN(  95)																	_hx_tmp3 = c2;
            																}
HXDLIN(  95)																::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            															}
            														}
            														else {
HXDLIN(  95)															if (forceClear) {
HXDLIN(  95)																::Dynamic this24 = undoImage->image;
HXDLIN(  95)																int x2 = (dx - rectLeft);
HXDLIN(  95)																int y2 = (dy - rectTop);
HXDLIN(  95)																int index3;
HXDLIN(  95)																if (undoImage->useVirtualPos) {
HXDLIN(  95)																	index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																}
            																else {
HXDLIN(  95)																	index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																}
HXDLIN(  95)																::iterMagic::Iimg_obj::set(this24,index3,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  95)								bool foundY = false;
HXDLIN(  95)								Float s = ((Float)0.);
HXDLIN(  95)								Float t = ((Float)0.);
HXDLIN(  95)								Float sxx = ((Float)0.);
HXDLIN(  95)								Float txx = ((Float)0.);
HXDLIN(  95)								{
HXDLIN(  95)									int _g_min = xIter3->start;
HXDLIN(  95)									int _g_max = xIter3->max;
HXDLIN(  95)									while((_g_min < _g_max)){
HXDLIN(  95)										_g_min = (_g_min + 1);
HXDLIN(  95)										int x3 = (_g_min - 1);
HXLINE( 222)										sxx = (sx * ( (Float)(x3) ));
HXLINE( 223)										txx = (tx * ( (Float)(x3) ));
HXLINE( 224)										foundY = false;
HXLINE(  95)										{
HXDLIN(  95)											int _g_min1 = yIter3->start;
HXDLIN(  95)											int _g_max1 = yIter3->max;
HXDLIN(  95)											while((_g_min1 < _g_max1)){
HXDLIN(  95)												_g_min1 = (_g_min1 + 1);
HXDLIN(  95)												int y3 = (_g_min1 - 1);
HXLINE( 226)												s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE( 227)												t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE(  95)												bool _hx_tmp4;
HXDLIN(  95)												if (!((s <= 0))) {
HXDLIN(  95)													_hx_tmp4 = (t <= 0);
            												}
            												else {
HXDLIN(  95)													_hx_tmp4 = true;
            												}
HXDLIN(  95)												if (_hx_tmp4) {
HXDLIN(  95)													if (foundY) {
HXDLIN(  95)														goto _hx_goto_140;
            													}
            												}
            												else {
HXDLIN(  95)													if (((s + t) < A)) {
HXDLIN(  95)														int x4 = ::hx::Mod(x3,tileImage->width);
HXDLIN(  95)														int y4 = ::hx::Mod(y3,tileImage->height);
HXDLIN(  95)														::Dynamic this25 = tileImage->image;
HXDLIN(  95)														int index4;
HXDLIN(  95)														if (tileImage->useVirtualPos) {
HXDLIN(  95)															index4 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x4) - tileImage->virtualX));
            														}
            														else {
HXDLIN(  95)															index4 = ::Std_obj::_hx_int(( (Float)(((y4 * tileImage->width) + x4)) ));
            														}
HXDLIN(  95)														int c3 = ::iterMagic::Iimg_obj::get(this25,index4);
HXDLIN(  95)														int color;
HXDLIN(  95)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  95)															color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            														}
            														else {
HXDLIN(  95)															color = c3;
            														}
HXDLIN(  95)														{
HXDLIN(  95)															int c4 = color;
HXDLIN(  95)															bool _hx_tmp5;
HXDLIN(  95)															if ((((c4 >> 24) & 255) < 254)) {
HXDLIN(  95)																_hx_tmp5 = this2->transparent;
            															}
            															else {
HXDLIN(  95)																_hx_tmp5 = false;
            															}
HXDLIN(  95)															if (_hx_tmp5) {
HXDLIN(  95)																int location1;
HXDLIN(  95)																if (this2->useVirtualPos) {
HXDLIN(  95)																	location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																}
            																else {
HXDLIN(  95)																	location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																}
HXDLIN(  95)																int this26 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN(  95)																int this27;
HXDLIN(  95)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  95)																	this27 = ((((((this26 >> 24) & 255) << 24) | ((this26 & 255) << 16)) | (((this26 >> 8) & 255) << 8)) | ((this26 >> 16) & 255));
            																}
            																else {
HXDLIN(  95)																	this27 = this26;
            																}
HXDLIN(  95)																Float a11;
HXDLIN(  95)																int this28 = ((this27 >> 24) & 255);
HXDLIN(  95)																if ((this28 == 0)) {
HXDLIN(  95)																	a11 = ((Float)0.);
            																}
            																else {
HXDLIN(  95)																	a11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																}
HXDLIN(  95)																Float r11;
HXDLIN(  95)																int this29 = ((this27 >> 16) & 255);
HXDLIN(  95)																if ((this29 == 0)) {
HXDLIN(  95)																	r11 = ((Float)0.);
            																}
            																else {
HXDLIN(  95)																	r11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																}
HXDLIN(  95)																Float g11;
HXDLIN(  95)																int this30 = ((this27 >> 8) & 255);
HXDLIN(  95)																if ((this30 == 0)) {
HXDLIN(  95)																	g11 = ((Float)0.);
            																}
            																else {
HXDLIN(  95)																	g11 = (( (Float)(this30) ) / ( (Float)(255) ));
            																}
HXDLIN(  95)																Float b12;
HXDLIN(  95)																int this31 = (this27 & 255);
HXDLIN(  95)																if ((this31 == 0)) {
HXDLIN(  95)																	b12 = ((Float)0.);
            																}
            																else {
HXDLIN(  95)																	b12 = (( (Float)(this31) ) / ( (Float)(255) ));
            																}
HXDLIN(  95)																Float a21;
HXDLIN(  95)																int this32 = ((color >> 24) & 255);
HXDLIN(  95)																if ((this32 == 0)) {
HXDLIN(  95)																	a21 = ((Float)0.);
            																}
            																else {
HXDLIN(  95)																	a21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																}
HXDLIN(  95)																Float r21;
HXDLIN(  95)																int this33 = ((color >> 16) & 255);
HXDLIN(  95)																if ((this33 == 0)) {
HXDLIN(  95)																	r21 = ((Float)0.);
            																}
            																else {
HXDLIN(  95)																	r21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																}
HXDLIN(  95)																Float g21;
HXDLIN(  95)																int this34 = ((color >> 8) & 255);
HXDLIN(  95)																if ((this34 == 0)) {
HXDLIN(  95)																	g21 = ((Float)0.);
            																}
            																else {
HXDLIN(  95)																	g21 = (( (Float)(this34) ) / ( (Float)(255) ));
            																}
HXDLIN(  95)																Float b22;
HXDLIN(  95)																int this35 = (color & 255);
HXDLIN(  95)																if ((this35 == 0)) {
HXDLIN(  95)																	b22 = ((Float)0.);
            																}
            																else {
HXDLIN(  95)																	b22 = (( (Float)(this35) ) / ( (Float)(255) ));
            																}
HXDLIN(  95)																Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  95)																int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  95)																int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  95)																int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  95)																int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  95)																int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  95)																{
HXDLIN(  95)																	int _hx_tmp6;
HXDLIN(  95)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  95)																		_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																	}
            																	else {
HXDLIN(  95)																		_hx_tmp6 = blended1;
            																	}
HXDLIN(  95)																	::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp6);
            																}
            															}
            															else {
HXDLIN(  95)																::Dynamic this36 = this2->image;
HXDLIN(  95)																int index5;
HXDLIN(  95)																if (this2->useVirtualPos) {
HXDLIN(  95)																	index5 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																}
            																else {
HXDLIN(  95)																	index5 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																}
HXDLIN(  95)																int _hx_tmp7;
HXDLIN(  95)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  95)																	_hx_tmp7 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            																}
            																else {
HXDLIN(  95)																	_hx_tmp7 = c4;
            																}
HXDLIN(  95)																::iterMagic::Iimg_obj::set(this36,index5,_hx_tmp7);
            															}
            														}
HXLINE( 236)														foundY = true;
            													}
            													else {
HXDLIN(  95)														if (foundY) {
HXDLIN(  95)															goto _hx_goto_140;
            														}
            													}
            												}
            											}
            											_hx_goto_140:;
            										}
            									}
            								}
HXDLIN(  95)								if ((hasHit == false)) {
HXDLIN(  95)									 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN(  95)									if (hasUndo) {
HXDLIN(  95)										v2->undoImage = undoImage;
HXDLIN(  95)										v2->undoX = xIter3->start;
HXDLIN(  95)										v2->undoY = yIter3->start;
            									}
            								}
            							}
            						}
            					}
HXLINE(  85)					lastX = nextX;
HXLINE(  86)					lastY = nextY;
            				}
            			}
            		}
            		else {
HXDLIN(  95)			int _g22 = 0;
HXDLIN(  95)			int _g23 = (quarter + 1);
HXDLIN(  95)			while((_g22 < _g23)){
HXDLIN(  95)				_g22 = (_g22 + 1);
HXDLIN(  95)				int i7 = (_g22 - 1);
HXDLIN(  95)				Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN(  95)				Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN(  95)				{
HXDLIN(  95)					 ::pi_xy::ImageStruct this37 = this1;
HXDLIN(  95)					bool hasHit1 = false;
HXDLIN(  95)					{
HXDLIN(  95)						Float bx1 = lastX;
HXDLIN(  95)						Float by1 = lastY;
HXDLIN(  95)						Float cx2 = nextX1;
HXDLIN(  95)						Float cy2 = nextY1;
HXDLIN(  95)						bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN(  95)						if (!(adjustWinding1)) {
HXDLIN(  95)							Float bx_1 = bx1;
HXDLIN(  95)							Float by_1 = by1;
HXLINE( 187)							bx1 = cx2;
HXLINE( 188)							by1 = cy2;
HXLINE( 189)							cx2 = bx_1;
HXLINE( 190)							cy2 = by_1;
            						}
HXLINE(  95)						{
HXDLIN(  95)							bool hasUndo1 = false;
HXDLIN(  95)							Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN(  95)							Float sx1 = (cy2 - cy);
HXDLIN(  95)							Float sy1 = (cx - cx2);
HXDLIN(  95)							Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN(  95)							Float tx1 = (cy - by1);
HXDLIN(  95)							Float ty1 = (bx1 - cx);
HXDLIN(  95)							Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN(  95)							 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  95)							if ((cx > bx1)) {
HXDLIN(  95)								if ((cx > cx2)) {
HXDLIN(  95)									int min4;
HXDLIN(  95)									if ((bx1 > cx2)) {
HXDLIN(  95)										min4 = ::Math_obj::floor(cx2);
            									}
            									else {
HXDLIN(  95)										min4 = ::Math_obj::floor(bx1);
            									}
HXDLIN(  95)									int ii_min8 = min4;
HXDLIN(  95)									int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN(  95)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            								}
            								else {
HXDLIN(  95)									int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN(  95)									int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN(  95)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            								}
            							}
            							else {
HXDLIN(  95)								if ((bx1 > cx2)) {
HXDLIN(  95)									int min5;
HXDLIN(  95)									if ((cx > cx2)) {
HXDLIN(  95)										min5 = ::Math_obj::floor(cx2);
            									}
            									else {
HXDLIN(  95)										min5 = ::Math_obj::ceil(cx);
            									}
HXDLIN(  95)									int ii_min10 = min5;
HXDLIN(  95)									int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN(  95)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            								}
            								else {
HXDLIN(  95)									int ii_min11 = ::Math_obj::floor(cx);
HXDLIN(  95)									int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN(  95)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            								}
            							}
HXDLIN(  95)							 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  95)							if ((cy > by1)) {
HXDLIN(  95)								if ((cy > cy2)) {
HXDLIN(  95)									int min6;
HXDLIN(  95)									if ((by1 > cy2)) {
HXDLIN(  95)										min6 = ::Math_obj::floor(cy2);
            									}
            									else {
HXDLIN(  95)										min6 = ::Math_obj::floor(by1);
            									}
HXDLIN(  95)									int ii_min12 = min6;
HXDLIN(  95)									int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN(  95)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            								}
            								else {
HXDLIN(  95)									int ii_min13 = ::Math_obj::floor(by1);
HXDLIN(  95)									int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN(  95)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            								}
            							}
            							else {
HXDLIN(  95)								if ((by1 > cy2)) {
HXDLIN(  95)									int min7;
HXDLIN(  95)									if ((cy > cy2)) {
HXDLIN(  95)										min7 = ::Math_obj::floor(cy2);
            									}
            									else {
HXDLIN(  95)										min7 = ::Math_obj::ceil(cy);
            									}
HXDLIN(  95)									int ii_min14 = min7;
HXDLIN(  95)									int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN(  95)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            								}
            								else {
HXDLIN(  95)									int ii_min15 = ::Math_obj::floor(cy);
HXDLIN(  95)									int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN(  95)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            								}
            							}
HXDLIN(  95)							 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  95)							if (hasUndo1) {
HXDLIN(  95)								int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  95)								int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  95)								 ::Dynamic imageType1 = null();
HXDLIN(  95)								 ::pi_xy::ImageStruct this38 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  95)								if (::hx::IsNull( imageType1 )) {
HXLINE(  54)									imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE(  95)								::Dynamic undoImage4;
HXDLIN(  95)								switch((int)(( (int)(imageType1) ))){
            									case (int)0: {
HXDLIN(  95)										 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  95)										 ::iterMagic::BytesImg b5 = byt1;
HXDLIN(  95)										{
HXDLIN(  95)											b5->width = width1;
HXDLIN(  95)											b5->height = height1;
HXDLIN(  95)											b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  95)											b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN(  95)											{
HXDLIN(  95)												int len2 = b5->length;
HXDLIN(  95)												int w1 = 0;
HXDLIN(  95)												{
HXDLIN(  95)													int _g24 = 0;
HXDLIN(  95)													int _g25 = b5->height;
HXDLIN(  95)													while((_g24 < _g25)){
HXDLIN(  95)														_g24 = (_g24 + 1);
HXDLIN(  95)														int y5 = (_g24 - 1);
HXDLIN(  95)														{
HXDLIN(  95)															int _g26 = 0;
HXDLIN(  95)															int _g27 = b5->width;
HXDLIN(  95)															while((_g26 < _g27)){
HXDLIN(  95)																_g26 = (_g26 + 1);
HXDLIN(  95)																int x5 = (_g26 - 1);
HXDLIN(  95)																{
HXDLIN(  95)																	w1 = (w1 + 1);
HXDLIN(  95)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  95)																{
HXDLIN(  95)																	w1 = (w1 + 1);
HXDLIN(  95)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  95)																{
HXDLIN(  95)																	w1 = (w1 + 1);
HXDLIN(  95)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  95)																{
HXDLIN(  95)																	w1 = (w1 + 1);
HXDLIN(  95)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  95)										undoImage4 = b5;
            									}
            									break;
            									case (int)1: {
HXDLIN(  95)										 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  95)										 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN(  95)										{
HXDLIN(  95)											a6->width = width1;
HXDLIN(  95)											a6->height = height1;
HXDLIN(  95)											a6->data = ::Array_obj< int >::__new(0);
HXDLIN(  95)											a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  95)											{
HXDLIN(  95)												int _g28 = 0;
HXDLIN(  95)												int _g29 = a6->length;
HXDLIN(  95)												while((_g28 < _g29)){
HXDLIN(  95)													_g28 = (_g28 + 1);
HXDLIN(  95)													int i8 = (_g28 - 1);
HXDLIN(  95)													a6->data[i8] = 0;
            												}
            											}
            										}
HXDLIN(  95)										undoImage4 = a6;
            									}
            									break;
            									case (int)2: {
HXDLIN(  95)										 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  95)										 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN(  95)										{
HXDLIN(  95)											b6->width = width1;
HXDLIN(  95)											b6->height = height1;
HXDLIN(  95)											b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  95)											int size1 = (b6->length * 4);
HXDLIN(  95)											b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  95)											{
HXDLIN(  95)												int _g30 = 0;
HXDLIN(  95)												int _g31 = b6->length;
HXDLIN(  95)												while((_g30 < _g31)){
HXDLIN(  95)													_g30 = (_g30 + 1);
HXDLIN(  95)													int i9 = (_g30 - 1);
HXDLIN(  95)													{
HXDLIN(  95)														 ::haxe::io::ArrayBufferViewImpl this39 = b6->data;
HXDLIN(  95)														bool undoImage5;
HXDLIN(  95)														if ((i9 >= 0)) {
HXDLIN(  95)															undoImage5 = (i9 < (this39->byteLength >> 2));
            														}
            														else {
HXDLIN(  95)															undoImage5 = false;
            														}
HXDLIN(  95)														if (undoImage5) {
HXDLIN(  95)															 ::haxe::io::Bytes _this1 = this39->bytes;
HXDLIN(  95)															int pos1 = ((i9 << 2) + this39->byteOffset);
HXDLIN(  95)															_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  95)															_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  95)															_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  95)															_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN(  95)										undoImage4 = b6;
            									}
            									break;
            									case (int)3: {
HXDLIN(  95)										 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  95)										 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN(  95)										{
HXDLIN(  95)											v3->width = width1;
HXDLIN(  95)											v3->height = height1;
HXDLIN(  95)											v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  95)											v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN(  95)											{
HXDLIN(  95)												int _g32 = 0;
HXDLIN(  95)												int _g33 = v3->length;
HXDLIN(  95)												while((_g32 < _g33)){
HXDLIN(  95)													_g32 = (_g32 + 1);
HXDLIN(  95)													int i10 = (_g32 - 1);
HXDLIN(  95)													v3->data->__unsafe_set(i10,0);
            												}
            											}
            										}
HXDLIN(  95)										undoImage4 = v3;
            									}
            									break;
            									case (int)4: {
HXDLIN(  95)										 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  95)										 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN(  95)										{
HXDLIN(  95)											b7->width = width1;
HXDLIN(  95)											b7->height = height1;
HXDLIN(  95)											b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  95)											b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  95)											{
HXDLIN(  95)												int len3 = b7->length;
HXDLIN(  95)												 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN(  95)												if (::hx::IsNull( d1->head )) {
HXDLIN(  95)													int _g34 = 0;
HXDLIN(  95)													int _g35 = len3;
HXDLIN(  95)													while((_g34 < _g35)){
HXDLIN(  95)														_g34 = (_g34 + 1);
HXDLIN(  95)														int i11 = (_g34 - 1);
HXDLIN(  95)														d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            													}
            												}
            												else {
HXDLIN(  95)													int _g36 = 0;
HXDLIN(  95)													int _g37 = len3;
HXDLIN(  95)													while((_g36 < _g37)){
HXDLIN(  95)														_g36 = (_g36 + 1);
HXDLIN(  95)														int i12 = (_g36 - 1);
HXDLIN(  95)														{
HXDLIN(  95)															 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN(  95)															 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  95)															{
HXDLIN(  95)																int _g38 = 0;
HXDLIN(  95)																int _g39 = i12;
HXDLIN(  95)																while((_g38 < _g39)){
HXDLIN(  95)																	_g38 = (_g38 + 1);
HXDLIN(  95)																	int i13 = (_g38 - 1);
HXLINE( 345)																	prev1 = l1;
HXLINE( 346)																	l1 = l1->next;
            																}
            															}
HXLINE(  95)															if (::hx::IsNull( prev1 )) {
HXDLIN(  95)																b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  95)																l1 = null();
            															}
            															else {
HXDLIN(  95)																prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  95)																l1 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  95)										undoImage4 = b7;
            									}
            									break;
            								}
HXDLIN(  95)								this38->image = undoImage4;
HXDLIN(  95)								this38->width = width1;
HXDLIN(  95)								this38->height = height1;
HXDLIN(  95)								this38->imageType = ( (int)(imageType1) );
HXDLIN(  95)								undoImage3 = this38;
HXDLIN(  95)								{
HXDLIN(  95)									int rectLeft1 = xIter31->start;
HXDLIN(  95)									int rectTop1 = yIter31->start;
HXDLIN(  95)									int rectRight1 = xIter31->max;
HXDLIN(  95)									bool forceClear1 = false;
HXDLIN(  95)									{
HXDLIN(  95)										int _g40 = rectTop1;
HXDLIN(  95)										int _g41 = yIter31->max;
HXDLIN(  95)										while((_g40 < _g41)){
HXDLIN(  95)											_g40 = (_g40 + 1);
HXDLIN(  95)											int dy1 = (_g40 - 1);
HXDLIN(  95)											{
HXDLIN(  95)												int _g42 = rectLeft1;
HXDLIN(  95)												int _g43 = rectRight1;
HXDLIN(  95)												while((_g42 < _g43)){
HXDLIN(  95)													_g42 = (_g42 + 1);
HXDLIN(  95)													int dx1 = (_g42 - 1);
HXDLIN(  95)													::Dynamic this40 = this37->image;
HXDLIN(  95)													int index6;
HXDLIN(  95)													if (this37->useVirtualPos) {
HXDLIN(  95)														index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this37->virtualY) * ( (Float)(this37->width) )) + dx1) - this37->virtualX));
            													}
            													else {
HXDLIN(  95)														index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this37->width) + dx1)) ));
            													}
HXDLIN(  95)													int c5 = ::iterMagic::Iimg_obj::get(this40,index6);
HXDLIN(  95)													int col1;
HXDLIN(  95)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  95)														col1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            													}
            													else {
HXDLIN(  95)														col1 = c5;
            													}
HXDLIN(  95)													bool _hx_tmp8;
HXDLIN(  95)													if (this37->useMask) {
HXDLIN(  95)														_hx_tmp8 = ::hx::IsNotNull( this37->mask );
            													}
            													else {
HXDLIN(  95)														_hx_tmp8 = false;
            													}
HXDLIN(  95)													if (_hx_tmp8) {
HXDLIN(  95)														 ::pi_xy::ImageStruct this41 = this37->mask;
HXDLIN(  95)														::Dynamic this42 = this41->image;
HXDLIN(  95)														int index7;
HXDLIN(  95)														if (this41->useVirtualPos) {
HXDLIN(  95)															index7 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this41->virtualY) * ( (Float)(this41->width) )) + dx1) - this41->virtualX));
            														}
            														else {
HXDLIN(  95)															index7 = ::Std_obj::_hx_int(( (Float)(((dy1 * this41->width) + dx1)) ));
            														}
HXDLIN(  95)														int c6 = ::iterMagic::Iimg_obj::get(this42,index7);
HXDLIN(  95)														int v4;
HXDLIN(  95)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  95)															v4 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            														}
            														else {
HXDLIN(  95)															v4 = c6;
            														}
HXDLIN(  95)														int maskPixel1 = v4;
HXDLIN(  95)														int this43 = col1;
HXDLIN(  95)														if ((maskPixel1 == 0)) {
HXDLIN(  95)															col1 = this43;
            														}
            														else {
HXDLIN(  95)															Float m01;
HXDLIN(  95)															int this44 = ((maskPixel1 >> 24) & 255);
HXDLIN(  95)															if ((this44 == 0)) {
HXDLIN(  95)																m01 = ((Float)0.);
            															}
            															else {
HXDLIN(  95)																m01 = (( (Float)(this44) ) / ( (Float)(255) ));
            															}
HXDLIN(  95)															Float m11;
HXDLIN(  95)															int this45 = ((maskPixel1 >> 16) & 255);
HXDLIN(  95)															if ((this45 == 0)) {
HXDLIN(  95)																m11 = ((Float)0.);
            															}
            															else {
HXDLIN(  95)																m11 = (( (Float)(this45) ) / ( (Float)(255) ));
            															}
HXDLIN(  95)															Float m21;
HXDLIN(  95)															int this46 = ((maskPixel1 >> 8) & 255);
HXDLIN(  95)															if ((this46 == 0)) {
HXDLIN(  95)																m21 = ((Float)0.);
            															}
            															else {
HXDLIN(  95)																m21 = (( (Float)(this46) ) / ( (Float)(255) ));
            															}
HXDLIN(  95)															Float m31;
HXDLIN(  95)															int this47 = (maskPixel1 & 255);
HXDLIN(  95)															if ((this47 == 0)) {
HXDLIN(  95)																m31 = ((Float)0.);
            															}
            															else {
HXDLIN(  95)																m31 = (( (Float)(this47) ) / ( (Float)(255) ));
            															}
HXDLIN(  95)															int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this43 >> 24) & 255)) )));
HXDLIN(  95)															int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this43 >> 16) & 255)) )));
HXDLIN(  95)															int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this43 >> 8) & 255)) )));
HXDLIN(  95)															int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this43 & 255)) )));
HXDLIN(  95)															col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  95)													if ((col1 != 0)) {
HXDLIN(  95)														int x6 = (dx1 - rectLeft1);
HXDLIN(  95)														int y6 = (dy1 - rectTop1);
HXDLIN(  95)														int c7 = col1;
HXDLIN(  95)														bool _hx_tmp9;
HXDLIN(  95)														if ((((c7 >> 24) & 255) < 254)) {
HXDLIN(  95)															_hx_tmp9 = undoImage3->transparent;
            														}
            														else {
HXDLIN(  95)															_hx_tmp9 = false;
            														}
HXDLIN(  95)														if (_hx_tmp9) {
HXDLIN(  95)															int location2;
HXDLIN(  95)															if (undoImage3->useVirtualPos) {
HXDLIN(  95)																location2 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            															}
            															else {
HXDLIN(  95)																location2 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            															}
HXDLIN(  95)															int this48 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN(  95)															int this49;
HXDLIN(  95)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  95)																this49 = ((((((this48 >> 24) & 255) << 24) | ((this48 & 255) << 16)) | (((this48 >> 8) & 255) << 8)) | ((this48 >> 16) & 255));
            															}
            															else {
HXDLIN(  95)																this49 = this48;
            															}
HXDLIN(  95)															Float a12;
HXDLIN(  95)															int this50 = ((this49 >> 24) & 255);
HXDLIN(  95)															if ((this50 == 0)) {
HXDLIN(  95)																a12 = ((Float)0.);
            															}
            															else {
HXDLIN(  95)																a12 = (( (Float)(this50) ) / ( (Float)(255) ));
            															}
HXDLIN(  95)															Float r12;
HXDLIN(  95)															int this51 = ((this49 >> 16) & 255);
HXDLIN(  95)															if ((this51 == 0)) {
HXDLIN(  95)																r12 = ((Float)0.);
            															}
            															else {
HXDLIN(  95)																r12 = (( (Float)(this51) ) / ( (Float)(255) ));
            															}
HXDLIN(  95)															Float g12;
HXDLIN(  95)															int this52 = ((this49 >> 8) & 255);
HXDLIN(  95)															if ((this52 == 0)) {
HXDLIN(  95)																g12 = ((Float)0.);
            															}
            															else {
HXDLIN(  95)																g12 = (( (Float)(this52) ) / ( (Float)(255) ));
            															}
HXDLIN(  95)															Float b13;
HXDLIN(  95)															int this53 = (this49 & 255);
HXDLIN(  95)															if ((this53 == 0)) {
HXDLIN(  95)																b13 = ((Float)0.);
            															}
            															else {
HXDLIN(  95)																b13 = (( (Float)(this53) ) / ( (Float)(255) ));
            															}
HXDLIN(  95)															Float a22;
HXDLIN(  95)															int this54 = ((col1 >> 24) & 255);
HXDLIN(  95)															if ((this54 == 0)) {
HXDLIN(  95)																a22 = ((Float)0.);
            															}
            															else {
HXDLIN(  95)																a22 = (( (Float)(this54) ) / ( (Float)(255) ));
            															}
HXDLIN(  95)															Float r22;
HXDLIN(  95)															int this55 = ((col1 >> 16) & 255);
HXDLIN(  95)															if ((this55 == 0)) {
HXDLIN(  95)																r22 = ((Float)0.);
            															}
            															else {
HXDLIN(  95)																r22 = (( (Float)(this55) ) / ( (Float)(255) ));
            															}
HXDLIN(  95)															Float g22;
HXDLIN(  95)															int this56 = ((col1 >> 8) & 255);
HXDLIN(  95)															if ((this56 == 0)) {
HXDLIN(  95)																g22 = ((Float)0.);
            															}
            															else {
HXDLIN(  95)																g22 = (( (Float)(this56) ) / ( (Float)(255) ));
            															}
HXDLIN(  95)															Float b23;
HXDLIN(  95)															int this57 = (col1 & 255);
HXDLIN(  95)															if ((this57 == 0)) {
HXDLIN(  95)																b23 = ((Float)0.);
            															}
            															else {
HXDLIN(  95)																b23 = (( (Float)(this57) ) / ( (Float)(255) ));
            															}
HXDLIN(  95)															Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  95)															int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  95)															int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  95)															int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  95)															int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  95)															int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN(  95)															{
HXDLIN(  95)																int _hx_tmp10;
HXDLIN(  95)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  95)																	_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																}
            																else {
HXDLIN(  95)																	_hx_tmp10 = blended2;
            																}
HXDLIN(  95)																::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            															}
            														}
            														else {
HXDLIN(  95)															::Dynamic this58 = undoImage3->image;
HXDLIN(  95)															int index8;
HXDLIN(  95)															if (undoImage3->useVirtualPos) {
HXDLIN(  95)																index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            															}
            															else {
HXDLIN(  95)																index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            															}
HXDLIN(  95)															int _hx_tmp11;
HXDLIN(  95)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  95)																_hx_tmp11 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            															}
            															else {
HXDLIN(  95)																_hx_tmp11 = c7;
            															}
HXDLIN(  95)															::iterMagic::Iimg_obj::set(this58,index8,_hx_tmp11);
            														}
            													}
            													else {
HXDLIN(  95)														if (forceClear1) {
HXDLIN(  95)															::Dynamic this59 = undoImage3->image;
HXDLIN(  95)															int x7 = (dx1 - rectLeft1);
HXDLIN(  95)															int y7 = (dy1 - rectTop1);
HXDLIN(  95)															int index9;
HXDLIN(  95)															if (undoImage3->useVirtualPos) {
HXDLIN(  95)																index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x7) - undoImage3->virtualX));
            															}
            															else {
HXDLIN(  95)																index9 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage3->width) + x7)) ));
            															}
HXDLIN(  95)															::iterMagic::Iimg_obj::set(this59,index9,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  95)							bool foundY1 = false;
HXDLIN(  95)							Float s1 = ((Float)0.);
HXDLIN(  95)							Float t1 = ((Float)0.);
HXDLIN(  95)							Float sxx1 = ((Float)0.);
HXDLIN(  95)							Float txx1 = ((Float)0.);
HXDLIN(  95)							{
HXDLIN(  95)								int _g_min2 = xIter31->start;
HXDLIN(  95)								int _g_max2 = xIter31->max;
HXDLIN(  95)								while((_g_min2 < _g_max2)){
HXDLIN(  95)									_g_min2 = (_g_min2 + 1);
HXDLIN(  95)									int x8 = (_g_min2 - 1);
HXLINE( 222)									sxx1 = (sx1 * ( (Float)(x8) ));
HXLINE( 223)									txx1 = (tx1 * ( (Float)(x8) ));
HXLINE( 224)									foundY1 = false;
HXLINE(  95)									{
HXDLIN(  95)										int _g_min3 = yIter31->start;
HXDLIN(  95)										int _g_max3 = yIter31->max;
HXDLIN(  95)										while((_g_min3 < _g_max3)){
HXDLIN(  95)											_g_min3 = (_g_min3 + 1);
HXDLIN(  95)											int y8 = (_g_min3 - 1);
HXLINE( 226)											s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y8) )));
HXLINE( 227)											t1 = ((t01 + txx1) + (ty1 * ( (Float)(y8) )));
HXLINE(  95)											bool _hx_tmp12;
HXDLIN(  95)											if (!((s1 <= 0))) {
HXDLIN(  95)												_hx_tmp12 = (t1 <= 0);
            											}
            											else {
HXDLIN(  95)												_hx_tmp12 = true;
            											}
HXDLIN(  95)											if (_hx_tmp12) {
HXDLIN(  95)												if (foundY1) {
HXDLIN(  95)													goto _hx_goto_153;
            												}
            											}
            											else {
HXDLIN(  95)												if (((s1 + t1) < A1)) {
HXDLIN(  95)													int x9 = ::hx::Mod(x8,tileImage->width);
HXDLIN(  95)													int y9 = ::hx::Mod(y8,tileImage->height);
HXDLIN(  95)													::Dynamic this60 = tileImage->image;
HXDLIN(  95)													int index10;
HXDLIN(  95)													if (tileImage->useVirtualPos) {
HXDLIN(  95)														index10 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x9) - tileImage->virtualX));
            													}
            													else {
HXDLIN(  95)														index10 = ::Std_obj::_hx_int(( (Float)(((y9 * tileImage->width) + x9)) ));
            													}
HXDLIN(  95)													int c8 = ::iterMagic::Iimg_obj::get(this60,index10);
HXDLIN(  95)													int color1;
HXDLIN(  95)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  95)														color1 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            													}
            													else {
HXDLIN(  95)														color1 = c8;
            													}
HXDLIN(  95)													{
HXDLIN(  95)														int c9 = color1;
HXDLIN(  95)														bool _hx_tmp13;
HXDLIN(  95)														if ((((c9 >> 24) & 255) < 254)) {
HXDLIN(  95)															_hx_tmp13 = this37->transparent;
            														}
            														else {
HXDLIN(  95)															_hx_tmp13 = false;
            														}
HXDLIN(  95)														if (_hx_tmp13) {
HXDLIN(  95)															int location3;
HXDLIN(  95)															if (this37->useVirtualPos) {
HXDLIN(  95)																location3 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - this37->virtualY) * ( (Float)(this37->width) )) + x8) - this37->virtualX));
            															}
            															else {
HXDLIN(  95)																location3 = ::Std_obj::_hx_int(( (Float)(((y8 * this37->width) + x8)) ));
            															}
HXDLIN(  95)															int this61 = ::iterMagic::Iimg_obj::get(this37->image,location3);
HXDLIN(  95)															int this62;
HXDLIN(  95)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  95)																this62 = ((((((this61 >> 24) & 255) << 24) | ((this61 & 255) << 16)) | (((this61 >> 8) & 255) << 8)) | ((this61 >> 16) & 255));
            															}
            															else {
HXDLIN(  95)																this62 = this61;
            															}
HXDLIN(  95)															Float a13;
HXDLIN(  95)															int this63 = ((this62 >> 24) & 255);
HXDLIN(  95)															if ((this63 == 0)) {
HXDLIN(  95)																a13 = ((Float)0.);
            															}
            															else {
HXDLIN(  95)																a13 = (( (Float)(this63) ) / ( (Float)(255) ));
            															}
HXDLIN(  95)															Float r13;
HXDLIN(  95)															int this64 = ((this62 >> 16) & 255);
HXDLIN(  95)															if ((this64 == 0)) {
HXDLIN(  95)																r13 = ((Float)0.);
            															}
            															else {
HXDLIN(  95)																r13 = (( (Float)(this64) ) / ( (Float)(255) ));
            															}
HXDLIN(  95)															Float g13;
HXDLIN(  95)															int this65 = ((this62 >> 8) & 255);
HXDLIN(  95)															if ((this65 == 0)) {
HXDLIN(  95)																g13 = ((Float)0.);
            															}
            															else {
HXDLIN(  95)																g13 = (( (Float)(this65) ) / ( (Float)(255) ));
            															}
HXDLIN(  95)															Float b14;
HXDLIN(  95)															int this66 = (this62 & 255);
HXDLIN(  95)															if ((this66 == 0)) {
HXDLIN(  95)																b14 = ((Float)0.);
            															}
            															else {
HXDLIN(  95)																b14 = (( (Float)(this66) ) / ( (Float)(255) ));
            															}
HXDLIN(  95)															Float a23;
HXDLIN(  95)															int this67 = ((color1 >> 24) & 255);
HXDLIN(  95)															if ((this67 == 0)) {
HXDLIN(  95)																a23 = ((Float)0.);
            															}
            															else {
HXDLIN(  95)																a23 = (( (Float)(this67) ) / ( (Float)(255) ));
            															}
HXDLIN(  95)															Float r23;
HXDLIN(  95)															int this68 = ((color1 >> 16) & 255);
HXDLIN(  95)															if ((this68 == 0)) {
HXDLIN(  95)																r23 = ((Float)0.);
            															}
            															else {
HXDLIN(  95)																r23 = (( (Float)(this68) ) / ( (Float)(255) ));
            															}
HXDLIN(  95)															Float g23;
HXDLIN(  95)															int this69 = ((color1 >> 8) & 255);
HXDLIN(  95)															if ((this69 == 0)) {
HXDLIN(  95)																g23 = ((Float)0.);
            															}
            															else {
HXDLIN(  95)																g23 = (( (Float)(this69) ) / ( (Float)(255) ));
            															}
HXDLIN(  95)															Float b24;
HXDLIN(  95)															int this70 = (color1 & 255);
HXDLIN(  95)															if ((this70 == 0)) {
HXDLIN(  95)																b24 = ((Float)0.);
            															}
            															else {
HXDLIN(  95)																b24 = (( (Float)(this70) ) / ( (Float)(255) ));
            															}
HXDLIN(  95)															Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  95)															int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  95)															int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  95)															int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN(  95)															int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  95)															int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN(  95)															{
HXDLIN(  95)																int _hx_tmp14;
HXDLIN(  95)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  95)																	_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																}
            																else {
HXDLIN(  95)																	_hx_tmp14 = blended3;
            																}
HXDLIN(  95)																::iterMagic::Iimg_obj::set(this37->image,location3,_hx_tmp14);
            															}
            														}
            														else {
HXDLIN(  95)															::Dynamic this71 = this37->image;
HXDLIN(  95)															int index11;
HXDLIN(  95)															if (this37->useVirtualPos) {
HXDLIN(  95)																index11 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - this37->virtualY) * ( (Float)(this37->width) )) + x8) - this37->virtualX));
            															}
            															else {
HXDLIN(  95)																index11 = ::Std_obj::_hx_int(( (Float)(((y8 * this37->width) + x8)) ));
            															}
HXDLIN(  95)															int _hx_tmp15;
HXDLIN(  95)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN(  95)																_hx_tmp15 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            															}
            															else {
HXDLIN(  95)																_hx_tmp15 = c9;
            															}
HXDLIN(  95)															::iterMagic::Iimg_obj::set(this71,index11,_hx_tmp15);
            														}
            													}
HXLINE( 236)													foundY1 = true;
            												}
            												else {
HXDLIN(  95)													if (foundY1) {
HXDLIN(  95)														goto _hx_goto_153;
            													}
            												}
            											}
            										}
            										_hx_goto_153:;
            									}
            								}
            							}
HXDLIN(  95)							if ((hasHit1 == false)) {
HXDLIN(  95)								 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN(  95)								if (hasUndo1) {
HXDLIN(  95)									v5->undoImage = undoImage3;
HXDLIN(  95)									v5->undoX = xIter31->start;
HXDLIN(  95)									v5->undoY = yIter31->start;
            								}
            							}
            						}
            					}
            				}
HXLINE(  93)				lastX = nextX1;
HXLINE(  94)				lastY = nextY1;
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(TileShape_Impl__obj,quadrant,(void))

void TileShape_Impl__obj::quadrantI( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float rx,Float ry, ::pi_xy::ImageStruct tileImage, ::Dynamic __o_phi){
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = ((Float)0.);
            	HX_GC_STACKFRAME(&_hx_pos_6e4d7718bf84d356_110_quadrantI)
HXDLIN( 110)		 ::Dynamic targetError = ((Float)1.05);
HXDLIN( 110)		if (::hx::IsNull( targetError )) {
HXLINE( 101)			targetError = ((Float)1.05);
            		}
HXLINE( 110)		Float rSmall;
HXDLIN( 110)		if ((rx > ry)) {
HXDLIN( 110)			rSmall = ry;
            		}
            		else {
HXDLIN( 110)			rSmall = rx;
            		}
HXDLIN( 110)		 ::Dynamic targetE = ( (Float)(targetError) );
HXDLIN( 110)		if (::hx::IsNull( targetE )) {
HXLINE(  20)			targetE = ((Float)1.05);
            		}
HXLINE( 110)		int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN( 110)		int noSides;
HXDLIN( 110)		if ((result < 12)) {
HXDLIN( 110)			noSides = 12;
            		}
            		else {
HXDLIN( 110)			if ((result > 500)) {
HXDLIN( 110)				noSides = 500;
            			}
            			else {
HXDLIN( 110)				noSides = result;
            			}
            		}
HXDLIN( 110)		int sides = (::Math_obj::ceil((( (Float)(noSides) ) / ( (Float)(4) ))) * 4);
HXDLIN( 110)		Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides) ));
HXDLIN( 110)		Float omega = ((( (Float)(3) ) * ::Math_obj::PI) / ( (Float)(2) ));
HXDLIN( 110)		int quarter = ::Std_obj::_hx_int((( (Float)(sides) ) / ( (Float)(4) )));
HXDLIN( 110)		Float lastX = ((Float)0.);
HXDLIN( 110)		Float lastY = ((Float)0.);
HXDLIN( 110)		if (::hx::IsNotEq( phi,0 )) {
HXLINE(  70)			lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) )))) + cx);
HXLINE(  71)			lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) )))) + cy);
            		}
            		else {
HXLINE(  73)			lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))));
HXLINE(  74)			lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))));
            		}
HXLINE( 110)		if (::hx::IsNotEq( phi,0 )) {
HXDLIN( 110)			Float cphi = ::Math_obj::cos(( (Float)(phi) ));
HXDLIN( 110)			Float sphi = ::Math_obj::sin(( (Float)(phi) ));
HXDLIN( 110)			{
HXDLIN( 110)				int _g = 0;
HXDLIN( 110)				int _g1 = (quarter + 1);
HXDLIN( 110)				while((_g < _g1)){
HXDLIN( 110)					_g = (_g + 1);
HXDLIN( 110)					int i = (_g - 1);
HXDLIN( 110)					Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega));
HXDLIN( 110)					Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega));
HXDLIN( 110)					Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXDLIN( 110)					Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXDLIN( 110)					{
HXDLIN( 110)						 ::pi_xy::ImageStruct this2 = this1;
HXDLIN( 110)						bool hasHit = false;
HXDLIN( 110)						{
HXDLIN( 110)							Float bx = lastX;
HXDLIN( 110)							Float by = lastY;
HXDLIN( 110)							Float cx1 = nextX;
HXDLIN( 110)							Float cy1 = nextY;
HXDLIN( 110)							bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN( 110)							if (!(adjustWinding)) {
HXDLIN( 110)								Float bx_ = bx;
HXDLIN( 110)								Float by_ = by;
HXLINE( 187)								bx = cx1;
HXLINE( 188)								by = cy1;
HXLINE( 189)								cx1 = bx_;
HXLINE( 190)								cy1 = by_;
            							}
HXLINE( 110)							{
HXDLIN( 110)								bool hasUndo = false;
HXDLIN( 110)								Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN( 110)								Float sx = (cy1 - cy);
HXDLIN( 110)								Float sy = (cx - cx1);
HXDLIN( 110)								Float t0 = ((cx * by) - (cy * bx));
HXDLIN( 110)								Float tx = (cy - by);
HXDLIN( 110)								Float ty = (bx - cx);
HXDLIN( 110)								Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN( 110)								 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 110)								if ((cx > bx)) {
HXDLIN( 110)									if ((cx > cx1)) {
HXDLIN( 110)										int min;
HXDLIN( 110)										if ((bx > cx1)) {
HXDLIN( 110)											min = ::Math_obj::floor(cx1);
            										}
            										else {
HXDLIN( 110)											min = ::Math_obj::floor(bx);
            										}
HXDLIN( 110)										int ii_min = min;
HXDLIN( 110)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 110)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            									}
            									else {
HXDLIN( 110)										int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 110)										int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 110)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            									}
            								}
            								else {
HXDLIN( 110)									if ((bx > cx1)) {
HXDLIN( 110)										int min1;
HXDLIN( 110)										if ((cx > cx1)) {
HXDLIN( 110)											min1 = ::Math_obj::floor(cx1);
            										}
            										else {
HXDLIN( 110)											min1 = ::Math_obj::ceil(cx);
            										}
HXDLIN( 110)										int ii_min2 = min1;
HXDLIN( 110)										int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 110)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            									}
            									else {
HXDLIN( 110)										int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 110)										int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 110)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            									}
            								}
HXDLIN( 110)								 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 110)								if ((cy > by)) {
HXDLIN( 110)									if ((cy > cy1)) {
HXDLIN( 110)										int min2;
HXDLIN( 110)										if ((by > cy1)) {
HXDLIN( 110)											min2 = ::Math_obj::floor(cy1);
            										}
            										else {
HXDLIN( 110)											min2 = ::Math_obj::floor(by);
            										}
HXDLIN( 110)										int ii_min4 = min2;
HXDLIN( 110)										int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 110)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            									}
            									else {
HXDLIN( 110)										int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 110)										int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 110)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            									}
            								}
            								else {
HXDLIN( 110)									if ((by > cy1)) {
HXDLIN( 110)										int min3;
HXDLIN( 110)										if ((cy > cy1)) {
HXDLIN( 110)											min3 = ::Math_obj::floor(cy1);
            										}
            										else {
HXDLIN( 110)											min3 = ::Math_obj::ceil(cy);
            										}
HXDLIN( 110)										int ii_min6 = min3;
HXDLIN( 110)										int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 110)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            									}
            									else {
HXDLIN( 110)										int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 110)										int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 110)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            									}
            								}
HXDLIN( 110)								 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 110)								if (hasUndo) {
HXDLIN( 110)									int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 110)									int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 110)									 ::Dynamic imageType = null();
HXDLIN( 110)									 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 110)									if (::hx::IsNull( imageType )) {
HXLINE(  54)										imageType = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 110)									::Dynamic undoImage1;
HXDLIN( 110)									switch((int)(( (int)(imageType) ))){
            										case (int)0: {
HXDLIN( 110)											 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 110)											 ::iterMagic::BytesImg b = byt;
HXDLIN( 110)											{
HXDLIN( 110)												b->width = width;
HXDLIN( 110)												b->height = height;
HXDLIN( 110)												b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 110)												b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 110)												{
HXDLIN( 110)													int len = b->length;
HXDLIN( 110)													int w = 0;
HXDLIN( 110)													{
HXDLIN( 110)														int _g2 = 0;
HXDLIN( 110)														int _g3 = b->height;
HXDLIN( 110)														while((_g2 < _g3)){
HXDLIN( 110)															_g2 = (_g2 + 1);
HXDLIN( 110)															int y = (_g2 - 1);
HXDLIN( 110)															{
HXDLIN( 110)																int _g4 = 0;
HXDLIN( 110)																int _g5 = b->width;
HXDLIN( 110)																while((_g4 < _g5)){
HXDLIN( 110)																	_g4 = (_g4 + 1);
HXDLIN( 110)																	int x = (_g4 - 1);
HXDLIN( 110)																	{
HXDLIN( 110)																		w = (w + 1);
HXDLIN( 110)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 110)																	{
HXDLIN( 110)																		w = (w + 1);
HXDLIN( 110)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 110)																	{
HXDLIN( 110)																		w = (w + 1);
HXDLIN( 110)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 110)																	{
HXDLIN( 110)																		w = (w + 1);
HXDLIN( 110)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 110)											undoImage1 = b;
            										}
            										break;
            										case (int)1: {
HXDLIN( 110)											 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 110)											 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 110)											{
HXDLIN( 110)												a->width = width;
HXDLIN( 110)												a->height = height;
HXDLIN( 110)												a->data = ::Array_obj< int >::__new(0);
HXDLIN( 110)												a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 110)												{
HXDLIN( 110)													int _g6 = 0;
HXDLIN( 110)													int _g7 = a->length;
HXDLIN( 110)													while((_g6 < _g7)){
HXDLIN( 110)														_g6 = (_g6 + 1);
HXDLIN( 110)														int i1 = (_g6 - 1);
HXDLIN( 110)														a->data[i1] = 0;
            													}
            												}
            											}
HXDLIN( 110)											undoImage1 = a;
            										}
            										break;
            										case (int)2: {
HXDLIN( 110)											 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 110)											 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 110)											{
HXDLIN( 110)												b1->width = width;
HXDLIN( 110)												b1->height = height;
HXDLIN( 110)												b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 110)												int size = (b1->length * 4);
HXDLIN( 110)												b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 110)												{
HXDLIN( 110)													int _g8 = 0;
HXDLIN( 110)													int _g9 = b1->length;
HXDLIN( 110)													while((_g8 < _g9)){
HXDLIN( 110)														_g8 = (_g8 + 1);
HXDLIN( 110)														int i2 = (_g8 - 1);
HXDLIN( 110)														{
HXDLIN( 110)															 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN( 110)															bool undoImage2;
HXDLIN( 110)															if ((i2 >= 0)) {
HXDLIN( 110)																undoImage2 = (i2 < (this4->byteLength >> 2));
            															}
            															else {
HXDLIN( 110)																undoImage2 = false;
            															}
HXDLIN( 110)															if (undoImage2) {
HXDLIN( 110)																 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN( 110)																int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN( 110)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 110)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 110)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 110)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 110)											undoImage1 = b1;
            										}
            										break;
            										case (int)3: {
HXDLIN( 110)											 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 110)											 ::iterMagic::VecIntImg v = vec;
HXDLIN( 110)											{
HXDLIN( 110)												v->width = width;
HXDLIN( 110)												v->height = height;
HXDLIN( 110)												v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 110)												v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 110)												{
HXDLIN( 110)													int _g10 = 0;
HXDLIN( 110)													int _g11 = v->length;
HXDLIN( 110)													while((_g10 < _g11)){
HXDLIN( 110)														_g10 = (_g10 + 1);
HXDLIN( 110)														int i3 = (_g10 - 1);
HXDLIN( 110)														v->data->__unsafe_set(i3,0);
            													}
            												}
            											}
HXDLIN( 110)											undoImage1 = v;
            										}
            										break;
            										case (int)4: {
HXDLIN( 110)											 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 110)											 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 110)											{
HXDLIN( 110)												b2->width = width;
HXDLIN( 110)												b2->height = height;
HXDLIN( 110)												b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 110)												b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 110)												{
HXDLIN( 110)													int len1 = b2->length;
HXDLIN( 110)													 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 110)													if (::hx::IsNull( d->head )) {
HXDLIN( 110)														int _g12 = 0;
HXDLIN( 110)														int _g13 = len1;
HXDLIN( 110)														while((_g12 < _g13)){
HXDLIN( 110)															_g12 = (_g12 + 1);
HXDLIN( 110)															int i4 = (_g12 - 1);
HXDLIN( 110)															d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            														}
            													}
            													else {
HXDLIN( 110)														int _g14 = 0;
HXDLIN( 110)														int _g15 = len1;
HXDLIN( 110)														while((_g14 < _g15)){
HXDLIN( 110)															_g14 = (_g14 + 1);
HXDLIN( 110)															int i5 = (_g14 - 1);
HXDLIN( 110)															{
HXDLIN( 110)																 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 110)																 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 110)																{
HXDLIN( 110)																	int _g16 = 0;
HXDLIN( 110)																	int _g17 = i5;
HXDLIN( 110)																	while((_g16 < _g17)){
HXDLIN( 110)																		_g16 = (_g16 + 1);
HXDLIN( 110)																		int i6 = (_g16 - 1);
HXLINE( 345)																		prev = l;
HXLINE( 346)																		l = l->next;
            																	}
            																}
HXLINE( 110)																if (::hx::IsNull( prev )) {
HXDLIN( 110)																	b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 110)																	l = null();
            																}
            																else {
HXDLIN( 110)																	prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 110)																	l = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 110)											undoImage1 = b2;
            										}
            										break;
            									}
HXDLIN( 110)									this3->image = undoImage1;
HXDLIN( 110)									this3->width = width;
HXDLIN( 110)									this3->height = height;
HXDLIN( 110)									this3->imageType = ( (int)(imageType) );
HXDLIN( 110)									undoImage = this3;
HXDLIN( 110)									{
HXDLIN( 110)										int rectLeft = xIter3->start;
HXDLIN( 110)										int rectTop = yIter3->start;
HXDLIN( 110)										int rectRight = xIter3->max;
HXDLIN( 110)										bool forceClear = false;
HXDLIN( 110)										{
HXDLIN( 110)											int _g18 = rectTop;
HXDLIN( 110)											int _g19 = yIter3->max;
HXDLIN( 110)											while((_g18 < _g19)){
HXDLIN( 110)												_g18 = (_g18 + 1);
HXDLIN( 110)												int dy = (_g18 - 1);
HXDLIN( 110)												{
HXDLIN( 110)													int _g20 = rectLeft;
HXDLIN( 110)													int _g21 = rectRight;
HXDLIN( 110)													while((_g20 < _g21)){
HXDLIN( 110)														_g20 = (_g20 + 1);
HXDLIN( 110)														int dx = (_g20 - 1);
HXDLIN( 110)														::Dynamic this5 = this2->image;
HXDLIN( 110)														int index;
HXDLIN( 110)														if (this2->useVirtualPos) {
HXDLIN( 110)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            														}
            														else {
HXDLIN( 110)															index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            														}
HXDLIN( 110)														int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN( 110)														int col;
HXDLIN( 110)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 110)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXDLIN( 110)															col = c;
            														}
HXDLIN( 110)														bool _hx_tmp;
HXDLIN( 110)														if (this2->useMask) {
HXDLIN( 110)															_hx_tmp = ::hx::IsNotNull( this2->mask );
            														}
            														else {
HXDLIN( 110)															_hx_tmp = false;
            														}
HXDLIN( 110)														if (_hx_tmp) {
HXDLIN( 110)															 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN( 110)															::Dynamic this7 = this6->image;
HXDLIN( 110)															int index1;
HXDLIN( 110)															if (this6->useVirtualPos) {
HXDLIN( 110)																index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            															}
            															else {
HXDLIN( 110)																index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            															}
HXDLIN( 110)															int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN( 110)															int v1;
HXDLIN( 110)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 110)																v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            															}
            															else {
HXDLIN( 110)																v1 = c1;
            															}
HXDLIN( 110)															int maskPixel = v1;
HXDLIN( 110)															int this8 = col;
HXDLIN( 110)															if ((maskPixel == 0)) {
HXDLIN( 110)																col = this8;
            															}
            															else {
HXDLIN( 110)																Float m0;
HXDLIN( 110)																int this9 = ((maskPixel >> 24) & 255);
HXDLIN( 110)																if ((this9 == 0)) {
HXDLIN( 110)																	m0 = ((Float)0.);
            																}
            																else {
HXDLIN( 110)																	m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN( 110)																Float m1;
HXDLIN( 110)																int this10 = ((maskPixel >> 16) & 255);
HXDLIN( 110)																if ((this10 == 0)) {
HXDLIN( 110)																	m1 = ((Float)0.);
            																}
            																else {
HXDLIN( 110)																	m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN( 110)																Float m2;
HXDLIN( 110)																int this11 = ((maskPixel >> 8) & 255);
HXDLIN( 110)																if ((this11 == 0)) {
HXDLIN( 110)																	m2 = ((Float)0.);
            																}
            																else {
HXDLIN( 110)																	m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN( 110)																Float m3;
HXDLIN( 110)																int this12 = (maskPixel & 255);
HXDLIN( 110)																if ((this12 == 0)) {
HXDLIN( 110)																	m3 = ((Float)0.);
            																}
            																else {
HXDLIN( 110)																	m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN( 110)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN( 110)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN( 110)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN( 110)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN( 110)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 110)														if ((col != 0)) {
HXDLIN( 110)															int x1 = (dx - rectLeft);
HXDLIN( 110)															int y1 = (dy - rectTop);
HXDLIN( 110)															int c2 = col;
HXDLIN( 110)															bool _hx_tmp1;
HXDLIN( 110)															if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 110)																_hx_tmp1 = undoImage->transparent;
            															}
            															else {
HXDLIN( 110)																_hx_tmp1 = false;
            															}
HXDLIN( 110)															if (_hx_tmp1) {
HXDLIN( 110)																int location;
HXDLIN( 110)																if (undoImage->useVirtualPos) {
HXDLIN( 110)																	location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXDLIN( 110)																	location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN( 110)																int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 110)																int this14;
HXDLIN( 110)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 110)																	this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																}
            																else {
HXDLIN( 110)																	this14 = this13;
            																}
HXDLIN( 110)																Float a1;
HXDLIN( 110)																int this15 = ((this14 >> 24) & 255);
HXDLIN( 110)																if ((this15 == 0)) {
HXDLIN( 110)																	a1 = ((Float)0.);
            																}
            																else {
HXDLIN( 110)																	a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																}
HXDLIN( 110)																Float r1;
HXDLIN( 110)																int this16 = ((this14 >> 16) & 255);
HXDLIN( 110)																if ((this16 == 0)) {
HXDLIN( 110)																	r1 = ((Float)0.);
            																}
            																else {
HXDLIN( 110)																	r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																}
HXDLIN( 110)																Float g1;
HXDLIN( 110)																int this17 = ((this14 >> 8) & 255);
HXDLIN( 110)																if ((this17 == 0)) {
HXDLIN( 110)																	g1 = ((Float)0.);
            																}
            																else {
HXDLIN( 110)																	g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																}
HXDLIN( 110)																Float b11;
HXDLIN( 110)																int this18 = (this14 & 255);
HXDLIN( 110)																if ((this18 == 0)) {
HXDLIN( 110)																	b11 = ((Float)0.);
            																}
            																else {
HXDLIN( 110)																	b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																}
HXDLIN( 110)																Float a2;
HXDLIN( 110)																int this19 = ((col >> 24) & 255);
HXDLIN( 110)																if ((this19 == 0)) {
HXDLIN( 110)																	a2 = ((Float)0.);
            																}
            																else {
HXDLIN( 110)																	a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																}
HXDLIN( 110)																Float r2;
HXDLIN( 110)																int this20 = ((col >> 16) & 255);
HXDLIN( 110)																if ((this20 == 0)) {
HXDLIN( 110)																	r2 = ((Float)0.);
            																}
            																else {
HXDLIN( 110)																	r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																}
HXDLIN( 110)																Float g2;
HXDLIN( 110)																int this21 = ((col >> 8) & 255);
HXDLIN( 110)																if ((this21 == 0)) {
HXDLIN( 110)																	g2 = ((Float)0.);
            																}
            																else {
HXDLIN( 110)																	g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																}
HXDLIN( 110)																Float b21;
HXDLIN( 110)																int this22 = (col & 255);
HXDLIN( 110)																if ((this22 == 0)) {
HXDLIN( 110)																	b21 = ((Float)0.);
            																}
            																else {
HXDLIN( 110)																	b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																}
HXDLIN( 110)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 110)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 110)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 110)																int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 110)																int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 110)																int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 110)																{
HXDLIN( 110)																	int _hx_tmp2;
HXDLIN( 110)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 110)																		_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXDLIN( 110)																		_hx_tmp2 = blended;
            																	}
HXDLIN( 110)																	::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																}
            															}
            															else {
HXDLIN( 110)																::Dynamic this23 = undoImage->image;
HXDLIN( 110)																int index2;
HXDLIN( 110)																if (undoImage->useVirtualPos) {
HXDLIN( 110)																	index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXDLIN( 110)																	index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN( 110)																int _hx_tmp3;
HXDLIN( 110)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 110)																	_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																}
            																else {
HXDLIN( 110)																	_hx_tmp3 = c2;
            																}
HXDLIN( 110)																::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            															}
            														}
            														else {
HXDLIN( 110)															if (forceClear) {
HXDLIN( 110)																::Dynamic this24 = undoImage->image;
HXDLIN( 110)																int x2 = (dx - rectLeft);
HXDLIN( 110)																int y2 = (dy - rectTop);
HXDLIN( 110)																int index3;
HXDLIN( 110)																if (undoImage->useVirtualPos) {
HXDLIN( 110)																	index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																}
            																else {
HXDLIN( 110)																	index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																}
HXDLIN( 110)																::iterMagic::Iimg_obj::set(this24,index3,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 110)								bool foundY = false;
HXDLIN( 110)								Float s = ((Float)0.);
HXDLIN( 110)								Float t = ((Float)0.);
HXDLIN( 110)								Float sxx = ((Float)0.);
HXDLIN( 110)								Float txx = ((Float)0.);
HXDLIN( 110)								{
HXDLIN( 110)									int _g_min = xIter3->start;
HXDLIN( 110)									int _g_max = xIter3->max;
HXDLIN( 110)									while((_g_min < _g_max)){
HXDLIN( 110)										_g_min = (_g_min + 1);
HXDLIN( 110)										int x3 = (_g_min - 1);
HXLINE( 222)										sxx = (sx * ( (Float)(x3) ));
HXLINE( 223)										txx = (tx * ( (Float)(x3) ));
HXLINE( 224)										foundY = false;
HXLINE( 110)										{
HXDLIN( 110)											int _g_min1 = yIter3->start;
HXDLIN( 110)											int _g_max1 = yIter3->max;
HXDLIN( 110)											while((_g_min1 < _g_max1)){
HXDLIN( 110)												_g_min1 = (_g_min1 + 1);
HXDLIN( 110)												int y3 = (_g_min1 - 1);
HXLINE( 226)												s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE( 227)												t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 110)												bool _hx_tmp4;
HXDLIN( 110)												if (!((s <= 0))) {
HXDLIN( 110)													_hx_tmp4 = (t <= 0);
            												}
            												else {
HXDLIN( 110)													_hx_tmp4 = true;
            												}
HXDLIN( 110)												if (_hx_tmp4) {
HXDLIN( 110)													if (foundY) {
HXDLIN( 110)														goto _hx_goto_167;
            													}
            												}
            												else {
HXDLIN( 110)													if (((s + t) < A)) {
HXDLIN( 110)														int x4 = ::hx::Mod(x3,tileImage->width);
HXDLIN( 110)														int y4 = ::hx::Mod(y3,tileImage->height);
HXDLIN( 110)														::Dynamic this25 = tileImage->image;
HXDLIN( 110)														int index4;
HXDLIN( 110)														if (tileImage->useVirtualPos) {
HXDLIN( 110)															index4 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x4) - tileImage->virtualX));
            														}
            														else {
HXDLIN( 110)															index4 = ::Std_obj::_hx_int(( (Float)(((y4 * tileImage->width) + x4)) ));
            														}
HXDLIN( 110)														int c3 = ::iterMagic::Iimg_obj::get(this25,index4);
HXDLIN( 110)														int color;
HXDLIN( 110)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 110)															color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            														}
            														else {
HXDLIN( 110)															color = c3;
            														}
HXDLIN( 110)														{
HXDLIN( 110)															int c4 = color;
HXDLIN( 110)															bool _hx_tmp5;
HXDLIN( 110)															if ((((c4 >> 24) & 255) < 254)) {
HXDLIN( 110)																_hx_tmp5 = this2->transparent;
            															}
            															else {
HXDLIN( 110)																_hx_tmp5 = false;
            															}
HXDLIN( 110)															if (_hx_tmp5) {
HXDLIN( 110)																int location1;
HXDLIN( 110)																if (this2->useVirtualPos) {
HXDLIN( 110)																	location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																}
            																else {
HXDLIN( 110)																	location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																}
HXDLIN( 110)																int this26 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN( 110)																int this27;
HXDLIN( 110)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 110)																	this27 = ((((((this26 >> 24) & 255) << 24) | ((this26 & 255) << 16)) | (((this26 >> 8) & 255) << 8)) | ((this26 >> 16) & 255));
            																}
            																else {
HXDLIN( 110)																	this27 = this26;
            																}
HXDLIN( 110)																Float a11;
HXDLIN( 110)																int this28 = ((this27 >> 24) & 255);
HXDLIN( 110)																if ((this28 == 0)) {
HXDLIN( 110)																	a11 = ((Float)0.);
            																}
            																else {
HXDLIN( 110)																	a11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																}
HXDLIN( 110)																Float r11;
HXDLIN( 110)																int this29 = ((this27 >> 16) & 255);
HXDLIN( 110)																if ((this29 == 0)) {
HXDLIN( 110)																	r11 = ((Float)0.);
            																}
            																else {
HXDLIN( 110)																	r11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																}
HXDLIN( 110)																Float g11;
HXDLIN( 110)																int this30 = ((this27 >> 8) & 255);
HXDLIN( 110)																if ((this30 == 0)) {
HXDLIN( 110)																	g11 = ((Float)0.);
            																}
            																else {
HXDLIN( 110)																	g11 = (( (Float)(this30) ) / ( (Float)(255) ));
            																}
HXDLIN( 110)																Float b12;
HXDLIN( 110)																int this31 = (this27 & 255);
HXDLIN( 110)																if ((this31 == 0)) {
HXDLIN( 110)																	b12 = ((Float)0.);
            																}
            																else {
HXDLIN( 110)																	b12 = (( (Float)(this31) ) / ( (Float)(255) ));
            																}
HXDLIN( 110)																Float a21;
HXDLIN( 110)																int this32 = ((color >> 24) & 255);
HXDLIN( 110)																if ((this32 == 0)) {
HXDLIN( 110)																	a21 = ((Float)0.);
            																}
            																else {
HXDLIN( 110)																	a21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																}
HXDLIN( 110)																Float r21;
HXDLIN( 110)																int this33 = ((color >> 16) & 255);
HXDLIN( 110)																if ((this33 == 0)) {
HXDLIN( 110)																	r21 = ((Float)0.);
            																}
            																else {
HXDLIN( 110)																	r21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																}
HXDLIN( 110)																Float g21;
HXDLIN( 110)																int this34 = ((color >> 8) & 255);
HXDLIN( 110)																if ((this34 == 0)) {
HXDLIN( 110)																	g21 = ((Float)0.);
            																}
            																else {
HXDLIN( 110)																	g21 = (( (Float)(this34) ) / ( (Float)(255) ));
            																}
HXDLIN( 110)																Float b22;
HXDLIN( 110)																int this35 = (color & 255);
HXDLIN( 110)																if ((this35 == 0)) {
HXDLIN( 110)																	b22 = ((Float)0.);
            																}
            																else {
HXDLIN( 110)																	b22 = (( (Float)(this35) ) / ( (Float)(255) ));
            																}
HXDLIN( 110)																Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 110)																int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 110)																int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 110)																int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 110)																int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 110)																int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 110)																{
HXDLIN( 110)																	int _hx_tmp6;
HXDLIN( 110)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 110)																		_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 110)																		_hx_tmp6 = blended1;
            																	}
HXDLIN( 110)																	::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp6);
            																}
            															}
            															else {
HXDLIN( 110)																::Dynamic this36 = this2->image;
HXDLIN( 110)																int index5;
HXDLIN( 110)																if (this2->useVirtualPos) {
HXDLIN( 110)																	index5 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																}
            																else {
HXDLIN( 110)																	index5 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																}
HXDLIN( 110)																int _hx_tmp7;
HXDLIN( 110)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 110)																	_hx_tmp7 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            																}
            																else {
HXDLIN( 110)																	_hx_tmp7 = c4;
            																}
HXDLIN( 110)																::iterMagic::Iimg_obj::set(this36,index5,_hx_tmp7);
            															}
            														}
HXLINE( 236)														foundY = true;
            													}
            													else {
HXDLIN( 110)														if (foundY) {
HXDLIN( 110)															goto _hx_goto_167;
            														}
            													}
            												}
            											}
            											_hx_goto_167:;
            										}
            									}
            								}
HXDLIN( 110)								if ((hasHit == false)) {
HXDLIN( 110)									 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN( 110)									if (hasUndo) {
HXDLIN( 110)										v2->undoImage = undoImage;
HXDLIN( 110)										v2->undoX = xIter3->start;
HXDLIN( 110)										v2->undoY = yIter3->start;
            									}
            								}
            							}
            						}
            					}
HXLINE(  85)					lastX = nextX;
HXLINE(  86)					lastY = nextY;
            				}
            			}
            		}
            		else {
HXDLIN( 110)			int _g22 = 0;
HXDLIN( 110)			int _g23 = (quarter + 1);
HXDLIN( 110)			while((_g22 < _g23)){
HXDLIN( 110)				_g22 = (_g22 + 1);
HXDLIN( 110)				int i7 = (_g22 - 1);
HXDLIN( 110)				Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN( 110)				Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN( 110)				{
HXDLIN( 110)					 ::pi_xy::ImageStruct this37 = this1;
HXDLIN( 110)					bool hasHit1 = false;
HXDLIN( 110)					{
HXDLIN( 110)						Float bx1 = lastX;
HXDLIN( 110)						Float by1 = lastY;
HXDLIN( 110)						Float cx2 = nextX1;
HXDLIN( 110)						Float cy2 = nextY1;
HXDLIN( 110)						bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN( 110)						if (!(adjustWinding1)) {
HXDLIN( 110)							Float bx_1 = bx1;
HXDLIN( 110)							Float by_1 = by1;
HXLINE( 187)							bx1 = cx2;
HXLINE( 188)							by1 = cy2;
HXLINE( 189)							cx2 = bx_1;
HXLINE( 190)							cy2 = by_1;
            						}
HXLINE( 110)						{
HXDLIN( 110)							bool hasUndo1 = false;
HXDLIN( 110)							Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN( 110)							Float sx1 = (cy2 - cy);
HXDLIN( 110)							Float sy1 = (cx - cx2);
HXDLIN( 110)							Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN( 110)							Float tx1 = (cy - by1);
HXDLIN( 110)							Float ty1 = (bx1 - cx);
HXDLIN( 110)							Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN( 110)							 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 110)							if ((cx > bx1)) {
HXDLIN( 110)								if ((cx > cx2)) {
HXDLIN( 110)									int min4;
HXDLIN( 110)									if ((bx1 > cx2)) {
HXDLIN( 110)										min4 = ::Math_obj::floor(cx2);
            									}
            									else {
HXDLIN( 110)										min4 = ::Math_obj::floor(bx1);
            									}
HXDLIN( 110)									int ii_min8 = min4;
HXDLIN( 110)									int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN( 110)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            								}
            								else {
HXDLIN( 110)									int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 110)									int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 110)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            								}
            							}
            							else {
HXDLIN( 110)								if ((bx1 > cx2)) {
HXDLIN( 110)									int min5;
HXDLIN( 110)									if ((cx > cx2)) {
HXDLIN( 110)										min5 = ::Math_obj::floor(cx2);
            									}
            									else {
HXDLIN( 110)										min5 = ::Math_obj::ceil(cx);
            									}
HXDLIN( 110)									int ii_min10 = min5;
HXDLIN( 110)									int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 110)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            								}
            								else {
HXDLIN( 110)									int ii_min11 = ::Math_obj::floor(cx);
HXDLIN( 110)									int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 110)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            								}
            							}
HXDLIN( 110)							 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 110)							if ((cy > by1)) {
HXDLIN( 110)								if ((cy > cy2)) {
HXDLIN( 110)									int min6;
HXDLIN( 110)									if ((by1 > cy2)) {
HXDLIN( 110)										min6 = ::Math_obj::floor(cy2);
            									}
            									else {
HXDLIN( 110)										min6 = ::Math_obj::floor(by1);
            									}
HXDLIN( 110)									int ii_min12 = min6;
HXDLIN( 110)									int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN( 110)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            								}
            								else {
HXDLIN( 110)									int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 110)									int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 110)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            								}
            							}
            							else {
HXDLIN( 110)								if ((by1 > cy2)) {
HXDLIN( 110)									int min7;
HXDLIN( 110)									if ((cy > cy2)) {
HXDLIN( 110)										min7 = ::Math_obj::floor(cy2);
            									}
            									else {
HXDLIN( 110)										min7 = ::Math_obj::ceil(cy);
            									}
HXDLIN( 110)									int ii_min14 = min7;
HXDLIN( 110)									int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 110)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            								}
            								else {
HXDLIN( 110)									int ii_min15 = ::Math_obj::floor(cy);
HXDLIN( 110)									int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 110)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            								}
            							}
HXDLIN( 110)							 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 110)							if (hasUndo1) {
HXDLIN( 110)								int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 110)								int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 110)								 ::Dynamic imageType1 = null();
HXDLIN( 110)								 ::pi_xy::ImageStruct this38 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 110)								if (::hx::IsNull( imageType1 )) {
HXLINE(  54)									imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE( 110)								::Dynamic undoImage4;
HXDLIN( 110)								switch((int)(( (int)(imageType1) ))){
            									case (int)0: {
HXDLIN( 110)										 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 110)										 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 110)										{
HXDLIN( 110)											b5->width = width1;
HXDLIN( 110)											b5->height = height1;
HXDLIN( 110)											b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 110)											b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 110)											{
HXDLIN( 110)												int len2 = b5->length;
HXDLIN( 110)												int w1 = 0;
HXDLIN( 110)												{
HXDLIN( 110)													int _g24 = 0;
HXDLIN( 110)													int _g25 = b5->height;
HXDLIN( 110)													while((_g24 < _g25)){
HXDLIN( 110)														_g24 = (_g24 + 1);
HXDLIN( 110)														int y5 = (_g24 - 1);
HXDLIN( 110)														{
HXDLIN( 110)															int _g26 = 0;
HXDLIN( 110)															int _g27 = b5->width;
HXDLIN( 110)															while((_g26 < _g27)){
HXDLIN( 110)																_g26 = (_g26 + 1);
HXDLIN( 110)																int x5 = (_g26 - 1);
HXDLIN( 110)																{
HXDLIN( 110)																	w1 = (w1 + 1);
HXDLIN( 110)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 110)																{
HXDLIN( 110)																	w1 = (w1 + 1);
HXDLIN( 110)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 110)																{
HXDLIN( 110)																	w1 = (w1 + 1);
HXDLIN( 110)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 110)																{
HXDLIN( 110)																	w1 = (w1 + 1);
HXDLIN( 110)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 110)										undoImage4 = b5;
            									}
            									break;
            									case (int)1: {
HXDLIN( 110)										 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 110)										 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 110)										{
HXDLIN( 110)											a6->width = width1;
HXDLIN( 110)											a6->height = height1;
HXDLIN( 110)											a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 110)											a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 110)											{
HXDLIN( 110)												int _g28 = 0;
HXDLIN( 110)												int _g29 = a6->length;
HXDLIN( 110)												while((_g28 < _g29)){
HXDLIN( 110)													_g28 = (_g28 + 1);
HXDLIN( 110)													int i8 = (_g28 - 1);
HXDLIN( 110)													a6->data[i8] = 0;
            												}
            											}
            										}
HXDLIN( 110)										undoImage4 = a6;
            									}
            									break;
            									case (int)2: {
HXDLIN( 110)										 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 110)										 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 110)										{
HXDLIN( 110)											b6->width = width1;
HXDLIN( 110)											b6->height = height1;
HXDLIN( 110)											b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 110)											int size1 = (b6->length * 4);
HXDLIN( 110)											b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 110)											{
HXDLIN( 110)												int _g30 = 0;
HXDLIN( 110)												int _g31 = b6->length;
HXDLIN( 110)												while((_g30 < _g31)){
HXDLIN( 110)													_g30 = (_g30 + 1);
HXDLIN( 110)													int i9 = (_g30 - 1);
HXDLIN( 110)													{
HXDLIN( 110)														 ::haxe::io::ArrayBufferViewImpl this39 = b6->data;
HXDLIN( 110)														bool undoImage5;
HXDLIN( 110)														if ((i9 >= 0)) {
HXDLIN( 110)															undoImage5 = (i9 < (this39->byteLength >> 2));
            														}
            														else {
HXDLIN( 110)															undoImage5 = false;
            														}
HXDLIN( 110)														if (undoImage5) {
HXDLIN( 110)															 ::haxe::io::Bytes _this1 = this39->bytes;
HXDLIN( 110)															int pos1 = ((i9 << 2) + this39->byteOffset);
HXDLIN( 110)															_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 110)															_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 110)															_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 110)															_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN( 110)										undoImage4 = b6;
            									}
            									break;
            									case (int)3: {
HXDLIN( 110)										 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 110)										 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 110)										{
HXDLIN( 110)											v3->width = width1;
HXDLIN( 110)											v3->height = height1;
HXDLIN( 110)											v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 110)											v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 110)											{
HXDLIN( 110)												int _g32 = 0;
HXDLIN( 110)												int _g33 = v3->length;
HXDLIN( 110)												while((_g32 < _g33)){
HXDLIN( 110)													_g32 = (_g32 + 1);
HXDLIN( 110)													int i10 = (_g32 - 1);
HXDLIN( 110)													v3->data->__unsafe_set(i10,0);
            												}
            											}
            										}
HXDLIN( 110)										undoImage4 = v3;
            									}
            									break;
            									case (int)4: {
HXDLIN( 110)										 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 110)										 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 110)										{
HXDLIN( 110)											b7->width = width1;
HXDLIN( 110)											b7->height = height1;
HXDLIN( 110)											b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 110)											b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 110)											{
HXDLIN( 110)												int len3 = b7->length;
HXDLIN( 110)												 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 110)												if (::hx::IsNull( d1->head )) {
HXDLIN( 110)													int _g34 = 0;
HXDLIN( 110)													int _g35 = len3;
HXDLIN( 110)													while((_g34 < _g35)){
HXDLIN( 110)														_g34 = (_g34 + 1);
HXDLIN( 110)														int i11 = (_g34 - 1);
HXDLIN( 110)														d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            													}
            												}
            												else {
HXDLIN( 110)													int _g36 = 0;
HXDLIN( 110)													int _g37 = len3;
HXDLIN( 110)													while((_g36 < _g37)){
HXDLIN( 110)														_g36 = (_g36 + 1);
HXDLIN( 110)														int i12 = (_g36 - 1);
HXDLIN( 110)														{
HXDLIN( 110)															 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 110)															 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 110)															{
HXDLIN( 110)																int _g38 = 0;
HXDLIN( 110)																int _g39 = i12;
HXDLIN( 110)																while((_g38 < _g39)){
HXDLIN( 110)																	_g38 = (_g38 + 1);
HXDLIN( 110)																	int i13 = (_g38 - 1);
HXLINE( 345)																	prev1 = l1;
HXLINE( 346)																	l1 = l1->next;
            																}
            															}
HXLINE( 110)															if (::hx::IsNull( prev1 )) {
HXDLIN( 110)																b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 110)																l1 = null();
            															}
            															else {
HXDLIN( 110)																prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 110)																l1 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 110)										undoImage4 = b7;
            									}
            									break;
            								}
HXDLIN( 110)								this38->image = undoImage4;
HXDLIN( 110)								this38->width = width1;
HXDLIN( 110)								this38->height = height1;
HXDLIN( 110)								this38->imageType = ( (int)(imageType1) );
HXDLIN( 110)								undoImage3 = this38;
HXDLIN( 110)								{
HXDLIN( 110)									int rectLeft1 = xIter31->start;
HXDLIN( 110)									int rectTop1 = yIter31->start;
HXDLIN( 110)									int rectRight1 = xIter31->max;
HXDLIN( 110)									bool forceClear1 = false;
HXDLIN( 110)									{
HXDLIN( 110)										int _g40 = rectTop1;
HXDLIN( 110)										int _g41 = yIter31->max;
HXDLIN( 110)										while((_g40 < _g41)){
HXDLIN( 110)											_g40 = (_g40 + 1);
HXDLIN( 110)											int dy1 = (_g40 - 1);
HXDLIN( 110)											{
HXDLIN( 110)												int _g42 = rectLeft1;
HXDLIN( 110)												int _g43 = rectRight1;
HXDLIN( 110)												while((_g42 < _g43)){
HXDLIN( 110)													_g42 = (_g42 + 1);
HXDLIN( 110)													int dx1 = (_g42 - 1);
HXDLIN( 110)													::Dynamic this40 = this37->image;
HXDLIN( 110)													int index6;
HXDLIN( 110)													if (this37->useVirtualPos) {
HXDLIN( 110)														index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this37->virtualY) * ( (Float)(this37->width) )) + dx1) - this37->virtualX));
            													}
            													else {
HXDLIN( 110)														index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this37->width) + dx1)) ));
            													}
HXDLIN( 110)													int c5 = ::iterMagic::Iimg_obj::get(this40,index6);
HXDLIN( 110)													int col1;
HXDLIN( 110)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 110)														col1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            													}
            													else {
HXDLIN( 110)														col1 = c5;
            													}
HXDLIN( 110)													bool _hx_tmp8;
HXDLIN( 110)													if (this37->useMask) {
HXDLIN( 110)														_hx_tmp8 = ::hx::IsNotNull( this37->mask );
            													}
            													else {
HXDLIN( 110)														_hx_tmp8 = false;
            													}
HXDLIN( 110)													if (_hx_tmp8) {
HXDLIN( 110)														 ::pi_xy::ImageStruct this41 = this37->mask;
HXDLIN( 110)														::Dynamic this42 = this41->image;
HXDLIN( 110)														int index7;
HXDLIN( 110)														if (this41->useVirtualPos) {
HXDLIN( 110)															index7 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this41->virtualY) * ( (Float)(this41->width) )) + dx1) - this41->virtualX));
            														}
            														else {
HXDLIN( 110)															index7 = ::Std_obj::_hx_int(( (Float)(((dy1 * this41->width) + dx1)) ));
            														}
HXDLIN( 110)														int c6 = ::iterMagic::Iimg_obj::get(this42,index7);
HXDLIN( 110)														int v4;
HXDLIN( 110)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 110)															v4 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            														}
            														else {
HXDLIN( 110)															v4 = c6;
            														}
HXDLIN( 110)														int maskPixel1 = v4;
HXDLIN( 110)														int this43 = col1;
HXDLIN( 110)														if ((maskPixel1 == 0)) {
HXDLIN( 110)															col1 = this43;
            														}
            														else {
HXDLIN( 110)															Float m01;
HXDLIN( 110)															int this44 = ((maskPixel1 >> 24) & 255);
HXDLIN( 110)															if ((this44 == 0)) {
HXDLIN( 110)																m01 = ((Float)0.);
            															}
            															else {
HXDLIN( 110)																m01 = (( (Float)(this44) ) / ( (Float)(255) ));
            															}
HXDLIN( 110)															Float m11;
HXDLIN( 110)															int this45 = ((maskPixel1 >> 16) & 255);
HXDLIN( 110)															if ((this45 == 0)) {
HXDLIN( 110)																m11 = ((Float)0.);
            															}
            															else {
HXDLIN( 110)																m11 = (( (Float)(this45) ) / ( (Float)(255) ));
            															}
HXDLIN( 110)															Float m21;
HXDLIN( 110)															int this46 = ((maskPixel1 >> 8) & 255);
HXDLIN( 110)															if ((this46 == 0)) {
HXDLIN( 110)																m21 = ((Float)0.);
            															}
            															else {
HXDLIN( 110)																m21 = (( (Float)(this46) ) / ( (Float)(255) ));
            															}
HXDLIN( 110)															Float m31;
HXDLIN( 110)															int this47 = (maskPixel1 & 255);
HXDLIN( 110)															if ((this47 == 0)) {
HXDLIN( 110)																m31 = ((Float)0.);
            															}
            															else {
HXDLIN( 110)																m31 = (( (Float)(this47) ) / ( (Float)(255) ));
            															}
HXDLIN( 110)															int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this43 >> 24) & 255)) )));
HXDLIN( 110)															int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this43 >> 16) & 255)) )));
HXDLIN( 110)															int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this43 >> 8) & 255)) )));
HXDLIN( 110)															int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this43 & 255)) )));
HXDLIN( 110)															col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN( 110)													if ((col1 != 0)) {
HXDLIN( 110)														int x6 = (dx1 - rectLeft1);
HXDLIN( 110)														int y6 = (dy1 - rectTop1);
HXDLIN( 110)														int c7 = col1;
HXDLIN( 110)														bool _hx_tmp9;
HXDLIN( 110)														if ((((c7 >> 24) & 255) < 254)) {
HXDLIN( 110)															_hx_tmp9 = undoImage3->transparent;
            														}
            														else {
HXDLIN( 110)															_hx_tmp9 = false;
            														}
HXDLIN( 110)														if (_hx_tmp9) {
HXDLIN( 110)															int location2;
HXDLIN( 110)															if (undoImage3->useVirtualPos) {
HXDLIN( 110)																location2 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            															}
            															else {
HXDLIN( 110)																location2 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            															}
HXDLIN( 110)															int this48 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 110)															int this49;
HXDLIN( 110)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 110)																this49 = ((((((this48 >> 24) & 255) << 24) | ((this48 & 255) << 16)) | (((this48 >> 8) & 255) << 8)) | ((this48 >> 16) & 255));
            															}
            															else {
HXDLIN( 110)																this49 = this48;
            															}
HXDLIN( 110)															Float a12;
HXDLIN( 110)															int this50 = ((this49 >> 24) & 255);
HXDLIN( 110)															if ((this50 == 0)) {
HXDLIN( 110)																a12 = ((Float)0.);
            															}
            															else {
HXDLIN( 110)																a12 = (( (Float)(this50) ) / ( (Float)(255) ));
            															}
HXDLIN( 110)															Float r12;
HXDLIN( 110)															int this51 = ((this49 >> 16) & 255);
HXDLIN( 110)															if ((this51 == 0)) {
HXDLIN( 110)																r12 = ((Float)0.);
            															}
            															else {
HXDLIN( 110)																r12 = (( (Float)(this51) ) / ( (Float)(255) ));
            															}
HXDLIN( 110)															Float g12;
HXDLIN( 110)															int this52 = ((this49 >> 8) & 255);
HXDLIN( 110)															if ((this52 == 0)) {
HXDLIN( 110)																g12 = ((Float)0.);
            															}
            															else {
HXDLIN( 110)																g12 = (( (Float)(this52) ) / ( (Float)(255) ));
            															}
HXDLIN( 110)															Float b13;
HXDLIN( 110)															int this53 = (this49 & 255);
HXDLIN( 110)															if ((this53 == 0)) {
HXDLIN( 110)																b13 = ((Float)0.);
            															}
            															else {
HXDLIN( 110)																b13 = (( (Float)(this53) ) / ( (Float)(255) ));
            															}
HXDLIN( 110)															Float a22;
HXDLIN( 110)															int this54 = ((col1 >> 24) & 255);
HXDLIN( 110)															if ((this54 == 0)) {
HXDLIN( 110)																a22 = ((Float)0.);
            															}
            															else {
HXDLIN( 110)																a22 = (( (Float)(this54) ) / ( (Float)(255) ));
            															}
HXDLIN( 110)															Float r22;
HXDLIN( 110)															int this55 = ((col1 >> 16) & 255);
HXDLIN( 110)															if ((this55 == 0)) {
HXDLIN( 110)																r22 = ((Float)0.);
            															}
            															else {
HXDLIN( 110)																r22 = (( (Float)(this55) ) / ( (Float)(255) ));
            															}
HXDLIN( 110)															Float g22;
HXDLIN( 110)															int this56 = ((col1 >> 8) & 255);
HXDLIN( 110)															if ((this56 == 0)) {
HXDLIN( 110)																g22 = ((Float)0.);
            															}
            															else {
HXDLIN( 110)																g22 = (( (Float)(this56) ) / ( (Float)(255) ));
            															}
HXDLIN( 110)															Float b23;
HXDLIN( 110)															int this57 = (col1 & 255);
HXDLIN( 110)															if ((this57 == 0)) {
HXDLIN( 110)																b23 = ((Float)0.);
            															}
            															else {
HXDLIN( 110)																b23 = (( (Float)(this57) ) / ( (Float)(255) ));
            															}
HXDLIN( 110)															Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 110)															int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 110)															int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 110)															int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 110)															int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 110)															int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 110)															{
HXDLIN( 110)																int _hx_tmp10;
HXDLIN( 110)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 110)																	_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																}
            																else {
HXDLIN( 110)																	_hx_tmp10 = blended2;
            																}
HXDLIN( 110)																::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            															}
            														}
            														else {
HXDLIN( 110)															::Dynamic this58 = undoImage3->image;
HXDLIN( 110)															int index8;
HXDLIN( 110)															if (undoImage3->useVirtualPos) {
HXDLIN( 110)																index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            															}
            															else {
HXDLIN( 110)																index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            															}
HXDLIN( 110)															int _hx_tmp11;
HXDLIN( 110)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 110)																_hx_tmp11 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            															}
            															else {
HXDLIN( 110)																_hx_tmp11 = c7;
            															}
HXDLIN( 110)															::iterMagic::Iimg_obj::set(this58,index8,_hx_tmp11);
            														}
            													}
            													else {
HXDLIN( 110)														if (forceClear1) {
HXDLIN( 110)															::Dynamic this59 = undoImage3->image;
HXDLIN( 110)															int x7 = (dx1 - rectLeft1);
HXDLIN( 110)															int y7 = (dy1 - rectTop1);
HXDLIN( 110)															int index9;
HXDLIN( 110)															if (undoImage3->useVirtualPos) {
HXDLIN( 110)																index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x7) - undoImage3->virtualX));
            															}
            															else {
HXDLIN( 110)																index9 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage3->width) + x7)) ));
            															}
HXDLIN( 110)															::iterMagic::Iimg_obj::set(this59,index9,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 110)							bool foundY1 = false;
HXDLIN( 110)							Float s1 = ((Float)0.);
HXDLIN( 110)							Float t1 = ((Float)0.);
HXDLIN( 110)							Float sxx1 = ((Float)0.);
HXDLIN( 110)							Float txx1 = ((Float)0.);
HXDLIN( 110)							{
HXDLIN( 110)								int _g_min2 = xIter31->start;
HXDLIN( 110)								int _g_max2 = xIter31->max;
HXDLIN( 110)								while((_g_min2 < _g_max2)){
HXDLIN( 110)									_g_min2 = (_g_min2 + 1);
HXDLIN( 110)									int x8 = (_g_min2 - 1);
HXLINE( 222)									sxx1 = (sx1 * ( (Float)(x8) ));
HXLINE( 223)									txx1 = (tx1 * ( (Float)(x8) ));
HXLINE( 224)									foundY1 = false;
HXLINE( 110)									{
HXDLIN( 110)										int _g_min3 = yIter31->start;
HXDLIN( 110)										int _g_max3 = yIter31->max;
HXDLIN( 110)										while((_g_min3 < _g_max3)){
HXDLIN( 110)											_g_min3 = (_g_min3 + 1);
HXDLIN( 110)											int y8 = (_g_min3 - 1);
HXLINE( 226)											s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y8) )));
HXLINE( 227)											t1 = ((t01 + txx1) + (ty1 * ( (Float)(y8) )));
HXLINE( 110)											bool _hx_tmp12;
HXDLIN( 110)											if (!((s1 <= 0))) {
HXDLIN( 110)												_hx_tmp12 = (t1 <= 0);
            											}
            											else {
HXDLIN( 110)												_hx_tmp12 = true;
            											}
HXDLIN( 110)											if (_hx_tmp12) {
HXDLIN( 110)												if (foundY1) {
HXDLIN( 110)													goto _hx_goto_180;
            												}
            											}
            											else {
HXDLIN( 110)												if (((s1 + t1) < A1)) {
HXDLIN( 110)													int x9 = ::hx::Mod(x8,tileImage->width);
HXDLIN( 110)													int y9 = ::hx::Mod(y8,tileImage->height);
HXDLIN( 110)													::Dynamic this60 = tileImage->image;
HXDLIN( 110)													int index10;
HXDLIN( 110)													if (tileImage->useVirtualPos) {
HXDLIN( 110)														index10 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x9) - tileImage->virtualX));
            													}
            													else {
HXDLIN( 110)														index10 = ::Std_obj::_hx_int(( (Float)(((y9 * tileImage->width) + x9)) ));
            													}
HXDLIN( 110)													int c8 = ::iterMagic::Iimg_obj::get(this60,index10);
HXDLIN( 110)													int color1;
HXDLIN( 110)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 110)														color1 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            													}
            													else {
HXDLIN( 110)														color1 = c8;
            													}
HXDLIN( 110)													{
HXDLIN( 110)														int c9 = color1;
HXDLIN( 110)														bool _hx_tmp13;
HXDLIN( 110)														if ((((c9 >> 24) & 255) < 254)) {
HXDLIN( 110)															_hx_tmp13 = this37->transparent;
            														}
            														else {
HXDLIN( 110)															_hx_tmp13 = false;
            														}
HXDLIN( 110)														if (_hx_tmp13) {
HXDLIN( 110)															int location3;
HXDLIN( 110)															if (this37->useVirtualPos) {
HXDLIN( 110)																location3 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - this37->virtualY) * ( (Float)(this37->width) )) + x8) - this37->virtualX));
            															}
            															else {
HXDLIN( 110)																location3 = ::Std_obj::_hx_int(( (Float)(((y8 * this37->width) + x8)) ));
            															}
HXDLIN( 110)															int this61 = ::iterMagic::Iimg_obj::get(this37->image,location3);
HXDLIN( 110)															int this62;
HXDLIN( 110)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 110)																this62 = ((((((this61 >> 24) & 255) << 24) | ((this61 & 255) << 16)) | (((this61 >> 8) & 255) << 8)) | ((this61 >> 16) & 255));
            															}
            															else {
HXDLIN( 110)																this62 = this61;
            															}
HXDLIN( 110)															Float a13;
HXDLIN( 110)															int this63 = ((this62 >> 24) & 255);
HXDLIN( 110)															if ((this63 == 0)) {
HXDLIN( 110)																a13 = ((Float)0.);
            															}
            															else {
HXDLIN( 110)																a13 = (( (Float)(this63) ) / ( (Float)(255) ));
            															}
HXDLIN( 110)															Float r13;
HXDLIN( 110)															int this64 = ((this62 >> 16) & 255);
HXDLIN( 110)															if ((this64 == 0)) {
HXDLIN( 110)																r13 = ((Float)0.);
            															}
            															else {
HXDLIN( 110)																r13 = (( (Float)(this64) ) / ( (Float)(255) ));
            															}
HXDLIN( 110)															Float g13;
HXDLIN( 110)															int this65 = ((this62 >> 8) & 255);
HXDLIN( 110)															if ((this65 == 0)) {
HXDLIN( 110)																g13 = ((Float)0.);
            															}
            															else {
HXDLIN( 110)																g13 = (( (Float)(this65) ) / ( (Float)(255) ));
            															}
HXDLIN( 110)															Float b14;
HXDLIN( 110)															int this66 = (this62 & 255);
HXDLIN( 110)															if ((this66 == 0)) {
HXDLIN( 110)																b14 = ((Float)0.);
            															}
            															else {
HXDLIN( 110)																b14 = (( (Float)(this66) ) / ( (Float)(255) ));
            															}
HXDLIN( 110)															Float a23;
HXDLIN( 110)															int this67 = ((color1 >> 24) & 255);
HXDLIN( 110)															if ((this67 == 0)) {
HXDLIN( 110)																a23 = ((Float)0.);
            															}
            															else {
HXDLIN( 110)																a23 = (( (Float)(this67) ) / ( (Float)(255) ));
            															}
HXDLIN( 110)															Float r23;
HXDLIN( 110)															int this68 = ((color1 >> 16) & 255);
HXDLIN( 110)															if ((this68 == 0)) {
HXDLIN( 110)																r23 = ((Float)0.);
            															}
            															else {
HXDLIN( 110)																r23 = (( (Float)(this68) ) / ( (Float)(255) ));
            															}
HXDLIN( 110)															Float g23;
HXDLIN( 110)															int this69 = ((color1 >> 8) & 255);
HXDLIN( 110)															if ((this69 == 0)) {
HXDLIN( 110)																g23 = ((Float)0.);
            															}
            															else {
HXDLIN( 110)																g23 = (( (Float)(this69) ) / ( (Float)(255) ));
            															}
HXDLIN( 110)															Float b24;
HXDLIN( 110)															int this70 = (color1 & 255);
HXDLIN( 110)															if ((this70 == 0)) {
HXDLIN( 110)																b24 = ((Float)0.);
            															}
            															else {
HXDLIN( 110)																b24 = (( (Float)(this70) ) / ( (Float)(255) ));
            															}
HXDLIN( 110)															Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 110)															int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 110)															int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 110)															int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 110)															int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 110)															int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 110)															{
HXDLIN( 110)																int _hx_tmp14;
HXDLIN( 110)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 110)																	_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																}
            																else {
HXDLIN( 110)																	_hx_tmp14 = blended3;
            																}
HXDLIN( 110)																::iterMagic::Iimg_obj::set(this37->image,location3,_hx_tmp14);
            															}
            														}
            														else {
HXDLIN( 110)															::Dynamic this71 = this37->image;
HXDLIN( 110)															int index11;
HXDLIN( 110)															if (this37->useVirtualPos) {
HXDLIN( 110)																index11 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - this37->virtualY) * ( (Float)(this37->width) )) + x8) - this37->virtualX));
            															}
            															else {
HXDLIN( 110)																index11 = ::Std_obj::_hx_int(( (Float)(((y8 * this37->width) + x8)) ));
            															}
HXDLIN( 110)															int _hx_tmp15;
HXDLIN( 110)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 110)																_hx_tmp15 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            															}
            															else {
HXDLIN( 110)																_hx_tmp15 = c9;
            															}
HXDLIN( 110)															::iterMagic::Iimg_obj::set(this71,index11,_hx_tmp15);
            														}
            													}
HXLINE( 236)													foundY1 = true;
            												}
            												else {
HXDLIN( 110)													if (foundY1) {
HXDLIN( 110)														goto _hx_goto_180;
            													}
            												}
            											}
            										}
            										_hx_goto_180:;
            									}
            								}
            							}
HXDLIN( 110)							if ((hasHit1 == false)) {
HXDLIN( 110)								 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN( 110)								if (hasUndo1) {
HXDLIN( 110)									v5->undoImage = undoImage3;
HXDLIN( 110)									v5->undoX = xIter31->start;
HXDLIN( 110)									v5->undoY = yIter31->start;
            								}
            							}
            						}
            					}
            				}
HXLINE(  93)				lastX = nextX1;
HXLINE(  94)				lastY = nextY1;
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(TileShape_Impl__obj,quadrantI,(void))

void TileShape_Impl__obj::quadrantII( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float rx,Float ry, ::pi_xy::ImageStruct tileImage, ::Dynamic __o_phi){
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = ((Float)0.);
            	HX_GC_STACKFRAME(&_hx_pos_6e4d7718bf84d356_123_quadrantII)
HXDLIN( 123)		 ::Dynamic targetError = ((Float)1.05);
HXDLIN( 123)		if (::hx::IsNull( targetError )) {
HXLINE( 101)			targetError = ((Float)1.05);
            		}
HXLINE( 123)		Float rSmall;
HXDLIN( 123)		if ((rx > ry)) {
HXDLIN( 123)			rSmall = ry;
            		}
            		else {
HXDLIN( 123)			rSmall = rx;
            		}
HXDLIN( 123)		 ::Dynamic targetE = ( (Float)(targetError) );
HXDLIN( 123)		if (::hx::IsNull( targetE )) {
HXLINE(  20)			targetE = ((Float)1.05);
            		}
HXLINE( 123)		int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN( 123)		int noSides;
HXDLIN( 123)		if ((result < 12)) {
HXDLIN( 123)			noSides = 12;
            		}
            		else {
HXDLIN( 123)			if ((result > 500)) {
HXDLIN( 123)				noSides = 500;
            			}
            			else {
HXDLIN( 123)				noSides = result;
            			}
            		}
HXDLIN( 123)		int sides = (::Math_obj::ceil((( (Float)(noSides) ) / ( (Float)(4) ))) * 4);
HXDLIN( 123)		Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides) ));
HXDLIN( 123)		Float omega = ::Math_obj::PI;
HXDLIN( 123)		int quarter = ::Std_obj::_hx_int((( (Float)(sides) ) / ( (Float)(4) )));
HXDLIN( 123)		Float lastX = ((Float)0.);
HXDLIN( 123)		Float lastY = ((Float)0.);
HXDLIN( 123)		if (::hx::IsNotEq( phi,0 )) {
HXLINE(  70)			lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) )))) + cx);
HXLINE(  71)			lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) )))) + cy);
            		}
            		else {
HXLINE(  73)			lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))));
HXLINE(  74)			lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))));
            		}
HXLINE( 123)		if (::hx::IsNotEq( phi,0 )) {
HXDLIN( 123)			Float cphi = ::Math_obj::cos(( (Float)(phi) ));
HXDLIN( 123)			Float sphi = ::Math_obj::sin(( (Float)(phi) ));
HXDLIN( 123)			{
HXDLIN( 123)				int _g = 0;
HXDLIN( 123)				int _g1 = (quarter + 1);
HXDLIN( 123)				while((_g < _g1)){
HXDLIN( 123)					_g = (_g + 1);
HXDLIN( 123)					int i = (_g - 1);
HXDLIN( 123)					Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega));
HXDLIN( 123)					Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega));
HXDLIN( 123)					Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXDLIN( 123)					Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXDLIN( 123)					{
HXDLIN( 123)						 ::pi_xy::ImageStruct this2 = this1;
HXDLIN( 123)						bool hasHit = false;
HXDLIN( 123)						{
HXDLIN( 123)							Float bx = lastX;
HXDLIN( 123)							Float by = lastY;
HXDLIN( 123)							Float cx1 = nextX;
HXDLIN( 123)							Float cy1 = nextY;
HXDLIN( 123)							bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN( 123)							if (!(adjustWinding)) {
HXDLIN( 123)								Float bx_ = bx;
HXDLIN( 123)								Float by_ = by;
HXLINE( 187)								bx = cx1;
HXLINE( 188)								by = cy1;
HXLINE( 189)								cx1 = bx_;
HXLINE( 190)								cy1 = by_;
            							}
HXLINE( 123)							{
HXDLIN( 123)								bool hasUndo = false;
HXDLIN( 123)								Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN( 123)								Float sx = (cy1 - cy);
HXDLIN( 123)								Float sy = (cx - cx1);
HXDLIN( 123)								Float t0 = ((cx * by) - (cy * bx));
HXDLIN( 123)								Float tx = (cy - by);
HXDLIN( 123)								Float ty = (bx - cx);
HXDLIN( 123)								Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN( 123)								 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 123)								if ((cx > bx)) {
HXDLIN( 123)									if ((cx > cx1)) {
HXDLIN( 123)										int min;
HXDLIN( 123)										if ((bx > cx1)) {
HXDLIN( 123)											min = ::Math_obj::floor(cx1);
            										}
            										else {
HXDLIN( 123)											min = ::Math_obj::floor(bx);
            										}
HXDLIN( 123)										int ii_min = min;
HXDLIN( 123)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 123)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            									}
            									else {
HXDLIN( 123)										int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 123)										int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 123)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            									}
            								}
            								else {
HXDLIN( 123)									if ((bx > cx1)) {
HXDLIN( 123)										int min1;
HXDLIN( 123)										if ((cx > cx1)) {
HXDLIN( 123)											min1 = ::Math_obj::floor(cx1);
            										}
            										else {
HXDLIN( 123)											min1 = ::Math_obj::ceil(cx);
            										}
HXDLIN( 123)										int ii_min2 = min1;
HXDLIN( 123)										int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 123)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            									}
            									else {
HXDLIN( 123)										int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 123)										int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 123)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            									}
            								}
HXDLIN( 123)								 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 123)								if ((cy > by)) {
HXDLIN( 123)									if ((cy > cy1)) {
HXDLIN( 123)										int min2;
HXDLIN( 123)										if ((by > cy1)) {
HXDLIN( 123)											min2 = ::Math_obj::floor(cy1);
            										}
            										else {
HXDLIN( 123)											min2 = ::Math_obj::floor(by);
            										}
HXDLIN( 123)										int ii_min4 = min2;
HXDLIN( 123)										int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 123)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            									}
            									else {
HXDLIN( 123)										int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 123)										int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 123)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            									}
            								}
            								else {
HXDLIN( 123)									if ((by > cy1)) {
HXDLIN( 123)										int min3;
HXDLIN( 123)										if ((cy > cy1)) {
HXDLIN( 123)											min3 = ::Math_obj::floor(cy1);
            										}
            										else {
HXDLIN( 123)											min3 = ::Math_obj::ceil(cy);
            										}
HXDLIN( 123)										int ii_min6 = min3;
HXDLIN( 123)										int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 123)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            									}
            									else {
HXDLIN( 123)										int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 123)										int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 123)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            									}
            								}
HXDLIN( 123)								 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 123)								if (hasUndo) {
HXDLIN( 123)									int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 123)									int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 123)									 ::Dynamic imageType = null();
HXDLIN( 123)									 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 123)									if (::hx::IsNull( imageType )) {
HXLINE(  54)										imageType = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 123)									::Dynamic undoImage1;
HXDLIN( 123)									switch((int)(( (int)(imageType) ))){
            										case (int)0: {
HXDLIN( 123)											 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 123)											 ::iterMagic::BytesImg b = byt;
HXDLIN( 123)											{
HXDLIN( 123)												b->width = width;
HXDLIN( 123)												b->height = height;
HXDLIN( 123)												b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 123)												b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 123)												{
HXDLIN( 123)													int len = b->length;
HXDLIN( 123)													int w = 0;
HXDLIN( 123)													{
HXDLIN( 123)														int _g2 = 0;
HXDLIN( 123)														int _g3 = b->height;
HXDLIN( 123)														while((_g2 < _g3)){
HXDLIN( 123)															_g2 = (_g2 + 1);
HXDLIN( 123)															int y = (_g2 - 1);
HXDLIN( 123)															{
HXDLIN( 123)																int _g4 = 0;
HXDLIN( 123)																int _g5 = b->width;
HXDLIN( 123)																while((_g4 < _g5)){
HXDLIN( 123)																	_g4 = (_g4 + 1);
HXDLIN( 123)																	int x = (_g4 - 1);
HXDLIN( 123)																	{
HXDLIN( 123)																		w = (w + 1);
HXDLIN( 123)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 123)																	{
HXDLIN( 123)																		w = (w + 1);
HXDLIN( 123)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 123)																	{
HXDLIN( 123)																		w = (w + 1);
HXDLIN( 123)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 123)																	{
HXDLIN( 123)																		w = (w + 1);
HXDLIN( 123)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 123)											undoImage1 = b;
            										}
            										break;
            										case (int)1: {
HXDLIN( 123)											 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 123)											 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 123)											{
HXDLIN( 123)												a->width = width;
HXDLIN( 123)												a->height = height;
HXDLIN( 123)												a->data = ::Array_obj< int >::__new(0);
HXDLIN( 123)												a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 123)												{
HXDLIN( 123)													int _g6 = 0;
HXDLIN( 123)													int _g7 = a->length;
HXDLIN( 123)													while((_g6 < _g7)){
HXDLIN( 123)														_g6 = (_g6 + 1);
HXDLIN( 123)														int i1 = (_g6 - 1);
HXDLIN( 123)														a->data[i1] = 0;
            													}
            												}
            											}
HXDLIN( 123)											undoImage1 = a;
            										}
            										break;
            										case (int)2: {
HXDLIN( 123)											 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 123)											 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 123)											{
HXDLIN( 123)												b1->width = width;
HXDLIN( 123)												b1->height = height;
HXDLIN( 123)												b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 123)												int size = (b1->length * 4);
HXDLIN( 123)												b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 123)												{
HXDLIN( 123)													int _g8 = 0;
HXDLIN( 123)													int _g9 = b1->length;
HXDLIN( 123)													while((_g8 < _g9)){
HXDLIN( 123)														_g8 = (_g8 + 1);
HXDLIN( 123)														int i2 = (_g8 - 1);
HXDLIN( 123)														{
HXDLIN( 123)															 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN( 123)															bool undoImage2;
HXDLIN( 123)															if ((i2 >= 0)) {
HXDLIN( 123)																undoImage2 = (i2 < (this4->byteLength >> 2));
            															}
            															else {
HXDLIN( 123)																undoImage2 = false;
            															}
HXDLIN( 123)															if (undoImage2) {
HXDLIN( 123)																 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN( 123)																int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN( 123)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 123)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 123)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 123)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 123)											undoImage1 = b1;
            										}
            										break;
            										case (int)3: {
HXDLIN( 123)											 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 123)											 ::iterMagic::VecIntImg v = vec;
HXDLIN( 123)											{
HXDLIN( 123)												v->width = width;
HXDLIN( 123)												v->height = height;
HXDLIN( 123)												v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 123)												v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 123)												{
HXDLIN( 123)													int _g10 = 0;
HXDLIN( 123)													int _g11 = v->length;
HXDLIN( 123)													while((_g10 < _g11)){
HXDLIN( 123)														_g10 = (_g10 + 1);
HXDLIN( 123)														int i3 = (_g10 - 1);
HXDLIN( 123)														v->data->__unsafe_set(i3,0);
            													}
            												}
            											}
HXDLIN( 123)											undoImage1 = v;
            										}
            										break;
            										case (int)4: {
HXDLIN( 123)											 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 123)											 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 123)											{
HXDLIN( 123)												b2->width = width;
HXDLIN( 123)												b2->height = height;
HXDLIN( 123)												b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 123)												b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 123)												{
HXDLIN( 123)													int len1 = b2->length;
HXDLIN( 123)													 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 123)													if (::hx::IsNull( d->head )) {
HXDLIN( 123)														int _g12 = 0;
HXDLIN( 123)														int _g13 = len1;
HXDLIN( 123)														while((_g12 < _g13)){
HXDLIN( 123)															_g12 = (_g12 + 1);
HXDLIN( 123)															int i4 = (_g12 - 1);
HXDLIN( 123)															d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            														}
            													}
            													else {
HXDLIN( 123)														int _g14 = 0;
HXDLIN( 123)														int _g15 = len1;
HXDLIN( 123)														while((_g14 < _g15)){
HXDLIN( 123)															_g14 = (_g14 + 1);
HXDLIN( 123)															int i5 = (_g14 - 1);
HXDLIN( 123)															{
HXDLIN( 123)																 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 123)																 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 123)																{
HXDLIN( 123)																	int _g16 = 0;
HXDLIN( 123)																	int _g17 = i5;
HXDLIN( 123)																	while((_g16 < _g17)){
HXDLIN( 123)																		_g16 = (_g16 + 1);
HXDLIN( 123)																		int i6 = (_g16 - 1);
HXLINE( 345)																		prev = l;
HXLINE( 346)																		l = l->next;
            																	}
            																}
HXLINE( 123)																if (::hx::IsNull( prev )) {
HXDLIN( 123)																	b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 123)																	l = null();
            																}
            																else {
HXDLIN( 123)																	prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 123)																	l = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 123)											undoImage1 = b2;
            										}
            										break;
            									}
HXDLIN( 123)									this3->image = undoImage1;
HXDLIN( 123)									this3->width = width;
HXDLIN( 123)									this3->height = height;
HXDLIN( 123)									this3->imageType = ( (int)(imageType) );
HXDLIN( 123)									undoImage = this3;
HXDLIN( 123)									{
HXDLIN( 123)										int rectLeft = xIter3->start;
HXDLIN( 123)										int rectTop = yIter3->start;
HXDLIN( 123)										int rectRight = xIter3->max;
HXDLIN( 123)										bool forceClear = false;
HXDLIN( 123)										{
HXDLIN( 123)											int _g18 = rectTop;
HXDLIN( 123)											int _g19 = yIter3->max;
HXDLIN( 123)											while((_g18 < _g19)){
HXDLIN( 123)												_g18 = (_g18 + 1);
HXDLIN( 123)												int dy = (_g18 - 1);
HXDLIN( 123)												{
HXDLIN( 123)													int _g20 = rectLeft;
HXDLIN( 123)													int _g21 = rectRight;
HXDLIN( 123)													while((_g20 < _g21)){
HXDLIN( 123)														_g20 = (_g20 + 1);
HXDLIN( 123)														int dx = (_g20 - 1);
HXDLIN( 123)														::Dynamic this5 = this2->image;
HXDLIN( 123)														int index;
HXDLIN( 123)														if (this2->useVirtualPos) {
HXDLIN( 123)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            														}
            														else {
HXDLIN( 123)															index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            														}
HXDLIN( 123)														int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN( 123)														int col;
HXDLIN( 123)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 123)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXDLIN( 123)															col = c;
            														}
HXDLIN( 123)														bool _hx_tmp;
HXDLIN( 123)														if (this2->useMask) {
HXDLIN( 123)															_hx_tmp = ::hx::IsNotNull( this2->mask );
            														}
            														else {
HXDLIN( 123)															_hx_tmp = false;
            														}
HXDLIN( 123)														if (_hx_tmp) {
HXDLIN( 123)															 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN( 123)															::Dynamic this7 = this6->image;
HXDLIN( 123)															int index1;
HXDLIN( 123)															if (this6->useVirtualPos) {
HXDLIN( 123)																index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            															}
            															else {
HXDLIN( 123)																index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            															}
HXDLIN( 123)															int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN( 123)															int v1;
HXDLIN( 123)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 123)																v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            															}
            															else {
HXDLIN( 123)																v1 = c1;
            															}
HXDLIN( 123)															int maskPixel = v1;
HXDLIN( 123)															int this8 = col;
HXDLIN( 123)															if ((maskPixel == 0)) {
HXDLIN( 123)																col = this8;
            															}
            															else {
HXDLIN( 123)																Float m0;
HXDLIN( 123)																int this9 = ((maskPixel >> 24) & 255);
HXDLIN( 123)																if ((this9 == 0)) {
HXDLIN( 123)																	m0 = ((Float)0.);
            																}
            																else {
HXDLIN( 123)																	m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN( 123)																Float m1;
HXDLIN( 123)																int this10 = ((maskPixel >> 16) & 255);
HXDLIN( 123)																if ((this10 == 0)) {
HXDLIN( 123)																	m1 = ((Float)0.);
            																}
            																else {
HXDLIN( 123)																	m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN( 123)																Float m2;
HXDLIN( 123)																int this11 = ((maskPixel >> 8) & 255);
HXDLIN( 123)																if ((this11 == 0)) {
HXDLIN( 123)																	m2 = ((Float)0.);
            																}
            																else {
HXDLIN( 123)																	m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN( 123)																Float m3;
HXDLIN( 123)																int this12 = (maskPixel & 255);
HXDLIN( 123)																if ((this12 == 0)) {
HXDLIN( 123)																	m3 = ((Float)0.);
            																}
            																else {
HXDLIN( 123)																	m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN( 123)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN( 123)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN( 123)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN( 123)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN( 123)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 123)														if ((col != 0)) {
HXDLIN( 123)															int x1 = (dx - rectLeft);
HXDLIN( 123)															int y1 = (dy - rectTop);
HXDLIN( 123)															int c2 = col;
HXDLIN( 123)															bool _hx_tmp1;
HXDLIN( 123)															if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 123)																_hx_tmp1 = undoImage->transparent;
            															}
            															else {
HXDLIN( 123)																_hx_tmp1 = false;
            															}
HXDLIN( 123)															if (_hx_tmp1) {
HXDLIN( 123)																int location;
HXDLIN( 123)																if (undoImage->useVirtualPos) {
HXDLIN( 123)																	location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXDLIN( 123)																	location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN( 123)																int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 123)																int this14;
HXDLIN( 123)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 123)																	this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																}
            																else {
HXDLIN( 123)																	this14 = this13;
            																}
HXDLIN( 123)																Float a1;
HXDLIN( 123)																int this15 = ((this14 >> 24) & 255);
HXDLIN( 123)																if ((this15 == 0)) {
HXDLIN( 123)																	a1 = ((Float)0.);
            																}
            																else {
HXDLIN( 123)																	a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																}
HXDLIN( 123)																Float r1;
HXDLIN( 123)																int this16 = ((this14 >> 16) & 255);
HXDLIN( 123)																if ((this16 == 0)) {
HXDLIN( 123)																	r1 = ((Float)0.);
            																}
            																else {
HXDLIN( 123)																	r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																}
HXDLIN( 123)																Float g1;
HXDLIN( 123)																int this17 = ((this14 >> 8) & 255);
HXDLIN( 123)																if ((this17 == 0)) {
HXDLIN( 123)																	g1 = ((Float)0.);
            																}
            																else {
HXDLIN( 123)																	g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																}
HXDLIN( 123)																Float b11;
HXDLIN( 123)																int this18 = (this14 & 255);
HXDLIN( 123)																if ((this18 == 0)) {
HXDLIN( 123)																	b11 = ((Float)0.);
            																}
            																else {
HXDLIN( 123)																	b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																}
HXDLIN( 123)																Float a2;
HXDLIN( 123)																int this19 = ((col >> 24) & 255);
HXDLIN( 123)																if ((this19 == 0)) {
HXDLIN( 123)																	a2 = ((Float)0.);
            																}
            																else {
HXDLIN( 123)																	a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																}
HXDLIN( 123)																Float r2;
HXDLIN( 123)																int this20 = ((col >> 16) & 255);
HXDLIN( 123)																if ((this20 == 0)) {
HXDLIN( 123)																	r2 = ((Float)0.);
            																}
            																else {
HXDLIN( 123)																	r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																}
HXDLIN( 123)																Float g2;
HXDLIN( 123)																int this21 = ((col >> 8) & 255);
HXDLIN( 123)																if ((this21 == 0)) {
HXDLIN( 123)																	g2 = ((Float)0.);
            																}
            																else {
HXDLIN( 123)																	g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																}
HXDLIN( 123)																Float b21;
HXDLIN( 123)																int this22 = (col & 255);
HXDLIN( 123)																if ((this22 == 0)) {
HXDLIN( 123)																	b21 = ((Float)0.);
            																}
            																else {
HXDLIN( 123)																	b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																}
HXDLIN( 123)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 123)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 123)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 123)																int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 123)																int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 123)																int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 123)																{
HXDLIN( 123)																	int _hx_tmp2;
HXDLIN( 123)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 123)																		_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXDLIN( 123)																		_hx_tmp2 = blended;
            																	}
HXDLIN( 123)																	::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																}
            															}
            															else {
HXDLIN( 123)																::Dynamic this23 = undoImage->image;
HXDLIN( 123)																int index2;
HXDLIN( 123)																if (undoImage->useVirtualPos) {
HXDLIN( 123)																	index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXDLIN( 123)																	index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN( 123)																int _hx_tmp3;
HXDLIN( 123)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 123)																	_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																}
            																else {
HXDLIN( 123)																	_hx_tmp3 = c2;
            																}
HXDLIN( 123)																::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            															}
            														}
            														else {
HXDLIN( 123)															if (forceClear) {
HXDLIN( 123)																::Dynamic this24 = undoImage->image;
HXDLIN( 123)																int x2 = (dx - rectLeft);
HXDLIN( 123)																int y2 = (dy - rectTop);
HXDLIN( 123)																int index3;
HXDLIN( 123)																if (undoImage->useVirtualPos) {
HXDLIN( 123)																	index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																}
            																else {
HXDLIN( 123)																	index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																}
HXDLIN( 123)																::iterMagic::Iimg_obj::set(this24,index3,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 123)								bool foundY = false;
HXDLIN( 123)								Float s = ((Float)0.);
HXDLIN( 123)								Float t = ((Float)0.);
HXDLIN( 123)								Float sxx = ((Float)0.);
HXDLIN( 123)								Float txx = ((Float)0.);
HXDLIN( 123)								{
HXDLIN( 123)									int _g_min = xIter3->start;
HXDLIN( 123)									int _g_max = xIter3->max;
HXDLIN( 123)									while((_g_min < _g_max)){
HXDLIN( 123)										_g_min = (_g_min + 1);
HXDLIN( 123)										int x3 = (_g_min - 1);
HXLINE( 222)										sxx = (sx * ( (Float)(x3) ));
HXLINE( 223)										txx = (tx * ( (Float)(x3) ));
HXLINE( 224)										foundY = false;
HXLINE( 123)										{
HXDLIN( 123)											int _g_min1 = yIter3->start;
HXDLIN( 123)											int _g_max1 = yIter3->max;
HXDLIN( 123)											while((_g_min1 < _g_max1)){
HXDLIN( 123)												_g_min1 = (_g_min1 + 1);
HXDLIN( 123)												int y3 = (_g_min1 - 1);
HXLINE( 226)												s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE( 227)												t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 123)												bool _hx_tmp4;
HXDLIN( 123)												if (!((s <= 0))) {
HXDLIN( 123)													_hx_tmp4 = (t <= 0);
            												}
            												else {
HXDLIN( 123)													_hx_tmp4 = true;
            												}
HXDLIN( 123)												if (_hx_tmp4) {
HXDLIN( 123)													if (foundY) {
HXDLIN( 123)														goto _hx_goto_194;
            													}
            												}
            												else {
HXDLIN( 123)													if (((s + t) < A)) {
HXDLIN( 123)														int x4 = ::hx::Mod(x3,tileImage->width);
HXDLIN( 123)														int y4 = ::hx::Mod(y3,tileImage->height);
HXDLIN( 123)														::Dynamic this25 = tileImage->image;
HXDLIN( 123)														int index4;
HXDLIN( 123)														if (tileImage->useVirtualPos) {
HXDLIN( 123)															index4 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x4) - tileImage->virtualX));
            														}
            														else {
HXDLIN( 123)															index4 = ::Std_obj::_hx_int(( (Float)(((y4 * tileImage->width) + x4)) ));
            														}
HXDLIN( 123)														int c3 = ::iterMagic::Iimg_obj::get(this25,index4);
HXDLIN( 123)														int color;
HXDLIN( 123)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 123)															color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            														}
            														else {
HXDLIN( 123)															color = c3;
            														}
HXDLIN( 123)														{
HXDLIN( 123)															int c4 = color;
HXDLIN( 123)															bool _hx_tmp5;
HXDLIN( 123)															if ((((c4 >> 24) & 255) < 254)) {
HXDLIN( 123)																_hx_tmp5 = this2->transparent;
            															}
            															else {
HXDLIN( 123)																_hx_tmp5 = false;
            															}
HXDLIN( 123)															if (_hx_tmp5) {
HXDLIN( 123)																int location1;
HXDLIN( 123)																if (this2->useVirtualPos) {
HXDLIN( 123)																	location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																}
            																else {
HXDLIN( 123)																	location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																}
HXDLIN( 123)																int this26 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN( 123)																int this27;
HXDLIN( 123)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 123)																	this27 = ((((((this26 >> 24) & 255) << 24) | ((this26 & 255) << 16)) | (((this26 >> 8) & 255) << 8)) | ((this26 >> 16) & 255));
            																}
            																else {
HXDLIN( 123)																	this27 = this26;
            																}
HXDLIN( 123)																Float a11;
HXDLIN( 123)																int this28 = ((this27 >> 24) & 255);
HXDLIN( 123)																if ((this28 == 0)) {
HXDLIN( 123)																	a11 = ((Float)0.);
            																}
            																else {
HXDLIN( 123)																	a11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																}
HXDLIN( 123)																Float r11;
HXDLIN( 123)																int this29 = ((this27 >> 16) & 255);
HXDLIN( 123)																if ((this29 == 0)) {
HXDLIN( 123)																	r11 = ((Float)0.);
            																}
            																else {
HXDLIN( 123)																	r11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																}
HXDLIN( 123)																Float g11;
HXDLIN( 123)																int this30 = ((this27 >> 8) & 255);
HXDLIN( 123)																if ((this30 == 0)) {
HXDLIN( 123)																	g11 = ((Float)0.);
            																}
            																else {
HXDLIN( 123)																	g11 = (( (Float)(this30) ) / ( (Float)(255) ));
            																}
HXDLIN( 123)																Float b12;
HXDLIN( 123)																int this31 = (this27 & 255);
HXDLIN( 123)																if ((this31 == 0)) {
HXDLIN( 123)																	b12 = ((Float)0.);
            																}
            																else {
HXDLIN( 123)																	b12 = (( (Float)(this31) ) / ( (Float)(255) ));
            																}
HXDLIN( 123)																Float a21;
HXDLIN( 123)																int this32 = ((color >> 24) & 255);
HXDLIN( 123)																if ((this32 == 0)) {
HXDLIN( 123)																	a21 = ((Float)0.);
            																}
            																else {
HXDLIN( 123)																	a21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																}
HXDLIN( 123)																Float r21;
HXDLIN( 123)																int this33 = ((color >> 16) & 255);
HXDLIN( 123)																if ((this33 == 0)) {
HXDLIN( 123)																	r21 = ((Float)0.);
            																}
            																else {
HXDLIN( 123)																	r21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																}
HXDLIN( 123)																Float g21;
HXDLIN( 123)																int this34 = ((color >> 8) & 255);
HXDLIN( 123)																if ((this34 == 0)) {
HXDLIN( 123)																	g21 = ((Float)0.);
            																}
            																else {
HXDLIN( 123)																	g21 = (( (Float)(this34) ) / ( (Float)(255) ));
            																}
HXDLIN( 123)																Float b22;
HXDLIN( 123)																int this35 = (color & 255);
HXDLIN( 123)																if ((this35 == 0)) {
HXDLIN( 123)																	b22 = ((Float)0.);
            																}
            																else {
HXDLIN( 123)																	b22 = (( (Float)(this35) ) / ( (Float)(255) ));
            																}
HXDLIN( 123)																Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 123)																int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 123)																int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 123)																int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 123)																int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 123)																int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 123)																{
HXDLIN( 123)																	int _hx_tmp6;
HXDLIN( 123)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 123)																		_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 123)																		_hx_tmp6 = blended1;
            																	}
HXDLIN( 123)																	::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp6);
            																}
            															}
            															else {
HXDLIN( 123)																::Dynamic this36 = this2->image;
HXDLIN( 123)																int index5;
HXDLIN( 123)																if (this2->useVirtualPos) {
HXDLIN( 123)																	index5 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																}
            																else {
HXDLIN( 123)																	index5 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																}
HXDLIN( 123)																int _hx_tmp7;
HXDLIN( 123)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 123)																	_hx_tmp7 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            																}
            																else {
HXDLIN( 123)																	_hx_tmp7 = c4;
            																}
HXDLIN( 123)																::iterMagic::Iimg_obj::set(this36,index5,_hx_tmp7);
            															}
            														}
HXLINE( 236)														foundY = true;
            													}
            													else {
HXDLIN( 123)														if (foundY) {
HXDLIN( 123)															goto _hx_goto_194;
            														}
            													}
            												}
            											}
            											_hx_goto_194:;
            										}
            									}
            								}
HXDLIN( 123)								if ((hasHit == false)) {
HXDLIN( 123)									 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN( 123)									if (hasUndo) {
HXDLIN( 123)										v2->undoImage = undoImage;
HXDLIN( 123)										v2->undoX = xIter3->start;
HXDLIN( 123)										v2->undoY = yIter3->start;
            									}
            								}
            							}
            						}
            					}
HXLINE(  85)					lastX = nextX;
HXLINE(  86)					lastY = nextY;
            				}
            			}
            		}
            		else {
HXDLIN( 123)			int _g22 = 0;
HXDLIN( 123)			int _g23 = (quarter + 1);
HXDLIN( 123)			while((_g22 < _g23)){
HXDLIN( 123)				_g22 = (_g22 + 1);
HXDLIN( 123)				int i7 = (_g22 - 1);
HXDLIN( 123)				Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN( 123)				Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN( 123)				{
HXDLIN( 123)					 ::pi_xy::ImageStruct this37 = this1;
HXDLIN( 123)					bool hasHit1 = false;
HXDLIN( 123)					{
HXDLIN( 123)						Float bx1 = lastX;
HXDLIN( 123)						Float by1 = lastY;
HXDLIN( 123)						Float cx2 = nextX1;
HXDLIN( 123)						Float cy2 = nextY1;
HXDLIN( 123)						bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN( 123)						if (!(adjustWinding1)) {
HXDLIN( 123)							Float bx_1 = bx1;
HXDLIN( 123)							Float by_1 = by1;
HXLINE( 187)							bx1 = cx2;
HXLINE( 188)							by1 = cy2;
HXLINE( 189)							cx2 = bx_1;
HXLINE( 190)							cy2 = by_1;
            						}
HXLINE( 123)						{
HXDLIN( 123)							bool hasUndo1 = false;
HXDLIN( 123)							Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN( 123)							Float sx1 = (cy2 - cy);
HXDLIN( 123)							Float sy1 = (cx - cx2);
HXDLIN( 123)							Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN( 123)							Float tx1 = (cy - by1);
HXDLIN( 123)							Float ty1 = (bx1 - cx);
HXDLIN( 123)							Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN( 123)							 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 123)							if ((cx > bx1)) {
HXDLIN( 123)								if ((cx > cx2)) {
HXDLIN( 123)									int min4;
HXDLIN( 123)									if ((bx1 > cx2)) {
HXDLIN( 123)										min4 = ::Math_obj::floor(cx2);
            									}
            									else {
HXDLIN( 123)										min4 = ::Math_obj::floor(bx1);
            									}
HXDLIN( 123)									int ii_min8 = min4;
HXDLIN( 123)									int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN( 123)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            								}
            								else {
HXDLIN( 123)									int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 123)									int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 123)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            								}
            							}
            							else {
HXDLIN( 123)								if ((bx1 > cx2)) {
HXDLIN( 123)									int min5;
HXDLIN( 123)									if ((cx > cx2)) {
HXDLIN( 123)										min5 = ::Math_obj::floor(cx2);
            									}
            									else {
HXDLIN( 123)										min5 = ::Math_obj::ceil(cx);
            									}
HXDLIN( 123)									int ii_min10 = min5;
HXDLIN( 123)									int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 123)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            								}
            								else {
HXDLIN( 123)									int ii_min11 = ::Math_obj::floor(cx);
HXDLIN( 123)									int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 123)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            								}
            							}
HXDLIN( 123)							 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 123)							if ((cy > by1)) {
HXDLIN( 123)								if ((cy > cy2)) {
HXDLIN( 123)									int min6;
HXDLIN( 123)									if ((by1 > cy2)) {
HXDLIN( 123)										min6 = ::Math_obj::floor(cy2);
            									}
            									else {
HXDLIN( 123)										min6 = ::Math_obj::floor(by1);
            									}
HXDLIN( 123)									int ii_min12 = min6;
HXDLIN( 123)									int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN( 123)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            								}
            								else {
HXDLIN( 123)									int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 123)									int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 123)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            								}
            							}
            							else {
HXDLIN( 123)								if ((by1 > cy2)) {
HXDLIN( 123)									int min7;
HXDLIN( 123)									if ((cy > cy2)) {
HXDLIN( 123)										min7 = ::Math_obj::floor(cy2);
            									}
            									else {
HXDLIN( 123)										min7 = ::Math_obj::ceil(cy);
            									}
HXDLIN( 123)									int ii_min14 = min7;
HXDLIN( 123)									int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 123)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            								}
            								else {
HXDLIN( 123)									int ii_min15 = ::Math_obj::floor(cy);
HXDLIN( 123)									int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 123)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            								}
            							}
HXDLIN( 123)							 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 123)							if (hasUndo1) {
HXDLIN( 123)								int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 123)								int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 123)								 ::Dynamic imageType1 = null();
HXDLIN( 123)								 ::pi_xy::ImageStruct this38 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 123)								if (::hx::IsNull( imageType1 )) {
HXLINE(  54)									imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE( 123)								::Dynamic undoImage4;
HXDLIN( 123)								switch((int)(( (int)(imageType1) ))){
            									case (int)0: {
HXDLIN( 123)										 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 123)										 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 123)										{
HXDLIN( 123)											b5->width = width1;
HXDLIN( 123)											b5->height = height1;
HXDLIN( 123)											b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 123)											b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 123)											{
HXDLIN( 123)												int len2 = b5->length;
HXDLIN( 123)												int w1 = 0;
HXDLIN( 123)												{
HXDLIN( 123)													int _g24 = 0;
HXDLIN( 123)													int _g25 = b5->height;
HXDLIN( 123)													while((_g24 < _g25)){
HXDLIN( 123)														_g24 = (_g24 + 1);
HXDLIN( 123)														int y5 = (_g24 - 1);
HXDLIN( 123)														{
HXDLIN( 123)															int _g26 = 0;
HXDLIN( 123)															int _g27 = b5->width;
HXDLIN( 123)															while((_g26 < _g27)){
HXDLIN( 123)																_g26 = (_g26 + 1);
HXDLIN( 123)																int x5 = (_g26 - 1);
HXDLIN( 123)																{
HXDLIN( 123)																	w1 = (w1 + 1);
HXDLIN( 123)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 123)																{
HXDLIN( 123)																	w1 = (w1 + 1);
HXDLIN( 123)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 123)																{
HXDLIN( 123)																	w1 = (w1 + 1);
HXDLIN( 123)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 123)																{
HXDLIN( 123)																	w1 = (w1 + 1);
HXDLIN( 123)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 123)										undoImage4 = b5;
            									}
            									break;
            									case (int)1: {
HXDLIN( 123)										 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 123)										 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 123)										{
HXDLIN( 123)											a6->width = width1;
HXDLIN( 123)											a6->height = height1;
HXDLIN( 123)											a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 123)											a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 123)											{
HXDLIN( 123)												int _g28 = 0;
HXDLIN( 123)												int _g29 = a6->length;
HXDLIN( 123)												while((_g28 < _g29)){
HXDLIN( 123)													_g28 = (_g28 + 1);
HXDLIN( 123)													int i8 = (_g28 - 1);
HXDLIN( 123)													a6->data[i8] = 0;
            												}
            											}
            										}
HXDLIN( 123)										undoImage4 = a6;
            									}
            									break;
            									case (int)2: {
HXDLIN( 123)										 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 123)										 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 123)										{
HXDLIN( 123)											b6->width = width1;
HXDLIN( 123)											b6->height = height1;
HXDLIN( 123)											b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 123)											int size1 = (b6->length * 4);
HXDLIN( 123)											b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 123)											{
HXDLIN( 123)												int _g30 = 0;
HXDLIN( 123)												int _g31 = b6->length;
HXDLIN( 123)												while((_g30 < _g31)){
HXDLIN( 123)													_g30 = (_g30 + 1);
HXDLIN( 123)													int i9 = (_g30 - 1);
HXDLIN( 123)													{
HXDLIN( 123)														 ::haxe::io::ArrayBufferViewImpl this39 = b6->data;
HXDLIN( 123)														bool undoImage5;
HXDLIN( 123)														if ((i9 >= 0)) {
HXDLIN( 123)															undoImage5 = (i9 < (this39->byteLength >> 2));
            														}
            														else {
HXDLIN( 123)															undoImage5 = false;
            														}
HXDLIN( 123)														if (undoImage5) {
HXDLIN( 123)															 ::haxe::io::Bytes _this1 = this39->bytes;
HXDLIN( 123)															int pos1 = ((i9 << 2) + this39->byteOffset);
HXDLIN( 123)															_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 123)															_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 123)															_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 123)															_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN( 123)										undoImage4 = b6;
            									}
            									break;
            									case (int)3: {
HXDLIN( 123)										 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 123)										 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 123)										{
HXDLIN( 123)											v3->width = width1;
HXDLIN( 123)											v3->height = height1;
HXDLIN( 123)											v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 123)											v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 123)											{
HXDLIN( 123)												int _g32 = 0;
HXDLIN( 123)												int _g33 = v3->length;
HXDLIN( 123)												while((_g32 < _g33)){
HXDLIN( 123)													_g32 = (_g32 + 1);
HXDLIN( 123)													int i10 = (_g32 - 1);
HXDLIN( 123)													v3->data->__unsafe_set(i10,0);
            												}
            											}
            										}
HXDLIN( 123)										undoImage4 = v3;
            									}
            									break;
            									case (int)4: {
HXDLIN( 123)										 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 123)										 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 123)										{
HXDLIN( 123)											b7->width = width1;
HXDLIN( 123)											b7->height = height1;
HXDLIN( 123)											b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 123)											b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 123)											{
HXDLIN( 123)												int len3 = b7->length;
HXDLIN( 123)												 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 123)												if (::hx::IsNull( d1->head )) {
HXDLIN( 123)													int _g34 = 0;
HXDLIN( 123)													int _g35 = len3;
HXDLIN( 123)													while((_g34 < _g35)){
HXDLIN( 123)														_g34 = (_g34 + 1);
HXDLIN( 123)														int i11 = (_g34 - 1);
HXDLIN( 123)														d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            													}
            												}
            												else {
HXDLIN( 123)													int _g36 = 0;
HXDLIN( 123)													int _g37 = len3;
HXDLIN( 123)													while((_g36 < _g37)){
HXDLIN( 123)														_g36 = (_g36 + 1);
HXDLIN( 123)														int i12 = (_g36 - 1);
HXDLIN( 123)														{
HXDLIN( 123)															 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 123)															 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 123)															{
HXDLIN( 123)																int _g38 = 0;
HXDLIN( 123)																int _g39 = i12;
HXDLIN( 123)																while((_g38 < _g39)){
HXDLIN( 123)																	_g38 = (_g38 + 1);
HXDLIN( 123)																	int i13 = (_g38 - 1);
HXLINE( 345)																	prev1 = l1;
HXLINE( 346)																	l1 = l1->next;
            																}
            															}
HXLINE( 123)															if (::hx::IsNull( prev1 )) {
HXDLIN( 123)																b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 123)																l1 = null();
            															}
            															else {
HXDLIN( 123)																prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 123)																l1 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 123)										undoImage4 = b7;
            									}
            									break;
            								}
HXDLIN( 123)								this38->image = undoImage4;
HXDLIN( 123)								this38->width = width1;
HXDLIN( 123)								this38->height = height1;
HXDLIN( 123)								this38->imageType = ( (int)(imageType1) );
HXDLIN( 123)								undoImage3 = this38;
HXDLIN( 123)								{
HXDLIN( 123)									int rectLeft1 = xIter31->start;
HXDLIN( 123)									int rectTop1 = yIter31->start;
HXDLIN( 123)									int rectRight1 = xIter31->max;
HXDLIN( 123)									bool forceClear1 = false;
HXDLIN( 123)									{
HXDLIN( 123)										int _g40 = rectTop1;
HXDLIN( 123)										int _g41 = yIter31->max;
HXDLIN( 123)										while((_g40 < _g41)){
HXDLIN( 123)											_g40 = (_g40 + 1);
HXDLIN( 123)											int dy1 = (_g40 - 1);
HXDLIN( 123)											{
HXDLIN( 123)												int _g42 = rectLeft1;
HXDLIN( 123)												int _g43 = rectRight1;
HXDLIN( 123)												while((_g42 < _g43)){
HXDLIN( 123)													_g42 = (_g42 + 1);
HXDLIN( 123)													int dx1 = (_g42 - 1);
HXDLIN( 123)													::Dynamic this40 = this37->image;
HXDLIN( 123)													int index6;
HXDLIN( 123)													if (this37->useVirtualPos) {
HXDLIN( 123)														index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this37->virtualY) * ( (Float)(this37->width) )) + dx1) - this37->virtualX));
            													}
            													else {
HXDLIN( 123)														index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this37->width) + dx1)) ));
            													}
HXDLIN( 123)													int c5 = ::iterMagic::Iimg_obj::get(this40,index6);
HXDLIN( 123)													int col1;
HXDLIN( 123)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 123)														col1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            													}
            													else {
HXDLIN( 123)														col1 = c5;
            													}
HXDLIN( 123)													bool _hx_tmp8;
HXDLIN( 123)													if (this37->useMask) {
HXDLIN( 123)														_hx_tmp8 = ::hx::IsNotNull( this37->mask );
            													}
            													else {
HXDLIN( 123)														_hx_tmp8 = false;
            													}
HXDLIN( 123)													if (_hx_tmp8) {
HXDLIN( 123)														 ::pi_xy::ImageStruct this41 = this37->mask;
HXDLIN( 123)														::Dynamic this42 = this41->image;
HXDLIN( 123)														int index7;
HXDLIN( 123)														if (this41->useVirtualPos) {
HXDLIN( 123)															index7 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this41->virtualY) * ( (Float)(this41->width) )) + dx1) - this41->virtualX));
            														}
            														else {
HXDLIN( 123)															index7 = ::Std_obj::_hx_int(( (Float)(((dy1 * this41->width) + dx1)) ));
            														}
HXDLIN( 123)														int c6 = ::iterMagic::Iimg_obj::get(this42,index7);
HXDLIN( 123)														int v4;
HXDLIN( 123)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 123)															v4 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            														}
            														else {
HXDLIN( 123)															v4 = c6;
            														}
HXDLIN( 123)														int maskPixel1 = v4;
HXDLIN( 123)														int this43 = col1;
HXDLIN( 123)														if ((maskPixel1 == 0)) {
HXDLIN( 123)															col1 = this43;
            														}
            														else {
HXDLIN( 123)															Float m01;
HXDLIN( 123)															int this44 = ((maskPixel1 >> 24) & 255);
HXDLIN( 123)															if ((this44 == 0)) {
HXDLIN( 123)																m01 = ((Float)0.);
            															}
            															else {
HXDLIN( 123)																m01 = (( (Float)(this44) ) / ( (Float)(255) ));
            															}
HXDLIN( 123)															Float m11;
HXDLIN( 123)															int this45 = ((maskPixel1 >> 16) & 255);
HXDLIN( 123)															if ((this45 == 0)) {
HXDLIN( 123)																m11 = ((Float)0.);
            															}
            															else {
HXDLIN( 123)																m11 = (( (Float)(this45) ) / ( (Float)(255) ));
            															}
HXDLIN( 123)															Float m21;
HXDLIN( 123)															int this46 = ((maskPixel1 >> 8) & 255);
HXDLIN( 123)															if ((this46 == 0)) {
HXDLIN( 123)																m21 = ((Float)0.);
            															}
            															else {
HXDLIN( 123)																m21 = (( (Float)(this46) ) / ( (Float)(255) ));
            															}
HXDLIN( 123)															Float m31;
HXDLIN( 123)															int this47 = (maskPixel1 & 255);
HXDLIN( 123)															if ((this47 == 0)) {
HXDLIN( 123)																m31 = ((Float)0.);
            															}
            															else {
HXDLIN( 123)																m31 = (( (Float)(this47) ) / ( (Float)(255) ));
            															}
HXDLIN( 123)															int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this43 >> 24) & 255)) )));
HXDLIN( 123)															int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this43 >> 16) & 255)) )));
HXDLIN( 123)															int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this43 >> 8) & 255)) )));
HXDLIN( 123)															int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this43 & 255)) )));
HXDLIN( 123)															col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN( 123)													if ((col1 != 0)) {
HXDLIN( 123)														int x6 = (dx1 - rectLeft1);
HXDLIN( 123)														int y6 = (dy1 - rectTop1);
HXDLIN( 123)														int c7 = col1;
HXDLIN( 123)														bool _hx_tmp9;
HXDLIN( 123)														if ((((c7 >> 24) & 255) < 254)) {
HXDLIN( 123)															_hx_tmp9 = undoImage3->transparent;
            														}
            														else {
HXDLIN( 123)															_hx_tmp9 = false;
            														}
HXDLIN( 123)														if (_hx_tmp9) {
HXDLIN( 123)															int location2;
HXDLIN( 123)															if (undoImage3->useVirtualPos) {
HXDLIN( 123)																location2 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            															}
            															else {
HXDLIN( 123)																location2 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            															}
HXDLIN( 123)															int this48 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 123)															int this49;
HXDLIN( 123)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 123)																this49 = ((((((this48 >> 24) & 255) << 24) | ((this48 & 255) << 16)) | (((this48 >> 8) & 255) << 8)) | ((this48 >> 16) & 255));
            															}
            															else {
HXDLIN( 123)																this49 = this48;
            															}
HXDLIN( 123)															Float a12;
HXDLIN( 123)															int this50 = ((this49 >> 24) & 255);
HXDLIN( 123)															if ((this50 == 0)) {
HXDLIN( 123)																a12 = ((Float)0.);
            															}
            															else {
HXDLIN( 123)																a12 = (( (Float)(this50) ) / ( (Float)(255) ));
            															}
HXDLIN( 123)															Float r12;
HXDLIN( 123)															int this51 = ((this49 >> 16) & 255);
HXDLIN( 123)															if ((this51 == 0)) {
HXDLIN( 123)																r12 = ((Float)0.);
            															}
            															else {
HXDLIN( 123)																r12 = (( (Float)(this51) ) / ( (Float)(255) ));
            															}
HXDLIN( 123)															Float g12;
HXDLIN( 123)															int this52 = ((this49 >> 8) & 255);
HXDLIN( 123)															if ((this52 == 0)) {
HXDLIN( 123)																g12 = ((Float)0.);
            															}
            															else {
HXDLIN( 123)																g12 = (( (Float)(this52) ) / ( (Float)(255) ));
            															}
HXDLIN( 123)															Float b13;
HXDLIN( 123)															int this53 = (this49 & 255);
HXDLIN( 123)															if ((this53 == 0)) {
HXDLIN( 123)																b13 = ((Float)0.);
            															}
            															else {
HXDLIN( 123)																b13 = (( (Float)(this53) ) / ( (Float)(255) ));
            															}
HXDLIN( 123)															Float a22;
HXDLIN( 123)															int this54 = ((col1 >> 24) & 255);
HXDLIN( 123)															if ((this54 == 0)) {
HXDLIN( 123)																a22 = ((Float)0.);
            															}
            															else {
HXDLIN( 123)																a22 = (( (Float)(this54) ) / ( (Float)(255) ));
            															}
HXDLIN( 123)															Float r22;
HXDLIN( 123)															int this55 = ((col1 >> 16) & 255);
HXDLIN( 123)															if ((this55 == 0)) {
HXDLIN( 123)																r22 = ((Float)0.);
            															}
            															else {
HXDLIN( 123)																r22 = (( (Float)(this55) ) / ( (Float)(255) ));
            															}
HXDLIN( 123)															Float g22;
HXDLIN( 123)															int this56 = ((col1 >> 8) & 255);
HXDLIN( 123)															if ((this56 == 0)) {
HXDLIN( 123)																g22 = ((Float)0.);
            															}
            															else {
HXDLIN( 123)																g22 = (( (Float)(this56) ) / ( (Float)(255) ));
            															}
HXDLIN( 123)															Float b23;
HXDLIN( 123)															int this57 = (col1 & 255);
HXDLIN( 123)															if ((this57 == 0)) {
HXDLIN( 123)																b23 = ((Float)0.);
            															}
            															else {
HXDLIN( 123)																b23 = (( (Float)(this57) ) / ( (Float)(255) ));
            															}
HXDLIN( 123)															Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 123)															int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 123)															int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 123)															int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 123)															int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 123)															int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 123)															{
HXDLIN( 123)																int _hx_tmp10;
HXDLIN( 123)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 123)																	_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																}
            																else {
HXDLIN( 123)																	_hx_tmp10 = blended2;
            																}
HXDLIN( 123)																::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            															}
            														}
            														else {
HXDLIN( 123)															::Dynamic this58 = undoImage3->image;
HXDLIN( 123)															int index8;
HXDLIN( 123)															if (undoImage3->useVirtualPos) {
HXDLIN( 123)																index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            															}
            															else {
HXDLIN( 123)																index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            															}
HXDLIN( 123)															int _hx_tmp11;
HXDLIN( 123)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 123)																_hx_tmp11 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            															}
            															else {
HXDLIN( 123)																_hx_tmp11 = c7;
            															}
HXDLIN( 123)															::iterMagic::Iimg_obj::set(this58,index8,_hx_tmp11);
            														}
            													}
            													else {
HXDLIN( 123)														if (forceClear1) {
HXDLIN( 123)															::Dynamic this59 = undoImage3->image;
HXDLIN( 123)															int x7 = (dx1 - rectLeft1);
HXDLIN( 123)															int y7 = (dy1 - rectTop1);
HXDLIN( 123)															int index9;
HXDLIN( 123)															if (undoImage3->useVirtualPos) {
HXDLIN( 123)																index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x7) - undoImage3->virtualX));
            															}
            															else {
HXDLIN( 123)																index9 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage3->width) + x7)) ));
            															}
HXDLIN( 123)															::iterMagic::Iimg_obj::set(this59,index9,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 123)							bool foundY1 = false;
HXDLIN( 123)							Float s1 = ((Float)0.);
HXDLIN( 123)							Float t1 = ((Float)0.);
HXDLIN( 123)							Float sxx1 = ((Float)0.);
HXDLIN( 123)							Float txx1 = ((Float)0.);
HXDLIN( 123)							{
HXDLIN( 123)								int _g_min2 = xIter31->start;
HXDLIN( 123)								int _g_max2 = xIter31->max;
HXDLIN( 123)								while((_g_min2 < _g_max2)){
HXDLIN( 123)									_g_min2 = (_g_min2 + 1);
HXDLIN( 123)									int x8 = (_g_min2 - 1);
HXLINE( 222)									sxx1 = (sx1 * ( (Float)(x8) ));
HXLINE( 223)									txx1 = (tx1 * ( (Float)(x8) ));
HXLINE( 224)									foundY1 = false;
HXLINE( 123)									{
HXDLIN( 123)										int _g_min3 = yIter31->start;
HXDLIN( 123)										int _g_max3 = yIter31->max;
HXDLIN( 123)										while((_g_min3 < _g_max3)){
HXDLIN( 123)											_g_min3 = (_g_min3 + 1);
HXDLIN( 123)											int y8 = (_g_min3 - 1);
HXLINE( 226)											s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y8) )));
HXLINE( 227)											t1 = ((t01 + txx1) + (ty1 * ( (Float)(y8) )));
HXLINE( 123)											bool _hx_tmp12;
HXDLIN( 123)											if (!((s1 <= 0))) {
HXDLIN( 123)												_hx_tmp12 = (t1 <= 0);
            											}
            											else {
HXDLIN( 123)												_hx_tmp12 = true;
            											}
HXDLIN( 123)											if (_hx_tmp12) {
HXDLIN( 123)												if (foundY1) {
HXDLIN( 123)													goto _hx_goto_207;
            												}
            											}
            											else {
HXDLIN( 123)												if (((s1 + t1) < A1)) {
HXDLIN( 123)													int x9 = ::hx::Mod(x8,tileImage->width);
HXDLIN( 123)													int y9 = ::hx::Mod(y8,tileImage->height);
HXDLIN( 123)													::Dynamic this60 = tileImage->image;
HXDLIN( 123)													int index10;
HXDLIN( 123)													if (tileImage->useVirtualPos) {
HXDLIN( 123)														index10 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x9) - tileImage->virtualX));
            													}
            													else {
HXDLIN( 123)														index10 = ::Std_obj::_hx_int(( (Float)(((y9 * tileImage->width) + x9)) ));
            													}
HXDLIN( 123)													int c8 = ::iterMagic::Iimg_obj::get(this60,index10);
HXDLIN( 123)													int color1;
HXDLIN( 123)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 123)														color1 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            													}
            													else {
HXDLIN( 123)														color1 = c8;
            													}
HXDLIN( 123)													{
HXDLIN( 123)														int c9 = color1;
HXDLIN( 123)														bool _hx_tmp13;
HXDLIN( 123)														if ((((c9 >> 24) & 255) < 254)) {
HXDLIN( 123)															_hx_tmp13 = this37->transparent;
            														}
            														else {
HXDLIN( 123)															_hx_tmp13 = false;
            														}
HXDLIN( 123)														if (_hx_tmp13) {
HXDLIN( 123)															int location3;
HXDLIN( 123)															if (this37->useVirtualPos) {
HXDLIN( 123)																location3 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - this37->virtualY) * ( (Float)(this37->width) )) + x8) - this37->virtualX));
            															}
            															else {
HXDLIN( 123)																location3 = ::Std_obj::_hx_int(( (Float)(((y8 * this37->width) + x8)) ));
            															}
HXDLIN( 123)															int this61 = ::iterMagic::Iimg_obj::get(this37->image,location3);
HXDLIN( 123)															int this62;
HXDLIN( 123)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 123)																this62 = ((((((this61 >> 24) & 255) << 24) | ((this61 & 255) << 16)) | (((this61 >> 8) & 255) << 8)) | ((this61 >> 16) & 255));
            															}
            															else {
HXDLIN( 123)																this62 = this61;
            															}
HXDLIN( 123)															Float a13;
HXDLIN( 123)															int this63 = ((this62 >> 24) & 255);
HXDLIN( 123)															if ((this63 == 0)) {
HXDLIN( 123)																a13 = ((Float)0.);
            															}
            															else {
HXDLIN( 123)																a13 = (( (Float)(this63) ) / ( (Float)(255) ));
            															}
HXDLIN( 123)															Float r13;
HXDLIN( 123)															int this64 = ((this62 >> 16) & 255);
HXDLIN( 123)															if ((this64 == 0)) {
HXDLIN( 123)																r13 = ((Float)0.);
            															}
            															else {
HXDLIN( 123)																r13 = (( (Float)(this64) ) / ( (Float)(255) ));
            															}
HXDLIN( 123)															Float g13;
HXDLIN( 123)															int this65 = ((this62 >> 8) & 255);
HXDLIN( 123)															if ((this65 == 0)) {
HXDLIN( 123)																g13 = ((Float)0.);
            															}
            															else {
HXDLIN( 123)																g13 = (( (Float)(this65) ) / ( (Float)(255) ));
            															}
HXDLIN( 123)															Float b14;
HXDLIN( 123)															int this66 = (this62 & 255);
HXDLIN( 123)															if ((this66 == 0)) {
HXDLIN( 123)																b14 = ((Float)0.);
            															}
            															else {
HXDLIN( 123)																b14 = (( (Float)(this66) ) / ( (Float)(255) ));
            															}
HXDLIN( 123)															Float a23;
HXDLIN( 123)															int this67 = ((color1 >> 24) & 255);
HXDLIN( 123)															if ((this67 == 0)) {
HXDLIN( 123)																a23 = ((Float)0.);
            															}
            															else {
HXDLIN( 123)																a23 = (( (Float)(this67) ) / ( (Float)(255) ));
            															}
HXDLIN( 123)															Float r23;
HXDLIN( 123)															int this68 = ((color1 >> 16) & 255);
HXDLIN( 123)															if ((this68 == 0)) {
HXDLIN( 123)																r23 = ((Float)0.);
            															}
            															else {
HXDLIN( 123)																r23 = (( (Float)(this68) ) / ( (Float)(255) ));
            															}
HXDLIN( 123)															Float g23;
HXDLIN( 123)															int this69 = ((color1 >> 8) & 255);
HXDLIN( 123)															if ((this69 == 0)) {
HXDLIN( 123)																g23 = ((Float)0.);
            															}
            															else {
HXDLIN( 123)																g23 = (( (Float)(this69) ) / ( (Float)(255) ));
            															}
HXDLIN( 123)															Float b24;
HXDLIN( 123)															int this70 = (color1 & 255);
HXDLIN( 123)															if ((this70 == 0)) {
HXDLIN( 123)																b24 = ((Float)0.);
            															}
            															else {
HXDLIN( 123)																b24 = (( (Float)(this70) ) / ( (Float)(255) ));
            															}
HXDLIN( 123)															Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 123)															int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 123)															int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 123)															int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 123)															int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 123)															int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 123)															{
HXDLIN( 123)																int _hx_tmp14;
HXDLIN( 123)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 123)																	_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																}
            																else {
HXDLIN( 123)																	_hx_tmp14 = blended3;
            																}
HXDLIN( 123)																::iterMagic::Iimg_obj::set(this37->image,location3,_hx_tmp14);
            															}
            														}
            														else {
HXDLIN( 123)															::Dynamic this71 = this37->image;
HXDLIN( 123)															int index11;
HXDLIN( 123)															if (this37->useVirtualPos) {
HXDLIN( 123)																index11 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - this37->virtualY) * ( (Float)(this37->width) )) + x8) - this37->virtualX));
            															}
            															else {
HXDLIN( 123)																index11 = ::Std_obj::_hx_int(( (Float)(((y8 * this37->width) + x8)) ));
            															}
HXDLIN( 123)															int _hx_tmp15;
HXDLIN( 123)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 123)																_hx_tmp15 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            															}
            															else {
HXDLIN( 123)																_hx_tmp15 = c9;
            															}
HXDLIN( 123)															::iterMagic::Iimg_obj::set(this71,index11,_hx_tmp15);
            														}
            													}
HXLINE( 236)													foundY1 = true;
            												}
            												else {
HXDLIN( 123)													if (foundY1) {
HXDLIN( 123)														goto _hx_goto_207;
            													}
            												}
            											}
            										}
            										_hx_goto_207:;
            									}
            								}
            							}
HXDLIN( 123)							if ((hasHit1 == false)) {
HXDLIN( 123)								 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN( 123)								if (hasUndo1) {
HXDLIN( 123)									v5->undoImage = undoImage3;
HXDLIN( 123)									v5->undoX = xIter31->start;
HXDLIN( 123)									v5->undoY = yIter31->start;
            								}
            							}
            						}
            					}
            				}
HXLINE(  93)				lastX = nextX1;
HXLINE(  94)				lastY = nextY1;
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(TileShape_Impl__obj,quadrantII,(void))

void TileShape_Impl__obj::quadrantIII( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float rx,Float ry, ::pi_xy::ImageStruct tileImage, ::Dynamic __o_phi){
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = ((Float)0.);
            	HX_GC_STACKFRAME(&_hx_pos_6e4d7718bf84d356_136_quadrantIII)
HXDLIN( 136)		 ::Dynamic targetError = ((Float)1.05);
HXDLIN( 136)		if (::hx::IsNull( targetError )) {
HXLINE( 101)			targetError = ((Float)1.05);
            		}
HXLINE( 136)		Float rSmall;
HXDLIN( 136)		if ((rx > ry)) {
HXDLIN( 136)			rSmall = ry;
            		}
            		else {
HXDLIN( 136)			rSmall = rx;
            		}
HXDLIN( 136)		 ::Dynamic targetE = ( (Float)(targetError) );
HXDLIN( 136)		if (::hx::IsNull( targetE )) {
HXLINE(  20)			targetE = ((Float)1.05);
            		}
HXLINE( 136)		int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN( 136)		int noSides;
HXDLIN( 136)		if ((result < 12)) {
HXDLIN( 136)			noSides = 12;
            		}
            		else {
HXDLIN( 136)			if ((result > 500)) {
HXDLIN( 136)				noSides = 500;
            			}
            			else {
HXDLIN( 136)				noSides = result;
            			}
            		}
HXDLIN( 136)		int sides = (::Math_obj::ceil((( (Float)(noSides) ) / ( (Float)(4) ))) * 4);
HXDLIN( 136)		Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides) ));
HXDLIN( 136)		Float omega = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN( 136)		int quarter = ::Std_obj::_hx_int((( (Float)(sides) ) / ( (Float)(4) )));
HXDLIN( 136)		Float lastX = ((Float)0.);
HXDLIN( 136)		Float lastY = ((Float)0.);
HXDLIN( 136)		if (::hx::IsNotEq( phi,0 )) {
HXLINE(  70)			lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) )))) + cx);
HXLINE(  71)			lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) )))) + cy);
            		}
            		else {
HXLINE(  73)			lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))));
HXLINE(  74)			lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))));
            		}
HXLINE( 136)		if (::hx::IsNotEq( phi,0 )) {
HXDLIN( 136)			Float cphi = ::Math_obj::cos(( (Float)(phi) ));
HXDLIN( 136)			Float sphi = ::Math_obj::sin(( (Float)(phi) ));
HXDLIN( 136)			{
HXDLIN( 136)				int _g = 0;
HXDLIN( 136)				int _g1 = (quarter + 1);
HXDLIN( 136)				while((_g < _g1)){
HXDLIN( 136)					_g = (_g + 1);
HXDLIN( 136)					int i = (_g - 1);
HXDLIN( 136)					Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega));
HXDLIN( 136)					Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega));
HXDLIN( 136)					Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXDLIN( 136)					Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXDLIN( 136)					{
HXDLIN( 136)						 ::pi_xy::ImageStruct this2 = this1;
HXDLIN( 136)						bool hasHit = false;
HXDLIN( 136)						{
HXDLIN( 136)							Float bx = lastX;
HXDLIN( 136)							Float by = lastY;
HXDLIN( 136)							Float cx1 = nextX;
HXDLIN( 136)							Float cy1 = nextY;
HXDLIN( 136)							bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN( 136)							if (!(adjustWinding)) {
HXDLIN( 136)								Float bx_ = bx;
HXDLIN( 136)								Float by_ = by;
HXLINE( 187)								bx = cx1;
HXLINE( 188)								by = cy1;
HXLINE( 189)								cx1 = bx_;
HXLINE( 190)								cy1 = by_;
            							}
HXLINE( 136)							{
HXDLIN( 136)								bool hasUndo = false;
HXDLIN( 136)								Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN( 136)								Float sx = (cy1 - cy);
HXDLIN( 136)								Float sy = (cx - cx1);
HXDLIN( 136)								Float t0 = ((cx * by) - (cy * bx));
HXDLIN( 136)								Float tx = (cy - by);
HXDLIN( 136)								Float ty = (bx - cx);
HXDLIN( 136)								Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN( 136)								 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 136)								if ((cx > bx)) {
HXDLIN( 136)									if ((cx > cx1)) {
HXDLIN( 136)										int min;
HXDLIN( 136)										if ((bx > cx1)) {
HXDLIN( 136)											min = ::Math_obj::floor(cx1);
            										}
            										else {
HXDLIN( 136)											min = ::Math_obj::floor(bx);
            										}
HXDLIN( 136)										int ii_min = min;
HXDLIN( 136)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 136)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            									}
            									else {
HXDLIN( 136)										int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 136)										int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 136)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            									}
            								}
            								else {
HXDLIN( 136)									if ((bx > cx1)) {
HXDLIN( 136)										int min1;
HXDLIN( 136)										if ((cx > cx1)) {
HXDLIN( 136)											min1 = ::Math_obj::floor(cx1);
            										}
            										else {
HXDLIN( 136)											min1 = ::Math_obj::ceil(cx);
            										}
HXDLIN( 136)										int ii_min2 = min1;
HXDLIN( 136)										int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 136)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            									}
            									else {
HXDLIN( 136)										int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 136)										int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 136)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            									}
            								}
HXDLIN( 136)								 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 136)								if ((cy > by)) {
HXDLIN( 136)									if ((cy > cy1)) {
HXDLIN( 136)										int min2;
HXDLIN( 136)										if ((by > cy1)) {
HXDLIN( 136)											min2 = ::Math_obj::floor(cy1);
            										}
            										else {
HXDLIN( 136)											min2 = ::Math_obj::floor(by);
            										}
HXDLIN( 136)										int ii_min4 = min2;
HXDLIN( 136)										int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 136)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            									}
            									else {
HXDLIN( 136)										int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 136)										int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 136)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            									}
            								}
            								else {
HXDLIN( 136)									if ((by > cy1)) {
HXDLIN( 136)										int min3;
HXDLIN( 136)										if ((cy > cy1)) {
HXDLIN( 136)											min3 = ::Math_obj::floor(cy1);
            										}
            										else {
HXDLIN( 136)											min3 = ::Math_obj::ceil(cy);
            										}
HXDLIN( 136)										int ii_min6 = min3;
HXDLIN( 136)										int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 136)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            									}
            									else {
HXDLIN( 136)										int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 136)										int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 136)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            									}
            								}
HXDLIN( 136)								 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 136)								if (hasUndo) {
HXDLIN( 136)									int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 136)									int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 136)									 ::Dynamic imageType = null();
HXDLIN( 136)									 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 136)									if (::hx::IsNull( imageType )) {
HXLINE(  54)										imageType = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 136)									::Dynamic undoImage1;
HXDLIN( 136)									switch((int)(( (int)(imageType) ))){
            										case (int)0: {
HXDLIN( 136)											 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 136)											 ::iterMagic::BytesImg b = byt;
HXDLIN( 136)											{
HXDLIN( 136)												b->width = width;
HXDLIN( 136)												b->height = height;
HXDLIN( 136)												b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 136)												b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 136)												{
HXDLIN( 136)													int len = b->length;
HXDLIN( 136)													int w = 0;
HXDLIN( 136)													{
HXDLIN( 136)														int _g2 = 0;
HXDLIN( 136)														int _g3 = b->height;
HXDLIN( 136)														while((_g2 < _g3)){
HXDLIN( 136)															_g2 = (_g2 + 1);
HXDLIN( 136)															int y = (_g2 - 1);
HXDLIN( 136)															{
HXDLIN( 136)																int _g4 = 0;
HXDLIN( 136)																int _g5 = b->width;
HXDLIN( 136)																while((_g4 < _g5)){
HXDLIN( 136)																	_g4 = (_g4 + 1);
HXDLIN( 136)																	int x = (_g4 - 1);
HXDLIN( 136)																	{
HXDLIN( 136)																		w = (w + 1);
HXDLIN( 136)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 136)																	{
HXDLIN( 136)																		w = (w + 1);
HXDLIN( 136)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 136)																	{
HXDLIN( 136)																		w = (w + 1);
HXDLIN( 136)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 136)																	{
HXDLIN( 136)																		w = (w + 1);
HXDLIN( 136)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 136)											undoImage1 = b;
            										}
            										break;
            										case (int)1: {
HXDLIN( 136)											 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 136)											 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 136)											{
HXDLIN( 136)												a->width = width;
HXDLIN( 136)												a->height = height;
HXDLIN( 136)												a->data = ::Array_obj< int >::__new(0);
HXDLIN( 136)												a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 136)												{
HXDLIN( 136)													int _g6 = 0;
HXDLIN( 136)													int _g7 = a->length;
HXDLIN( 136)													while((_g6 < _g7)){
HXDLIN( 136)														_g6 = (_g6 + 1);
HXDLIN( 136)														int i1 = (_g6 - 1);
HXDLIN( 136)														a->data[i1] = 0;
            													}
            												}
            											}
HXDLIN( 136)											undoImage1 = a;
            										}
            										break;
            										case (int)2: {
HXDLIN( 136)											 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 136)											 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 136)											{
HXDLIN( 136)												b1->width = width;
HXDLIN( 136)												b1->height = height;
HXDLIN( 136)												b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 136)												int size = (b1->length * 4);
HXDLIN( 136)												b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 136)												{
HXDLIN( 136)													int _g8 = 0;
HXDLIN( 136)													int _g9 = b1->length;
HXDLIN( 136)													while((_g8 < _g9)){
HXDLIN( 136)														_g8 = (_g8 + 1);
HXDLIN( 136)														int i2 = (_g8 - 1);
HXDLIN( 136)														{
HXDLIN( 136)															 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN( 136)															bool undoImage2;
HXDLIN( 136)															if ((i2 >= 0)) {
HXDLIN( 136)																undoImage2 = (i2 < (this4->byteLength >> 2));
            															}
            															else {
HXDLIN( 136)																undoImage2 = false;
            															}
HXDLIN( 136)															if (undoImage2) {
HXDLIN( 136)																 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN( 136)																int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN( 136)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 136)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 136)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 136)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 136)											undoImage1 = b1;
            										}
            										break;
            										case (int)3: {
HXDLIN( 136)											 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 136)											 ::iterMagic::VecIntImg v = vec;
HXDLIN( 136)											{
HXDLIN( 136)												v->width = width;
HXDLIN( 136)												v->height = height;
HXDLIN( 136)												v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 136)												v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 136)												{
HXDLIN( 136)													int _g10 = 0;
HXDLIN( 136)													int _g11 = v->length;
HXDLIN( 136)													while((_g10 < _g11)){
HXDLIN( 136)														_g10 = (_g10 + 1);
HXDLIN( 136)														int i3 = (_g10 - 1);
HXDLIN( 136)														v->data->__unsafe_set(i3,0);
            													}
            												}
            											}
HXDLIN( 136)											undoImage1 = v;
            										}
            										break;
            										case (int)4: {
HXDLIN( 136)											 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 136)											 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 136)											{
HXDLIN( 136)												b2->width = width;
HXDLIN( 136)												b2->height = height;
HXDLIN( 136)												b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 136)												b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 136)												{
HXDLIN( 136)													int len1 = b2->length;
HXDLIN( 136)													 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 136)													if (::hx::IsNull( d->head )) {
HXDLIN( 136)														int _g12 = 0;
HXDLIN( 136)														int _g13 = len1;
HXDLIN( 136)														while((_g12 < _g13)){
HXDLIN( 136)															_g12 = (_g12 + 1);
HXDLIN( 136)															int i4 = (_g12 - 1);
HXDLIN( 136)															d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            														}
            													}
            													else {
HXDLIN( 136)														int _g14 = 0;
HXDLIN( 136)														int _g15 = len1;
HXDLIN( 136)														while((_g14 < _g15)){
HXDLIN( 136)															_g14 = (_g14 + 1);
HXDLIN( 136)															int i5 = (_g14 - 1);
HXDLIN( 136)															{
HXDLIN( 136)																 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 136)																 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 136)																{
HXDLIN( 136)																	int _g16 = 0;
HXDLIN( 136)																	int _g17 = i5;
HXDLIN( 136)																	while((_g16 < _g17)){
HXDLIN( 136)																		_g16 = (_g16 + 1);
HXDLIN( 136)																		int i6 = (_g16 - 1);
HXLINE( 345)																		prev = l;
HXLINE( 346)																		l = l->next;
            																	}
            																}
HXLINE( 136)																if (::hx::IsNull( prev )) {
HXDLIN( 136)																	b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 136)																	l = null();
            																}
            																else {
HXDLIN( 136)																	prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 136)																	l = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 136)											undoImage1 = b2;
            										}
            										break;
            									}
HXDLIN( 136)									this3->image = undoImage1;
HXDLIN( 136)									this3->width = width;
HXDLIN( 136)									this3->height = height;
HXDLIN( 136)									this3->imageType = ( (int)(imageType) );
HXDLIN( 136)									undoImage = this3;
HXDLIN( 136)									{
HXDLIN( 136)										int rectLeft = xIter3->start;
HXDLIN( 136)										int rectTop = yIter3->start;
HXDLIN( 136)										int rectRight = xIter3->max;
HXDLIN( 136)										bool forceClear = false;
HXDLIN( 136)										{
HXDLIN( 136)											int _g18 = rectTop;
HXDLIN( 136)											int _g19 = yIter3->max;
HXDLIN( 136)											while((_g18 < _g19)){
HXDLIN( 136)												_g18 = (_g18 + 1);
HXDLIN( 136)												int dy = (_g18 - 1);
HXDLIN( 136)												{
HXDLIN( 136)													int _g20 = rectLeft;
HXDLIN( 136)													int _g21 = rectRight;
HXDLIN( 136)													while((_g20 < _g21)){
HXDLIN( 136)														_g20 = (_g20 + 1);
HXDLIN( 136)														int dx = (_g20 - 1);
HXDLIN( 136)														::Dynamic this5 = this2->image;
HXDLIN( 136)														int index;
HXDLIN( 136)														if (this2->useVirtualPos) {
HXDLIN( 136)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            														}
            														else {
HXDLIN( 136)															index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            														}
HXDLIN( 136)														int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN( 136)														int col;
HXDLIN( 136)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 136)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXDLIN( 136)															col = c;
            														}
HXDLIN( 136)														bool _hx_tmp;
HXDLIN( 136)														if (this2->useMask) {
HXDLIN( 136)															_hx_tmp = ::hx::IsNotNull( this2->mask );
            														}
            														else {
HXDLIN( 136)															_hx_tmp = false;
            														}
HXDLIN( 136)														if (_hx_tmp) {
HXDLIN( 136)															 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN( 136)															::Dynamic this7 = this6->image;
HXDLIN( 136)															int index1;
HXDLIN( 136)															if (this6->useVirtualPos) {
HXDLIN( 136)																index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            															}
            															else {
HXDLIN( 136)																index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            															}
HXDLIN( 136)															int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN( 136)															int v1;
HXDLIN( 136)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 136)																v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            															}
            															else {
HXDLIN( 136)																v1 = c1;
            															}
HXDLIN( 136)															int maskPixel = v1;
HXDLIN( 136)															int this8 = col;
HXDLIN( 136)															if ((maskPixel == 0)) {
HXDLIN( 136)																col = this8;
            															}
            															else {
HXDLIN( 136)																Float m0;
HXDLIN( 136)																int this9 = ((maskPixel >> 24) & 255);
HXDLIN( 136)																if ((this9 == 0)) {
HXDLIN( 136)																	m0 = ((Float)0.);
            																}
            																else {
HXDLIN( 136)																	m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN( 136)																Float m1;
HXDLIN( 136)																int this10 = ((maskPixel >> 16) & 255);
HXDLIN( 136)																if ((this10 == 0)) {
HXDLIN( 136)																	m1 = ((Float)0.);
            																}
            																else {
HXDLIN( 136)																	m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN( 136)																Float m2;
HXDLIN( 136)																int this11 = ((maskPixel >> 8) & 255);
HXDLIN( 136)																if ((this11 == 0)) {
HXDLIN( 136)																	m2 = ((Float)0.);
            																}
            																else {
HXDLIN( 136)																	m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN( 136)																Float m3;
HXDLIN( 136)																int this12 = (maskPixel & 255);
HXDLIN( 136)																if ((this12 == 0)) {
HXDLIN( 136)																	m3 = ((Float)0.);
            																}
            																else {
HXDLIN( 136)																	m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN( 136)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN( 136)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN( 136)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN( 136)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN( 136)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 136)														if ((col != 0)) {
HXDLIN( 136)															int x1 = (dx - rectLeft);
HXDLIN( 136)															int y1 = (dy - rectTop);
HXDLIN( 136)															int c2 = col;
HXDLIN( 136)															bool _hx_tmp1;
HXDLIN( 136)															if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 136)																_hx_tmp1 = undoImage->transparent;
            															}
            															else {
HXDLIN( 136)																_hx_tmp1 = false;
            															}
HXDLIN( 136)															if (_hx_tmp1) {
HXDLIN( 136)																int location;
HXDLIN( 136)																if (undoImage->useVirtualPos) {
HXDLIN( 136)																	location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXDLIN( 136)																	location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN( 136)																int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 136)																int this14;
HXDLIN( 136)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 136)																	this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																}
            																else {
HXDLIN( 136)																	this14 = this13;
            																}
HXDLIN( 136)																Float a1;
HXDLIN( 136)																int this15 = ((this14 >> 24) & 255);
HXDLIN( 136)																if ((this15 == 0)) {
HXDLIN( 136)																	a1 = ((Float)0.);
            																}
            																else {
HXDLIN( 136)																	a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																}
HXDLIN( 136)																Float r1;
HXDLIN( 136)																int this16 = ((this14 >> 16) & 255);
HXDLIN( 136)																if ((this16 == 0)) {
HXDLIN( 136)																	r1 = ((Float)0.);
            																}
            																else {
HXDLIN( 136)																	r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																}
HXDLIN( 136)																Float g1;
HXDLIN( 136)																int this17 = ((this14 >> 8) & 255);
HXDLIN( 136)																if ((this17 == 0)) {
HXDLIN( 136)																	g1 = ((Float)0.);
            																}
            																else {
HXDLIN( 136)																	g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																}
HXDLIN( 136)																Float b11;
HXDLIN( 136)																int this18 = (this14 & 255);
HXDLIN( 136)																if ((this18 == 0)) {
HXDLIN( 136)																	b11 = ((Float)0.);
            																}
            																else {
HXDLIN( 136)																	b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																}
HXDLIN( 136)																Float a2;
HXDLIN( 136)																int this19 = ((col >> 24) & 255);
HXDLIN( 136)																if ((this19 == 0)) {
HXDLIN( 136)																	a2 = ((Float)0.);
            																}
            																else {
HXDLIN( 136)																	a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																}
HXDLIN( 136)																Float r2;
HXDLIN( 136)																int this20 = ((col >> 16) & 255);
HXDLIN( 136)																if ((this20 == 0)) {
HXDLIN( 136)																	r2 = ((Float)0.);
            																}
            																else {
HXDLIN( 136)																	r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																}
HXDLIN( 136)																Float g2;
HXDLIN( 136)																int this21 = ((col >> 8) & 255);
HXDLIN( 136)																if ((this21 == 0)) {
HXDLIN( 136)																	g2 = ((Float)0.);
            																}
            																else {
HXDLIN( 136)																	g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																}
HXDLIN( 136)																Float b21;
HXDLIN( 136)																int this22 = (col & 255);
HXDLIN( 136)																if ((this22 == 0)) {
HXDLIN( 136)																	b21 = ((Float)0.);
            																}
            																else {
HXDLIN( 136)																	b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																}
HXDLIN( 136)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 136)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 136)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 136)																int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 136)																int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 136)																int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 136)																{
HXDLIN( 136)																	int _hx_tmp2;
HXDLIN( 136)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 136)																		_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXDLIN( 136)																		_hx_tmp2 = blended;
            																	}
HXDLIN( 136)																	::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																}
            															}
            															else {
HXDLIN( 136)																::Dynamic this23 = undoImage->image;
HXDLIN( 136)																int index2;
HXDLIN( 136)																if (undoImage->useVirtualPos) {
HXDLIN( 136)																	index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXDLIN( 136)																	index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN( 136)																int _hx_tmp3;
HXDLIN( 136)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 136)																	_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																}
            																else {
HXDLIN( 136)																	_hx_tmp3 = c2;
            																}
HXDLIN( 136)																::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            															}
            														}
            														else {
HXDLIN( 136)															if (forceClear) {
HXDLIN( 136)																::Dynamic this24 = undoImage->image;
HXDLIN( 136)																int x2 = (dx - rectLeft);
HXDLIN( 136)																int y2 = (dy - rectTop);
HXDLIN( 136)																int index3;
HXDLIN( 136)																if (undoImage->useVirtualPos) {
HXDLIN( 136)																	index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																}
            																else {
HXDLIN( 136)																	index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																}
HXDLIN( 136)																::iterMagic::Iimg_obj::set(this24,index3,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 136)								bool foundY = false;
HXDLIN( 136)								Float s = ((Float)0.);
HXDLIN( 136)								Float t = ((Float)0.);
HXDLIN( 136)								Float sxx = ((Float)0.);
HXDLIN( 136)								Float txx = ((Float)0.);
HXDLIN( 136)								{
HXDLIN( 136)									int _g_min = xIter3->start;
HXDLIN( 136)									int _g_max = xIter3->max;
HXDLIN( 136)									while((_g_min < _g_max)){
HXDLIN( 136)										_g_min = (_g_min + 1);
HXDLIN( 136)										int x3 = (_g_min - 1);
HXLINE( 222)										sxx = (sx * ( (Float)(x3) ));
HXLINE( 223)										txx = (tx * ( (Float)(x3) ));
HXLINE( 224)										foundY = false;
HXLINE( 136)										{
HXDLIN( 136)											int _g_min1 = yIter3->start;
HXDLIN( 136)											int _g_max1 = yIter3->max;
HXDLIN( 136)											while((_g_min1 < _g_max1)){
HXDLIN( 136)												_g_min1 = (_g_min1 + 1);
HXDLIN( 136)												int y3 = (_g_min1 - 1);
HXLINE( 226)												s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE( 227)												t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 136)												bool _hx_tmp4;
HXDLIN( 136)												if (!((s <= 0))) {
HXDLIN( 136)													_hx_tmp4 = (t <= 0);
            												}
            												else {
HXDLIN( 136)													_hx_tmp4 = true;
            												}
HXDLIN( 136)												if (_hx_tmp4) {
HXDLIN( 136)													if (foundY) {
HXDLIN( 136)														goto _hx_goto_221;
            													}
            												}
            												else {
HXDLIN( 136)													if (((s + t) < A)) {
HXDLIN( 136)														int x4 = ::hx::Mod(x3,tileImage->width);
HXDLIN( 136)														int y4 = ::hx::Mod(y3,tileImage->height);
HXDLIN( 136)														::Dynamic this25 = tileImage->image;
HXDLIN( 136)														int index4;
HXDLIN( 136)														if (tileImage->useVirtualPos) {
HXDLIN( 136)															index4 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x4) - tileImage->virtualX));
            														}
            														else {
HXDLIN( 136)															index4 = ::Std_obj::_hx_int(( (Float)(((y4 * tileImage->width) + x4)) ));
            														}
HXDLIN( 136)														int c3 = ::iterMagic::Iimg_obj::get(this25,index4);
HXDLIN( 136)														int color;
HXDLIN( 136)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 136)															color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            														}
            														else {
HXDLIN( 136)															color = c3;
            														}
HXDLIN( 136)														{
HXDLIN( 136)															int c4 = color;
HXDLIN( 136)															bool _hx_tmp5;
HXDLIN( 136)															if ((((c4 >> 24) & 255) < 254)) {
HXDLIN( 136)																_hx_tmp5 = this2->transparent;
            															}
            															else {
HXDLIN( 136)																_hx_tmp5 = false;
            															}
HXDLIN( 136)															if (_hx_tmp5) {
HXDLIN( 136)																int location1;
HXDLIN( 136)																if (this2->useVirtualPos) {
HXDLIN( 136)																	location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																}
            																else {
HXDLIN( 136)																	location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																}
HXDLIN( 136)																int this26 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN( 136)																int this27;
HXDLIN( 136)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 136)																	this27 = ((((((this26 >> 24) & 255) << 24) | ((this26 & 255) << 16)) | (((this26 >> 8) & 255) << 8)) | ((this26 >> 16) & 255));
            																}
            																else {
HXDLIN( 136)																	this27 = this26;
            																}
HXDLIN( 136)																Float a11;
HXDLIN( 136)																int this28 = ((this27 >> 24) & 255);
HXDLIN( 136)																if ((this28 == 0)) {
HXDLIN( 136)																	a11 = ((Float)0.);
            																}
            																else {
HXDLIN( 136)																	a11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																}
HXDLIN( 136)																Float r11;
HXDLIN( 136)																int this29 = ((this27 >> 16) & 255);
HXDLIN( 136)																if ((this29 == 0)) {
HXDLIN( 136)																	r11 = ((Float)0.);
            																}
            																else {
HXDLIN( 136)																	r11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																}
HXDLIN( 136)																Float g11;
HXDLIN( 136)																int this30 = ((this27 >> 8) & 255);
HXDLIN( 136)																if ((this30 == 0)) {
HXDLIN( 136)																	g11 = ((Float)0.);
            																}
            																else {
HXDLIN( 136)																	g11 = (( (Float)(this30) ) / ( (Float)(255) ));
            																}
HXDLIN( 136)																Float b12;
HXDLIN( 136)																int this31 = (this27 & 255);
HXDLIN( 136)																if ((this31 == 0)) {
HXDLIN( 136)																	b12 = ((Float)0.);
            																}
            																else {
HXDLIN( 136)																	b12 = (( (Float)(this31) ) / ( (Float)(255) ));
            																}
HXDLIN( 136)																Float a21;
HXDLIN( 136)																int this32 = ((color >> 24) & 255);
HXDLIN( 136)																if ((this32 == 0)) {
HXDLIN( 136)																	a21 = ((Float)0.);
            																}
            																else {
HXDLIN( 136)																	a21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																}
HXDLIN( 136)																Float r21;
HXDLIN( 136)																int this33 = ((color >> 16) & 255);
HXDLIN( 136)																if ((this33 == 0)) {
HXDLIN( 136)																	r21 = ((Float)0.);
            																}
            																else {
HXDLIN( 136)																	r21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																}
HXDLIN( 136)																Float g21;
HXDLIN( 136)																int this34 = ((color >> 8) & 255);
HXDLIN( 136)																if ((this34 == 0)) {
HXDLIN( 136)																	g21 = ((Float)0.);
            																}
            																else {
HXDLIN( 136)																	g21 = (( (Float)(this34) ) / ( (Float)(255) ));
            																}
HXDLIN( 136)																Float b22;
HXDLIN( 136)																int this35 = (color & 255);
HXDLIN( 136)																if ((this35 == 0)) {
HXDLIN( 136)																	b22 = ((Float)0.);
            																}
            																else {
HXDLIN( 136)																	b22 = (( (Float)(this35) ) / ( (Float)(255) ));
            																}
HXDLIN( 136)																Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 136)																int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 136)																int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 136)																int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 136)																int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 136)																int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 136)																{
HXDLIN( 136)																	int _hx_tmp6;
HXDLIN( 136)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 136)																		_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 136)																		_hx_tmp6 = blended1;
            																	}
HXDLIN( 136)																	::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp6);
            																}
            															}
            															else {
HXDLIN( 136)																::Dynamic this36 = this2->image;
HXDLIN( 136)																int index5;
HXDLIN( 136)																if (this2->useVirtualPos) {
HXDLIN( 136)																	index5 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																}
            																else {
HXDLIN( 136)																	index5 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																}
HXDLIN( 136)																int _hx_tmp7;
HXDLIN( 136)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 136)																	_hx_tmp7 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            																}
            																else {
HXDLIN( 136)																	_hx_tmp7 = c4;
            																}
HXDLIN( 136)																::iterMagic::Iimg_obj::set(this36,index5,_hx_tmp7);
            															}
            														}
HXLINE( 236)														foundY = true;
            													}
            													else {
HXDLIN( 136)														if (foundY) {
HXDLIN( 136)															goto _hx_goto_221;
            														}
            													}
            												}
            											}
            											_hx_goto_221:;
            										}
            									}
            								}
HXDLIN( 136)								if ((hasHit == false)) {
HXDLIN( 136)									 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN( 136)									if (hasUndo) {
HXDLIN( 136)										v2->undoImage = undoImage;
HXDLIN( 136)										v2->undoX = xIter3->start;
HXDLIN( 136)										v2->undoY = yIter3->start;
            									}
            								}
            							}
            						}
            					}
HXLINE(  85)					lastX = nextX;
HXLINE(  86)					lastY = nextY;
            				}
            			}
            		}
            		else {
HXDLIN( 136)			int _g22 = 0;
HXDLIN( 136)			int _g23 = (quarter + 1);
HXDLIN( 136)			while((_g22 < _g23)){
HXDLIN( 136)				_g22 = (_g22 + 1);
HXDLIN( 136)				int i7 = (_g22 - 1);
HXDLIN( 136)				Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN( 136)				Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN( 136)				{
HXDLIN( 136)					 ::pi_xy::ImageStruct this37 = this1;
HXDLIN( 136)					bool hasHit1 = false;
HXDLIN( 136)					{
HXDLIN( 136)						Float bx1 = lastX;
HXDLIN( 136)						Float by1 = lastY;
HXDLIN( 136)						Float cx2 = nextX1;
HXDLIN( 136)						Float cy2 = nextY1;
HXDLIN( 136)						bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN( 136)						if (!(adjustWinding1)) {
HXDLIN( 136)							Float bx_1 = bx1;
HXDLIN( 136)							Float by_1 = by1;
HXLINE( 187)							bx1 = cx2;
HXLINE( 188)							by1 = cy2;
HXLINE( 189)							cx2 = bx_1;
HXLINE( 190)							cy2 = by_1;
            						}
HXLINE( 136)						{
HXDLIN( 136)							bool hasUndo1 = false;
HXDLIN( 136)							Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN( 136)							Float sx1 = (cy2 - cy);
HXDLIN( 136)							Float sy1 = (cx - cx2);
HXDLIN( 136)							Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN( 136)							Float tx1 = (cy - by1);
HXDLIN( 136)							Float ty1 = (bx1 - cx);
HXDLIN( 136)							Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN( 136)							 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 136)							if ((cx > bx1)) {
HXDLIN( 136)								if ((cx > cx2)) {
HXDLIN( 136)									int min4;
HXDLIN( 136)									if ((bx1 > cx2)) {
HXDLIN( 136)										min4 = ::Math_obj::floor(cx2);
            									}
            									else {
HXDLIN( 136)										min4 = ::Math_obj::floor(bx1);
            									}
HXDLIN( 136)									int ii_min8 = min4;
HXDLIN( 136)									int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN( 136)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            								}
            								else {
HXDLIN( 136)									int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 136)									int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 136)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            								}
            							}
            							else {
HXDLIN( 136)								if ((bx1 > cx2)) {
HXDLIN( 136)									int min5;
HXDLIN( 136)									if ((cx > cx2)) {
HXDLIN( 136)										min5 = ::Math_obj::floor(cx2);
            									}
            									else {
HXDLIN( 136)										min5 = ::Math_obj::ceil(cx);
            									}
HXDLIN( 136)									int ii_min10 = min5;
HXDLIN( 136)									int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 136)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            								}
            								else {
HXDLIN( 136)									int ii_min11 = ::Math_obj::floor(cx);
HXDLIN( 136)									int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 136)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            								}
            							}
HXDLIN( 136)							 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 136)							if ((cy > by1)) {
HXDLIN( 136)								if ((cy > cy2)) {
HXDLIN( 136)									int min6;
HXDLIN( 136)									if ((by1 > cy2)) {
HXDLIN( 136)										min6 = ::Math_obj::floor(cy2);
            									}
            									else {
HXDLIN( 136)										min6 = ::Math_obj::floor(by1);
            									}
HXDLIN( 136)									int ii_min12 = min6;
HXDLIN( 136)									int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN( 136)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            								}
            								else {
HXDLIN( 136)									int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 136)									int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 136)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            								}
            							}
            							else {
HXDLIN( 136)								if ((by1 > cy2)) {
HXDLIN( 136)									int min7;
HXDLIN( 136)									if ((cy > cy2)) {
HXDLIN( 136)										min7 = ::Math_obj::floor(cy2);
            									}
            									else {
HXDLIN( 136)										min7 = ::Math_obj::ceil(cy);
            									}
HXDLIN( 136)									int ii_min14 = min7;
HXDLIN( 136)									int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 136)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            								}
            								else {
HXDLIN( 136)									int ii_min15 = ::Math_obj::floor(cy);
HXDLIN( 136)									int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 136)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            								}
            							}
HXDLIN( 136)							 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 136)							if (hasUndo1) {
HXDLIN( 136)								int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 136)								int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 136)								 ::Dynamic imageType1 = null();
HXDLIN( 136)								 ::pi_xy::ImageStruct this38 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 136)								if (::hx::IsNull( imageType1 )) {
HXLINE(  54)									imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE( 136)								::Dynamic undoImage4;
HXDLIN( 136)								switch((int)(( (int)(imageType1) ))){
            									case (int)0: {
HXDLIN( 136)										 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 136)										 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 136)										{
HXDLIN( 136)											b5->width = width1;
HXDLIN( 136)											b5->height = height1;
HXDLIN( 136)											b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 136)											b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 136)											{
HXDLIN( 136)												int len2 = b5->length;
HXDLIN( 136)												int w1 = 0;
HXDLIN( 136)												{
HXDLIN( 136)													int _g24 = 0;
HXDLIN( 136)													int _g25 = b5->height;
HXDLIN( 136)													while((_g24 < _g25)){
HXDLIN( 136)														_g24 = (_g24 + 1);
HXDLIN( 136)														int y5 = (_g24 - 1);
HXDLIN( 136)														{
HXDLIN( 136)															int _g26 = 0;
HXDLIN( 136)															int _g27 = b5->width;
HXDLIN( 136)															while((_g26 < _g27)){
HXDLIN( 136)																_g26 = (_g26 + 1);
HXDLIN( 136)																int x5 = (_g26 - 1);
HXDLIN( 136)																{
HXDLIN( 136)																	w1 = (w1 + 1);
HXDLIN( 136)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 136)																{
HXDLIN( 136)																	w1 = (w1 + 1);
HXDLIN( 136)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 136)																{
HXDLIN( 136)																	w1 = (w1 + 1);
HXDLIN( 136)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 136)																{
HXDLIN( 136)																	w1 = (w1 + 1);
HXDLIN( 136)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 136)										undoImage4 = b5;
            									}
            									break;
            									case (int)1: {
HXDLIN( 136)										 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 136)										 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 136)										{
HXDLIN( 136)											a6->width = width1;
HXDLIN( 136)											a6->height = height1;
HXDLIN( 136)											a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 136)											a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 136)											{
HXDLIN( 136)												int _g28 = 0;
HXDLIN( 136)												int _g29 = a6->length;
HXDLIN( 136)												while((_g28 < _g29)){
HXDLIN( 136)													_g28 = (_g28 + 1);
HXDLIN( 136)													int i8 = (_g28 - 1);
HXDLIN( 136)													a6->data[i8] = 0;
            												}
            											}
            										}
HXDLIN( 136)										undoImage4 = a6;
            									}
            									break;
            									case (int)2: {
HXDLIN( 136)										 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 136)										 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 136)										{
HXDLIN( 136)											b6->width = width1;
HXDLIN( 136)											b6->height = height1;
HXDLIN( 136)											b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 136)											int size1 = (b6->length * 4);
HXDLIN( 136)											b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 136)											{
HXDLIN( 136)												int _g30 = 0;
HXDLIN( 136)												int _g31 = b6->length;
HXDLIN( 136)												while((_g30 < _g31)){
HXDLIN( 136)													_g30 = (_g30 + 1);
HXDLIN( 136)													int i9 = (_g30 - 1);
HXDLIN( 136)													{
HXDLIN( 136)														 ::haxe::io::ArrayBufferViewImpl this39 = b6->data;
HXDLIN( 136)														bool undoImage5;
HXDLIN( 136)														if ((i9 >= 0)) {
HXDLIN( 136)															undoImage5 = (i9 < (this39->byteLength >> 2));
            														}
            														else {
HXDLIN( 136)															undoImage5 = false;
            														}
HXDLIN( 136)														if (undoImage5) {
HXDLIN( 136)															 ::haxe::io::Bytes _this1 = this39->bytes;
HXDLIN( 136)															int pos1 = ((i9 << 2) + this39->byteOffset);
HXDLIN( 136)															_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 136)															_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 136)															_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 136)															_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN( 136)										undoImage4 = b6;
            									}
            									break;
            									case (int)3: {
HXDLIN( 136)										 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 136)										 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 136)										{
HXDLIN( 136)											v3->width = width1;
HXDLIN( 136)											v3->height = height1;
HXDLIN( 136)											v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 136)											v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 136)											{
HXDLIN( 136)												int _g32 = 0;
HXDLIN( 136)												int _g33 = v3->length;
HXDLIN( 136)												while((_g32 < _g33)){
HXDLIN( 136)													_g32 = (_g32 + 1);
HXDLIN( 136)													int i10 = (_g32 - 1);
HXDLIN( 136)													v3->data->__unsafe_set(i10,0);
            												}
            											}
            										}
HXDLIN( 136)										undoImage4 = v3;
            									}
            									break;
            									case (int)4: {
HXDLIN( 136)										 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 136)										 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 136)										{
HXDLIN( 136)											b7->width = width1;
HXDLIN( 136)											b7->height = height1;
HXDLIN( 136)											b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 136)											b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 136)											{
HXDLIN( 136)												int len3 = b7->length;
HXDLIN( 136)												 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 136)												if (::hx::IsNull( d1->head )) {
HXDLIN( 136)													int _g34 = 0;
HXDLIN( 136)													int _g35 = len3;
HXDLIN( 136)													while((_g34 < _g35)){
HXDLIN( 136)														_g34 = (_g34 + 1);
HXDLIN( 136)														int i11 = (_g34 - 1);
HXDLIN( 136)														d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            													}
            												}
            												else {
HXDLIN( 136)													int _g36 = 0;
HXDLIN( 136)													int _g37 = len3;
HXDLIN( 136)													while((_g36 < _g37)){
HXDLIN( 136)														_g36 = (_g36 + 1);
HXDLIN( 136)														int i12 = (_g36 - 1);
HXDLIN( 136)														{
HXDLIN( 136)															 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 136)															 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 136)															{
HXDLIN( 136)																int _g38 = 0;
HXDLIN( 136)																int _g39 = i12;
HXDLIN( 136)																while((_g38 < _g39)){
HXDLIN( 136)																	_g38 = (_g38 + 1);
HXDLIN( 136)																	int i13 = (_g38 - 1);
HXLINE( 345)																	prev1 = l1;
HXLINE( 346)																	l1 = l1->next;
            																}
            															}
HXLINE( 136)															if (::hx::IsNull( prev1 )) {
HXDLIN( 136)																b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 136)																l1 = null();
            															}
            															else {
HXDLIN( 136)																prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 136)																l1 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 136)										undoImage4 = b7;
            									}
            									break;
            								}
HXDLIN( 136)								this38->image = undoImage4;
HXDLIN( 136)								this38->width = width1;
HXDLIN( 136)								this38->height = height1;
HXDLIN( 136)								this38->imageType = ( (int)(imageType1) );
HXDLIN( 136)								undoImage3 = this38;
HXDLIN( 136)								{
HXDLIN( 136)									int rectLeft1 = xIter31->start;
HXDLIN( 136)									int rectTop1 = yIter31->start;
HXDLIN( 136)									int rectRight1 = xIter31->max;
HXDLIN( 136)									bool forceClear1 = false;
HXDLIN( 136)									{
HXDLIN( 136)										int _g40 = rectTop1;
HXDLIN( 136)										int _g41 = yIter31->max;
HXDLIN( 136)										while((_g40 < _g41)){
HXDLIN( 136)											_g40 = (_g40 + 1);
HXDLIN( 136)											int dy1 = (_g40 - 1);
HXDLIN( 136)											{
HXDLIN( 136)												int _g42 = rectLeft1;
HXDLIN( 136)												int _g43 = rectRight1;
HXDLIN( 136)												while((_g42 < _g43)){
HXDLIN( 136)													_g42 = (_g42 + 1);
HXDLIN( 136)													int dx1 = (_g42 - 1);
HXDLIN( 136)													::Dynamic this40 = this37->image;
HXDLIN( 136)													int index6;
HXDLIN( 136)													if (this37->useVirtualPos) {
HXDLIN( 136)														index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this37->virtualY) * ( (Float)(this37->width) )) + dx1) - this37->virtualX));
            													}
            													else {
HXDLIN( 136)														index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this37->width) + dx1)) ));
            													}
HXDLIN( 136)													int c5 = ::iterMagic::Iimg_obj::get(this40,index6);
HXDLIN( 136)													int col1;
HXDLIN( 136)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 136)														col1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            													}
            													else {
HXDLIN( 136)														col1 = c5;
            													}
HXDLIN( 136)													bool _hx_tmp8;
HXDLIN( 136)													if (this37->useMask) {
HXDLIN( 136)														_hx_tmp8 = ::hx::IsNotNull( this37->mask );
            													}
            													else {
HXDLIN( 136)														_hx_tmp8 = false;
            													}
HXDLIN( 136)													if (_hx_tmp8) {
HXDLIN( 136)														 ::pi_xy::ImageStruct this41 = this37->mask;
HXDLIN( 136)														::Dynamic this42 = this41->image;
HXDLIN( 136)														int index7;
HXDLIN( 136)														if (this41->useVirtualPos) {
HXDLIN( 136)															index7 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this41->virtualY) * ( (Float)(this41->width) )) + dx1) - this41->virtualX));
            														}
            														else {
HXDLIN( 136)															index7 = ::Std_obj::_hx_int(( (Float)(((dy1 * this41->width) + dx1)) ));
            														}
HXDLIN( 136)														int c6 = ::iterMagic::Iimg_obj::get(this42,index7);
HXDLIN( 136)														int v4;
HXDLIN( 136)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 136)															v4 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            														}
            														else {
HXDLIN( 136)															v4 = c6;
            														}
HXDLIN( 136)														int maskPixel1 = v4;
HXDLIN( 136)														int this43 = col1;
HXDLIN( 136)														if ((maskPixel1 == 0)) {
HXDLIN( 136)															col1 = this43;
            														}
            														else {
HXDLIN( 136)															Float m01;
HXDLIN( 136)															int this44 = ((maskPixel1 >> 24) & 255);
HXDLIN( 136)															if ((this44 == 0)) {
HXDLIN( 136)																m01 = ((Float)0.);
            															}
            															else {
HXDLIN( 136)																m01 = (( (Float)(this44) ) / ( (Float)(255) ));
            															}
HXDLIN( 136)															Float m11;
HXDLIN( 136)															int this45 = ((maskPixel1 >> 16) & 255);
HXDLIN( 136)															if ((this45 == 0)) {
HXDLIN( 136)																m11 = ((Float)0.);
            															}
            															else {
HXDLIN( 136)																m11 = (( (Float)(this45) ) / ( (Float)(255) ));
            															}
HXDLIN( 136)															Float m21;
HXDLIN( 136)															int this46 = ((maskPixel1 >> 8) & 255);
HXDLIN( 136)															if ((this46 == 0)) {
HXDLIN( 136)																m21 = ((Float)0.);
            															}
            															else {
HXDLIN( 136)																m21 = (( (Float)(this46) ) / ( (Float)(255) ));
            															}
HXDLIN( 136)															Float m31;
HXDLIN( 136)															int this47 = (maskPixel1 & 255);
HXDLIN( 136)															if ((this47 == 0)) {
HXDLIN( 136)																m31 = ((Float)0.);
            															}
            															else {
HXDLIN( 136)																m31 = (( (Float)(this47) ) / ( (Float)(255) ));
            															}
HXDLIN( 136)															int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this43 >> 24) & 255)) )));
HXDLIN( 136)															int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this43 >> 16) & 255)) )));
HXDLIN( 136)															int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this43 >> 8) & 255)) )));
HXDLIN( 136)															int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this43 & 255)) )));
HXDLIN( 136)															col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN( 136)													if ((col1 != 0)) {
HXDLIN( 136)														int x6 = (dx1 - rectLeft1);
HXDLIN( 136)														int y6 = (dy1 - rectTop1);
HXDLIN( 136)														int c7 = col1;
HXDLIN( 136)														bool _hx_tmp9;
HXDLIN( 136)														if ((((c7 >> 24) & 255) < 254)) {
HXDLIN( 136)															_hx_tmp9 = undoImage3->transparent;
            														}
            														else {
HXDLIN( 136)															_hx_tmp9 = false;
            														}
HXDLIN( 136)														if (_hx_tmp9) {
HXDLIN( 136)															int location2;
HXDLIN( 136)															if (undoImage3->useVirtualPos) {
HXDLIN( 136)																location2 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            															}
            															else {
HXDLIN( 136)																location2 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            															}
HXDLIN( 136)															int this48 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 136)															int this49;
HXDLIN( 136)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 136)																this49 = ((((((this48 >> 24) & 255) << 24) | ((this48 & 255) << 16)) | (((this48 >> 8) & 255) << 8)) | ((this48 >> 16) & 255));
            															}
            															else {
HXDLIN( 136)																this49 = this48;
            															}
HXDLIN( 136)															Float a12;
HXDLIN( 136)															int this50 = ((this49 >> 24) & 255);
HXDLIN( 136)															if ((this50 == 0)) {
HXDLIN( 136)																a12 = ((Float)0.);
            															}
            															else {
HXDLIN( 136)																a12 = (( (Float)(this50) ) / ( (Float)(255) ));
            															}
HXDLIN( 136)															Float r12;
HXDLIN( 136)															int this51 = ((this49 >> 16) & 255);
HXDLIN( 136)															if ((this51 == 0)) {
HXDLIN( 136)																r12 = ((Float)0.);
            															}
            															else {
HXDLIN( 136)																r12 = (( (Float)(this51) ) / ( (Float)(255) ));
            															}
HXDLIN( 136)															Float g12;
HXDLIN( 136)															int this52 = ((this49 >> 8) & 255);
HXDLIN( 136)															if ((this52 == 0)) {
HXDLIN( 136)																g12 = ((Float)0.);
            															}
            															else {
HXDLIN( 136)																g12 = (( (Float)(this52) ) / ( (Float)(255) ));
            															}
HXDLIN( 136)															Float b13;
HXDLIN( 136)															int this53 = (this49 & 255);
HXDLIN( 136)															if ((this53 == 0)) {
HXDLIN( 136)																b13 = ((Float)0.);
            															}
            															else {
HXDLIN( 136)																b13 = (( (Float)(this53) ) / ( (Float)(255) ));
            															}
HXDLIN( 136)															Float a22;
HXDLIN( 136)															int this54 = ((col1 >> 24) & 255);
HXDLIN( 136)															if ((this54 == 0)) {
HXDLIN( 136)																a22 = ((Float)0.);
            															}
            															else {
HXDLIN( 136)																a22 = (( (Float)(this54) ) / ( (Float)(255) ));
            															}
HXDLIN( 136)															Float r22;
HXDLIN( 136)															int this55 = ((col1 >> 16) & 255);
HXDLIN( 136)															if ((this55 == 0)) {
HXDLIN( 136)																r22 = ((Float)0.);
            															}
            															else {
HXDLIN( 136)																r22 = (( (Float)(this55) ) / ( (Float)(255) ));
            															}
HXDLIN( 136)															Float g22;
HXDLIN( 136)															int this56 = ((col1 >> 8) & 255);
HXDLIN( 136)															if ((this56 == 0)) {
HXDLIN( 136)																g22 = ((Float)0.);
            															}
            															else {
HXDLIN( 136)																g22 = (( (Float)(this56) ) / ( (Float)(255) ));
            															}
HXDLIN( 136)															Float b23;
HXDLIN( 136)															int this57 = (col1 & 255);
HXDLIN( 136)															if ((this57 == 0)) {
HXDLIN( 136)																b23 = ((Float)0.);
            															}
            															else {
HXDLIN( 136)																b23 = (( (Float)(this57) ) / ( (Float)(255) ));
            															}
HXDLIN( 136)															Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 136)															int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 136)															int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 136)															int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 136)															int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 136)															int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 136)															{
HXDLIN( 136)																int _hx_tmp10;
HXDLIN( 136)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 136)																	_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																}
            																else {
HXDLIN( 136)																	_hx_tmp10 = blended2;
            																}
HXDLIN( 136)																::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            															}
            														}
            														else {
HXDLIN( 136)															::Dynamic this58 = undoImage3->image;
HXDLIN( 136)															int index8;
HXDLIN( 136)															if (undoImage3->useVirtualPos) {
HXDLIN( 136)																index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            															}
            															else {
HXDLIN( 136)																index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            															}
HXDLIN( 136)															int _hx_tmp11;
HXDLIN( 136)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 136)																_hx_tmp11 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            															}
            															else {
HXDLIN( 136)																_hx_tmp11 = c7;
            															}
HXDLIN( 136)															::iterMagic::Iimg_obj::set(this58,index8,_hx_tmp11);
            														}
            													}
            													else {
HXDLIN( 136)														if (forceClear1) {
HXDLIN( 136)															::Dynamic this59 = undoImage3->image;
HXDLIN( 136)															int x7 = (dx1 - rectLeft1);
HXDLIN( 136)															int y7 = (dy1 - rectTop1);
HXDLIN( 136)															int index9;
HXDLIN( 136)															if (undoImage3->useVirtualPos) {
HXDLIN( 136)																index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x7) - undoImage3->virtualX));
            															}
            															else {
HXDLIN( 136)																index9 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage3->width) + x7)) ));
            															}
HXDLIN( 136)															::iterMagic::Iimg_obj::set(this59,index9,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 136)							bool foundY1 = false;
HXDLIN( 136)							Float s1 = ((Float)0.);
HXDLIN( 136)							Float t1 = ((Float)0.);
HXDLIN( 136)							Float sxx1 = ((Float)0.);
HXDLIN( 136)							Float txx1 = ((Float)0.);
HXDLIN( 136)							{
HXDLIN( 136)								int _g_min2 = xIter31->start;
HXDLIN( 136)								int _g_max2 = xIter31->max;
HXDLIN( 136)								while((_g_min2 < _g_max2)){
HXDLIN( 136)									_g_min2 = (_g_min2 + 1);
HXDLIN( 136)									int x8 = (_g_min2 - 1);
HXLINE( 222)									sxx1 = (sx1 * ( (Float)(x8) ));
HXLINE( 223)									txx1 = (tx1 * ( (Float)(x8) ));
HXLINE( 224)									foundY1 = false;
HXLINE( 136)									{
HXDLIN( 136)										int _g_min3 = yIter31->start;
HXDLIN( 136)										int _g_max3 = yIter31->max;
HXDLIN( 136)										while((_g_min3 < _g_max3)){
HXDLIN( 136)											_g_min3 = (_g_min3 + 1);
HXDLIN( 136)											int y8 = (_g_min3 - 1);
HXLINE( 226)											s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y8) )));
HXLINE( 227)											t1 = ((t01 + txx1) + (ty1 * ( (Float)(y8) )));
HXLINE( 136)											bool _hx_tmp12;
HXDLIN( 136)											if (!((s1 <= 0))) {
HXDLIN( 136)												_hx_tmp12 = (t1 <= 0);
            											}
            											else {
HXDLIN( 136)												_hx_tmp12 = true;
            											}
HXDLIN( 136)											if (_hx_tmp12) {
HXDLIN( 136)												if (foundY1) {
HXDLIN( 136)													goto _hx_goto_234;
            												}
            											}
            											else {
HXDLIN( 136)												if (((s1 + t1) < A1)) {
HXDLIN( 136)													int x9 = ::hx::Mod(x8,tileImage->width);
HXDLIN( 136)													int y9 = ::hx::Mod(y8,tileImage->height);
HXDLIN( 136)													::Dynamic this60 = tileImage->image;
HXDLIN( 136)													int index10;
HXDLIN( 136)													if (tileImage->useVirtualPos) {
HXDLIN( 136)														index10 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x9) - tileImage->virtualX));
            													}
            													else {
HXDLIN( 136)														index10 = ::Std_obj::_hx_int(( (Float)(((y9 * tileImage->width) + x9)) ));
            													}
HXDLIN( 136)													int c8 = ::iterMagic::Iimg_obj::get(this60,index10);
HXDLIN( 136)													int color1;
HXDLIN( 136)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 136)														color1 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            													}
            													else {
HXDLIN( 136)														color1 = c8;
            													}
HXDLIN( 136)													{
HXDLIN( 136)														int c9 = color1;
HXDLIN( 136)														bool _hx_tmp13;
HXDLIN( 136)														if ((((c9 >> 24) & 255) < 254)) {
HXDLIN( 136)															_hx_tmp13 = this37->transparent;
            														}
            														else {
HXDLIN( 136)															_hx_tmp13 = false;
            														}
HXDLIN( 136)														if (_hx_tmp13) {
HXDLIN( 136)															int location3;
HXDLIN( 136)															if (this37->useVirtualPos) {
HXDLIN( 136)																location3 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - this37->virtualY) * ( (Float)(this37->width) )) + x8) - this37->virtualX));
            															}
            															else {
HXDLIN( 136)																location3 = ::Std_obj::_hx_int(( (Float)(((y8 * this37->width) + x8)) ));
            															}
HXDLIN( 136)															int this61 = ::iterMagic::Iimg_obj::get(this37->image,location3);
HXDLIN( 136)															int this62;
HXDLIN( 136)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 136)																this62 = ((((((this61 >> 24) & 255) << 24) | ((this61 & 255) << 16)) | (((this61 >> 8) & 255) << 8)) | ((this61 >> 16) & 255));
            															}
            															else {
HXDLIN( 136)																this62 = this61;
            															}
HXDLIN( 136)															Float a13;
HXDLIN( 136)															int this63 = ((this62 >> 24) & 255);
HXDLIN( 136)															if ((this63 == 0)) {
HXDLIN( 136)																a13 = ((Float)0.);
            															}
            															else {
HXDLIN( 136)																a13 = (( (Float)(this63) ) / ( (Float)(255) ));
            															}
HXDLIN( 136)															Float r13;
HXDLIN( 136)															int this64 = ((this62 >> 16) & 255);
HXDLIN( 136)															if ((this64 == 0)) {
HXDLIN( 136)																r13 = ((Float)0.);
            															}
            															else {
HXDLIN( 136)																r13 = (( (Float)(this64) ) / ( (Float)(255) ));
            															}
HXDLIN( 136)															Float g13;
HXDLIN( 136)															int this65 = ((this62 >> 8) & 255);
HXDLIN( 136)															if ((this65 == 0)) {
HXDLIN( 136)																g13 = ((Float)0.);
            															}
            															else {
HXDLIN( 136)																g13 = (( (Float)(this65) ) / ( (Float)(255) ));
            															}
HXDLIN( 136)															Float b14;
HXDLIN( 136)															int this66 = (this62 & 255);
HXDLIN( 136)															if ((this66 == 0)) {
HXDLIN( 136)																b14 = ((Float)0.);
            															}
            															else {
HXDLIN( 136)																b14 = (( (Float)(this66) ) / ( (Float)(255) ));
            															}
HXDLIN( 136)															Float a23;
HXDLIN( 136)															int this67 = ((color1 >> 24) & 255);
HXDLIN( 136)															if ((this67 == 0)) {
HXDLIN( 136)																a23 = ((Float)0.);
            															}
            															else {
HXDLIN( 136)																a23 = (( (Float)(this67) ) / ( (Float)(255) ));
            															}
HXDLIN( 136)															Float r23;
HXDLIN( 136)															int this68 = ((color1 >> 16) & 255);
HXDLIN( 136)															if ((this68 == 0)) {
HXDLIN( 136)																r23 = ((Float)0.);
            															}
            															else {
HXDLIN( 136)																r23 = (( (Float)(this68) ) / ( (Float)(255) ));
            															}
HXDLIN( 136)															Float g23;
HXDLIN( 136)															int this69 = ((color1 >> 8) & 255);
HXDLIN( 136)															if ((this69 == 0)) {
HXDLIN( 136)																g23 = ((Float)0.);
            															}
            															else {
HXDLIN( 136)																g23 = (( (Float)(this69) ) / ( (Float)(255) ));
            															}
HXDLIN( 136)															Float b24;
HXDLIN( 136)															int this70 = (color1 & 255);
HXDLIN( 136)															if ((this70 == 0)) {
HXDLIN( 136)																b24 = ((Float)0.);
            															}
            															else {
HXDLIN( 136)																b24 = (( (Float)(this70) ) / ( (Float)(255) ));
            															}
HXDLIN( 136)															Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 136)															int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 136)															int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 136)															int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 136)															int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 136)															int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 136)															{
HXDLIN( 136)																int _hx_tmp14;
HXDLIN( 136)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 136)																	_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																}
            																else {
HXDLIN( 136)																	_hx_tmp14 = blended3;
            																}
HXDLIN( 136)																::iterMagic::Iimg_obj::set(this37->image,location3,_hx_tmp14);
            															}
            														}
            														else {
HXDLIN( 136)															::Dynamic this71 = this37->image;
HXDLIN( 136)															int index11;
HXDLIN( 136)															if (this37->useVirtualPos) {
HXDLIN( 136)																index11 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - this37->virtualY) * ( (Float)(this37->width) )) + x8) - this37->virtualX));
            															}
            															else {
HXDLIN( 136)																index11 = ::Std_obj::_hx_int(( (Float)(((y8 * this37->width) + x8)) ));
            															}
HXDLIN( 136)															int _hx_tmp15;
HXDLIN( 136)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 136)																_hx_tmp15 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            															}
            															else {
HXDLIN( 136)																_hx_tmp15 = c9;
            															}
HXDLIN( 136)															::iterMagic::Iimg_obj::set(this71,index11,_hx_tmp15);
            														}
            													}
HXLINE( 236)													foundY1 = true;
            												}
            												else {
HXDLIN( 136)													if (foundY1) {
HXDLIN( 136)														goto _hx_goto_234;
            													}
            												}
            											}
            										}
            										_hx_goto_234:;
            									}
            								}
            							}
HXDLIN( 136)							if ((hasHit1 == false)) {
HXDLIN( 136)								 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN( 136)								if (hasUndo1) {
HXDLIN( 136)									v5->undoImage = undoImage3;
HXDLIN( 136)									v5->undoX = xIter31->start;
HXDLIN( 136)									v5->undoY = yIter31->start;
            								}
            							}
            						}
            					}
            				}
HXLINE(  93)				lastX = nextX1;
HXLINE(  94)				lastY = nextY1;
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(TileShape_Impl__obj,quadrantIII,(void))

void TileShape_Impl__obj::quadrantIV( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float rx,Float ry, ::pi_xy::ImageStruct tileImage, ::Dynamic __o_phi){
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = ((Float)0.);
            	HX_GC_STACKFRAME(&_hx_pos_6e4d7718bf84d356_149_quadrantIV)
HXDLIN( 149)		 ::Dynamic targetError = ((Float)1.05);
HXDLIN( 149)		if (::hx::IsNull( targetError )) {
HXLINE( 101)			targetError = ((Float)1.05);
            		}
HXLINE( 149)		Float rSmall;
HXDLIN( 149)		if ((rx > ry)) {
HXDLIN( 149)			rSmall = ry;
            		}
            		else {
HXDLIN( 149)			rSmall = rx;
            		}
HXDLIN( 149)		 ::Dynamic targetE = ( (Float)(targetError) );
HXDLIN( 149)		if (::hx::IsNull( targetE )) {
HXLINE(  20)			targetE = ((Float)1.05);
            		}
HXLINE( 149)		int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN( 149)		int noSides;
HXDLIN( 149)		if ((result < 12)) {
HXDLIN( 149)			noSides = 12;
            		}
            		else {
HXDLIN( 149)			if ((result > 500)) {
HXDLIN( 149)				noSides = 500;
            			}
            			else {
HXDLIN( 149)				noSides = result;
            			}
            		}
HXDLIN( 149)		int sides = (::Math_obj::ceil((( (Float)(noSides) ) / ( (Float)(4) ))) * 4);
HXDLIN( 149)		Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides) ));
HXDLIN( 149)		Float omega = ( (Float)(0) );
HXDLIN( 149)		int quarter = ::Std_obj::_hx_int((( (Float)(sides) ) / ( (Float)(4) )));
HXDLIN( 149)		Float lastX = ((Float)0.);
HXDLIN( 149)		Float lastY = ((Float)0.);
HXDLIN( 149)		if (::hx::IsNotEq( phi,0 )) {
HXLINE(  70)			lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) )))) + cx);
HXLINE(  71)			lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) )))) + cy);
            		}
            		else {
HXLINE(  73)			lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))));
HXLINE(  74)			lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))));
            		}
HXLINE( 149)		if (::hx::IsNotEq( phi,0 )) {
HXDLIN( 149)			Float cphi = ::Math_obj::cos(( (Float)(phi) ));
HXDLIN( 149)			Float sphi = ::Math_obj::sin(( (Float)(phi) ));
HXDLIN( 149)			{
HXDLIN( 149)				int _g = 0;
HXDLIN( 149)				int _g1 = (quarter + 1);
HXDLIN( 149)				while((_g < _g1)){
HXDLIN( 149)					_g = (_g + 1);
HXDLIN( 149)					int i = (_g - 1);
HXDLIN( 149)					Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega));
HXDLIN( 149)					Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega));
HXDLIN( 149)					Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXDLIN( 149)					Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXDLIN( 149)					{
HXDLIN( 149)						 ::pi_xy::ImageStruct this2 = this1;
HXDLIN( 149)						bool hasHit = false;
HXDLIN( 149)						{
HXDLIN( 149)							Float bx = lastX;
HXDLIN( 149)							Float by = lastY;
HXDLIN( 149)							Float cx1 = nextX;
HXDLIN( 149)							Float cy1 = nextY;
HXDLIN( 149)							bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN( 149)							if (!(adjustWinding)) {
HXDLIN( 149)								Float bx_ = bx;
HXDLIN( 149)								Float by_ = by;
HXLINE( 187)								bx = cx1;
HXLINE( 188)								by = cy1;
HXLINE( 189)								cx1 = bx_;
HXLINE( 190)								cy1 = by_;
            							}
HXLINE( 149)							{
HXDLIN( 149)								bool hasUndo = false;
HXDLIN( 149)								Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN( 149)								Float sx = (cy1 - cy);
HXDLIN( 149)								Float sy = (cx - cx1);
HXDLIN( 149)								Float t0 = ((cx * by) - (cy * bx));
HXDLIN( 149)								Float tx = (cy - by);
HXDLIN( 149)								Float ty = (bx - cx);
HXDLIN( 149)								Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN( 149)								 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 149)								if ((cx > bx)) {
HXDLIN( 149)									if ((cx > cx1)) {
HXDLIN( 149)										int min;
HXDLIN( 149)										if ((bx > cx1)) {
HXDLIN( 149)											min = ::Math_obj::floor(cx1);
            										}
            										else {
HXDLIN( 149)											min = ::Math_obj::floor(bx);
            										}
HXDLIN( 149)										int ii_min = min;
HXDLIN( 149)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 149)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            									}
            									else {
HXDLIN( 149)										int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 149)										int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 149)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            									}
            								}
            								else {
HXDLIN( 149)									if ((bx > cx1)) {
HXDLIN( 149)										int min1;
HXDLIN( 149)										if ((cx > cx1)) {
HXDLIN( 149)											min1 = ::Math_obj::floor(cx1);
            										}
            										else {
HXDLIN( 149)											min1 = ::Math_obj::ceil(cx);
            										}
HXDLIN( 149)										int ii_min2 = min1;
HXDLIN( 149)										int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 149)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            									}
            									else {
HXDLIN( 149)										int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 149)										int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 149)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            									}
            								}
HXDLIN( 149)								 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 149)								if ((cy > by)) {
HXDLIN( 149)									if ((cy > cy1)) {
HXDLIN( 149)										int min2;
HXDLIN( 149)										if ((by > cy1)) {
HXDLIN( 149)											min2 = ::Math_obj::floor(cy1);
            										}
            										else {
HXDLIN( 149)											min2 = ::Math_obj::floor(by);
            										}
HXDLIN( 149)										int ii_min4 = min2;
HXDLIN( 149)										int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 149)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            									}
            									else {
HXDLIN( 149)										int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 149)										int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 149)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            									}
            								}
            								else {
HXDLIN( 149)									if ((by > cy1)) {
HXDLIN( 149)										int min3;
HXDLIN( 149)										if ((cy > cy1)) {
HXDLIN( 149)											min3 = ::Math_obj::floor(cy1);
            										}
            										else {
HXDLIN( 149)											min3 = ::Math_obj::ceil(cy);
            										}
HXDLIN( 149)										int ii_min6 = min3;
HXDLIN( 149)										int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 149)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            									}
            									else {
HXDLIN( 149)										int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 149)										int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 149)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            									}
            								}
HXDLIN( 149)								 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 149)								if (hasUndo) {
HXDLIN( 149)									int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 149)									int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 149)									 ::Dynamic imageType = null();
HXDLIN( 149)									 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 149)									if (::hx::IsNull( imageType )) {
HXLINE(  54)										imageType = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE( 149)									::Dynamic undoImage1;
HXDLIN( 149)									switch((int)(( (int)(imageType) ))){
            										case (int)0: {
HXDLIN( 149)											 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 149)											 ::iterMagic::BytesImg b = byt;
HXDLIN( 149)											{
HXDLIN( 149)												b->width = width;
HXDLIN( 149)												b->height = height;
HXDLIN( 149)												b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 149)												b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 149)												{
HXDLIN( 149)													int len = b->length;
HXDLIN( 149)													int w = 0;
HXDLIN( 149)													{
HXDLIN( 149)														int _g2 = 0;
HXDLIN( 149)														int _g3 = b->height;
HXDLIN( 149)														while((_g2 < _g3)){
HXDLIN( 149)															_g2 = (_g2 + 1);
HXDLIN( 149)															int y = (_g2 - 1);
HXDLIN( 149)															{
HXDLIN( 149)																int _g4 = 0;
HXDLIN( 149)																int _g5 = b->width;
HXDLIN( 149)																while((_g4 < _g5)){
HXDLIN( 149)																	_g4 = (_g4 + 1);
HXDLIN( 149)																	int x = (_g4 - 1);
HXDLIN( 149)																	{
HXDLIN( 149)																		w = (w + 1);
HXDLIN( 149)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 149)																	{
HXDLIN( 149)																		w = (w + 1);
HXDLIN( 149)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 149)																	{
HXDLIN( 149)																		w = (w + 1);
HXDLIN( 149)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN( 149)																	{
HXDLIN( 149)																		w = (w + 1);
HXDLIN( 149)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 149)											undoImage1 = b;
            										}
            										break;
            										case (int)1: {
HXDLIN( 149)											 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 149)											 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 149)											{
HXDLIN( 149)												a->width = width;
HXDLIN( 149)												a->height = height;
HXDLIN( 149)												a->data = ::Array_obj< int >::__new(0);
HXDLIN( 149)												a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 149)												{
HXDLIN( 149)													int _g6 = 0;
HXDLIN( 149)													int _g7 = a->length;
HXDLIN( 149)													while((_g6 < _g7)){
HXDLIN( 149)														_g6 = (_g6 + 1);
HXDLIN( 149)														int i1 = (_g6 - 1);
HXDLIN( 149)														a->data[i1] = 0;
            													}
            												}
            											}
HXDLIN( 149)											undoImage1 = a;
            										}
            										break;
            										case (int)2: {
HXDLIN( 149)											 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 149)											 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 149)											{
HXDLIN( 149)												b1->width = width;
HXDLIN( 149)												b1->height = height;
HXDLIN( 149)												b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 149)												int size = (b1->length * 4);
HXDLIN( 149)												b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 149)												{
HXDLIN( 149)													int _g8 = 0;
HXDLIN( 149)													int _g9 = b1->length;
HXDLIN( 149)													while((_g8 < _g9)){
HXDLIN( 149)														_g8 = (_g8 + 1);
HXDLIN( 149)														int i2 = (_g8 - 1);
HXDLIN( 149)														{
HXDLIN( 149)															 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN( 149)															bool undoImage2;
HXDLIN( 149)															if ((i2 >= 0)) {
HXDLIN( 149)																undoImage2 = (i2 < (this4->byteLength >> 2));
            															}
            															else {
HXDLIN( 149)																undoImage2 = false;
            															}
HXDLIN( 149)															if (undoImage2) {
HXDLIN( 149)																 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN( 149)																int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN( 149)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 149)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 149)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 149)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN( 149)											undoImage1 = b1;
            										}
            										break;
            										case (int)3: {
HXDLIN( 149)											 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 149)											 ::iterMagic::VecIntImg v = vec;
HXDLIN( 149)											{
HXDLIN( 149)												v->width = width;
HXDLIN( 149)												v->height = height;
HXDLIN( 149)												v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 149)												v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 149)												{
HXDLIN( 149)													int _g10 = 0;
HXDLIN( 149)													int _g11 = v->length;
HXDLIN( 149)													while((_g10 < _g11)){
HXDLIN( 149)														_g10 = (_g10 + 1);
HXDLIN( 149)														int i3 = (_g10 - 1);
HXDLIN( 149)														v->data->__unsafe_set(i3,0);
            													}
            												}
            											}
HXDLIN( 149)											undoImage1 = v;
            										}
            										break;
            										case (int)4: {
HXDLIN( 149)											 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 149)											 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 149)											{
HXDLIN( 149)												b2->width = width;
HXDLIN( 149)												b2->height = height;
HXDLIN( 149)												b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 149)												b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 149)												{
HXDLIN( 149)													int len1 = b2->length;
HXDLIN( 149)													 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 149)													if (::hx::IsNull( d->head )) {
HXDLIN( 149)														int _g12 = 0;
HXDLIN( 149)														int _g13 = len1;
HXDLIN( 149)														while((_g12 < _g13)){
HXDLIN( 149)															_g12 = (_g12 + 1);
HXDLIN( 149)															int i4 = (_g12 - 1);
HXDLIN( 149)															d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            														}
            													}
            													else {
HXDLIN( 149)														int _g14 = 0;
HXDLIN( 149)														int _g15 = len1;
HXDLIN( 149)														while((_g14 < _g15)){
HXDLIN( 149)															_g14 = (_g14 + 1);
HXDLIN( 149)															int i5 = (_g14 - 1);
HXDLIN( 149)															{
HXDLIN( 149)																 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 149)																 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 149)																{
HXDLIN( 149)																	int _g16 = 0;
HXDLIN( 149)																	int _g17 = i5;
HXDLIN( 149)																	while((_g16 < _g17)){
HXDLIN( 149)																		_g16 = (_g16 + 1);
HXDLIN( 149)																		int i6 = (_g16 - 1);
HXLINE( 345)																		prev = l;
HXLINE( 346)																		l = l->next;
            																	}
            																}
HXLINE( 149)																if (::hx::IsNull( prev )) {
HXDLIN( 149)																	b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 149)																	l = null();
            																}
            																else {
HXDLIN( 149)																	prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 149)																	l = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN( 149)											undoImage1 = b2;
            										}
            										break;
            									}
HXDLIN( 149)									this3->image = undoImage1;
HXDLIN( 149)									this3->width = width;
HXDLIN( 149)									this3->height = height;
HXDLIN( 149)									this3->imageType = ( (int)(imageType) );
HXDLIN( 149)									undoImage = this3;
HXDLIN( 149)									{
HXDLIN( 149)										int rectLeft = xIter3->start;
HXDLIN( 149)										int rectTop = yIter3->start;
HXDLIN( 149)										int rectRight = xIter3->max;
HXDLIN( 149)										bool forceClear = false;
HXDLIN( 149)										{
HXDLIN( 149)											int _g18 = rectTop;
HXDLIN( 149)											int _g19 = yIter3->max;
HXDLIN( 149)											while((_g18 < _g19)){
HXDLIN( 149)												_g18 = (_g18 + 1);
HXDLIN( 149)												int dy = (_g18 - 1);
HXDLIN( 149)												{
HXDLIN( 149)													int _g20 = rectLeft;
HXDLIN( 149)													int _g21 = rectRight;
HXDLIN( 149)													while((_g20 < _g21)){
HXDLIN( 149)														_g20 = (_g20 + 1);
HXDLIN( 149)														int dx = (_g20 - 1);
HXDLIN( 149)														::Dynamic this5 = this2->image;
HXDLIN( 149)														int index;
HXDLIN( 149)														if (this2->useVirtualPos) {
HXDLIN( 149)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            														}
            														else {
HXDLIN( 149)															index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            														}
HXDLIN( 149)														int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN( 149)														int col;
HXDLIN( 149)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 149)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXDLIN( 149)															col = c;
            														}
HXDLIN( 149)														bool _hx_tmp;
HXDLIN( 149)														if (this2->useMask) {
HXDLIN( 149)															_hx_tmp = ::hx::IsNotNull( this2->mask );
            														}
            														else {
HXDLIN( 149)															_hx_tmp = false;
            														}
HXDLIN( 149)														if (_hx_tmp) {
HXDLIN( 149)															 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN( 149)															::Dynamic this7 = this6->image;
HXDLIN( 149)															int index1;
HXDLIN( 149)															if (this6->useVirtualPos) {
HXDLIN( 149)																index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            															}
            															else {
HXDLIN( 149)																index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            															}
HXDLIN( 149)															int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN( 149)															int v1;
HXDLIN( 149)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 149)																v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            															}
            															else {
HXDLIN( 149)																v1 = c1;
            															}
HXDLIN( 149)															int maskPixel = v1;
HXDLIN( 149)															int this8 = col;
HXDLIN( 149)															if ((maskPixel == 0)) {
HXDLIN( 149)																col = this8;
            															}
            															else {
HXDLIN( 149)																Float m0;
HXDLIN( 149)																int this9 = ((maskPixel >> 24) & 255);
HXDLIN( 149)																if ((this9 == 0)) {
HXDLIN( 149)																	m0 = ((Float)0.);
            																}
            																else {
HXDLIN( 149)																	m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN( 149)																Float m1;
HXDLIN( 149)																int this10 = ((maskPixel >> 16) & 255);
HXDLIN( 149)																if ((this10 == 0)) {
HXDLIN( 149)																	m1 = ((Float)0.);
            																}
            																else {
HXDLIN( 149)																	m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN( 149)																Float m2;
HXDLIN( 149)																int this11 = ((maskPixel >> 8) & 255);
HXDLIN( 149)																if ((this11 == 0)) {
HXDLIN( 149)																	m2 = ((Float)0.);
            																}
            																else {
HXDLIN( 149)																	m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN( 149)																Float m3;
HXDLIN( 149)																int this12 = (maskPixel & 255);
HXDLIN( 149)																if ((this12 == 0)) {
HXDLIN( 149)																	m3 = ((Float)0.);
            																}
            																else {
HXDLIN( 149)																	m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																}
HXDLIN( 149)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN( 149)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN( 149)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN( 149)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN( 149)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN( 149)														if ((col != 0)) {
HXDLIN( 149)															int x1 = (dx - rectLeft);
HXDLIN( 149)															int y1 = (dy - rectTop);
HXDLIN( 149)															int c2 = col;
HXDLIN( 149)															bool _hx_tmp1;
HXDLIN( 149)															if ((((c2 >> 24) & 255) < 254)) {
HXDLIN( 149)																_hx_tmp1 = undoImage->transparent;
            															}
            															else {
HXDLIN( 149)																_hx_tmp1 = false;
            															}
HXDLIN( 149)															if (_hx_tmp1) {
HXDLIN( 149)																int location;
HXDLIN( 149)																if (undoImage->useVirtualPos) {
HXDLIN( 149)																	location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXDLIN( 149)																	location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN( 149)																int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 149)																int this14;
HXDLIN( 149)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 149)																	this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																}
            																else {
HXDLIN( 149)																	this14 = this13;
            																}
HXDLIN( 149)																Float a1;
HXDLIN( 149)																int this15 = ((this14 >> 24) & 255);
HXDLIN( 149)																if ((this15 == 0)) {
HXDLIN( 149)																	a1 = ((Float)0.);
            																}
            																else {
HXDLIN( 149)																	a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																}
HXDLIN( 149)																Float r1;
HXDLIN( 149)																int this16 = ((this14 >> 16) & 255);
HXDLIN( 149)																if ((this16 == 0)) {
HXDLIN( 149)																	r1 = ((Float)0.);
            																}
            																else {
HXDLIN( 149)																	r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																}
HXDLIN( 149)																Float g1;
HXDLIN( 149)																int this17 = ((this14 >> 8) & 255);
HXDLIN( 149)																if ((this17 == 0)) {
HXDLIN( 149)																	g1 = ((Float)0.);
            																}
            																else {
HXDLIN( 149)																	g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																}
HXDLIN( 149)																Float b11;
HXDLIN( 149)																int this18 = (this14 & 255);
HXDLIN( 149)																if ((this18 == 0)) {
HXDLIN( 149)																	b11 = ((Float)0.);
            																}
            																else {
HXDLIN( 149)																	b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																}
HXDLIN( 149)																Float a2;
HXDLIN( 149)																int this19 = ((col >> 24) & 255);
HXDLIN( 149)																if ((this19 == 0)) {
HXDLIN( 149)																	a2 = ((Float)0.);
            																}
            																else {
HXDLIN( 149)																	a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																}
HXDLIN( 149)																Float r2;
HXDLIN( 149)																int this20 = ((col >> 16) & 255);
HXDLIN( 149)																if ((this20 == 0)) {
HXDLIN( 149)																	r2 = ((Float)0.);
            																}
            																else {
HXDLIN( 149)																	r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																}
HXDLIN( 149)																Float g2;
HXDLIN( 149)																int this21 = ((col >> 8) & 255);
HXDLIN( 149)																if ((this21 == 0)) {
HXDLIN( 149)																	g2 = ((Float)0.);
            																}
            																else {
HXDLIN( 149)																	g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																}
HXDLIN( 149)																Float b21;
HXDLIN( 149)																int this22 = (col & 255);
HXDLIN( 149)																if ((this22 == 0)) {
HXDLIN( 149)																	b21 = ((Float)0.);
            																}
            																else {
HXDLIN( 149)																	b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																}
HXDLIN( 149)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 149)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 149)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 149)																int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 149)																int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 149)																int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 149)																{
HXDLIN( 149)																	int _hx_tmp2;
HXDLIN( 149)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 149)																		_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXDLIN( 149)																		_hx_tmp2 = blended;
            																	}
HXDLIN( 149)																	::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																}
            															}
            															else {
HXDLIN( 149)																::Dynamic this23 = undoImage->image;
HXDLIN( 149)																int index2;
HXDLIN( 149)																if (undoImage->useVirtualPos) {
HXDLIN( 149)																	index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXDLIN( 149)																	index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN( 149)																int _hx_tmp3;
HXDLIN( 149)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 149)																	_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																}
            																else {
HXDLIN( 149)																	_hx_tmp3 = c2;
            																}
HXDLIN( 149)																::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            															}
            														}
            														else {
HXDLIN( 149)															if (forceClear) {
HXDLIN( 149)																::Dynamic this24 = undoImage->image;
HXDLIN( 149)																int x2 = (dx - rectLeft);
HXDLIN( 149)																int y2 = (dy - rectTop);
HXDLIN( 149)																int index3;
HXDLIN( 149)																if (undoImage->useVirtualPos) {
HXDLIN( 149)																	index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																}
            																else {
HXDLIN( 149)																	index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																}
HXDLIN( 149)																::iterMagic::Iimg_obj::set(this24,index3,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN( 149)								bool foundY = false;
HXDLIN( 149)								Float s = ((Float)0.);
HXDLIN( 149)								Float t = ((Float)0.);
HXDLIN( 149)								Float sxx = ((Float)0.);
HXDLIN( 149)								Float txx = ((Float)0.);
HXDLIN( 149)								{
HXDLIN( 149)									int _g_min = xIter3->start;
HXDLIN( 149)									int _g_max = xIter3->max;
HXDLIN( 149)									while((_g_min < _g_max)){
HXDLIN( 149)										_g_min = (_g_min + 1);
HXDLIN( 149)										int x3 = (_g_min - 1);
HXLINE( 222)										sxx = (sx * ( (Float)(x3) ));
HXLINE( 223)										txx = (tx * ( (Float)(x3) ));
HXLINE( 224)										foundY = false;
HXLINE( 149)										{
HXDLIN( 149)											int _g_min1 = yIter3->start;
HXDLIN( 149)											int _g_max1 = yIter3->max;
HXDLIN( 149)											while((_g_min1 < _g_max1)){
HXDLIN( 149)												_g_min1 = (_g_min1 + 1);
HXDLIN( 149)												int y3 = (_g_min1 - 1);
HXLINE( 226)												s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE( 227)												t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 149)												bool _hx_tmp4;
HXDLIN( 149)												if (!((s <= 0))) {
HXDLIN( 149)													_hx_tmp4 = (t <= 0);
            												}
            												else {
HXDLIN( 149)													_hx_tmp4 = true;
            												}
HXDLIN( 149)												if (_hx_tmp4) {
HXDLIN( 149)													if (foundY) {
HXDLIN( 149)														goto _hx_goto_248;
            													}
            												}
            												else {
HXDLIN( 149)													if (((s + t) < A)) {
HXDLIN( 149)														int x4 = ::hx::Mod(x3,tileImage->width);
HXDLIN( 149)														int y4 = ::hx::Mod(y3,tileImage->height);
HXDLIN( 149)														::Dynamic this25 = tileImage->image;
HXDLIN( 149)														int index4;
HXDLIN( 149)														if (tileImage->useVirtualPos) {
HXDLIN( 149)															index4 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x4) - tileImage->virtualX));
            														}
            														else {
HXDLIN( 149)															index4 = ::Std_obj::_hx_int(( (Float)(((y4 * tileImage->width) + x4)) ));
            														}
HXDLIN( 149)														int c3 = ::iterMagic::Iimg_obj::get(this25,index4);
HXDLIN( 149)														int color;
HXDLIN( 149)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 149)															color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            														}
            														else {
HXDLIN( 149)															color = c3;
            														}
HXDLIN( 149)														{
HXDLIN( 149)															int c4 = color;
HXDLIN( 149)															bool _hx_tmp5;
HXDLIN( 149)															if ((((c4 >> 24) & 255) < 254)) {
HXDLIN( 149)																_hx_tmp5 = this2->transparent;
            															}
            															else {
HXDLIN( 149)																_hx_tmp5 = false;
            															}
HXDLIN( 149)															if (_hx_tmp5) {
HXDLIN( 149)																int location1;
HXDLIN( 149)																if (this2->useVirtualPos) {
HXDLIN( 149)																	location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																}
            																else {
HXDLIN( 149)																	location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																}
HXDLIN( 149)																int this26 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN( 149)																int this27;
HXDLIN( 149)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 149)																	this27 = ((((((this26 >> 24) & 255) << 24) | ((this26 & 255) << 16)) | (((this26 >> 8) & 255) << 8)) | ((this26 >> 16) & 255));
            																}
            																else {
HXDLIN( 149)																	this27 = this26;
            																}
HXDLIN( 149)																Float a11;
HXDLIN( 149)																int this28 = ((this27 >> 24) & 255);
HXDLIN( 149)																if ((this28 == 0)) {
HXDLIN( 149)																	a11 = ((Float)0.);
            																}
            																else {
HXDLIN( 149)																	a11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																}
HXDLIN( 149)																Float r11;
HXDLIN( 149)																int this29 = ((this27 >> 16) & 255);
HXDLIN( 149)																if ((this29 == 0)) {
HXDLIN( 149)																	r11 = ((Float)0.);
            																}
            																else {
HXDLIN( 149)																	r11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																}
HXDLIN( 149)																Float g11;
HXDLIN( 149)																int this30 = ((this27 >> 8) & 255);
HXDLIN( 149)																if ((this30 == 0)) {
HXDLIN( 149)																	g11 = ((Float)0.);
            																}
            																else {
HXDLIN( 149)																	g11 = (( (Float)(this30) ) / ( (Float)(255) ));
            																}
HXDLIN( 149)																Float b12;
HXDLIN( 149)																int this31 = (this27 & 255);
HXDLIN( 149)																if ((this31 == 0)) {
HXDLIN( 149)																	b12 = ((Float)0.);
            																}
            																else {
HXDLIN( 149)																	b12 = (( (Float)(this31) ) / ( (Float)(255) ));
            																}
HXDLIN( 149)																Float a21;
HXDLIN( 149)																int this32 = ((color >> 24) & 255);
HXDLIN( 149)																if ((this32 == 0)) {
HXDLIN( 149)																	a21 = ((Float)0.);
            																}
            																else {
HXDLIN( 149)																	a21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																}
HXDLIN( 149)																Float r21;
HXDLIN( 149)																int this33 = ((color >> 16) & 255);
HXDLIN( 149)																if ((this33 == 0)) {
HXDLIN( 149)																	r21 = ((Float)0.);
            																}
            																else {
HXDLIN( 149)																	r21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																}
HXDLIN( 149)																Float g21;
HXDLIN( 149)																int this34 = ((color >> 8) & 255);
HXDLIN( 149)																if ((this34 == 0)) {
HXDLIN( 149)																	g21 = ((Float)0.);
            																}
            																else {
HXDLIN( 149)																	g21 = (( (Float)(this34) ) / ( (Float)(255) ));
            																}
HXDLIN( 149)																Float b22;
HXDLIN( 149)																int this35 = (color & 255);
HXDLIN( 149)																if ((this35 == 0)) {
HXDLIN( 149)																	b22 = ((Float)0.);
            																}
            																else {
HXDLIN( 149)																	b22 = (( (Float)(this35) ) / ( (Float)(255) ));
            																}
HXDLIN( 149)																Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 149)																int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 149)																int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 149)																int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 149)																int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 149)																int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 149)																{
HXDLIN( 149)																	int _hx_tmp6;
HXDLIN( 149)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 149)																		_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																	}
            																	else {
HXDLIN( 149)																		_hx_tmp6 = blended1;
            																	}
HXDLIN( 149)																	::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp6);
            																}
            															}
            															else {
HXDLIN( 149)																::Dynamic this36 = this2->image;
HXDLIN( 149)																int index5;
HXDLIN( 149)																if (this2->useVirtualPos) {
HXDLIN( 149)																	index5 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																}
            																else {
HXDLIN( 149)																	index5 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																}
HXDLIN( 149)																int _hx_tmp7;
HXDLIN( 149)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 149)																	_hx_tmp7 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            																}
            																else {
HXDLIN( 149)																	_hx_tmp7 = c4;
            																}
HXDLIN( 149)																::iterMagic::Iimg_obj::set(this36,index5,_hx_tmp7);
            															}
            														}
HXLINE( 236)														foundY = true;
            													}
            													else {
HXDLIN( 149)														if (foundY) {
HXDLIN( 149)															goto _hx_goto_248;
            														}
            													}
            												}
            											}
            											_hx_goto_248:;
            										}
            									}
            								}
HXDLIN( 149)								if ((hasHit == false)) {
HXDLIN( 149)									 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN( 149)									if (hasUndo) {
HXDLIN( 149)										v2->undoImage = undoImage;
HXDLIN( 149)										v2->undoX = xIter3->start;
HXDLIN( 149)										v2->undoY = yIter3->start;
            									}
            								}
            							}
            						}
            					}
HXLINE(  85)					lastX = nextX;
HXLINE(  86)					lastY = nextY;
            				}
            			}
            		}
            		else {
HXDLIN( 149)			int _g22 = 0;
HXDLIN( 149)			int _g23 = (quarter + 1);
HXDLIN( 149)			while((_g22 < _g23)){
HXDLIN( 149)				_g22 = (_g22 + 1);
HXDLIN( 149)				int i7 = (_g22 - 1);
HXDLIN( 149)				Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN( 149)				Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + ((Float)0.0001)) + omega))));
HXDLIN( 149)				{
HXDLIN( 149)					 ::pi_xy::ImageStruct this37 = this1;
HXDLIN( 149)					bool hasHit1 = false;
HXDLIN( 149)					{
HXDLIN( 149)						Float bx1 = lastX;
HXDLIN( 149)						Float by1 = lastY;
HXDLIN( 149)						Float cx2 = nextX1;
HXDLIN( 149)						Float cy2 = nextY1;
HXDLIN( 149)						bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN( 149)						if (!(adjustWinding1)) {
HXDLIN( 149)							Float bx_1 = bx1;
HXDLIN( 149)							Float by_1 = by1;
HXLINE( 187)							bx1 = cx2;
HXLINE( 188)							by1 = cy2;
HXLINE( 189)							cx2 = bx_1;
HXLINE( 190)							cy2 = by_1;
            						}
HXLINE( 149)						{
HXDLIN( 149)							bool hasUndo1 = false;
HXDLIN( 149)							Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN( 149)							Float sx1 = (cy2 - cy);
HXDLIN( 149)							Float sy1 = (cx - cx2);
HXDLIN( 149)							Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN( 149)							Float tx1 = (cy - by1);
HXDLIN( 149)							Float ty1 = (bx1 - cx);
HXDLIN( 149)							Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN( 149)							 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 149)							if ((cx > bx1)) {
HXDLIN( 149)								if ((cx > cx2)) {
HXDLIN( 149)									int min4;
HXDLIN( 149)									if ((bx1 > cx2)) {
HXDLIN( 149)										min4 = ::Math_obj::floor(cx2);
            									}
            									else {
HXDLIN( 149)										min4 = ::Math_obj::floor(bx1);
            									}
HXDLIN( 149)									int ii_min8 = min4;
HXDLIN( 149)									int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN( 149)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            								}
            								else {
HXDLIN( 149)									int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 149)									int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 149)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            								}
            							}
            							else {
HXDLIN( 149)								if ((bx1 > cx2)) {
HXDLIN( 149)									int min5;
HXDLIN( 149)									if ((cx > cx2)) {
HXDLIN( 149)										min5 = ::Math_obj::floor(cx2);
            									}
            									else {
HXDLIN( 149)										min5 = ::Math_obj::ceil(cx);
            									}
HXDLIN( 149)									int ii_min10 = min5;
HXDLIN( 149)									int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 149)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            								}
            								else {
HXDLIN( 149)									int ii_min11 = ::Math_obj::floor(cx);
HXDLIN( 149)									int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 149)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            								}
            							}
HXDLIN( 149)							 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 149)							if ((cy > by1)) {
HXDLIN( 149)								if ((cy > cy2)) {
HXDLIN( 149)									int min6;
HXDLIN( 149)									if ((by1 > cy2)) {
HXDLIN( 149)										min6 = ::Math_obj::floor(cy2);
            									}
            									else {
HXDLIN( 149)										min6 = ::Math_obj::floor(by1);
            									}
HXDLIN( 149)									int ii_min12 = min6;
HXDLIN( 149)									int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN( 149)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            								}
            								else {
HXDLIN( 149)									int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 149)									int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 149)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            								}
            							}
            							else {
HXDLIN( 149)								if ((by1 > cy2)) {
HXDLIN( 149)									int min7;
HXDLIN( 149)									if ((cy > cy2)) {
HXDLIN( 149)										min7 = ::Math_obj::floor(cy2);
            									}
            									else {
HXDLIN( 149)										min7 = ::Math_obj::ceil(cy);
            									}
HXDLIN( 149)									int ii_min14 = min7;
HXDLIN( 149)									int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 149)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            								}
            								else {
HXDLIN( 149)									int ii_min15 = ::Math_obj::floor(cy);
HXDLIN( 149)									int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 149)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            								}
            							}
HXDLIN( 149)							 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 149)							if (hasUndo1) {
HXDLIN( 149)								int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 149)								int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 149)								 ::Dynamic imageType1 = null();
HXDLIN( 149)								 ::pi_xy::ImageStruct this38 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 149)								if (::hx::IsNull( imageType1 )) {
HXLINE(  54)									imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE( 149)								::Dynamic undoImage4;
HXDLIN( 149)								switch((int)(( (int)(imageType1) ))){
            									case (int)0: {
HXDLIN( 149)										 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 149)										 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 149)										{
HXDLIN( 149)											b5->width = width1;
HXDLIN( 149)											b5->height = height1;
HXDLIN( 149)											b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 149)											b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 149)											{
HXDLIN( 149)												int len2 = b5->length;
HXDLIN( 149)												int w1 = 0;
HXDLIN( 149)												{
HXDLIN( 149)													int _g24 = 0;
HXDLIN( 149)													int _g25 = b5->height;
HXDLIN( 149)													while((_g24 < _g25)){
HXDLIN( 149)														_g24 = (_g24 + 1);
HXDLIN( 149)														int y5 = (_g24 - 1);
HXDLIN( 149)														{
HXDLIN( 149)															int _g26 = 0;
HXDLIN( 149)															int _g27 = b5->width;
HXDLIN( 149)															while((_g26 < _g27)){
HXDLIN( 149)																_g26 = (_g26 + 1);
HXDLIN( 149)																int x5 = (_g26 - 1);
HXDLIN( 149)																{
HXDLIN( 149)																	w1 = (w1 + 1);
HXDLIN( 149)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 149)																{
HXDLIN( 149)																	w1 = (w1 + 1);
HXDLIN( 149)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 149)																{
HXDLIN( 149)																	w1 = (w1 + 1);
HXDLIN( 149)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN( 149)																{
HXDLIN( 149)																	w1 = (w1 + 1);
HXDLIN( 149)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 149)										undoImage4 = b5;
            									}
            									break;
            									case (int)1: {
HXDLIN( 149)										 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 149)										 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 149)										{
HXDLIN( 149)											a6->width = width1;
HXDLIN( 149)											a6->height = height1;
HXDLIN( 149)											a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 149)											a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 149)											{
HXDLIN( 149)												int _g28 = 0;
HXDLIN( 149)												int _g29 = a6->length;
HXDLIN( 149)												while((_g28 < _g29)){
HXDLIN( 149)													_g28 = (_g28 + 1);
HXDLIN( 149)													int i8 = (_g28 - 1);
HXDLIN( 149)													a6->data[i8] = 0;
            												}
            											}
            										}
HXDLIN( 149)										undoImage4 = a6;
            									}
            									break;
            									case (int)2: {
HXDLIN( 149)										 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 149)										 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 149)										{
HXDLIN( 149)											b6->width = width1;
HXDLIN( 149)											b6->height = height1;
HXDLIN( 149)											b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 149)											int size1 = (b6->length * 4);
HXDLIN( 149)											b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 149)											{
HXDLIN( 149)												int _g30 = 0;
HXDLIN( 149)												int _g31 = b6->length;
HXDLIN( 149)												while((_g30 < _g31)){
HXDLIN( 149)													_g30 = (_g30 + 1);
HXDLIN( 149)													int i9 = (_g30 - 1);
HXDLIN( 149)													{
HXDLIN( 149)														 ::haxe::io::ArrayBufferViewImpl this39 = b6->data;
HXDLIN( 149)														bool undoImage5;
HXDLIN( 149)														if ((i9 >= 0)) {
HXDLIN( 149)															undoImage5 = (i9 < (this39->byteLength >> 2));
            														}
            														else {
HXDLIN( 149)															undoImage5 = false;
            														}
HXDLIN( 149)														if (undoImage5) {
HXDLIN( 149)															 ::haxe::io::Bytes _this1 = this39->bytes;
HXDLIN( 149)															int pos1 = ((i9 << 2) + this39->byteOffset);
HXDLIN( 149)															_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 149)															_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 149)															_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 149)															_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN( 149)										undoImage4 = b6;
            									}
            									break;
            									case (int)3: {
HXDLIN( 149)										 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 149)										 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 149)										{
HXDLIN( 149)											v3->width = width1;
HXDLIN( 149)											v3->height = height1;
HXDLIN( 149)											v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 149)											v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 149)											{
HXDLIN( 149)												int _g32 = 0;
HXDLIN( 149)												int _g33 = v3->length;
HXDLIN( 149)												while((_g32 < _g33)){
HXDLIN( 149)													_g32 = (_g32 + 1);
HXDLIN( 149)													int i10 = (_g32 - 1);
HXDLIN( 149)													v3->data->__unsafe_set(i10,0);
            												}
            											}
            										}
HXDLIN( 149)										undoImage4 = v3;
            									}
            									break;
            									case (int)4: {
HXDLIN( 149)										 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 149)										 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 149)										{
HXDLIN( 149)											b7->width = width1;
HXDLIN( 149)											b7->height = height1;
HXDLIN( 149)											b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 149)											b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 149)											{
HXDLIN( 149)												int len3 = b7->length;
HXDLIN( 149)												 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 149)												if (::hx::IsNull( d1->head )) {
HXDLIN( 149)													int _g34 = 0;
HXDLIN( 149)													int _g35 = len3;
HXDLIN( 149)													while((_g34 < _g35)){
HXDLIN( 149)														_g34 = (_g34 + 1);
HXDLIN( 149)														int i11 = (_g34 - 1);
HXDLIN( 149)														d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            													}
            												}
            												else {
HXDLIN( 149)													int _g36 = 0;
HXDLIN( 149)													int _g37 = len3;
HXDLIN( 149)													while((_g36 < _g37)){
HXDLIN( 149)														_g36 = (_g36 + 1);
HXDLIN( 149)														int i12 = (_g36 - 1);
HXDLIN( 149)														{
HXDLIN( 149)															 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 149)															 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 149)															{
HXDLIN( 149)																int _g38 = 0;
HXDLIN( 149)																int _g39 = i12;
HXDLIN( 149)																while((_g38 < _g39)){
HXDLIN( 149)																	_g38 = (_g38 + 1);
HXDLIN( 149)																	int i13 = (_g38 - 1);
HXLINE( 345)																	prev1 = l1;
HXLINE( 346)																	l1 = l1->next;
            																}
            															}
HXLINE( 149)															if (::hx::IsNull( prev1 )) {
HXDLIN( 149)																b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 149)																l1 = null();
            															}
            															else {
HXDLIN( 149)																prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 149)																l1 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 149)										undoImage4 = b7;
            									}
            									break;
            								}
HXDLIN( 149)								this38->image = undoImage4;
HXDLIN( 149)								this38->width = width1;
HXDLIN( 149)								this38->height = height1;
HXDLIN( 149)								this38->imageType = ( (int)(imageType1) );
HXDLIN( 149)								undoImage3 = this38;
HXDLIN( 149)								{
HXDLIN( 149)									int rectLeft1 = xIter31->start;
HXDLIN( 149)									int rectTop1 = yIter31->start;
HXDLIN( 149)									int rectRight1 = xIter31->max;
HXDLIN( 149)									bool forceClear1 = false;
HXDLIN( 149)									{
HXDLIN( 149)										int _g40 = rectTop1;
HXDLIN( 149)										int _g41 = yIter31->max;
HXDLIN( 149)										while((_g40 < _g41)){
HXDLIN( 149)											_g40 = (_g40 + 1);
HXDLIN( 149)											int dy1 = (_g40 - 1);
HXDLIN( 149)											{
HXDLIN( 149)												int _g42 = rectLeft1;
HXDLIN( 149)												int _g43 = rectRight1;
HXDLIN( 149)												while((_g42 < _g43)){
HXDLIN( 149)													_g42 = (_g42 + 1);
HXDLIN( 149)													int dx1 = (_g42 - 1);
HXDLIN( 149)													::Dynamic this40 = this37->image;
HXDLIN( 149)													int index6;
HXDLIN( 149)													if (this37->useVirtualPos) {
HXDLIN( 149)														index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this37->virtualY) * ( (Float)(this37->width) )) + dx1) - this37->virtualX));
            													}
            													else {
HXDLIN( 149)														index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this37->width) + dx1)) ));
            													}
HXDLIN( 149)													int c5 = ::iterMagic::Iimg_obj::get(this40,index6);
HXDLIN( 149)													int col1;
HXDLIN( 149)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 149)														col1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            													}
            													else {
HXDLIN( 149)														col1 = c5;
            													}
HXDLIN( 149)													bool _hx_tmp8;
HXDLIN( 149)													if (this37->useMask) {
HXDLIN( 149)														_hx_tmp8 = ::hx::IsNotNull( this37->mask );
            													}
            													else {
HXDLIN( 149)														_hx_tmp8 = false;
            													}
HXDLIN( 149)													if (_hx_tmp8) {
HXDLIN( 149)														 ::pi_xy::ImageStruct this41 = this37->mask;
HXDLIN( 149)														::Dynamic this42 = this41->image;
HXDLIN( 149)														int index7;
HXDLIN( 149)														if (this41->useVirtualPos) {
HXDLIN( 149)															index7 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this41->virtualY) * ( (Float)(this41->width) )) + dx1) - this41->virtualX));
            														}
            														else {
HXDLIN( 149)															index7 = ::Std_obj::_hx_int(( (Float)(((dy1 * this41->width) + dx1)) ));
            														}
HXDLIN( 149)														int c6 = ::iterMagic::Iimg_obj::get(this42,index7);
HXDLIN( 149)														int v4;
HXDLIN( 149)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 149)															v4 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            														}
            														else {
HXDLIN( 149)															v4 = c6;
            														}
HXDLIN( 149)														int maskPixel1 = v4;
HXDLIN( 149)														int this43 = col1;
HXDLIN( 149)														if ((maskPixel1 == 0)) {
HXDLIN( 149)															col1 = this43;
            														}
            														else {
HXDLIN( 149)															Float m01;
HXDLIN( 149)															int this44 = ((maskPixel1 >> 24) & 255);
HXDLIN( 149)															if ((this44 == 0)) {
HXDLIN( 149)																m01 = ((Float)0.);
            															}
            															else {
HXDLIN( 149)																m01 = (( (Float)(this44) ) / ( (Float)(255) ));
            															}
HXDLIN( 149)															Float m11;
HXDLIN( 149)															int this45 = ((maskPixel1 >> 16) & 255);
HXDLIN( 149)															if ((this45 == 0)) {
HXDLIN( 149)																m11 = ((Float)0.);
            															}
            															else {
HXDLIN( 149)																m11 = (( (Float)(this45) ) / ( (Float)(255) ));
            															}
HXDLIN( 149)															Float m21;
HXDLIN( 149)															int this46 = ((maskPixel1 >> 8) & 255);
HXDLIN( 149)															if ((this46 == 0)) {
HXDLIN( 149)																m21 = ((Float)0.);
            															}
            															else {
HXDLIN( 149)																m21 = (( (Float)(this46) ) / ( (Float)(255) ));
            															}
HXDLIN( 149)															Float m31;
HXDLIN( 149)															int this47 = (maskPixel1 & 255);
HXDLIN( 149)															if ((this47 == 0)) {
HXDLIN( 149)																m31 = ((Float)0.);
            															}
            															else {
HXDLIN( 149)																m31 = (( (Float)(this47) ) / ( (Float)(255) ));
            															}
HXDLIN( 149)															int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this43 >> 24) & 255)) )));
HXDLIN( 149)															int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this43 >> 16) & 255)) )));
HXDLIN( 149)															int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this43 >> 8) & 255)) )));
HXDLIN( 149)															int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this43 & 255)) )));
HXDLIN( 149)															col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN( 149)													if ((col1 != 0)) {
HXDLIN( 149)														int x6 = (dx1 - rectLeft1);
HXDLIN( 149)														int y6 = (dy1 - rectTop1);
HXDLIN( 149)														int c7 = col1;
HXDLIN( 149)														bool _hx_tmp9;
HXDLIN( 149)														if ((((c7 >> 24) & 255) < 254)) {
HXDLIN( 149)															_hx_tmp9 = undoImage3->transparent;
            														}
            														else {
HXDLIN( 149)															_hx_tmp9 = false;
            														}
HXDLIN( 149)														if (_hx_tmp9) {
HXDLIN( 149)															int location2;
HXDLIN( 149)															if (undoImage3->useVirtualPos) {
HXDLIN( 149)																location2 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            															}
            															else {
HXDLIN( 149)																location2 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            															}
HXDLIN( 149)															int this48 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 149)															int this49;
HXDLIN( 149)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 149)																this49 = ((((((this48 >> 24) & 255) << 24) | ((this48 & 255) << 16)) | (((this48 >> 8) & 255) << 8)) | ((this48 >> 16) & 255));
            															}
            															else {
HXDLIN( 149)																this49 = this48;
            															}
HXDLIN( 149)															Float a12;
HXDLIN( 149)															int this50 = ((this49 >> 24) & 255);
HXDLIN( 149)															if ((this50 == 0)) {
HXDLIN( 149)																a12 = ((Float)0.);
            															}
            															else {
HXDLIN( 149)																a12 = (( (Float)(this50) ) / ( (Float)(255) ));
            															}
HXDLIN( 149)															Float r12;
HXDLIN( 149)															int this51 = ((this49 >> 16) & 255);
HXDLIN( 149)															if ((this51 == 0)) {
HXDLIN( 149)																r12 = ((Float)0.);
            															}
            															else {
HXDLIN( 149)																r12 = (( (Float)(this51) ) / ( (Float)(255) ));
            															}
HXDLIN( 149)															Float g12;
HXDLIN( 149)															int this52 = ((this49 >> 8) & 255);
HXDLIN( 149)															if ((this52 == 0)) {
HXDLIN( 149)																g12 = ((Float)0.);
            															}
            															else {
HXDLIN( 149)																g12 = (( (Float)(this52) ) / ( (Float)(255) ));
            															}
HXDLIN( 149)															Float b13;
HXDLIN( 149)															int this53 = (this49 & 255);
HXDLIN( 149)															if ((this53 == 0)) {
HXDLIN( 149)																b13 = ((Float)0.);
            															}
            															else {
HXDLIN( 149)																b13 = (( (Float)(this53) ) / ( (Float)(255) ));
            															}
HXDLIN( 149)															Float a22;
HXDLIN( 149)															int this54 = ((col1 >> 24) & 255);
HXDLIN( 149)															if ((this54 == 0)) {
HXDLIN( 149)																a22 = ((Float)0.);
            															}
            															else {
HXDLIN( 149)																a22 = (( (Float)(this54) ) / ( (Float)(255) ));
            															}
HXDLIN( 149)															Float r22;
HXDLIN( 149)															int this55 = ((col1 >> 16) & 255);
HXDLIN( 149)															if ((this55 == 0)) {
HXDLIN( 149)																r22 = ((Float)0.);
            															}
            															else {
HXDLIN( 149)																r22 = (( (Float)(this55) ) / ( (Float)(255) ));
            															}
HXDLIN( 149)															Float g22;
HXDLIN( 149)															int this56 = ((col1 >> 8) & 255);
HXDLIN( 149)															if ((this56 == 0)) {
HXDLIN( 149)																g22 = ((Float)0.);
            															}
            															else {
HXDLIN( 149)																g22 = (( (Float)(this56) ) / ( (Float)(255) ));
            															}
HXDLIN( 149)															Float b23;
HXDLIN( 149)															int this57 = (col1 & 255);
HXDLIN( 149)															if ((this57 == 0)) {
HXDLIN( 149)																b23 = ((Float)0.);
            															}
            															else {
HXDLIN( 149)																b23 = (( (Float)(this57) ) / ( (Float)(255) ));
            															}
HXDLIN( 149)															Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 149)															int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 149)															int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 149)															int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 149)															int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 149)															int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 149)															{
HXDLIN( 149)																int _hx_tmp10;
HXDLIN( 149)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 149)																	_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																}
            																else {
HXDLIN( 149)																	_hx_tmp10 = blended2;
            																}
HXDLIN( 149)																::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            															}
            														}
            														else {
HXDLIN( 149)															::Dynamic this58 = undoImage3->image;
HXDLIN( 149)															int index8;
HXDLIN( 149)															if (undoImage3->useVirtualPos) {
HXDLIN( 149)																index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            															}
            															else {
HXDLIN( 149)																index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            															}
HXDLIN( 149)															int _hx_tmp11;
HXDLIN( 149)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 149)																_hx_tmp11 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            															}
            															else {
HXDLIN( 149)																_hx_tmp11 = c7;
            															}
HXDLIN( 149)															::iterMagic::Iimg_obj::set(this58,index8,_hx_tmp11);
            														}
            													}
            													else {
HXDLIN( 149)														if (forceClear1) {
HXDLIN( 149)															::Dynamic this59 = undoImage3->image;
HXDLIN( 149)															int x7 = (dx1 - rectLeft1);
HXDLIN( 149)															int y7 = (dy1 - rectTop1);
HXDLIN( 149)															int index9;
HXDLIN( 149)															if (undoImage3->useVirtualPos) {
HXDLIN( 149)																index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x7) - undoImage3->virtualX));
            															}
            															else {
HXDLIN( 149)																index9 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage3->width) + x7)) ));
            															}
HXDLIN( 149)															::iterMagic::Iimg_obj::set(this59,index9,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 149)							bool foundY1 = false;
HXDLIN( 149)							Float s1 = ((Float)0.);
HXDLIN( 149)							Float t1 = ((Float)0.);
HXDLIN( 149)							Float sxx1 = ((Float)0.);
HXDLIN( 149)							Float txx1 = ((Float)0.);
HXDLIN( 149)							{
HXDLIN( 149)								int _g_min2 = xIter31->start;
HXDLIN( 149)								int _g_max2 = xIter31->max;
HXDLIN( 149)								while((_g_min2 < _g_max2)){
HXDLIN( 149)									_g_min2 = (_g_min2 + 1);
HXDLIN( 149)									int x8 = (_g_min2 - 1);
HXLINE( 222)									sxx1 = (sx1 * ( (Float)(x8) ));
HXLINE( 223)									txx1 = (tx1 * ( (Float)(x8) ));
HXLINE( 224)									foundY1 = false;
HXLINE( 149)									{
HXDLIN( 149)										int _g_min3 = yIter31->start;
HXDLIN( 149)										int _g_max3 = yIter31->max;
HXDLIN( 149)										while((_g_min3 < _g_max3)){
HXDLIN( 149)											_g_min3 = (_g_min3 + 1);
HXDLIN( 149)											int y8 = (_g_min3 - 1);
HXLINE( 226)											s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y8) )));
HXLINE( 227)											t1 = ((t01 + txx1) + (ty1 * ( (Float)(y8) )));
HXLINE( 149)											bool _hx_tmp12;
HXDLIN( 149)											if (!((s1 <= 0))) {
HXDLIN( 149)												_hx_tmp12 = (t1 <= 0);
            											}
            											else {
HXDLIN( 149)												_hx_tmp12 = true;
            											}
HXDLIN( 149)											if (_hx_tmp12) {
HXDLIN( 149)												if (foundY1) {
HXDLIN( 149)													goto _hx_goto_261;
            												}
            											}
            											else {
HXDLIN( 149)												if (((s1 + t1) < A1)) {
HXDLIN( 149)													int x9 = ::hx::Mod(x8,tileImage->width);
HXDLIN( 149)													int y9 = ::hx::Mod(y8,tileImage->height);
HXDLIN( 149)													::Dynamic this60 = tileImage->image;
HXDLIN( 149)													int index10;
HXDLIN( 149)													if (tileImage->useVirtualPos) {
HXDLIN( 149)														index10 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x9) - tileImage->virtualX));
            													}
            													else {
HXDLIN( 149)														index10 = ::Std_obj::_hx_int(( (Float)(((y9 * tileImage->width) + x9)) ));
            													}
HXDLIN( 149)													int c8 = ::iterMagic::Iimg_obj::get(this60,index10);
HXDLIN( 149)													int color1;
HXDLIN( 149)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 149)														color1 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            													}
            													else {
HXDLIN( 149)														color1 = c8;
            													}
HXDLIN( 149)													{
HXDLIN( 149)														int c9 = color1;
HXDLIN( 149)														bool _hx_tmp13;
HXDLIN( 149)														if ((((c9 >> 24) & 255) < 254)) {
HXDLIN( 149)															_hx_tmp13 = this37->transparent;
            														}
            														else {
HXDLIN( 149)															_hx_tmp13 = false;
            														}
HXDLIN( 149)														if (_hx_tmp13) {
HXDLIN( 149)															int location3;
HXDLIN( 149)															if (this37->useVirtualPos) {
HXDLIN( 149)																location3 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - this37->virtualY) * ( (Float)(this37->width) )) + x8) - this37->virtualX));
            															}
            															else {
HXDLIN( 149)																location3 = ::Std_obj::_hx_int(( (Float)(((y8 * this37->width) + x8)) ));
            															}
HXDLIN( 149)															int this61 = ::iterMagic::Iimg_obj::get(this37->image,location3);
HXDLIN( 149)															int this62;
HXDLIN( 149)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 149)																this62 = ((((((this61 >> 24) & 255) << 24) | ((this61 & 255) << 16)) | (((this61 >> 8) & 255) << 8)) | ((this61 >> 16) & 255));
            															}
            															else {
HXDLIN( 149)																this62 = this61;
            															}
HXDLIN( 149)															Float a13;
HXDLIN( 149)															int this63 = ((this62 >> 24) & 255);
HXDLIN( 149)															if ((this63 == 0)) {
HXDLIN( 149)																a13 = ((Float)0.);
            															}
            															else {
HXDLIN( 149)																a13 = (( (Float)(this63) ) / ( (Float)(255) ));
            															}
HXDLIN( 149)															Float r13;
HXDLIN( 149)															int this64 = ((this62 >> 16) & 255);
HXDLIN( 149)															if ((this64 == 0)) {
HXDLIN( 149)																r13 = ((Float)0.);
            															}
            															else {
HXDLIN( 149)																r13 = (( (Float)(this64) ) / ( (Float)(255) ));
            															}
HXDLIN( 149)															Float g13;
HXDLIN( 149)															int this65 = ((this62 >> 8) & 255);
HXDLIN( 149)															if ((this65 == 0)) {
HXDLIN( 149)																g13 = ((Float)0.);
            															}
            															else {
HXDLIN( 149)																g13 = (( (Float)(this65) ) / ( (Float)(255) ));
            															}
HXDLIN( 149)															Float b14;
HXDLIN( 149)															int this66 = (this62 & 255);
HXDLIN( 149)															if ((this66 == 0)) {
HXDLIN( 149)																b14 = ((Float)0.);
            															}
            															else {
HXDLIN( 149)																b14 = (( (Float)(this66) ) / ( (Float)(255) ));
            															}
HXDLIN( 149)															Float a23;
HXDLIN( 149)															int this67 = ((color1 >> 24) & 255);
HXDLIN( 149)															if ((this67 == 0)) {
HXDLIN( 149)																a23 = ((Float)0.);
            															}
            															else {
HXDLIN( 149)																a23 = (( (Float)(this67) ) / ( (Float)(255) ));
            															}
HXDLIN( 149)															Float r23;
HXDLIN( 149)															int this68 = ((color1 >> 16) & 255);
HXDLIN( 149)															if ((this68 == 0)) {
HXDLIN( 149)																r23 = ((Float)0.);
            															}
            															else {
HXDLIN( 149)																r23 = (( (Float)(this68) ) / ( (Float)(255) ));
            															}
HXDLIN( 149)															Float g23;
HXDLIN( 149)															int this69 = ((color1 >> 8) & 255);
HXDLIN( 149)															if ((this69 == 0)) {
HXDLIN( 149)																g23 = ((Float)0.);
            															}
            															else {
HXDLIN( 149)																g23 = (( (Float)(this69) ) / ( (Float)(255) ));
            															}
HXDLIN( 149)															Float b24;
HXDLIN( 149)															int this70 = (color1 & 255);
HXDLIN( 149)															if ((this70 == 0)) {
HXDLIN( 149)																b24 = ((Float)0.);
            															}
            															else {
HXDLIN( 149)																b24 = (( (Float)(this70) ) / ( (Float)(255) ));
            															}
HXDLIN( 149)															Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 149)															int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 149)															int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 149)															int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 149)															int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 149)															int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 149)															{
HXDLIN( 149)																int _hx_tmp14;
HXDLIN( 149)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 149)																	_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																}
            																else {
HXDLIN( 149)																	_hx_tmp14 = blended3;
            																}
HXDLIN( 149)																::iterMagic::Iimg_obj::set(this37->image,location3,_hx_tmp14);
            															}
            														}
            														else {
HXDLIN( 149)															::Dynamic this71 = this37->image;
HXDLIN( 149)															int index11;
HXDLIN( 149)															if (this37->useVirtualPos) {
HXDLIN( 149)																index11 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - this37->virtualY) * ( (Float)(this37->width) )) + x8) - this37->virtualX));
            															}
            															else {
HXDLIN( 149)																index11 = ::Std_obj::_hx_int(( (Float)(((y8 * this37->width) + x8)) ));
            															}
HXDLIN( 149)															int _hx_tmp15;
HXDLIN( 149)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXDLIN( 149)																_hx_tmp15 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            															}
            															else {
HXDLIN( 149)																_hx_tmp15 = c9;
            															}
HXDLIN( 149)															::iterMagic::Iimg_obj::set(this71,index11,_hx_tmp15);
            														}
            													}
HXLINE( 236)													foundY1 = true;
            												}
            												else {
HXDLIN( 149)													if (foundY1) {
HXDLIN( 149)														goto _hx_goto_261;
            													}
            												}
            											}
            										}
            										_hx_goto_261:;
            									}
            								}
            							}
HXDLIN( 149)							if ((hasHit1 == false)) {
HXDLIN( 149)								 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN( 149)								if (hasUndo1) {
HXDLIN( 149)									v5->undoImage = undoImage3;
HXDLIN( 149)									v5->undoX = xIter31->start;
HXDLIN( 149)									v5->undoY = yIter31->start;
            								}
            							}
            						}
            					}
            				}
HXLINE(  93)				lastX = nextX1;
HXLINE(  94)				lastY = nextY1;
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(TileShape_Impl__obj,quadrantIV,(void))

 ::pi_xy::algo::HitTri TileShape_Impl__obj::sweepTri( ::pi_xy::ImageStruct this1,Float ax,Float ay,Float rx,Float ry,Float startRadian,Float sweepRadian, ::pi_xy::ImageStruct tileImage,::hx::Null< bool >  __o_hasHit){
            		bool hasHit = __o_hasHit.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_6e4d7718bf84d356_160_sweepTri)
HXLINE( 161)		Float currAngle = startRadian;
HXLINE( 162)		Float bx = ((rx * ::Math_obj::cos(currAngle)) + ax);
HXLINE( 163)		Float by = ((ry * ::Math_obj::sin(currAngle)) + ay);
HXLINE( 165)		currAngle = (startRadian + sweepRadian);
HXLINE( 166)		Float cx = ((rx * ::Math_obj::cos(currAngle)) + ax);
HXLINE( 167)		Float cy = ((ry * ::Math_obj::sin(currAngle)) + ay);
HXLINE( 168)		Float bx1 = bx;
HXDLIN( 168)		Float by1 = by;
HXDLIN( 168)		Float cx1 = cx;
HXDLIN( 168)		Float cy1 = cy;
HXDLIN( 168)		bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN( 168)		if (!(adjustWinding)) {
HXLINE( 168)			Float bx_ = bx1;
HXDLIN( 168)			Float by_ = by1;
HXLINE( 187)			bx1 = cx1;
HXLINE( 188)			by1 = cy1;
HXLINE( 189)			cx1 = bx_;
HXLINE( 190)			cy1 = by_;
            		}
HXLINE( 168)		bool hasUndo = false;
HXDLIN( 168)		Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN( 168)		Float sx = (cy1 - ay);
HXDLIN( 168)		Float sy = (ax - cx1);
HXDLIN( 168)		Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN( 168)		Float tx = (ay - by1);
HXDLIN( 168)		Float ty = (bx1 - ax);
HXDLIN( 168)		Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN( 168)		 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 168)		if ((ax > bx1)) {
HXLINE( 168)			if ((ax > cx1)) {
HXLINE( 168)				int min;
HXDLIN( 168)				if ((bx1 > cx1)) {
HXLINE( 168)					min = ::Math_obj::floor(cx1);
            				}
            				else {
HXLINE( 168)					min = ::Math_obj::floor(bx1);
            				}
HXDLIN( 168)				int ii_min = min;
HXDLIN( 168)				int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 168)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            			}
            			else {
HXLINE( 168)				int ii_min1 = ::Math_obj::floor(bx1);
HXDLIN( 168)				int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 168)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            			}
            		}
            		else {
HXLINE( 168)			if ((bx1 > cx1)) {
HXLINE( 168)				int min1;
HXDLIN( 168)				if ((ax > cx1)) {
HXLINE( 168)					min1 = ::Math_obj::floor(cx1);
            				}
            				else {
HXLINE( 168)					min1 = ::Math_obj::ceil(ax);
            				}
HXDLIN( 168)				int ii_min2 = min1;
HXDLIN( 168)				int ii_max2 = ::Math_obj::ceil(bx1);
HXDLIN( 168)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            			}
            			else {
HXLINE( 168)				int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 168)				int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 168)				xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            			}
            		}
HXDLIN( 168)		 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 168)		if ((ay > by1)) {
HXLINE( 168)			if ((ay > cy1)) {
HXLINE( 168)				int min2;
HXDLIN( 168)				if ((by1 > cy1)) {
HXLINE( 168)					min2 = ::Math_obj::floor(cy1);
            				}
            				else {
HXLINE( 168)					min2 = ::Math_obj::floor(by1);
            				}
HXDLIN( 168)				int ii_min4 = min2;
HXDLIN( 168)				int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 168)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            			}
            			else {
HXLINE( 168)				int ii_min5 = ::Math_obj::floor(by1);
HXDLIN( 168)				int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 168)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            			}
            		}
            		else {
HXLINE( 168)			if ((by1 > cy1)) {
HXLINE( 168)				int min3;
HXDLIN( 168)				if ((ay > cy1)) {
HXLINE( 168)					min3 = ::Math_obj::floor(cy1);
            				}
            				else {
HXLINE( 168)					min3 = ::Math_obj::ceil(ay);
            				}
HXDLIN( 168)				int ii_min6 = min3;
HXDLIN( 168)				int ii_max6 = ::Math_obj::ceil(by1);
HXDLIN( 168)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            			}
            			else {
HXLINE( 168)				int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 168)				int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 168)				yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            			}
            		}
HXDLIN( 168)		 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 168)		if (hasUndo) {
HXLINE( 168)			int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 168)			int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 168)			 ::Dynamic imageType = null();
HXDLIN( 168)			 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 168)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 168)			::Dynamic undoImage1;
HXDLIN( 168)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXLINE( 168)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 168)					 ::iterMagic::BytesImg b = byt;
HXDLIN( 168)					{
HXLINE( 168)						b->width = width;
HXDLIN( 168)						b->height = height;
HXDLIN( 168)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 168)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 168)						{
HXLINE( 168)							int len = b->length;
HXDLIN( 168)							int w = 0;
HXDLIN( 168)							{
HXLINE( 168)								int _g = 0;
HXDLIN( 168)								int _g1 = b->height;
HXDLIN( 168)								while((_g < _g1)){
HXLINE( 168)									_g = (_g + 1);
HXDLIN( 168)									int y = (_g - 1);
HXDLIN( 168)									{
HXLINE( 168)										int _g2 = 0;
HXDLIN( 168)										int _g3 = b->width;
HXDLIN( 168)										while((_g2 < _g3)){
HXLINE( 168)											_g2 = (_g2 + 1);
HXDLIN( 168)											int x = (_g2 - 1);
HXDLIN( 168)											{
HXLINE( 168)												w = (w + 1);
HXDLIN( 168)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 168)											{
HXLINE( 168)												w = (w + 1);
HXDLIN( 168)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 168)											{
HXLINE( 168)												w = (w + 1);
HXDLIN( 168)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 168)											{
HXLINE( 168)												w = (w + 1);
HXDLIN( 168)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 168)					undoImage1 = b;
            				}
            				break;
            				case (int)1: {
HXLINE( 168)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 168)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 168)					{
HXLINE( 168)						a->width = width;
HXDLIN( 168)						a->height = height;
HXDLIN( 168)						a->data = ::Array_obj< int >::__new(0);
HXDLIN( 168)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 168)						{
HXLINE( 168)							int _g4 = 0;
HXDLIN( 168)							int _g5 = a->length;
HXDLIN( 168)							while((_g4 < _g5)){
HXLINE( 168)								_g4 = (_g4 + 1);
HXDLIN( 168)								int i = (_g4 - 1);
HXDLIN( 168)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN( 168)					undoImage1 = a;
            				}
            				break;
            				case (int)2: {
HXLINE( 168)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 168)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 168)					{
HXLINE( 168)						b1->width = width;
HXDLIN( 168)						b1->height = height;
HXDLIN( 168)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 168)						int size = (b1->length * 4);
HXDLIN( 168)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 168)						{
HXLINE( 168)							int _g6 = 0;
HXDLIN( 168)							int _g7 = b1->length;
HXDLIN( 168)							while((_g6 < _g7)){
HXLINE( 168)								_g6 = (_g6 + 1);
HXDLIN( 168)								int i1 = (_g6 - 1);
HXDLIN( 168)								{
HXLINE( 168)									 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 168)									bool undoImage2;
HXDLIN( 168)									if ((i1 >= 0)) {
HXLINE( 168)										undoImage2 = (i1 < (this3->byteLength >> 2));
            									}
            									else {
HXLINE( 168)										undoImage2 = false;
            									}
HXDLIN( 168)									if (undoImage2) {
HXLINE( 168)										 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 168)										int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN( 168)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 168)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 168)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 168)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 168)					undoImage1 = b1;
            				}
            				break;
            				case (int)3: {
HXLINE( 168)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 168)					 ::iterMagic::VecIntImg v = vec;
HXDLIN( 168)					{
HXLINE( 168)						v->width = width;
HXDLIN( 168)						v->height = height;
HXDLIN( 168)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 168)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 168)						{
HXLINE( 168)							int _g8 = 0;
HXDLIN( 168)							int _g9 = v->length;
HXDLIN( 168)							while((_g8 < _g9)){
HXLINE( 168)								_g8 = (_g8 + 1);
HXDLIN( 168)								int i2 = (_g8 - 1);
HXDLIN( 168)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN( 168)					undoImage1 = v;
            				}
            				break;
            				case (int)4: {
HXLINE( 168)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 168)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 168)					{
HXLINE( 168)						b2->width = width;
HXDLIN( 168)						b2->height = height;
HXDLIN( 168)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 168)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 168)						{
HXLINE( 168)							int len1 = b2->length;
HXDLIN( 168)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 168)							if (::hx::IsNull( d->head )) {
HXLINE( 168)								int _g10 = 0;
HXDLIN( 168)								int _g11 = len1;
HXDLIN( 168)								while((_g10 < _g11)){
HXLINE( 168)									_g10 = (_g10 + 1);
HXDLIN( 168)									int i3 = (_g10 - 1);
HXDLIN( 168)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXLINE( 168)								int _g12 = 0;
HXDLIN( 168)								int _g13 = len1;
HXDLIN( 168)								while((_g12 < _g13)){
HXLINE( 168)									_g12 = (_g12 + 1);
HXDLIN( 168)									int i4 = (_g12 - 1);
HXDLIN( 168)									{
HXLINE( 168)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 168)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 168)										{
HXLINE( 168)											int _g14 = 0;
HXDLIN( 168)											int _g15 = i4;
HXDLIN( 168)											while((_g14 < _g15)){
HXLINE( 168)												_g14 = (_g14 + 1);
HXDLIN( 168)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE( 168)										if (::hx::IsNull( prev )) {
HXLINE( 168)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 168)											l = null();
            										}
            										else {
HXLINE( 168)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 168)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 168)					undoImage1 = b2;
            				}
            				break;
            			}
HXDLIN( 168)			this2->image = undoImage1;
HXDLIN( 168)			this2->width = width;
HXDLIN( 168)			this2->height = height;
HXDLIN( 168)			this2->imageType = ( (int)(imageType) );
HXDLIN( 168)			undoImage = this2;
HXDLIN( 168)			{
HXLINE( 168)				int rectLeft = xIter3->start;
HXDLIN( 168)				int rectTop = yIter3->start;
HXDLIN( 168)				int rectRight = xIter3->max;
HXDLIN( 168)				bool forceClear = false;
HXDLIN( 168)				{
HXLINE( 168)					int _g16 = rectTop;
HXDLIN( 168)					int _g17 = yIter3->max;
HXDLIN( 168)					while((_g16 < _g17)){
HXLINE( 168)						_g16 = (_g16 + 1);
HXDLIN( 168)						int dy = (_g16 - 1);
HXDLIN( 168)						{
HXLINE( 168)							int _g18 = rectLeft;
HXDLIN( 168)							int _g19 = rectRight;
HXDLIN( 168)							while((_g18 < _g19)){
HXLINE( 168)								_g18 = (_g18 + 1);
HXDLIN( 168)								int dx = (_g18 - 1);
HXDLIN( 168)								::Dynamic this4 = this1->image;
HXDLIN( 168)								int index;
HXDLIN( 168)								if (this1->useVirtualPos) {
HXLINE( 168)									index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            								}
            								else {
HXLINE( 168)									index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            								}
HXDLIN( 168)								int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN( 168)								int col;
HXDLIN( 168)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 168)									col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE( 168)									col = c;
            								}
HXDLIN( 168)								bool _hx_tmp;
HXDLIN( 168)								if (this1->useMask) {
HXLINE( 168)									_hx_tmp = ::hx::IsNotNull( this1->mask );
            								}
            								else {
HXLINE( 168)									_hx_tmp = false;
            								}
HXDLIN( 168)								if (_hx_tmp) {
HXLINE( 168)									 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN( 168)									::Dynamic this6 = this5->image;
HXDLIN( 168)									int index1;
HXDLIN( 168)									if (this5->useVirtualPos) {
HXLINE( 168)										index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx) - this5->virtualX));
            									}
            									else {
HXLINE( 168)										index1 = ::Std_obj::_hx_int(( (Float)(((dy * this5->width) + dx)) ));
            									}
HXDLIN( 168)									int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN( 168)									int v1;
HXDLIN( 168)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 168)										v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            									}
            									else {
HXLINE( 168)										v1 = c1;
            									}
HXDLIN( 168)									int maskPixel = v1;
HXDLIN( 168)									int this7 = col;
HXDLIN( 168)									if ((maskPixel == 0)) {
HXLINE( 168)										col = this7;
            									}
            									else {
HXLINE( 168)										Float m0;
HXDLIN( 168)										int this8 = ((maskPixel >> 24) & 255);
HXDLIN( 168)										if ((this8 == 0)) {
HXLINE( 168)											m0 = ((Float)0.);
            										}
            										else {
HXLINE( 168)											m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            										}
HXDLIN( 168)										Float m1;
HXDLIN( 168)										int this9 = ((maskPixel >> 16) & 255);
HXDLIN( 168)										if ((this9 == 0)) {
HXLINE( 168)											m1 = ((Float)0.);
            										}
            										else {
HXLINE( 168)											m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            										}
HXDLIN( 168)										Float m2;
HXDLIN( 168)										int this10 = ((maskPixel >> 8) & 255);
HXDLIN( 168)										if ((this10 == 0)) {
HXLINE( 168)											m2 = ((Float)0.);
            										}
            										else {
HXLINE( 168)											m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            										}
HXDLIN( 168)										Float m3;
HXDLIN( 168)										int this11 = (maskPixel & 255);
HXDLIN( 168)										if ((this11 == 0)) {
HXLINE( 168)											m3 = ((Float)0.);
            										}
            										else {
HXLINE( 168)											m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            										}
HXDLIN( 168)										int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN( 168)										int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN( 168)										int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN( 168)										int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN( 168)										col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 168)								if ((col != 0)) {
HXLINE( 168)									int x1 = (dx - rectLeft);
HXDLIN( 168)									int y1 = (dy - rectTop);
HXDLIN( 168)									int c2 = col;
HXDLIN( 168)									bool _hx_tmp1;
HXDLIN( 168)									if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 168)										_hx_tmp1 = undoImage->transparent;
            									}
            									else {
HXLINE( 168)										_hx_tmp1 = false;
            									}
HXDLIN( 168)									if (_hx_tmp1) {
HXLINE( 168)										int location;
HXDLIN( 168)										if (undoImage->useVirtualPos) {
HXLINE( 168)											location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 168)											location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 168)										int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 168)										int this13;
HXDLIN( 168)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 168)											this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            										}
            										else {
HXLINE( 168)											this13 = this12;
            										}
HXDLIN( 168)										Float a1;
HXDLIN( 168)										int this14 = ((this13 >> 24) & 255);
HXDLIN( 168)										if ((this14 == 0)) {
HXLINE( 168)											a1 = ((Float)0.);
            										}
            										else {
HXLINE( 168)											a1 = (( (Float)(this14) ) / ( (Float)(255) ));
            										}
HXDLIN( 168)										Float r1;
HXDLIN( 168)										int this15 = ((this13 >> 16) & 255);
HXDLIN( 168)										if ((this15 == 0)) {
HXLINE( 168)											r1 = ((Float)0.);
            										}
            										else {
HXLINE( 168)											r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            										}
HXDLIN( 168)										Float g1;
HXDLIN( 168)										int this16 = ((this13 >> 8) & 255);
HXDLIN( 168)										if ((this16 == 0)) {
HXLINE( 168)											g1 = ((Float)0.);
            										}
            										else {
HXLINE( 168)											g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            										}
HXDLIN( 168)										Float b11;
HXDLIN( 168)										int this17 = (this13 & 255);
HXDLIN( 168)										if ((this17 == 0)) {
HXLINE( 168)											b11 = ((Float)0.);
            										}
            										else {
HXLINE( 168)											b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            										}
HXDLIN( 168)										Float a2;
HXDLIN( 168)										int this18 = ((col >> 24) & 255);
HXDLIN( 168)										if ((this18 == 0)) {
HXLINE( 168)											a2 = ((Float)0.);
            										}
            										else {
HXLINE( 168)											a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            										}
HXDLIN( 168)										Float r2;
HXDLIN( 168)										int this19 = ((col >> 16) & 255);
HXDLIN( 168)										if ((this19 == 0)) {
HXLINE( 168)											r2 = ((Float)0.);
            										}
            										else {
HXLINE( 168)											r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            										}
HXDLIN( 168)										Float g2;
HXDLIN( 168)										int this20 = ((col >> 8) & 255);
HXDLIN( 168)										if ((this20 == 0)) {
HXLINE( 168)											g2 = ((Float)0.);
            										}
            										else {
HXLINE( 168)											g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            										}
HXDLIN( 168)										Float b21;
HXDLIN( 168)										int this21 = (col & 255);
HXDLIN( 168)										if ((this21 == 0)) {
HXLINE( 168)											b21 = ((Float)0.);
            										}
            										else {
HXLINE( 168)											b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            										}
HXDLIN( 168)										Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 168)										int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 168)										int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 168)										int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 168)										int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 168)										int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 168)										{
HXLINE( 168)											int _hx_tmp2;
HXDLIN( 168)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 168)												_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            											}
            											else {
HXLINE( 168)												_hx_tmp2 = blended;
            											}
HXDLIN( 168)											::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            										}
            									}
            									else {
HXLINE( 168)										::Dynamic this22 = undoImage->image;
HXDLIN( 168)										int index2;
HXDLIN( 168)										if (undoImage->useVirtualPos) {
HXLINE( 168)											index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            										}
            										else {
HXLINE( 168)											index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            										}
HXDLIN( 168)										int _hx_tmp3;
HXDLIN( 168)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 168)											_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            										}
            										else {
HXLINE( 168)											_hx_tmp3 = c2;
            										}
HXDLIN( 168)										::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp3);
            									}
            								}
            								else {
HXLINE( 168)									if (forceClear) {
HXLINE( 168)										::Dynamic this23 = undoImage->image;
HXDLIN( 168)										int x2 = (dx - rectLeft);
HXDLIN( 168)										int y2 = (dy - rectTop);
HXDLIN( 168)										int index3;
HXDLIN( 168)										if (undoImage->useVirtualPos) {
HXLINE( 168)											index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            										}
            										else {
HXLINE( 168)											index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            										}
HXDLIN( 168)										::iterMagic::Iimg_obj::set(this23,index3,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 168)		bool foundY = false;
HXDLIN( 168)		Float s = ((Float)0.);
HXDLIN( 168)		Float t = ((Float)0.);
HXDLIN( 168)		Float sxx = ((Float)0.);
HXDLIN( 168)		Float txx = ((Float)0.);
HXDLIN( 168)		{
HXLINE( 168)			int _g_min = xIter3->start;
HXDLIN( 168)			int _g_max = xIter3->max;
HXDLIN( 168)			while((_g_min < _g_max)){
HXLINE( 168)				_g_min = (_g_min + 1);
HXDLIN( 168)				int x3 = (_g_min - 1);
HXLINE( 222)				sxx = (sx * ( (Float)(x3) ));
HXLINE( 223)				txx = (tx * ( (Float)(x3) ));
HXLINE( 224)				foundY = false;
HXLINE( 168)				{
HXLINE( 168)					int _g_min1 = yIter3->start;
HXDLIN( 168)					int _g_max1 = yIter3->max;
HXDLIN( 168)					while((_g_min1 < _g_max1)){
HXLINE( 168)						_g_min1 = (_g_min1 + 1);
HXDLIN( 168)						int y3 = (_g_min1 - 1);
HXLINE( 226)						s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE( 227)						t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 168)						bool _hx_tmp4;
HXDLIN( 168)						if (!((s <= 0))) {
HXLINE( 168)							_hx_tmp4 = (t <= 0);
            						}
            						else {
HXLINE( 168)							_hx_tmp4 = true;
            						}
HXDLIN( 168)						if (_hx_tmp4) {
HXLINE( 168)							if (foundY) {
HXLINE( 168)								goto _hx_goto_274;
            							}
            						}
            						else {
HXLINE( 168)							if (((s + t) < A)) {
HXLINE( 168)								int x4 = ::hx::Mod(x3,tileImage->width);
HXDLIN( 168)								int y4 = ::hx::Mod(y3,tileImage->height);
HXDLIN( 168)								::Dynamic this24 = tileImage->image;
HXDLIN( 168)								int index4;
HXDLIN( 168)								if (tileImage->useVirtualPos) {
HXLINE( 168)									index4 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x4) - tileImage->virtualX));
            								}
            								else {
HXLINE( 168)									index4 = ::Std_obj::_hx_int(( (Float)(((y4 * tileImage->width) + x4)) ));
            								}
HXDLIN( 168)								int c3 = ::iterMagic::Iimg_obj::get(this24,index4);
HXDLIN( 168)								int color;
HXDLIN( 168)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 168)									color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            								}
            								else {
HXLINE( 168)									color = c3;
            								}
HXDLIN( 168)								{
HXLINE( 168)									int c4 = color;
HXDLIN( 168)									bool _hx_tmp5;
HXDLIN( 168)									if ((((c4 >> 24) & 255) < 254)) {
HXLINE( 168)										_hx_tmp5 = this1->transparent;
            									}
            									else {
HXLINE( 168)										_hx_tmp5 = false;
            									}
HXDLIN( 168)									if (_hx_tmp5) {
HXLINE( 168)										int location1;
HXDLIN( 168)										if (this1->useVirtualPos) {
HXLINE( 168)											location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            										}
            										else {
HXLINE( 168)											location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            										}
HXDLIN( 168)										int this25 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN( 168)										int this26;
HXDLIN( 168)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 168)											this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            										}
            										else {
HXLINE( 168)											this26 = this25;
            										}
HXDLIN( 168)										Float a11;
HXDLIN( 168)										int this27 = ((this26 >> 24) & 255);
HXDLIN( 168)										if ((this27 == 0)) {
HXLINE( 168)											a11 = ((Float)0.);
            										}
            										else {
HXLINE( 168)											a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            										}
HXDLIN( 168)										Float r11;
HXDLIN( 168)										int this28 = ((this26 >> 16) & 255);
HXDLIN( 168)										if ((this28 == 0)) {
HXLINE( 168)											r11 = ((Float)0.);
            										}
            										else {
HXLINE( 168)											r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            										}
HXDLIN( 168)										Float g11;
HXDLIN( 168)										int this29 = ((this26 >> 8) & 255);
HXDLIN( 168)										if ((this29 == 0)) {
HXLINE( 168)											g11 = ((Float)0.);
            										}
            										else {
HXLINE( 168)											g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            										}
HXDLIN( 168)										Float b12;
HXDLIN( 168)										int this30 = (this26 & 255);
HXDLIN( 168)										if ((this30 == 0)) {
HXLINE( 168)											b12 = ((Float)0.);
            										}
            										else {
HXLINE( 168)											b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            										}
HXDLIN( 168)										Float a21;
HXDLIN( 168)										int this31 = ((color >> 24) & 255);
HXDLIN( 168)										if ((this31 == 0)) {
HXLINE( 168)											a21 = ((Float)0.);
            										}
            										else {
HXLINE( 168)											a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            										}
HXDLIN( 168)										Float r21;
HXDLIN( 168)										int this32 = ((color >> 16) & 255);
HXDLIN( 168)										if ((this32 == 0)) {
HXLINE( 168)											r21 = ((Float)0.);
            										}
            										else {
HXLINE( 168)											r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            										}
HXDLIN( 168)										Float g21;
HXDLIN( 168)										int this33 = ((color >> 8) & 255);
HXDLIN( 168)										if ((this33 == 0)) {
HXLINE( 168)											g21 = ((Float)0.);
            										}
            										else {
HXLINE( 168)											g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            										}
HXDLIN( 168)										Float b22;
HXDLIN( 168)										int this34 = (color & 255);
HXDLIN( 168)										if ((this34 == 0)) {
HXLINE( 168)											b22 = ((Float)0.);
            										}
            										else {
HXLINE( 168)											b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            										}
HXDLIN( 168)										Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 168)										int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 168)										int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 168)										int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 168)										int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 168)										int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 168)										{
HXLINE( 168)											int _hx_tmp6;
HXDLIN( 168)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 168)												_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            											}
            											else {
HXLINE( 168)												_hx_tmp6 = blended1;
            											}
HXDLIN( 168)											::iterMagic::Iimg_obj::set(this1->image,location1,_hx_tmp6);
            										}
            									}
            									else {
HXLINE( 168)										::Dynamic this35 = this1->image;
HXDLIN( 168)										int index5;
HXDLIN( 168)										if (this1->useVirtualPos) {
HXLINE( 168)											index5 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            										}
            										else {
HXLINE( 168)											index5 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            										}
HXDLIN( 168)										int _hx_tmp7;
HXDLIN( 168)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 168)											_hx_tmp7 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            										}
            										else {
HXLINE( 168)											_hx_tmp7 = c4;
            										}
HXDLIN( 168)										::iterMagic::Iimg_obj::set(this35,index5,_hx_tmp7);
            									}
            								}
HXLINE( 236)								foundY = true;
            							}
            							else {
HXLINE( 168)								if (foundY) {
HXLINE( 168)									goto _hx_goto_274;
            								}
            							}
            						}
            					}
            					_hx_goto_274:;
            				}
            			}
            		}
HXDLIN( 168)		if ((hasHit == false)) {
HXLINE( 168)			 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx1,by1,cx1,cy1,true);
HXDLIN( 168)			if (hasUndo) {
HXLINE( 168)				v2->undoImage = undoImage;
HXDLIN( 168)				v2->undoX = xIter3->start;
HXDLIN( 168)				v2->undoY = yIter3->start;
            			}
HXDLIN( 168)			return v2;
            		}
            		else {
HXLINE( 168)			return null();
            		}
HXDLIN( 168)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(TileShape_Impl__obj,sweepTri,return )

 ::pi_xy::algo::HitTriArray TileShape_Impl__obj::pie( ::pi_xy::ImageStruct this1,Float ax,Float ay,Float rx,Float ry,Float startRadian,Float sweepRadian, ::pi_xy::ImageStruct tileImage,::hx::Null< bool >  __o_hasHit, ::Dynamic __o_targetError){
            		bool hasHit = __o_hasHit.Default(false);
            		 ::Dynamic targetError = __o_targetError;
            		if (::hx::IsNull(__o_targetError)) targetError = ((Float)1.05);
            	HX_GC_STACKFRAME(&_hx_pos_6e4d7718bf84d356_177_pie)
HXLINE( 178)		Float rSmall;
HXDLIN( 178)		if ((rx > ry)) {
HXLINE( 178)			rSmall = ry;
            		}
            		else {
HXLINE( 178)			rSmall = rx;
            		}
HXLINE( 179)		 ::Dynamic targetE = targetError;
HXDLIN( 179)		if (::hx::IsNull( targetE )) {
HXLINE( 179)			targetE = ((Float)1.05);
            		}
HXDLIN( 179)		int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN( 179)		int noSides;
HXDLIN( 179)		if ((result < 12)) {
HXLINE( 179)			noSides = 12;
            		}
            		else {
HXLINE( 179)			if ((result > 500)) {
HXLINE( 179)				noSides = 500;
            			}
            			else {
HXLINE( 179)				noSides = result;
            			}
            		}
HXLINE( 180)		Float theta = ((((Float)1.41213) * ::Math_obj::PI) / ( (Float)(noSides) ));
HXLINE( 181)		Float currAngle = startRadian;
HXLINE( 182)		int tot = ::Math_obj::floor((sweepRadian / theta));
HXLINE( 183)		theta = (theta + (((sweepRadian / theta) - ( (Float)(tot) )) / ( (Float)(noSides) )));
HXLINE( 184)		tot = ::Math_obj::floor((sweepRadian / theta));
HXLINE( 185)		Float bx = ((rx * ::Math_obj::cos(currAngle)) + ax);
HXLINE( 186)		Float by = ((ry * ::Math_obj::sin(currAngle)) + ay);
HXLINE( 187)		Float cx = ((Float)0.);
HXLINE( 188)		Float cy = ((Float)0.);
HXLINE( 189)		::Array< ::Dynamic> arrTri = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 190)		{
HXLINE( 190)			int _g = 1;
HXDLIN( 190)			int _g1 = (tot + 1);
HXDLIN( 190)			while((_g < _g1)){
HXLINE( 190)				_g = (_g + 1);
HXDLIN( 190)				int i = (_g - 1);
HXLINE( 191)				currAngle = (startRadian + (( (Float)(i) ) * theta));
HXLINE( 192)				cx = ((rx * ::Math_obj::cos(currAngle)) + ax);
HXLINE( 193)				cy = ((ry * ::Math_obj::sin(currAngle)) + ay);
HXLINE( 194)				Float bx1 = bx;
HXDLIN( 194)				Float by1 = by;
HXDLIN( 194)				Float cx1 = cx;
HXDLIN( 194)				Float cy1 = cy;
HXDLIN( 194)				bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN( 194)				if (!(adjustWinding)) {
HXLINE( 194)					Float bx_ = bx1;
HXDLIN( 194)					Float by_ = by1;
HXLINE( 187)					bx1 = cx1;
HXLINE( 188)					by1 = cy1;
HXLINE( 189)					cx1 = bx_;
HXLINE( 190)					cy1 = by_;
            				}
HXLINE( 194)				bool hasUndo = false;
HXDLIN( 194)				Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN( 194)				Float sx = (cy1 - ay);
HXDLIN( 194)				Float sy = (ax - cx1);
HXDLIN( 194)				Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN( 194)				Float tx = (ay - by1);
HXDLIN( 194)				Float ty = (bx1 - ax);
HXDLIN( 194)				Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN( 194)				 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 194)				if ((ax > bx1)) {
HXLINE( 194)					if ((ax > cx1)) {
HXLINE( 194)						int min;
HXDLIN( 194)						if ((bx1 > cx1)) {
HXLINE( 194)							min = ::Math_obj::floor(cx1);
            						}
            						else {
HXLINE( 194)							min = ::Math_obj::floor(bx1);
            						}
HXDLIN( 194)						int ii_min = min;
HXDLIN( 194)						int ii_max = ::Math_obj::ceil(ax);
HXDLIN( 194)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            					}
            					else {
HXLINE( 194)						int ii_min1 = ::Math_obj::floor(bx1);
HXDLIN( 194)						int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 194)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            					}
            				}
            				else {
HXLINE( 194)					if ((bx1 > cx1)) {
HXLINE( 194)						int min1;
HXDLIN( 194)						if ((ax > cx1)) {
HXLINE( 194)							min1 = ::Math_obj::floor(cx1);
            						}
            						else {
HXLINE( 194)							min1 = ::Math_obj::ceil(ax);
            						}
HXDLIN( 194)						int ii_min2 = min1;
HXDLIN( 194)						int ii_max2 = ::Math_obj::ceil(bx1);
HXDLIN( 194)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            					}
            					else {
HXLINE( 194)						int ii_min3 = ::Math_obj::floor(ax);
HXDLIN( 194)						int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 194)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            					}
            				}
HXDLIN( 194)				 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 194)				if ((ay > by1)) {
HXLINE( 194)					if ((ay > cy1)) {
HXLINE( 194)						int min2;
HXDLIN( 194)						if ((by1 > cy1)) {
HXLINE( 194)							min2 = ::Math_obj::floor(cy1);
            						}
            						else {
HXLINE( 194)							min2 = ::Math_obj::floor(by1);
            						}
HXDLIN( 194)						int ii_min4 = min2;
HXDLIN( 194)						int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN( 194)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            					}
            					else {
HXLINE( 194)						int ii_min5 = ::Math_obj::floor(by1);
HXDLIN( 194)						int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 194)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            					}
            				}
            				else {
HXLINE( 194)					if ((by1 > cy1)) {
HXLINE( 194)						int min3;
HXDLIN( 194)						if ((ay > cy1)) {
HXLINE( 194)							min3 = ::Math_obj::floor(cy1);
            						}
            						else {
HXLINE( 194)							min3 = ::Math_obj::ceil(ay);
            						}
HXDLIN( 194)						int ii_min6 = min3;
HXDLIN( 194)						int ii_max6 = ::Math_obj::ceil(by1);
HXDLIN( 194)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            					}
            					else {
HXLINE( 194)						int ii_min7 = ::Math_obj::floor(ay);
HXDLIN( 194)						int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 194)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            					}
            				}
HXDLIN( 194)				 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 194)				if (hasUndo) {
HXLINE( 194)					int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 194)					int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 194)					 ::Dynamic imageType = null();
HXDLIN( 194)					 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 194)					if (::hx::IsNull( imageType )) {
HXLINE(  54)						imageType = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE( 194)					::Dynamic undoImage1;
HXDLIN( 194)					switch((int)(( (int)(imageType) ))){
            						case (int)0: {
HXLINE( 194)							 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 194)							 ::iterMagic::BytesImg b = byt;
HXDLIN( 194)							{
HXLINE( 194)								b->width = width;
HXDLIN( 194)								b->height = height;
HXDLIN( 194)								b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 194)								b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 194)								{
HXLINE( 194)									int len = b->length;
HXDLIN( 194)									int w = 0;
HXDLIN( 194)									{
HXLINE( 194)										int _g2 = 0;
HXDLIN( 194)										int _g3 = b->height;
HXDLIN( 194)										while((_g2 < _g3)){
HXLINE( 194)											_g2 = (_g2 + 1);
HXDLIN( 194)											int y = (_g2 - 1);
HXDLIN( 194)											{
HXLINE( 194)												int _g4 = 0;
HXDLIN( 194)												int _g5 = b->width;
HXDLIN( 194)												while((_g4 < _g5)){
HXLINE( 194)													_g4 = (_g4 + 1);
HXDLIN( 194)													int x = (_g4 - 1);
HXDLIN( 194)													{
HXLINE( 194)														w = (w + 1);
HXDLIN( 194)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 194)													{
HXLINE( 194)														w = (w + 1);
HXDLIN( 194)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 194)													{
HXLINE( 194)														w = (w + 1);
HXDLIN( 194)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN( 194)													{
HXLINE( 194)														w = (w + 1);
HXDLIN( 194)														b->data->b[(w - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 194)							undoImage1 = b;
            						}
            						break;
            						case (int)1: {
HXLINE( 194)							 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 194)							 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 194)							{
HXLINE( 194)								a->width = width;
HXDLIN( 194)								a->height = height;
HXDLIN( 194)								a->data = ::Array_obj< int >::__new(0);
HXDLIN( 194)								a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 194)								{
HXLINE( 194)									int _g6 = 0;
HXDLIN( 194)									int _g7 = a->length;
HXDLIN( 194)									while((_g6 < _g7)){
HXLINE( 194)										_g6 = (_g6 + 1);
HXDLIN( 194)										int i1 = (_g6 - 1);
HXDLIN( 194)										a->data[i1] = 0;
            									}
            								}
            							}
HXDLIN( 194)							undoImage1 = a;
            						}
            						break;
            						case (int)2: {
HXLINE( 194)							 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 194)							 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 194)							{
HXLINE( 194)								b1->width = width;
HXDLIN( 194)								b1->height = height;
HXDLIN( 194)								b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 194)								int size = (b1->length * 4);
HXDLIN( 194)								b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 194)								{
HXLINE( 194)									int _g8 = 0;
HXDLIN( 194)									int _g9 = b1->length;
HXDLIN( 194)									while((_g8 < _g9)){
HXLINE( 194)										_g8 = (_g8 + 1);
HXDLIN( 194)										int i2 = (_g8 - 1);
HXDLIN( 194)										{
HXLINE( 194)											 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN( 194)											bool undoImage2;
HXDLIN( 194)											if ((i2 >= 0)) {
HXLINE( 194)												undoImage2 = (i2 < (this3->byteLength >> 2));
            											}
            											else {
HXLINE( 194)												undoImage2 = false;
            											}
HXDLIN( 194)											if (undoImage2) {
HXLINE( 194)												 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN( 194)												int pos = ((i2 << 2) + this3->byteOffset);
HXDLIN( 194)												_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 194)												_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 194)												_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 194)												_this->b[(pos + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN( 194)							undoImage1 = b1;
            						}
            						break;
            						case (int)3: {
HXLINE( 194)							 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 194)							 ::iterMagic::VecIntImg v = vec;
HXDLIN( 194)							{
HXLINE( 194)								v->width = width;
HXDLIN( 194)								v->height = height;
HXDLIN( 194)								v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 194)								v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 194)								{
HXLINE( 194)									int _g10 = 0;
HXDLIN( 194)									int _g11 = v->length;
HXDLIN( 194)									while((_g10 < _g11)){
HXLINE( 194)										_g10 = (_g10 + 1);
HXDLIN( 194)										int i3 = (_g10 - 1);
HXDLIN( 194)										v->data->__unsafe_set(i3,0);
            									}
            								}
            							}
HXDLIN( 194)							undoImage1 = v;
            						}
            						break;
            						case (int)4: {
HXLINE( 194)							 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 194)							 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 194)							{
HXLINE( 194)								b2->width = width;
HXDLIN( 194)								b2->height = height;
HXDLIN( 194)								b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 194)								b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 194)								{
HXLINE( 194)									int len1 = b2->length;
HXDLIN( 194)									 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 194)									if (::hx::IsNull( d->head )) {
HXLINE( 194)										int _g12 = 0;
HXDLIN( 194)										int _g13 = len1;
HXDLIN( 194)										while((_g12 < _g13)){
HXLINE( 194)											_g12 = (_g12 + 1);
HXDLIN( 194)											int i4 = (_g12 - 1);
HXDLIN( 194)											d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            										}
            									}
            									else {
HXLINE( 194)										int _g14 = 0;
HXDLIN( 194)										int _g15 = len1;
HXDLIN( 194)										while((_g14 < _g15)){
HXLINE( 194)											_g14 = (_g14 + 1);
HXDLIN( 194)											int i5 = (_g14 - 1);
HXDLIN( 194)											{
HXLINE( 194)												 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 194)												 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 194)												{
HXLINE( 194)													int _g16 = 0;
HXDLIN( 194)													int _g17 = i5;
HXDLIN( 194)													while((_g16 < _g17)){
HXLINE( 194)														_g16 = (_g16 + 1);
HXDLIN( 194)														int i6 = (_g16 - 1);
HXLINE( 345)														prev = l;
HXLINE( 346)														l = l->next;
            													}
            												}
HXLINE( 194)												if (::hx::IsNull( prev )) {
HXLINE( 194)													b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 194)													l = null();
            												}
            												else {
HXLINE( 194)													prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 194)													l = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN( 194)							undoImage1 = b2;
            						}
            						break;
            					}
HXDLIN( 194)					this2->image = undoImage1;
HXDLIN( 194)					this2->width = width;
HXDLIN( 194)					this2->height = height;
HXDLIN( 194)					this2->imageType = ( (int)(imageType) );
HXDLIN( 194)					undoImage = this2;
HXDLIN( 194)					{
HXLINE( 194)						int rectLeft = xIter3->start;
HXDLIN( 194)						int rectTop = yIter3->start;
HXDLIN( 194)						int rectRight = xIter3->max;
HXDLIN( 194)						bool forceClear = false;
HXDLIN( 194)						{
HXLINE( 194)							int _g18 = rectTop;
HXDLIN( 194)							int _g19 = yIter3->max;
HXDLIN( 194)							while((_g18 < _g19)){
HXLINE( 194)								_g18 = (_g18 + 1);
HXDLIN( 194)								int dy = (_g18 - 1);
HXDLIN( 194)								{
HXLINE( 194)									int _g20 = rectLeft;
HXDLIN( 194)									int _g21 = rectRight;
HXDLIN( 194)									while((_g20 < _g21)){
HXLINE( 194)										_g20 = (_g20 + 1);
HXDLIN( 194)										int dx = (_g20 - 1);
HXDLIN( 194)										::Dynamic this4 = this1->image;
HXDLIN( 194)										int index;
HXDLIN( 194)										if (this1->useVirtualPos) {
HXLINE( 194)											index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            										}
            										else {
HXLINE( 194)											index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            										}
HXDLIN( 194)										int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN( 194)										int col;
HXDLIN( 194)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 194)											col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            										}
            										else {
HXLINE( 194)											col = c;
            										}
HXDLIN( 194)										bool _hx_tmp;
HXDLIN( 194)										if (this1->useMask) {
HXLINE( 194)											_hx_tmp = ::hx::IsNotNull( this1->mask );
            										}
            										else {
HXLINE( 194)											_hx_tmp = false;
            										}
HXDLIN( 194)										if (_hx_tmp) {
HXLINE( 194)											 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN( 194)											::Dynamic this6 = this5->image;
HXDLIN( 194)											int index1;
HXDLIN( 194)											if (this5->useVirtualPos) {
HXLINE( 194)												index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx) - this5->virtualX));
            											}
            											else {
HXLINE( 194)												index1 = ::Std_obj::_hx_int(( (Float)(((dy * this5->width) + dx)) ));
            											}
HXDLIN( 194)											int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN( 194)											int v1;
HXDLIN( 194)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 194)												v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            											}
            											else {
HXLINE( 194)												v1 = c1;
            											}
HXDLIN( 194)											int maskPixel = v1;
HXDLIN( 194)											int this7 = col;
HXDLIN( 194)											if ((maskPixel == 0)) {
HXLINE( 194)												col = this7;
            											}
            											else {
HXLINE( 194)												Float m0;
HXDLIN( 194)												int this8 = ((maskPixel >> 24) & 255);
HXDLIN( 194)												if ((this8 == 0)) {
HXLINE( 194)													m0 = ((Float)0.);
            												}
            												else {
HXLINE( 194)													m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            												}
HXDLIN( 194)												Float m1;
HXDLIN( 194)												int this9 = ((maskPixel >> 16) & 255);
HXDLIN( 194)												if ((this9 == 0)) {
HXLINE( 194)													m1 = ((Float)0.);
            												}
            												else {
HXLINE( 194)													m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            												}
HXDLIN( 194)												Float m2;
HXDLIN( 194)												int this10 = ((maskPixel >> 8) & 255);
HXDLIN( 194)												if ((this10 == 0)) {
HXLINE( 194)													m2 = ((Float)0.);
            												}
            												else {
HXLINE( 194)													m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            												}
HXDLIN( 194)												Float m3;
HXDLIN( 194)												int this11 = (maskPixel & 255);
HXDLIN( 194)												if ((this11 == 0)) {
HXLINE( 194)													m3 = ((Float)0.);
            												}
            												else {
HXLINE( 194)													m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            												}
HXDLIN( 194)												int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN( 194)												int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN( 194)												int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN( 194)												int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN( 194)												col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN( 194)										if ((col != 0)) {
HXLINE( 194)											int x1 = (dx - rectLeft);
HXDLIN( 194)											int y1 = (dy - rectTop);
HXDLIN( 194)											int c2 = col;
HXDLIN( 194)											bool _hx_tmp1;
HXDLIN( 194)											if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 194)												_hx_tmp1 = undoImage->transparent;
            											}
            											else {
HXLINE( 194)												_hx_tmp1 = false;
            											}
HXDLIN( 194)											if (_hx_tmp1) {
HXLINE( 194)												int location;
HXDLIN( 194)												if (undoImage->useVirtualPos) {
HXLINE( 194)													location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            												}
            												else {
HXLINE( 194)													location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            												}
HXDLIN( 194)												int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 194)												int this13;
HXDLIN( 194)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 194)													this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            												}
            												else {
HXLINE( 194)													this13 = this12;
            												}
HXDLIN( 194)												Float a1;
HXDLIN( 194)												int this14 = ((this13 >> 24) & 255);
HXDLIN( 194)												if ((this14 == 0)) {
HXLINE( 194)													a1 = ((Float)0.);
            												}
            												else {
HXLINE( 194)													a1 = (( (Float)(this14) ) / ( (Float)(255) ));
            												}
HXDLIN( 194)												Float r1;
HXDLIN( 194)												int this15 = ((this13 >> 16) & 255);
HXDLIN( 194)												if ((this15 == 0)) {
HXLINE( 194)													r1 = ((Float)0.);
            												}
            												else {
HXLINE( 194)													r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            												}
HXDLIN( 194)												Float g1;
HXDLIN( 194)												int this16 = ((this13 >> 8) & 255);
HXDLIN( 194)												if ((this16 == 0)) {
HXLINE( 194)													g1 = ((Float)0.);
            												}
            												else {
HXLINE( 194)													g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            												}
HXDLIN( 194)												Float b11;
HXDLIN( 194)												int this17 = (this13 & 255);
HXDLIN( 194)												if ((this17 == 0)) {
HXLINE( 194)													b11 = ((Float)0.);
            												}
            												else {
HXLINE( 194)													b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            												}
HXDLIN( 194)												Float a2;
HXDLIN( 194)												int this18 = ((col >> 24) & 255);
HXDLIN( 194)												if ((this18 == 0)) {
HXLINE( 194)													a2 = ((Float)0.);
            												}
            												else {
HXLINE( 194)													a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            												}
HXDLIN( 194)												Float r2;
HXDLIN( 194)												int this19 = ((col >> 16) & 255);
HXDLIN( 194)												if ((this19 == 0)) {
HXLINE( 194)													r2 = ((Float)0.);
            												}
            												else {
HXLINE( 194)													r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            												}
HXDLIN( 194)												Float g2;
HXDLIN( 194)												int this20 = ((col >> 8) & 255);
HXDLIN( 194)												if ((this20 == 0)) {
HXLINE( 194)													g2 = ((Float)0.);
            												}
            												else {
HXLINE( 194)													g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            												}
HXDLIN( 194)												Float b21;
HXDLIN( 194)												int this21 = (col & 255);
HXDLIN( 194)												if ((this21 == 0)) {
HXLINE( 194)													b21 = ((Float)0.);
            												}
            												else {
HXLINE( 194)													b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            												}
HXDLIN( 194)												Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 194)												int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 194)												int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 194)												int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 194)												int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 194)												int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 194)												{
HXLINE( 194)													int _hx_tmp2;
HXDLIN( 194)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 194)														_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            													}
            													else {
HXLINE( 194)														_hx_tmp2 = blended;
            													}
HXDLIN( 194)													::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            												}
            											}
            											else {
HXLINE( 194)												::Dynamic this22 = undoImage->image;
HXDLIN( 194)												int index2;
HXDLIN( 194)												if (undoImage->useVirtualPos) {
HXLINE( 194)													index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            												}
            												else {
HXLINE( 194)													index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            												}
HXDLIN( 194)												int _hx_tmp3;
HXDLIN( 194)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 194)													_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            												}
            												else {
HXLINE( 194)													_hx_tmp3 = c2;
            												}
HXDLIN( 194)												::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp3);
            											}
            										}
            										else {
HXLINE( 194)											if (forceClear) {
HXLINE( 194)												::Dynamic this23 = undoImage->image;
HXDLIN( 194)												int x2 = (dx - rectLeft);
HXDLIN( 194)												int y2 = (dy - rectTop);
HXDLIN( 194)												int index3;
HXDLIN( 194)												if (undoImage->useVirtualPos) {
HXLINE( 194)													index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            												}
            												else {
HXLINE( 194)													index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            												}
HXDLIN( 194)												::iterMagic::Iimg_obj::set(this23,index3,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN( 194)				bool foundY = false;
HXDLIN( 194)				Float s = ((Float)0.);
HXDLIN( 194)				Float t = ((Float)0.);
HXDLIN( 194)				Float sxx = ((Float)0.);
HXDLIN( 194)				Float txx = ((Float)0.);
HXDLIN( 194)				{
HXLINE( 194)					int _g_min = xIter3->start;
HXDLIN( 194)					int _g_max = xIter3->max;
HXDLIN( 194)					while((_g_min < _g_max)){
HXLINE( 194)						_g_min = (_g_min + 1);
HXDLIN( 194)						int x3 = (_g_min - 1);
HXLINE( 222)						sxx = (sx * ( (Float)(x3) ));
HXLINE( 223)						txx = (tx * ( (Float)(x3) ));
HXLINE( 224)						foundY = false;
HXLINE( 194)						{
HXLINE( 194)							int _g_min1 = yIter3->start;
HXDLIN( 194)							int _g_max1 = yIter3->max;
HXDLIN( 194)							while((_g_min1 < _g_max1)){
HXLINE( 194)								_g_min1 = (_g_min1 + 1);
HXDLIN( 194)								int y3 = (_g_min1 - 1);
HXLINE( 226)								s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE( 227)								t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 194)								bool _hx_tmp4;
HXDLIN( 194)								if (!((s <= 0))) {
HXLINE( 194)									_hx_tmp4 = (t <= 0);
            								}
            								else {
HXLINE( 194)									_hx_tmp4 = true;
            								}
HXDLIN( 194)								if (_hx_tmp4) {
HXLINE( 194)									if (foundY) {
HXLINE( 194)										goto _hx_goto_288;
            									}
            								}
            								else {
HXLINE( 194)									if (((s + t) < A)) {
HXLINE( 194)										int x4 = ::hx::Mod(x3,tileImage->width);
HXDLIN( 194)										int y4 = ::hx::Mod(y3,tileImage->height);
HXDLIN( 194)										::Dynamic this24 = tileImage->image;
HXDLIN( 194)										int index4;
HXDLIN( 194)										if (tileImage->useVirtualPos) {
HXLINE( 194)											index4 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x4) - tileImage->virtualX));
            										}
            										else {
HXLINE( 194)											index4 = ::Std_obj::_hx_int(( (Float)(((y4 * tileImage->width) + x4)) ));
            										}
HXDLIN( 194)										int c3 = ::iterMagic::Iimg_obj::get(this24,index4);
HXDLIN( 194)										int color;
HXDLIN( 194)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 194)											color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            										}
            										else {
HXLINE( 194)											color = c3;
            										}
HXDLIN( 194)										{
HXLINE( 194)											int c4 = color;
HXDLIN( 194)											bool _hx_tmp5;
HXDLIN( 194)											if ((((c4 >> 24) & 255) < 254)) {
HXLINE( 194)												_hx_tmp5 = this1->transparent;
            											}
            											else {
HXLINE( 194)												_hx_tmp5 = false;
            											}
HXDLIN( 194)											if (_hx_tmp5) {
HXLINE( 194)												int location1;
HXDLIN( 194)												if (this1->useVirtualPos) {
HXLINE( 194)													location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            												}
            												else {
HXLINE( 194)													location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            												}
HXDLIN( 194)												int this25 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN( 194)												int this26;
HXDLIN( 194)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 194)													this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            												}
            												else {
HXLINE( 194)													this26 = this25;
            												}
HXDLIN( 194)												Float a11;
HXDLIN( 194)												int this27 = ((this26 >> 24) & 255);
HXDLIN( 194)												if ((this27 == 0)) {
HXLINE( 194)													a11 = ((Float)0.);
            												}
            												else {
HXLINE( 194)													a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            												}
HXDLIN( 194)												Float r11;
HXDLIN( 194)												int this28 = ((this26 >> 16) & 255);
HXDLIN( 194)												if ((this28 == 0)) {
HXLINE( 194)													r11 = ((Float)0.);
            												}
            												else {
HXLINE( 194)													r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            												}
HXDLIN( 194)												Float g11;
HXDLIN( 194)												int this29 = ((this26 >> 8) & 255);
HXDLIN( 194)												if ((this29 == 0)) {
HXLINE( 194)													g11 = ((Float)0.);
            												}
            												else {
HXLINE( 194)													g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            												}
HXDLIN( 194)												Float b12;
HXDLIN( 194)												int this30 = (this26 & 255);
HXDLIN( 194)												if ((this30 == 0)) {
HXLINE( 194)													b12 = ((Float)0.);
            												}
            												else {
HXLINE( 194)													b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            												}
HXDLIN( 194)												Float a21;
HXDLIN( 194)												int this31 = ((color >> 24) & 255);
HXDLIN( 194)												if ((this31 == 0)) {
HXLINE( 194)													a21 = ((Float)0.);
            												}
            												else {
HXLINE( 194)													a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            												}
HXDLIN( 194)												Float r21;
HXDLIN( 194)												int this32 = ((color >> 16) & 255);
HXDLIN( 194)												if ((this32 == 0)) {
HXLINE( 194)													r21 = ((Float)0.);
            												}
            												else {
HXLINE( 194)													r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            												}
HXDLIN( 194)												Float g21;
HXDLIN( 194)												int this33 = ((color >> 8) & 255);
HXDLIN( 194)												if ((this33 == 0)) {
HXLINE( 194)													g21 = ((Float)0.);
            												}
            												else {
HXLINE( 194)													g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            												}
HXDLIN( 194)												Float b22;
HXDLIN( 194)												int this34 = (color & 255);
HXDLIN( 194)												if ((this34 == 0)) {
HXLINE( 194)													b22 = ((Float)0.);
            												}
            												else {
HXLINE( 194)													b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            												}
HXDLIN( 194)												Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 194)												int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 194)												int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 194)												int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 194)												int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 194)												int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 194)												{
HXLINE( 194)													int _hx_tmp6;
HXDLIN( 194)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 194)														_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            													}
            													else {
HXLINE( 194)														_hx_tmp6 = blended1;
            													}
HXDLIN( 194)													::iterMagic::Iimg_obj::set(this1->image,location1,_hx_tmp6);
            												}
            											}
            											else {
HXLINE( 194)												::Dynamic this35 = this1->image;
HXDLIN( 194)												int index5;
HXDLIN( 194)												if (this1->useVirtualPos) {
HXLINE( 194)													index5 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            												}
            												else {
HXLINE( 194)													index5 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            												}
HXDLIN( 194)												int _hx_tmp7;
HXDLIN( 194)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 194)													_hx_tmp7 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            												}
            												else {
HXLINE( 194)													_hx_tmp7 = c4;
            												}
HXDLIN( 194)												::iterMagic::Iimg_obj::set(this35,index5,_hx_tmp7);
            											}
            										}
HXLINE( 236)										foundY = true;
            									}
            									else {
HXLINE( 194)										if (foundY) {
HXLINE( 194)											goto _hx_goto_288;
            										}
            									}
            								}
            							}
            							_hx_goto_288:;
            						}
            					}
            				}
HXDLIN( 194)				 ::pi_xy::algo::HitTri triHit;
HXDLIN( 194)				if ((hasHit == false)) {
HXLINE( 194)					 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx1,by1,cx1,cy1,true);
HXDLIN( 194)					if (hasUndo) {
HXLINE( 194)						v2->undoImage = undoImage;
HXDLIN( 194)						v2->undoX = xIter3->start;
HXDLIN( 194)						v2->undoY = yIter3->start;
            					}
HXDLIN( 194)					triHit = v2;
            				}
            				else {
HXLINE( 194)					triHit = null();
            				}
HXLINE( 195)				if (hasHit) {
HXLINE( 195)					arrTri[arrTri->length] = triHit;
            				}
HXLINE( 196)				bx = cx;
HXLINE( 197)				by = cy;
            			}
            		}
HXLINE( 200)		currAngle = (startRadian + sweepRadian);
HXLINE( 201)		cx = ((rx * ::Math_obj::cos(currAngle)) + ax);
HXLINE( 202)		cy = ((ry * ::Math_obj::sin(currAngle)) + ay);
HXLINE( 203)		Float bx2 = bx;
HXDLIN( 203)		Float by2 = by;
HXDLIN( 203)		Float cx2 = cx;
HXDLIN( 203)		Float cy2 = cy;
HXDLIN( 203)		bool adjustWinding1 = (((((ax * by2) - (bx2 * ay)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ay) - (ax * cy2))) > 0);
HXDLIN( 203)		if (!(adjustWinding1)) {
HXLINE( 203)			Float bx_1 = bx2;
HXDLIN( 203)			Float by_1 = by2;
HXLINE( 187)			bx2 = cx2;
HXLINE( 188)			by2 = cy2;
HXLINE( 189)			cx2 = bx_1;
HXLINE( 190)			cy2 = by_1;
            		}
HXLINE( 203)		bool hasUndo1 = false;
HXDLIN( 203)		Float s01 = ((ay * cx2) - (ax * cy2));
HXDLIN( 203)		Float sx1 = (cy2 - ay);
HXDLIN( 203)		Float sy1 = (ax - cx2);
HXDLIN( 203)		Float t01 = ((ax * by2) - (ay * bx2));
HXDLIN( 203)		Float tx1 = (ay - by2);
HXDLIN( 203)		Float ty1 = (bx2 - ax);
HXDLIN( 203)		Float A1 = ((((-(by2) * cx2) + (ay * (-(bx2) + cx2))) + (ax * (by2 - cy2))) + (bx2 * cy2));
HXDLIN( 203)		 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 203)		if ((ax > bx2)) {
HXLINE( 203)			if ((ax > cx2)) {
HXLINE( 203)				int min4;
HXDLIN( 203)				if ((bx2 > cx2)) {
HXLINE( 203)					min4 = ::Math_obj::floor(cx2);
            				}
            				else {
HXLINE( 203)					min4 = ::Math_obj::floor(bx2);
            				}
HXDLIN( 203)				int ii_min8 = min4;
HXDLIN( 203)				int ii_max8 = ::Math_obj::ceil(ax);
HXDLIN( 203)				xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            			}
            			else {
HXLINE( 203)				int ii_min9 = ::Math_obj::floor(bx2);
HXDLIN( 203)				int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 203)				xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            			}
            		}
            		else {
HXLINE( 203)			if ((bx2 > cx2)) {
HXLINE( 203)				int min5;
HXDLIN( 203)				if ((ax > cx2)) {
HXLINE( 203)					min5 = ::Math_obj::floor(cx2);
            				}
            				else {
HXLINE( 203)					min5 = ::Math_obj::ceil(ax);
            				}
HXDLIN( 203)				int ii_min10 = min5;
HXDLIN( 203)				int ii_max10 = ::Math_obj::ceil(bx2);
HXDLIN( 203)				xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            			}
            			else {
HXLINE( 203)				int ii_min11 = ::Math_obj::floor(ax);
HXDLIN( 203)				int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 203)				xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            			}
            		}
HXDLIN( 203)		 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 203)		if ((ay > by2)) {
HXLINE( 203)			if ((ay > cy2)) {
HXLINE( 203)				int min6;
HXDLIN( 203)				if ((by2 > cy2)) {
HXLINE( 203)					min6 = ::Math_obj::floor(cy2);
            				}
            				else {
HXLINE( 203)					min6 = ::Math_obj::floor(by2);
            				}
HXDLIN( 203)				int ii_min12 = min6;
HXDLIN( 203)				int ii_max12 = ::Math_obj::ceil(ay);
HXDLIN( 203)				yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            			}
            			else {
HXLINE( 203)				int ii_min13 = ::Math_obj::floor(by2);
HXDLIN( 203)				int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 203)				yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            			}
            		}
            		else {
HXLINE( 203)			if ((by2 > cy2)) {
HXLINE( 203)				int min7;
HXDLIN( 203)				if ((ay > cy2)) {
HXLINE( 203)					min7 = ::Math_obj::floor(cy2);
            				}
            				else {
HXLINE( 203)					min7 = ::Math_obj::ceil(ay);
            				}
HXDLIN( 203)				int ii_min14 = min7;
HXDLIN( 203)				int ii_max14 = ::Math_obj::ceil(by2);
HXDLIN( 203)				yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            			}
            			else {
HXLINE( 203)				int ii_min15 = ::Math_obj::floor(ay);
HXDLIN( 203)				int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 203)				yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            			}
            		}
HXDLIN( 203)		 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 203)		if (hasUndo1) {
HXLINE( 203)			int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 203)			int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 203)			 ::Dynamic imageType1 = null();
HXDLIN( 203)			 ::pi_xy::ImageStruct this36 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 203)			if (::hx::IsNull( imageType1 )) {
HXLINE(  54)				imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE( 203)			::Dynamic undoImage4;
HXDLIN( 203)			switch((int)(( (int)(imageType1) ))){
            				case (int)0: {
HXLINE( 203)					 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 203)					 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 203)					{
HXLINE( 203)						b5->width = width1;
HXDLIN( 203)						b5->height = height1;
HXDLIN( 203)						b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 203)						b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 203)						{
HXLINE( 203)							int len2 = b5->length;
HXDLIN( 203)							int w1 = 0;
HXDLIN( 203)							{
HXLINE( 203)								int _g22 = 0;
HXDLIN( 203)								int _g23 = b5->height;
HXDLIN( 203)								while((_g22 < _g23)){
HXLINE( 203)									_g22 = (_g22 + 1);
HXDLIN( 203)									int y5 = (_g22 - 1);
HXDLIN( 203)									{
HXLINE( 203)										int _g24 = 0;
HXDLIN( 203)										int _g25 = b5->width;
HXDLIN( 203)										while((_g24 < _g25)){
HXLINE( 203)											_g24 = (_g24 + 1);
HXDLIN( 203)											int x5 = (_g24 - 1);
HXDLIN( 203)											{
HXLINE( 203)												w1 = (w1 + 1);
HXDLIN( 203)												b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 203)											{
HXLINE( 203)												w1 = (w1 + 1);
HXDLIN( 203)												b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 203)											{
HXLINE( 203)												w1 = (w1 + 1);
HXDLIN( 203)												b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN( 203)											{
HXLINE( 203)												w1 = (w1 + 1);
HXDLIN( 203)												b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 203)					undoImage4 = b5;
            				}
            				break;
            				case (int)1: {
HXLINE( 203)					 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 203)					 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 203)					{
HXLINE( 203)						a6->width = width1;
HXDLIN( 203)						a6->height = height1;
HXDLIN( 203)						a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 203)						a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 203)						{
HXLINE( 203)							int _g26 = 0;
HXDLIN( 203)							int _g27 = a6->length;
HXDLIN( 203)							while((_g26 < _g27)){
HXLINE( 203)								_g26 = (_g26 + 1);
HXDLIN( 203)								int i7 = (_g26 - 1);
HXDLIN( 203)								a6->data[i7] = 0;
            							}
            						}
            					}
HXDLIN( 203)					undoImage4 = a6;
            				}
            				break;
            				case (int)2: {
HXLINE( 203)					 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 203)					 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 203)					{
HXLINE( 203)						b6->width = width1;
HXDLIN( 203)						b6->height = height1;
HXDLIN( 203)						b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 203)						int size1 = (b6->length * 4);
HXDLIN( 203)						b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 203)						{
HXLINE( 203)							int _g28 = 0;
HXDLIN( 203)							int _g29 = b6->length;
HXDLIN( 203)							while((_g28 < _g29)){
HXLINE( 203)								_g28 = (_g28 + 1);
HXDLIN( 203)								int i8 = (_g28 - 1);
HXDLIN( 203)								{
HXLINE( 203)									 ::haxe::io::ArrayBufferViewImpl this37 = b6->data;
HXDLIN( 203)									bool undoImage5;
HXDLIN( 203)									if ((i8 >= 0)) {
HXLINE( 203)										undoImage5 = (i8 < (this37->byteLength >> 2));
            									}
            									else {
HXLINE( 203)										undoImage5 = false;
            									}
HXDLIN( 203)									if (undoImage5) {
HXLINE( 203)										 ::haxe::io::Bytes _this1 = this37->bytes;
HXDLIN( 203)										int pos1 = ((i8 << 2) + this37->byteOffset);
HXDLIN( 203)										_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 203)										_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 203)										_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 203)										_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN( 203)					undoImage4 = b6;
            				}
            				break;
            				case (int)3: {
HXLINE( 203)					 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 203)					 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 203)					{
HXLINE( 203)						v3->width = width1;
HXDLIN( 203)						v3->height = height1;
HXDLIN( 203)						v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 203)						v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 203)						{
HXLINE( 203)							int _g30 = 0;
HXDLIN( 203)							int _g31 = v3->length;
HXDLIN( 203)							while((_g30 < _g31)){
HXLINE( 203)								_g30 = (_g30 + 1);
HXDLIN( 203)								int i9 = (_g30 - 1);
HXDLIN( 203)								v3->data->__unsafe_set(i9,0);
            							}
            						}
            					}
HXDLIN( 203)					undoImage4 = v3;
            				}
            				break;
            				case (int)4: {
HXLINE( 203)					 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 203)					 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 203)					{
HXLINE( 203)						b7->width = width1;
HXDLIN( 203)						b7->height = height1;
HXDLIN( 203)						b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 203)						b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 203)						{
HXLINE( 203)							int len3 = b7->length;
HXDLIN( 203)							 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 203)							if (::hx::IsNull( d1->head )) {
HXLINE( 203)								int _g32 = 0;
HXDLIN( 203)								int _g33 = len3;
HXDLIN( 203)								while((_g32 < _g33)){
HXLINE( 203)									_g32 = (_g32 + 1);
HXDLIN( 203)									int i10 = (_g32 - 1);
HXDLIN( 203)									d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            								}
            							}
            							else {
HXLINE( 203)								int _g34 = 0;
HXDLIN( 203)								int _g35 = len3;
HXDLIN( 203)								while((_g34 < _g35)){
HXLINE( 203)									_g34 = (_g34 + 1);
HXDLIN( 203)									int i11 = (_g34 - 1);
HXDLIN( 203)									{
HXLINE( 203)										 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 203)										 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 203)										{
HXLINE( 203)											int _g36 = 0;
HXDLIN( 203)											int _g37 = i11;
HXDLIN( 203)											while((_g36 < _g37)){
HXLINE( 203)												_g36 = (_g36 + 1);
HXDLIN( 203)												int i12 = (_g36 - 1);
HXLINE( 345)												prev1 = l1;
HXLINE( 346)												l1 = l1->next;
            											}
            										}
HXLINE( 203)										if (::hx::IsNull( prev1 )) {
HXLINE( 203)											b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 203)											l1 = null();
            										}
            										else {
HXLINE( 203)											prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 203)											l1 = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN( 203)					undoImage4 = b7;
            				}
            				break;
            			}
HXDLIN( 203)			this36->image = undoImage4;
HXDLIN( 203)			this36->width = width1;
HXDLIN( 203)			this36->height = height1;
HXDLIN( 203)			this36->imageType = ( (int)(imageType1) );
HXDLIN( 203)			undoImage3 = this36;
HXDLIN( 203)			{
HXLINE( 203)				int rectLeft1 = xIter31->start;
HXDLIN( 203)				int rectTop1 = yIter31->start;
HXDLIN( 203)				int rectRight1 = xIter31->max;
HXDLIN( 203)				bool forceClear1 = false;
HXDLIN( 203)				{
HXLINE( 203)					int _g38 = rectTop1;
HXDLIN( 203)					int _g39 = yIter31->max;
HXDLIN( 203)					while((_g38 < _g39)){
HXLINE( 203)						_g38 = (_g38 + 1);
HXDLIN( 203)						int dy1 = (_g38 - 1);
HXDLIN( 203)						{
HXLINE( 203)							int _g40 = rectLeft1;
HXDLIN( 203)							int _g41 = rectRight1;
HXDLIN( 203)							while((_g40 < _g41)){
HXLINE( 203)								_g40 = (_g40 + 1);
HXDLIN( 203)								int dx1 = (_g40 - 1);
HXDLIN( 203)								::Dynamic this38 = this1->image;
HXDLIN( 203)								int index6;
HXDLIN( 203)								if (this1->useVirtualPos) {
HXLINE( 203)									index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx1) - this1->virtualX));
            								}
            								else {
HXLINE( 203)									index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this1->width) + dx1)) ));
            								}
HXDLIN( 203)								int c5 = ::iterMagic::Iimg_obj::get(this38,index6);
HXDLIN( 203)								int col1;
HXDLIN( 203)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 203)									col1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            								}
            								else {
HXLINE( 203)									col1 = c5;
            								}
HXDLIN( 203)								bool _hx_tmp8;
HXDLIN( 203)								if (this1->useMask) {
HXLINE( 203)									_hx_tmp8 = ::hx::IsNotNull( this1->mask );
            								}
            								else {
HXLINE( 203)									_hx_tmp8 = false;
            								}
HXDLIN( 203)								if (_hx_tmp8) {
HXLINE( 203)									 ::pi_xy::ImageStruct this39 = this1->mask;
HXDLIN( 203)									::Dynamic this40 = this39->image;
HXDLIN( 203)									int index7;
HXDLIN( 203)									if (this39->useVirtualPos) {
HXLINE( 203)										index7 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this39->virtualY) * ( (Float)(this39->width) )) + dx1) - this39->virtualX));
            									}
            									else {
HXLINE( 203)										index7 = ::Std_obj::_hx_int(( (Float)(((dy1 * this39->width) + dx1)) ));
            									}
HXDLIN( 203)									int c6 = ::iterMagic::Iimg_obj::get(this40,index7);
HXDLIN( 203)									int v4;
HXDLIN( 203)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 203)										v4 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            									}
            									else {
HXLINE( 203)										v4 = c6;
            									}
HXDLIN( 203)									int maskPixel1 = v4;
HXDLIN( 203)									int this41 = col1;
HXDLIN( 203)									if ((maskPixel1 == 0)) {
HXLINE( 203)										col1 = this41;
            									}
            									else {
HXLINE( 203)										Float m01;
HXDLIN( 203)										int this42 = ((maskPixel1 >> 24) & 255);
HXDLIN( 203)										if ((this42 == 0)) {
HXLINE( 203)											m01 = ((Float)0.);
            										}
            										else {
HXLINE( 203)											m01 = (( (Float)(this42) ) / ( (Float)(255) ));
            										}
HXDLIN( 203)										Float m11;
HXDLIN( 203)										int this43 = ((maskPixel1 >> 16) & 255);
HXDLIN( 203)										if ((this43 == 0)) {
HXLINE( 203)											m11 = ((Float)0.);
            										}
            										else {
HXLINE( 203)											m11 = (( (Float)(this43) ) / ( (Float)(255) ));
            										}
HXDLIN( 203)										Float m21;
HXDLIN( 203)										int this44 = ((maskPixel1 >> 8) & 255);
HXDLIN( 203)										if ((this44 == 0)) {
HXLINE( 203)											m21 = ((Float)0.);
            										}
            										else {
HXLINE( 203)											m21 = (( (Float)(this44) ) / ( (Float)(255) ));
            										}
HXDLIN( 203)										Float m31;
HXDLIN( 203)										int this45 = (maskPixel1 & 255);
HXDLIN( 203)										if ((this45 == 0)) {
HXLINE( 203)											m31 = ((Float)0.);
            										}
            										else {
HXLINE( 203)											m31 = (( (Float)(this45) ) / ( (Float)(255) ));
            										}
HXDLIN( 203)										int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this41 >> 24) & 255)) )));
HXDLIN( 203)										int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this41 >> 16) & 255)) )));
HXDLIN( 203)										int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this41 >> 8) & 255)) )));
HXDLIN( 203)										int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this41 & 255)) )));
HXDLIN( 203)										col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            									}
            								}
HXDLIN( 203)								if ((col1 != 0)) {
HXLINE( 203)									int x6 = (dx1 - rectLeft1);
HXDLIN( 203)									int y6 = (dy1 - rectTop1);
HXDLIN( 203)									int c7 = col1;
HXDLIN( 203)									bool _hx_tmp9;
HXDLIN( 203)									if ((((c7 >> 24) & 255) < 254)) {
HXLINE( 203)										_hx_tmp9 = undoImage3->transparent;
            									}
            									else {
HXLINE( 203)										_hx_tmp9 = false;
            									}
HXDLIN( 203)									if (_hx_tmp9) {
HXLINE( 203)										int location2;
HXDLIN( 203)										if (undoImage3->useVirtualPos) {
HXLINE( 203)											location2 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            										}
            										else {
HXLINE( 203)											location2 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            										}
HXDLIN( 203)										int this46 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 203)										int this47;
HXDLIN( 203)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 203)											this47 = ((((((this46 >> 24) & 255) << 24) | ((this46 & 255) << 16)) | (((this46 >> 8) & 255) << 8)) | ((this46 >> 16) & 255));
            										}
            										else {
HXLINE( 203)											this47 = this46;
            										}
HXDLIN( 203)										Float a12;
HXDLIN( 203)										int this48 = ((this47 >> 24) & 255);
HXDLIN( 203)										if ((this48 == 0)) {
HXLINE( 203)											a12 = ((Float)0.);
            										}
            										else {
HXLINE( 203)											a12 = (( (Float)(this48) ) / ( (Float)(255) ));
            										}
HXDLIN( 203)										Float r12;
HXDLIN( 203)										int this49 = ((this47 >> 16) & 255);
HXDLIN( 203)										if ((this49 == 0)) {
HXLINE( 203)											r12 = ((Float)0.);
            										}
            										else {
HXLINE( 203)											r12 = (( (Float)(this49) ) / ( (Float)(255) ));
            										}
HXDLIN( 203)										Float g12;
HXDLIN( 203)										int this50 = ((this47 >> 8) & 255);
HXDLIN( 203)										if ((this50 == 0)) {
HXLINE( 203)											g12 = ((Float)0.);
            										}
            										else {
HXLINE( 203)											g12 = (( (Float)(this50) ) / ( (Float)(255) ));
            										}
HXDLIN( 203)										Float b13;
HXDLIN( 203)										int this51 = (this47 & 255);
HXDLIN( 203)										if ((this51 == 0)) {
HXLINE( 203)											b13 = ((Float)0.);
            										}
            										else {
HXLINE( 203)											b13 = (( (Float)(this51) ) / ( (Float)(255) ));
            										}
HXDLIN( 203)										Float a22;
HXDLIN( 203)										int this52 = ((col1 >> 24) & 255);
HXDLIN( 203)										if ((this52 == 0)) {
HXLINE( 203)											a22 = ((Float)0.);
            										}
            										else {
HXLINE( 203)											a22 = (( (Float)(this52) ) / ( (Float)(255) ));
            										}
HXDLIN( 203)										Float r22;
HXDLIN( 203)										int this53 = ((col1 >> 16) & 255);
HXDLIN( 203)										if ((this53 == 0)) {
HXLINE( 203)											r22 = ((Float)0.);
            										}
            										else {
HXLINE( 203)											r22 = (( (Float)(this53) ) / ( (Float)(255) ));
            										}
HXDLIN( 203)										Float g22;
HXDLIN( 203)										int this54 = ((col1 >> 8) & 255);
HXDLIN( 203)										if ((this54 == 0)) {
HXLINE( 203)											g22 = ((Float)0.);
            										}
            										else {
HXLINE( 203)											g22 = (( (Float)(this54) ) / ( (Float)(255) ));
            										}
HXDLIN( 203)										Float b23;
HXDLIN( 203)										int this55 = (col1 & 255);
HXDLIN( 203)										if ((this55 == 0)) {
HXLINE( 203)											b23 = ((Float)0.);
            										}
            										else {
HXLINE( 203)											b23 = (( (Float)(this55) ) / ( (Float)(255) ));
            										}
HXDLIN( 203)										Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 203)										int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 203)										int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 203)										int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 203)										int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 203)										int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 203)										{
HXLINE( 203)											int _hx_tmp10;
HXDLIN( 203)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 203)												_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            											}
            											else {
HXLINE( 203)												_hx_tmp10 = blended2;
            											}
HXDLIN( 203)											::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            										}
            									}
            									else {
HXLINE( 203)										::Dynamic this56 = undoImage3->image;
HXDLIN( 203)										int index8;
HXDLIN( 203)										if (undoImage3->useVirtualPos) {
HXLINE( 203)											index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            										}
            										else {
HXLINE( 203)											index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            										}
HXDLIN( 203)										int _hx_tmp11;
HXDLIN( 203)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 203)											_hx_tmp11 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            										}
            										else {
HXLINE( 203)											_hx_tmp11 = c7;
            										}
HXDLIN( 203)										::iterMagic::Iimg_obj::set(this56,index8,_hx_tmp11);
            									}
            								}
            								else {
HXLINE( 203)									if (forceClear1) {
HXLINE( 203)										::Dynamic this57 = undoImage3->image;
HXDLIN( 203)										int x7 = (dx1 - rectLeft1);
HXDLIN( 203)										int y7 = (dy1 - rectTop1);
HXDLIN( 203)										int index9;
HXDLIN( 203)										if (undoImage3->useVirtualPos) {
HXLINE( 203)											index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x7) - undoImage3->virtualX));
            										}
            										else {
HXLINE( 203)											index9 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage3->width) + x7)) ));
            										}
HXDLIN( 203)										::iterMagic::Iimg_obj::set(this57,index9,0);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 203)		bool foundY1 = false;
HXDLIN( 203)		Float s1 = ((Float)0.);
HXDLIN( 203)		Float t1 = ((Float)0.);
HXDLIN( 203)		Float sxx1 = ((Float)0.);
HXDLIN( 203)		Float txx1 = ((Float)0.);
HXDLIN( 203)		{
HXLINE( 203)			int _g_min2 = xIter31->start;
HXDLIN( 203)			int _g_max2 = xIter31->max;
HXDLIN( 203)			while((_g_min2 < _g_max2)){
HXLINE( 203)				_g_min2 = (_g_min2 + 1);
HXDLIN( 203)				int x8 = (_g_min2 - 1);
HXLINE( 222)				sxx1 = (sx1 * ( (Float)(x8) ));
HXLINE( 223)				txx1 = (tx1 * ( (Float)(x8) ));
HXLINE( 224)				foundY1 = false;
HXLINE( 203)				{
HXLINE( 203)					int _g_min3 = yIter31->start;
HXDLIN( 203)					int _g_max3 = yIter31->max;
HXDLIN( 203)					while((_g_min3 < _g_max3)){
HXLINE( 203)						_g_min3 = (_g_min3 + 1);
HXDLIN( 203)						int y8 = (_g_min3 - 1);
HXLINE( 226)						s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y8) )));
HXLINE( 227)						t1 = ((t01 + txx1) + (ty1 * ( (Float)(y8) )));
HXLINE( 203)						bool _hx_tmp12;
HXDLIN( 203)						if (!((s1 <= 0))) {
HXLINE( 203)							_hx_tmp12 = (t1 <= 0);
            						}
            						else {
HXLINE( 203)							_hx_tmp12 = true;
            						}
HXDLIN( 203)						if (_hx_tmp12) {
HXLINE( 203)							if (foundY1) {
HXLINE( 203)								goto _hx_goto_300;
            							}
            						}
            						else {
HXLINE( 203)							if (((s1 + t1) < A1)) {
HXLINE( 203)								int x9 = ::hx::Mod(x8,tileImage->width);
HXDLIN( 203)								int y9 = ::hx::Mod(y8,tileImage->height);
HXDLIN( 203)								::Dynamic this58 = tileImage->image;
HXDLIN( 203)								int index10;
HXDLIN( 203)								if (tileImage->useVirtualPos) {
HXLINE( 203)									index10 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x9) - tileImage->virtualX));
            								}
            								else {
HXLINE( 203)									index10 = ::Std_obj::_hx_int(( (Float)(((y9 * tileImage->width) + x9)) ));
            								}
HXDLIN( 203)								int c8 = ::iterMagic::Iimg_obj::get(this58,index10);
HXDLIN( 203)								int color1;
HXDLIN( 203)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 203)									color1 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            								}
            								else {
HXLINE( 203)									color1 = c8;
            								}
HXDLIN( 203)								{
HXLINE( 203)									int c9 = color1;
HXDLIN( 203)									bool _hx_tmp13;
HXDLIN( 203)									if ((((c9 >> 24) & 255) < 254)) {
HXLINE( 203)										_hx_tmp13 = this1->transparent;
            									}
            									else {
HXLINE( 203)										_hx_tmp13 = false;
            									}
HXDLIN( 203)									if (_hx_tmp13) {
HXLINE( 203)										int location3;
HXDLIN( 203)										if (this1->useVirtualPos) {
HXLINE( 203)											location3 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - this1->virtualY) * ( (Float)(this1->width) )) + x8) - this1->virtualX));
            										}
            										else {
HXLINE( 203)											location3 = ::Std_obj::_hx_int(( (Float)(((y8 * this1->width) + x8)) ));
            										}
HXDLIN( 203)										int this59 = ::iterMagic::Iimg_obj::get(this1->image,location3);
HXDLIN( 203)										int this60;
HXDLIN( 203)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 203)											this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            										}
            										else {
HXLINE( 203)											this60 = this59;
            										}
HXDLIN( 203)										Float a13;
HXDLIN( 203)										int this61 = ((this60 >> 24) & 255);
HXDLIN( 203)										if ((this61 == 0)) {
HXLINE( 203)											a13 = ((Float)0.);
            										}
            										else {
HXLINE( 203)											a13 = (( (Float)(this61) ) / ( (Float)(255) ));
            										}
HXDLIN( 203)										Float r13;
HXDLIN( 203)										int this62 = ((this60 >> 16) & 255);
HXDLIN( 203)										if ((this62 == 0)) {
HXLINE( 203)											r13 = ((Float)0.);
            										}
            										else {
HXLINE( 203)											r13 = (( (Float)(this62) ) / ( (Float)(255) ));
            										}
HXDLIN( 203)										Float g13;
HXDLIN( 203)										int this63 = ((this60 >> 8) & 255);
HXDLIN( 203)										if ((this63 == 0)) {
HXLINE( 203)											g13 = ((Float)0.);
            										}
            										else {
HXLINE( 203)											g13 = (( (Float)(this63) ) / ( (Float)(255) ));
            										}
HXDLIN( 203)										Float b14;
HXDLIN( 203)										int this64 = (this60 & 255);
HXDLIN( 203)										if ((this64 == 0)) {
HXLINE( 203)											b14 = ((Float)0.);
            										}
            										else {
HXLINE( 203)											b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            										}
HXDLIN( 203)										Float a23;
HXDLIN( 203)										int this65 = ((color1 >> 24) & 255);
HXDLIN( 203)										if ((this65 == 0)) {
HXLINE( 203)											a23 = ((Float)0.);
            										}
            										else {
HXLINE( 203)											a23 = (( (Float)(this65) ) / ( (Float)(255) ));
            										}
HXDLIN( 203)										Float r23;
HXDLIN( 203)										int this66 = ((color1 >> 16) & 255);
HXDLIN( 203)										if ((this66 == 0)) {
HXLINE( 203)											r23 = ((Float)0.);
            										}
            										else {
HXLINE( 203)											r23 = (( (Float)(this66) ) / ( (Float)(255) ));
            										}
HXDLIN( 203)										Float g23;
HXDLIN( 203)										int this67 = ((color1 >> 8) & 255);
HXDLIN( 203)										if ((this67 == 0)) {
HXLINE( 203)											g23 = ((Float)0.);
            										}
            										else {
HXLINE( 203)											g23 = (( (Float)(this67) ) / ( (Float)(255) ));
            										}
HXDLIN( 203)										Float b24;
HXDLIN( 203)										int this68 = (color1 & 255);
HXDLIN( 203)										if ((this68 == 0)) {
HXLINE( 203)											b24 = ((Float)0.);
            										}
            										else {
HXLINE( 203)											b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            										}
HXDLIN( 203)										Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 203)										int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 203)										int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 203)										int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 203)										int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 203)										int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 203)										{
HXLINE( 203)											int _hx_tmp14;
HXDLIN( 203)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 203)												_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            											}
            											else {
HXLINE( 203)												_hx_tmp14 = blended3;
            											}
HXDLIN( 203)											::iterMagic::Iimg_obj::set(this1->image,location3,_hx_tmp14);
            										}
            									}
            									else {
HXLINE( 203)										::Dynamic this69 = this1->image;
HXDLIN( 203)										int index11;
HXDLIN( 203)										if (this1->useVirtualPos) {
HXLINE( 203)											index11 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - this1->virtualY) * ( (Float)(this1->width) )) + x8) - this1->virtualX));
            										}
            										else {
HXLINE( 203)											index11 = ::Std_obj::_hx_int(( (Float)(((y8 * this1->width) + x8)) ));
            										}
HXDLIN( 203)										int _hx_tmp15;
HXDLIN( 203)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 203)											_hx_tmp15 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            										}
            										else {
HXLINE( 203)											_hx_tmp15 = c9;
            										}
HXDLIN( 203)										::iterMagic::Iimg_obj::set(this69,index11,_hx_tmp15);
            									}
            								}
HXLINE( 236)								foundY1 = true;
            							}
            							else {
HXLINE( 203)								if (foundY1) {
HXLINE( 203)									goto _hx_goto_300;
            								}
            							}
            						}
            					}
            					_hx_goto_300:;
            				}
            			}
            		}
HXDLIN( 203)		 ::pi_xy::algo::HitTri triHit1;
HXDLIN( 203)		if ((hasHit == false)) {
HXLINE( 203)			 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,ax,ay,bx2,by2,cx2,cy2,true);
HXDLIN( 203)			if (hasUndo1) {
HXLINE( 203)				v5->undoImage = undoImage3;
HXDLIN( 203)				v5->undoX = xIter31->start;
HXDLIN( 203)				v5->undoY = yIter31->start;
            			}
HXDLIN( 203)			triHit1 = v5;
            		}
            		else {
HXLINE( 203)			triHit1 = null();
            		}
HXLINE( 204)		if (hasHit) {
HXLINE( 204)			arrTri[arrTri->length] = triHit1;
            		}
HXLINE( 205)		if (hasHit) {
HXLINE( 206)			return  ::pi_xy::algo::HitTriArray_obj::__alloc( HX_CTX ,arrTri);
            		}
            		else {
HXLINE( 208)			arrTri = null();
HXLINE( 209)			return null();
            		}
HXLINE( 205)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC10(TileShape_Impl__obj,pie,return )

void TileShape_Impl__obj::ellipseTri( ::pi_xy::ImageStruct this1,Float cx,Float cy,Float rx,Float ry, ::pi_xy::ImageStruct tileImage, ::Dynamic __o_phi, ::Dynamic __o_printSides, ::Dynamic __o_targetError){
            		 ::Dynamic phi = __o_phi;
            		if (::hx::IsNull(__o_phi)) phi = 0;
            		 ::Dynamic printSides = __o_printSides;
            		if (::hx::IsNull(__o_printSides)) printSides = false;
            		 ::Dynamic targetError = __o_targetError;
            		if (::hx::IsNull(__o_targetError)) targetError = ((Float)1.05);
            	HX_GC_STACKFRAME(&_hx_pos_6e4d7718bf84d356_219_ellipseTri)
HXLINE( 220)		Float rSmall;
HXDLIN( 220)		if ((rx > ry)) {
HXLINE( 220)			rSmall = ry;
            		}
            		else {
HXLINE( 220)			rSmall = rx;
            		}
HXLINE( 221)		 ::Dynamic targetE = targetError;
HXDLIN( 221)		if (::hx::IsNull( targetE )) {
HXLINE( 221)			targetE = ((Float)1.05);
            		}
HXDLIN( 221)		int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN( 221)		int noSides;
HXDLIN( 221)		if ((result < 12)) {
HXLINE( 221)			noSides = 12;
            		}
            		else {
HXLINE( 221)			if ((result > 500)) {
HXLINE( 221)				noSides = 500;
            			}
            			else {
HXLINE( 221)				noSides = result;
            			}
            		}
HXLINE( 222)		if (( (bool)(printSides) )) {
HXLINE( 222)			::haxe::Log_obj::trace(noSides,::hx::SourceInfo(HX_("src/pi_xy/imageAbstracts/TileShape.hx",71,74,77,8a),222,HX_("pi_xy.imageAbstracts._TileShape.TileShape_Impl_",aa,04,c9,1d),HX_("ellipseTri",ed,3e,df,4c)));
            		}
HXLINE( 223)		{
HXLINE( 223)			 ::Dynamic phi1 = phi;
HXDLIN( 223)			 ::Dynamic sides = noSides;
HXLINE( 227)			if (::hx::IsNull( sides )) {
HXLINE( 227)				sides = 36;
            			}
HXLINE( 226)			if (::hx::IsNull( phi1 )) {
HXLINE( 226)				phi1 = ((Float)0.);
            			}
HXLINE( 223)			{
HXLINE( 223)				 ::Dynamic phi2 = phi1;
HXDLIN( 223)				 ::Dynamic sides1 = sides;
HXDLIN( 223)				if (::hx::IsNull( sides1 )) {
HXLINE(  83)					sides1 = 36;
            				}
HXLINE( 223)				if (::hx::IsNull( phi2 )) {
HXLINE(  82)					phi2 = ((Float)0.);
            				}
HXLINE( 223)				Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN( 223)				Float omega;
HXDLIN( 223)				omega = ((Float)0.);
HXDLIN( 223)				Float lastX = ((Float)0.);
HXDLIN( 223)				Float lastY = ((Float)0.);
HXDLIN( 223)				if (::hx::IsNotEq( phi2,0 )) {
HXLINE( 154)					lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi2) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi2) )))) + cx);
HXLINE( 155)					lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi2) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi2) )))) + cy);
            				}
            				else {
HXLINE( 157)					lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))));
HXLINE( 158)					lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))));
            				}
HXLINE( 223)				if (::hx::IsNotEq( phi2,0 )) {
HXLINE( 223)					Float cphi = ::Math_obj::cos(( (Float)(phi2) ));
HXDLIN( 223)					Float sphi = ::Math_obj::sin(( (Float)(phi2) ));
HXDLIN( 223)					{
HXLINE( 223)						int _g = 0;
HXDLIN( 223)						int _g1 = (sides1 + 1);
HXDLIN( 223)						while((_g < _g1)){
HXLINE( 223)							_g = (_g + 1);
HXDLIN( 223)							int i = (_g - 1);
HXDLIN( 223)							Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 223)							Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN( 223)							Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXDLIN( 223)							Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXDLIN( 223)							{
HXLINE( 223)								 ::pi_xy::ImageStruct this2 = this1;
HXDLIN( 223)								bool hasHit = false;
HXDLIN( 223)								{
HXLINE( 223)									Float bx = lastX;
HXDLIN( 223)									Float by = lastY;
HXDLIN( 223)									Float cx1 = nextX;
HXDLIN( 223)									Float cy1 = nextY;
HXDLIN( 223)									bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN( 223)									if (!(adjustWinding)) {
HXLINE( 223)										Float bx_ = bx;
HXDLIN( 223)										Float by_ = by;
HXLINE( 187)										bx = cx1;
HXLINE( 188)										by = cy1;
HXLINE( 189)										cx1 = bx_;
HXLINE( 190)										cy1 = by_;
            									}
HXLINE( 223)									{
HXLINE( 223)										bool hasUndo = false;
HXDLIN( 223)										Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN( 223)										Float sx = (cy1 - cy);
HXDLIN( 223)										Float sy = (cx - cx1);
HXDLIN( 223)										Float t0 = ((cx * by) - (cy * bx));
HXDLIN( 223)										Float tx = (cy - by);
HXDLIN( 223)										Float ty = (bx - cx);
HXDLIN( 223)										Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN( 223)										 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN( 223)										if ((cx > bx)) {
HXLINE( 223)											if ((cx > cx1)) {
HXLINE( 223)												int min;
HXDLIN( 223)												if ((bx > cx1)) {
HXLINE( 223)													min = ::Math_obj::floor(cx1);
            												}
            												else {
HXLINE( 223)													min = ::Math_obj::floor(bx);
            												}
HXDLIN( 223)												int ii_min = min;
HXDLIN( 223)												int ii_max = ::Math_obj::ceil(cx);
HXDLIN( 223)												xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            											}
            											else {
HXLINE( 223)												int ii_min1 = ::Math_obj::floor(bx);
HXDLIN( 223)												int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN( 223)												xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            											}
            										}
            										else {
HXLINE( 223)											if ((bx > cx1)) {
HXLINE( 223)												int min1;
HXDLIN( 223)												if ((cx > cx1)) {
HXLINE( 223)													min1 = ::Math_obj::floor(cx1);
            												}
            												else {
HXLINE( 223)													min1 = ::Math_obj::ceil(cx);
            												}
HXDLIN( 223)												int ii_min2 = min1;
HXDLIN( 223)												int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN( 223)												xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            											}
            											else {
HXLINE( 223)												int ii_min3 = ::Math_obj::floor(cx);
HXDLIN( 223)												int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN( 223)												xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            											}
            										}
HXDLIN( 223)										 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN( 223)										if ((cy > by)) {
HXLINE( 223)											if ((cy > cy1)) {
HXLINE( 223)												int min2;
HXDLIN( 223)												if ((by > cy1)) {
HXLINE( 223)													min2 = ::Math_obj::floor(cy1);
            												}
            												else {
HXLINE( 223)													min2 = ::Math_obj::floor(by);
            												}
HXDLIN( 223)												int ii_min4 = min2;
HXDLIN( 223)												int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN( 223)												yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            											}
            											else {
HXLINE( 223)												int ii_min5 = ::Math_obj::floor(by);
HXDLIN( 223)												int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN( 223)												yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            											}
            										}
            										else {
HXLINE( 223)											if ((by > cy1)) {
HXLINE( 223)												int min3;
HXDLIN( 223)												if ((cy > cy1)) {
HXLINE( 223)													min3 = ::Math_obj::floor(cy1);
            												}
            												else {
HXLINE( 223)													min3 = ::Math_obj::ceil(cy);
            												}
HXDLIN( 223)												int ii_min6 = min3;
HXDLIN( 223)												int ii_max6 = ::Math_obj::ceil(by);
HXDLIN( 223)												yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            											}
            											else {
HXLINE( 223)												int ii_min7 = ::Math_obj::floor(cy);
HXDLIN( 223)												int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN( 223)												yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            											}
            										}
HXDLIN( 223)										 ::pi_xy::ImageStruct undoImage = null();
HXDLIN( 223)										if (hasUndo) {
HXLINE( 223)											int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN( 223)											int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN( 223)											 ::Dynamic imageType = null();
HXDLIN( 223)											 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 223)											if (::hx::IsNull( imageType )) {
HXLINE(  54)												imageType = ::pi_xy::ImageStruct_obj::defaultType;
            											}
HXLINE( 223)											::Dynamic undoImage1;
HXDLIN( 223)											switch((int)(( (int)(imageType) ))){
            												case (int)0: {
HXLINE( 223)													 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 223)													 ::iterMagic::BytesImg b = byt;
HXDLIN( 223)													{
HXLINE( 223)														b->width = width;
HXDLIN( 223)														b->height = height;
HXDLIN( 223)														b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 223)														b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN( 223)														{
HXLINE( 223)															int len = b->length;
HXDLIN( 223)															int w = 0;
HXDLIN( 223)															{
HXLINE( 223)																int _g2 = 0;
HXDLIN( 223)																int _g3 = b->height;
HXDLIN( 223)																while((_g2 < _g3)){
HXLINE( 223)																	_g2 = (_g2 + 1);
HXDLIN( 223)																	int y = (_g2 - 1);
HXDLIN( 223)																	{
HXLINE( 223)																		int _g4 = 0;
HXDLIN( 223)																		int _g5 = b->width;
HXDLIN( 223)																		while((_g4 < _g5)){
HXLINE( 223)																			_g4 = (_g4 + 1);
HXDLIN( 223)																			int x = (_g4 - 1);
HXDLIN( 223)																			{
HXLINE( 223)																				w = (w + 1);
HXDLIN( 223)																				b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 223)																			{
HXLINE( 223)																				w = (w + 1);
HXDLIN( 223)																				b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 223)																			{
HXLINE( 223)																				w = (w + 1);
HXDLIN( 223)																				b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN( 223)																			{
HXLINE( 223)																				w = (w + 1);
HXDLIN( 223)																				b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 223)													undoImage1 = b;
            												}
            												break;
            												case (int)1: {
HXLINE( 223)													 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 223)													 ::iterMagic::ArrIntImg a = arrI;
HXDLIN( 223)													{
HXLINE( 223)														a->width = width;
HXDLIN( 223)														a->height = height;
HXDLIN( 223)														a->data = ::Array_obj< int >::__new(0);
HXDLIN( 223)														a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 223)														{
HXLINE( 223)															int _g6 = 0;
HXDLIN( 223)															int _g7 = a->length;
HXDLIN( 223)															while((_g6 < _g7)){
HXLINE( 223)																_g6 = (_g6 + 1);
HXDLIN( 223)																int i1 = (_g6 - 1);
HXDLIN( 223)																a->data[i1] = 0;
            															}
            														}
            													}
HXDLIN( 223)													undoImage1 = a;
            												}
            												break;
            												case (int)2: {
HXLINE( 223)													 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 223)													 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN( 223)													{
HXLINE( 223)														b1->width = width;
HXDLIN( 223)														b1->height = height;
HXDLIN( 223)														b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 223)														int size = (b1->length * 4);
HXDLIN( 223)														b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN( 223)														{
HXLINE( 223)															int _g8 = 0;
HXDLIN( 223)															int _g9 = b1->length;
HXDLIN( 223)															while((_g8 < _g9)){
HXLINE( 223)																_g8 = (_g8 + 1);
HXDLIN( 223)																int i2 = (_g8 - 1);
HXDLIN( 223)																{
HXLINE( 223)																	 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN( 223)																	bool undoImage2;
HXDLIN( 223)																	if ((i2 >= 0)) {
HXLINE( 223)																		undoImage2 = (i2 < (this4->byteLength >> 2));
            																	}
            																	else {
HXLINE( 223)																		undoImage2 = false;
            																	}
HXDLIN( 223)																	if (undoImage2) {
HXLINE( 223)																		 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN( 223)																		int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN( 223)																		_this->b[pos] = ( (unsigned char)(0) );
HXDLIN( 223)																		_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN( 223)																		_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN( 223)																		_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 223)													undoImage1 = b1;
            												}
            												break;
            												case (int)3: {
HXLINE( 223)													 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 223)													 ::iterMagic::VecIntImg v = vec;
HXDLIN( 223)													{
HXLINE( 223)														v->width = width;
HXDLIN( 223)														v->height = height;
HXDLIN( 223)														v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 223)														v->data = ::Array_obj< int >::__new(v->length);
HXDLIN( 223)														{
HXLINE( 223)															int _g10 = 0;
HXDLIN( 223)															int _g11 = v->length;
HXDLIN( 223)															while((_g10 < _g11)){
HXLINE( 223)																_g10 = (_g10 + 1);
HXDLIN( 223)																int i3 = (_g10 - 1);
HXDLIN( 223)																v->data->__unsafe_set(i3,0);
            															}
            														}
            													}
HXDLIN( 223)													undoImage1 = v;
            												}
            												break;
            												case (int)4: {
HXLINE( 223)													 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 223)													 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN( 223)													{
HXLINE( 223)														b2->width = width;
HXDLIN( 223)														b2->height = height;
HXDLIN( 223)														b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN( 223)														b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 223)														{
HXLINE( 223)															int len1 = b2->length;
HXDLIN( 223)															 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN( 223)															if (::hx::IsNull( d->head )) {
HXLINE( 223)																int _g12 = 0;
HXDLIN( 223)																int _g13 = len1;
HXDLIN( 223)																while((_g12 < _g13)){
HXLINE( 223)																	_g12 = (_g12 + 1);
HXDLIN( 223)																	int i4 = (_g12 - 1);
HXDLIN( 223)																	d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            																}
            															}
            															else {
HXLINE( 223)																int _g14 = 0;
HXDLIN( 223)																int _g15 = len1;
HXDLIN( 223)																while((_g14 < _g15)){
HXLINE( 223)																	_g14 = (_g14 + 1);
HXDLIN( 223)																	int i5 = (_g14 - 1);
HXDLIN( 223)																	{
HXLINE( 223)																		 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN( 223)																		 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN( 223)																		{
HXLINE( 223)																			int _g16 = 0;
HXDLIN( 223)																			int _g17 = i5;
HXDLIN( 223)																			while((_g16 < _g17)){
HXLINE( 223)																				_g16 = (_g16 + 1);
HXDLIN( 223)																				int i6 = (_g16 - 1);
HXLINE( 345)																				prev = l;
HXLINE( 346)																				l = l->next;
            																			}
            																		}
HXLINE( 223)																		if (::hx::IsNull( prev )) {
HXLINE( 223)																			b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 223)																			l = null();
            																		}
            																		else {
HXLINE( 223)																			prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN( 223)																			l = null();
            																		}
            																	}
            																}
            															}
            														}
            													}
HXDLIN( 223)													undoImage1 = b2;
            												}
            												break;
            											}
HXDLIN( 223)											this3->image = undoImage1;
HXDLIN( 223)											this3->width = width;
HXDLIN( 223)											this3->height = height;
HXDLIN( 223)											this3->imageType = ( (int)(imageType) );
HXDLIN( 223)											undoImage = this3;
HXDLIN( 223)											{
HXLINE( 223)												int rectLeft = xIter3->start;
HXDLIN( 223)												int rectTop = yIter3->start;
HXDLIN( 223)												int rectRight = xIter3->max;
HXDLIN( 223)												bool forceClear = false;
HXDLIN( 223)												{
HXLINE( 223)													int _g18 = rectTop;
HXDLIN( 223)													int _g19 = yIter3->max;
HXDLIN( 223)													while((_g18 < _g19)){
HXLINE( 223)														_g18 = (_g18 + 1);
HXDLIN( 223)														int dy = (_g18 - 1);
HXDLIN( 223)														{
HXLINE( 223)															int _g20 = rectLeft;
HXDLIN( 223)															int _g21 = rectRight;
HXDLIN( 223)															while((_g20 < _g21)){
HXLINE( 223)																_g20 = (_g20 + 1);
HXDLIN( 223)																int dx = (_g20 - 1);
HXDLIN( 223)																::Dynamic this5 = this2->image;
HXDLIN( 223)																int index;
HXDLIN( 223)																if (this2->useVirtualPos) {
HXLINE( 223)																	index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            																}
            																else {
HXLINE( 223)																	index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            																}
HXDLIN( 223)																int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN( 223)																int col;
HXDLIN( 223)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 223)																	col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																}
            																else {
HXLINE( 223)																	col = c;
            																}
HXDLIN( 223)																bool _hx_tmp;
HXDLIN( 223)																if (this2->useMask) {
HXLINE( 223)																	_hx_tmp = ::hx::IsNotNull( this2->mask );
            																}
            																else {
HXLINE( 223)																	_hx_tmp = false;
            																}
HXDLIN( 223)																if (_hx_tmp) {
HXLINE( 223)																	 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN( 223)																	::Dynamic this7 = this6->image;
HXDLIN( 223)																	int index1;
HXDLIN( 223)																	if (this6->useVirtualPos) {
HXLINE( 223)																		index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            																	}
            																	else {
HXLINE( 223)																		index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            																	}
HXDLIN( 223)																	int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN( 223)																	int v1;
HXDLIN( 223)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 223)																		v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																	}
            																	else {
HXLINE( 223)																		v1 = c1;
            																	}
HXDLIN( 223)																	int maskPixel = v1;
HXDLIN( 223)																	int this8 = col;
HXDLIN( 223)																	if ((maskPixel == 0)) {
HXLINE( 223)																		col = this8;
            																	}
            																	else {
HXLINE( 223)																		Float m0;
HXDLIN( 223)																		int this9 = ((maskPixel >> 24) & 255);
HXDLIN( 223)																		if ((this9 == 0)) {
HXLINE( 223)																			m0 = ((Float)0.);
            																		}
            																		else {
HXLINE( 223)																			m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																		}
HXDLIN( 223)																		Float m1;
HXDLIN( 223)																		int this10 = ((maskPixel >> 16) & 255);
HXDLIN( 223)																		if ((this10 == 0)) {
HXLINE( 223)																			m1 = ((Float)0.);
            																		}
            																		else {
HXLINE( 223)																			m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																		}
HXDLIN( 223)																		Float m2;
HXDLIN( 223)																		int this11 = ((maskPixel >> 8) & 255);
HXDLIN( 223)																		if ((this11 == 0)) {
HXLINE( 223)																			m2 = ((Float)0.);
            																		}
            																		else {
HXLINE( 223)																			m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																		}
HXDLIN( 223)																		Float m3;
HXDLIN( 223)																		int this12 = (maskPixel & 255);
HXDLIN( 223)																		if ((this12 == 0)) {
HXLINE( 223)																			m3 = ((Float)0.);
            																		}
            																		else {
HXLINE( 223)																			m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																		}
HXDLIN( 223)																		int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN( 223)																		int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN( 223)																		int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN( 223)																		int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN( 223)																		col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																	}
            																}
HXDLIN( 223)																if ((col != 0)) {
HXLINE( 223)																	int x1 = (dx - rectLeft);
HXDLIN( 223)																	int y1 = (dy - rectTop);
HXDLIN( 223)																	int c2 = col;
HXDLIN( 223)																	bool _hx_tmp1;
HXDLIN( 223)																	if ((((c2 >> 24) & 255) < 254)) {
HXLINE( 223)																		_hx_tmp1 = undoImage->transparent;
            																	}
            																	else {
HXLINE( 223)																		_hx_tmp1 = false;
            																	}
HXDLIN( 223)																	if (_hx_tmp1) {
HXLINE( 223)																		int location;
HXDLIN( 223)																		if (undoImage->useVirtualPos) {
HXLINE( 223)																			location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																		}
            																		else {
HXLINE( 223)																			location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																		}
HXDLIN( 223)																		int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN( 223)																		int this14;
HXDLIN( 223)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 223)																			this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																		}
            																		else {
HXLINE( 223)																			this14 = this13;
            																		}
HXDLIN( 223)																		Float a1;
HXDLIN( 223)																		int this15 = ((this14 >> 24) & 255);
HXDLIN( 223)																		if ((this15 == 0)) {
HXLINE( 223)																			a1 = ((Float)0.);
            																		}
            																		else {
HXLINE( 223)																			a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																		}
HXDLIN( 223)																		Float r1;
HXDLIN( 223)																		int this16 = ((this14 >> 16) & 255);
HXDLIN( 223)																		if ((this16 == 0)) {
HXLINE( 223)																			r1 = ((Float)0.);
            																		}
            																		else {
HXLINE( 223)																			r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																		}
HXDLIN( 223)																		Float g1;
HXDLIN( 223)																		int this17 = ((this14 >> 8) & 255);
HXDLIN( 223)																		if ((this17 == 0)) {
HXLINE( 223)																			g1 = ((Float)0.);
            																		}
            																		else {
HXLINE( 223)																			g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																		}
HXDLIN( 223)																		Float b11;
HXDLIN( 223)																		int this18 = (this14 & 255);
HXDLIN( 223)																		if ((this18 == 0)) {
HXLINE( 223)																			b11 = ((Float)0.);
            																		}
            																		else {
HXLINE( 223)																			b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																		}
HXDLIN( 223)																		Float a2;
HXDLIN( 223)																		int this19 = ((col >> 24) & 255);
HXDLIN( 223)																		if ((this19 == 0)) {
HXLINE( 223)																			a2 = ((Float)0.);
            																		}
            																		else {
HXLINE( 223)																			a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																		}
HXDLIN( 223)																		Float r2;
HXDLIN( 223)																		int this20 = ((col >> 16) & 255);
HXDLIN( 223)																		if ((this20 == 0)) {
HXLINE( 223)																			r2 = ((Float)0.);
            																		}
            																		else {
HXLINE( 223)																			r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																		}
HXDLIN( 223)																		Float g2;
HXDLIN( 223)																		int this21 = ((col >> 8) & 255);
HXDLIN( 223)																		if ((this21 == 0)) {
HXLINE( 223)																			g2 = ((Float)0.);
            																		}
            																		else {
HXLINE( 223)																			g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																		}
HXDLIN( 223)																		Float b21;
HXDLIN( 223)																		int this22 = (col & 255);
HXDLIN( 223)																		if ((this22 == 0)) {
HXLINE( 223)																			b21 = ((Float)0.);
            																		}
            																		else {
HXLINE( 223)																			b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																		}
HXDLIN( 223)																		Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN( 223)																		int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN( 223)																		int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN( 223)																		int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN( 223)																		int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN( 223)																		int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN( 223)																		{
HXLINE( 223)																			int _hx_tmp2;
HXDLIN( 223)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 223)																				_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																			}
            																			else {
HXLINE( 223)																				_hx_tmp2 = blended;
            																			}
HXDLIN( 223)																			::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																		}
            																	}
            																	else {
HXLINE( 223)																		::Dynamic this23 = undoImage->image;
HXDLIN( 223)																		int index2;
HXDLIN( 223)																		if (undoImage->useVirtualPos) {
HXLINE( 223)																			index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																		}
            																		else {
HXLINE( 223)																			index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																		}
HXDLIN( 223)																		int _hx_tmp3;
HXDLIN( 223)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 223)																			_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																		}
            																		else {
HXLINE( 223)																			_hx_tmp3 = c2;
            																		}
HXDLIN( 223)																		::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            																	}
            																}
            																else {
HXLINE( 223)																	if (forceClear) {
HXLINE( 223)																		::Dynamic this24 = undoImage->image;
HXDLIN( 223)																		int x2 = (dx - rectLeft);
HXDLIN( 223)																		int y2 = (dy - rectTop);
HXDLIN( 223)																		int index3;
HXDLIN( 223)																		if (undoImage->useVirtualPos) {
HXLINE( 223)																			index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																		}
            																		else {
HXLINE( 223)																			index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																		}
HXDLIN( 223)																		::iterMagic::Iimg_obj::set(this24,index3,0);
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN( 223)										bool foundY = false;
HXDLIN( 223)										Float s = ((Float)0.);
HXDLIN( 223)										Float t = ((Float)0.);
HXDLIN( 223)										Float sxx = ((Float)0.);
HXDLIN( 223)										Float txx = ((Float)0.);
HXDLIN( 223)										{
HXLINE( 223)											int _g_min = xIter3->start;
HXDLIN( 223)											int _g_max = xIter3->max;
HXDLIN( 223)											while((_g_min < _g_max)){
HXLINE( 223)												_g_min = (_g_min + 1);
HXDLIN( 223)												int x3 = (_g_min - 1);
HXLINE( 222)												sxx = (sx * ( (Float)(x3) ));
HXLINE( 223)												txx = (tx * ( (Float)(x3) ));
HXLINE( 224)												foundY = false;
HXLINE( 223)												{
HXLINE( 223)													int _g_min1 = yIter3->start;
HXDLIN( 223)													int _g_max1 = yIter3->max;
HXDLIN( 223)													while((_g_min1 < _g_max1)){
HXLINE( 223)														_g_min1 = (_g_min1 + 1);
HXDLIN( 223)														int y3 = (_g_min1 - 1);
HXLINE( 226)														s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE( 227)														t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE( 223)														bool _hx_tmp4;
HXDLIN( 223)														if (!((s <= 0))) {
HXLINE( 223)															_hx_tmp4 = (t <= 0);
            														}
            														else {
HXLINE( 223)															_hx_tmp4 = true;
            														}
HXDLIN( 223)														if (_hx_tmp4) {
HXLINE( 223)															if (foundY) {
HXLINE( 223)																goto _hx_goto_314;
            															}
            														}
            														else {
HXLINE( 223)															if (((s + t) < A)) {
HXLINE( 223)																int x4 = ::hx::Mod(x3,tileImage->width);
HXDLIN( 223)																int y4 = ::hx::Mod(y3,tileImage->height);
HXDLIN( 223)																::Dynamic this25 = tileImage->image;
HXDLIN( 223)																int index4;
HXDLIN( 223)																if (tileImage->useVirtualPos) {
HXLINE( 223)																	index4 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x4) - tileImage->virtualX));
            																}
            																else {
HXLINE( 223)																	index4 = ::Std_obj::_hx_int(( (Float)(((y4 * tileImage->width) + x4)) ));
            																}
HXDLIN( 223)																int c3 = ::iterMagic::Iimg_obj::get(this25,index4);
HXDLIN( 223)																int color;
HXDLIN( 223)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 223)																	color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            																}
            																else {
HXLINE( 223)																	color = c3;
            																}
HXDLIN( 223)																{
HXLINE( 223)																	int c4 = color;
HXDLIN( 223)																	bool _hx_tmp5;
HXDLIN( 223)																	if ((((c4 >> 24) & 255) < 254)) {
HXLINE( 223)																		_hx_tmp5 = this2->transparent;
            																	}
            																	else {
HXLINE( 223)																		_hx_tmp5 = false;
            																	}
HXDLIN( 223)																	if (_hx_tmp5) {
HXLINE( 223)																		int location1;
HXDLIN( 223)																		if (this2->useVirtualPos) {
HXLINE( 223)																			location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																		}
            																		else {
HXLINE( 223)																			location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																		}
HXDLIN( 223)																		int this26 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN( 223)																		int this27;
HXDLIN( 223)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 223)																			this27 = ((((((this26 >> 24) & 255) << 24) | ((this26 & 255) << 16)) | (((this26 >> 8) & 255) << 8)) | ((this26 >> 16) & 255));
            																		}
            																		else {
HXLINE( 223)																			this27 = this26;
            																		}
HXDLIN( 223)																		Float a11;
HXDLIN( 223)																		int this28 = ((this27 >> 24) & 255);
HXDLIN( 223)																		if ((this28 == 0)) {
HXLINE( 223)																			a11 = ((Float)0.);
            																		}
            																		else {
HXLINE( 223)																			a11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																		}
HXDLIN( 223)																		Float r11;
HXDLIN( 223)																		int this29 = ((this27 >> 16) & 255);
HXDLIN( 223)																		if ((this29 == 0)) {
HXLINE( 223)																			r11 = ((Float)0.);
            																		}
            																		else {
HXLINE( 223)																			r11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																		}
HXDLIN( 223)																		Float g11;
HXDLIN( 223)																		int this30 = ((this27 >> 8) & 255);
HXDLIN( 223)																		if ((this30 == 0)) {
HXLINE( 223)																			g11 = ((Float)0.);
            																		}
            																		else {
HXLINE( 223)																			g11 = (( (Float)(this30) ) / ( (Float)(255) ));
            																		}
HXDLIN( 223)																		Float b12;
HXDLIN( 223)																		int this31 = (this27 & 255);
HXDLIN( 223)																		if ((this31 == 0)) {
HXLINE( 223)																			b12 = ((Float)0.);
            																		}
            																		else {
HXLINE( 223)																			b12 = (( (Float)(this31) ) / ( (Float)(255) ));
            																		}
HXDLIN( 223)																		Float a21;
HXDLIN( 223)																		int this32 = ((color >> 24) & 255);
HXDLIN( 223)																		if ((this32 == 0)) {
HXLINE( 223)																			a21 = ((Float)0.);
            																		}
            																		else {
HXLINE( 223)																			a21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																		}
HXDLIN( 223)																		Float r21;
HXDLIN( 223)																		int this33 = ((color >> 16) & 255);
HXDLIN( 223)																		if ((this33 == 0)) {
HXLINE( 223)																			r21 = ((Float)0.);
            																		}
            																		else {
HXLINE( 223)																			r21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																		}
HXDLIN( 223)																		Float g21;
HXDLIN( 223)																		int this34 = ((color >> 8) & 255);
HXDLIN( 223)																		if ((this34 == 0)) {
HXLINE( 223)																			g21 = ((Float)0.);
            																		}
            																		else {
HXLINE( 223)																			g21 = (( (Float)(this34) ) / ( (Float)(255) ));
            																		}
HXDLIN( 223)																		Float b22;
HXDLIN( 223)																		int this35 = (color & 255);
HXDLIN( 223)																		if ((this35 == 0)) {
HXLINE( 223)																			b22 = ((Float)0.);
            																		}
            																		else {
HXLINE( 223)																			b22 = (( (Float)(this35) ) / ( (Float)(255) ));
            																		}
HXDLIN( 223)																		Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN( 223)																		int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN( 223)																		int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN( 223)																		int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN( 223)																		int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN( 223)																		int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN( 223)																		{
HXLINE( 223)																			int _hx_tmp6;
HXDLIN( 223)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 223)																				_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																			}
            																			else {
HXLINE( 223)																				_hx_tmp6 = blended1;
            																			}
HXDLIN( 223)																			::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp6);
            																		}
            																	}
            																	else {
HXLINE( 223)																		::Dynamic this36 = this2->image;
HXDLIN( 223)																		int index5;
HXDLIN( 223)																		if (this2->useVirtualPos) {
HXLINE( 223)																			index5 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																		}
            																		else {
HXLINE( 223)																			index5 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																		}
HXDLIN( 223)																		int _hx_tmp7;
HXDLIN( 223)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 223)																			_hx_tmp7 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            																		}
            																		else {
HXLINE( 223)																			_hx_tmp7 = c4;
            																		}
HXDLIN( 223)																		::iterMagic::Iimg_obj::set(this36,index5,_hx_tmp7);
            																	}
            																}
HXLINE( 236)																foundY = true;
            															}
            															else {
HXLINE( 223)																if (foundY) {
HXLINE( 223)																	goto _hx_goto_314;
            																}
            															}
            														}
            													}
            													_hx_goto_314:;
            												}
            											}
            										}
HXDLIN( 223)										if ((hasHit == false)) {
HXLINE( 223)											 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN( 223)											if (hasUndo) {
HXLINE( 223)												v2->undoImage = undoImage;
HXDLIN( 223)												v2->undoX = xIter3->start;
HXDLIN( 223)												v2->undoY = yIter3->start;
            											}
            										}
            									}
            								}
            							}
HXLINE( 169)							lastX = nextX;
HXLINE( 170)							lastY = nextY;
            						}
            					}
            				}
            				else {
HXLINE( 223)					int _g22 = 0;
HXDLIN( 223)					int _g23 = (sides1 + 1);
HXDLIN( 223)					while((_g22 < _g23)){
HXLINE( 223)						_g22 = (_g22 + 1);
HXDLIN( 223)						int i7 = (_g22 - 1);
HXDLIN( 223)						Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 223)						Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN( 223)						{
HXLINE( 223)							 ::pi_xy::ImageStruct this37 = this1;
HXDLIN( 223)							bool hasHit1 = false;
HXDLIN( 223)							{
HXLINE( 223)								Float bx1 = lastX;
HXDLIN( 223)								Float by1 = lastY;
HXDLIN( 223)								Float cx2 = nextX1;
HXDLIN( 223)								Float cy2 = nextY1;
HXDLIN( 223)								bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN( 223)								if (!(adjustWinding1)) {
HXLINE( 223)									Float bx_1 = bx1;
HXDLIN( 223)									Float by_1 = by1;
HXLINE( 187)									bx1 = cx2;
HXLINE( 188)									by1 = cy2;
HXLINE( 189)									cx2 = bx_1;
HXLINE( 190)									cy2 = by_1;
            								}
HXLINE( 223)								{
HXLINE( 223)									bool hasUndo1 = false;
HXDLIN( 223)									Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN( 223)									Float sx1 = (cy2 - cy);
HXDLIN( 223)									Float sy1 = (cx - cx2);
HXDLIN( 223)									Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN( 223)									Float tx1 = (cy - by1);
HXDLIN( 223)									Float ty1 = (bx1 - cx);
HXDLIN( 223)									Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN( 223)									 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN( 223)									if ((cx > bx1)) {
HXLINE( 223)										if ((cx > cx2)) {
HXLINE( 223)											int min4;
HXDLIN( 223)											if ((bx1 > cx2)) {
HXLINE( 223)												min4 = ::Math_obj::floor(cx2);
            											}
            											else {
HXLINE( 223)												min4 = ::Math_obj::floor(bx1);
            											}
HXDLIN( 223)											int ii_min8 = min4;
HXDLIN( 223)											int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN( 223)											xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            										}
            										else {
HXLINE( 223)											int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN( 223)											int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN( 223)											xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            										}
            									}
            									else {
HXLINE( 223)										if ((bx1 > cx2)) {
HXLINE( 223)											int min5;
HXDLIN( 223)											if ((cx > cx2)) {
HXLINE( 223)												min5 = ::Math_obj::floor(cx2);
            											}
            											else {
HXLINE( 223)												min5 = ::Math_obj::ceil(cx);
            											}
HXDLIN( 223)											int ii_min10 = min5;
HXDLIN( 223)											int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN( 223)											xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            										}
            										else {
HXLINE( 223)											int ii_min11 = ::Math_obj::floor(cx);
HXDLIN( 223)											int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN( 223)											xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            										}
            									}
HXDLIN( 223)									 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN( 223)									if ((cy > by1)) {
HXLINE( 223)										if ((cy > cy2)) {
HXLINE( 223)											int min6;
HXDLIN( 223)											if ((by1 > cy2)) {
HXLINE( 223)												min6 = ::Math_obj::floor(cy2);
            											}
            											else {
HXLINE( 223)												min6 = ::Math_obj::floor(by1);
            											}
HXDLIN( 223)											int ii_min12 = min6;
HXDLIN( 223)											int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN( 223)											yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            										}
            										else {
HXLINE( 223)											int ii_min13 = ::Math_obj::floor(by1);
HXDLIN( 223)											int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN( 223)											yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            										}
            									}
            									else {
HXLINE( 223)										if ((by1 > cy2)) {
HXLINE( 223)											int min7;
HXDLIN( 223)											if ((cy > cy2)) {
HXLINE( 223)												min7 = ::Math_obj::floor(cy2);
            											}
            											else {
HXLINE( 223)												min7 = ::Math_obj::ceil(cy);
            											}
HXDLIN( 223)											int ii_min14 = min7;
HXDLIN( 223)											int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN( 223)											yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            										}
            										else {
HXLINE( 223)											int ii_min15 = ::Math_obj::floor(cy);
HXDLIN( 223)											int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN( 223)											yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            										}
            									}
HXDLIN( 223)									 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN( 223)									if (hasUndo1) {
HXLINE( 223)										int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN( 223)										int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN( 223)										 ::Dynamic imageType1 = null();
HXDLIN( 223)										 ::pi_xy::ImageStruct this38 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN( 223)										if (::hx::IsNull( imageType1 )) {
HXLINE(  54)											imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            										}
HXLINE( 223)										::Dynamic undoImage4;
HXDLIN( 223)										switch((int)(( (int)(imageType1) ))){
            											case (int)0: {
HXLINE( 223)												 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN( 223)												 ::iterMagic::BytesImg b5 = byt1;
HXDLIN( 223)												{
HXLINE( 223)													b5->width = width1;
HXDLIN( 223)													b5->height = height1;
HXDLIN( 223)													b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 223)													b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN( 223)													{
HXLINE( 223)														int len2 = b5->length;
HXDLIN( 223)														int w1 = 0;
HXDLIN( 223)														{
HXLINE( 223)															int _g24 = 0;
HXDLIN( 223)															int _g25 = b5->height;
HXDLIN( 223)															while((_g24 < _g25)){
HXLINE( 223)																_g24 = (_g24 + 1);
HXDLIN( 223)																int y5 = (_g24 - 1);
HXDLIN( 223)																{
HXLINE( 223)																	int _g26 = 0;
HXDLIN( 223)																	int _g27 = b5->width;
HXDLIN( 223)																	while((_g26 < _g27)){
HXLINE( 223)																		_g26 = (_g26 + 1);
HXDLIN( 223)																		int x5 = (_g26 - 1);
HXDLIN( 223)																		{
HXLINE( 223)																			w1 = (w1 + 1);
HXDLIN( 223)																			b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 223)																		{
HXLINE( 223)																			w1 = (w1 + 1);
HXDLIN( 223)																			b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 223)																		{
HXLINE( 223)																			w1 = (w1 + 1);
HXDLIN( 223)																			b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																		}
HXDLIN( 223)																		{
HXLINE( 223)																			w1 = (w1 + 1);
HXDLIN( 223)																			b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 223)												undoImage4 = b5;
            											}
            											break;
            											case (int)1: {
HXLINE( 223)												 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN( 223)												 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN( 223)												{
HXLINE( 223)													a6->width = width1;
HXDLIN( 223)													a6->height = height1;
HXDLIN( 223)													a6->data = ::Array_obj< int >::__new(0);
HXDLIN( 223)													a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 223)													{
HXLINE( 223)														int _g28 = 0;
HXDLIN( 223)														int _g29 = a6->length;
HXDLIN( 223)														while((_g28 < _g29)){
HXLINE( 223)															_g28 = (_g28 + 1);
HXDLIN( 223)															int i8 = (_g28 - 1);
HXDLIN( 223)															a6->data[i8] = 0;
            														}
            													}
            												}
HXDLIN( 223)												undoImage4 = a6;
            											}
            											break;
            											case (int)2: {
HXLINE( 223)												 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN( 223)												 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN( 223)												{
HXLINE( 223)													b6->width = width1;
HXDLIN( 223)													b6->height = height1;
HXDLIN( 223)													b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 223)													int size1 = (b6->length * 4);
HXDLIN( 223)													b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN( 223)													{
HXLINE( 223)														int _g30 = 0;
HXDLIN( 223)														int _g31 = b6->length;
HXDLIN( 223)														while((_g30 < _g31)){
HXLINE( 223)															_g30 = (_g30 + 1);
HXDLIN( 223)															int i9 = (_g30 - 1);
HXDLIN( 223)															{
HXLINE( 223)																 ::haxe::io::ArrayBufferViewImpl this39 = b6->data;
HXDLIN( 223)																bool undoImage5;
HXDLIN( 223)																if ((i9 >= 0)) {
HXLINE( 223)																	undoImage5 = (i9 < (this39->byteLength >> 2));
            																}
            																else {
HXLINE( 223)																	undoImage5 = false;
            																}
HXDLIN( 223)																if (undoImage5) {
HXLINE( 223)																	 ::haxe::io::Bytes _this1 = this39->bytes;
HXDLIN( 223)																	int pos1 = ((i9 << 2) + this39->byteOffset);
HXDLIN( 223)																	_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN( 223)																	_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN( 223)																	_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN( 223)																	_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
HXDLIN( 223)												undoImage4 = b6;
            											}
            											break;
            											case (int)3: {
HXLINE( 223)												 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN( 223)												 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN( 223)												{
HXLINE( 223)													v3->width = width1;
HXDLIN( 223)													v3->height = height1;
HXDLIN( 223)													v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 223)													v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN( 223)													{
HXLINE( 223)														int _g32 = 0;
HXDLIN( 223)														int _g33 = v3->length;
HXDLIN( 223)														while((_g32 < _g33)){
HXLINE( 223)															_g32 = (_g32 + 1);
HXDLIN( 223)															int i10 = (_g32 - 1);
HXDLIN( 223)															v3->data->__unsafe_set(i10,0);
            														}
            													}
            												}
HXDLIN( 223)												undoImage4 = v3;
            											}
            											break;
            											case (int)4: {
HXLINE( 223)												 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN( 223)												 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN( 223)												{
HXLINE( 223)													b7->width = width1;
HXDLIN( 223)													b7->height = height1;
HXDLIN( 223)													b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN( 223)													b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN( 223)													{
HXLINE( 223)														int len3 = b7->length;
HXDLIN( 223)														 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN( 223)														if (::hx::IsNull( d1->head )) {
HXLINE( 223)															int _g34 = 0;
HXDLIN( 223)															int _g35 = len3;
HXDLIN( 223)															while((_g34 < _g35)){
HXLINE( 223)																_g34 = (_g34 + 1);
HXDLIN( 223)																int i11 = (_g34 - 1);
HXDLIN( 223)																d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            															}
            														}
            														else {
HXLINE( 223)															int _g36 = 0;
HXDLIN( 223)															int _g37 = len3;
HXDLIN( 223)															while((_g36 < _g37)){
HXLINE( 223)																_g36 = (_g36 + 1);
HXDLIN( 223)																int i12 = (_g36 - 1);
HXDLIN( 223)																{
HXLINE( 223)																	 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN( 223)																	 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN( 223)																	{
HXLINE( 223)																		int _g38 = 0;
HXDLIN( 223)																		int _g39 = i12;
HXDLIN( 223)																		while((_g38 < _g39)){
HXLINE( 223)																			_g38 = (_g38 + 1);
HXDLIN( 223)																			int i13 = (_g38 - 1);
HXLINE( 345)																			prev1 = l1;
HXLINE( 346)																			l1 = l1->next;
            																		}
            																	}
HXLINE( 223)																	if (::hx::IsNull( prev1 )) {
HXLINE( 223)																		b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 223)																		l1 = null();
            																	}
            																	else {
HXLINE( 223)																		prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN( 223)																		l1 = null();
            																	}
            																}
            															}
            														}
            													}
            												}
HXDLIN( 223)												undoImage4 = b7;
            											}
            											break;
            										}
HXDLIN( 223)										this38->image = undoImage4;
HXDLIN( 223)										this38->width = width1;
HXDLIN( 223)										this38->height = height1;
HXDLIN( 223)										this38->imageType = ( (int)(imageType1) );
HXDLIN( 223)										undoImage3 = this38;
HXDLIN( 223)										{
HXLINE( 223)											int rectLeft1 = xIter31->start;
HXDLIN( 223)											int rectTop1 = yIter31->start;
HXDLIN( 223)											int rectRight1 = xIter31->max;
HXDLIN( 223)											bool forceClear1 = false;
HXDLIN( 223)											{
HXLINE( 223)												int _g40 = rectTop1;
HXDLIN( 223)												int _g41 = yIter31->max;
HXDLIN( 223)												while((_g40 < _g41)){
HXLINE( 223)													_g40 = (_g40 + 1);
HXDLIN( 223)													int dy1 = (_g40 - 1);
HXDLIN( 223)													{
HXLINE( 223)														int _g42 = rectLeft1;
HXDLIN( 223)														int _g43 = rectRight1;
HXDLIN( 223)														while((_g42 < _g43)){
HXLINE( 223)															_g42 = (_g42 + 1);
HXDLIN( 223)															int dx1 = (_g42 - 1);
HXDLIN( 223)															::Dynamic this40 = this37->image;
HXDLIN( 223)															int index6;
HXDLIN( 223)															if (this37->useVirtualPos) {
HXLINE( 223)																index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this37->virtualY) * ( (Float)(this37->width) )) + dx1) - this37->virtualX));
            															}
            															else {
HXLINE( 223)																index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this37->width) + dx1)) ));
            															}
HXDLIN( 223)															int c5 = ::iterMagic::Iimg_obj::get(this40,index6);
HXDLIN( 223)															int col1;
HXDLIN( 223)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 223)																col1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            															}
            															else {
HXLINE( 223)																col1 = c5;
            															}
HXDLIN( 223)															bool _hx_tmp8;
HXDLIN( 223)															if (this37->useMask) {
HXLINE( 223)																_hx_tmp8 = ::hx::IsNotNull( this37->mask );
            															}
            															else {
HXLINE( 223)																_hx_tmp8 = false;
            															}
HXDLIN( 223)															if (_hx_tmp8) {
HXLINE( 223)																 ::pi_xy::ImageStruct this41 = this37->mask;
HXDLIN( 223)																::Dynamic this42 = this41->image;
HXDLIN( 223)																int index7;
HXDLIN( 223)																if (this41->useVirtualPos) {
HXLINE( 223)																	index7 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this41->virtualY) * ( (Float)(this41->width) )) + dx1) - this41->virtualX));
            																}
            																else {
HXLINE( 223)																	index7 = ::Std_obj::_hx_int(( (Float)(((dy1 * this41->width) + dx1)) ));
            																}
HXDLIN( 223)																int c6 = ::iterMagic::Iimg_obj::get(this42,index7);
HXDLIN( 223)																int v4;
HXDLIN( 223)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 223)																	v4 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            																}
            																else {
HXLINE( 223)																	v4 = c6;
            																}
HXDLIN( 223)																int maskPixel1 = v4;
HXDLIN( 223)																int this43 = col1;
HXDLIN( 223)																if ((maskPixel1 == 0)) {
HXLINE( 223)																	col1 = this43;
            																}
            																else {
HXLINE( 223)																	Float m01;
HXDLIN( 223)																	int this44 = ((maskPixel1 >> 24) & 255);
HXDLIN( 223)																	if ((this44 == 0)) {
HXLINE( 223)																		m01 = ((Float)0.);
            																	}
            																	else {
HXLINE( 223)																		m01 = (( (Float)(this44) ) / ( (Float)(255) ));
            																	}
HXDLIN( 223)																	Float m11;
HXDLIN( 223)																	int this45 = ((maskPixel1 >> 16) & 255);
HXDLIN( 223)																	if ((this45 == 0)) {
HXLINE( 223)																		m11 = ((Float)0.);
            																	}
            																	else {
HXLINE( 223)																		m11 = (( (Float)(this45) ) / ( (Float)(255) ));
            																	}
HXDLIN( 223)																	Float m21;
HXDLIN( 223)																	int this46 = ((maskPixel1 >> 8) & 255);
HXDLIN( 223)																	if ((this46 == 0)) {
HXLINE( 223)																		m21 = ((Float)0.);
            																	}
            																	else {
HXLINE( 223)																		m21 = (( (Float)(this46) ) / ( (Float)(255) ));
            																	}
HXDLIN( 223)																	Float m31;
HXDLIN( 223)																	int this47 = (maskPixel1 & 255);
HXDLIN( 223)																	if ((this47 == 0)) {
HXLINE( 223)																		m31 = ((Float)0.);
            																	}
            																	else {
HXLINE( 223)																		m31 = (( (Float)(this47) ) / ( (Float)(255) ));
            																	}
HXDLIN( 223)																	int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this43 >> 24) & 255)) )));
HXDLIN( 223)																	int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this43 >> 16) & 255)) )));
HXDLIN( 223)																	int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this43 >> 8) & 255)) )));
HXDLIN( 223)																	int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this43 & 255)) )));
HXDLIN( 223)																	col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            																}
            															}
HXDLIN( 223)															if ((col1 != 0)) {
HXLINE( 223)																int x6 = (dx1 - rectLeft1);
HXDLIN( 223)																int y6 = (dy1 - rectTop1);
HXDLIN( 223)																int c7 = col1;
HXDLIN( 223)																bool _hx_tmp9;
HXDLIN( 223)																if ((((c7 >> 24) & 255) < 254)) {
HXLINE( 223)																	_hx_tmp9 = undoImage3->transparent;
            																}
            																else {
HXLINE( 223)																	_hx_tmp9 = false;
            																}
HXDLIN( 223)																if (_hx_tmp9) {
HXLINE( 223)																	int location2;
HXDLIN( 223)																	if (undoImage3->useVirtualPos) {
HXLINE( 223)																		location2 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            																	}
            																	else {
HXLINE( 223)																		location2 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            																	}
HXDLIN( 223)																	int this48 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN( 223)																	int this49;
HXDLIN( 223)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 223)																		this49 = ((((((this48 >> 24) & 255) << 24) | ((this48 & 255) << 16)) | (((this48 >> 8) & 255) << 8)) | ((this48 >> 16) & 255));
            																	}
            																	else {
HXLINE( 223)																		this49 = this48;
            																	}
HXDLIN( 223)																	Float a12;
HXDLIN( 223)																	int this50 = ((this49 >> 24) & 255);
HXDLIN( 223)																	if ((this50 == 0)) {
HXLINE( 223)																		a12 = ((Float)0.);
            																	}
            																	else {
HXLINE( 223)																		a12 = (( (Float)(this50) ) / ( (Float)(255) ));
            																	}
HXDLIN( 223)																	Float r12;
HXDLIN( 223)																	int this51 = ((this49 >> 16) & 255);
HXDLIN( 223)																	if ((this51 == 0)) {
HXLINE( 223)																		r12 = ((Float)0.);
            																	}
            																	else {
HXLINE( 223)																		r12 = (( (Float)(this51) ) / ( (Float)(255) ));
            																	}
HXDLIN( 223)																	Float g12;
HXDLIN( 223)																	int this52 = ((this49 >> 8) & 255);
HXDLIN( 223)																	if ((this52 == 0)) {
HXLINE( 223)																		g12 = ((Float)0.);
            																	}
            																	else {
HXLINE( 223)																		g12 = (( (Float)(this52) ) / ( (Float)(255) ));
            																	}
HXDLIN( 223)																	Float b13;
HXDLIN( 223)																	int this53 = (this49 & 255);
HXDLIN( 223)																	if ((this53 == 0)) {
HXLINE( 223)																		b13 = ((Float)0.);
            																	}
            																	else {
HXLINE( 223)																		b13 = (( (Float)(this53) ) / ( (Float)(255) ));
            																	}
HXDLIN( 223)																	Float a22;
HXDLIN( 223)																	int this54 = ((col1 >> 24) & 255);
HXDLIN( 223)																	if ((this54 == 0)) {
HXLINE( 223)																		a22 = ((Float)0.);
            																	}
            																	else {
HXLINE( 223)																		a22 = (( (Float)(this54) ) / ( (Float)(255) ));
            																	}
HXDLIN( 223)																	Float r22;
HXDLIN( 223)																	int this55 = ((col1 >> 16) & 255);
HXDLIN( 223)																	if ((this55 == 0)) {
HXLINE( 223)																		r22 = ((Float)0.);
            																	}
            																	else {
HXLINE( 223)																		r22 = (( (Float)(this55) ) / ( (Float)(255) ));
            																	}
HXDLIN( 223)																	Float g22;
HXDLIN( 223)																	int this56 = ((col1 >> 8) & 255);
HXDLIN( 223)																	if ((this56 == 0)) {
HXLINE( 223)																		g22 = ((Float)0.);
            																	}
            																	else {
HXLINE( 223)																		g22 = (( (Float)(this56) ) / ( (Float)(255) ));
            																	}
HXDLIN( 223)																	Float b23;
HXDLIN( 223)																	int this57 = (col1 & 255);
HXDLIN( 223)																	if ((this57 == 0)) {
HXLINE( 223)																		b23 = ((Float)0.);
            																	}
            																	else {
HXLINE( 223)																		b23 = (( (Float)(this57) ) / ( (Float)(255) ));
            																	}
HXDLIN( 223)																	Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN( 223)																	int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN( 223)																	int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN( 223)																	int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN( 223)																	int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN( 223)																	int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN( 223)																	{
HXLINE( 223)																		int _hx_tmp10;
HXDLIN( 223)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 223)																			_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																		}
            																		else {
HXLINE( 223)																			_hx_tmp10 = blended2;
            																		}
HXDLIN( 223)																		::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            																	}
            																}
            																else {
HXLINE( 223)																	::Dynamic this58 = undoImage3->image;
HXDLIN( 223)																	int index8;
HXDLIN( 223)																	if (undoImage3->useVirtualPos) {
HXLINE( 223)																		index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            																	}
            																	else {
HXLINE( 223)																		index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            																	}
HXDLIN( 223)																	int _hx_tmp11;
HXDLIN( 223)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 223)																		_hx_tmp11 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            																	}
            																	else {
HXLINE( 223)																		_hx_tmp11 = c7;
            																	}
HXDLIN( 223)																	::iterMagic::Iimg_obj::set(this58,index8,_hx_tmp11);
            																}
            															}
            															else {
HXLINE( 223)																if (forceClear1) {
HXLINE( 223)																	::Dynamic this59 = undoImage3->image;
HXDLIN( 223)																	int x7 = (dx1 - rectLeft1);
HXDLIN( 223)																	int y7 = (dy1 - rectTop1);
HXDLIN( 223)																	int index9;
HXDLIN( 223)																	if (undoImage3->useVirtualPos) {
HXLINE( 223)																		index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x7) - undoImage3->virtualX));
            																	}
            																	else {
HXLINE( 223)																		index9 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage3->width) + x7)) ));
            																	}
HXDLIN( 223)																	::iterMagic::Iimg_obj::set(this59,index9,0);
            																}
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN( 223)									bool foundY1 = false;
HXDLIN( 223)									Float s1 = ((Float)0.);
HXDLIN( 223)									Float t1 = ((Float)0.);
HXDLIN( 223)									Float sxx1 = ((Float)0.);
HXDLIN( 223)									Float txx1 = ((Float)0.);
HXDLIN( 223)									{
HXLINE( 223)										int _g_min2 = xIter31->start;
HXDLIN( 223)										int _g_max2 = xIter31->max;
HXDLIN( 223)										while((_g_min2 < _g_max2)){
HXLINE( 223)											_g_min2 = (_g_min2 + 1);
HXDLIN( 223)											int x8 = (_g_min2 - 1);
HXLINE( 222)											sxx1 = (sx1 * ( (Float)(x8) ));
HXLINE( 223)											txx1 = (tx1 * ( (Float)(x8) ));
HXLINE( 224)											foundY1 = false;
HXLINE( 223)											{
HXLINE( 223)												int _g_min3 = yIter31->start;
HXDLIN( 223)												int _g_max3 = yIter31->max;
HXDLIN( 223)												while((_g_min3 < _g_max3)){
HXLINE( 223)													_g_min3 = (_g_min3 + 1);
HXDLIN( 223)													int y8 = (_g_min3 - 1);
HXLINE( 226)													s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y8) )));
HXLINE( 227)													t1 = ((t01 + txx1) + (ty1 * ( (Float)(y8) )));
HXLINE( 223)													bool _hx_tmp12;
HXDLIN( 223)													if (!((s1 <= 0))) {
HXLINE( 223)														_hx_tmp12 = (t1 <= 0);
            													}
            													else {
HXLINE( 223)														_hx_tmp12 = true;
            													}
HXDLIN( 223)													if (_hx_tmp12) {
HXLINE( 223)														if (foundY1) {
HXLINE( 223)															goto _hx_goto_327;
            														}
            													}
            													else {
HXLINE( 223)														if (((s1 + t1) < A1)) {
HXLINE( 223)															int x9 = ::hx::Mod(x8,tileImage->width);
HXDLIN( 223)															int y9 = ::hx::Mod(y8,tileImage->height);
HXDLIN( 223)															::Dynamic this60 = tileImage->image;
HXDLIN( 223)															int index10;
HXDLIN( 223)															if (tileImage->useVirtualPos) {
HXLINE( 223)																index10 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x9) - tileImage->virtualX));
            															}
            															else {
HXLINE( 223)																index10 = ::Std_obj::_hx_int(( (Float)(((y9 * tileImage->width) + x9)) ));
            															}
HXDLIN( 223)															int c8 = ::iterMagic::Iimg_obj::get(this60,index10);
HXDLIN( 223)															int color1;
HXDLIN( 223)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 223)																color1 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            															}
            															else {
HXLINE( 223)																color1 = c8;
            															}
HXDLIN( 223)															{
HXLINE( 223)																int c9 = color1;
HXDLIN( 223)																bool _hx_tmp13;
HXDLIN( 223)																if ((((c9 >> 24) & 255) < 254)) {
HXLINE( 223)																	_hx_tmp13 = this37->transparent;
            																}
            																else {
HXLINE( 223)																	_hx_tmp13 = false;
            																}
HXDLIN( 223)																if (_hx_tmp13) {
HXLINE( 223)																	int location3;
HXDLIN( 223)																	if (this37->useVirtualPos) {
HXLINE( 223)																		location3 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - this37->virtualY) * ( (Float)(this37->width) )) + x8) - this37->virtualX));
            																	}
            																	else {
HXLINE( 223)																		location3 = ::Std_obj::_hx_int(( (Float)(((y8 * this37->width) + x8)) ));
            																	}
HXDLIN( 223)																	int this61 = ::iterMagic::Iimg_obj::get(this37->image,location3);
HXDLIN( 223)																	int this62;
HXDLIN( 223)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 223)																		this62 = ((((((this61 >> 24) & 255) << 24) | ((this61 & 255) << 16)) | (((this61 >> 8) & 255) << 8)) | ((this61 >> 16) & 255));
            																	}
            																	else {
HXLINE( 223)																		this62 = this61;
            																	}
HXDLIN( 223)																	Float a13;
HXDLIN( 223)																	int this63 = ((this62 >> 24) & 255);
HXDLIN( 223)																	if ((this63 == 0)) {
HXLINE( 223)																		a13 = ((Float)0.);
            																	}
            																	else {
HXLINE( 223)																		a13 = (( (Float)(this63) ) / ( (Float)(255) ));
            																	}
HXDLIN( 223)																	Float r13;
HXDLIN( 223)																	int this64 = ((this62 >> 16) & 255);
HXDLIN( 223)																	if ((this64 == 0)) {
HXLINE( 223)																		r13 = ((Float)0.);
            																	}
            																	else {
HXLINE( 223)																		r13 = (( (Float)(this64) ) / ( (Float)(255) ));
            																	}
HXDLIN( 223)																	Float g13;
HXDLIN( 223)																	int this65 = ((this62 >> 8) & 255);
HXDLIN( 223)																	if ((this65 == 0)) {
HXLINE( 223)																		g13 = ((Float)0.);
            																	}
            																	else {
HXLINE( 223)																		g13 = (( (Float)(this65) ) / ( (Float)(255) ));
            																	}
HXDLIN( 223)																	Float b14;
HXDLIN( 223)																	int this66 = (this62 & 255);
HXDLIN( 223)																	if ((this66 == 0)) {
HXLINE( 223)																		b14 = ((Float)0.);
            																	}
            																	else {
HXLINE( 223)																		b14 = (( (Float)(this66) ) / ( (Float)(255) ));
            																	}
HXDLIN( 223)																	Float a23;
HXDLIN( 223)																	int this67 = ((color1 >> 24) & 255);
HXDLIN( 223)																	if ((this67 == 0)) {
HXLINE( 223)																		a23 = ((Float)0.);
            																	}
            																	else {
HXLINE( 223)																		a23 = (( (Float)(this67) ) / ( (Float)(255) ));
            																	}
HXDLIN( 223)																	Float r23;
HXDLIN( 223)																	int this68 = ((color1 >> 16) & 255);
HXDLIN( 223)																	if ((this68 == 0)) {
HXLINE( 223)																		r23 = ((Float)0.);
            																	}
            																	else {
HXLINE( 223)																		r23 = (( (Float)(this68) ) / ( (Float)(255) ));
            																	}
HXDLIN( 223)																	Float g23;
HXDLIN( 223)																	int this69 = ((color1 >> 8) & 255);
HXDLIN( 223)																	if ((this69 == 0)) {
HXLINE( 223)																		g23 = ((Float)0.);
            																	}
            																	else {
HXLINE( 223)																		g23 = (( (Float)(this69) ) / ( (Float)(255) ));
            																	}
HXDLIN( 223)																	Float b24;
HXDLIN( 223)																	int this70 = (color1 & 255);
HXDLIN( 223)																	if ((this70 == 0)) {
HXLINE( 223)																		b24 = ((Float)0.);
            																	}
            																	else {
HXLINE( 223)																		b24 = (( (Float)(this70) ) / ( (Float)(255) ));
            																	}
HXDLIN( 223)																	Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN( 223)																	int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN( 223)																	int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN( 223)																	int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN( 223)																	int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN( 223)																	int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN( 223)																	{
HXLINE( 223)																		int _hx_tmp14;
HXDLIN( 223)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 223)																			_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																		}
            																		else {
HXLINE( 223)																			_hx_tmp14 = blended3;
            																		}
HXDLIN( 223)																		::iterMagic::Iimg_obj::set(this37->image,location3,_hx_tmp14);
            																	}
            																}
            																else {
HXLINE( 223)																	::Dynamic this71 = this37->image;
HXDLIN( 223)																	int index11;
HXDLIN( 223)																	if (this37->useVirtualPos) {
HXLINE( 223)																		index11 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - this37->virtualY) * ( (Float)(this37->width) )) + x8) - this37->virtualX));
            																	}
            																	else {
HXLINE( 223)																		index11 = ::Std_obj::_hx_int(( (Float)(((y8 * this37->width) + x8)) ));
            																	}
HXDLIN( 223)																	int _hx_tmp15;
HXDLIN( 223)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE( 223)																		_hx_tmp15 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            																	}
            																	else {
HXLINE( 223)																		_hx_tmp15 = c9;
            																	}
HXDLIN( 223)																	::iterMagic::Iimg_obj::set(this71,index11,_hx_tmp15);
            																}
            															}
HXLINE( 236)															foundY1 = true;
            														}
            														else {
HXLINE( 223)															if (foundY1) {
HXLINE( 223)																goto _hx_goto_327;
            															}
            														}
            													}
            												}
            												_hx_goto_327:;
            											}
            										}
            									}
HXDLIN( 223)									if ((hasHit1 == false)) {
HXLINE( 223)										 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN( 223)										if (hasUndo1) {
HXLINE( 223)											v5->undoImage = undoImage3;
HXDLIN( 223)											v5->undoX = xIter31->start;
HXDLIN( 223)											v5->undoY = yIter31->start;
            										}
            									}
            								}
            							}
            						}
HXLINE( 177)						lastX = nextX1;
HXLINE( 178)						lastY = nextY1;
            					}
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(TileShape_Impl__obj,ellipseTri,(void))


TileShape_Impl__obj::TileShape_Impl__obj()
{
}

bool TileShape_Impl__obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"pie") ) { outValue = pie_dyn(); return true; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"_new") ) { outValue = _new_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"quad") ) { outValue = quad_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"line") ) { outValue = line_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"triangle") ) { outValue = triangle_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"quadrant") ) { outValue = quadrant_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"sweepTri") ) { outValue = sweepTri_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"rectangle") ) { outValue = rectangle_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"PolyBuild") ) { outValue = PolyBuild_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"quadrantI") ) { outValue = quadrantI_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"quadrantII") ) { outValue = quadrantII_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"quadrantIV") ) { outValue = quadrantIV_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"ellipseTri") ) { outValue = ellipseTri_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"quadrantIII") ) { outValue = quadrantIII_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *TileShape_Impl__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *TileShape_Impl__obj_sStaticStorageInfo = 0;
#endif

::hx::Class TileShape_Impl__obj::__mClass;

static ::String TileShape_Impl__obj_sStaticFields[] = {
	HX_("_new",61,15,1f,3f),
	HX_("triangle",c8,be,c5,8d),
	HX_("quad",c7,38,0a,4b),
	HX_("rectangle",2f,d4,7c,19),
	HX_("line",f4,17,b3,47),
	HX_("PolyBuild",22,59,a5,f2),
	HX_("quadrant",fc,f5,e7,e8),
	HX_("quadrantI",cd,46,0f,e2),
	HX_("quadrantII",dc,ac,4e,eb),
	HX_("quadrantIII",ed,93,88,f9),
	HX_("quadrantIV",e9,ac,4e,eb),
	HX_("sweepTri",9f,86,ef,d9),
	HX_("pie",4c,58,55,00),
	HX_("ellipseTri",ed,3e,df,4c),
	::String(null())
};

void TileShape_Impl__obj::__register()
{
	TileShape_Impl__obj _hx_dummy;
	TileShape_Impl__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pi_xy.imageAbstracts._TileShape.TileShape_Impl_",aa,04,c9,1d);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &TileShape_Impl__obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(TileShape_Impl__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< TileShape_Impl__obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = TileShape_Impl__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = TileShape_Impl__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pi_xy
} // end namespace imageAbstracts
} // end namespace _TileShape
