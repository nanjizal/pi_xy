// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_nme_utils_ByteArray
#include <nme/utils/ByteArray.h>
#endif
#ifndef INCLUDED_nme_utils_Float32Buffer
#include <nme/utils/Float32Buffer.h>
#endif
#ifndef INCLUDED_nme_utils_IDataInput
#include <nme/utils/IDataInput.h>
#endif
#ifndef INCLUDED_nme_utils_IDataOutput
#include <nme/utils/IDataOutput.h>
#endif
#ifndef INCLUDED_nme_utils_IMemoryRange
#include <nme/utils/IMemoryRange.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_893ef48ddcc48d10_22_new,"nme.utils.Float32Buffer","new",0xdd466048,"nme.utils.Float32Buffer.new","nme/utils/Float32Buffer.hx",22,0x155cdaea)
HX_LOCAL_STACK_FRAME(_hx_pos_893ef48ddcc48d10_51_resize,"nme.utils.Float32Buffer","resize",0x6da5ab0c,"nme.utils.Float32Buffer.resize","nme/utils/Float32Buffer.hx",51,0x155cdaea)
HX_LOCAL_STACK_FRAME(_hx_pos_893ef48ddcc48d10_75_setF32,"nme.utils.Float32Buffer","setF32",0xd48f711b,"nme.utils.Float32Buffer.setF32","nme/utils/Float32Buffer.hx",75,0x155cdaea)
HX_LOCAL_STACK_FRAME(_hx_pos_893ef48ddcc48d10_110_getF32,"nme.utils.Float32Buffer","getF32",0x08471ca7,"nme.utils.Float32Buffer.getF32","nme/utils/Float32Buffer.hx",110,0x155cdaea)
HX_LOCAL_STACK_FRAME(_hx_pos_893ef48ddcc48d10_128_setF32q,"nme.utils.Float32Buffer","setF32q",0x28f386f6,"nme.utils.Float32Buffer.setF32q","nme/utils/Float32Buffer.hx",128,0x155cdaea)
namespace nme{
namespace utils{

void Float32Buffer_obj::__construct(::hx::Null< int >  __o_inCount,::hx::Null< bool >  __o_inWriteOnly){
            		int inCount = __o_inCount.Default(0);
            		bool inWriteOnly = __o_inWriteOnly.Default(false);
            	HX_STACKFRAME(&_hx_pos_893ef48ddcc48d10_22_new)
HXLINE(  23)		this->count = inCount;
HXLINE(  24)		int _hx_tmp;
HXDLIN(  24)		if ((this->count < 4)) {
HXLINE(  24)			_hx_tmp = 16;
            		}
            		else {
HXLINE(  24)			_hx_tmp = (this->count << 2);
            		}
HXDLIN(  24)		super::__construct(_hx_tmp,inWriteOnly);
            	}

Dynamic Float32Buffer_obj::__CreateEmpty() { return new Float32Buffer_obj; }

void *Float32Buffer_obj::_hx_vtable = 0;

Dynamic Float32Buffer_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Float32Buffer_obj > _hx_result = new Float32Buffer_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool Float32Buffer_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x195c64b7) {
		if (inClassId<=(int)0x0cbcdce2) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x0cbcdce2;
		} else {
			return inClassId==(int)0x195c64b7;
		}
	} else {
		return inClassId==(int)0x4c5abe70;
	}
}

void Float32Buffer_obj::resize(int inSize){
            	HX_STACKFRAME(&_hx_pos_893ef48ddcc48d10_51_resize)
HXLINE(  52)		this->count = inSize;
HXLINE(  53)		this->setByteSize(((this->count = inSize) << 2));
            	}


HX_DEFINE_DYNAMIC_FUNC1(Float32Buffer_obj,resize,(void))

void Float32Buffer_obj::setF32(int index,Float val){
            	HX_STACKFRAME(&_hx_pos_893ef48ddcc48d10_75_setF32)
HXLINE(  85)		int bpos = (index << 2);
HXLINE(  86)		if ((index >= this->count)) {
HXLINE(  88)			this->count = (index + 1);
HXLINE(  89)			this->ensureElem((bpos + 3),true);
            		}
HXLINE(  94)		__hxcpp_memory_set_float(this->b,bpos,val);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Float32Buffer_obj,setF32,(void))

Float Float32Buffer_obj::getF32(int index){
            	HX_STACKFRAME(&_hx_pos_893ef48ddcc48d10_110_getF32)
HXDLIN( 110)		return __hxcpp_memory_get_float(this->b,(index << 2));
            	}


HX_DEFINE_DYNAMIC_FUNC1(Float32Buffer_obj,getF32,return )

void Float32Buffer_obj::setF32q(int index,Float val){
            	HX_STACKFRAME(&_hx_pos_893ef48ddcc48d10_128_setF32q)
HXDLIN( 128)		__hxcpp_memory_set_float(this->b,(index << 2),val);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Float32Buffer_obj,setF32q,(void))


::hx::ObjectPtr< Float32Buffer_obj > Float32Buffer_obj::__new(::hx::Null< int >  __o_inCount,::hx::Null< bool >  __o_inWriteOnly) {
	::hx::ObjectPtr< Float32Buffer_obj > __this = new Float32Buffer_obj();
	__this->__construct(__o_inCount,__o_inWriteOnly);
	return __this;
}

::hx::ObjectPtr< Float32Buffer_obj > Float32Buffer_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< int >  __o_inCount,::hx::Null< bool >  __o_inWriteOnly) {
	Float32Buffer_obj *__this = (Float32Buffer_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Float32Buffer_obj), true, "nme.utils.Float32Buffer"));
	*(void **)__this = Float32Buffer_obj::_hx_vtable;
	__this->__construct(__o_inCount,__o_inWriteOnly);
	return __this;
}

Float32Buffer_obj::Float32Buffer_obj()
{
}

::hx::Val Float32Buffer_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"count") ) { return ::hx::Val( count ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"resize") ) { return ::hx::Val( resize_dyn() ); }
		if (HX_FIELD_EQ(inName,"setF32") ) { return ::hx::Val( setF32_dyn() ); }
		if (HX_FIELD_EQ(inName,"getF32") ) { return ::hx::Val( getF32_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"setF32q") ) { return ::hx::Val( setF32q_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val Float32Buffer_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"count") ) { count=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Float32Buffer_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("count",cf,44,63,4a));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Float32Buffer_obj_sMemberStorageInfo[] = {
	{::hx::fsInt,(int)offsetof(Float32Buffer_obj,count),HX_("count",cf,44,63,4a)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Float32Buffer_obj_sStaticStorageInfo = 0;
#endif

static ::String Float32Buffer_obj_sMemberFields[] = {
	HX_("count",cf,44,63,4a),
	HX_("resize",f4,59,7b,08),
	HX_("setF32",03,20,65,6f),
	HX_("getF32",8f,cb,1c,a3),
	HX_("setF32q",0e,e3,16,09),
	::String(null()) };

::hx::Class Float32Buffer_obj::__mClass;

void Float32Buffer_obj::__register()
{
	Float32Buffer_obj _hx_dummy;
	Float32Buffer_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("nme.utils.Float32Buffer",56,dc,76,1f);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Float32Buffer_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Float32Buffer_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Float32Buffer_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Float32Buffer_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace nme
} // end namespace utils
