// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_Sys
#include <Sys.h>
#endif
#ifndef INCLUDED_format_png_Reader
#include <format/png/Reader.h>
#endif
#ifndef INCLUDED_format_png_Tools
#include <format/png/Tools.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericCell_Int
#include <haxe/ds/GenericCell_Int.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericStack_Int
#include <haxe/ds/GenericStack_Int.h>
#endif
#ifndef INCLUDED_haxe_ds_List
#include <haxe/ds/List.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_haxe_io_Input
#include <haxe/io/Input.h>
#endif
#ifndef INCLUDED_haxe_io_Path
#include <haxe/io/Path.h>
#endif
#ifndef INCLUDED_iterMagic_ArrIntImg
#include <iterMagic/ArrIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_BytesImg
#include <iterMagic/BytesImg.h>
#endif
#ifndef INCLUDED_iterMagic_Iimg
#include <iterMagic/Iimg.h>
#endif
#ifndef INCLUDED_iterMagic_StackIntImg
#include <iterMagic/StackIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_U32ArrImg
#include <iterMagic/U32ArrImg.h>
#endif
#ifndef INCLUDED_iterMagic_VecIntImg
#include <iterMagic/VecIntImg.h>
#endif
#ifndef INCLUDED_pi_xy_ByteAccessor
#include <pi_xy/ByteAccessor.h>
#endif
#ifndef INCLUDED_pi_xy_ImageStruct
#include <pi_xy/ImageStruct.h>
#endif
#ifndef INCLUDED_pi_xy__Endian_Endian_Fields_
#include <pi_xy/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitQuad
#include <pi_xy/algo/HitQuad.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitTri
#include <pi_xy/algo/HitTri.h>
#endif
#ifndef INCLUDED_pi_xy_algo_IhitObj
#include <pi_xy/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pi_xy_algo_QuadPoints_
#include <pi_xy/algo/QuadPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_TriPoints_
#include <pi_xy/algo/TriPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_iter_IntIterStart
#include <pi_xy/iter/IntIterStart.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_NineSlicePicture
#include <pi_xy/triangleGML/NineSlicePicture.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_triGML_BasicShape
#include <pi_xy/triangleGML/triGML/BasicShape.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_triGML_FillForm
#include <pi_xy/triangleGML/triGML/FillForm.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_triGML_GroupShape
#include <pi_xy/triangleGML/triGML/GroupShape.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_triGML_ShapeInterface
#include <pi_xy/triangleGML/triGML/ShapeInterface.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_triGML_shape_picture_NineSlicePicture_
#include <pi_xy/triangleGML/triGML/shape/picture/NineSlicePicture_.h>
#endif
#ifndef INCLUDED_sys_io_File
#include <sys/io/File.h>
#endif
#ifndef INCLUDED_sys_io_FileInput
#include <sys/io/FileInput.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_c19e8e9a0f2b0013_9_new,"pi_xy.triangleGML.NineSlicePicture","new",0x2aadb747,"pi_xy.triangleGML.NineSlicePicture.new","pi_xy/triangleGML/NineSlicePicture.hx",9,0x4dc049c7)
HX_LOCAL_STACK_FRAME(_hx_pos_c19e8e9a0f2b0013_14_setParameter,"pi_xy.triangleGML.NineSlicePicture","setParameter",0x1a6b79e0,"pi_xy.triangleGML.NineSlicePicture.setParameter","pi_xy/triangleGML/NineSlicePicture.hx",14,0x4dc049c7)
HX_LOCAL_STACK_FRAME(_hx_pos_c19e8e9a0f2b0013_25_render,"pi_xy.triangleGML.NineSlicePicture","render",0xb8338ecf,"pi_xy.triangleGML.NineSlicePicture.render","pi_xy/triangleGML/NineSlicePicture.hx",25,0x4dc049c7)
HX_LOCAL_STACK_FRAME(_hx_pos_c19e8e9a0f2b0013_44_setImage,"pi_xy.triangleGML.NineSlicePicture","setImage",0xf0123c12,"pi_xy.triangleGML.NineSlicePicture.setImage","pi_xy/triangleGML/NineSlicePicture.hx",44,0x4dc049c7)
namespace pi_xy{
namespace triangleGML{

void NineSlicePicture_obj::__construct( ::Dynamic opacity, ::Dynamic visibility, ::Dynamic strokeColor, ::Dynamic strokeWidth,::Array< ::String > strokeDashGapArray, ::Dynamic fill, ::Dynamic left, ::Dynamic top, ::Dynamic initWid, ::Dynamic initHi, ::Dynamic initLeft, ::Dynamic initTop, ::Dynamic initFat, ::Dynamic initTall, ::Dynamic newWid, ::Dynamic newHi, ::Dynamic newLeft, ::Dynamic newTop, ::Dynamic newFat, ::Dynamic newTall, ::pi_xy::ImageStruct imageTexture, ::Dynamic pictureX, ::Dynamic pictureY, ::Dynamic pictureWidth, ::Dynamic pictureHeight, ::Dynamic rounded){
            	HX_STACKFRAME(&_hx_pos_c19e8e9a0f2b0013_9_new)
HXDLIN(   9)		super::__construct(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,initWid,initHi,initLeft,initTop,initFat,initTall,newWid,newHi,newLeft,newTop,newFat,newTall,imageTexture,pictureX,pictureY,pictureWidth,pictureHeight,rounded);
            	}

Dynamic NineSlicePicture_obj::__CreateEmpty() { return new NineSlicePicture_obj; }

void *NineSlicePicture_obj::_hx_vtable = 0;

Dynamic NineSlicePicture_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< NineSlicePicture_obj > _hx_result = new NineSlicePicture_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7],inArgs[8],inArgs[9],inArgs[10],inArgs[11],inArgs[12],inArgs[13],inArgs[14],inArgs[15],inArgs[16],inArgs[17],inArgs[18],inArgs[19],inArgs[20],inArgs[21],inArgs[22],inArgs[23],inArgs[24],inArgs[25]);
	return _hx_result;
}

bool NineSlicePicture_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x4f186619) {
		if (inClassId<=(int)0x31a200bd) {
			if (inClassId<=(int)0x1a0bd5c0) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x1a0bd5c0;
			} else {
				return inClassId==(int)0x31a200bd;
			}
		} else {
			return inClassId==(int)0x4f186619;
		}
	} else {
		return inClassId==(int)0x79ec058e || inClassId==(int)0x7ff8cec5;
	}
}

void NineSlicePicture_obj::setParameter(::String name,::String value){
            	HX_GC_STACKFRAME(&_hx_pos_c19e8e9a0f2b0013_14_setParameter)
HXDLIN(  14)		if ((name == HX_("srcPicture",3a,16,56,b7))) {
HXLINE(  16)			::String name1 = value;
HXDLIN(  16)			if ((name1.substr(-4,1) == HX_(".",2e,00,00,00))) {
HXLINE(  16)				name1 = name1.substr(0,-4);
            			}
HXDLIN(  16)			 ::format::png::Reader reader =  ::format::png::Reader_obj::__alloc( HX_CTX ,::sys::io::File_obj::read(::haxe::io::Path_obj::join(::Array_obj< ::String >::__new(2)->init(0,::haxe::io::Path_obj::directory(::Sys_obj::programPath()))->init(1,(name1 + HX_(".png",3b,2d,bd,1e)))),true));
HXDLIN(  16)			 ::haxe::ds::List data = reader->read();
HXDLIN(  16)			 ::Dynamic header = ::format::png::Tools_obj::getHeader(data);
HXDLIN(  16)			 ::haxe::io::Bytes bytes = ::format::png::Tools_obj::extract32(data,null(),null());
HXDLIN(  16)			 ::haxe::io::Bytes bytesCameleon = bytes;
HXDLIN(  16)			int width = ( (int)(header->__Field(HX_("width",06,b6,62,ca),::hx::paccDynamic)) );
HXDLIN(  16)			int height = ( (int)(header->__Field(HX_("height",e7,07,4c,02),::hx::paccDynamic)) );
HXDLIN(  16)			 ::Dynamic imageType = null();
HXDLIN(  16)			 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  16)			if (::hx::IsNull( imageType )) {
HXLINE(  16)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXDLIN(  16)			::Dynamic _hx_tmp;
HXDLIN(  16)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXLINE(  16)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  16)					 ::iterMagic::BytesImg b = byt;
HXDLIN(  16)					{
HXLINE(  16)						b->width = width;
HXDLIN(  16)						b->height = height;
HXDLIN(  16)						b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  16)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  16)						{
HXLINE(  16)							int len = b->length;
HXDLIN(  16)							int w = 0;
HXDLIN(  16)							{
HXLINE(  16)								int _g = 0;
HXDLIN(  16)								int _g1 = b->height;
HXDLIN(  16)								while((_g < _g1)){
HXLINE(  16)									_g = (_g + 1);
HXDLIN(  16)									int y = (_g - 1);
HXDLIN(  16)									{
HXLINE(  16)										int _g2 = 0;
HXDLIN(  16)										int _g3 = b->width;
HXDLIN(  16)										while((_g2 < _g3)){
HXLINE(  16)											_g2 = (_g2 + 1);
HXDLIN(  16)											int x = (_g2 - 1);
HXDLIN(  16)											{
HXLINE(  16)												w = (w + 1);
HXDLIN(  16)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  16)											{
HXLINE(  16)												w = (w + 1);
HXDLIN(  16)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  16)											{
HXLINE(  16)												w = (w + 1);
HXDLIN(  16)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  16)											{
HXLINE(  16)												w = (w + 1);
HXDLIN(  16)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  16)					_hx_tmp = b;
            				}
            				break;
            				case (int)1: {
HXLINE(  16)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  16)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  16)					{
HXLINE(  16)						a->width = width;
HXDLIN(  16)						a->height = height;
HXDLIN(  16)						a->data = ::Array_obj< int >::__new(0);
HXDLIN(  16)						a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  16)						{
HXLINE(  16)							int _g4 = 0;
HXDLIN(  16)							int _g5 = a->length;
HXDLIN(  16)							while((_g4 < _g5)){
HXLINE(  16)								_g4 = (_g4 + 1);
HXDLIN(  16)								int i = (_g4 - 1);
HXDLIN(  16)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN(  16)					_hx_tmp = a;
            				}
            				break;
            				case (int)2: {
HXLINE(  16)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  16)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  16)					{
HXLINE(  16)						b1->width = width;
HXDLIN(  16)						b1->height = height;
HXDLIN(  16)						b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  16)						int size = (b1->length * 4);
HXDLIN(  16)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  16)						{
HXLINE(  16)							int _g6 = 0;
HXDLIN(  16)							int _g7 = b1->length;
HXDLIN(  16)							while((_g6 < _g7)){
HXLINE(  16)								_g6 = (_g6 + 1);
HXDLIN(  16)								int i1 = (_g6 - 1);
HXDLIN(  16)								{
HXLINE(  16)									 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN(  16)									bool _hx_tmp1;
HXDLIN(  16)									if ((i1 >= 0)) {
HXLINE(  16)										_hx_tmp1 = (i1 < (this2->byteLength >> 2));
            									}
            									else {
HXLINE(  16)										_hx_tmp1 = false;
            									}
HXDLIN(  16)									if (_hx_tmp1) {
HXLINE(  16)										 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  16)										int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN(  16)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  16)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  16)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  16)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN(  16)					_hx_tmp = b1;
            				}
            				break;
            				case (int)3: {
HXLINE(  16)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  16)					 ::iterMagic::VecIntImg v = vec;
HXDLIN(  16)					{
HXLINE(  16)						v->width = width;
HXDLIN(  16)						v->height = height;
HXDLIN(  16)						v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  16)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  16)						{
HXLINE(  16)							int _g8 = 0;
HXDLIN(  16)							int _g9 = v->length;
HXDLIN(  16)							while((_g8 < _g9)){
HXLINE(  16)								_g8 = (_g8 + 1);
HXDLIN(  16)								int i2 = (_g8 - 1);
HXDLIN(  16)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN(  16)					_hx_tmp = v;
            				}
            				break;
            				case (int)4: {
HXLINE(  16)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  16)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  16)					{
HXLINE(  16)						b2->width = width;
HXDLIN(  16)						b2->height = height;
HXDLIN(  16)						b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  16)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  16)						{
HXLINE(  16)							int len1 = b2->length;
HXDLIN(  16)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  16)							if (::hx::IsNull( d->head )) {
HXLINE(  16)								int _g10 = 0;
HXDLIN(  16)								int _g11 = len1;
HXDLIN(  16)								while((_g10 < _g11)){
HXLINE(  16)									_g10 = (_g10 + 1);
HXDLIN(  16)									int i3 = (_g10 - 1);
HXDLIN(  16)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXLINE(  16)								int _g12 = 0;
HXDLIN(  16)								int _g13 = len1;
HXDLIN(  16)								while((_g12 < _g13)){
HXLINE(  16)									_g12 = (_g12 + 1);
HXDLIN(  16)									int i4 = (_g12 - 1);
HXDLIN(  16)									{
HXLINE(  16)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  16)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  16)										{
HXLINE(  16)											int _g14 = 0;
HXDLIN(  16)											int _g15 = i4;
HXDLIN(  16)											while((_g14 < _g15)){
HXLINE(  16)												_g14 = (_g14 + 1);
HXDLIN(  16)												int i5 = (_g14 - 1);
HXDLIN(  16)												prev = l;
HXDLIN(  16)												l = l->next;
            											}
            										}
HXDLIN(  16)										if (::hx::IsNull( prev )) {
HXLINE(  16)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  16)											l = null();
            										}
            										else {
HXLINE(  16)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  16)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  16)					_hx_tmp = b2;
            				}
            				break;
            			}
HXDLIN(  16)			this1->image = _hx_tmp;
HXDLIN(  16)			this1->width = width;
HXDLIN(  16)			this1->height = height;
HXDLIN(  16)			this1->imageType = ( (int)(imageType) );
HXDLIN(  16)			 ::pi_xy::ImageStruct pixelImage = this1;
HXDLIN(  16)			pixelImage->transparent = true;
HXDLIN(  16)			{
HXLINE(  16)				int p = 0;
HXDLIN(  16)				int a1;
HXDLIN(  16)				int r;
HXDLIN(  16)				int g;
HXDLIN(  16)				int b3;
HXDLIN(  16)				{
HXLINE(  16)					int _g16 = 0;
HXDLIN(  16)					int _g17 = (bytesCameleon->length >> 2);
HXDLIN(  16)					while((_g16 < _g17)){
HXLINE(  16)						_g16 = (_g16 + 1);
HXDLIN(  16)						int i6 = (_g16 - 1);
HXDLIN(  16)						int b4 = ( (int)(bytesCameleon->b->__get(p)) );
HXDLIN(  16)						int g1 = ( (int)(bytesCameleon->b->__get((p + 1))) );
HXDLIN(  16)						int r1 = ( (int)(bytesCameleon->b->__get((p + 2))) );
HXDLIN(  16)						int a2 = ( (int)(bytesCameleon->b->__get((p + 3))) );
HXDLIN(  16)						{
HXLINE(  16)							p = (p + 1);
HXDLIN(  16)							bytesCameleon->b[(p - 1)] = ( (unsigned char)(r1) );
            						}
HXDLIN(  16)						{
HXLINE(  16)							p = (p + 1);
HXDLIN(  16)							bytesCameleon->b[(p - 1)] = ( (unsigned char)(g1) );
            						}
HXDLIN(  16)						{
HXLINE(  16)							p = (p + 1);
HXDLIN(  16)							bytesCameleon->b[(p - 1)] = ( (unsigned char)(b4) );
            						}
HXDLIN(  16)						{
HXLINE(  16)							p = (p + 1);
HXDLIN(  16)							bytesCameleon->b[(p - 1)] = ( (unsigned char)(a2) );
            						}
            					}
            				}
            			}
HXDLIN(  16)			{
HXLINE(  16)				int width1 = pixelImage->width;
HXDLIN(  16)				int height1 = pixelImage->height;
HXDLIN(  16)				 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  16)				 ::iterMagic::BytesImg b5 = byt1;
HXDLIN(  16)				{
HXLINE(  16)					b5->width = width1;
HXDLIN(  16)					b5->height = height1;
HXDLIN(  16)					b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  16)					b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN(  16)					{
HXLINE(  16)						int len2 = b5->length;
HXDLIN(  16)						int w1 = 0;
HXDLIN(  16)						{
HXLINE(  16)							int _g18 = 0;
HXDLIN(  16)							int _g19 = b5->height;
HXDLIN(  16)							while((_g18 < _g19)){
HXLINE(  16)								_g18 = (_g18 + 1);
HXDLIN(  16)								int y1 = (_g18 - 1);
HXDLIN(  16)								{
HXLINE(  16)									int _g20 = 0;
HXDLIN(  16)									int _g21 = b5->width;
HXDLIN(  16)									while((_g20 < _g21)){
HXLINE(  16)										_g20 = (_g20 + 1);
HXDLIN(  16)										int x1 = (_g20 - 1);
HXDLIN(  16)										{
HXLINE(  16)											w1 = (w1 + 1);
HXDLIN(  16)											b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  16)										{
HXLINE(  16)											w1 = (w1 + 1);
HXDLIN(  16)											b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  16)										{
HXLINE(  16)											w1 = (w1 + 1);
HXDLIN(  16)											b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  16)										{
HXLINE(  16)											w1 = (w1 + 1);
HXDLIN(  16)											b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  16)				 ::iterMagic::BytesImg imageBytes = b5;
HXDLIN(  16)				::Dynamic accessorBytes = imageBytes;
HXDLIN(  16)				accessorBytes->__SetField(HX_("data",2a,56,63,42),bytesCameleon,::hx::paccDynamic);
HXDLIN(  16)				{
HXLINE(  16)					int _g22 = 0;
HXDLIN(  16)					int _g23 = imageBytes->length;
HXDLIN(  16)					while((_g22 < _g23)){
HXLINE(  16)						_g22 = (_g22 + 1);
HXDLIN(  16)						int i7 = (_g22 - 1);
HXDLIN(  16)						::haxe::Log_obj::trace(i7,::hx::SourceInfo(HX_("src/pi_xy/Pixelimage.hx",36,00,3a,6f),488,HX_("pi_xy._Pixelimage.Pixelimage_Impl_",f6,5e,97,e3),HX_("fromBytes",a1,f2,20,72)));
HXDLIN(  16)						{
HXLINE(  16)							::Dynamic this3 = pixelImage->image;
HXDLIN(  16)							 ::haxe::io::Bytes _this1 = imageBytes->data;
HXDLIN(  16)							int pos1 = ::Std_obj::_hx_int(( (Float)((i7 * 4)) ));
HXDLIN(  16)							::iterMagic::Iimg_obj::set(this3,i7,(((( (int)(_this1->b->__get(pos1)) ) | (( (int)(_this1->b->__get((pos1 + 1))) ) << 8)) | (( (int)(_this1->b->__get((pos1 + 2))) ) << 16)) | (( (int)(_this1->b->__get((pos1 + 3))) ) << 24)));
            						}
            					}
            				}
            			}
HXDLIN(  16)			 ::pi_xy::ImageStruct img = pixelImage;
HXLINE(  17)			this->imageTexture = img;
            		}
            		else {
HXLINE(  19)			this->super::setParameter(name,value);
            		}
            	}


 ::Dynamic NineSlicePicture_obj::render( ::Dynamic _tmp_pixelImage){
            	HX_GC_STACKFRAME(&_hx_pos_c19e8e9a0f2b0013_25_render)
HXLINE(  28)		 ::pi_xy::ImageStruct pixelImage = ( ( ::pi_xy::ImageStruct)(_tmp_pixelImage) );
HXDLIN(  28)		if (::hx::IsNotNull( this->imageTexture )) {
HXLINE(  29)			Float win_x = ( (Float)(0) );
HXDLIN(  29)			Float win_y = ( (Float)(0) );
HXDLIN(  29)			Float win_width = ( (Float)(( ( ::pi_xy::ImageStruct)(this->imageTexture) )->width) );
HXDLIN(  29)			Float win_height = ( (Float)(( ( ::pi_xy::ImageStruct)(this->imageTexture) )->height) );
HXLINE(  30)			win_x = this->pictureX;
HXLINE(  31)			win_y = this->pictureY;
HXLINE(  32)			if ((this->pictureWidth != ((Float)0.))) {
HXLINE(  32)				win_width = this->pictureWidth;
            			}
HXLINE(  33)			if ((this->pictureHeight != ((Float)0.))) {
HXLINE(  33)				win_height = this->pictureHeight;
            			}
HXLINE(  34)			if ((this->rounded != true)) {
HXLINE(  35)				 ::pi_xy::ImageStruct this1 = pixelImage;
HXDLIN(  35)				 ::pi_xy::ImageStruct texture = ( ( ::pi_xy::ImageStruct)(this->imageTexture) );
HXDLIN(  35)				Float x = this->left;
HXDLIN(  35)				Float y = this->top;
HXDLIN(  35)				Float wid = this->initWid;
HXDLIN(  35)				Float hi = this->initHi;
HXDLIN(  35)				Float left = this->initLeft;
HXDLIN(  35)				Float top = this->initTop;
HXDLIN(  35)				Float fat = this->initFat;
HXDLIN(  35)				Float tall = this->initTall;
HXDLIN(  35)				Float widNew = this->newWid;
HXDLIN(  35)				Float hiNew = this->newHi;
HXDLIN(  35)				Float leftNew = this->newLeft;
HXDLIN(  35)				Float topNew = this->newTop;
HXDLIN(  35)				Float fatNew = this->newFat;
HXDLIN(  35)				Float tallNew = this->newTall;
HXDLIN(  35)				bool hasHit = false;
HXDLIN(  35)				int width = ::Std_obj::_hx_int(wid);
HXDLIN(  35)				int height = ::Std_obj::_hx_int(hi);
HXDLIN(  35)				 ::Dynamic imageType = null();
HXDLIN(  35)				 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  35)				if (::hx::IsNull( imageType )) {
HXLINE(  54)					imageType = ::pi_xy::ImageStruct_obj::defaultType;
            				}
HXLINE(  35)				::Dynamic _hx_tmp;
HXDLIN(  35)				switch((int)(( (int)(imageType) ))){
            					case (int)0: {
HXLINE(  35)						 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  35)						 ::iterMagic::BytesImg b = byt;
HXDLIN(  35)						{
HXLINE(  35)							b->width = width;
HXDLIN(  35)							b->height = height;
HXDLIN(  35)							b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  35)							b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  35)							{
HXLINE(  35)								int len = b->length;
HXDLIN(  35)								int w = 0;
HXDLIN(  35)								{
HXLINE(  35)									int _g = 0;
HXDLIN(  35)									int _g1 = b->height;
HXDLIN(  35)									while((_g < _g1)){
HXLINE(  35)										_g = (_g + 1);
HXDLIN(  35)										int y1 = (_g - 1);
HXDLIN(  35)										{
HXLINE(  35)											int _g2 = 0;
HXDLIN(  35)											int _g3 = b->width;
HXDLIN(  35)											while((_g2 < _g3)){
HXLINE(  35)												_g2 = (_g2 + 1);
HXDLIN(  35)												int x1 = (_g2 - 1);
HXDLIN(  35)												{
HXLINE(  35)													w = (w + 1);
HXDLIN(  35)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  35)												{
HXLINE(  35)													w = (w + 1);
HXDLIN(  35)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  35)												{
HXLINE(  35)													w = (w + 1);
HXDLIN(  35)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
HXDLIN(  35)												{
HXLINE(  35)													w = (w + 1);
HXDLIN(  35)													b->data->b[(w - 1)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						_hx_tmp = b;
            					}
            					break;
            					case (int)1: {
HXLINE(  35)						 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)						 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  35)						{
HXLINE(  35)							a->width = width;
HXDLIN(  35)							a->height = height;
HXDLIN(  35)							a->data = ::Array_obj< int >::__new(0);
HXDLIN(  35)							a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  35)							{
HXLINE(  35)								int _g4 = 0;
HXDLIN(  35)								int _g5 = a->length;
HXDLIN(  35)								while((_g4 < _g5)){
HXLINE(  35)									_g4 = (_g4 + 1);
HXDLIN(  35)									int i = (_g4 - 1);
HXDLIN(  35)									a->data[i] = 0;
            								}
            							}
            						}
HXDLIN(  35)						_hx_tmp = a;
            					}
            					break;
            					case (int)2: {
HXLINE(  35)						 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  35)						 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  35)						{
HXLINE(  35)							b1->width = width;
HXDLIN(  35)							b1->height = height;
HXDLIN(  35)							b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  35)							int size = (b1->length * 4);
HXDLIN(  35)							b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  35)							{
HXLINE(  35)								int _g6 = 0;
HXDLIN(  35)								int _g7 = b1->length;
HXDLIN(  35)								while((_g6 < _g7)){
HXLINE(  35)									_g6 = (_g6 + 1);
HXDLIN(  35)									int i1 = (_g6 - 1);
HXDLIN(  35)									{
HXLINE(  35)										 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  35)										bool _hx_tmp1;
HXDLIN(  35)										if ((i1 >= 0)) {
HXLINE(  35)											_hx_tmp1 = (i1 < (this3->byteLength >> 2));
            										}
            										else {
HXLINE(  35)											_hx_tmp1 = false;
            										}
HXDLIN(  35)										if (_hx_tmp1) {
HXLINE(  35)											 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  35)											int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  35)											_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  35)											_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  35)											_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  35)											_this->b[(pos + 3)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						_hx_tmp = b1;
            					}
            					break;
            					case (int)3: {
HXLINE(  35)						 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)						 ::iterMagic::VecIntImg v = vec;
HXDLIN(  35)						{
HXLINE(  35)							v->width = width;
HXDLIN(  35)							v->height = height;
HXDLIN(  35)							v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  35)							v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  35)							{
HXLINE(  35)								int _g8 = 0;
HXDLIN(  35)								int _g9 = v->length;
HXDLIN(  35)								while((_g8 < _g9)){
HXLINE(  35)									_g8 = (_g8 + 1);
HXDLIN(  35)									int i2 = (_g8 - 1);
HXDLIN(  35)									v->data->__unsafe_set(i2,0);
            								}
            							}
            						}
HXDLIN(  35)						_hx_tmp = v;
            					}
            					break;
            					case (int)4: {
HXLINE(  35)						 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)						 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  35)						{
HXLINE(  35)							b2->width = width;
HXDLIN(  35)							b2->height = height;
HXDLIN(  35)							b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  35)							b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  35)							{
HXLINE(  35)								int len1 = b2->length;
HXDLIN(  35)								 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  35)								if (::hx::IsNull( d->head )) {
HXLINE(  35)									int _g10 = 0;
HXDLIN(  35)									int _g11 = len1;
HXDLIN(  35)									while((_g10 < _g11)){
HXLINE(  35)										_g10 = (_g10 + 1);
HXDLIN(  35)										int i3 = (_g10 - 1);
HXDLIN(  35)										d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            									}
            								}
            								else {
HXLINE(  35)									int _g12 = 0;
HXDLIN(  35)									int _g13 = len1;
HXDLIN(  35)									while((_g12 < _g13)){
HXLINE(  35)										_g12 = (_g12 + 1);
HXDLIN(  35)										int i4 = (_g12 - 1);
HXDLIN(  35)										{
HXLINE(  35)											 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  35)											 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  35)											{
HXLINE(  35)												int _g14 = 0;
HXDLIN(  35)												int _g15 = i4;
HXDLIN(  35)												while((_g14 < _g15)){
HXLINE(  35)													_g14 = (_g14 + 1);
HXDLIN(  35)													int i5 = (_g14 - 1);
HXLINE( 345)													prev = l;
HXLINE( 346)													l = l->next;
            												}
            											}
HXLINE(  35)											if (::hx::IsNull( prev )) {
HXLINE(  35)												b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  35)												l = null();
            											}
            											else {
HXLINE(  35)												prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  35)												l = null();
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						_hx_tmp = b2;
            					}
            					break;
            				}
HXDLIN(  35)				this2->image = _hx_tmp;
HXDLIN(  35)				this2->width = width;
HXDLIN(  35)				this2->height = height;
HXDLIN(  35)				this2->imageType = ( (int)(imageType) );
HXDLIN(  35)				 ::pi_xy::ImageStruct temp = this2;
HXDLIN(  35)				temp->transparent = false;
HXDLIN(  35)				Float ax = ( (Float)(0) );
HXDLIN(  35)				Float ay = ( (Float)(0) );
HXDLIN(  35)				Float bx = (ax + widNew);
HXDLIN(  35)				Float by = ( (Float)(0) );
HXDLIN(  35)				Float cx = bx;
HXDLIN(  35)				Float cy = (ay + hiNew);
HXDLIN(  35)				Float dx = ( (Float)(0) );
HXDLIN(  35)				Float dy = cx;
HXDLIN(  35)				Float rightW = ((widNew - leftNew) - fatNew);
HXDLIN(  35)				Float bottomH = ((hiNew - topNew) - tallNew);
HXDLIN(  35)				Float leftX = leftNew;
HXDLIN(  35)				Float topY = topNew;
HXDLIN(  35)				Float rightX = (leftNew + fatNew);
HXDLIN(  35)				Float bottomY = (topNew + tallNew);
HXDLIN(  35)				Float au = ((Float)0.);
HXDLIN(  35)				Float av = ((Float)0.);
HXDLIN(  35)				Float bu = ((Float)0.);
HXDLIN(  35)				Float cv = ((Float)0.);
HXDLIN(  35)				Float sw = (( (Float)(1) ) / (wid + 1));
HXDLIN(  35)				Float sh = (( (Float)(1) ) / (hi + 1));
HXLINE( 236)				bu = (left * sw);
HXLINE( 237)				cv = (top * sh);
HXLINE(  35)				{
HXLINE(  35)					{
HXLINE(  35)						Float au1 = ((Float)0.);
HXDLIN(  35)						Float av1 = ((Float)0.);
HXDLIN(  35)						Float bu1 = bu;
HXDLIN(  35)						Float bv = ((Float)0.);
HXDLIN(  35)						bool hasUndo = false;
HXDLIN(  35)						Float temp1 = au1;
HXLINE( 422)						au1 = bu1;
HXLINE( 423)						bu1 = temp1;
HXLINE( 424)						temp1 = av1;
HXLINE( 425)						av1 = bv;
HXLINE( 426)						bv = temp1;
HXLINE(  35)						Float bcx = leftX;
HXDLIN(  35)						Float bcy = (( (Float)(0) ) - topY);
HXDLIN(  35)						Float acx = ( (Float)(0) );
HXDLIN(  35)						Float acy = (( (Float)(0) ) - topY);
HXDLIN(  35)						Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  35)						Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  35)						Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  35)						Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  35)						if ((0 > leftX)) {
HXLINE(  35)							int ii_min = ::Math_obj::floor(leftX);
HXDLIN(  35)							int ii_max = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  35)							xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            						}
            						else {
HXLINE(  35)							if ((leftX > 0)) {
HXLINE(  35)								int ii_min1 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  35)								int ii_max1 = ::Math_obj::ceil(leftX);
HXDLIN(  35)								xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            							}
            							else {
HXLINE(  35)								int ii_min2 = ::Math_obj::floor(( (Float)(0) ));
HXDLIN(  35)								int ii_max2 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  35)								xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  35)						if ((0 > topY)) {
HXLINE(  35)							int min;
HXDLIN(  35)							if ((0 > topY)) {
HXLINE(  35)								min = ::Math_obj::floor(topY);
            							}
            							else {
HXLINE(  35)								min = ::Math_obj::ceil(( (Float)(0) ));
            							}
HXDLIN(  35)							int ii_min3 = min;
HXDLIN(  35)							int ii_max3 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  35)							yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            						}
            						else {
HXLINE(  35)							int ii_min4 = ::Math_obj::floor(( (Float)(0) ));
HXDLIN(  35)							int ii_max4 = ::Math_obj::ceil(topY);
HXDLIN(  35)							yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            						}
HXDLIN(  35)						 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  35)						if (hasUndo) {
HXLINE(  35)							int width1 = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  35)							int height1 = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  35)							 ::Dynamic imageType1 = null();
HXDLIN(  35)							 ::pi_xy::ImageStruct this4 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  35)							if (::hx::IsNull( imageType1 )) {
HXLINE(  54)								imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE(  35)							::Dynamic undoImage1;
HXDLIN(  35)							switch((int)(( (int)(imageType1) ))){
            								case (int)0: {
HXLINE(  35)									 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::BytesImg b3 = byt1;
HXDLIN(  35)									{
HXLINE(  35)										b3->width = width1;
HXDLIN(  35)										b3->height = height1;
HXDLIN(  35)										b3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  35)										b3->data = ::haxe::io::Bytes_obj::alloc((b3->length * 4));
HXDLIN(  35)										{
HXLINE(  35)											int len2 = b3->length;
HXDLIN(  35)											int w1 = 0;
HXDLIN(  35)											{
HXLINE(  35)												int _g16 = 0;
HXDLIN(  35)												int _g17 = b3->height;
HXDLIN(  35)												while((_g16 < _g17)){
HXLINE(  35)													_g16 = (_g16 + 1);
HXDLIN(  35)													int y2 = (_g16 - 1);
HXDLIN(  35)													{
HXLINE(  35)														int _g18 = 0;
HXDLIN(  35)														int _g19 = b3->width;
HXDLIN(  35)														while((_g18 < _g19)){
HXLINE(  35)															_g18 = (_g18 + 1);
HXDLIN(  35)															int x2 = (_g18 - 1);
HXDLIN(  35)															{
HXLINE(  35)																w1 = (w1 + 1);
HXDLIN(  35)																b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w1 = (w1 + 1);
HXDLIN(  35)																b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w1 = (w1 + 1);
HXDLIN(  35)																b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w1 = (w1 + 1);
HXDLIN(  35)																b3->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage1 = b3;
            								}
            								break;
            								case (int)1: {
HXLINE(  35)									 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::ArrIntImg a1 = arrI1;
HXDLIN(  35)									{
HXLINE(  35)										a1->width = width1;
HXDLIN(  35)										a1->height = height1;
HXDLIN(  35)										a1->data = ::Array_obj< int >::__new(0);
HXDLIN(  35)										a1->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  35)										{
HXLINE(  35)											int _g20 = 0;
HXDLIN(  35)											int _g21 = a1->length;
HXDLIN(  35)											while((_g20 < _g21)){
HXLINE(  35)												_g20 = (_g20 + 1);
HXDLIN(  35)												int i6 = (_g20 - 1);
HXDLIN(  35)												a1->data[i6] = 0;
            											}
            										}
            									}
HXDLIN(  35)									undoImage1 = a1;
            								}
            								break;
            								case (int)2: {
HXLINE(  35)									 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::U32ArrImg b4 = u32a1;
HXDLIN(  35)									{
HXLINE(  35)										b4->width = width1;
HXDLIN(  35)										b4->height = height1;
HXDLIN(  35)										b4->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  35)										int size1 = (b4->length * 4);
HXDLIN(  35)										b4->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  35)										{
HXLINE(  35)											int _g22 = 0;
HXDLIN(  35)											int _g23 = b4->length;
HXDLIN(  35)											while((_g22 < _g23)){
HXLINE(  35)												_g22 = (_g22 + 1);
HXDLIN(  35)												int i7 = (_g22 - 1);
HXDLIN(  35)												{
HXLINE(  35)													 ::haxe::io::ArrayBufferViewImpl this5 = b4->data;
HXDLIN(  35)													bool undoImage2;
HXDLIN(  35)													if ((i7 >= 0)) {
HXLINE(  35)														undoImage2 = (i7 < (this5->byteLength >> 2));
            													}
            													else {
HXLINE(  35)														undoImage2 = false;
            													}
HXDLIN(  35)													if (undoImage2) {
HXLINE(  35)														 ::haxe::io::Bytes _this1 = this5->bytes;
HXDLIN(  35)														int pos1 = ((i7 << 2) + this5->byteOffset);
HXDLIN(  35)														_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  35)														_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage1 = b4;
            								}
            								break;
            								case (int)3: {
HXLINE(  35)									 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::VecIntImg v1 = vec1;
HXDLIN(  35)									{
HXLINE(  35)										v1->width = width1;
HXDLIN(  35)										v1->height = height1;
HXDLIN(  35)										v1->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  35)										v1->data = ::Array_obj< int >::__new(v1->length);
HXDLIN(  35)										{
HXLINE(  35)											int _g24 = 0;
HXDLIN(  35)											int _g25 = v1->length;
HXDLIN(  35)											while((_g24 < _g25)){
HXLINE(  35)												_g24 = (_g24 + 1);
HXDLIN(  35)												int i8 = (_g24 - 1);
HXDLIN(  35)												v1->data->__unsafe_set(i8,0);
            											}
            										}
            									}
HXDLIN(  35)									undoImage1 = v1;
            								}
            								break;
            								case (int)4: {
HXLINE(  35)									 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::StackIntImg b5 = sInt1;
HXDLIN(  35)									{
HXLINE(  35)										b5->width = width1;
HXDLIN(  35)										b5->height = height1;
HXDLIN(  35)										b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  35)										b5->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  35)										{
HXLINE(  35)											int len3 = b5->length;
HXDLIN(  35)											 ::haxe::ds::GenericStack_Int d1 = b5->data;
HXDLIN(  35)											if (::hx::IsNull( d1->head )) {
HXLINE(  35)												int _g26 = 0;
HXDLIN(  35)												int _g27 = len3;
HXDLIN(  35)												while((_g26 < _g27)){
HXLINE(  35)													_g26 = (_g26 + 1);
HXDLIN(  35)													int i9 = (_g26 - 1);
HXDLIN(  35)													d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            												}
            											}
            											else {
HXLINE(  35)												int _g28 = 0;
HXDLIN(  35)												int _g29 = len3;
HXDLIN(  35)												while((_g28 < _g29)){
HXLINE(  35)													_g28 = (_g28 + 1);
HXDLIN(  35)													int i10 = (_g28 - 1);
HXDLIN(  35)													{
HXLINE(  35)														 ::haxe::ds::GenericCell_Int l1 = b5->data->head;
HXDLIN(  35)														 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  35)														{
HXLINE(  35)															int _g30 = 0;
HXDLIN(  35)															int _g31 = i10;
HXDLIN(  35)															while((_g30 < _g31)){
HXLINE(  35)																_g30 = (_g30 + 1);
HXDLIN(  35)																int i11 = (_g30 - 1);
HXLINE( 345)																prev1 = l1;
HXLINE( 346)																l1 = l1->next;
            															}
            														}
HXLINE(  35)														if (::hx::IsNull( prev1 )) {
HXLINE(  35)															b5->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  35)															l1 = null();
            														}
            														else {
HXLINE(  35)															prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  35)															l1 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage1 = b5;
            								}
            								break;
            							}
HXDLIN(  35)							this4->image = undoImage1;
HXDLIN(  35)							this4->width = width1;
HXDLIN(  35)							this4->height = height1;
HXDLIN(  35)							this4->imageType = ( (int)(imageType1) );
HXDLIN(  35)							undoImage = this4;
HXDLIN(  35)							{
HXLINE(  35)								int rectLeft = xIter3->start;
HXDLIN(  35)								int rectTop = yIter3->start;
HXDLIN(  35)								int rectRight = xIter3->max;
HXDLIN(  35)								bool forceClear = false;
HXDLIN(  35)								{
HXLINE(  35)									int _g32 = rectTop;
HXDLIN(  35)									int _g33 = yIter3->max;
HXDLIN(  35)									while((_g32 < _g33)){
HXLINE(  35)										_g32 = (_g32 + 1);
HXDLIN(  35)										int dy1 = (_g32 - 1);
HXDLIN(  35)										{
HXLINE(  35)											int _g34 = rectLeft;
HXDLIN(  35)											int _g35 = rectRight;
HXDLIN(  35)											while((_g34 < _g35)){
HXLINE(  35)												_g34 = (_g34 + 1);
HXDLIN(  35)												int dx1 = (_g34 - 1);
HXDLIN(  35)												::Dynamic this6 = temp->image;
HXDLIN(  35)												int index;
HXDLIN(  35)												if (temp->useVirtualPos) {
HXLINE(  35)													index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx1) - temp->virtualX));
            												}
            												else {
HXLINE(  35)													index = ::Std_obj::_hx_int(( (Float)(((dy1 * temp->width) + dx1)) ));
            												}
HXDLIN(  35)												int c = ::iterMagic::Iimg_obj::get(this6,index);
HXDLIN(  35)												int col;
HXDLIN(  35)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)													col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            												}
            												else {
HXLINE(  35)													col = c;
            												}
HXDLIN(  35)												bool _hx_tmp2;
HXDLIN(  35)												if (temp->useMask) {
HXLINE(  35)													_hx_tmp2 = ::hx::IsNotNull( temp->mask );
            												}
            												else {
HXLINE(  35)													_hx_tmp2 = false;
            												}
HXDLIN(  35)												if (_hx_tmp2) {
HXLINE(  35)													 ::pi_xy::ImageStruct this7 = temp->mask;
HXDLIN(  35)													::Dynamic this8 = this7->image;
HXDLIN(  35)													int index1;
HXDLIN(  35)													if (this7->useVirtualPos) {
HXLINE(  35)														index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this7->virtualY) * ( (Float)(this7->width) )) + dx1) - this7->virtualX));
            													}
            													else {
HXLINE(  35)														index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this7->width) + dx1)) ));
            													}
HXDLIN(  35)													int c1 = ::iterMagic::Iimg_obj::get(this8,index1);
HXDLIN(  35)													int v2;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														v2 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														v2 = c1;
            													}
HXDLIN(  35)													int maskPixel = v2;
HXDLIN(  35)													int this9 = col;
HXDLIN(  35)													if ((maskPixel == 0)) {
HXLINE(  35)														col = this9;
            													}
            													else {
HXLINE(  35)														Float m0;
HXDLIN(  35)														int this10 = ((maskPixel >> 24) & 255);
HXDLIN(  35)														if ((this10 == 0)) {
HXLINE(  35)															m0 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m0 = (( (Float)(this10) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m1;
HXDLIN(  35)														int this11 = ((maskPixel >> 16) & 255);
HXDLIN(  35)														if ((this11 == 0)) {
HXLINE(  35)															m1 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m1 = (( (Float)(this11) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m2;
HXDLIN(  35)														int this12 = ((maskPixel >> 8) & 255);
HXDLIN(  35)														if ((this12 == 0)) {
HXLINE(  35)															m2 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m2 = (( (Float)(this12) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m3;
HXDLIN(  35)														int this13 = (maskPixel & 255);
HXDLIN(  35)														if ((this13 == 0)) {
HXLINE(  35)															m3 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m3 = (( (Float)(this13) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this9 >> 24) & 255)) )));
HXDLIN(  35)														int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this9 >> 16) & 255)) )));
HXDLIN(  35)														int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this9 >> 8) & 255)) )));
HXDLIN(  35)														int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this9 & 255)) )));
HXDLIN(  35)														col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  35)												if ((col != 0)) {
HXLINE(  35)													int x3 = (dx1 - rectLeft);
HXDLIN(  35)													int y3 = (dy1 - rectTop);
HXDLIN(  35)													int c2 = col;
HXDLIN(  35)													bool _hx_tmp3;
HXDLIN(  35)													if ((((c2 >> 24) & 255) < 254)) {
HXLINE(  35)														_hx_tmp3 = undoImage->transparent;
            													}
            													else {
HXLINE(  35)														_hx_tmp3 = false;
            													}
HXDLIN(  35)													if (_hx_tmp3) {
HXLINE(  35)														int location;
HXDLIN(  35)														if (undoImage->useVirtualPos) {
HXLINE(  35)															location = ::Std_obj::_hx_int(((((( (Float)(y3) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x3) - undoImage->virtualX));
            														}
            														else {
HXLINE(  35)															location = ::Std_obj::_hx_int(( (Float)(((y3 * undoImage->width) + x3)) ));
            														}
HXDLIN(  35)														int this14 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN(  35)														int this15;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															this15 = ((((((this14 >> 24) & 255) << 24) | ((this14 & 255) << 16)) | (((this14 >> 8) & 255) << 8)) | ((this14 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															this15 = this14;
            														}
HXDLIN(  35)														Float a11;
HXDLIN(  35)														int this16 = ((this15 >> 24) & 255);
HXDLIN(  35)														if ((this16 == 0)) {
HXLINE(  35)															a11 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a11 = (( (Float)(this16) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r1;
HXDLIN(  35)														int this17 = ((this15 >> 16) & 255);
HXDLIN(  35)														if ((this17 == 0)) {
HXLINE(  35)															r1 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r1 = (( (Float)(this17) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g1;
HXDLIN(  35)														int this18 = ((this15 >> 8) & 255);
HXDLIN(  35)														if ((this18 == 0)) {
HXLINE(  35)															g1 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g1 = (( (Float)(this18) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b11;
HXDLIN(  35)														int this19 = (this15 & 255);
HXDLIN(  35)														if ((this19 == 0)) {
HXLINE(  35)															b11 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b11 = (( (Float)(this19) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a2;
HXDLIN(  35)														int this20 = ((col >> 24) & 255);
HXDLIN(  35)														if ((this20 == 0)) {
HXLINE(  35)															a2 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a2 = (( (Float)(this20) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r2;
HXDLIN(  35)														int this21 = ((col >> 16) & 255);
HXDLIN(  35)														if ((this21 == 0)) {
HXLINE(  35)															r2 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r2 = (( (Float)(this21) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g2;
HXDLIN(  35)														int this22 = ((col >> 8) & 255);
HXDLIN(  35)														if ((this22 == 0)) {
HXLINE(  35)															g2 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g2 = (( (Float)(this22) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b21;
HXDLIN(  35)														int this23 = (col & 255);
HXDLIN(  35)														if ((this23 == 0)) {
HXLINE(  35)															b21 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b21 = (( (Float)(this23) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN(  35)														int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  35)														int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  35)														int b6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  35)														int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  35)														int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b6);
HXDLIN(  35)														{
HXLINE(  35)															int _hx_tmp4;
HXDLIN(  35)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)																_hx_tmp4 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            															}
            															else {
HXLINE(  35)																_hx_tmp4 = blended;
            															}
HXDLIN(  35)															::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp4);
            														}
            													}
            													else {
HXLINE(  35)														::Dynamic this24 = undoImage->image;
HXDLIN(  35)														int index2;
HXDLIN(  35)														if (undoImage->useVirtualPos) {
HXLINE(  35)															index2 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x3) - undoImage->virtualX));
            														}
            														else {
HXLINE(  35)															index2 = ::Std_obj::_hx_int(( (Float)(((y3 * undoImage->width) + x3)) ));
            														}
HXDLIN(  35)														int _hx_tmp5;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp5 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp5 = c2;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this24,index2,_hx_tmp5);
            													}
            												}
            												else {
HXLINE(  35)													if (forceClear) {
HXLINE(  35)														::Dynamic this25 = undoImage->image;
HXDLIN(  35)														int x4 = (dx1 - rectLeft);
HXDLIN(  35)														int y4 = (dy1 - rectTop);
HXDLIN(  35)														int index3;
HXDLIN(  35)														if (undoImage->useVirtualPos) {
HXLINE(  35)															index3 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x4) - undoImage->virtualX));
            														}
            														else {
HXLINE(  35)															index3 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage->width) + x4)) ));
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this25,index3,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						{
HXLINE(  35)							int _g_min = xIter3->start;
HXDLIN(  35)							int _g_max = xIter3->max;
HXDLIN(  35)							while((_g_min < _g_max)){
HXLINE(  35)								_g_min = (_g_min + 1);
HXDLIN(  35)								int px = (_g_min - 1);
HXDLIN(  35)								Float pcx = ( (Float)(px) );
HXDLIN(  35)								{
HXLINE(  35)									int _g_min1 = yIter3->start;
HXDLIN(  35)									int _g_max1 = yIter3->max;
HXDLIN(  35)									while((_g_min1 < _g_max1)){
HXLINE(  35)										_g_min1 = (_g_min1 + 1);
HXDLIN(  35)										int py = (_g_min1 - 1);
HXDLIN(  35)										Float pcy = (( (Float)(py) ) - topY);
HXDLIN(  35)										Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  35)										Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  35)										Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  35)										Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  35)										Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  35)										bool _hx_tmp6;
HXDLIN(  35)										bool _hx_tmp7;
HXDLIN(  35)										if ((ratioA >= 0)) {
HXLINE(  35)											_hx_tmp7 = (ratioB >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp7 = false;
            										}
HXDLIN(  35)										if (_hx_tmp7) {
HXLINE(  35)											_hx_tmp6 = (ratioC >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp6 = false;
            										}
HXDLIN(  35)										if (_hx_tmp6) {
HXLINE(  35)											Float u = (((au1 * ratioA) + (bu1 * ratioB)) + (((Float)0.) * ratioC));
HXDLIN(  35)											Float v3 = (((av1 * ratioA) + (bv * ratioB)) + (cv * ratioC));
HXDLIN(  35)											int x5 = ::Std_obj::_hx_int(((u * win_width) + win_x));
HXDLIN(  35)											int y5 = ::Std_obj::_hx_int(((v3 * win_height) + win_y));
HXDLIN(  35)											::Dynamic this26 = texture->image;
HXDLIN(  35)											int index4;
HXDLIN(  35)											if (texture->useVirtualPos) {
HXLINE(  35)												index4 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - texture->virtualY) * ( (Float)(texture->width) )) + x5) - texture->virtualX));
            											}
            											else {
HXLINE(  35)												index4 = ::Std_obj::_hx_int(( (Float)(((y5 * texture->width) + x5)) ));
            											}
HXDLIN(  35)											int c3 = ::iterMagic::Iimg_obj::get(this26,index4);
HXDLIN(  35)											int col1;
HXDLIN(  35)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)												col1 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            											}
            											else {
HXLINE(  35)												col1 = c3;
            											}
HXDLIN(  35)											{
HXLINE(  35)												int c4 = col1;
HXDLIN(  35)												bool _hx_tmp8;
HXDLIN(  35)												if ((((c4 >> 24) & 255) < 254)) {
HXLINE(  35)													_hx_tmp8 = temp->transparent;
            												}
            												else {
HXLINE(  35)													_hx_tmp8 = false;
            												}
HXDLIN(  35)												if (_hx_tmp8) {
HXLINE(  35)													int location1;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														location1 = ::Std_obj::_hx_int(((((( (Float)(py) ) - temp->virtualY) * ( (Float)(temp->width) )) + px) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														location1 = ::Std_obj::_hx_int(( (Float)(((py * temp->width) + px)) ));
            													}
HXDLIN(  35)													int this27 = ::iterMagic::Iimg_obj::get(temp->image,location1);
HXDLIN(  35)													int this28;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														this28 = ((((((this27 >> 24) & 255) << 24) | ((this27 & 255) << 16)) | (((this27 >> 8) & 255) << 8)) | ((this27 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														this28 = this27;
            													}
HXDLIN(  35)													Float a12;
HXDLIN(  35)													int this29 = ((this28 >> 24) & 255);
HXDLIN(  35)													if ((this29 == 0)) {
HXLINE(  35)														a12 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a12 = (( (Float)(this29) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r11;
HXDLIN(  35)													int this30 = ((this28 >> 16) & 255);
HXDLIN(  35)													if ((this30 == 0)) {
HXLINE(  35)														r11 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r11 = (( (Float)(this30) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g11;
HXDLIN(  35)													int this31 = ((this28 >> 8) & 255);
HXDLIN(  35)													if ((this31 == 0)) {
HXLINE(  35)														g11 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g11 = (( (Float)(this31) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b12;
HXDLIN(  35)													int this32 = (this28 & 255);
HXDLIN(  35)													if ((this32 == 0)) {
HXLINE(  35)														b12 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b12 = (( (Float)(this32) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a21;
HXDLIN(  35)													int this33 = ((col1 >> 24) & 255);
HXDLIN(  35)													if ((this33 == 0)) {
HXLINE(  35)														a21 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a21 = (( (Float)(this33) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r21;
HXDLIN(  35)													int this34 = ((col1 >> 16) & 255);
HXDLIN(  35)													if ((this34 == 0)) {
HXLINE(  35)														r21 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r21 = (( (Float)(this34) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g21;
HXDLIN(  35)													int this35 = ((col1 >> 8) & 255);
HXDLIN(  35)													if ((this35 == 0)) {
HXLINE(  35)														g21 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g21 = (( (Float)(this35) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b22;
HXDLIN(  35)													int this36 = (col1 & 255);
HXDLIN(  35)													if ((this36 == 0)) {
HXLINE(  35)														b22 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b22 = (( (Float)(this36) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a31 = (a12 * (( (Float)(1) ) - a21));
HXDLIN(  35)													int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  35)													int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  35)													int b7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  35)													int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  35)													int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b7);
HXDLIN(  35)													{
HXLINE(  35)														int _hx_tmp9;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp9 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp9 = blended1;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(temp->image,location1,_hx_tmp9);
            													}
            												}
            												else {
HXLINE(  35)													::Dynamic this37 = temp->image;
HXDLIN(  35)													int index5;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														index5 = ::Std_obj::_hx_int(((((( (Float)(py) ) - temp->virtualY) * ( (Float)(temp->width) )) + px) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														index5 = ::Std_obj::_hx_int(( (Float)(((py * temp->width) + px)) ));
            													}
HXDLIN(  35)													int _hx_tmp10;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														_hx_tmp10 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														_hx_tmp10 = c4;
            													}
HXDLIN(  35)													::iterMagic::Iimg_obj::set(this37,index5,_hx_tmp10);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						if ((hasHit == false)) {
HXLINE(  35)							 ::pi_xy::algo::HitTri v4 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,( (Float)(0) ),( (Float)(0) ),leftX,( (Float)(0) ),( (Float)(0) ),topY,true);
HXDLIN(  35)							if (hasUndo) {
HXLINE(  35)								v4->undoImage = undoImage;
HXDLIN(  35)								v4->undoX = xIter3->start;
HXDLIN(  35)								v4->undoY = yIter3->start;
            							}
            						}
            					}
HXDLIN(  35)					{
HXLINE(  35)						Float au2 = bu;
HXDLIN(  35)						Float av2 = ((Float)0.);
HXDLIN(  35)						Float bu2 = bu;
HXDLIN(  35)						Float bv1 = cv;
HXDLIN(  35)						bool hasUndo1 = false;
HXDLIN(  35)						Float temp2 = au2;
HXLINE( 422)						au2 = bu2;
HXLINE( 423)						bu2 = temp2;
HXLINE( 424)						temp2 = av2;
HXLINE( 425)						av2 = bv1;
HXLINE( 426)						bv1 = temp2;
HXLINE(  35)						Float bcx1 = leftX;
HXDLIN(  35)						Float bcy1 = (topY - topY);
HXDLIN(  35)						Float acx1 = leftX;
HXDLIN(  35)						Float acy1 = (( (Float)(0) ) - topY);
HXDLIN(  35)						Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  35)						Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  35)						Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  35)						Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  35)						if ((leftX > leftX)) {
HXLINE(  35)							if ((leftX > 0)) {
HXLINE(  35)								int min1;
HXDLIN(  35)								if ((leftX > 0)) {
HXLINE(  35)									min1 = ::Math_obj::floor(( (Float)(0) ));
            								}
            								else {
HXLINE(  35)									min1 = ::Math_obj::floor(leftX);
            								}
HXDLIN(  35)								int ii_min5 = min1;
HXDLIN(  35)								int ii_max5 = ::Math_obj::ceil(leftX);
HXDLIN(  35)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            							}
            							else {
HXLINE(  35)								int ii_min6 = ::Math_obj::floor(leftX);
HXDLIN(  35)								int ii_max6 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  35)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            							}
            						}
            						else {
HXLINE(  35)							if ((leftX > 0)) {
HXLINE(  35)								int min2;
HXDLIN(  35)								if ((leftX > 0)) {
HXLINE(  35)									min2 = ::Math_obj::floor(( (Float)(0) ));
            								}
            								else {
HXLINE(  35)									min2 = ::Math_obj::ceil(leftX);
            								}
HXDLIN(  35)								int ii_min7 = min2;
HXDLIN(  35)								int ii_max7 = ::Math_obj::ceil(leftX);
HXDLIN(  35)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            							}
            							else {
HXLINE(  35)								int ii_min8 = ::Math_obj::floor(leftX);
HXDLIN(  35)								int ii_max8 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  35)								xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  35)						if ((0 > topY)) {
HXLINE(  35)							if ((0 > topY)) {
HXLINE(  35)								int min3;
HXDLIN(  35)								if ((topY > topY)) {
HXLINE(  35)									min3 = ::Math_obj::floor(topY);
            								}
            								else {
HXLINE(  35)									min3 = ::Math_obj::floor(topY);
            								}
HXDLIN(  35)								int ii_min9 = min3;
HXDLIN(  35)								int ii_max9 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  35)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            							}
            							else {
HXLINE(  35)								int ii_min10 = ::Math_obj::floor(topY);
HXDLIN(  35)								int ii_max10 = ::Math_obj::ceil(topY);
HXDLIN(  35)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            							}
            						}
            						else {
HXLINE(  35)							if ((topY > topY)) {
HXLINE(  35)								int min4;
HXDLIN(  35)								if ((0 > topY)) {
HXLINE(  35)									min4 = ::Math_obj::floor(topY);
            								}
            								else {
HXLINE(  35)									min4 = ::Math_obj::ceil(( (Float)(0) ));
            								}
HXDLIN(  35)								int ii_min11 = min4;
HXDLIN(  35)								int ii_max11 = ::Math_obj::ceil(topY);
HXDLIN(  35)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            							}
            							else {
HXLINE(  35)								int ii_min12 = ::Math_obj::floor(( (Float)(0) ));
HXDLIN(  35)								int ii_max12 = ::Math_obj::ceil(topY);
HXDLIN(  35)								yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  35)						if (hasUndo1) {
HXLINE(  35)							int width2 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  35)							int height2 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  35)							 ::Dynamic imageType2 = null();
HXDLIN(  35)							 ::pi_xy::ImageStruct this38 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  35)							if (::hx::IsNull( imageType2 )) {
HXLINE(  54)								imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE(  35)							::Dynamic undoImage4;
HXDLIN(  35)							switch((int)(( (int)(imageType2) ))){
            								case (int)0: {
HXLINE(  35)									 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::BytesImg b8 = byt2;
HXDLIN(  35)									{
HXLINE(  35)										b8->width = width2;
HXDLIN(  35)										b8->height = height2;
HXDLIN(  35)										b8->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  35)										b8->data = ::haxe::io::Bytes_obj::alloc((b8->length * 4));
HXDLIN(  35)										{
HXLINE(  35)											int len4 = b8->length;
HXDLIN(  35)											int w2 = 0;
HXDLIN(  35)											{
HXLINE(  35)												int _g36 = 0;
HXDLIN(  35)												int _g37 = b8->height;
HXDLIN(  35)												while((_g36 < _g37)){
HXLINE(  35)													_g36 = (_g36 + 1);
HXDLIN(  35)													int y6 = (_g36 - 1);
HXDLIN(  35)													{
HXLINE(  35)														int _g38 = 0;
HXDLIN(  35)														int _g39 = b8->width;
HXDLIN(  35)														while((_g38 < _g39)){
HXLINE(  35)															_g38 = (_g38 + 1);
HXDLIN(  35)															int x6 = (_g38 - 1);
HXDLIN(  35)															{
HXLINE(  35)																w2 = (w2 + 1);
HXDLIN(  35)																b8->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w2 = (w2 + 1);
HXDLIN(  35)																b8->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w2 = (w2 + 1);
HXDLIN(  35)																b8->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w2 = (w2 + 1);
HXDLIN(  35)																b8->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage4 = b8;
            								}
            								break;
            								case (int)1: {
HXLINE(  35)									 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::ArrIntImg a6 = arrI2;
HXDLIN(  35)									{
HXLINE(  35)										a6->width = width2;
HXDLIN(  35)										a6->height = height2;
HXDLIN(  35)										a6->data = ::Array_obj< int >::__new(0);
HXDLIN(  35)										a6->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  35)										{
HXLINE(  35)											int _g40 = 0;
HXDLIN(  35)											int _g41 = a6->length;
HXDLIN(  35)											while((_g40 < _g41)){
HXLINE(  35)												_g40 = (_g40 + 1);
HXDLIN(  35)												int i12 = (_g40 - 1);
HXDLIN(  35)												a6->data[i12] = 0;
            											}
            										}
            									}
HXDLIN(  35)									undoImage4 = a6;
            								}
            								break;
            								case (int)2: {
HXLINE(  35)									 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::U32ArrImg b9 = u32a2;
HXDLIN(  35)									{
HXLINE(  35)										b9->width = width2;
HXDLIN(  35)										b9->height = height2;
HXDLIN(  35)										b9->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  35)										int size2 = (b9->length * 4);
HXDLIN(  35)										b9->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN(  35)										{
HXLINE(  35)											int _g42 = 0;
HXDLIN(  35)											int _g43 = b9->length;
HXDLIN(  35)											while((_g42 < _g43)){
HXLINE(  35)												_g42 = (_g42 + 1);
HXDLIN(  35)												int i13 = (_g42 - 1);
HXDLIN(  35)												{
HXLINE(  35)													 ::haxe::io::ArrayBufferViewImpl this39 = b9->data;
HXDLIN(  35)													bool undoImage5;
HXDLIN(  35)													if ((i13 >= 0)) {
HXLINE(  35)														undoImage5 = (i13 < (this39->byteLength >> 2));
            													}
            													else {
HXLINE(  35)														undoImage5 = false;
            													}
HXDLIN(  35)													if (undoImage5) {
HXLINE(  35)														 ::haxe::io::Bytes _this2 = this39->bytes;
HXDLIN(  35)														int pos2 = ((i13 << 2) + this39->byteOffset);
HXDLIN(  35)														_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN(  35)														_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage4 = b9;
            								}
            								break;
            								case (int)3: {
HXLINE(  35)									 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::VecIntImg v5 = vec2;
HXDLIN(  35)									{
HXLINE(  35)										v5->width = width2;
HXDLIN(  35)										v5->height = height2;
HXDLIN(  35)										v5->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  35)										v5->data = ::Array_obj< int >::__new(v5->length);
HXDLIN(  35)										{
HXLINE(  35)											int _g44 = 0;
HXDLIN(  35)											int _g45 = v5->length;
HXDLIN(  35)											while((_g44 < _g45)){
HXLINE(  35)												_g44 = (_g44 + 1);
HXDLIN(  35)												int i14 = (_g44 - 1);
HXDLIN(  35)												v5->data->__unsafe_set(i14,0);
            											}
            										}
            									}
HXDLIN(  35)									undoImage4 = v5;
            								}
            								break;
            								case (int)4: {
HXLINE(  35)									 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::StackIntImg b10 = sInt2;
HXDLIN(  35)									{
HXLINE(  35)										b10->width = width2;
HXDLIN(  35)										b10->height = height2;
HXDLIN(  35)										b10->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  35)										b10->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  35)										{
HXLINE(  35)											int len5 = b10->length;
HXDLIN(  35)											 ::haxe::ds::GenericStack_Int d2 = b10->data;
HXDLIN(  35)											if (::hx::IsNull( d2->head )) {
HXLINE(  35)												int _g46 = 0;
HXDLIN(  35)												int _g47 = len5;
HXDLIN(  35)												while((_g46 < _g47)){
HXLINE(  35)													_g46 = (_g46 + 1);
HXDLIN(  35)													int i15 = (_g46 - 1);
HXDLIN(  35)													d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            												}
            											}
            											else {
HXLINE(  35)												int _g48 = 0;
HXDLIN(  35)												int _g49 = len5;
HXDLIN(  35)												while((_g48 < _g49)){
HXLINE(  35)													_g48 = (_g48 + 1);
HXDLIN(  35)													int i16 = (_g48 - 1);
HXDLIN(  35)													{
HXLINE(  35)														 ::haxe::ds::GenericCell_Int l2 = b10->data->head;
HXDLIN(  35)														 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN(  35)														{
HXLINE(  35)															int _g50 = 0;
HXDLIN(  35)															int _g51 = i16;
HXDLIN(  35)															while((_g50 < _g51)){
HXLINE(  35)																_g50 = (_g50 + 1);
HXDLIN(  35)																int i17 = (_g50 - 1);
HXLINE( 345)																prev2 = l2;
HXLINE( 346)																l2 = l2->next;
            															}
            														}
HXLINE(  35)														if (::hx::IsNull( prev2 )) {
HXLINE(  35)															b10->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  35)															l2 = null();
            														}
            														else {
HXLINE(  35)															prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  35)															l2 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage4 = b10;
            								}
            								break;
            							}
HXDLIN(  35)							this38->image = undoImage4;
HXDLIN(  35)							this38->width = width2;
HXDLIN(  35)							this38->height = height2;
HXDLIN(  35)							this38->imageType = ( (int)(imageType2) );
HXDLIN(  35)							undoImage3 = this38;
HXDLIN(  35)							{
HXLINE(  35)								int rectLeft1 = xIter31->start;
HXDLIN(  35)								int rectTop1 = yIter31->start;
HXDLIN(  35)								int rectRight1 = xIter31->max;
HXDLIN(  35)								bool forceClear1 = false;
HXDLIN(  35)								{
HXLINE(  35)									int _g52 = rectTop1;
HXDLIN(  35)									int _g53 = yIter31->max;
HXDLIN(  35)									while((_g52 < _g53)){
HXLINE(  35)										_g52 = (_g52 + 1);
HXDLIN(  35)										int dy2 = (_g52 - 1);
HXDLIN(  35)										{
HXLINE(  35)											int _g54 = rectLeft1;
HXDLIN(  35)											int _g55 = rectRight1;
HXDLIN(  35)											while((_g54 < _g55)){
HXLINE(  35)												_g54 = (_g54 + 1);
HXDLIN(  35)												int dx2 = (_g54 - 1);
HXDLIN(  35)												::Dynamic this40 = temp->image;
HXDLIN(  35)												int index6;
HXDLIN(  35)												if (temp->useVirtualPos) {
HXLINE(  35)													index6 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx2) - temp->virtualX));
            												}
            												else {
HXLINE(  35)													index6 = ::Std_obj::_hx_int(( (Float)(((dy2 * temp->width) + dx2)) ));
            												}
HXDLIN(  35)												int c5 = ::iterMagic::Iimg_obj::get(this40,index6);
HXDLIN(  35)												int col2;
HXDLIN(  35)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)													col2 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            												}
            												else {
HXLINE(  35)													col2 = c5;
            												}
HXDLIN(  35)												bool _hx_tmp11;
HXDLIN(  35)												if (temp->useMask) {
HXLINE(  35)													_hx_tmp11 = ::hx::IsNotNull( temp->mask );
            												}
            												else {
HXLINE(  35)													_hx_tmp11 = false;
            												}
HXDLIN(  35)												if (_hx_tmp11) {
HXLINE(  35)													 ::pi_xy::ImageStruct this41 = temp->mask;
HXDLIN(  35)													::Dynamic this42 = this41->image;
HXDLIN(  35)													int index7;
HXDLIN(  35)													if (this41->useVirtualPos) {
HXLINE(  35)														index7 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this41->virtualY) * ( (Float)(this41->width) )) + dx2) - this41->virtualX));
            													}
            													else {
HXLINE(  35)														index7 = ::Std_obj::_hx_int(( (Float)(((dy2 * this41->width) + dx2)) ));
            													}
HXDLIN(  35)													int c6 = ::iterMagic::Iimg_obj::get(this42,index7);
HXDLIN(  35)													int v6;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														v6 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														v6 = c6;
            													}
HXDLIN(  35)													int maskPixel1 = v6;
HXDLIN(  35)													int this43 = col2;
HXDLIN(  35)													if ((maskPixel1 == 0)) {
HXLINE(  35)														col2 = this43;
            													}
            													else {
HXLINE(  35)														Float m01;
HXDLIN(  35)														int this44 = ((maskPixel1 >> 24) & 255);
HXDLIN(  35)														if ((this44 == 0)) {
HXLINE(  35)															m01 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m01 = (( (Float)(this44) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m11;
HXDLIN(  35)														int this45 = ((maskPixel1 >> 16) & 255);
HXDLIN(  35)														if ((this45 == 0)) {
HXLINE(  35)															m11 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m11 = (( (Float)(this45) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m21;
HXDLIN(  35)														int this46 = ((maskPixel1 >> 8) & 255);
HXDLIN(  35)														if ((this46 == 0)) {
HXLINE(  35)															m21 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m21 = (( (Float)(this46) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m31;
HXDLIN(  35)														int this47 = (maskPixel1 & 255);
HXDLIN(  35)														if ((this47 == 0)) {
HXLINE(  35)															m31 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m31 = (( (Float)(this47) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this43 >> 24) & 255)) )));
HXDLIN(  35)														int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this43 >> 16) & 255)) )));
HXDLIN(  35)														int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this43 >> 8) & 255)) )));
HXDLIN(  35)														int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this43 & 255)) )));
HXDLIN(  35)														col2 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  35)												if ((col2 != 0)) {
HXLINE(  35)													int x7 = (dx2 - rectLeft1);
HXDLIN(  35)													int y7 = (dy2 - rectTop1);
HXDLIN(  35)													int c7 = col2;
HXDLIN(  35)													bool _hx_tmp12;
HXDLIN(  35)													if ((((c7 >> 24) & 255) < 254)) {
HXLINE(  35)														_hx_tmp12 = undoImage3->transparent;
            													}
            													else {
HXLINE(  35)														_hx_tmp12 = false;
            													}
HXDLIN(  35)													if (_hx_tmp12) {
HXLINE(  35)														int location2;
HXDLIN(  35)														if (undoImage3->useVirtualPos) {
HXLINE(  35)															location2 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x7) - undoImage3->virtualX));
            														}
            														else {
HXLINE(  35)															location2 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage3->width) + x7)) ));
            														}
HXDLIN(  35)														int this48 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN(  35)														int this49;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															this49 = ((((((this48 >> 24) & 255) << 24) | ((this48 & 255) << 16)) | (((this48 >> 8) & 255) << 8)) | ((this48 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															this49 = this48;
            														}
HXDLIN(  35)														Float a13;
HXDLIN(  35)														int this50 = ((this49 >> 24) & 255);
HXDLIN(  35)														if ((this50 == 0)) {
HXLINE(  35)															a13 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a13 = (( (Float)(this50) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r12;
HXDLIN(  35)														int this51 = ((this49 >> 16) & 255);
HXDLIN(  35)														if ((this51 == 0)) {
HXLINE(  35)															r12 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r12 = (( (Float)(this51) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g12;
HXDLIN(  35)														int this52 = ((this49 >> 8) & 255);
HXDLIN(  35)														if ((this52 == 0)) {
HXLINE(  35)															g12 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g12 = (( (Float)(this52) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b13;
HXDLIN(  35)														int this53 = (this49 & 255);
HXDLIN(  35)														if ((this53 == 0)) {
HXLINE(  35)															b13 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b13 = (( (Float)(this53) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a22;
HXDLIN(  35)														int this54 = ((col2 >> 24) & 255);
HXDLIN(  35)														if ((this54 == 0)) {
HXLINE(  35)															a22 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a22 = (( (Float)(this54) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r22;
HXDLIN(  35)														int this55 = ((col2 >> 16) & 255);
HXDLIN(  35)														if ((this55 == 0)) {
HXLINE(  35)															r22 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r22 = (( (Float)(this55) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g22;
HXDLIN(  35)														int this56 = ((col2 >> 8) & 255);
HXDLIN(  35)														if ((this56 == 0)) {
HXLINE(  35)															g22 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g22 = (( (Float)(this56) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b23;
HXDLIN(  35)														int this57 = (col2 & 255);
HXDLIN(  35)														if ((this57 == 0)) {
HXLINE(  35)															b23 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b23 = (( (Float)(this57) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a32 = (a13 * (( (Float)(1) ) - a22));
HXDLIN(  35)														int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  35)														int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  35)														int b14 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  35)														int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  35)														int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b14);
HXDLIN(  35)														{
HXLINE(  35)															int _hx_tmp13;
HXDLIN(  35)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)																_hx_tmp13 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            															}
            															else {
HXLINE(  35)																_hx_tmp13 = blended2;
            															}
HXDLIN(  35)															::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp13);
            														}
            													}
            													else {
HXLINE(  35)														::Dynamic this58 = undoImage3->image;
HXDLIN(  35)														int index8;
HXDLIN(  35)														if (undoImage3->useVirtualPos) {
HXLINE(  35)															index8 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x7) - undoImage3->virtualX));
            														}
            														else {
HXLINE(  35)															index8 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage3->width) + x7)) ));
            														}
HXDLIN(  35)														int _hx_tmp14;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp14 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp14 = c7;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this58,index8,_hx_tmp14);
            													}
            												}
            												else {
HXLINE(  35)													if (forceClear1) {
HXLINE(  35)														::Dynamic this59 = undoImage3->image;
HXDLIN(  35)														int x8 = (dx2 - rectLeft1);
HXDLIN(  35)														int y8 = (dy2 - rectTop1);
HXDLIN(  35)														int index9;
HXDLIN(  35)														if (undoImage3->useVirtualPos) {
HXLINE(  35)															index9 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x8) - undoImage3->virtualX));
            														}
            														else {
HXLINE(  35)															index9 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage3->width) + x8)) ));
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this59,index9,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						{
HXLINE(  35)							int _g_min2 = xIter31->start;
HXDLIN(  35)							int _g_max2 = xIter31->max;
HXDLIN(  35)							while((_g_min2 < _g_max2)){
HXLINE(  35)								_g_min2 = (_g_min2 + 1);
HXDLIN(  35)								int px1 = (_g_min2 - 1);
HXDLIN(  35)								Float pcx1 = ( (Float)(px1) );
HXDLIN(  35)								{
HXLINE(  35)									int _g_min3 = yIter31->start;
HXDLIN(  35)									int _g_max3 = yIter31->max;
HXDLIN(  35)									while((_g_min3 < _g_max3)){
HXLINE(  35)										_g_min3 = (_g_min3 + 1);
HXDLIN(  35)										int py1 = (_g_min3 - 1);
HXDLIN(  35)										Float pcy1 = (( (Float)(py1) ) - topY);
HXDLIN(  35)										Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN(  35)										Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN(  35)										Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN(  35)										Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN(  35)										Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN(  35)										bool _hx_tmp15;
HXDLIN(  35)										bool _hx_tmp16;
HXDLIN(  35)										if ((ratioA1 >= 0)) {
HXLINE(  35)											_hx_tmp16 = (ratioB1 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp16 = false;
            										}
HXDLIN(  35)										if (_hx_tmp16) {
HXLINE(  35)											_hx_tmp15 = (ratioC1 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp15 = false;
            										}
HXDLIN(  35)										if (_hx_tmp15) {
HXLINE(  35)											Float u1 = (((au2 * ratioA1) + (bu2 * ratioB1)) + (((Float)0.) * ratioC1));
HXDLIN(  35)											Float v7 = (((av2 * ratioA1) + (bv1 * ratioB1)) + (cv * ratioC1));
HXDLIN(  35)											int x9 = ::Std_obj::_hx_int(((u1 * win_width) + win_x));
HXDLIN(  35)											int y9 = ::Std_obj::_hx_int(((v7 * win_height) + win_y));
HXDLIN(  35)											::Dynamic this60 = texture->image;
HXDLIN(  35)											int index10;
HXDLIN(  35)											if (texture->useVirtualPos) {
HXLINE(  35)												index10 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - texture->virtualY) * ( (Float)(texture->width) )) + x9) - texture->virtualX));
            											}
            											else {
HXLINE(  35)												index10 = ::Std_obj::_hx_int(( (Float)(((y9 * texture->width) + x9)) ));
            											}
HXDLIN(  35)											int c8 = ::iterMagic::Iimg_obj::get(this60,index10);
HXDLIN(  35)											int col3;
HXDLIN(  35)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)												col3 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            											}
            											else {
HXLINE(  35)												col3 = c8;
            											}
HXDLIN(  35)											{
HXLINE(  35)												int c9 = col3;
HXDLIN(  35)												bool _hx_tmp17;
HXDLIN(  35)												if ((((c9 >> 24) & 255) < 254)) {
HXLINE(  35)													_hx_tmp17 = temp->transparent;
            												}
            												else {
HXLINE(  35)													_hx_tmp17 = false;
            												}
HXDLIN(  35)												if (_hx_tmp17) {
HXLINE(  35)													int location3;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														location3 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - temp->virtualY) * ( (Float)(temp->width) )) + px1) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														location3 = ::Std_obj::_hx_int(( (Float)(((py1 * temp->width) + px1)) ));
            													}
HXDLIN(  35)													int this61 = ::iterMagic::Iimg_obj::get(temp->image,location3);
HXDLIN(  35)													int this62;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														this62 = ((((((this61 >> 24) & 255) << 24) | ((this61 & 255) << 16)) | (((this61 >> 8) & 255) << 8)) | ((this61 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														this62 = this61;
            													}
HXDLIN(  35)													Float a14;
HXDLIN(  35)													int this63 = ((this62 >> 24) & 255);
HXDLIN(  35)													if ((this63 == 0)) {
HXLINE(  35)														a14 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a14 = (( (Float)(this63) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r13;
HXDLIN(  35)													int this64 = ((this62 >> 16) & 255);
HXDLIN(  35)													if ((this64 == 0)) {
HXLINE(  35)														r13 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r13 = (( (Float)(this64) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g13;
HXDLIN(  35)													int this65 = ((this62 >> 8) & 255);
HXDLIN(  35)													if ((this65 == 0)) {
HXLINE(  35)														g13 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g13 = (( (Float)(this65) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b15;
HXDLIN(  35)													int this66 = (this62 & 255);
HXDLIN(  35)													if ((this66 == 0)) {
HXLINE(  35)														b15 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b15 = (( (Float)(this66) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a23;
HXDLIN(  35)													int this67 = ((col3 >> 24) & 255);
HXDLIN(  35)													if ((this67 == 0)) {
HXLINE(  35)														a23 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a23 = (( (Float)(this67) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r23;
HXDLIN(  35)													int this68 = ((col3 >> 16) & 255);
HXDLIN(  35)													if ((this68 == 0)) {
HXLINE(  35)														r23 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r23 = (( (Float)(this68) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g23;
HXDLIN(  35)													int this69 = ((col3 >> 8) & 255);
HXDLIN(  35)													if ((this69 == 0)) {
HXLINE(  35)														g23 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g23 = (( (Float)(this69) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b24;
HXDLIN(  35)													int this70 = (col3 & 255);
HXDLIN(  35)													if ((this70 == 0)) {
HXLINE(  35)														b24 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b24 = (( (Float)(this70) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a33 = (a14 * (( (Float)(1) ) - a23));
HXDLIN(  35)													int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  35)													int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  35)													int b16 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b15 * a33) + (b24 * a23))));
HXDLIN(  35)													int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  35)													int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b16);
HXDLIN(  35)													{
HXLINE(  35)														int _hx_tmp18;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp18 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp18 = blended3;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(temp->image,location3,_hx_tmp18);
            													}
            												}
            												else {
HXLINE(  35)													::Dynamic this71 = temp->image;
HXDLIN(  35)													int index11;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														index11 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - temp->virtualY) * ( (Float)(temp->width) )) + px1) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														index11 = ::Std_obj::_hx_int(( (Float)(((py1 * temp->width) + px1)) ));
            													}
HXDLIN(  35)													int _hx_tmp19;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														_hx_tmp19 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														_hx_tmp19 = c9;
            													}
HXDLIN(  35)													::iterMagic::Iimg_obj::set(this71,index11,_hx_tmp19);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						if ((hasHit == false)) {
HXLINE(  35)							 ::pi_xy::algo::HitTri v8 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,leftX,( (Float)(0) ),leftX,topY,( (Float)(0) ),topY,true);
HXDLIN(  35)							if (hasUndo1) {
HXLINE(  35)								v8->undoImage = undoImage3;
HXDLIN(  35)								v8->undoX = xIter31->start;
HXDLIN(  35)								v8->undoY = yIter31->start;
            							}
            						}
            					}
HXDLIN(  35)					if ((hasHit == true)) {
HXLINE(  35)						 ::pi_xy::algo::HitQuad v9 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,( (Float)(0) ),( (Float)(0) ),leftX,( (Float)(0) ),leftX,topY,( (Float)(0) ),topY,true);
            					}
            				}
HXLINE( 243)				au = bu;
HXLINE( 244)				bu = ((left + fat) * sw);
HXLINE(  35)				{
HXLINE(  35)					{
HXLINE(  35)						Float au3 = au;
HXDLIN(  35)						Float av3 = ((Float)0.);
HXDLIN(  35)						Float bu3 = bu;
HXDLIN(  35)						Float bv2 = ((Float)0.);
HXDLIN(  35)						bool hasUndo2 = false;
HXDLIN(  35)						Float temp3 = au3;
HXLINE( 422)						au3 = bu3;
HXLINE( 423)						bu3 = temp3;
HXLINE( 424)						temp3 = av3;
HXLINE( 425)						av3 = bv2;
HXLINE( 426)						bv2 = temp3;
HXLINE(  35)						Float bcx2 = (rightX - leftX);
HXDLIN(  35)						Float bcy2 = (( (Float)(0) ) - topY);
HXDLIN(  35)						Float acx2 = (leftX - leftX);
HXDLIN(  35)						Float acy2 = (( (Float)(0) ) - topY);
HXDLIN(  35)						Float dot112 = ((bcx2 * bcx2) + (bcy2 * bcy2));
HXDLIN(  35)						Float dot122 = ((bcx2 * acx2) + (bcy2 * acy2));
HXDLIN(  35)						Float dot222 = ((acx2 * acx2) + (acy2 * acy2));
HXDLIN(  35)						Float denom12 = (( (Float)(1) ) / ((dot112 * dot222) - (dot122 * dot122)));
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart xIter32;
HXDLIN(  35)						if ((leftX > rightX)) {
HXLINE(  35)							if ((leftX > leftX)) {
HXLINE(  35)								int min5;
HXDLIN(  35)								if ((rightX > leftX)) {
HXLINE(  35)									min5 = ::Math_obj::floor(leftX);
            								}
            								else {
HXLINE(  35)									min5 = ::Math_obj::floor(rightX);
            								}
HXDLIN(  35)								int ii_min13 = min5;
HXDLIN(  35)								int ii_max13 = ::Math_obj::ceil(leftX);
HXDLIN(  35)								xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            							}
            							else {
HXLINE(  35)								int ii_min14 = ::Math_obj::floor(rightX);
HXDLIN(  35)								int ii_max14 = ::Math_obj::ceil(leftX);
HXDLIN(  35)								xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            							}
            						}
            						else {
HXLINE(  35)							if ((rightX > leftX)) {
HXLINE(  35)								int min6;
HXDLIN(  35)								if ((leftX > leftX)) {
HXLINE(  35)									min6 = ::Math_obj::floor(leftX);
            								}
            								else {
HXLINE(  35)									min6 = ::Math_obj::ceil(leftX);
            								}
HXDLIN(  35)								int ii_min15 = min6;
HXDLIN(  35)								int ii_max15 = ::Math_obj::ceil(rightX);
HXDLIN(  35)								xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            							}
            							else {
HXLINE(  35)								int ii_min16 = ::Math_obj::floor(leftX);
HXDLIN(  35)								int ii_max16 = ::Math_obj::ceil(leftX);
HXDLIN(  35)								xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart yIter32;
HXDLIN(  35)						if ((0 > topY)) {
HXLINE(  35)							int min7;
HXDLIN(  35)							if ((0 > topY)) {
HXLINE(  35)								min7 = ::Math_obj::floor(topY);
            							}
            							else {
HXLINE(  35)								min7 = ::Math_obj::ceil(( (Float)(0) ));
            							}
HXDLIN(  35)							int ii_min17 = min7;
HXDLIN(  35)							int ii_max17 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  35)							yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            						}
            						else {
HXLINE(  35)							int ii_min18 = ::Math_obj::floor(( (Float)(0) ));
HXDLIN(  35)							int ii_max18 = ::Math_obj::ceil(topY);
HXDLIN(  35)							yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            						}
HXDLIN(  35)						 ::pi_xy::ImageStruct undoImage6 = null();
HXDLIN(  35)						if (hasUndo2) {
HXLINE(  35)							int width3 = ((xIter32->max - xIter32->start) + 1);
HXDLIN(  35)							int height3 = ((yIter32->max - yIter32->start) + 1);
HXDLIN(  35)							 ::Dynamic imageType3 = null();
HXDLIN(  35)							 ::pi_xy::ImageStruct this72 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  35)							if (::hx::IsNull( imageType3 )) {
HXLINE(  54)								imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE(  35)							::Dynamic undoImage7;
HXDLIN(  35)							switch((int)(( (int)(imageType3) ))){
            								case (int)0: {
HXLINE(  35)									 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::BytesImg b17 = byt3;
HXDLIN(  35)									{
HXLINE(  35)										b17->width = width3;
HXDLIN(  35)										b17->height = height3;
HXDLIN(  35)										b17->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  35)										b17->data = ::haxe::io::Bytes_obj::alloc((b17->length * 4));
HXDLIN(  35)										{
HXLINE(  35)											int len6 = b17->length;
HXDLIN(  35)											int w3 = 0;
HXDLIN(  35)											{
HXLINE(  35)												int _g56 = 0;
HXDLIN(  35)												int _g57 = b17->height;
HXDLIN(  35)												while((_g56 < _g57)){
HXLINE(  35)													_g56 = (_g56 + 1);
HXDLIN(  35)													int y10 = (_g56 - 1);
HXDLIN(  35)													{
HXLINE(  35)														int _g58 = 0;
HXDLIN(  35)														int _g59 = b17->width;
HXDLIN(  35)														while((_g58 < _g59)){
HXLINE(  35)															_g58 = (_g58 + 1);
HXDLIN(  35)															int x10 = (_g58 - 1);
HXDLIN(  35)															{
HXLINE(  35)																w3 = (w3 + 1);
HXDLIN(  35)																b17->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w3 = (w3 + 1);
HXDLIN(  35)																b17->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w3 = (w3 + 1);
HXDLIN(  35)																b17->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w3 = (w3 + 1);
HXDLIN(  35)																b17->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage7 = b17;
            								}
            								break;
            								case (int)1: {
HXLINE(  35)									 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::ArrIntImg a9 = arrI3;
HXDLIN(  35)									{
HXLINE(  35)										a9->width = width3;
HXDLIN(  35)										a9->height = height3;
HXDLIN(  35)										a9->data = ::Array_obj< int >::__new(0);
HXDLIN(  35)										a9->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  35)										{
HXLINE(  35)											int _g60 = 0;
HXDLIN(  35)											int _g61 = a9->length;
HXDLIN(  35)											while((_g60 < _g61)){
HXLINE(  35)												_g60 = (_g60 + 1);
HXDLIN(  35)												int i18 = (_g60 - 1);
HXDLIN(  35)												a9->data[i18] = 0;
            											}
            										}
            									}
HXDLIN(  35)									undoImage7 = a9;
            								}
            								break;
            								case (int)2: {
HXLINE(  35)									 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::U32ArrImg b18 = u32a3;
HXDLIN(  35)									{
HXLINE(  35)										b18->width = width3;
HXDLIN(  35)										b18->height = height3;
HXDLIN(  35)										b18->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  35)										int size3 = (b18->length * 4);
HXDLIN(  35)										b18->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN(  35)										{
HXLINE(  35)											int _g62 = 0;
HXDLIN(  35)											int _g63 = b18->length;
HXDLIN(  35)											while((_g62 < _g63)){
HXLINE(  35)												_g62 = (_g62 + 1);
HXDLIN(  35)												int i19 = (_g62 - 1);
HXDLIN(  35)												{
HXLINE(  35)													 ::haxe::io::ArrayBufferViewImpl this73 = b18->data;
HXDLIN(  35)													bool undoImage8;
HXDLIN(  35)													if ((i19 >= 0)) {
HXLINE(  35)														undoImage8 = (i19 < (this73->byteLength >> 2));
            													}
            													else {
HXLINE(  35)														undoImage8 = false;
            													}
HXDLIN(  35)													if (undoImage8) {
HXLINE(  35)														 ::haxe::io::Bytes _this3 = this73->bytes;
HXDLIN(  35)														int pos3 = ((i19 << 2) + this73->byteOffset);
HXDLIN(  35)														_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN(  35)														_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage7 = b18;
            								}
            								break;
            								case (int)3: {
HXLINE(  35)									 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::VecIntImg v10 = vec3;
HXDLIN(  35)									{
HXLINE(  35)										v10->width = width3;
HXDLIN(  35)										v10->height = height3;
HXDLIN(  35)										v10->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  35)										v10->data = ::Array_obj< int >::__new(v10->length);
HXDLIN(  35)										{
HXLINE(  35)											int _g64 = 0;
HXDLIN(  35)											int _g65 = v10->length;
HXDLIN(  35)											while((_g64 < _g65)){
HXLINE(  35)												_g64 = (_g64 + 1);
HXDLIN(  35)												int i20 = (_g64 - 1);
HXDLIN(  35)												v10->data->__unsafe_set(i20,0);
            											}
            										}
            									}
HXDLIN(  35)									undoImage7 = v10;
            								}
            								break;
            								case (int)4: {
HXLINE(  35)									 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::StackIntImg b19 = sInt3;
HXDLIN(  35)									{
HXLINE(  35)										b19->width = width3;
HXDLIN(  35)										b19->height = height3;
HXDLIN(  35)										b19->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  35)										b19->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  35)										{
HXLINE(  35)											int len7 = b19->length;
HXDLIN(  35)											 ::haxe::ds::GenericStack_Int d3 = b19->data;
HXDLIN(  35)											if (::hx::IsNull( d3->head )) {
HXLINE(  35)												int _g66 = 0;
HXDLIN(  35)												int _g67 = len7;
HXDLIN(  35)												while((_g66 < _g67)){
HXLINE(  35)													_g66 = (_g66 + 1);
HXDLIN(  35)													int i21 = (_g66 - 1);
HXDLIN(  35)													d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            												}
            											}
            											else {
HXLINE(  35)												int _g68 = 0;
HXDLIN(  35)												int _g69 = len7;
HXDLIN(  35)												while((_g68 < _g69)){
HXLINE(  35)													_g68 = (_g68 + 1);
HXDLIN(  35)													int i22 = (_g68 - 1);
HXDLIN(  35)													{
HXLINE(  35)														 ::haxe::ds::GenericCell_Int l3 = b19->data->head;
HXDLIN(  35)														 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN(  35)														{
HXLINE(  35)															int _g70 = 0;
HXDLIN(  35)															int _g71 = i22;
HXDLIN(  35)															while((_g70 < _g71)){
HXLINE(  35)																_g70 = (_g70 + 1);
HXDLIN(  35)																int i23 = (_g70 - 1);
HXLINE( 345)																prev3 = l3;
HXLINE( 346)																l3 = l3->next;
            															}
            														}
HXLINE(  35)														if (::hx::IsNull( prev3 )) {
HXLINE(  35)															b19->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  35)															l3 = null();
            														}
            														else {
HXLINE(  35)															prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  35)															l3 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage7 = b19;
            								}
            								break;
            							}
HXDLIN(  35)							this72->image = undoImage7;
HXDLIN(  35)							this72->width = width3;
HXDLIN(  35)							this72->height = height3;
HXDLIN(  35)							this72->imageType = ( (int)(imageType3) );
HXDLIN(  35)							undoImage6 = this72;
HXDLIN(  35)							{
HXLINE(  35)								int rectLeft2 = xIter32->start;
HXDLIN(  35)								int rectTop2 = yIter32->start;
HXDLIN(  35)								int rectRight2 = xIter32->max;
HXDLIN(  35)								bool forceClear2 = false;
HXDLIN(  35)								{
HXLINE(  35)									int _g72 = rectTop2;
HXDLIN(  35)									int _g73 = yIter32->max;
HXDLIN(  35)									while((_g72 < _g73)){
HXLINE(  35)										_g72 = (_g72 + 1);
HXDLIN(  35)										int dy3 = (_g72 - 1);
HXDLIN(  35)										{
HXLINE(  35)											int _g74 = rectLeft2;
HXDLIN(  35)											int _g75 = rectRight2;
HXDLIN(  35)											while((_g74 < _g75)){
HXLINE(  35)												_g74 = (_g74 + 1);
HXDLIN(  35)												int dx3 = (_g74 - 1);
HXDLIN(  35)												::Dynamic this74 = temp->image;
HXDLIN(  35)												int index12;
HXDLIN(  35)												if (temp->useVirtualPos) {
HXLINE(  35)													index12 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx3) - temp->virtualX));
            												}
            												else {
HXLINE(  35)													index12 = ::Std_obj::_hx_int(( (Float)(((dy3 * temp->width) + dx3)) ));
            												}
HXDLIN(  35)												int c10 = ::iterMagic::Iimg_obj::get(this74,index12);
HXDLIN(  35)												int col4;
HXDLIN(  35)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)													col4 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            												}
            												else {
HXLINE(  35)													col4 = c10;
            												}
HXDLIN(  35)												bool _hx_tmp20;
HXDLIN(  35)												if (temp->useMask) {
HXLINE(  35)													_hx_tmp20 = ::hx::IsNotNull( temp->mask );
            												}
            												else {
HXLINE(  35)													_hx_tmp20 = false;
            												}
HXDLIN(  35)												if (_hx_tmp20) {
HXLINE(  35)													 ::pi_xy::ImageStruct this75 = temp->mask;
HXDLIN(  35)													::Dynamic this76 = this75->image;
HXDLIN(  35)													int index13;
HXDLIN(  35)													if (this75->useVirtualPos) {
HXLINE(  35)														index13 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - this75->virtualY) * ( (Float)(this75->width) )) + dx3) - this75->virtualX));
            													}
            													else {
HXLINE(  35)														index13 = ::Std_obj::_hx_int(( (Float)(((dy3 * this75->width) + dx3)) ));
            													}
HXDLIN(  35)													int c11 = ::iterMagic::Iimg_obj::get(this76,index13);
HXDLIN(  35)													int v11;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														v11 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														v11 = c11;
            													}
HXDLIN(  35)													int maskPixel2 = v11;
HXDLIN(  35)													int this77 = col4;
HXDLIN(  35)													if ((maskPixel2 == 0)) {
HXLINE(  35)														col4 = this77;
            													}
            													else {
HXLINE(  35)														Float m02;
HXDLIN(  35)														int this78 = ((maskPixel2 >> 24) & 255);
HXDLIN(  35)														if ((this78 == 0)) {
HXLINE(  35)															m02 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m02 = (( (Float)(this78) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m12;
HXDLIN(  35)														int this79 = ((maskPixel2 >> 16) & 255);
HXDLIN(  35)														if ((this79 == 0)) {
HXLINE(  35)															m12 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m12 = (( (Float)(this79) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m22;
HXDLIN(  35)														int this80 = ((maskPixel2 >> 8) & 255);
HXDLIN(  35)														if ((this80 == 0)) {
HXLINE(  35)															m22 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m22 = (( (Float)(this80) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m32;
HXDLIN(  35)														int this81 = (maskPixel2 & 255);
HXDLIN(  35)														if ((this81 == 0)) {
HXLINE(  35)															m32 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m32 = (( (Float)(this81) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this77 >> 24) & 255)) )));
HXDLIN(  35)														int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this77 >> 16) & 255)) )));
HXDLIN(  35)														int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this77 >> 8) & 255)) )));
HXDLIN(  35)														int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this77 & 255)) )));
HXDLIN(  35)														col4 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  35)												if ((col4 != 0)) {
HXLINE(  35)													int x11 = (dx3 - rectLeft2);
HXDLIN(  35)													int y11 = (dy3 - rectTop2);
HXDLIN(  35)													int c12 = col4;
HXDLIN(  35)													bool _hx_tmp21;
HXDLIN(  35)													if ((((c12 >> 24) & 255) < 254)) {
HXLINE(  35)														_hx_tmp21 = undoImage6->transparent;
            													}
            													else {
HXLINE(  35)														_hx_tmp21 = false;
            													}
HXDLIN(  35)													if (_hx_tmp21) {
HXLINE(  35)														int location4;
HXDLIN(  35)														if (undoImage6->useVirtualPos) {
HXLINE(  35)															location4 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x11) - undoImage6->virtualX));
            														}
            														else {
HXLINE(  35)															location4 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage6->width) + x11)) ));
            														}
HXDLIN(  35)														int this82 = ::iterMagic::Iimg_obj::get(undoImage6->image,location4);
HXDLIN(  35)														int this83;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															this83 = ((((((this82 >> 24) & 255) << 24) | ((this82 & 255) << 16)) | (((this82 >> 8) & 255) << 8)) | ((this82 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															this83 = this82;
            														}
HXDLIN(  35)														Float a15;
HXDLIN(  35)														int this84 = ((this83 >> 24) & 255);
HXDLIN(  35)														if ((this84 == 0)) {
HXLINE(  35)															a15 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a15 = (( (Float)(this84) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r14;
HXDLIN(  35)														int this85 = ((this83 >> 16) & 255);
HXDLIN(  35)														if ((this85 == 0)) {
HXLINE(  35)															r14 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r14 = (( (Float)(this85) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g14;
HXDLIN(  35)														int this86 = ((this83 >> 8) & 255);
HXDLIN(  35)														if ((this86 == 0)) {
HXLINE(  35)															g14 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g14 = (( (Float)(this86) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b110;
HXDLIN(  35)														int this87 = (this83 & 255);
HXDLIN(  35)														if ((this87 == 0)) {
HXLINE(  35)															b110 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b110 = (( (Float)(this87) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a24;
HXDLIN(  35)														int this88 = ((col4 >> 24) & 255);
HXDLIN(  35)														if ((this88 == 0)) {
HXLINE(  35)															a24 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a24 = (( (Float)(this88) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r24;
HXDLIN(  35)														int this89 = ((col4 >> 16) & 255);
HXDLIN(  35)														if ((this89 == 0)) {
HXLINE(  35)															r24 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r24 = (( (Float)(this89) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g24;
HXDLIN(  35)														int this90 = ((col4 >> 8) & 255);
HXDLIN(  35)														if ((this90 == 0)) {
HXLINE(  35)															g24 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g24 = (( (Float)(this90) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b25;
HXDLIN(  35)														int this91 = (col4 & 255);
HXDLIN(  35)														if ((this91 == 0)) {
HXLINE(  35)															b25 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b25 = (( (Float)(this91) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a34 = (a15 * (( (Float)(1) ) - a24));
HXDLIN(  35)														int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN(  35)														int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN(  35)														int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a34) + (b25 * a24))));
HXDLIN(  35)														int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN(  35)														int blended4 = ((((a10 << 24) | (r6 << 16)) | (g6 << 8)) | b20);
HXDLIN(  35)														{
HXLINE(  35)															int _hx_tmp22;
HXDLIN(  35)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)																_hx_tmp22 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            															}
            															else {
HXLINE(  35)																_hx_tmp22 = blended4;
            															}
HXDLIN(  35)															::iterMagic::Iimg_obj::set(undoImage6->image,location4,_hx_tmp22);
            														}
            													}
            													else {
HXLINE(  35)														::Dynamic this92 = undoImage6->image;
HXDLIN(  35)														int index14;
HXDLIN(  35)														if (undoImage6->useVirtualPos) {
HXLINE(  35)															index14 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x11) - undoImage6->virtualX));
            														}
            														else {
HXLINE(  35)															index14 = ::Std_obj::_hx_int(( (Float)(((y11 * undoImage6->width) + x11)) ));
            														}
HXDLIN(  35)														int _hx_tmp23;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp23 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp23 = c12;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this92,index14,_hx_tmp23);
            													}
            												}
            												else {
HXLINE(  35)													if (forceClear2) {
HXLINE(  35)														::Dynamic this93 = undoImage6->image;
HXDLIN(  35)														int x12 = (dx3 - rectLeft2);
HXDLIN(  35)														int y12 = (dy3 - rectTop2);
HXDLIN(  35)														int index15;
HXDLIN(  35)														if (undoImage6->useVirtualPos) {
HXLINE(  35)															index15 = ::Std_obj::_hx_int(((((( (Float)(y12) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x12) - undoImage6->virtualX));
            														}
            														else {
HXLINE(  35)															index15 = ::Std_obj::_hx_int(( (Float)(((y12 * undoImage6->width) + x12)) ));
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this93,index15,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						{
HXLINE(  35)							int _g_min4 = xIter32->start;
HXDLIN(  35)							int _g_max4 = xIter32->max;
HXDLIN(  35)							while((_g_min4 < _g_max4)){
HXLINE(  35)								_g_min4 = (_g_min4 + 1);
HXDLIN(  35)								int px2 = (_g_min4 - 1);
HXDLIN(  35)								Float pcx2 = (( (Float)(px2) ) - leftX);
HXDLIN(  35)								{
HXLINE(  35)									int _g_min5 = yIter32->start;
HXDLIN(  35)									int _g_max5 = yIter32->max;
HXDLIN(  35)									while((_g_min5 < _g_max5)){
HXLINE(  35)										_g_min5 = (_g_min5 + 1);
HXDLIN(  35)										int py2 = (_g_min5 - 1);
HXDLIN(  35)										Float pcy2 = (( (Float)(py2) ) - topY);
HXDLIN(  35)										Float dot312 = ((pcx2 * bcx2) + (pcy2 * bcy2));
HXDLIN(  35)										Float dot322 = ((pcx2 * acx2) + (pcy2 * acy2));
HXDLIN(  35)										Float ratioA2 = (((dot222 * dot312) - (dot122 * dot322)) * denom12);
HXDLIN(  35)										Float ratioB2 = (((dot112 * dot322) - (dot122 * dot312)) * denom12);
HXDLIN(  35)										Float ratioC2 = ((((Float)1.0) - ratioB2) - ratioA2);
HXDLIN(  35)										bool _hx_tmp24;
HXDLIN(  35)										bool _hx_tmp25;
HXDLIN(  35)										if ((ratioA2 >= 0)) {
HXLINE(  35)											_hx_tmp25 = (ratioB2 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp25 = false;
            										}
HXDLIN(  35)										if (_hx_tmp25) {
HXLINE(  35)											_hx_tmp24 = (ratioC2 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp24 = false;
            										}
HXDLIN(  35)										if (_hx_tmp24) {
HXLINE(  35)											Float u2 = (((au3 * ratioA2) + (bu3 * ratioB2)) + (au * ratioC2));
HXDLIN(  35)											Float v12 = (((av3 * ratioA2) + (bv2 * ratioB2)) + (cv * ratioC2));
HXDLIN(  35)											int x13 = ::Std_obj::_hx_int(((u2 * win_width) + win_x));
HXDLIN(  35)											int y13 = ::Std_obj::_hx_int(((v12 * win_height) + win_y));
HXDLIN(  35)											::Dynamic this94 = texture->image;
HXDLIN(  35)											int index16;
HXDLIN(  35)											if (texture->useVirtualPos) {
HXLINE(  35)												index16 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - texture->virtualY) * ( (Float)(texture->width) )) + x13) - texture->virtualX));
            											}
            											else {
HXLINE(  35)												index16 = ::Std_obj::_hx_int(( (Float)(((y13 * texture->width) + x13)) ));
            											}
HXDLIN(  35)											int c13 = ::iterMagic::Iimg_obj::get(this94,index16);
HXDLIN(  35)											int col5;
HXDLIN(  35)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)												col5 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            											}
            											else {
HXLINE(  35)												col5 = c13;
            											}
HXDLIN(  35)											{
HXLINE(  35)												int c14 = col5;
HXDLIN(  35)												bool _hx_tmp26;
HXDLIN(  35)												if ((((c14 >> 24) & 255) < 254)) {
HXLINE(  35)													_hx_tmp26 = temp->transparent;
            												}
            												else {
HXLINE(  35)													_hx_tmp26 = false;
            												}
HXDLIN(  35)												if (_hx_tmp26) {
HXLINE(  35)													int location5;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														location5 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - temp->virtualY) * ( (Float)(temp->width) )) + px2) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														location5 = ::Std_obj::_hx_int(( (Float)(((py2 * temp->width) + px2)) ));
            													}
HXDLIN(  35)													int this95 = ::iterMagic::Iimg_obj::get(temp->image,location5);
HXDLIN(  35)													int this96;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														this96 = ((((((this95 >> 24) & 255) << 24) | ((this95 & 255) << 16)) | (((this95 >> 8) & 255) << 8)) | ((this95 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														this96 = this95;
            													}
HXDLIN(  35)													Float a16;
HXDLIN(  35)													int this97 = ((this96 >> 24) & 255);
HXDLIN(  35)													if ((this97 == 0)) {
HXLINE(  35)														a16 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a16 = (( (Float)(this97) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r15;
HXDLIN(  35)													int this98 = ((this96 >> 16) & 255);
HXDLIN(  35)													if ((this98 == 0)) {
HXLINE(  35)														r15 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r15 = (( (Float)(this98) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g15;
HXDLIN(  35)													int this99 = ((this96 >> 8) & 255);
HXDLIN(  35)													if ((this99 == 0)) {
HXLINE(  35)														g15 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g15 = (( (Float)(this99) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b111;
HXDLIN(  35)													int this100 = (this96 & 255);
HXDLIN(  35)													if ((this100 == 0)) {
HXLINE(  35)														b111 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b111 = (( (Float)(this100) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a25;
HXDLIN(  35)													int this101 = ((col5 >> 24) & 255);
HXDLIN(  35)													if ((this101 == 0)) {
HXLINE(  35)														a25 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a25 = (( (Float)(this101) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r25;
HXDLIN(  35)													int this102 = ((col5 >> 16) & 255);
HXDLIN(  35)													if ((this102 == 0)) {
HXLINE(  35)														r25 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r25 = (( (Float)(this102) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g25;
HXDLIN(  35)													int this103 = ((col5 >> 8) & 255);
HXDLIN(  35)													if ((this103 == 0)) {
HXLINE(  35)														g25 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g25 = (( (Float)(this103) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b26;
HXDLIN(  35)													int this104 = (col5 & 255);
HXDLIN(  35)													if ((this104 == 0)) {
HXLINE(  35)														b26 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b26 = (( (Float)(this104) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a35 = (a16 * (( (Float)(1) ) - a25));
HXDLIN(  35)													int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN(  35)													int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN(  35)													int b27 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a35) + (b26 * a25))));
HXDLIN(  35)													int a17 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN(  35)													int blended5 = ((((a17 << 24) | (r7 << 16)) | (g7 << 8)) | b27);
HXDLIN(  35)													{
HXLINE(  35)														int _hx_tmp27;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp27 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp27 = blended5;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(temp->image,location5,_hx_tmp27);
            													}
            												}
            												else {
HXLINE(  35)													::Dynamic this105 = temp->image;
HXDLIN(  35)													int index17;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														index17 = ::Std_obj::_hx_int(((((( (Float)(py2) ) - temp->virtualY) * ( (Float)(temp->width) )) + px2) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														index17 = ::Std_obj::_hx_int(( (Float)(((py2 * temp->width) + px2)) ));
            													}
HXDLIN(  35)													int _hx_tmp28;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														_hx_tmp28 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														_hx_tmp28 = c14;
            													}
HXDLIN(  35)													::iterMagic::Iimg_obj::set(this105,index17,_hx_tmp28);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						if ((hasHit == false)) {
HXLINE(  35)							 ::pi_xy::algo::HitTri v13 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,leftX,( (Float)(0) ),rightX,( (Float)(0) ),leftX,topY,true);
HXDLIN(  35)							if (hasUndo2) {
HXLINE(  35)								v13->undoImage = undoImage6;
HXDLIN(  35)								v13->undoX = xIter32->start;
HXDLIN(  35)								v13->undoY = yIter32->start;
            							}
            						}
            					}
HXDLIN(  35)					{
HXLINE(  35)						Float au4 = bu;
HXDLIN(  35)						Float av4 = ((Float)0.);
HXDLIN(  35)						Float bu4 = bu;
HXDLIN(  35)						Float bv3 = cv;
HXDLIN(  35)						bool hasUndo3 = false;
HXDLIN(  35)						Float temp4 = au4;
HXLINE( 422)						au4 = bu4;
HXLINE( 423)						bu4 = temp4;
HXLINE( 424)						temp4 = av4;
HXLINE( 425)						av4 = bv3;
HXLINE( 426)						bv3 = temp4;
HXLINE(  35)						Float bcx3 = (rightX - leftX);
HXDLIN(  35)						Float bcy3 = (topY - topY);
HXDLIN(  35)						Float acx3 = (rightX - leftX);
HXDLIN(  35)						Float acy3 = (( (Float)(0) ) - topY);
HXDLIN(  35)						Float dot113 = ((bcx3 * bcx3) + (bcy3 * bcy3));
HXDLIN(  35)						Float dot123 = ((bcx3 * acx3) + (bcy3 * acy3));
HXDLIN(  35)						Float dot223 = ((acx3 * acx3) + (acy3 * acy3));
HXDLIN(  35)						Float denom13 = (( (Float)(1) ) / ((dot113 * dot223) - (dot123 * dot123)));
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart xIter33;
HXDLIN(  35)						if ((rightX > rightX)) {
HXLINE(  35)							if ((rightX > leftX)) {
HXLINE(  35)								int min8;
HXDLIN(  35)								if ((rightX > leftX)) {
HXLINE(  35)									min8 = ::Math_obj::floor(leftX);
            								}
            								else {
HXLINE(  35)									min8 = ::Math_obj::floor(rightX);
            								}
HXDLIN(  35)								int ii_min19 = min8;
HXDLIN(  35)								int ii_max19 = ::Math_obj::ceil(rightX);
HXDLIN(  35)								xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            							}
            							else {
HXLINE(  35)								int ii_min20 = ::Math_obj::floor(rightX);
HXDLIN(  35)								int ii_max20 = ::Math_obj::ceil(leftX);
HXDLIN(  35)								xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            							}
            						}
            						else {
HXLINE(  35)							if ((rightX > leftX)) {
HXLINE(  35)								int min9;
HXDLIN(  35)								if ((rightX > leftX)) {
HXLINE(  35)									min9 = ::Math_obj::floor(leftX);
            								}
            								else {
HXLINE(  35)									min9 = ::Math_obj::ceil(rightX);
            								}
HXDLIN(  35)								int ii_min21 = min9;
HXDLIN(  35)								int ii_max21 = ::Math_obj::ceil(rightX);
HXDLIN(  35)								xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            							}
            							else {
HXLINE(  35)								int ii_min22 = ::Math_obj::floor(rightX);
HXDLIN(  35)								int ii_max22 = ::Math_obj::ceil(leftX);
HXDLIN(  35)								xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart yIter33;
HXDLIN(  35)						if ((0 > topY)) {
HXLINE(  35)							if ((0 > topY)) {
HXLINE(  35)								int min10;
HXDLIN(  35)								if ((topY > topY)) {
HXLINE(  35)									min10 = ::Math_obj::floor(topY);
            								}
            								else {
HXLINE(  35)									min10 = ::Math_obj::floor(topY);
            								}
HXDLIN(  35)								int ii_min23 = min10;
HXDLIN(  35)								int ii_max23 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  35)								yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            							}
            							else {
HXLINE(  35)								int ii_min24 = ::Math_obj::floor(topY);
HXDLIN(  35)								int ii_max24 = ::Math_obj::ceil(topY);
HXDLIN(  35)								yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            							}
            						}
            						else {
HXLINE(  35)							if ((topY > topY)) {
HXLINE(  35)								int min11;
HXDLIN(  35)								if ((0 > topY)) {
HXLINE(  35)									min11 = ::Math_obj::floor(topY);
            								}
            								else {
HXLINE(  35)									min11 = ::Math_obj::ceil(( (Float)(0) ));
            								}
HXDLIN(  35)								int ii_min25 = min11;
HXDLIN(  35)								int ii_max25 = ::Math_obj::ceil(topY);
HXDLIN(  35)								yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            							}
            							else {
HXLINE(  35)								int ii_min26 = ::Math_obj::floor(( (Float)(0) ));
HXDLIN(  35)								int ii_max26 = ::Math_obj::ceil(topY);
HXDLIN(  35)								yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::ImageStruct undoImage9 = null();
HXDLIN(  35)						if (hasUndo3) {
HXLINE(  35)							int width4 = ((xIter33->max - xIter33->start) + 1);
HXDLIN(  35)							int height4 = ((yIter33->max - yIter33->start) + 1);
HXDLIN(  35)							 ::Dynamic imageType4 = null();
HXDLIN(  35)							 ::pi_xy::ImageStruct this106 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  35)							if (::hx::IsNull( imageType4 )) {
HXLINE(  54)								imageType4 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE(  35)							::Dynamic undoImage10;
HXDLIN(  35)							switch((int)(( (int)(imageType4) ))){
            								case (int)0: {
HXLINE(  35)									 ::iterMagic::BytesImg byt4 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::BytesImg b28 = byt4;
HXDLIN(  35)									{
HXLINE(  35)										b28->width = width4;
HXDLIN(  35)										b28->height = height4;
HXDLIN(  35)										b28->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN(  35)										b28->data = ::haxe::io::Bytes_obj::alloc((b28->length * 4));
HXDLIN(  35)										{
HXLINE(  35)											int len8 = b28->length;
HXDLIN(  35)											int w4 = 0;
HXDLIN(  35)											{
HXLINE(  35)												int _g76 = 0;
HXDLIN(  35)												int _g77 = b28->height;
HXDLIN(  35)												while((_g76 < _g77)){
HXLINE(  35)													_g76 = (_g76 + 1);
HXDLIN(  35)													int y14 = (_g76 - 1);
HXDLIN(  35)													{
HXLINE(  35)														int _g78 = 0;
HXDLIN(  35)														int _g79 = b28->width;
HXDLIN(  35)														while((_g78 < _g79)){
HXLINE(  35)															_g78 = (_g78 + 1);
HXDLIN(  35)															int x14 = (_g78 - 1);
HXDLIN(  35)															{
HXLINE(  35)																w4 = (w4 + 1);
HXDLIN(  35)																b28->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w4 = (w4 + 1);
HXDLIN(  35)																b28->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w4 = (w4 + 1);
HXDLIN(  35)																b28->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w4 = (w4 + 1);
HXDLIN(  35)																b28->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage10 = b28;
            								}
            								break;
            								case (int)1: {
HXLINE(  35)									 ::iterMagic::ArrIntImg arrI4 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::ArrIntImg a18 = arrI4;
HXDLIN(  35)									{
HXLINE(  35)										a18->width = width4;
HXDLIN(  35)										a18->height = height4;
HXDLIN(  35)										a18->data = ::Array_obj< int >::__new(0);
HXDLIN(  35)										a18->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN(  35)										{
HXLINE(  35)											int _g80 = 0;
HXDLIN(  35)											int _g81 = a18->length;
HXDLIN(  35)											while((_g80 < _g81)){
HXLINE(  35)												_g80 = (_g80 + 1);
HXDLIN(  35)												int i24 = (_g80 - 1);
HXDLIN(  35)												a18->data[i24] = 0;
            											}
            										}
            									}
HXDLIN(  35)									undoImage10 = a18;
            								}
            								break;
            								case (int)2: {
HXLINE(  35)									 ::iterMagic::U32ArrImg u32a4 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::U32ArrImg b29 = u32a4;
HXDLIN(  35)									{
HXLINE(  35)										b29->width = width4;
HXDLIN(  35)										b29->height = height4;
HXDLIN(  35)										b29->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN(  35)										int size4 = (b29->length * 4);
HXDLIN(  35)										b29->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size4),0,size4);
HXDLIN(  35)										{
HXLINE(  35)											int _g82 = 0;
HXDLIN(  35)											int _g83 = b29->length;
HXDLIN(  35)											while((_g82 < _g83)){
HXLINE(  35)												_g82 = (_g82 + 1);
HXDLIN(  35)												int i25 = (_g82 - 1);
HXDLIN(  35)												{
HXLINE(  35)													 ::haxe::io::ArrayBufferViewImpl this107 = b29->data;
HXDLIN(  35)													bool undoImage11;
HXDLIN(  35)													if ((i25 >= 0)) {
HXLINE(  35)														undoImage11 = (i25 < (this107->byteLength >> 2));
            													}
            													else {
HXLINE(  35)														undoImage11 = false;
            													}
HXDLIN(  35)													if (undoImage11) {
HXLINE(  35)														 ::haxe::io::Bytes _this4 = this107->bytes;
HXDLIN(  35)														int pos4 = ((i25 << 2) + this107->byteOffset);
HXDLIN(  35)														_this4->b[pos4] = ( (unsigned char)(0) );
HXDLIN(  35)														_this4->b[(pos4 + 1)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this4->b[(pos4 + 2)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this4->b[(pos4 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage10 = b29;
            								}
            								break;
            								case (int)3: {
HXLINE(  35)									 ::iterMagic::VecIntImg vec4 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::VecIntImg v14 = vec4;
HXDLIN(  35)									{
HXLINE(  35)										v14->width = width4;
HXDLIN(  35)										v14->height = height4;
HXDLIN(  35)										v14->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN(  35)										v14->data = ::Array_obj< int >::__new(v14->length);
HXDLIN(  35)										{
HXLINE(  35)											int _g84 = 0;
HXDLIN(  35)											int _g85 = v14->length;
HXDLIN(  35)											while((_g84 < _g85)){
HXLINE(  35)												_g84 = (_g84 + 1);
HXDLIN(  35)												int i26 = (_g84 - 1);
HXDLIN(  35)												v14->data->__unsafe_set(i26,0);
            											}
            										}
            									}
HXDLIN(  35)									undoImage10 = v14;
            								}
            								break;
            								case (int)4: {
HXLINE(  35)									 ::iterMagic::StackIntImg sInt4 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::StackIntImg b30 = sInt4;
HXDLIN(  35)									{
HXLINE(  35)										b30->width = width4;
HXDLIN(  35)										b30->height = height4;
HXDLIN(  35)										b30->length = ::Std_obj::_hx_int(( (Float)((width4 * height4)) ));
HXDLIN(  35)										b30->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  35)										{
HXLINE(  35)											int len9 = b30->length;
HXDLIN(  35)											 ::haxe::ds::GenericStack_Int d4 = b30->data;
HXDLIN(  35)											if (::hx::IsNull( d4->head )) {
HXLINE(  35)												int _g86 = 0;
HXDLIN(  35)												int _g87 = len9;
HXDLIN(  35)												while((_g86 < _g87)){
HXLINE(  35)													_g86 = (_g86 + 1);
HXDLIN(  35)													int i27 = (_g86 - 1);
HXDLIN(  35)													d4->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d4->head);
            												}
            											}
            											else {
HXLINE(  35)												int _g88 = 0;
HXDLIN(  35)												int _g89 = len9;
HXDLIN(  35)												while((_g88 < _g89)){
HXLINE(  35)													_g88 = (_g88 + 1);
HXDLIN(  35)													int i28 = (_g88 - 1);
HXDLIN(  35)													{
HXLINE(  35)														 ::haxe::ds::GenericCell_Int l4 = b30->data->head;
HXDLIN(  35)														 ::haxe::ds::GenericCell_Int prev4 = null();
HXDLIN(  35)														{
HXLINE(  35)															int _g90 = 0;
HXDLIN(  35)															int _g91 = i28;
HXDLIN(  35)															while((_g90 < _g91)){
HXLINE(  35)																_g90 = (_g90 + 1);
HXDLIN(  35)																int i29 = (_g90 - 1);
HXLINE( 345)																prev4 = l4;
HXLINE( 346)																l4 = l4->next;
            															}
            														}
HXLINE(  35)														if (::hx::IsNull( prev4 )) {
HXLINE(  35)															b30->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN(  35)															l4 = null();
            														}
            														else {
HXLINE(  35)															prev4->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l4->next);
HXDLIN(  35)															l4 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage10 = b30;
            								}
            								break;
            							}
HXDLIN(  35)							this106->image = undoImage10;
HXDLIN(  35)							this106->width = width4;
HXDLIN(  35)							this106->height = height4;
HXDLIN(  35)							this106->imageType = ( (int)(imageType4) );
HXDLIN(  35)							undoImage9 = this106;
HXDLIN(  35)							{
HXLINE(  35)								int rectLeft3 = xIter33->start;
HXDLIN(  35)								int rectTop3 = yIter33->start;
HXDLIN(  35)								int rectRight3 = xIter33->max;
HXDLIN(  35)								bool forceClear3 = false;
HXDLIN(  35)								{
HXLINE(  35)									int _g92 = rectTop3;
HXDLIN(  35)									int _g93 = yIter33->max;
HXDLIN(  35)									while((_g92 < _g93)){
HXLINE(  35)										_g92 = (_g92 + 1);
HXDLIN(  35)										int dy4 = (_g92 - 1);
HXDLIN(  35)										{
HXLINE(  35)											int _g94 = rectLeft3;
HXDLIN(  35)											int _g95 = rectRight3;
HXDLIN(  35)											while((_g94 < _g95)){
HXLINE(  35)												_g94 = (_g94 + 1);
HXDLIN(  35)												int dx4 = (_g94 - 1);
HXDLIN(  35)												::Dynamic this108 = temp->image;
HXDLIN(  35)												int index18;
HXDLIN(  35)												if (temp->useVirtualPos) {
HXLINE(  35)													index18 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx4) - temp->virtualX));
            												}
            												else {
HXLINE(  35)													index18 = ::Std_obj::_hx_int(( (Float)(((dy4 * temp->width) + dx4)) ));
            												}
HXDLIN(  35)												int c15 = ::iterMagic::Iimg_obj::get(this108,index18);
HXDLIN(  35)												int col6;
HXDLIN(  35)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)													col6 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            												}
            												else {
HXLINE(  35)													col6 = c15;
            												}
HXDLIN(  35)												bool _hx_tmp29;
HXDLIN(  35)												if (temp->useMask) {
HXLINE(  35)													_hx_tmp29 = ::hx::IsNotNull( temp->mask );
            												}
            												else {
HXLINE(  35)													_hx_tmp29 = false;
            												}
HXDLIN(  35)												if (_hx_tmp29) {
HXLINE(  35)													 ::pi_xy::ImageStruct this109 = temp->mask;
HXDLIN(  35)													::Dynamic this110 = this109->image;
HXDLIN(  35)													int index19;
HXDLIN(  35)													if (this109->useVirtualPos) {
HXLINE(  35)														index19 = ::Std_obj::_hx_int(((((( (Float)(dy4) ) - this109->virtualY) * ( (Float)(this109->width) )) + dx4) - this109->virtualX));
            													}
            													else {
HXLINE(  35)														index19 = ::Std_obj::_hx_int(( (Float)(((dy4 * this109->width) + dx4)) ));
            													}
HXDLIN(  35)													int c16 = ::iterMagic::Iimg_obj::get(this110,index19);
HXDLIN(  35)													int v15;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														v15 = ((((((c16 >> 24) & 255) << 24) | ((c16 & 255) << 16)) | (((c16 >> 8) & 255) << 8)) | ((c16 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														v15 = c16;
            													}
HXDLIN(  35)													int maskPixel3 = v15;
HXDLIN(  35)													int this111 = col6;
HXDLIN(  35)													if ((maskPixel3 == 0)) {
HXLINE(  35)														col6 = this111;
            													}
            													else {
HXLINE(  35)														Float m03;
HXDLIN(  35)														int this112 = ((maskPixel3 >> 24) & 255);
HXDLIN(  35)														if ((this112 == 0)) {
HXLINE(  35)															m03 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m03 = (( (Float)(this112) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m13;
HXDLIN(  35)														int this113 = ((maskPixel3 >> 16) & 255);
HXDLIN(  35)														if ((this113 == 0)) {
HXLINE(  35)															m13 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m13 = (( (Float)(this113) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m23;
HXDLIN(  35)														int this114 = ((maskPixel3 >> 8) & 255);
HXDLIN(  35)														if ((this114 == 0)) {
HXLINE(  35)															m23 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m23 = (( (Float)(this114) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m33;
HXDLIN(  35)														int this115 = (maskPixel3 & 255);
HXDLIN(  35)														if ((this115 == 0)) {
HXLINE(  35)															m33 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m33 = (( (Float)(this115) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														int ch03 = ::Std_obj::_hx_int(((((Float)1.) - m03) * ( (Float)(((this111 >> 24) & 255)) )));
HXDLIN(  35)														int ch13 = ::Std_obj::_hx_int(((((Float)1.) - m13) * ( (Float)(((this111 >> 16) & 255)) )));
HXDLIN(  35)														int ch23 = ::Std_obj::_hx_int(((((Float)1.) - m23) * ( (Float)(((this111 >> 8) & 255)) )));
HXDLIN(  35)														int ch33 = ::Std_obj::_hx_int(((((Float)1.) - m33) * ( (Float)((this111 & 255)) )));
HXDLIN(  35)														col6 = ((((::Math_obj::round((( (Float)(ch03) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch13) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch23) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch33) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  35)												if ((col6 != 0)) {
HXLINE(  35)													int x15 = (dx4 - rectLeft3);
HXDLIN(  35)													int y15 = (dy4 - rectTop3);
HXDLIN(  35)													int c17 = col6;
HXDLIN(  35)													bool _hx_tmp30;
HXDLIN(  35)													if ((((c17 >> 24) & 255) < 254)) {
HXLINE(  35)														_hx_tmp30 = undoImage9->transparent;
            													}
            													else {
HXLINE(  35)														_hx_tmp30 = false;
            													}
HXDLIN(  35)													if (_hx_tmp30) {
HXLINE(  35)														int location6;
HXDLIN(  35)														if (undoImage9->useVirtualPos) {
HXLINE(  35)															location6 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x15) - undoImage9->virtualX));
            														}
            														else {
HXLINE(  35)															location6 = ::Std_obj::_hx_int(( (Float)(((y15 * undoImage9->width) + x15)) ));
            														}
HXDLIN(  35)														int this116 = ::iterMagic::Iimg_obj::get(undoImage9->image,location6);
HXDLIN(  35)														int this117;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															this117 = ((((((this116 >> 24) & 255) << 24) | ((this116 & 255) << 16)) | (((this116 >> 8) & 255) << 8)) | ((this116 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															this117 = this116;
            														}
HXDLIN(  35)														Float a19;
HXDLIN(  35)														int this118 = ((this117 >> 24) & 255);
HXDLIN(  35)														if ((this118 == 0)) {
HXLINE(  35)															a19 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a19 = (( (Float)(this118) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r16;
HXDLIN(  35)														int this119 = ((this117 >> 16) & 255);
HXDLIN(  35)														if ((this119 == 0)) {
HXLINE(  35)															r16 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r16 = (( (Float)(this119) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g16;
HXDLIN(  35)														int this120 = ((this117 >> 8) & 255);
HXDLIN(  35)														if ((this120 == 0)) {
HXLINE(  35)															g16 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g16 = (( (Float)(this120) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b112;
HXDLIN(  35)														int this121 = (this117 & 255);
HXDLIN(  35)														if ((this121 == 0)) {
HXLINE(  35)															b112 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b112 = (( (Float)(this121) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a26;
HXDLIN(  35)														int this122 = ((col6 >> 24) & 255);
HXDLIN(  35)														if ((this122 == 0)) {
HXLINE(  35)															a26 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a26 = (( (Float)(this122) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r26;
HXDLIN(  35)														int this123 = ((col6 >> 16) & 255);
HXDLIN(  35)														if ((this123 == 0)) {
HXLINE(  35)															r26 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r26 = (( (Float)(this123) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g26;
HXDLIN(  35)														int this124 = ((col6 >> 8) & 255);
HXDLIN(  35)														if ((this124 == 0)) {
HXLINE(  35)															g26 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g26 = (( (Float)(this124) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b210;
HXDLIN(  35)														int this125 = (col6 & 255);
HXDLIN(  35)														if ((this125 == 0)) {
HXLINE(  35)															b210 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b210 = (( (Float)(this125) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a36 = (a19 * (( (Float)(1) ) - a26));
HXDLIN(  35)														int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN(  35)														int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN(  35)														int b31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b112 * a36) + (b210 * a26))));
HXDLIN(  35)														int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN(  35)														int blended6 = ((((a20 << 24) | (r8 << 16)) | (g8 << 8)) | b31);
HXDLIN(  35)														{
HXLINE(  35)															int _hx_tmp31;
HXDLIN(  35)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)																_hx_tmp31 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            															}
            															else {
HXLINE(  35)																_hx_tmp31 = blended6;
            															}
HXDLIN(  35)															::iterMagic::Iimg_obj::set(undoImage9->image,location6,_hx_tmp31);
            														}
            													}
            													else {
HXLINE(  35)														::Dynamic this126 = undoImage9->image;
HXDLIN(  35)														int index20;
HXDLIN(  35)														if (undoImage9->useVirtualPos) {
HXLINE(  35)															index20 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x15) - undoImage9->virtualX));
            														}
            														else {
HXLINE(  35)															index20 = ::Std_obj::_hx_int(( (Float)(((y15 * undoImage9->width) + x15)) ));
            														}
HXDLIN(  35)														int _hx_tmp32;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp32 = ((((((c17 >> 24) & 255) << 24) | ((c17 & 255) << 16)) | (((c17 >> 8) & 255) << 8)) | ((c17 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp32 = c17;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this126,index20,_hx_tmp32);
            													}
            												}
            												else {
HXLINE(  35)													if (forceClear3) {
HXLINE(  35)														::Dynamic this127 = undoImage9->image;
HXDLIN(  35)														int x16 = (dx4 - rectLeft3);
HXDLIN(  35)														int y16 = (dy4 - rectTop3);
HXDLIN(  35)														int index21;
HXDLIN(  35)														if (undoImage9->useVirtualPos) {
HXLINE(  35)															index21 = ::Std_obj::_hx_int(((((( (Float)(y16) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x16) - undoImage9->virtualX));
            														}
            														else {
HXLINE(  35)															index21 = ::Std_obj::_hx_int(( (Float)(((y16 * undoImage9->width) + x16)) ));
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this127,index21,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						{
HXLINE(  35)							int _g_min6 = xIter33->start;
HXDLIN(  35)							int _g_max6 = xIter33->max;
HXDLIN(  35)							while((_g_min6 < _g_max6)){
HXLINE(  35)								_g_min6 = (_g_min6 + 1);
HXDLIN(  35)								int px3 = (_g_min6 - 1);
HXDLIN(  35)								Float pcx3 = (( (Float)(px3) ) - leftX);
HXDLIN(  35)								{
HXLINE(  35)									int _g_min7 = yIter33->start;
HXDLIN(  35)									int _g_max7 = yIter33->max;
HXDLIN(  35)									while((_g_min7 < _g_max7)){
HXLINE(  35)										_g_min7 = (_g_min7 + 1);
HXDLIN(  35)										int py3 = (_g_min7 - 1);
HXDLIN(  35)										Float pcy3 = (( (Float)(py3) ) - topY);
HXDLIN(  35)										Float dot313 = ((pcx3 * bcx3) + (pcy3 * bcy3));
HXDLIN(  35)										Float dot323 = ((pcx3 * acx3) + (pcy3 * acy3));
HXDLIN(  35)										Float ratioA3 = (((dot223 * dot313) - (dot123 * dot323)) * denom13);
HXDLIN(  35)										Float ratioB3 = (((dot113 * dot323) - (dot123 * dot313)) * denom13);
HXDLIN(  35)										Float ratioC3 = ((((Float)1.0) - ratioB3) - ratioA3);
HXDLIN(  35)										bool _hx_tmp33;
HXDLIN(  35)										bool _hx_tmp34;
HXDLIN(  35)										if ((ratioA3 >= 0)) {
HXLINE(  35)											_hx_tmp34 = (ratioB3 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp34 = false;
            										}
HXDLIN(  35)										if (_hx_tmp34) {
HXLINE(  35)											_hx_tmp33 = (ratioC3 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp33 = false;
            										}
HXDLIN(  35)										if (_hx_tmp33) {
HXLINE(  35)											Float u3 = (((au4 * ratioA3) + (bu4 * ratioB3)) + (au * ratioC3));
HXDLIN(  35)											Float v16 = (((av4 * ratioA3) + (bv3 * ratioB3)) + (cv * ratioC3));
HXDLIN(  35)											int x17 = ::Std_obj::_hx_int(((u3 * win_width) + win_x));
HXDLIN(  35)											int y17 = ::Std_obj::_hx_int(((v16 * win_height) + win_y));
HXDLIN(  35)											::Dynamic this128 = texture->image;
HXDLIN(  35)											int index22;
HXDLIN(  35)											if (texture->useVirtualPos) {
HXLINE(  35)												index22 = ::Std_obj::_hx_int(((((( (Float)(y17) ) - texture->virtualY) * ( (Float)(texture->width) )) + x17) - texture->virtualX));
            											}
            											else {
HXLINE(  35)												index22 = ::Std_obj::_hx_int(( (Float)(((y17 * texture->width) + x17)) ));
            											}
HXDLIN(  35)											int c18 = ::iterMagic::Iimg_obj::get(this128,index22);
HXDLIN(  35)											int col7;
HXDLIN(  35)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)												col7 = ((((((c18 >> 24) & 255) << 24) | ((c18 & 255) << 16)) | (((c18 >> 8) & 255) << 8)) | ((c18 >> 16) & 255));
            											}
            											else {
HXLINE(  35)												col7 = c18;
            											}
HXDLIN(  35)											{
HXLINE(  35)												int c19 = col7;
HXDLIN(  35)												bool _hx_tmp35;
HXDLIN(  35)												if ((((c19 >> 24) & 255) < 254)) {
HXLINE(  35)													_hx_tmp35 = temp->transparent;
            												}
            												else {
HXLINE(  35)													_hx_tmp35 = false;
            												}
HXDLIN(  35)												if (_hx_tmp35) {
HXLINE(  35)													int location7;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														location7 = ::Std_obj::_hx_int(((((( (Float)(py3) ) - temp->virtualY) * ( (Float)(temp->width) )) + px3) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														location7 = ::Std_obj::_hx_int(( (Float)(((py3 * temp->width) + px3)) ));
            													}
HXDLIN(  35)													int this129 = ::iterMagic::Iimg_obj::get(temp->image,location7);
HXDLIN(  35)													int this130;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														this130 = ((((((this129 >> 24) & 255) << 24) | ((this129 & 255) << 16)) | (((this129 >> 8) & 255) << 8)) | ((this129 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														this130 = this129;
            													}
HXDLIN(  35)													Float a110;
HXDLIN(  35)													int this131 = ((this130 >> 24) & 255);
HXDLIN(  35)													if ((this131 == 0)) {
HXLINE(  35)														a110 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a110 = (( (Float)(this131) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r17;
HXDLIN(  35)													int this132 = ((this130 >> 16) & 255);
HXDLIN(  35)													if ((this132 == 0)) {
HXLINE(  35)														r17 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r17 = (( (Float)(this132) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g17;
HXDLIN(  35)													int this133 = ((this130 >> 8) & 255);
HXDLIN(  35)													if ((this133 == 0)) {
HXLINE(  35)														g17 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g17 = (( (Float)(this133) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b113;
HXDLIN(  35)													int this134 = (this130 & 255);
HXDLIN(  35)													if ((this134 == 0)) {
HXLINE(  35)														b113 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b113 = (( (Float)(this134) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a27;
HXDLIN(  35)													int this135 = ((col7 >> 24) & 255);
HXDLIN(  35)													if ((this135 == 0)) {
HXLINE(  35)														a27 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a27 = (( (Float)(this135) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r27;
HXDLIN(  35)													int this136 = ((col7 >> 16) & 255);
HXDLIN(  35)													if ((this136 == 0)) {
HXLINE(  35)														r27 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r27 = (( (Float)(this136) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g27;
HXDLIN(  35)													int this137 = ((col7 >> 8) & 255);
HXDLIN(  35)													if ((this137 == 0)) {
HXLINE(  35)														g27 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g27 = (( (Float)(this137) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b211;
HXDLIN(  35)													int this138 = (col7 & 255);
HXDLIN(  35)													if ((this138 == 0)) {
HXLINE(  35)														b211 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b211 = (( (Float)(this138) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a37 = (a110 * (( (Float)(1) ) - a27));
HXDLIN(  35)													int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN(  35)													int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN(  35)													int b32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b113 * a37) + (b211 * a27))));
HXDLIN(  35)													int a28 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN(  35)													int blended7 = ((((a28 << 24) | (r9 << 16)) | (g9 << 8)) | b32);
HXDLIN(  35)													{
HXLINE(  35)														int _hx_tmp36;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp36 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp36 = blended7;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(temp->image,location7,_hx_tmp36);
            													}
            												}
            												else {
HXLINE(  35)													::Dynamic this139 = temp->image;
HXDLIN(  35)													int index23;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														index23 = ::Std_obj::_hx_int(((((( (Float)(py3) ) - temp->virtualY) * ( (Float)(temp->width) )) + px3) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														index23 = ::Std_obj::_hx_int(( (Float)(((py3 * temp->width) + px3)) ));
            													}
HXDLIN(  35)													int _hx_tmp37;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														_hx_tmp37 = ((((((c19 >> 24) & 255) << 24) | ((c19 & 255) << 16)) | (((c19 >> 8) & 255) << 8)) | ((c19 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														_hx_tmp37 = c19;
            													}
HXDLIN(  35)													::iterMagic::Iimg_obj::set(this139,index23,_hx_tmp37);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						if ((hasHit == false)) {
HXLINE(  35)							 ::pi_xy::algo::HitTri v17 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,rightX,( (Float)(0) ),rightX,topY,leftX,topY,true);
HXDLIN(  35)							if (hasUndo3) {
HXLINE(  35)								v17->undoImage = undoImage9;
HXDLIN(  35)								v17->undoX = xIter33->start;
HXDLIN(  35)								v17->undoY = yIter33->start;
            							}
            						}
            					}
HXDLIN(  35)					if ((hasHit == true)) {
HXLINE(  35)						 ::pi_xy::algo::HitQuad v18 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,leftX,( (Float)(0) ),rightX,( (Float)(0) ),rightX,topY,leftX,topY,true);
            					}
            				}
HXLINE( 250)				au = bu;
HXLINE( 251)				bu = ((Float)1.);
HXLINE(  35)				{
HXLINE(  35)					Float bx1 = widNew;
HXDLIN(  35)					Float cx1 = widNew;
HXDLIN(  35)					{
HXLINE(  35)						Float au5 = au;
HXDLIN(  35)						Float av5 = ((Float)0.);
HXDLIN(  35)						Float bu5 = bu;
HXDLIN(  35)						Float bv4 = ( (Float)(0) );
HXDLIN(  35)						bool hasUndo4 = false;
HXDLIN(  35)						Float temp5 = au5;
HXLINE( 422)						au5 = bu5;
HXLINE( 423)						bu5 = temp5;
HXLINE( 424)						temp5 = av5;
HXLINE( 425)						av5 = bv4;
HXLINE( 426)						bv4 = temp5;
HXLINE(  35)						Float bcx4 = (bx1 - rightX);
HXDLIN(  35)						Float bcy4 = (( (Float)(0) ) - topY);
HXDLIN(  35)						Float acx4 = (rightX - rightX);
HXDLIN(  35)						Float acy4 = (( (Float)(0) ) - topY);
HXDLIN(  35)						Float dot114 = ((bcx4 * bcx4) + (bcy4 * bcy4));
HXDLIN(  35)						Float dot124 = ((bcx4 * acx4) + (bcy4 * acy4));
HXDLIN(  35)						Float dot224 = ((acx4 * acx4) + (acy4 * acy4));
HXDLIN(  35)						Float denom14 = (( (Float)(1) ) / ((dot114 * dot224) - (dot124 * dot124)));
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart xIter34;
HXDLIN(  35)						if ((rightX > bx1)) {
HXLINE(  35)							if ((rightX > rightX)) {
HXLINE(  35)								int min12;
HXDLIN(  35)								if ((bx1 > rightX)) {
HXLINE(  35)									min12 = ::Math_obj::floor(rightX);
            								}
            								else {
HXLINE(  35)									min12 = ::Math_obj::floor(bx1);
            								}
HXDLIN(  35)								int ii_min27 = min12;
HXDLIN(  35)								int ii_max27 = ::Math_obj::ceil(rightX);
HXDLIN(  35)								xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            							}
            							else {
HXLINE(  35)								int ii_min28 = ::Math_obj::floor(bx1);
HXDLIN(  35)								int ii_max28 = ::Math_obj::ceil(rightX);
HXDLIN(  35)								xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            							}
            						}
            						else {
HXLINE(  35)							if ((bx1 > rightX)) {
HXLINE(  35)								int min13;
HXDLIN(  35)								if ((rightX > rightX)) {
HXLINE(  35)									min13 = ::Math_obj::floor(rightX);
            								}
            								else {
HXLINE(  35)									min13 = ::Math_obj::ceil(rightX);
            								}
HXDLIN(  35)								int ii_min29 = min13;
HXDLIN(  35)								int ii_max29 = ::Math_obj::ceil(bx1);
HXDLIN(  35)								xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            							}
            							else {
HXLINE(  35)								int ii_min30 = ::Math_obj::floor(rightX);
HXDLIN(  35)								int ii_max30 = ::Math_obj::ceil(rightX);
HXDLIN(  35)								xIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart yIter34;
HXDLIN(  35)						if ((0 > topY)) {
HXLINE(  35)							int min14;
HXDLIN(  35)							if ((0 > topY)) {
HXLINE(  35)								min14 = ::Math_obj::floor(topY);
            							}
            							else {
HXLINE(  35)								min14 = ::Math_obj::ceil(( (Float)(0) ));
            							}
HXDLIN(  35)							int ii_min31 = min14;
HXDLIN(  35)							int ii_max31 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  35)							yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            						}
            						else {
HXLINE(  35)							int ii_min32 = ::Math_obj::floor(( (Float)(0) ));
HXDLIN(  35)							int ii_max32 = ::Math_obj::ceil(topY);
HXDLIN(  35)							yIter34 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min32,ii_max32);
            						}
HXDLIN(  35)						 ::pi_xy::ImageStruct undoImage12 = null();
HXDLIN(  35)						if (hasUndo4) {
HXLINE(  35)							int width5 = ((xIter34->max - xIter34->start) + 1);
HXDLIN(  35)							int height5 = ((yIter34->max - yIter34->start) + 1);
HXDLIN(  35)							 ::Dynamic imageType5 = null();
HXDLIN(  35)							 ::pi_xy::ImageStruct this140 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  35)							if (::hx::IsNull( imageType5 )) {
HXLINE(  54)								imageType5 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE(  35)							::Dynamic undoImage13;
HXDLIN(  35)							switch((int)(( (int)(imageType5) ))){
            								case (int)0: {
HXLINE(  35)									 ::iterMagic::BytesImg byt5 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::BytesImg b33 = byt5;
HXDLIN(  35)									{
HXLINE(  35)										b33->width = width5;
HXDLIN(  35)										b33->height = height5;
HXDLIN(  35)										b33->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN(  35)										b33->data = ::haxe::io::Bytes_obj::alloc((b33->length * 4));
HXDLIN(  35)										{
HXLINE(  35)											int len10 = b33->length;
HXDLIN(  35)											int w5 = 0;
HXDLIN(  35)											{
HXLINE(  35)												int _g96 = 0;
HXDLIN(  35)												int _g97 = b33->height;
HXDLIN(  35)												while((_g96 < _g97)){
HXLINE(  35)													_g96 = (_g96 + 1);
HXDLIN(  35)													int y18 = (_g96 - 1);
HXDLIN(  35)													{
HXLINE(  35)														int _g98 = 0;
HXDLIN(  35)														int _g99 = b33->width;
HXDLIN(  35)														while((_g98 < _g99)){
HXLINE(  35)															_g98 = (_g98 + 1);
HXDLIN(  35)															int x18 = (_g98 - 1);
HXDLIN(  35)															{
HXLINE(  35)																w5 = (w5 + 1);
HXDLIN(  35)																b33->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w5 = (w5 + 1);
HXDLIN(  35)																b33->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w5 = (w5 + 1);
HXDLIN(  35)																b33->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w5 = (w5 + 1);
HXDLIN(  35)																b33->data->b[(w5 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage13 = b33;
            								}
            								break;
            								case (int)1: {
HXLINE(  35)									 ::iterMagic::ArrIntImg arrI5 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::ArrIntImg a29 = arrI5;
HXDLIN(  35)									{
HXLINE(  35)										a29->width = width5;
HXDLIN(  35)										a29->height = height5;
HXDLIN(  35)										a29->data = ::Array_obj< int >::__new(0);
HXDLIN(  35)										a29->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN(  35)										{
HXLINE(  35)											int _g100 = 0;
HXDLIN(  35)											int _g101 = a29->length;
HXDLIN(  35)											while((_g100 < _g101)){
HXLINE(  35)												_g100 = (_g100 + 1);
HXDLIN(  35)												int i30 = (_g100 - 1);
HXDLIN(  35)												a29->data[i30] = 0;
            											}
            										}
            									}
HXDLIN(  35)									undoImage13 = a29;
            								}
            								break;
            								case (int)2: {
HXLINE(  35)									 ::iterMagic::U32ArrImg u32a5 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::U32ArrImg b34 = u32a5;
HXDLIN(  35)									{
HXLINE(  35)										b34->width = width5;
HXDLIN(  35)										b34->height = height5;
HXDLIN(  35)										b34->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN(  35)										int size5 = (b34->length * 4);
HXDLIN(  35)										b34->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size5),0,size5);
HXDLIN(  35)										{
HXLINE(  35)											int _g102 = 0;
HXDLIN(  35)											int _g103 = b34->length;
HXDLIN(  35)											while((_g102 < _g103)){
HXLINE(  35)												_g102 = (_g102 + 1);
HXDLIN(  35)												int i31 = (_g102 - 1);
HXDLIN(  35)												{
HXLINE(  35)													 ::haxe::io::ArrayBufferViewImpl this141 = b34->data;
HXDLIN(  35)													bool undoImage14;
HXDLIN(  35)													if ((i31 >= 0)) {
HXLINE(  35)														undoImage14 = (i31 < (this141->byteLength >> 2));
            													}
            													else {
HXLINE(  35)														undoImage14 = false;
            													}
HXDLIN(  35)													if (undoImage14) {
HXLINE(  35)														 ::haxe::io::Bytes _this5 = this141->bytes;
HXDLIN(  35)														int pos5 = ((i31 << 2) + this141->byteOffset);
HXDLIN(  35)														_this5->b[pos5] = ( (unsigned char)(0) );
HXDLIN(  35)														_this5->b[(pos5 + 1)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this5->b[(pos5 + 2)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this5->b[(pos5 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage13 = b34;
            								}
            								break;
            								case (int)3: {
HXLINE(  35)									 ::iterMagic::VecIntImg vec5 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::VecIntImg v19 = vec5;
HXDLIN(  35)									{
HXLINE(  35)										v19->width = width5;
HXDLIN(  35)										v19->height = height5;
HXDLIN(  35)										v19->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN(  35)										v19->data = ::Array_obj< int >::__new(v19->length);
HXDLIN(  35)										{
HXLINE(  35)											int _g104 = 0;
HXDLIN(  35)											int _g105 = v19->length;
HXDLIN(  35)											while((_g104 < _g105)){
HXLINE(  35)												_g104 = (_g104 + 1);
HXDLIN(  35)												int i32 = (_g104 - 1);
HXDLIN(  35)												v19->data->__unsafe_set(i32,0);
            											}
            										}
            									}
HXDLIN(  35)									undoImage13 = v19;
            								}
            								break;
            								case (int)4: {
HXLINE(  35)									 ::iterMagic::StackIntImg sInt5 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::StackIntImg b35 = sInt5;
HXDLIN(  35)									{
HXLINE(  35)										b35->width = width5;
HXDLIN(  35)										b35->height = height5;
HXDLIN(  35)										b35->length = ::Std_obj::_hx_int(( (Float)((width5 * height5)) ));
HXDLIN(  35)										b35->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  35)										{
HXLINE(  35)											int len11 = b35->length;
HXDLIN(  35)											 ::haxe::ds::GenericStack_Int d5 = b35->data;
HXDLIN(  35)											if (::hx::IsNull( d5->head )) {
HXLINE(  35)												int _g106 = 0;
HXDLIN(  35)												int _g107 = len11;
HXDLIN(  35)												while((_g106 < _g107)){
HXLINE(  35)													_g106 = (_g106 + 1);
HXDLIN(  35)													int i33 = (_g106 - 1);
HXDLIN(  35)													d5->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d5->head);
            												}
            											}
            											else {
HXLINE(  35)												int _g108 = 0;
HXDLIN(  35)												int _g109 = len11;
HXDLIN(  35)												while((_g108 < _g109)){
HXLINE(  35)													_g108 = (_g108 + 1);
HXDLIN(  35)													int i34 = (_g108 - 1);
HXDLIN(  35)													{
HXLINE(  35)														 ::haxe::ds::GenericCell_Int l5 = b35->data->head;
HXDLIN(  35)														 ::haxe::ds::GenericCell_Int prev5 = null();
HXDLIN(  35)														{
HXLINE(  35)															int _g110 = 0;
HXDLIN(  35)															int _g111 = i34;
HXDLIN(  35)															while((_g110 < _g111)){
HXLINE(  35)																_g110 = (_g110 + 1);
HXDLIN(  35)																int i35 = (_g110 - 1);
HXLINE( 345)																prev5 = l5;
HXLINE( 346)																l5 = l5->next;
            															}
            														}
HXLINE(  35)														if (::hx::IsNull( prev5 )) {
HXLINE(  35)															b35->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN(  35)															l5 = null();
            														}
            														else {
HXLINE(  35)															prev5->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l5->next);
HXDLIN(  35)															l5 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage13 = b35;
            								}
            								break;
            							}
HXDLIN(  35)							this140->image = undoImage13;
HXDLIN(  35)							this140->width = width5;
HXDLIN(  35)							this140->height = height5;
HXDLIN(  35)							this140->imageType = ( (int)(imageType5) );
HXDLIN(  35)							undoImage12 = this140;
HXDLIN(  35)							{
HXLINE(  35)								int rectLeft4 = xIter34->start;
HXDLIN(  35)								int rectTop4 = yIter34->start;
HXDLIN(  35)								int rectRight4 = xIter34->max;
HXDLIN(  35)								bool forceClear4 = false;
HXDLIN(  35)								{
HXLINE(  35)									int _g112 = rectTop4;
HXDLIN(  35)									int _g113 = yIter34->max;
HXDLIN(  35)									while((_g112 < _g113)){
HXLINE(  35)										_g112 = (_g112 + 1);
HXDLIN(  35)										int dy5 = (_g112 - 1);
HXDLIN(  35)										{
HXLINE(  35)											int _g114 = rectLeft4;
HXDLIN(  35)											int _g115 = rectRight4;
HXDLIN(  35)											while((_g114 < _g115)){
HXLINE(  35)												_g114 = (_g114 + 1);
HXDLIN(  35)												int dx5 = (_g114 - 1);
HXDLIN(  35)												::Dynamic this142 = temp->image;
HXDLIN(  35)												int index24;
HXDLIN(  35)												if (temp->useVirtualPos) {
HXLINE(  35)													index24 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx5) - temp->virtualX));
            												}
            												else {
HXLINE(  35)													index24 = ::Std_obj::_hx_int(( (Float)(((dy5 * temp->width) + dx5)) ));
            												}
HXDLIN(  35)												int c20 = ::iterMagic::Iimg_obj::get(this142,index24);
HXDLIN(  35)												int col8;
HXDLIN(  35)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)													col8 = ((((((c20 >> 24) & 255) << 24) | ((c20 & 255) << 16)) | (((c20 >> 8) & 255) << 8)) | ((c20 >> 16) & 255));
            												}
            												else {
HXLINE(  35)													col8 = c20;
            												}
HXDLIN(  35)												bool _hx_tmp38;
HXDLIN(  35)												if (temp->useMask) {
HXLINE(  35)													_hx_tmp38 = ::hx::IsNotNull( temp->mask );
            												}
            												else {
HXLINE(  35)													_hx_tmp38 = false;
            												}
HXDLIN(  35)												if (_hx_tmp38) {
HXLINE(  35)													 ::pi_xy::ImageStruct this143 = temp->mask;
HXDLIN(  35)													::Dynamic this144 = this143->image;
HXDLIN(  35)													int index25;
HXDLIN(  35)													if (this143->useVirtualPos) {
HXLINE(  35)														index25 = ::Std_obj::_hx_int(((((( (Float)(dy5) ) - this143->virtualY) * ( (Float)(this143->width) )) + dx5) - this143->virtualX));
            													}
            													else {
HXLINE(  35)														index25 = ::Std_obj::_hx_int(( (Float)(((dy5 * this143->width) + dx5)) ));
            													}
HXDLIN(  35)													int c21 = ::iterMagic::Iimg_obj::get(this144,index25);
HXDLIN(  35)													int v20;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														v20 = ((((((c21 >> 24) & 255) << 24) | ((c21 & 255) << 16)) | (((c21 >> 8) & 255) << 8)) | ((c21 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														v20 = c21;
            													}
HXDLIN(  35)													int maskPixel4 = v20;
HXDLIN(  35)													int this145 = col8;
HXDLIN(  35)													if ((maskPixel4 == 0)) {
HXLINE(  35)														col8 = this145;
            													}
            													else {
HXLINE(  35)														Float m04;
HXDLIN(  35)														int this146 = ((maskPixel4 >> 24) & 255);
HXDLIN(  35)														if ((this146 == 0)) {
HXLINE(  35)															m04 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m04 = (( (Float)(this146) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m14;
HXDLIN(  35)														int this147 = ((maskPixel4 >> 16) & 255);
HXDLIN(  35)														if ((this147 == 0)) {
HXLINE(  35)															m14 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m14 = (( (Float)(this147) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m24;
HXDLIN(  35)														int this148 = ((maskPixel4 >> 8) & 255);
HXDLIN(  35)														if ((this148 == 0)) {
HXLINE(  35)															m24 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m24 = (( (Float)(this148) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m34;
HXDLIN(  35)														int this149 = (maskPixel4 & 255);
HXDLIN(  35)														if ((this149 == 0)) {
HXLINE(  35)															m34 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m34 = (( (Float)(this149) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														int ch04 = ::Std_obj::_hx_int(((((Float)1.) - m04) * ( (Float)(((this145 >> 24) & 255)) )));
HXDLIN(  35)														int ch14 = ::Std_obj::_hx_int(((((Float)1.) - m14) * ( (Float)(((this145 >> 16) & 255)) )));
HXDLIN(  35)														int ch24 = ::Std_obj::_hx_int(((((Float)1.) - m24) * ( (Float)(((this145 >> 8) & 255)) )));
HXDLIN(  35)														int ch34 = ::Std_obj::_hx_int(((((Float)1.) - m34) * ( (Float)((this145 & 255)) )));
HXDLIN(  35)														col8 = ((((::Math_obj::round((( (Float)(ch04) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch14) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch24) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch34) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  35)												if ((col8 != 0)) {
HXLINE(  35)													int x19 = (dx5 - rectLeft4);
HXDLIN(  35)													int y19 = (dy5 - rectTop4);
HXDLIN(  35)													int c22 = col8;
HXDLIN(  35)													bool _hx_tmp39;
HXDLIN(  35)													if ((((c22 >> 24) & 255) < 254)) {
HXLINE(  35)														_hx_tmp39 = undoImage12->transparent;
            													}
            													else {
HXLINE(  35)														_hx_tmp39 = false;
            													}
HXDLIN(  35)													if (_hx_tmp39) {
HXLINE(  35)														int location8;
HXDLIN(  35)														if (undoImage12->useVirtualPos) {
HXLINE(  35)															location8 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x19) - undoImage12->virtualX));
            														}
            														else {
HXLINE(  35)															location8 = ::Std_obj::_hx_int(( (Float)(((y19 * undoImage12->width) + x19)) ));
            														}
HXDLIN(  35)														int this150 = ::iterMagic::Iimg_obj::get(undoImage12->image,location8);
HXDLIN(  35)														int this151;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															this151 = ((((((this150 >> 24) & 255) << 24) | ((this150 & 255) << 16)) | (((this150 >> 8) & 255) << 8)) | ((this150 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															this151 = this150;
            														}
HXDLIN(  35)														Float a111;
HXDLIN(  35)														int this152 = ((this151 >> 24) & 255);
HXDLIN(  35)														if ((this152 == 0)) {
HXLINE(  35)															a111 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a111 = (( (Float)(this152) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r18;
HXDLIN(  35)														int this153 = ((this151 >> 16) & 255);
HXDLIN(  35)														if ((this153 == 0)) {
HXLINE(  35)															r18 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r18 = (( (Float)(this153) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g18;
HXDLIN(  35)														int this154 = ((this151 >> 8) & 255);
HXDLIN(  35)														if ((this154 == 0)) {
HXLINE(  35)															g18 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g18 = (( (Float)(this154) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b114;
HXDLIN(  35)														int this155 = (this151 & 255);
HXDLIN(  35)														if ((this155 == 0)) {
HXLINE(  35)															b114 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b114 = (( (Float)(this155) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a210;
HXDLIN(  35)														int this156 = ((col8 >> 24) & 255);
HXDLIN(  35)														if ((this156 == 0)) {
HXLINE(  35)															a210 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a210 = (( (Float)(this156) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r28;
HXDLIN(  35)														int this157 = ((col8 >> 16) & 255);
HXDLIN(  35)														if ((this157 == 0)) {
HXLINE(  35)															r28 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r28 = (( (Float)(this157) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g28;
HXDLIN(  35)														int this158 = ((col8 >> 8) & 255);
HXDLIN(  35)														if ((this158 == 0)) {
HXLINE(  35)															g28 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g28 = (( (Float)(this158) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b212;
HXDLIN(  35)														int this159 = (col8 & 255);
HXDLIN(  35)														if ((this159 == 0)) {
HXLINE(  35)															b212 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b212 = (( (Float)(this159) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a38 = (a111 * (( (Float)(1) ) - a210));
HXDLIN(  35)														int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r18 * a38) + (r28 * a210))));
HXDLIN(  35)														int g10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g18 * a38) + (g28 * a210))));
HXDLIN(  35)														int b36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b114 * a38) + (b212 * a210))));
HXDLIN(  35)														int a30 = ::Std_obj::_hx_int((( (Float)(255) ) * (a38 + a210)));
HXDLIN(  35)														int blended8 = ((((a30 << 24) | (r10 << 16)) | (g10 << 8)) | b36);
HXDLIN(  35)														{
HXLINE(  35)															int _hx_tmp40;
HXDLIN(  35)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)																_hx_tmp40 = ((((((blended8 >> 24) & 255) << 24) | ((blended8 & 255) << 16)) | (((blended8 >> 8) & 255) << 8)) | ((blended8 >> 16) & 255));
            															}
            															else {
HXLINE(  35)																_hx_tmp40 = blended8;
            															}
HXDLIN(  35)															::iterMagic::Iimg_obj::set(undoImage12->image,location8,_hx_tmp40);
            														}
            													}
            													else {
HXLINE(  35)														::Dynamic this160 = undoImage12->image;
HXDLIN(  35)														int index26;
HXDLIN(  35)														if (undoImage12->useVirtualPos) {
HXLINE(  35)															index26 = ::Std_obj::_hx_int(((((( (Float)(y19) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x19) - undoImage12->virtualX));
            														}
            														else {
HXLINE(  35)															index26 = ::Std_obj::_hx_int(( (Float)(((y19 * undoImage12->width) + x19)) ));
            														}
HXDLIN(  35)														int _hx_tmp41;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp41 = ((((((c22 >> 24) & 255) << 24) | ((c22 & 255) << 16)) | (((c22 >> 8) & 255) << 8)) | ((c22 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp41 = c22;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this160,index26,_hx_tmp41);
            													}
            												}
            												else {
HXLINE(  35)													if (forceClear4) {
HXLINE(  35)														::Dynamic this161 = undoImage12->image;
HXDLIN(  35)														int x20 = (dx5 - rectLeft4);
HXDLIN(  35)														int y20 = (dy5 - rectTop4);
HXDLIN(  35)														int index27;
HXDLIN(  35)														if (undoImage12->useVirtualPos) {
HXLINE(  35)															index27 = ::Std_obj::_hx_int(((((( (Float)(y20) ) - undoImage12->virtualY) * ( (Float)(undoImage12->width) )) + x20) - undoImage12->virtualX));
            														}
            														else {
HXLINE(  35)															index27 = ::Std_obj::_hx_int(( (Float)(((y20 * undoImage12->width) + x20)) ));
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this161,index27,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						{
HXLINE(  35)							int _g_min8 = xIter34->start;
HXDLIN(  35)							int _g_max8 = xIter34->max;
HXDLIN(  35)							while((_g_min8 < _g_max8)){
HXLINE(  35)								_g_min8 = (_g_min8 + 1);
HXDLIN(  35)								int px4 = (_g_min8 - 1);
HXDLIN(  35)								Float pcx4 = (( (Float)(px4) ) - rightX);
HXDLIN(  35)								{
HXLINE(  35)									int _g_min9 = yIter34->start;
HXDLIN(  35)									int _g_max9 = yIter34->max;
HXDLIN(  35)									while((_g_min9 < _g_max9)){
HXLINE(  35)										_g_min9 = (_g_min9 + 1);
HXDLIN(  35)										int py4 = (_g_min9 - 1);
HXDLIN(  35)										Float pcy4 = (( (Float)(py4) ) - topY);
HXDLIN(  35)										Float dot314 = ((pcx4 * bcx4) + (pcy4 * bcy4));
HXDLIN(  35)										Float dot324 = ((pcx4 * acx4) + (pcy4 * acy4));
HXDLIN(  35)										Float ratioA4 = (((dot224 * dot314) - (dot124 * dot324)) * denom14);
HXDLIN(  35)										Float ratioB4 = (((dot114 * dot324) - (dot124 * dot314)) * denom14);
HXDLIN(  35)										Float ratioC4 = ((((Float)1.0) - ratioB4) - ratioA4);
HXDLIN(  35)										bool _hx_tmp42;
HXDLIN(  35)										bool _hx_tmp43;
HXDLIN(  35)										if ((ratioA4 >= 0)) {
HXLINE(  35)											_hx_tmp43 = (ratioB4 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp43 = false;
            										}
HXDLIN(  35)										if (_hx_tmp43) {
HXLINE(  35)											_hx_tmp42 = (ratioC4 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp42 = false;
            										}
HXDLIN(  35)										if (_hx_tmp42) {
HXLINE(  35)											Float u4 = (((au5 * ratioA4) + (bu5 * ratioB4)) + (au * ratioC4));
HXDLIN(  35)											Float v21 = (((av5 * ratioA4) + (bv4 * ratioB4)) + (cv * ratioC4));
HXDLIN(  35)											int x21 = ::Std_obj::_hx_int(((u4 * win_width) + win_x));
HXDLIN(  35)											int y21 = ::Std_obj::_hx_int(((v21 * win_height) + win_y));
HXDLIN(  35)											::Dynamic this162 = texture->image;
HXDLIN(  35)											int index28;
HXDLIN(  35)											if (texture->useVirtualPos) {
HXLINE(  35)												index28 = ::Std_obj::_hx_int(((((( (Float)(y21) ) - texture->virtualY) * ( (Float)(texture->width) )) + x21) - texture->virtualX));
            											}
            											else {
HXLINE(  35)												index28 = ::Std_obj::_hx_int(( (Float)(((y21 * texture->width) + x21)) ));
            											}
HXDLIN(  35)											int c23 = ::iterMagic::Iimg_obj::get(this162,index28);
HXDLIN(  35)											int col9;
HXDLIN(  35)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)												col9 = ((((((c23 >> 24) & 255) << 24) | ((c23 & 255) << 16)) | (((c23 >> 8) & 255) << 8)) | ((c23 >> 16) & 255));
            											}
            											else {
HXLINE(  35)												col9 = c23;
            											}
HXDLIN(  35)											{
HXLINE(  35)												int c24 = col9;
HXDLIN(  35)												bool _hx_tmp44;
HXDLIN(  35)												if ((((c24 >> 24) & 255) < 254)) {
HXLINE(  35)													_hx_tmp44 = temp->transparent;
            												}
            												else {
HXLINE(  35)													_hx_tmp44 = false;
            												}
HXDLIN(  35)												if (_hx_tmp44) {
HXLINE(  35)													int location9;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														location9 = ::Std_obj::_hx_int(((((( (Float)(py4) ) - temp->virtualY) * ( (Float)(temp->width) )) + px4) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														location9 = ::Std_obj::_hx_int(( (Float)(((py4 * temp->width) + px4)) ));
            													}
HXDLIN(  35)													int this163 = ::iterMagic::Iimg_obj::get(temp->image,location9);
HXDLIN(  35)													int this164;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														this164 = ((((((this163 >> 24) & 255) << 24) | ((this163 & 255) << 16)) | (((this163 >> 8) & 255) << 8)) | ((this163 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														this164 = this163;
            													}
HXDLIN(  35)													Float a112;
HXDLIN(  35)													int this165 = ((this164 >> 24) & 255);
HXDLIN(  35)													if ((this165 == 0)) {
HXLINE(  35)														a112 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a112 = (( (Float)(this165) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r19;
HXDLIN(  35)													int this166 = ((this164 >> 16) & 255);
HXDLIN(  35)													if ((this166 == 0)) {
HXLINE(  35)														r19 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r19 = (( (Float)(this166) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g19;
HXDLIN(  35)													int this167 = ((this164 >> 8) & 255);
HXDLIN(  35)													if ((this167 == 0)) {
HXLINE(  35)														g19 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g19 = (( (Float)(this167) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b115;
HXDLIN(  35)													int this168 = (this164 & 255);
HXDLIN(  35)													if ((this168 == 0)) {
HXLINE(  35)														b115 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b115 = (( (Float)(this168) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a211;
HXDLIN(  35)													int this169 = ((col9 >> 24) & 255);
HXDLIN(  35)													if ((this169 == 0)) {
HXLINE(  35)														a211 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a211 = (( (Float)(this169) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r29;
HXDLIN(  35)													int this170 = ((col9 >> 16) & 255);
HXDLIN(  35)													if ((this170 == 0)) {
HXLINE(  35)														r29 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r29 = (( (Float)(this170) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g29;
HXDLIN(  35)													int this171 = ((col9 >> 8) & 255);
HXDLIN(  35)													if ((this171 == 0)) {
HXLINE(  35)														g29 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g29 = (( (Float)(this171) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b213;
HXDLIN(  35)													int this172 = (col9 & 255);
HXDLIN(  35)													if ((this172 == 0)) {
HXLINE(  35)														b213 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b213 = (( (Float)(this172) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a39 = (a112 * (( (Float)(1) ) - a211));
HXDLIN(  35)													int r20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r19 * a39) + (r29 * a211))));
HXDLIN(  35)													int g20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g19 * a39) + (g29 * a211))));
HXDLIN(  35)													int b37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b115 * a39) + (b213 * a211))));
HXDLIN(  35)													int a40 = ::Std_obj::_hx_int((( (Float)(255) ) * (a39 + a211)));
HXDLIN(  35)													int blended9 = ((((a40 << 24) | (r20 << 16)) | (g20 << 8)) | b37);
HXDLIN(  35)													{
HXLINE(  35)														int _hx_tmp45;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp45 = ((((((blended9 >> 24) & 255) << 24) | ((blended9 & 255) << 16)) | (((blended9 >> 8) & 255) << 8)) | ((blended9 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp45 = blended9;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(temp->image,location9,_hx_tmp45);
            													}
            												}
            												else {
HXLINE(  35)													::Dynamic this173 = temp->image;
HXDLIN(  35)													int index29;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														index29 = ::Std_obj::_hx_int(((((( (Float)(py4) ) - temp->virtualY) * ( (Float)(temp->width) )) + px4) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														index29 = ::Std_obj::_hx_int(( (Float)(((py4 * temp->width) + px4)) ));
            													}
HXDLIN(  35)													int _hx_tmp46;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														_hx_tmp46 = ((((((c24 >> 24) & 255) << 24) | ((c24 & 255) << 16)) | (((c24 >> 8) & 255) << 8)) | ((c24 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														_hx_tmp46 = c24;
            													}
HXDLIN(  35)													::iterMagic::Iimg_obj::set(this173,index29,_hx_tmp46);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						if ((hasHit == false)) {
HXLINE(  35)							 ::pi_xy::algo::HitTri v22 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,rightX,( (Float)(0) ),bx1,( (Float)(0) ),rightX,topY,true);
HXDLIN(  35)							if (hasUndo4) {
HXLINE(  35)								v22->undoImage = undoImage12;
HXDLIN(  35)								v22->undoX = xIter34->start;
HXDLIN(  35)								v22->undoY = yIter34->start;
            							}
            						}
            					}
HXDLIN(  35)					{
HXLINE(  35)						Float au6 = bu;
HXDLIN(  35)						Float av6 = ( (Float)(0) );
HXDLIN(  35)						Float bu6 = bu;
HXDLIN(  35)						Float bv5 = cv;
HXDLIN(  35)						bool hasUndo5 = false;
HXDLIN(  35)						Float temp6 = au6;
HXLINE( 422)						au6 = bu6;
HXLINE( 423)						bu6 = temp6;
HXLINE( 424)						temp6 = av6;
HXLINE( 425)						av6 = bv5;
HXLINE( 426)						bv5 = temp6;
HXLINE(  35)						Float bcx5 = (cx1 - rightX);
HXDLIN(  35)						Float bcy5 = (topY - topY);
HXDLIN(  35)						Float acx5 = (bx1 - rightX);
HXDLIN(  35)						Float acy5 = (( (Float)(0) ) - topY);
HXDLIN(  35)						Float dot115 = ((bcx5 * bcx5) + (bcy5 * bcy5));
HXDLIN(  35)						Float dot125 = ((bcx5 * acx5) + (bcy5 * acy5));
HXDLIN(  35)						Float dot225 = ((acx5 * acx5) + (acy5 * acy5));
HXDLIN(  35)						Float denom15 = (( (Float)(1) ) / ((dot115 * dot225) - (dot125 * dot125)));
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart xIter35;
HXDLIN(  35)						if ((bx1 > cx1)) {
HXLINE(  35)							if ((bx1 > rightX)) {
HXLINE(  35)								int min15;
HXDLIN(  35)								if ((cx1 > rightX)) {
HXLINE(  35)									min15 = ::Math_obj::floor(rightX);
            								}
            								else {
HXLINE(  35)									min15 = ::Math_obj::floor(cx1);
            								}
HXDLIN(  35)								int ii_min33 = min15;
HXDLIN(  35)								int ii_max33 = ::Math_obj::ceil(bx1);
HXDLIN(  35)								xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min33,ii_max33);
            							}
            							else {
HXLINE(  35)								int ii_min34 = ::Math_obj::floor(cx1);
HXDLIN(  35)								int ii_max34 = ::Math_obj::ceil(rightX);
HXDLIN(  35)								xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min34,ii_max34);
            							}
            						}
            						else {
HXLINE(  35)							if ((cx1 > rightX)) {
HXLINE(  35)								int min16;
HXDLIN(  35)								if ((bx1 > rightX)) {
HXLINE(  35)									min16 = ::Math_obj::floor(rightX);
            								}
            								else {
HXLINE(  35)									min16 = ::Math_obj::ceil(bx1);
            								}
HXDLIN(  35)								int ii_min35 = min16;
HXDLIN(  35)								int ii_max35 = ::Math_obj::ceil(cx1);
HXDLIN(  35)								xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min35,ii_max35);
            							}
            							else {
HXLINE(  35)								int ii_min36 = ::Math_obj::floor(bx1);
HXDLIN(  35)								int ii_max36 = ::Math_obj::ceil(rightX);
HXDLIN(  35)								xIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min36,ii_max36);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart yIter35;
HXDLIN(  35)						if ((0 > topY)) {
HXLINE(  35)							if ((0 > topY)) {
HXLINE(  35)								int min17;
HXDLIN(  35)								if ((topY > topY)) {
HXLINE(  35)									min17 = ::Math_obj::floor(topY);
            								}
            								else {
HXLINE(  35)									min17 = ::Math_obj::floor(topY);
            								}
HXDLIN(  35)								int ii_min37 = min17;
HXDLIN(  35)								int ii_max37 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  35)								yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min37,ii_max37);
            							}
            							else {
HXLINE(  35)								int ii_min38 = ::Math_obj::floor(topY);
HXDLIN(  35)								int ii_max38 = ::Math_obj::ceil(topY);
HXDLIN(  35)								yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min38,ii_max38);
            							}
            						}
            						else {
HXLINE(  35)							if ((topY > topY)) {
HXLINE(  35)								int min18;
HXDLIN(  35)								if ((0 > topY)) {
HXLINE(  35)									min18 = ::Math_obj::floor(topY);
            								}
            								else {
HXLINE(  35)									min18 = ::Math_obj::ceil(( (Float)(0) ));
            								}
HXDLIN(  35)								int ii_min39 = min18;
HXDLIN(  35)								int ii_max39 = ::Math_obj::ceil(topY);
HXDLIN(  35)								yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min39,ii_max39);
            							}
            							else {
HXLINE(  35)								int ii_min40 = ::Math_obj::floor(( (Float)(0) ));
HXDLIN(  35)								int ii_max40 = ::Math_obj::ceil(topY);
HXDLIN(  35)								yIter35 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min40,ii_max40);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::ImageStruct undoImage15 = null();
HXDLIN(  35)						if (hasUndo5) {
HXLINE(  35)							int width6 = ((xIter35->max - xIter35->start) + 1);
HXDLIN(  35)							int height6 = ((yIter35->max - yIter35->start) + 1);
HXDLIN(  35)							 ::Dynamic imageType6 = null();
HXDLIN(  35)							 ::pi_xy::ImageStruct this174 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  35)							if (::hx::IsNull( imageType6 )) {
HXLINE(  54)								imageType6 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE(  35)							::Dynamic undoImage16;
HXDLIN(  35)							switch((int)(( (int)(imageType6) ))){
            								case (int)0: {
HXLINE(  35)									 ::iterMagic::BytesImg byt6 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::BytesImg b38 = byt6;
HXDLIN(  35)									{
HXLINE(  35)										b38->width = width6;
HXDLIN(  35)										b38->height = height6;
HXDLIN(  35)										b38->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN(  35)										b38->data = ::haxe::io::Bytes_obj::alloc((b38->length * 4));
HXDLIN(  35)										{
HXLINE(  35)											int len12 = b38->length;
HXDLIN(  35)											int w6 = 0;
HXDLIN(  35)											{
HXLINE(  35)												int _g116 = 0;
HXDLIN(  35)												int _g117 = b38->height;
HXDLIN(  35)												while((_g116 < _g117)){
HXLINE(  35)													_g116 = (_g116 + 1);
HXDLIN(  35)													int y22 = (_g116 - 1);
HXDLIN(  35)													{
HXLINE(  35)														int _g118 = 0;
HXDLIN(  35)														int _g119 = b38->width;
HXDLIN(  35)														while((_g118 < _g119)){
HXLINE(  35)															_g118 = (_g118 + 1);
HXDLIN(  35)															int x22 = (_g118 - 1);
HXDLIN(  35)															{
HXLINE(  35)																w6 = (w6 + 1);
HXDLIN(  35)																b38->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w6 = (w6 + 1);
HXDLIN(  35)																b38->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w6 = (w6 + 1);
HXDLIN(  35)																b38->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w6 = (w6 + 1);
HXDLIN(  35)																b38->data->b[(w6 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage16 = b38;
            								}
            								break;
            								case (int)1: {
HXLINE(  35)									 ::iterMagic::ArrIntImg arrI6 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::ArrIntImg a41 = arrI6;
HXDLIN(  35)									{
HXLINE(  35)										a41->width = width6;
HXDLIN(  35)										a41->height = height6;
HXDLIN(  35)										a41->data = ::Array_obj< int >::__new(0);
HXDLIN(  35)										a41->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN(  35)										{
HXLINE(  35)											int _g120 = 0;
HXDLIN(  35)											int _g121 = a41->length;
HXDLIN(  35)											while((_g120 < _g121)){
HXLINE(  35)												_g120 = (_g120 + 1);
HXDLIN(  35)												int i36 = (_g120 - 1);
HXDLIN(  35)												a41->data[i36] = 0;
            											}
            										}
            									}
HXDLIN(  35)									undoImage16 = a41;
            								}
            								break;
            								case (int)2: {
HXLINE(  35)									 ::iterMagic::U32ArrImg u32a6 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::U32ArrImg b39 = u32a6;
HXDLIN(  35)									{
HXLINE(  35)										b39->width = width6;
HXDLIN(  35)										b39->height = height6;
HXDLIN(  35)										b39->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN(  35)										int size6 = (b39->length * 4);
HXDLIN(  35)										b39->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size6),0,size6);
HXDLIN(  35)										{
HXLINE(  35)											int _g122 = 0;
HXDLIN(  35)											int _g123 = b39->length;
HXDLIN(  35)											while((_g122 < _g123)){
HXLINE(  35)												_g122 = (_g122 + 1);
HXDLIN(  35)												int i37 = (_g122 - 1);
HXDLIN(  35)												{
HXLINE(  35)													 ::haxe::io::ArrayBufferViewImpl this175 = b39->data;
HXDLIN(  35)													bool undoImage17;
HXDLIN(  35)													if ((i37 >= 0)) {
HXLINE(  35)														undoImage17 = (i37 < (this175->byteLength >> 2));
            													}
            													else {
HXLINE(  35)														undoImage17 = false;
            													}
HXDLIN(  35)													if (undoImage17) {
HXLINE(  35)														 ::haxe::io::Bytes _this6 = this175->bytes;
HXDLIN(  35)														int pos6 = ((i37 << 2) + this175->byteOffset);
HXDLIN(  35)														_this6->b[pos6] = ( (unsigned char)(0) );
HXDLIN(  35)														_this6->b[(pos6 + 1)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this6->b[(pos6 + 2)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this6->b[(pos6 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage16 = b39;
            								}
            								break;
            								case (int)3: {
HXLINE(  35)									 ::iterMagic::VecIntImg vec6 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::VecIntImg v23 = vec6;
HXDLIN(  35)									{
HXLINE(  35)										v23->width = width6;
HXDLIN(  35)										v23->height = height6;
HXDLIN(  35)										v23->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN(  35)										v23->data = ::Array_obj< int >::__new(v23->length);
HXDLIN(  35)										{
HXLINE(  35)											int _g124 = 0;
HXDLIN(  35)											int _g125 = v23->length;
HXDLIN(  35)											while((_g124 < _g125)){
HXLINE(  35)												_g124 = (_g124 + 1);
HXDLIN(  35)												int i38 = (_g124 - 1);
HXDLIN(  35)												v23->data->__unsafe_set(i38,0);
            											}
            										}
            									}
HXDLIN(  35)									undoImage16 = v23;
            								}
            								break;
            								case (int)4: {
HXLINE(  35)									 ::iterMagic::StackIntImg sInt6 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::StackIntImg b40 = sInt6;
HXDLIN(  35)									{
HXLINE(  35)										b40->width = width6;
HXDLIN(  35)										b40->height = height6;
HXDLIN(  35)										b40->length = ::Std_obj::_hx_int(( (Float)((width6 * height6)) ));
HXDLIN(  35)										b40->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  35)										{
HXLINE(  35)											int len13 = b40->length;
HXDLIN(  35)											 ::haxe::ds::GenericStack_Int d6 = b40->data;
HXDLIN(  35)											if (::hx::IsNull( d6->head )) {
HXLINE(  35)												int _g126 = 0;
HXDLIN(  35)												int _g127 = len13;
HXDLIN(  35)												while((_g126 < _g127)){
HXLINE(  35)													_g126 = (_g126 + 1);
HXDLIN(  35)													int i39 = (_g126 - 1);
HXDLIN(  35)													d6->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d6->head);
            												}
            											}
            											else {
HXLINE(  35)												int _g128 = 0;
HXDLIN(  35)												int _g129 = len13;
HXDLIN(  35)												while((_g128 < _g129)){
HXLINE(  35)													_g128 = (_g128 + 1);
HXDLIN(  35)													int i40 = (_g128 - 1);
HXDLIN(  35)													{
HXLINE(  35)														 ::haxe::ds::GenericCell_Int l6 = b40->data->head;
HXDLIN(  35)														 ::haxe::ds::GenericCell_Int prev6 = null();
HXDLIN(  35)														{
HXLINE(  35)															int _g130 = 0;
HXDLIN(  35)															int _g131 = i40;
HXDLIN(  35)															while((_g130 < _g131)){
HXLINE(  35)																_g130 = (_g130 + 1);
HXDLIN(  35)																int i41 = (_g130 - 1);
HXLINE( 345)																prev6 = l6;
HXLINE( 346)																l6 = l6->next;
            															}
            														}
HXLINE(  35)														if (::hx::IsNull( prev6 )) {
HXLINE(  35)															b40->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN(  35)															l6 = null();
            														}
            														else {
HXLINE(  35)															prev6->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l6->next);
HXDLIN(  35)															l6 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage16 = b40;
            								}
            								break;
            							}
HXDLIN(  35)							this174->image = undoImage16;
HXDLIN(  35)							this174->width = width6;
HXDLIN(  35)							this174->height = height6;
HXDLIN(  35)							this174->imageType = ( (int)(imageType6) );
HXDLIN(  35)							undoImage15 = this174;
HXDLIN(  35)							{
HXLINE(  35)								int rectLeft5 = xIter35->start;
HXDLIN(  35)								int rectTop5 = yIter35->start;
HXDLIN(  35)								int rectRight5 = xIter35->max;
HXDLIN(  35)								bool forceClear5 = false;
HXDLIN(  35)								{
HXLINE(  35)									int _g132 = rectTop5;
HXDLIN(  35)									int _g133 = yIter35->max;
HXDLIN(  35)									while((_g132 < _g133)){
HXLINE(  35)										_g132 = (_g132 + 1);
HXDLIN(  35)										int dy6 = (_g132 - 1);
HXDLIN(  35)										{
HXLINE(  35)											int _g134 = rectLeft5;
HXDLIN(  35)											int _g135 = rectRight5;
HXDLIN(  35)											while((_g134 < _g135)){
HXLINE(  35)												_g134 = (_g134 + 1);
HXDLIN(  35)												int dx6 = (_g134 - 1);
HXDLIN(  35)												::Dynamic this176 = temp->image;
HXDLIN(  35)												int index30;
HXDLIN(  35)												if (temp->useVirtualPos) {
HXLINE(  35)													index30 = ::Std_obj::_hx_int(((((( (Float)(dy6) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx6) - temp->virtualX));
            												}
            												else {
HXLINE(  35)													index30 = ::Std_obj::_hx_int(( (Float)(((dy6 * temp->width) + dx6)) ));
            												}
HXDLIN(  35)												int c25 = ::iterMagic::Iimg_obj::get(this176,index30);
HXDLIN(  35)												int col10;
HXDLIN(  35)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)													col10 = ((((((c25 >> 24) & 255) << 24) | ((c25 & 255) << 16)) | (((c25 >> 8) & 255) << 8)) | ((c25 >> 16) & 255));
            												}
            												else {
HXLINE(  35)													col10 = c25;
            												}
HXDLIN(  35)												bool _hx_tmp47;
HXDLIN(  35)												if (temp->useMask) {
HXLINE(  35)													_hx_tmp47 = ::hx::IsNotNull( temp->mask );
            												}
            												else {
HXLINE(  35)													_hx_tmp47 = false;
            												}
HXDLIN(  35)												if (_hx_tmp47) {
HXLINE(  35)													 ::pi_xy::ImageStruct this177 = temp->mask;
HXDLIN(  35)													::Dynamic this178 = this177->image;
HXDLIN(  35)													int index31;
HXDLIN(  35)													if (this177->useVirtualPos) {
HXLINE(  35)														index31 = ::Std_obj::_hx_int(((((( (Float)(dy6) ) - this177->virtualY) * ( (Float)(this177->width) )) + dx6) - this177->virtualX));
            													}
            													else {
HXLINE(  35)														index31 = ::Std_obj::_hx_int(( (Float)(((dy6 * this177->width) + dx6)) ));
            													}
HXDLIN(  35)													int c26 = ::iterMagic::Iimg_obj::get(this178,index31);
HXDLIN(  35)													int v24;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														v24 = ((((((c26 >> 24) & 255) << 24) | ((c26 & 255) << 16)) | (((c26 >> 8) & 255) << 8)) | ((c26 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														v24 = c26;
            													}
HXDLIN(  35)													int maskPixel5 = v24;
HXDLIN(  35)													int this179 = col10;
HXDLIN(  35)													if ((maskPixel5 == 0)) {
HXLINE(  35)														col10 = this179;
            													}
            													else {
HXLINE(  35)														Float m05;
HXDLIN(  35)														int this180 = ((maskPixel5 >> 24) & 255);
HXDLIN(  35)														if ((this180 == 0)) {
HXLINE(  35)															m05 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m05 = (( (Float)(this180) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m15;
HXDLIN(  35)														int this181 = ((maskPixel5 >> 16) & 255);
HXDLIN(  35)														if ((this181 == 0)) {
HXLINE(  35)															m15 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m15 = (( (Float)(this181) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m25;
HXDLIN(  35)														int this182 = ((maskPixel5 >> 8) & 255);
HXDLIN(  35)														if ((this182 == 0)) {
HXLINE(  35)															m25 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m25 = (( (Float)(this182) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m35;
HXDLIN(  35)														int this183 = (maskPixel5 & 255);
HXDLIN(  35)														if ((this183 == 0)) {
HXLINE(  35)															m35 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m35 = (( (Float)(this183) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														int ch05 = ::Std_obj::_hx_int(((((Float)1.) - m05) * ( (Float)(((this179 >> 24) & 255)) )));
HXDLIN(  35)														int ch15 = ::Std_obj::_hx_int(((((Float)1.) - m15) * ( (Float)(((this179 >> 16) & 255)) )));
HXDLIN(  35)														int ch25 = ::Std_obj::_hx_int(((((Float)1.) - m25) * ( (Float)(((this179 >> 8) & 255)) )));
HXDLIN(  35)														int ch35 = ::Std_obj::_hx_int(((((Float)1.) - m35) * ( (Float)((this179 & 255)) )));
HXDLIN(  35)														col10 = ((((::Math_obj::round((( (Float)(ch05) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch15) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch25) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch35) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  35)												if ((col10 != 0)) {
HXLINE(  35)													int x23 = (dx6 - rectLeft5);
HXDLIN(  35)													int y23 = (dy6 - rectTop5);
HXDLIN(  35)													int c27 = col10;
HXDLIN(  35)													bool _hx_tmp48;
HXDLIN(  35)													if ((((c27 >> 24) & 255) < 254)) {
HXLINE(  35)														_hx_tmp48 = undoImage15->transparent;
            													}
            													else {
HXLINE(  35)														_hx_tmp48 = false;
            													}
HXDLIN(  35)													if (_hx_tmp48) {
HXLINE(  35)														int location10;
HXDLIN(  35)														if (undoImage15->useVirtualPos) {
HXLINE(  35)															location10 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x23) - undoImage15->virtualX));
            														}
            														else {
HXLINE(  35)															location10 = ::Std_obj::_hx_int(( (Float)(((y23 * undoImage15->width) + x23)) ));
            														}
HXDLIN(  35)														int this184 = ::iterMagic::Iimg_obj::get(undoImage15->image,location10);
HXDLIN(  35)														int this185;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															this185 = ((((((this184 >> 24) & 255) << 24) | ((this184 & 255) << 16)) | (((this184 >> 8) & 255) << 8)) | ((this184 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															this185 = this184;
            														}
HXDLIN(  35)														Float a113;
HXDLIN(  35)														int this186 = ((this185 >> 24) & 255);
HXDLIN(  35)														if ((this186 == 0)) {
HXLINE(  35)															a113 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a113 = (( (Float)(this186) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r110;
HXDLIN(  35)														int this187 = ((this185 >> 16) & 255);
HXDLIN(  35)														if ((this187 == 0)) {
HXLINE(  35)															r110 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r110 = (( (Float)(this187) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g110;
HXDLIN(  35)														int this188 = ((this185 >> 8) & 255);
HXDLIN(  35)														if ((this188 == 0)) {
HXLINE(  35)															g110 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g110 = (( (Float)(this188) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b116;
HXDLIN(  35)														int this189 = (this185 & 255);
HXDLIN(  35)														if ((this189 == 0)) {
HXLINE(  35)															b116 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b116 = (( (Float)(this189) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a212;
HXDLIN(  35)														int this190 = ((col10 >> 24) & 255);
HXDLIN(  35)														if ((this190 == 0)) {
HXLINE(  35)															a212 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a212 = (( (Float)(this190) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r210;
HXDLIN(  35)														int this191 = ((col10 >> 16) & 255);
HXDLIN(  35)														if ((this191 == 0)) {
HXLINE(  35)															r210 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r210 = (( (Float)(this191) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g210;
HXDLIN(  35)														int this192 = ((col10 >> 8) & 255);
HXDLIN(  35)														if ((this192 == 0)) {
HXLINE(  35)															g210 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g210 = (( (Float)(this192) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b214;
HXDLIN(  35)														int this193 = (col10 & 255);
HXDLIN(  35)														if ((this193 == 0)) {
HXLINE(  35)															b214 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b214 = (( (Float)(this193) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a310 = (a113 * (( (Float)(1) ) - a212));
HXDLIN(  35)														int r30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r110 * a310) + (r210 * a212))));
HXDLIN(  35)														int g30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g110 * a310) + (g210 * a212))));
HXDLIN(  35)														int b41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b116 * a310) + (b214 * a212))));
HXDLIN(  35)														int a42 = ::Std_obj::_hx_int((( (Float)(255) ) * (a310 + a212)));
HXDLIN(  35)														int blended10 = ((((a42 << 24) | (r30 << 16)) | (g30 << 8)) | b41);
HXDLIN(  35)														{
HXLINE(  35)															int _hx_tmp49;
HXDLIN(  35)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)																_hx_tmp49 = ((((((blended10 >> 24) & 255) << 24) | ((blended10 & 255) << 16)) | (((blended10 >> 8) & 255) << 8)) | ((blended10 >> 16) & 255));
            															}
            															else {
HXLINE(  35)																_hx_tmp49 = blended10;
            															}
HXDLIN(  35)															::iterMagic::Iimg_obj::set(undoImage15->image,location10,_hx_tmp49);
            														}
            													}
            													else {
HXLINE(  35)														::Dynamic this194 = undoImage15->image;
HXDLIN(  35)														int index32;
HXDLIN(  35)														if (undoImage15->useVirtualPos) {
HXLINE(  35)															index32 = ::Std_obj::_hx_int(((((( (Float)(y23) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x23) - undoImage15->virtualX));
            														}
            														else {
HXLINE(  35)															index32 = ::Std_obj::_hx_int(( (Float)(((y23 * undoImage15->width) + x23)) ));
            														}
HXDLIN(  35)														int _hx_tmp50;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp50 = ((((((c27 >> 24) & 255) << 24) | ((c27 & 255) << 16)) | (((c27 >> 8) & 255) << 8)) | ((c27 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp50 = c27;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this194,index32,_hx_tmp50);
            													}
            												}
            												else {
HXLINE(  35)													if (forceClear5) {
HXLINE(  35)														::Dynamic this195 = undoImage15->image;
HXDLIN(  35)														int x24 = (dx6 - rectLeft5);
HXDLIN(  35)														int y24 = (dy6 - rectTop5);
HXDLIN(  35)														int index33;
HXDLIN(  35)														if (undoImage15->useVirtualPos) {
HXLINE(  35)															index33 = ::Std_obj::_hx_int(((((( (Float)(y24) ) - undoImage15->virtualY) * ( (Float)(undoImage15->width) )) + x24) - undoImage15->virtualX));
            														}
            														else {
HXLINE(  35)															index33 = ::Std_obj::_hx_int(( (Float)(((y24 * undoImage15->width) + x24)) ));
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this195,index33,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						{
HXLINE(  35)							int _g_min10 = xIter35->start;
HXDLIN(  35)							int _g_max10 = xIter35->max;
HXDLIN(  35)							while((_g_min10 < _g_max10)){
HXLINE(  35)								_g_min10 = (_g_min10 + 1);
HXDLIN(  35)								int px5 = (_g_min10 - 1);
HXDLIN(  35)								Float pcx5 = (( (Float)(px5) ) - rightX);
HXDLIN(  35)								{
HXLINE(  35)									int _g_min11 = yIter35->start;
HXDLIN(  35)									int _g_max11 = yIter35->max;
HXDLIN(  35)									while((_g_min11 < _g_max11)){
HXLINE(  35)										_g_min11 = (_g_min11 + 1);
HXDLIN(  35)										int py5 = (_g_min11 - 1);
HXDLIN(  35)										Float pcy5 = (( (Float)(py5) ) - topY);
HXDLIN(  35)										Float dot315 = ((pcx5 * bcx5) + (pcy5 * bcy5));
HXDLIN(  35)										Float dot325 = ((pcx5 * acx5) + (pcy5 * acy5));
HXDLIN(  35)										Float ratioA5 = (((dot225 * dot315) - (dot125 * dot325)) * denom15);
HXDLIN(  35)										Float ratioB5 = (((dot115 * dot325) - (dot125 * dot315)) * denom15);
HXDLIN(  35)										Float ratioC5 = ((((Float)1.0) - ratioB5) - ratioA5);
HXDLIN(  35)										bool _hx_tmp51;
HXDLIN(  35)										bool _hx_tmp52;
HXDLIN(  35)										if ((ratioA5 >= 0)) {
HXLINE(  35)											_hx_tmp52 = (ratioB5 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp52 = false;
            										}
HXDLIN(  35)										if (_hx_tmp52) {
HXLINE(  35)											_hx_tmp51 = (ratioC5 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp51 = false;
            										}
HXDLIN(  35)										if (_hx_tmp51) {
HXLINE(  35)											Float u5 = (((au6 * ratioA5) + (bu6 * ratioB5)) + (au * ratioC5));
HXDLIN(  35)											Float v25 = (((av6 * ratioA5) + (bv5 * ratioB5)) + (cv * ratioC5));
HXDLIN(  35)											int x25 = ::Std_obj::_hx_int(((u5 * win_width) + win_x));
HXDLIN(  35)											int y25 = ::Std_obj::_hx_int(((v25 * win_height) + win_y));
HXDLIN(  35)											::Dynamic this196 = texture->image;
HXDLIN(  35)											int index34;
HXDLIN(  35)											if (texture->useVirtualPos) {
HXLINE(  35)												index34 = ::Std_obj::_hx_int(((((( (Float)(y25) ) - texture->virtualY) * ( (Float)(texture->width) )) + x25) - texture->virtualX));
            											}
            											else {
HXLINE(  35)												index34 = ::Std_obj::_hx_int(( (Float)(((y25 * texture->width) + x25)) ));
            											}
HXDLIN(  35)											int c28 = ::iterMagic::Iimg_obj::get(this196,index34);
HXDLIN(  35)											int col11;
HXDLIN(  35)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)												col11 = ((((((c28 >> 24) & 255) << 24) | ((c28 & 255) << 16)) | (((c28 >> 8) & 255) << 8)) | ((c28 >> 16) & 255));
            											}
            											else {
HXLINE(  35)												col11 = c28;
            											}
HXDLIN(  35)											{
HXLINE(  35)												int c29 = col11;
HXDLIN(  35)												bool _hx_tmp53;
HXDLIN(  35)												if ((((c29 >> 24) & 255) < 254)) {
HXLINE(  35)													_hx_tmp53 = temp->transparent;
            												}
            												else {
HXLINE(  35)													_hx_tmp53 = false;
            												}
HXDLIN(  35)												if (_hx_tmp53) {
HXLINE(  35)													int location11;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														location11 = ::Std_obj::_hx_int(((((( (Float)(py5) ) - temp->virtualY) * ( (Float)(temp->width) )) + px5) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														location11 = ::Std_obj::_hx_int(( (Float)(((py5 * temp->width) + px5)) ));
            													}
HXDLIN(  35)													int this197 = ::iterMagic::Iimg_obj::get(temp->image,location11);
HXDLIN(  35)													int this198;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														this198 = ((((((this197 >> 24) & 255) << 24) | ((this197 & 255) << 16)) | (((this197 >> 8) & 255) << 8)) | ((this197 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														this198 = this197;
            													}
HXDLIN(  35)													Float a114;
HXDLIN(  35)													int this199 = ((this198 >> 24) & 255);
HXDLIN(  35)													if ((this199 == 0)) {
HXLINE(  35)														a114 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a114 = (( (Float)(this199) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r111;
HXDLIN(  35)													int this200 = ((this198 >> 16) & 255);
HXDLIN(  35)													if ((this200 == 0)) {
HXLINE(  35)														r111 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r111 = (( (Float)(this200) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g111;
HXDLIN(  35)													int this201 = ((this198 >> 8) & 255);
HXDLIN(  35)													if ((this201 == 0)) {
HXLINE(  35)														g111 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g111 = (( (Float)(this201) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b117;
HXDLIN(  35)													int this202 = (this198 & 255);
HXDLIN(  35)													if ((this202 == 0)) {
HXLINE(  35)														b117 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b117 = (( (Float)(this202) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a213;
HXDLIN(  35)													int this203 = ((col11 >> 24) & 255);
HXDLIN(  35)													if ((this203 == 0)) {
HXLINE(  35)														a213 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a213 = (( (Float)(this203) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r211;
HXDLIN(  35)													int this204 = ((col11 >> 16) & 255);
HXDLIN(  35)													if ((this204 == 0)) {
HXLINE(  35)														r211 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r211 = (( (Float)(this204) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g211;
HXDLIN(  35)													int this205 = ((col11 >> 8) & 255);
HXDLIN(  35)													if ((this205 == 0)) {
HXLINE(  35)														g211 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g211 = (( (Float)(this205) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b215;
HXDLIN(  35)													int this206 = (col11 & 255);
HXDLIN(  35)													if ((this206 == 0)) {
HXLINE(  35)														b215 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b215 = (( (Float)(this206) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a311 = (a114 * (( (Float)(1) ) - a213));
HXDLIN(  35)													int r31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r111 * a311) + (r211 * a213))));
HXDLIN(  35)													int g31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g111 * a311) + (g211 * a213))));
HXDLIN(  35)													int b42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b117 * a311) + (b215 * a213))));
HXDLIN(  35)													int a43 = ::Std_obj::_hx_int((( (Float)(255) ) * (a311 + a213)));
HXDLIN(  35)													int blended11 = ((((a43 << 24) | (r31 << 16)) | (g31 << 8)) | b42);
HXDLIN(  35)													{
HXLINE(  35)														int _hx_tmp54;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp54 = ((((((blended11 >> 24) & 255) << 24) | ((blended11 & 255) << 16)) | (((blended11 >> 8) & 255) << 8)) | ((blended11 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp54 = blended11;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(temp->image,location11,_hx_tmp54);
            													}
            												}
            												else {
HXLINE(  35)													::Dynamic this207 = temp->image;
HXDLIN(  35)													int index35;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														index35 = ::Std_obj::_hx_int(((((( (Float)(py5) ) - temp->virtualY) * ( (Float)(temp->width) )) + px5) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														index35 = ::Std_obj::_hx_int(( (Float)(((py5 * temp->width) + px5)) ));
            													}
HXDLIN(  35)													int _hx_tmp55;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														_hx_tmp55 = ((((((c29 >> 24) & 255) << 24) | ((c29 & 255) << 16)) | (((c29 >> 8) & 255) << 8)) | ((c29 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														_hx_tmp55 = c29;
            													}
HXDLIN(  35)													::iterMagic::Iimg_obj::set(this207,index35,_hx_tmp55);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						if ((hasHit == false)) {
HXLINE(  35)							 ::pi_xy::algo::HitTri v26 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx1,( (Float)(0) ),cx1,topY,rightX,topY,true);
HXDLIN(  35)							if (hasUndo5) {
HXLINE(  35)								v26->undoImage = undoImage15;
HXDLIN(  35)								v26->undoX = xIter35->start;
HXDLIN(  35)								v26->undoY = yIter35->start;
            							}
            						}
            					}
HXDLIN(  35)					if ((hasHit == true)) {
HXLINE(  35)						 ::pi_xy::algo::HitQuad v27 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,rightX,( (Float)(0) ),bx1,( (Float)(0) ),cx1,topY,rightX,topY,true);
            					}
            				}
HXLINE( 258)				av = (top * sh);
HXLINE( 259)				bu = (left * sw);
HXLINE( 260)				cv = ((top + tall) * sh);
HXLINE(  35)				{
HXLINE(  35)					Float ay1 = (topY - ( (Float)(1) ));
HXDLIN(  35)					Float by1 = (topY - ( (Float)(1) ));
HXDLIN(  35)					Float cy1 = (bottomY + 1);
HXDLIN(  35)					{
HXLINE(  35)						Float au7 = ((Float)0.);
HXDLIN(  35)						Float av7 = av;
HXDLIN(  35)						Float bu7 = bu;
HXDLIN(  35)						Float bv6 = av;
HXDLIN(  35)						bool hasUndo6 = false;
HXDLIN(  35)						Float temp7 = au7;
HXLINE( 422)						au7 = bu7;
HXLINE( 423)						bu7 = temp7;
HXLINE( 424)						temp7 = av7;
HXLINE( 425)						av7 = bv6;
HXLINE( 426)						bv6 = temp7;
HXLINE(  35)						Float bcx6 = leftX;
HXDLIN(  35)						Float bcy6 = (by1 - bottomY);
HXDLIN(  35)						Float acx6 = ( (Float)(0) );
HXDLIN(  35)						Float acy6 = (ay1 - bottomY);
HXDLIN(  35)						Float dot116 = ((bcx6 * bcx6) + (bcy6 * bcy6));
HXDLIN(  35)						Float dot126 = ((bcx6 * acx6) + (bcy6 * acy6));
HXDLIN(  35)						Float dot226 = ((acx6 * acx6) + (acy6 * acy6));
HXDLIN(  35)						Float denom16 = (( (Float)(1) ) / ((dot116 * dot226) - (dot126 * dot126)));
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart xIter36;
HXDLIN(  35)						if ((0 > leftX)) {
HXLINE(  35)							int ii_min41 = ::Math_obj::floor(leftX);
HXDLIN(  35)							int ii_max41 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  35)							xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min41,ii_max41);
            						}
            						else {
HXLINE(  35)							if ((leftX > 0)) {
HXLINE(  35)								int ii_min42 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  35)								int ii_max42 = ::Math_obj::ceil(leftX);
HXDLIN(  35)								xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min42,ii_max42);
            							}
            							else {
HXLINE(  35)								int ii_min43 = ::Math_obj::floor(( (Float)(0) ));
HXDLIN(  35)								int ii_max43 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  35)								xIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min43,ii_max43);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart yIter36;
HXDLIN(  35)						if ((ay1 > by1)) {
HXLINE(  35)							if ((ay1 > bottomY)) {
HXLINE(  35)								int min19;
HXDLIN(  35)								if ((by1 > bottomY)) {
HXLINE(  35)									min19 = ::Math_obj::floor(bottomY);
            								}
            								else {
HXLINE(  35)									min19 = ::Math_obj::floor(by1);
            								}
HXDLIN(  35)								int ii_min44 = min19;
HXDLIN(  35)								int ii_max44 = ::Math_obj::ceil(ay1);
HXDLIN(  35)								yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min44,ii_max44);
            							}
            							else {
HXLINE(  35)								int ii_min45 = ::Math_obj::floor(by1);
HXDLIN(  35)								int ii_max45 = ::Math_obj::ceil(bottomY);
HXDLIN(  35)								yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min45,ii_max45);
            							}
            						}
            						else {
HXLINE(  35)							if ((by1 > bottomY)) {
HXLINE(  35)								int min20;
HXDLIN(  35)								if ((ay1 > bottomY)) {
HXLINE(  35)									min20 = ::Math_obj::floor(bottomY);
            								}
            								else {
HXLINE(  35)									min20 = ::Math_obj::ceil(ay1);
            								}
HXDLIN(  35)								int ii_min46 = min20;
HXDLIN(  35)								int ii_max46 = ::Math_obj::ceil(by1);
HXDLIN(  35)								yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min46,ii_max46);
            							}
            							else {
HXLINE(  35)								int ii_min47 = ::Math_obj::floor(ay1);
HXDLIN(  35)								int ii_max47 = ::Math_obj::ceil(bottomY);
HXDLIN(  35)								yIter36 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min47,ii_max47);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::ImageStruct undoImage18 = null();
HXDLIN(  35)						if (hasUndo6) {
HXLINE(  35)							int width7 = ((xIter36->max - xIter36->start) + 1);
HXDLIN(  35)							int height7 = ((yIter36->max - yIter36->start) + 1);
HXDLIN(  35)							 ::Dynamic imageType7 = null();
HXDLIN(  35)							 ::pi_xy::ImageStruct this208 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  35)							if (::hx::IsNull( imageType7 )) {
HXLINE(  54)								imageType7 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE(  35)							::Dynamic undoImage19;
HXDLIN(  35)							switch((int)(( (int)(imageType7) ))){
            								case (int)0: {
HXLINE(  35)									 ::iterMagic::BytesImg byt7 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::BytesImg b43 = byt7;
HXDLIN(  35)									{
HXLINE(  35)										b43->width = width7;
HXDLIN(  35)										b43->height = height7;
HXDLIN(  35)										b43->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN(  35)										b43->data = ::haxe::io::Bytes_obj::alloc((b43->length * 4));
HXDLIN(  35)										{
HXLINE(  35)											int len14 = b43->length;
HXDLIN(  35)											int w7 = 0;
HXDLIN(  35)											{
HXLINE(  35)												int _g136 = 0;
HXDLIN(  35)												int _g137 = b43->height;
HXDLIN(  35)												while((_g136 < _g137)){
HXLINE(  35)													_g136 = (_g136 + 1);
HXDLIN(  35)													int y26 = (_g136 - 1);
HXDLIN(  35)													{
HXLINE(  35)														int _g138 = 0;
HXDLIN(  35)														int _g139 = b43->width;
HXDLIN(  35)														while((_g138 < _g139)){
HXLINE(  35)															_g138 = (_g138 + 1);
HXDLIN(  35)															int x26 = (_g138 - 1);
HXDLIN(  35)															{
HXLINE(  35)																w7 = (w7 + 1);
HXDLIN(  35)																b43->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w7 = (w7 + 1);
HXDLIN(  35)																b43->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w7 = (w7 + 1);
HXDLIN(  35)																b43->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w7 = (w7 + 1);
HXDLIN(  35)																b43->data->b[(w7 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage19 = b43;
            								}
            								break;
            								case (int)1: {
HXLINE(  35)									 ::iterMagic::ArrIntImg arrI7 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::ArrIntImg a44 = arrI7;
HXDLIN(  35)									{
HXLINE(  35)										a44->width = width7;
HXDLIN(  35)										a44->height = height7;
HXDLIN(  35)										a44->data = ::Array_obj< int >::__new(0);
HXDLIN(  35)										a44->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN(  35)										{
HXLINE(  35)											int _g140 = 0;
HXDLIN(  35)											int _g141 = a44->length;
HXDLIN(  35)											while((_g140 < _g141)){
HXLINE(  35)												_g140 = (_g140 + 1);
HXDLIN(  35)												int i42 = (_g140 - 1);
HXDLIN(  35)												a44->data[i42] = 0;
            											}
            										}
            									}
HXDLIN(  35)									undoImage19 = a44;
            								}
            								break;
            								case (int)2: {
HXLINE(  35)									 ::iterMagic::U32ArrImg u32a7 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::U32ArrImg b44 = u32a7;
HXDLIN(  35)									{
HXLINE(  35)										b44->width = width7;
HXDLIN(  35)										b44->height = height7;
HXDLIN(  35)										b44->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN(  35)										int size7 = (b44->length * 4);
HXDLIN(  35)										b44->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size7),0,size7);
HXDLIN(  35)										{
HXLINE(  35)											int _g142 = 0;
HXDLIN(  35)											int _g143 = b44->length;
HXDLIN(  35)											while((_g142 < _g143)){
HXLINE(  35)												_g142 = (_g142 + 1);
HXDLIN(  35)												int i43 = (_g142 - 1);
HXDLIN(  35)												{
HXLINE(  35)													 ::haxe::io::ArrayBufferViewImpl this209 = b44->data;
HXDLIN(  35)													bool undoImage20;
HXDLIN(  35)													if ((i43 >= 0)) {
HXLINE(  35)														undoImage20 = (i43 < (this209->byteLength >> 2));
            													}
            													else {
HXLINE(  35)														undoImage20 = false;
            													}
HXDLIN(  35)													if (undoImage20) {
HXLINE(  35)														 ::haxe::io::Bytes _this7 = this209->bytes;
HXDLIN(  35)														int pos7 = ((i43 << 2) + this209->byteOffset);
HXDLIN(  35)														_this7->b[pos7] = ( (unsigned char)(0) );
HXDLIN(  35)														_this7->b[(pos7 + 1)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this7->b[(pos7 + 2)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this7->b[(pos7 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage19 = b44;
            								}
            								break;
            								case (int)3: {
HXLINE(  35)									 ::iterMagic::VecIntImg vec7 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::VecIntImg v28 = vec7;
HXDLIN(  35)									{
HXLINE(  35)										v28->width = width7;
HXDLIN(  35)										v28->height = height7;
HXDLIN(  35)										v28->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN(  35)										v28->data = ::Array_obj< int >::__new(v28->length);
HXDLIN(  35)										{
HXLINE(  35)											int _g144 = 0;
HXDLIN(  35)											int _g145 = v28->length;
HXDLIN(  35)											while((_g144 < _g145)){
HXLINE(  35)												_g144 = (_g144 + 1);
HXDLIN(  35)												int i44 = (_g144 - 1);
HXDLIN(  35)												v28->data->__unsafe_set(i44,0);
            											}
            										}
            									}
HXDLIN(  35)									undoImage19 = v28;
            								}
            								break;
            								case (int)4: {
HXLINE(  35)									 ::iterMagic::StackIntImg sInt7 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::StackIntImg b45 = sInt7;
HXDLIN(  35)									{
HXLINE(  35)										b45->width = width7;
HXDLIN(  35)										b45->height = height7;
HXDLIN(  35)										b45->length = ::Std_obj::_hx_int(( (Float)((width7 * height7)) ));
HXDLIN(  35)										b45->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  35)										{
HXLINE(  35)											int len15 = b45->length;
HXDLIN(  35)											 ::haxe::ds::GenericStack_Int d7 = b45->data;
HXDLIN(  35)											if (::hx::IsNull( d7->head )) {
HXLINE(  35)												int _g146 = 0;
HXDLIN(  35)												int _g147 = len15;
HXDLIN(  35)												while((_g146 < _g147)){
HXLINE(  35)													_g146 = (_g146 + 1);
HXDLIN(  35)													int i45 = (_g146 - 1);
HXDLIN(  35)													d7->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d7->head);
            												}
            											}
            											else {
HXLINE(  35)												int _g148 = 0;
HXDLIN(  35)												int _g149 = len15;
HXDLIN(  35)												while((_g148 < _g149)){
HXLINE(  35)													_g148 = (_g148 + 1);
HXDLIN(  35)													int i46 = (_g148 - 1);
HXDLIN(  35)													{
HXLINE(  35)														 ::haxe::ds::GenericCell_Int l7 = b45->data->head;
HXDLIN(  35)														 ::haxe::ds::GenericCell_Int prev7 = null();
HXDLIN(  35)														{
HXLINE(  35)															int _g150 = 0;
HXDLIN(  35)															int _g151 = i46;
HXDLIN(  35)															while((_g150 < _g151)){
HXLINE(  35)																_g150 = (_g150 + 1);
HXDLIN(  35)																int i47 = (_g150 - 1);
HXLINE( 345)																prev7 = l7;
HXLINE( 346)																l7 = l7->next;
            															}
            														}
HXLINE(  35)														if (::hx::IsNull( prev7 )) {
HXLINE(  35)															b45->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l7->next);
HXDLIN(  35)															l7 = null();
            														}
            														else {
HXLINE(  35)															prev7->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l7->next);
HXDLIN(  35)															l7 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage19 = b45;
            								}
            								break;
            							}
HXDLIN(  35)							this208->image = undoImage19;
HXDLIN(  35)							this208->width = width7;
HXDLIN(  35)							this208->height = height7;
HXDLIN(  35)							this208->imageType = ( (int)(imageType7) );
HXDLIN(  35)							undoImage18 = this208;
HXDLIN(  35)							{
HXLINE(  35)								int rectLeft6 = xIter36->start;
HXDLIN(  35)								int rectTop6 = yIter36->start;
HXDLIN(  35)								int rectRight6 = xIter36->max;
HXDLIN(  35)								bool forceClear6 = false;
HXDLIN(  35)								{
HXLINE(  35)									int _g152 = rectTop6;
HXDLIN(  35)									int _g153 = yIter36->max;
HXDLIN(  35)									while((_g152 < _g153)){
HXLINE(  35)										_g152 = (_g152 + 1);
HXDLIN(  35)										int dy7 = (_g152 - 1);
HXDLIN(  35)										{
HXLINE(  35)											int _g154 = rectLeft6;
HXDLIN(  35)											int _g155 = rectRight6;
HXDLIN(  35)											while((_g154 < _g155)){
HXLINE(  35)												_g154 = (_g154 + 1);
HXDLIN(  35)												int dx7 = (_g154 - 1);
HXDLIN(  35)												::Dynamic this210 = temp->image;
HXDLIN(  35)												int index36;
HXDLIN(  35)												if (temp->useVirtualPos) {
HXLINE(  35)													index36 = ::Std_obj::_hx_int(((((( (Float)(dy7) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx7) - temp->virtualX));
            												}
            												else {
HXLINE(  35)													index36 = ::Std_obj::_hx_int(( (Float)(((dy7 * temp->width) + dx7)) ));
            												}
HXDLIN(  35)												int c30 = ::iterMagic::Iimg_obj::get(this210,index36);
HXDLIN(  35)												int col12;
HXDLIN(  35)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)													col12 = ((((((c30 >> 24) & 255) << 24) | ((c30 & 255) << 16)) | (((c30 >> 8) & 255) << 8)) | ((c30 >> 16) & 255));
            												}
            												else {
HXLINE(  35)													col12 = c30;
            												}
HXDLIN(  35)												bool _hx_tmp56;
HXDLIN(  35)												if (temp->useMask) {
HXLINE(  35)													_hx_tmp56 = ::hx::IsNotNull( temp->mask );
            												}
            												else {
HXLINE(  35)													_hx_tmp56 = false;
            												}
HXDLIN(  35)												if (_hx_tmp56) {
HXLINE(  35)													 ::pi_xy::ImageStruct this211 = temp->mask;
HXDLIN(  35)													::Dynamic this212 = this211->image;
HXDLIN(  35)													int index37;
HXDLIN(  35)													if (this211->useVirtualPos) {
HXLINE(  35)														index37 = ::Std_obj::_hx_int(((((( (Float)(dy7) ) - this211->virtualY) * ( (Float)(this211->width) )) + dx7) - this211->virtualX));
            													}
            													else {
HXLINE(  35)														index37 = ::Std_obj::_hx_int(( (Float)(((dy7 * this211->width) + dx7)) ));
            													}
HXDLIN(  35)													int c31 = ::iterMagic::Iimg_obj::get(this212,index37);
HXDLIN(  35)													int v29;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														v29 = ((((((c31 >> 24) & 255) << 24) | ((c31 & 255) << 16)) | (((c31 >> 8) & 255) << 8)) | ((c31 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														v29 = c31;
            													}
HXDLIN(  35)													int maskPixel6 = v29;
HXDLIN(  35)													int this213 = col12;
HXDLIN(  35)													if ((maskPixel6 == 0)) {
HXLINE(  35)														col12 = this213;
            													}
            													else {
HXLINE(  35)														Float m06;
HXDLIN(  35)														int this214 = ((maskPixel6 >> 24) & 255);
HXDLIN(  35)														if ((this214 == 0)) {
HXLINE(  35)															m06 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m06 = (( (Float)(this214) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m16;
HXDLIN(  35)														int this215 = ((maskPixel6 >> 16) & 255);
HXDLIN(  35)														if ((this215 == 0)) {
HXLINE(  35)															m16 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m16 = (( (Float)(this215) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m26;
HXDLIN(  35)														int this216 = ((maskPixel6 >> 8) & 255);
HXDLIN(  35)														if ((this216 == 0)) {
HXLINE(  35)															m26 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m26 = (( (Float)(this216) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m36;
HXDLIN(  35)														int this217 = (maskPixel6 & 255);
HXDLIN(  35)														if ((this217 == 0)) {
HXLINE(  35)															m36 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m36 = (( (Float)(this217) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														int ch06 = ::Std_obj::_hx_int(((((Float)1.) - m06) * ( (Float)(((this213 >> 24) & 255)) )));
HXDLIN(  35)														int ch16 = ::Std_obj::_hx_int(((((Float)1.) - m16) * ( (Float)(((this213 >> 16) & 255)) )));
HXDLIN(  35)														int ch26 = ::Std_obj::_hx_int(((((Float)1.) - m26) * ( (Float)(((this213 >> 8) & 255)) )));
HXDLIN(  35)														int ch36 = ::Std_obj::_hx_int(((((Float)1.) - m36) * ( (Float)((this213 & 255)) )));
HXDLIN(  35)														col12 = ((((::Math_obj::round((( (Float)(ch06) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch16) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch26) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch36) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  35)												if ((col12 != 0)) {
HXLINE(  35)													int x27 = (dx7 - rectLeft6);
HXDLIN(  35)													int y27 = (dy7 - rectTop6);
HXDLIN(  35)													int c32 = col12;
HXDLIN(  35)													bool _hx_tmp57;
HXDLIN(  35)													if ((((c32 >> 24) & 255) < 254)) {
HXLINE(  35)														_hx_tmp57 = undoImage18->transparent;
            													}
            													else {
HXLINE(  35)														_hx_tmp57 = false;
            													}
HXDLIN(  35)													if (_hx_tmp57) {
HXLINE(  35)														int location12;
HXDLIN(  35)														if (undoImage18->useVirtualPos) {
HXLINE(  35)															location12 = ::Std_obj::_hx_int(((((( (Float)(y27) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x27) - undoImage18->virtualX));
            														}
            														else {
HXLINE(  35)															location12 = ::Std_obj::_hx_int(( (Float)(((y27 * undoImage18->width) + x27)) ));
            														}
HXDLIN(  35)														int this218 = ::iterMagic::Iimg_obj::get(undoImage18->image,location12);
HXDLIN(  35)														int this219;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															this219 = ((((((this218 >> 24) & 255) << 24) | ((this218 & 255) << 16)) | (((this218 >> 8) & 255) << 8)) | ((this218 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															this219 = this218;
            														}
HXDLIN(  35)														Float a115;
HXDLIN(  35)														int this220 = ((this219 >> 24) & 255);
HXDLIN(  35)														if ((this220 == 0)) {
HXLINE(  35)															a115 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a115 = (( (Float)(this220) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r112;
HXDLIN(  35)														int this221 = ((this219 >> 16) & 255);
HXDLIN(  35)														if ((this221 == 0)) {
HXLINE(  35)															r112 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r112 = (( (Float)(this221) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g112;
HXDLIN(  35)														int this222 = ((this219 >> 8) & 255);
HXDLIN(  35)														if ((this222 == 0)) {
HXLINE(  35)															g112 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g112 = (( (Float)(this222) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b118;
HXDLIN(  35)														int this223 = (this219 & 255);
HXDLIN(  35)														if ((this223 == 0)) {
HXLINE(  35)															b118 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b118 = (( (Float)(this223) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a214;
HXDLIN(  35)														int this224 = ((col12 >> 24) & 255);
HXDLIN(  35)														if ((this224 == 0)) {
HXLINE(  35)															a214 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a214 = (( (Float)(this224) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r212;
HXDLIN(  35)														int this225 = ((col12 >> 16) & 255);
HXDLIN(  35)														if ((this225 == 0)) {
HXLINE(  35)															r212 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r212 = (( (Float)(this225) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g212;
HXDLIN(  35)														int this226 = ((col12 >> 8) & 255);
HXDLIN(  35)														if ((this226 == 0)) {
HXLINE(  35)															g212 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g212 = (( (Float)(this226) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b216;
HXDLIN(  35)														int this227 = (col12 & 255);
HXDLIN(  35)														if ((this227 == 0)) {
HXLINE(  35)															b216 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b216 = (( (Float)(this227) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a312 = (a115 * (( (Float)(1) ) - a214));
HXDLIN(  35)														int r32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r112 * a312) + (r212 * a214))));
HXDLIN(  35)														int g32 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g112 * a312) + (g212 * a214))));
HXDLIN(  35)														int b46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b118 * a312) + (b216 * a214))));
HXDLIN(  35)														int a45 = ::Std_obj::_hx_int((( (Float)(255) ) * (a312 + a214)));
HXDLIN(  35)														int blended12 = ((((a45 << 24) | (r32 << 16)) | (g32 << 8)) | b46);
HXDLIN(  35)														{
HXLINE(  35)															int _hx_tmp58;
HXDLIN(  35)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)																_hx_tmp58 = ((((((blended12 >> 24) & 255) << 24) | ((blended12 & 255) << 16)) | (((blended12 >> 8) & 255) << 8)) | ((blended12 >> 16) & 255));
            															}
            															else {
HXLINE(  35)																_hx_tmp58 = blended12;
            															}
HXDLIN(  35)															::iterMagic::Iimg_obj::set(undoImage18->image,location12,_hx_tmp58);
            														}
            													}
            													else {
HXLINE(  35)														::Dynamic this228 = undoImage18->image;
HXDLIN(  35)														int index38;
HXDLIN(  35)														if (undoImage18->useVirtualPos) {
HXLINE(  35)															index38 = ::Std_obj::_hx_int(((((( (Float)(y27) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x27) - undoImage18->virtualX));
            														}
            														else {
HXLINE(  35)															index38 = ::Std_obj::_hx_int(( (Float)(((y27 * undoImage18->width) + x27)) ));
            														}
HXDLIN(  35)														int _hx_tmp59;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp59 = ((((((c32 >> 24) & 255) << 24) | ((c32 & 255) << 16)) | (((c32 >> 8) & 255) << 8)) | ((c32 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp59 = c32;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this228,index38,_hx_tmp59);
            													}
            												}
            												else {
HXLINE(  35)													if (forceClear6) {
HXLINE(  35)														::Dynamic this229 = undoImage18->image;
HXDLIN(  35)														int x28 = (dx7 - rectLeft6);
HXDLIN(  35)														int y28 = (dy7 - rectTop6);
HXDLIN(  35)														int index39;
HXDLIN(  35)														if (undoImage18->useVirtualPos) {
HXLINE(  35)															index39 = ::Std_obj::_hx_int(((((( (Float)(y28) ) - undoImage18->virtualY) * ( (Float)(undoImage18->width) )) + x28) - undoImage18->virtualX));
            														}
            														else {
HXLINE(  35)															index39 = ::Std_obj::_hx_int(( (Float)(((y28 * undoImage18->width) + x28)) ));
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this229,index39,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						{
HXLINE(  35)							int _g_min12 = xIter36->start;
HXDLIN(  35)							int _g_max12 = xIter36->max;
HXDLIN(  35)							while((_g_min12 < _g_max12)){
HXLINE(  35)								_g_min12 = (_g_min12 + 1);
HXDLIN(  35)								int px6 = (_g_min12 - 1);
HXDLIN(  35)								Float pcx6 = ( (Float)(px6) );
HXDLIN(  35)								{
HXLINE(  35)									int _g_min13 = yIter36->start;
HXDLIN(  35)									int _g_max13 = yIter36->max;
HXDLIN(  35)									while((_g_min13 < _g_max13)){
HXLINE(  35)										_g_min13 = (_g_min13 + 1);
HXDLIN(  35)										int py6 = (_g_min13 - 1);
HXDLIN(  35)										Float pcy6 = (( (Float)(py6) ) - bottomY);
HXDLIN(  35)										Float dot316 = ((pcx6 * bcx6) + (pcy6 * bcy6));
HXDLIN(  35)										Float dot326 = ((pcx6 * acx6) + (pcy6 * acy6));
HXDLIN(  35)										Float ratioA6 = (((dot226 * dot316) - (dot126 * dot326)) * denom16);
HXDLIN(  35)										Float ratioB6 = (((dot116 * dot326) - (dot126 * dot316)) * denom16);
HXDLIN(  35)										Float ratioC6 = ((((Float)1.0) - ratioB6) - ratioA6);
HXDLIN(  35)										bool _hx_tmp60;
HXDLIN(  35)										bool _hx_tmp61;
HXDLIN(  35)										if ((ratioA6 >= 0)) {
HXLINE(  35)											_hx_tmp61 = (ratioB6 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp61 = false;
            										}
HXDLIN(  35)										if (_hx_tmp61) {
HXLINE(  35)											_hx_tmp60 = (ratioC6 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp60 = false;
            										}
HXDLIN(  35)										if (_hx_tmp60) {
HXLINE(  35)											Float u6 = (((au7 * ratioA6) + (bu7 * ratioB6)) + (((Float)0.) * ratioC6));
HXDLIN(  35)											Float v30 = (((av7 * ratioA6) + (bv6 * ratioB6)) + (cv * ratioC6));
HXDLIN(  35)											int x29 = ::Std_obj::_hx_int(((u6 * win_width) + win_x));
HXDLIN(  35)											int y29 = ::Std_obj::_hx_int(((v30 * win_height) + win_y));
HXDLIN(  35)											::Dynamic this230 = texture->image;
HXDLIN(  35)											int index40;
HXDLIN(  35)											if (texture->useVirtualPos) {
HXLINE(  35)												index40 = ::Std_obj::_hx_int(((((( (Float)(y29) ) - texture->virtualY) * ( (Float)(texture->width) )) + x29) - texture->virtualX));
            											}
            											else {
HXLINE(  35)												index40 = ::Std_obj::_hx_int(( (Float)(((y29 * texture->width) + x29)) ));
            											}
HXDLIN(  35)											int c33 = ::iterMagic::Iimg_obj::get(this230,index40);
HXDLIN(  35)											int col13;
HXDLIN(  35)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)												col13 = ((((((c33 >> 24) & 255) << 24) | ((c33 & 255) << 16)) | (((c33 >> 8) & 255) << 8)) | ((c33 >> 16) & 255));
            											}
            											else {
HXLINE(  35)												col13 = c33;
            											}
HXDLIN(  35)											{
HXLINE(  35)												int c34 = col13;
HXDLIN(  35)												bool _hx_tmp62;
HXDLIN(  35)												if ((((c34 >> 24) & 255) < 254)) {
HXLINE(  35)													_hx_tmp62 = temp->transparent;
            												}
            												else {
HXLINE(  35)													_hx_tmp62 = false;
            												}
HXDLIN(  35)												if (_hx_tmp62) {
HXLINE(  35)													int location13;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														location13 = ::Std_obj::_hx_int(((((( (Float)(py6) ) - temp->virtualY) * ( (Float)(temp->width) )) + px6) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														location13 = ::Std_obj::_hx_int(( (Float)(((py6 * temp->width) + px6)) ));
            													}
HXDLIN(  35)													int this231 = ::iterMagic::Iimg_obj::get(temp->image,location13);
HXDLIN(  35)													int this232;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														this232 = ((((((this231 >> 24) & 255) << 24) | ((this231 & 255) << 16)) | (((this231 >> 8) & 255) << 8)) | ((this231 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														this232 = this231;
            													}
HXDLIN(  35)													Float a116;
HXDLIN(  35)													int this233 = ((this232 >> 24) & 255);
HXDLIN(  35)													if ((this233 == 0)) {
HXLINE(  35)														a116 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a116 = (( (Float)(this233) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r113;
HXDLIN(  35)													int this234 = ((this232 >> 16) & 255);
HXDLIN(  35)													if ((this234 == 0)) {
HXLINE(  35)														r113 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r113 = (( (Float)(this234) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g113;
HXDLIN(  35)													int this235 = ((this232 >> 8) & 255);
HXDLIN(  35)													if ((this235 == 0)) {
HXLINE(  35)														g113 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g113 = (( (Float)(this235) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b119;
HXDLIN(  35)													int this236 = (this232 & 255);
HXDLIN(  35)													if ((this236 == 0)) {
HXLINE(  35)														b119 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b119 = (( (Float)(this236) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a215;
HXDLIN(  35)													int this237 = ((col13 >> 24) & 255);
HXDLIN(  35)													if ((this237 == 0)) {
HXLINE(  35)														a215 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a215 = (( (Float)(this237) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r213;
HXDLIN(  35)													int this238 = ((col13 >> 16) & 255);
HXDLIN(  35)													if ((this238 == 0)) {
HXLINE(  35)														r213 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r213 = (( (Float)(this238) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g213;
HXDLIN(  35)													int this239 = ((col13 >> 8) & 255);
HXDLIN(  35)													if ((this239 == 0)) {
HXLINE(  35)														g213 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g213 = (( (Float)(this239) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b217;
HXDLIN(  35)													int this240 = (col13 & 255);
HXDLIN(  35)													if ((this240 == 0)) {
HXLINE(  35)														b217 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b217 = (( (Float)(this240) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a313 = (a116 * (( (Float)(1) ) - a215));
HXDLIN(  35)													int r33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r113 * a313) + (r213 * a215))));
HXDLIN(  35)													int g33 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g113 * a313) + (g213 * a215))));
HXDLIN(  35)													int b47 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b119 * a313) + (b217 * a215))));
HXDLIN(  35)													int a46 = ::Std_obj::_hx_int((( (Float)(255) ) * (a313 + a215)));
HXDLIN(  35)													int blended13 = ((((a46 << 24) | (r33 << 16)) | (g33 << 8)) | b47);
HXDLIN(  35)													{
HXLINE(  35)														int _hx_tmp63;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp63 = ((((((blended13 >> 24) & 255) << 24) | ((blended13 & 255) << 16)) | (((blended13 >> 8) & 255) << 8)) | ((blended13 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp63 = blended13;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(temp->image,location13,_hx_tmp63);
            													}
            												}
            												else {
HXLINE(  35)													::Dynamic this241 = temp->image;
HXDLIN(  35)													int index41;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														index41 = ::Std_obj::_hx_int(((((( (Float)(py6) ) - temp->virtualY) * ( (Float)(temp->width) )) + px6) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														index41 = ::Std_obj::_hx_int(( (Float)(((py6 * temp->width) + px6)) ));
            													}
HXDLIN(  35)													int _hx_tmp64;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														_hx_tmp64 = ((((((c34 >> 24) & 255) << 24) | ((c34 & 255) << 16)) | (((c34 >> 8) & 255) << 8)) | ((c34 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														_hx_tmp64 = c34;
            													}
HXDLIN(  35)													::iterMagic::Iimg_obj::set(this241,index41,_hx_tmp64);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						if ((hasHit == false)) {
HXLINE(  35)							 ::pi_xy::algo::HitTri v31 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,( (Float)(0) ),ay1,leftX,by1,( (Float)(0) ),bottomY,true);
HXDLIN(  35)							if (hasUndo6) {
HXLINE(  35)								v31->undoImage = undoImage18;
HXDLIN(  35)								v31->undoX = xIter36->start;
HXDLIN(  35)								v31->undoY = yIter36->start;
            							}
            						}
            					}
HXDLIN(  35)					{
HXLINE(  35)						Float au8 = bu;
HXDLIN(  35)						Float av8 = av;
HXDLIN(  35)						Float bu8 = bu;
HXDLIN(  35)						Float bv7 = cv;
HXDLIN(  35)						bool hasUndo7 = false;
HXDLIN(  35)						Float temp8 = au8;
HXLINE( 422)						au8 = bu8;
HXLINE( 423)						bu8 = temp8;
HXLINE( 424)						temp8 = av8;
HXLINE( 425)						av8 = bv7;
HXLINE( 426)						bv7 = temp8;
HXLINE(  35)						Float bcx7 = leftX;
HXDLIN(  35)						Float bcy7 = (cy1 - bottomY);
HXDLIN(  35)						Float acx7 = leftX;
HXDLIN(  35)						Float acy7 = (by1 - bottomY);
HXDLIN(  35)						Float dot117 = ((bcx7 * bcx7) + (bcy7 * bcy7));
HXDLIN(  35)						Float dot127 = ((bcx7 * acx7) + (bcy7 * acy7));
HXDLIN(  35)						Float dot227 = ((acx7 * acx7) + (acy7 * acy7));
HXDLIN(  35)						Float denom17 = (( (Float)(1) ) / ((dot117 * dot227) - (dot127 * dot127)));
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart xIter37;
HXDLIN(  35)						if ((leftX > leftX)) {
HXLINE(  35)							if ((leftX > 0)) {
HXLINE(  35)								int min21;
HXDLIN(  35)								if ((leftX > 0)) {
HXLINE(  35)									min21 = ::Math_obj::floor(( (Float)(0) ));
            								}
            								else {
HXLINE(  35)									min21 = ::Math_obj::floor(leftX);
            								}
HXDLIN(  35)								int ii_min48 = min21;
HXDLIN(  35)								int ii_max48 = ::Math_obj::ceil(leftX);
HXDLIN(  35)								xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min48,ii_max48);
            							}
            							else {
HXLINE(  35)								int ii_min49 = ::Math_obj::floor(leftX);
HXDLIN(  35)								int ii_max49 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  35)								xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min49,ii_max49);
            							}
            						}
            						else {
HXLINE(  35)							if ((leftX > 0)) {
HXLINE(  35)								int min22;
HXDLIN(  35)								if ((leftX > 0)) {
HXLINE(  35)									min22 = ::Math_obj::floor(( (Float)(0) ));
            								}
            								else {
HXLINE(  35)									min22 = ::Math_obj::ceil(leftX);
            								}
HXDLIN(  35)								int ii_min50 = min22;
HXDLIN(  35)								int ii_max50 = ::Math_obj::ceil(leftX);
HXDLIN(  35)								xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min50,ii_max50);
            							}
            							else {
HXLINE(  35)								int ii_min51 = ::Math_obj::floor(leftX);
HXDLIN(  35)								int ii_max51 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  35)								xIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min51,ii_max51);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart yIter37;
HXDLIN(  35)						if ((by1 > cy1)) {
HXLINE(  35)							if ((by1 > bottomY)) {
HXLINE(  35)								int min23;
HXDLIN(  35)								if ((cy1 > bottomY)) {
HXLINE(  35)									min23 = ::Math_obj::floor(bottomY);
            								}
            								else {
HXLINE(  35)									min23 = ::Math_obj::floor(cy1);
            								}
HXDLIN(  35)								int ii_min52 = min23;
HXDLIN(  35)								int ii_max52 = ::Math_obj::ceil(by1);
HXDLIN(  35)								yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min52,ii_max52);
            							}
            							else {
HXLINE(  35)								int ii_min53 = ::Math_obj::floor(cy1);
HXDLIN(  35)								int ii_max53 = ::Math_obj::ceil(bottomY);
HXDLIN(  35)								yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min53,ii_max53);
            							}
            						}
            						else {
HXLINE(  35)							if ((cy1 > bottomY)) {
HXLINE(  35)								int min24;
HXDLIN(  35)								if ((by1 > bottomY)) {
HXLINE(  35)									min24 = ::Math_obj::floor(bottomY);
            								}
            								else {
HXLINE(  35)									min24 = ::Math_obj::ceil(by1);
            								}
HXDLIN(  35)								int ii_min54 = min24;
HXDLIN(  35)								int ii_max54 = ::Math_obj::ceil(cy1);
HXDLIN(  35)								yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min54,ii_max54);
            							}
            							else {
HXLINE(  35)								int ii_min55 = ::Math_obj::floor(by1);
HXDLIN(  35)								int ii_max55 = ::Math_obj::ceil(bottomY);
HXDLIN(  35)								yIter37 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min55,ii_max55);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::ImageStruct undoImage21 = null();
HXDLIN(  35)						if (hasUndo7) {
HXLINE(  35)							int width8 = ((xIter37->max - xIter37->start) + 1);
HXDLIN(  35)							int height8 = ((yIter37->max - yIter37->start) + 1);
HXDLIN(  35)							 ::Dynamic imageType8 = null();
HXDLIN(  35)							 ::pi_xy::ImageStruct this242 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  35)							if (::hx::IsNull( imageType8 )) {
HXLINE(  54)								imageType8 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE(  35)							::Dynamic undoImage22;
HXDLIN(  35)							switch((int)(( (int)(imageType8) ))){
            								case (int)0: {
HXLINE(  35)									 ::iterMagic::BytesImg byt8 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::BytesImg b48 = byt8;
HXDLIN(  35)									{
HXLINE(  35)										b48->width = width8;
HXDLIN(  35)										b48->height = height8;
HXDLIN(  35)										b48->length = ::Std_obj::_hx_int(( (Float)((width8 * height8)) ));
HXDLIN(  35)										b48->data = ::haxe::io::Bytes_obj::alloc((b48->length * 4));
HXDLIN(  35)										{
HXLINE(  35)											int len16 = b48->length;
HXDLIN(  35)											int w8 = 0;
HXDLIN(  35)											{
HXLINE(  35)												int _g156 = 0;
HXDLIN(  35)												int _g157 = b48->height;
HXDLIN(  35)												while((_g156 < _g157)){
HXLINE(  35)													_g156 = (_g156 + 1);
HXDLIN(  35)													int y30 = (_g156 - 1);
HXDLIN(  35)													{
HXLINE(  35)														int _g158 = 0;
HXDLIN(  35)														int _g159 = b48->width;
HXDLIN(  35)														while((_g158 < _g159)){
HXLINE(  35)															_g158 = (_g158 + 1);
HXDLIN(  35)															int x30 = (_g158 - 1);
HXDLIN(  35)															{
HXLINE(  35)																w8 = (w8 + 1);
HXDLIN(  35)																b48->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w8 = (w8 + 1);
HXDLIN(  35)																b48->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w8 = (w8 + 1);
HXDLIN(  35)																b48->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w8 = (w8 + 1);
HXDLIN(  35)																b48->data->b[(w8 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage22 = b48;
            								}
            								break;
            								case (int)1: {
HXLINE(  35)									 ::iterMagic::ArrIntImg arrI8 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::ArrIntImg a47 = arrI8;
HXDLIN(  35)									{
HXLINE(  35)										a47->width = width8;
HXDLIN(  35)										a47->height = height8;
HXDLIN(  35)										a47->data = ::Array_obj< int >::__new(0);
HXDLIN(  35)										a47->length = ::Std_obj::_hx_int(( (Float)((width8 * height8)) ));
HXDLIN(  35)										{
HXLINE(  35)											int _g160 = 0;
HXDLIN(  35)											int _g161 = a47->length;
HXDLIN(  35)											while((_g160 < _g161)){
HXLINE(  35)												_g160 = (_g160 + 1);
HXDLIN(  35)												int i48 = (_g160 - 1);
HXDLIN(  35)												a47->data[i48] = 0;
            											}
            										}
            									}
HXDLIN(  35)									undoImage22 = a47;
            								}
            								break;
            								case (int)2: {
HXLINE(  35)									 ::iterMagic::U32ArrImg u32a8 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::U32ArrImg b49 = u32a8;
HXDLIN(  35)									{
HXLINE(  35)										b49->width = width8;
HXDLIN(  35)										b49->height = height8;
HXDLIN(  35)										b49->length = ::Std_obj::_hx_int(( (Float)((width8 * height8)) ));
HXDLIN(  35)										int size8 = (b49->length * 4);
HXDLIN(  35)										b49->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size8),0,size8);
HXDLIN(  35)										{
HXLINE(  35)											int _g162 = 0;
HXDLIN(  35)											int _g163 = b49->length;
HXDLIN(  35)											while((_g162 < _g163)){
HXLINE(  35)												_g162 = (_g162 + 1);
HXDLIN(  35)												int i49 = (_g162 - 1);
HXDLIN(  35)												{
HXLINE(  35)													 ::haxe::io::ArrayBufferViewImpl this243 = b49->data;
HXDLIN(  35)													bool undoImage23;
HXDLIN(  35)													if ((i49 >= 0)) {
HXLINE(  35)														undoImage23 = (i49 < (this243->byteLength >> 2));
            													}
            													else {
HXLINE(  35)														undoImage23 = false;
            													}
HXDLIN(  35)													if (undoImage23) {
HXLINE(  35)														 ::haxe::io::Bytes _this8 = this243->bytes;
HXDLIN(  35)														int pos8 = ((i49 << 2) + this243->byteOffset);
HXDLIN(  35)														_this8->b[pos8] = ( (unsigned char)(0) );
HXDLIN(  35)														_this8->b[(pos8 + 1)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this8->b[(pos8 + 2)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this8->b[(pos8 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage22 = b49;
            								}
            								break;
            								case (int)3: {
HXLINE(  35)									 ::iterMagic::VecIntImg vec8 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::VecIntImg v32 = vec8;
HXDLIN(  35)									{
HXLINE(  35)										v32->width = width8;
HXDLIN(  35)										v32->height = height8;
HXDLIN(  35)										v32->length = ::Std_obj::_hx_int(( (Float)((width8 * height8)) ));
HXDLIN(  35)										v32->data = ::Array_obj< int >::__new(v32->length);
HXDLIN(  35)										{
HXLINE(  35)											int _g164 = 0;
HXDLIN(  35)											int _g165 = v32->length;
HXDLIN(  35)											while((_g164 < _g165)){
HXLINE(  35)												_g164 = (_g164 + 1);
HXDLIN(  35)												int i50 = (_g164 - 1);
HXDLIN(  35)												v32->data->__unsafe_set(i50,0);
            											}
            										}
            									}
HXDLIN(  35)									undoImage22 = v32;
            								}
            								break;
            								case (int)4: {
HXLINE(  35)									 ::iterMagic::StackIntImg sInt8 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::StackIntImg b50 = sInt8;
HXDLIN(  35)									{
HXLINE(  35)										b50->width = width8;
HXDLIN(  35)										b50->height = height8;
HXDLIN(  35)										b50->length = ::Std_obj::_hx_int(( (Float)((width8 * height8)) ));
HXDLIN(  35)										b50->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  35)										{
HXLINE(  35)											int len17 = b50->length;
HXDLIN(  35)											 ::haxe::ds::GenericStack_Int d8 = b50->data;
HXDLIN(  35)											if (::hx::IsNull( d8->head )) {
HXLINE(  35)												int _g166 = 0;
HXDLIN(  35)												int _g167 = len17;
HXDLIN(  35)												while((_g166 < _g167)){
HXLINE(  35)													_g166 = (_g166 + 1);
HXDLIN(  35)													int i51 = (_g166 - 1);
HXDLIN(  35)													d8->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d8->head);
            												}
            											}
            											else {
HXLINE(  35)												int _g168 = 0;
HXDLIN(  35)												int _g169 = len17;
HXDLIN(  35)												while((_g168 < _g169)){
HXLINE(  35)													_g168 = (_g168 + 1);
HXDLIN(  35)													int i52 = (_g168 - 1);
HXDLIN(  35)													{
HXLINE(  35)														 ::haxe::ds::GenericCell_Int l8 = b50->data->head;
HXDLIN(  35)														 ::haxe::ds::GenericCell_Int prev8 = null();
HXDLIN(  35)														{
HXLINE(  35)															int _g170 = 0;
HXDLIN(  35)															int _g171 = i52;
HXDLIN(  35)															while((_g170 < _g171)){
HXLINE(  35)																_g170 = (_g170 + 1);
HXDLIN(  35)																int i53 = (_g170 - 1);
HXLINE( 345)																prev8 = l8;
HXLINE( 346)																l8 = l8->next;
            															}
            														}
HXLINE(  35)														if (::hx::IsNull( prev8 )) {
HXLINE(  35)															b50->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l8->next);
HXDLIN(  35)															l8 = null();
            														}
            														else {
HXLINE(  35)															prev8->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l8->next);
HXDLIN(  35)															l8 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage22 = b50;
            								}
            								break;
            							}
HXDLIN(  35)							this242->image = undoImage22;
HXDLIN(  35)							this242->width = width8;
HXDLIN(  35)							this242->height = height8;
HXDLIN(  35)							this242->imageType = ( (int)(imageType8) );
HXDLIN(  35)							undoImage21 = this242;
HXDLIN(  35)							{
HXLINE(  35)								int rectLeft7 = xIter37->start;
HXDLIN(  35)								int rectTop7 = yIter37->start;
HXDLIN(  35)								int rectRight7 = xIter37->max;
HXDLIN(  35)								bool forceClear7 = false;
HXDLIN(  35)								{
HXLINE(  35)									int _g172 = rectTop7;
HXDLIN(  35)									int _g173 = yIter37->max;
HXDLIN(  35)									while((_g172 < _g173)){
HXLINE(  35)										_g172 = (_g172 + 1);
HXDLIN(  35)										int dy8 = (_g172 - 1);
HXDLIN(  35)										{
HXLINE(  35)											int _g174 = rectLeft7;
HXDLIN(  35)											int _g175 = rectRight7;
HXDLIN(  35)											while((_g174 < _g175)){
HXLINE(  35)												_g174 = (_g174 + 1);
HXDLIN(  35)												int dx8 = (_g174 - 1);
HXDLIN(  35)												::Dynamic this244 = temp->image;
HXDLIN(  35)												int index42;
HXDLIN(  35)												if (temp->useVirtualPos) {
HXLINE(  35)													index42 = ::Std_obj::_hx_int(((((( (Float)(dy8) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx8) - temp->virtualX));
            												}
            												else {
HXLINE(  35)													index42 = ::Std_obj::_hx_int(( (Float)(((dy8 * temp->width) + dx8)) ));
            												}
HXDLIN(  35)												int c35 = ::iterMagic::Iimg_obj::get(this244,index42);
HXDLIN(  35)												int col14;
HXDLIN(  35)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)													col14 = ((((((c35 >> 24) & 255) << 24) | ((c35 & 255) << 16)) | (((c35 >> 8) & 255) << 8)) | ((c35 >> 16) & 255));
            												}
            												else {
HXLINE(  35)													col14 = c35;
            												}
HXDLIN(  35)												bool _hx_tmp65;
HXDLIN(  35)												if (temp->useMask) {
HXLINE(  35)													_hx_tmp65 = ::hx::IsNotNull( temp->mask );
            												}
            												else {
HXLINE(  35)													_hx_tmp65 = false;
            												}
HXDLIN(  35)												if (_hx_tmp65) {
HXLINE(  35)													 ::pi_xy::ImageStruct this245 = temp->mask;
HXDLIN(  35)													::Dynamic this246 = this245->image;
HXDLIN(  35)													int index43;
HXDLIN(  35)													if (this245->useVirtualPos) {
HXLINE(  35)														index43 = ::Std_obj::_hx_int(((((( (Float)(dy8) ) - this245->virtualY) * ( (Float)(this245->width) )) + dx8) - this245->virtualX));
            													}
            													else {
HXLINE(  35)														index43 = ::Std_obj::_hx_int(( (Float)(((dy8 * this245->width) + dx8)) ));
            													}
HXDLIN(  35)													int c36 = ::iterMagic::Iimg_obj::get(this246,index43);
HXDLIN(  35)													int v33;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														v33 = ((((((c36 >> 24) & 255) << 24) | ((c36 & 255) << 16)) | (((c36 >> 8) & 255) << 8)) | ((c36 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														v33 = c36;
            													}
HXDLIN(  35)													int maskPixel7 = v33;
HXDLIN(  35)													int this247 = col14;
HXDLIN(  35)													if ((maskPixel7 == 0)) {
HXLINE(  35)														col14 = this247;
            													}
            													else {
HXLINE(  35)														Float m07;
HXDLIN(  35)														int this248 = ((maskPixel7 >> 24) & 255);
HXDLIN(  35)														if ((this248 == 0)) {
HXLINE(  35)															m07 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m07 = (( (Float)(this248) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m17;
HXDLIN(  35)														int this249 = ((maskPixel7 >> 16) & 255);
HXDLIN(  35)														if ((this249 == 0)) {
HXLINE(  35)															m17 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m17 = (( (Float)(this249) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m27;
HXDLIN(  35)														int this250 = ((maskPixel7 >> 8) & 255);
HXDLIN(  35)														if ((this250 == 0)) {
HXLINE(  35)															m27 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m27 = (( (Float)(this250) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m37;
HXDLIN(  35)														int this251 = (maskPixel7 & 255);
HXDLIN(  35)														if ((this251 == 0)) {
HXLINE(  35)															m37 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m37 = (( (Float)(this251) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														int ch07 = ::Std_obj::_hx_int(((((Float)1.) - m07) * ( (Float)(((this247 >> 24) & 255)) )));
HXDLIN(  35)														int ch17 = ::Std_obj::_hx_int(((((Float)1.) - m17) * ( (Float)(((this247 >> 16) & 255)) )));
HXDLIN(  35)														int ch27 = ::Std_obj::_hx_int(((((Float)1.) - m27) * ( (Float)(((this247 >> 8) & 255)) )));
HXDLIN(  35)														int ch37 = ::Std_obj::_hx_int(((((Float)1.) - m37) * ( (Float)((this247 & 255)) )));
HXDLIN(  35)														col14 = ((((::Math_obj::round((( (Float)(ch07) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch17) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch27) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch37) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  35)												if ((col14 != 0)) {
HXLINE(  35)													int x31 = (dx8 - rectLeft7);
HXDLIN(  35)													int y31 = (dy8 - rectTop7);
HXDLIN(  35)													int c37 = col14;
HXDLIN(  35)													bool _hx_tmp66;
HXDLIN(  35)													if ((((c37 >> 24) & 255) < 254)) {
HXLINE(  35)														_hx_tmp66 = undoImage21->transparent;
            													}
            													else {
HXLINE(  35)														_hx_tmp66 = false;
            													}
HXDLIN(  35)													if (_hx_tmp66) {
HXLINE(  35)														int location14;
HXDLIN(  35)														if (undoImage21->useVirtualPos) {
HXLINE(  35)															location14 = ::Std_obj::_hx_int(((((( (Float)(y31) ) - undoImage21->virtualY) * ( (Float)(undoImage21->width) )) + x31) - undoImage21->virtualX));
            														}
            														else {
HXLINE(  35)															location14 = ::Std_obj::_hx_int(( (Float)(((y31 * undoImage21->width) + x31)) ));
            														}
HXDLIN(  35)														int this252 = ::iterMagic::Iimg_obj::get(undoImage21->image,location14);
HXDLIN(  35)														int this253;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															this253 = ((((((this252 >> 24) & 255) << 24) | ((this252 & 255) << 16)) | (((this252 >> 8) & 255) << 8)) | ((this252 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															this253 = this252;
            														}
HXDLIN(  35)														Float a117;
HXDLIN(  35)														int this254 = ((this253 >> 24) & 255);
HXDLIN(  35)														if ((this254 == 0)) {
HXLINE(  35)															a117 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a117 = (( (Float)(this254) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r114;
HXDLIN(  35)														int this255 = ((this253 >> 16) & 255);
HXDLIN(  35)														if ((this255 == 0)) {
HXLINE(  35)															r114 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r114 = (( (Float)(this255) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g114;
HXDLIN(  35)														int this256 = ((this253 >> 8) & 255);
HXDLIN(  35)														if ((this256 == 0)) {
HXLINE(  35)															g114 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g114 = (( (Float)(this256) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b120;
HXDLIN(  35)														int this257 = (this253 & 255);
HXDLIN(  35)														if ((this257 == 0)) {
HXLINE(  35)															b120 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b120 = (( (Float)(this257) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a216;
HXDLIN(  35)														int this258 = ((col14 >> 24) & 255);
HXDLIN(  35)														if ((this258 == 0)) {
HXLINE(  35)															a216 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a216 = (( (Float)(this258) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r214;
HXDLIN(  35)														int this259 = ((col14 >> 16) & 255);
HXDLIN(  35)														if ((this259 == 0)) {
HXLINE(  35)															r214 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r214 = (( (Float)(this259) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g214;
HXDLIN(  35)														int this260 = ((col14 >> 8) & 255);
HXDLIN(  35)														if ((this260 == 0)) {
HXLINE(  35)															g214 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g214 = (( (Float)(this260) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b218;
HXDLIN(  35)														int this261 = (col14 & 255);
HXDLIN(  35)														if ((this261 == 0)) {
HXLINE(  35)															b218 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b218 = (( (Float)(this261) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a314 = (a117 * (( (Float)(1) ) - a216));
HXDLIN(  35)														int r34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r114 * a314) + (r214 * a216))));
HXDLIN(  35)														int g34 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g114 * a314) + (g214 * a216))));
HXDLIN(  35)														int b51 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b120 * a314) + (b218 * a216))));
HXDLIN(  35)														int a48 = ::Std_obj::_hx_int((( (Float)(255) ) * (a314 + a216)));
HXDLIN(  35)														int blended14 = ((((a48 << 24) | (r34 << 16)) | (g34 << 8)) | b51);
HXDLIN(  35)														{
HXLINE(  35)															int _hx_tmp67;
HXDLIN(  35)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)																_hx_tmp67 = ((((((blended14 >> 24) & 255) << 24) | ((blended14 & 255) << 16)) | (((blended14 >> 8) & 255) << 8)) | ((blended14 >> 16) & 255));
            															}
            															else {
HXLINE(  35)																_hx_tmp67 = blended14;
            															}
HXDLIN(  35)															::iterMagic::Iimg_obj::set(undoImage21->image,location14,_hx_tmp67);
            														}
            													}
            													else {
HXLINE(  35)														::Dynamic this262 = undoImage21->image;
HXDLIN(  35)														int index44;
HXDLIN(  35)														if (undoImage21->useVirtualPos) {
HXLINE(  35)															index44 = ::Std_obj::_hx_int(((((( (Float)(y31) ) - undoImage21->virtualY) * ( (Float)(undoImage21->width) )) + x31) - undoImage21->virtualX));
            														}
            														else {
HXLINE(  35)															index44 = ::Std_obj::_hx_int(( (Float)(((y31 * undoImage21->width) + x31)) ));
            														}
HXDLIN(  35)														int _hx_tmp68;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp68 = ((((((c37 >> 24) & 255) << 24) | ((c37 & 255) << 16)) | (((c37 >> 8) & 255) << 8)) | ((c37 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp68 = c37;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this262,index44,_hx_tmp68);
            													}
            												}
            												else {
HXLINE(  35)													if (forceClear7) {
HXLINE(  35)														::Dynamic this263 = undoImage21->image;
HXDLIN(  35)														int x32 = (dx8 - rectLeft7);
HXDLIN(  35)														int y32 = (dy8 - rectTop7);
HXDLIN(  35)														int index45;
HXDLIN(  35)														if (undoImage21->useVirtualPos) {
HXLINE(  35)															index45 = ::Std_obj::_hx_int(((((( (Float)(y32) ) - undoImage21->virtualY) * ( (Float)(undoImage21->width) )) + x32) - undoImage21->virtualX));
            														}
            														else {
HXLINE(  35)															index45 = ::Std_obj::_hx_int(( (Float)(((y32 * undoImage21->width) + x32)) ));
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this263,index45,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						{
HXLINE(  35)							int _g_min14 = xIter37->start;
HXDLIN(  35)							int _g_max14 = xIter37->max;
HXDLIN(  35)							while((_g_min14 < _g_max14)){
HXLINE(  35)								_g_min14 = (_g_min14 + 1);
HXDLIN(  35)								int px7 = (_g_min14 - 1);
HXDLIN(  35)								Float pcx7 = ( (Float)(px7) );
HXDLIN(  35)								{
HXLINE(  35)									int _g_min15 = yIter37->start;
HXDLIN(  35)									int _g_max15 = yIter37->max;
HXDLIN(  35)									while((_g_min15 < _g_max15)){
HXLINE(  35)										_g_min15 = (_g_min15 + 1);
HXDLIN(  35)										int py7 = (_g_min15 - 1);
HXDLIN(  35)										Float pcy7 = (( (Float)(py7) ) - bottomY);
HXDLIN(  35)										Float dot317 = ((pcx7 * bcx7) + (pcy7 * bcy7));
HXDLIN(  35)										Float dot327 = ((pcx7 * acx7) + (pcy7 * acy7));
HXDLIN(  35)										Float ratioA7 = (((dot227 * dot317) - (dot127 * dot327)) * denom17);
HXDLIN(  35)										Float ratioB7 = (((dot117 * dot327) - (dot127 * dot317)) * denom17);
HXDLIN(  35)										Float ratioC7 = ((((Float)1.0) - ratioB7) - ratioA7);
HXDLIN(  35)										bool _hx_tmp69;
HXDLIN(  35)										bool _hx_tmp70;
HXDLIN(  35)										if ((ratioA7 >= 0)) {
HXLINE(  35)											_hx_tmp70 = (ratioB7 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp70 = false;
            										}
HXDLIN(  35)										if (_hx_tmp70) {
HXLINE(  35)											_hx_tmp69 = (ratioC7 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp69 = false;
            										}
HXDLIN(  35)										if (_hx_tmp69) {
HXLINE(  35)											Float u7 = (((au8 * ratioA7) + (bu8 * ratioB7)) + (((Float)0.) * ratioC7));
HXDLIN(  35)											Float v34 = (((av8 * ratioA7) + (bv7 * ratioB7)) + (cv * ratioC7));
HXDLIN(  35)											int x33 = ::Std_obj::_hx_int(((u7 * win_width) + win_x));
HXDLIN(  35)											int y33 = ::Std_obj::_hx_int(((v34 * win_height) + win_y));
HXDLIN(  35)											::Dynamic this264 = texture->image;
HXDLIN(  35)											int index46;
HXDLIN(  35)											if (texture->useVirtualPos) {
HXLINE(  35)												index46 = ::Std_obj::_hx_int(((((( (Float)(y33) ) - texture->virtualY) * ( (Float)(texture->width) )) + x33) - texture->virtualX));
            											}
            											else {
HXLINE(  35)												index46 = ::Std_obj::_hx_int(( (Float)(((y33 * texture->width) + x33)) ));
            											}
HXDLIN(  35)											int c38 = ::iterMagic::Iimg_obj::get(this264,index46);
HXDLIN(  35)											int col15;
HXDLIN(  35)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)												col15 = ((((((c38 >> 24) & 255) << 24) | ((c38 & 255) << 16)) | (((c38 >> 8) & 255) << 8)) | ((c38 >> 16) & 255));
            											}
            											else {
HXLINE(  35)												col15 = c38;
            											}
HXDLIN(  35)											{
HXLINE(  35)												int c39 = col15;
HXDLIN(  35)												bool _hx_tmp71;
HXDLIN(  35)												if ((((c39 >> 24) & 255) < 254)) {
HXLINE(  35)													_hx_tmp71 = temp->transparent;
            												}
            												else {
HXLINE(  35)													_hx_tmp71 = false;
            												}
HXDLIN(  35)												if (_hx_tmp71) {
HXLINE(  35)													int location15;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														location15 = ::Std_obj::_hx_int(((((( (Float)(py7) ) - temp->virtualY) * ( (Float)(temp->width) )) + px7) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														location15 = ::Std_obj::_hx_int(( (Float)(((py7 * temp->width) + px7)) ));
            													}
HXDLIN(  35)													int this265 = ::iterMagic::Iimg_obj::get(temp->image,location15);
HXDLIN(  35)													int this266;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														this266 = ((((((this265 >> 24) & 255) << 24) | ((this265 & 255) << 16)) | (((this265 >> 8) & 255) << 8)) | ((this265 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														this266 = this265;
            													}
HXDLIN(  35)													Float a118;
HXDLIN(  35)													int this267 = ((this266 >> 24) & 255);
HXDLIN(  35)													if ((this267 == 0)) {
HXLINE(  35)														a118 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a118 = (( (Float)(this267) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r115;
HXDLIN(  35)													int this268 = ((this266 >> 16) & 255);
HXDLIN(  35)													if ((this268 == 0)) {
HXLINE(  35)														r115 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r115 = (( (Float)(this268) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g115;
HXDLIN(  35)													int this269 = ((this266 >> 8) & 255);
HXDLIN(  35)													if ((this269 == 0)) {
HXLINE(  35)														g115 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g115 = (( (Float)(this269) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b121;
HXDLIN(  35)													int this270 = (this266 & 255);
HXDLIN(  35)													if ((this270 == 0)) {
HXLINE(  35)														b121 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b121 = (( (Float)(this270) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a217;
HXDLIN(  35)													int this271 = ((col15 >> 24) & 255);
HXDLIN(  35)													if ((this271 == 0)) {
HXLINE(  35)														a217 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a217 = (( (Float)(this271) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r215;
HXDLIN(  35)													int this272 = ((col15 >> 16) & 255);
HXDLIN(  35)													if ((this272 == 0)) {
HXLINE(  35)														r215 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r215 = (( (Float)(this272) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g215;
HXDLIN(  35)													int this273 = ((col15 >> 8) & 255);
HXDLIN(  35)													if ((this273 == 0)) {
HXLINE(  35)														g215 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g215 = (( (Float)(this273) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b219;
HXDLIN(  35)													int this274 = (col15 & 255);
HXDLIN(  35)													if ((this274 == 0)) {
HXLINE(  35)														b219 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b219 = (( (Float)(this274) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a315 = (a118 * (( (Float)(1) ) - a217));
HXDLIN(  35)													int r35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r115 * a315) + (r215 * a217))));
HXDLIN(  35)													int g35 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g115 * a315) + (g215 * a217))));
HXDLIN(  35)													int b52 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b121 * a315) + (b219 * a217))));
HXDLIN(  35)													int a49 = ::Std_obj::_hx_int((( (Float)(255) ) * (a315 + a217)));
HXDLIN(  35)													int blended15 = ((((a49 << 24) | (r35 << 16)) | (g35 << 8)) | b52);
HXDLIN(  35)													{
HXLINE(  35)														int _hx_tmp72;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp72 = ((((((blended15 >> 24) & 255) << 24) | ((blended15 & 255) << 16)) | (((blended15 >> 8) & 255) << 8)) | ((blended15 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp72 = blended15;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(temp->image,location15,_hx_tmp72);
            													}
            												}
            												else {
HXLINE(  35)													::Dynamic this275 = temp->image;
HXDLIN(  35)													int index47;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														index47 = ::Std_obj::_hx_int(((((( (Float)(py7) ) - temp->virtualY) * ( (Float)(temp->width) )) + px7) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														index47 = ::Std_obj::_hx_int(( (Float)(((py7 * temp->width) + px7)) ));
            													}
HXDLIN(  35)													int _hx_tmp73;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														_hx_tmp73 = ((((((c39 >> 24) & 255) << 24) | ((c39 & 255) << 16)) | (((c39 >> 8) & 255) << 8)) | ((c39 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														_hx_tmp73 = c39;
            													}
HXDLIN(  35)													::iterMagic::Iimg_obj::set(this275,index47,_hx_tmp73);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						if ((hasHit == false)) {
HXLINE(  35)							 ::pi_xy::algo::HitTri v35 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,leftX,by1,leftX,cy1,( (Float)(0) ),bottomY,true);
HXDLIN(  35)							if (hasUndo7) {
HXLINE(  35)								v35->undoImage = undoImage21;
HXDLIN(  35)								v35->undoX = xIter37->start;
HXDLIN(  35)								v35->undoY = yIter37->start;
            							}
            						}
            					}
HXDLIN(  35)					if ((hasHit == true)) {
HXLINE(  35)						 ::pi_xy::algo::HitQuad v36 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,( (Float)(0) ),ay1,leftX,by1,leftX,cy1,( (Float)(0) ),bottomY,true);
            					}
            				}
HXLINE( 266)				au = bu;
HXLINE( 267)				bu = ((left + fat) * sw);
HXLINE(  35)				{
HXLINE(  35)					Float ay2 = (topY - ( (Float)(1) ));
HXDLIN(  35)					Float by2 = (topY - ( (Float)(1) ));
HXDLIN(  35)					Float cy2 = (bottomY + 1);
HXDLIN(  35)					{
HXLINE(  35)						Float au9 = au;
HXDLIN(  35)						Float av9 = av;
HXDLIN(  35)						Float bu9 = bu;
HXDLIN(  35)						Float bv8 = av;
HXDLIN(  35)						bool hasUndo8 = false;
HXDLIN(  35)						Float temp9 = au9;
HXLINE( 422)						au9 = bu9;
HXLINE( 423)						bu9 = temp9;
HXLINE( 424)						temp9 = av9;
HXLINE( 425)						av9 = bv8;
HXLINE( 426)						bv8 = temp9;
HXLINE(  35)						Float bcx8 = (rightX - leftX);
HXDLIN(  35)						Float bcy8 = (by2 - bottomY);
HXDLIN(  35)						Float acx8 = (leftX - leftX);
HXDLIN(  35)						Float acy8 = (ay2 - bottomY);
HXDLIN(  35)						Float dot118 = ((bcx8 * bcx8) + (bcy8 * bcy8));
HXDLIN(  35)						Float dot128 = ((bcx8 * acx8) + (bcy8 * acy8));
HXDLIN(  35)						Float dot228 = ((acx8 * acx8) + (acy8 * acy8));
HXDLIN(  35)						Float denom18 = (( (Float)(1) ) / ((dot118 * dot228) - (dot128 * dot128)));
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart xIter38;
HXDLIN(  35)						if ((leftX > rightX)) {
HXLINE(  35)							if ((leftX > leftX)) {
HXLINE(  35)								int min25;
HXDLIN(  35)								if ((rightX > leftX)) {
HXLINE(  35)									min25 = ::Math_obj::floor(leftX);
            								}
            								else {
HXLINE(  35)									min25 = ::Math_obj::floor(rightX);
            								}
HXDLIN(  35)								int ii_min56 = min25;
HXDLIN(  35)								int ii_max56 = ::Math_obj::ceil(leftX);
HXDLIN(  35)								xIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min56,ii_max56);
            							}
            							else {
HXLINE(  35)								int ii_min57 = ::Math_obj::floor(rightX);
HXDLIN(  35)								int ii_max57 = ::Math_obj::ceil(leftX);
HXDLIN(  35)								xIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min57,ii_max57);
            							}
            						}
            						else {
HXLINE(  35)							if ((rightX > leftX)) {
HXLINE(  35)								int min26;
HXDLIN(  35)								if ((leftX > leftX)) {
HXLINE(  35)									min26 = ::Math_obj::floor(leftX);
            								}
            								else {
HXLINE(  35)									min26 = ::Math_obj::ceil(leftX);
            								}
HXDLIN(  35)								int ii_min58 = min26;
HXDLIN(  35)								int ii_max58 = ::Math_obj::ceil(rightX);
HXDLIN(  35)								xIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min58,ii_max58);
            							}
            							else {
HXLINE(  35)								int ii_min59 = ::Math_obj::floor(leftX);
HXDLIN(  35)								int ii_max59 = ::Math_obj::ceil(leftX);
HXDLIN(  35)								xIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min59,ii_max59);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart yIter38;
HXDLIN(  35)						if ((ay2 > by2)) {
HXLINE(  35)							if ((ay2 > bottomY)) {
HXLINE(  35)								int min27;
HXDLIN(  35)								if ((by2 > bottomY)) {
HXLINE(  35)									min27 = ::Math_obj::floor(bottomY);
            								}
            								else {
HXLINE(  35)									min27 = ::Math_obj::floor(by2);
            								}
HXDLIN(  35)								int ii_min60 = min27;
HXDLIN(  35)								int ii_max60 = ::Math_obj::ceil(ay2);
HXDLIN(  35)								yIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min60,ii_max60);
            							}
            							else {
HXLINE(  35)								int ii_min61 = ::Math_obj::floor(by2);
HXDLIN(  35)								int ii_max61 = ::Math_obj::ceil(bottomY);
HXDLIN(  35)								yIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min61,ii_max61);
            							}
            						}
            						else {
HXLINE(  35)							if ((by2 > bottomY)) {
HXLINE(  35)								int min28;
HXDLIN(  35)								if ((ay2 > bottomY)) {
HXLINE(  35)									min28 = ::Math_obj::floor(bottomY);
            								}
            								else {
HXLINE(  35)									min28 = ::Math_obj::ceil(ay2);
            								}
HXDLIN(  35)								int ii_min62 = min28;
HXDLIN(  35)								int ii_max62 = ::Math_obj::ceil(by2);
HXDLIN(  35)								yIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min62,ii_max62);
            							}
            							else {
HXLINE(  35)								int ii_min63 = ::Math_obj::floor(ay2);
HXDLIN(  35)								int ii_max63 = ::Math_obj::ceil(bottomY);
HXDLIN(  35)								yIter38 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min63,ii_max63);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::ImageStruct undoImage24 = null();
HXDLIN(  35)						if (hasUndo8) {
HXLINE(  35)							int width9 = ((xIter38->max - xIter38->start) + 1);
HXDLIN(  35)							int height9 = ((yIter38->max - yIter38->start) + 1);
HXDLIN(  35)							 ::Dynamic imageType9 = null();
HXDLIN(  35)							 ::pi_xy::ImageStruct this276 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  35)							if (::hx::IsNull( imageType9 )) {
HXLINE(  54)								imageType9 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE(  35)							::Dynamic undoImage25;
HXDLIN(  35)							switch((int)(( (int)(imageType9) ))){
            								case (int)0: {
HXLINE(  35)									 ::iterMagic::BytesImg byt9 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::BytesImg b53 = byt9;
HXDLIN(  35)									{
HXLINE(  35)										b53->width = width9;
HXDLIN(  35)										b53->height = height9;
HXDLIN(  35)										b53->length = ::Std_obj::_hx_int(( (Float)((width9 * height9)) ));
HXDLIN(  35)										b53->data = ::haxe::io::Bytes_obj::alloc((b53->length * 4));
HXDLIN(  35)										{
HXLINE(  35)											int len18 = b53->length;
HXDLIN(  35)											int w9 = 0;
HXDLIN(  35)											{
HXLINE(  35)												int _g176 = 0;
HXDLIN(  35)												int _g177 = b53->height;
HXDLIN(  35)												while((_g176 < _g177)){
HXLINE(  35)													_g176 = (_g176 + 1);
HXDLIN(  35)													int y34 = (_g176 - 1);
HXDLIN(  35)													{
HXLINE(  35)														int _g178 = 0;
HXDLIN(  35)														int _g179 = b53->width;
HXDLIN(  35)														while((_g178 < _g179)){
HXLINE(  35)															_g178 = (_g178 + 1);
HXDLIN(  35)															int x34 = (_g178 - 1);
HXDLIN(  35)															{
HXLINE(  35)																w9 = (w9 + 1);
HXDLIN(  35)																b53->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w9 = (w9 + 1);
HXDLIN(  35)																b53->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w9 = (w9 + 1);
HXDLIN(  35)																b53->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w9 = (w9 + 1);
HXDLIN(  35)																b53->data->b[(w9 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage25 = b53;
            								}
            								break;
            								case (int)1: {
HXLINE(  35)									 ::iterMagic::ArrIntImg arrI9 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::ArrIntImg a50 = arrI9;
HXDLIN(  35)									{
HXLINE(  35)										a50->width = width9;
HXDLIN(  35)										a50->height = height9;
HXDLIN(  35)										a50->data = ::Array_obj< int >::__new(0);
HXDLIN(  35)										a50->length = ::Std_obj::_hx_int(( (Float)((width9 * height9)) ));
HXDLIN(  35)										{
HXLINE(  35)											int _g180 = 0;
HXDLIN(  35)											int _g181 = a50->length;
HXDLIN(  35)											while((_g180 < _g181)){
HXLINE(  35)												_g180 = (_g180 + 1);
HXDLIN(  35)												int i54 = (_g180 - 1);
HXDLIN(  35)												a50->data[i54] = 0;
            											}
            										}
            									}
HXDLIN(  35)									undoImage25 = a50;
            								}
            								break;
            								case (int)2: {
HXLINE(  35)									 ::iterMagic::U32ArrImg u32a9 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::U32ArrImg b54 = u32a9;
HXDLIN(  35)									{
HXLINE(  35)										b54->width = width9;
HXDLIN(  35)										b54->height = height9;
HXDLIN(  35)										b54->length = ::Std_obj::_hx_int(( (Float)((width9 * height9)) ));
HXDLIN(  35)										int size9 = (b54->length * 4);
HXDLIN(  35)										b54->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size9),0,size9);
HXDLIN(  35)										{
HXLINE(  35)											int _g182 = 0;
HXDLIN(  35)											int _g183 = b54->length;
HXDLIN(  35)											while((_g182 < _g183)){
HXLINE(  35)												_g182 = (_g182 + 1);
HXDLIN(  35)												int i55 = (_g182 - 1);
HXDLIN(  35)												{
HXLINE(  35)													 ::haxe::io::ArrayBufferViewImpl this277 = b54->data;
HXDLIN(  35)													bool undoImage26;
HXDLIN(  35)													if ((i55 >= 0)) {
HXLINE(  35)														undoImage26 = (i55 < (this277->byteLength >> 2));
            													}
            													else {
HXLINE(  35)														undoImage26 = false;
            													}
HXDLIN(  35)													if (undoImage26) {
HXLINE(  35)														 ::haxe::io::Bytes _this9 = this277->bytes;
HXDLIN(  35)														int pos9 = ((i55 << 2) + this277->byteOffset);
HXDLIN(  35)														_this9->b[pos9] = ( (unsigned char)(0) );
HXDLIN(  35)														_this9->b[(pos9 + 1)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this9->b[(pos9 + 2)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this9->b[(pos9 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage25 = b54;
            								}
            								break;
            								case (int)3: {
HXLINE(  35)									 ::iterMagic::VecIntImg vec9 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::VecIntImg v37 = vec9;
HXDLIN(  35)									{
HXLINE(  35)										v37->width = width9;
HXDLIN(  35)										v37->height = height9;
HXDLIN(  35)										v37->length = ::Std_obj::_hx_int(( (Float)((width9 * height9)) ));
HXDLIN(  35)										v37->data = ::Array_obj< int >::__new(v37->length);
HXDLIN(  35)										{
HXLINE(  35)											int _g184 = 0;
HXDLIN(  35)											int _g185 = v37->length;
HXDLIN(  35)											while((_g184 < _g185)){
HXLINE(  35)												_g184 = (_g184 + 1);
HXDLIN(  35)												int i56 = (_g184 - 1);
HXDLIN(  35)												v37->data->__unsafe_set(i56,0);
            											}
            										}
            									}
HXDLIN(  35)									undoImage25 = v37;
            								}
            								break;
            								case (int)4: {
HXLINE(  35)									 ::iterMagic::StackIntImg sInt9 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::StackIntImg b55 = sInt9;
HXDLIN(  35)									{
HXLINE(  35)										b55->width = width9;
HXDLIN(  35)										b55->height = height9;
HXDLIN(  35)										b55->length = ::Std_obj::_hx_int(( (Float)((width9 * height9)) ));
HXDLIN(  35)										b55->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  35)										{
HXLINE(  35)											int len19 = b55->length;
HXDLIN(  35)											 ::haxe::ds::GenericStack_Int d9 = b55->data;
HXDLIN(  35)											if (::hx::IsNull( d9->head )) {
HXLINE(  35)												int _g186 = 0;
HXDLIN(  35)												int _g187 = len19;
HXDLIN(  35)												while((_g186 < _g187)){
HXLINE(  35)													_g186 = (_g186 + 1);
HXDLIN(  35)													int i57 = (_g186 - 1);
HXDLIN(  35)													d9->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d9->head);
            												}
            											}
            											else {
HXLINE(  35)												int _g188 = 0;
HXDLIN(  35)												int _g189 = len19;
HXDLIN(  35)												while((_g188 < _g189)){
HXLINE(  35)													_g188 = (_g188 + 1);
HXDLIN(  35)													int i58 = (_g188 - 1);
HXDLIN(  35)													{
HXLINE(  35)														 ::haxe::ds::GenericCell_Int l9 = b55->data->head;
HXDLIN(  35)														 ::haxe::ds::GenericCell_Int prev9 = null();
HXDLIN(  35)														{
HXLINE(  35)															int _g190 = 0;
HXDLIN(  35)															int _g191 = i58;
HXDLIN(  35)															while((_g190 < _g191)){
HXLINE(  35)																_g190 = (_g190 + 1);
HXDLIN(  35)																int i59 = (_g190 - 1);
HXLINE( 345)																prev9 = l9;
HXLINE( 346)																l9 = l9->next;
            															}
            														}
HXLINE(  35)														if (::hx::IsNull( prev9 )) {
HXLINE(  35)															b55->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l9->next);
HXDLIN(  35)															l9 = null();
            														}
            														else {
HXLINE(  35)															prev9->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l9->next);
HXDLIN(  35)															l9 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage25 = b55;
            								}
            								break;
            							}
HXDLIN(  35)							this276->image = undoImage25;
HXDLIN(  35)							this276->width = width9;
HXDLIN(  35)							this276->height = height9;
HXDLIN(  35)							this276->imageType = ( (int)(imageType9) );
HXDLIN(  35)							undoImage24 = this276;
HXDLIN(  35)							{
HXLINE(  35)								int rectLeft8 = xIter38->start;
HXDLIN(  35)								int rectTop8 = yIter38->start;
HXDLIN(  35)								int rectRight8 = xIter38->max;
HXDLIN(  35)								bool forceClear8 = false;
HXDLIN(  35)								{
HXLINE(  35)									int _g192 = rectTop8;
HXDLIN(  35)									int _g193 = yIter38->max;
HXDLIN(  35)									while((_g192 < _g193)){
HXLINE(  35)										_g192 = (_g192 + 1);
HXDLIN(  35)										int dy9 = (_g192 - 1);
HXDLIN(  35)										{
HXLINE(  35)											int _g194 = rectLeft8;
HXDLIN(  35)											int _g195 = rectRight8;
HXDLIN(  35)											while((_g194 < _g195)){
HXLINE(  35)												_g194 = (_g194 + 1);
HXDLIN(  35)												int dx9 = (_g194 - 1);
HXDLIN(  35)												::Dynamic this278 = temp->image;
HXDLIN(  35)												int index48;
HXDLIN(  35)												if (temp->useVirtualPos) {
HXLINE(  35)													index48 = ::Std_obj::_hx_int(((((( (Float)(dy9) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx9) - temp->virtualX));
            												}
            												else {
HXLINE(  35)													index48 = ::Std_obj::_hx_int(( (Float)(((dy9 * temp->width) + dx9)) ));
            												}
HXDLIN(  35)												int c40 = ::iterMagic::Iimg_obj::get(this278,index48);
HXDLIN(  35)												int col16;
HXDLIN(  35)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)													col16 = ((((((c40 >> 24) & 255) << 24) | ((c40 & 255) << 16)) | (((c40 >> 8) & 255) << 8)) | ((c40 >> 16) & 255));
            												}
            												else {
HXLINE(  35)													col16 = c40;
            												}
HXDLIN(  35)												bool _hx_tmp74;
HXDLIN(  35)												if (temp->useMask) {
HXLINE(  35)													_hx_tmp74 = ::hx::IsNotNull( temp->mask );
            												}
            												else {
HXLINE(  35)													_hx_tmp74 = false;
            												}
HXDLIN(  35)												if (_hx_tmp74) {
HXLINE(  35)													 ::pi_xy::ImageStruct this279 = temp->mask;
HXDLIN(  35)													::Dynamic this280 = this279->image;
HXDLIN(  35)													int index49;
HXDLIN(  35)													if (this279->useVirtualPos) {
HXLINE(  35)														index49 = ::Std_obj::_hx_int(((((( (Float)(dy9) ) - this279->virtualY) * ( (Float)(this279->width) )) + dx9) - this279->virtualX));
            													}
            													else {
HXLINE(  35)														index49 = ::Std_obj::_hx_int(( (Float)(((dy9 * this279->width) + dx9)) ));
            													}
HXDLIN(  35)													int c41 = ::iterMagic::Iimg_obj::get(this280,index49);
HXDLIN(  35)													int v38;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														v38 = ((((((c41 >> 24) & 255) << 24) | ((c41 & 255) << 16)) | (((c41 >> 8) & 255) << 8)) | ((c41 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														v38 = c41;
            													}
HXDLIN(  35)													int maskPixel8 = v38;
HXDLIN(  35)													int this281 = col16;
HXDLIN(  35)													if ((maskPixel8 == 0)) {
HXLINE(  35)														col16 = this281;
            													}
            													else {
HXLINE(  35)														Float m08;
HXDLIN(  35)														int this282 = ((maskPixel8 >> 24) & 255);
HXDLIN(  35)														if ((this282 == 0)) {
HXLINE(  35)															m08 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m08 = (( (Float)(this282) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m18;
HXDLIN(  35)														int this283 = ((maskPixel8 >> 16) & 255);
HXDLIN(  35)														if ((this283 == 0)) {
HXLINE(  35)															m18 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m18 = (( (Float)(this283) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m28;
HXDLIN(  35)														int this284 = ((maskPixel8 >> 8) & 255);
HXDLIN(  35)														if ((this284 == 0)) {
HXLINE(  35)															m28 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m28 = (( (Float)(this284) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m38;
HXDLIN(  35)														int this285 = (maskPixel8 & 255);
HXDLIN(  35)														if ((this285 == 0)) {
HXLINE(  35)															m38 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m38 = (( (Float)(this285) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														int ch08 = ::Std_obj::_hx_int(((((Float)1.) - m08) * ( (Float)(((this281 >> 24) & 255)) )));
HXDLIN(  35)														int ch18 = ::Std_obj::_hx_int(((((Float)1.) - m18) * ( (Float)(((this281 >> 16) & 255)) )));
HXDLIN(  35)														int ch28 = ::Std_obj::_hx_int(((((Float)1.) - m28) * ( (Float)(((this281 >> 8) & 255)) )));
HXDLIN(  35)														int ch38 = ::Std_obj::_hx_int(((((Float)1.) - m38) * ( (Float)((this281 & 255)) )));
HXDLIN(  35)														col16 = ((((::Math_obj::round((( (Float)(ch08) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch18) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch28) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch38) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  35)												if ((col16 != 0)) {
HXLINE(  35)													int x35 = (dx9 - rectLeft8);
HXDLIN(  35)													int y35 = (dy9 - rectTop8);
HXDLIN(  35)													int c42 = col16;
HXDLIN(  35)													bool _hx_tmp75;
HXDLIN(  35)													if ((((c42 >> 24) & 255) < 254)) {
HXLINE(  35)														_hx_tmp75 = undoImage24->transparent;
            													}
            													else {
HXLINE(  35)														_hx_tmp75 = false;
            													}
HXDLIN(  35)													if (_hx_tmp75) {
HXLINE(  35)														int location16;
HXDLIN(  35)														if (undoImage24->useVirtualPos) {
HXLINE(  35)															location16 = ::Std_obj::_hx_int(((((( (Float)(y35) ) - undoImage24->virtualY) * ( (Float)(undoImage24->width) )) + x35) - undoImage24->virtualX));
            														}
            														else {
HXLINE(  35)															location16 = ::Std_obj::_hx_int(( (Float)(((y35 * undoImage24->width) + x35)) ));
            														}
HXDLIN(  35)														int this286 = ::iterMagic::Iimg_obj::get(undoImage24->image,location16);
HXDLIN(  35)														int this287;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															this287 = ((((((this286 >> 24) & 255) << 24) | ((this286 & 255) << 16)) | (((this286 >> 8) & 255) << 8)) | ((this286 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															this287 = this286;
            														}
HXDLIN(  35)														Float a119;
HXDLIN(  35)														int this288 = ((this287 >> 24) & 255);
HXDLIN(  35)														if ((this288 == 0)) {
HXLINE(  35)															a119 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a119 = (( (Float)(this288) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r116;
HXDLIN(  35)														int this289 = ((this287 >> 16) & 255);
HXDLIN(  35)														if ((this289 == 0)) {
HXLINE(  35)															r116 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r116 = (( (Float)(this289) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g116;
HXDLIN(  35)														int this290 = ((this287 >> 8) & 255);
HXDLIN(  35)														if ((this290 == 0)) {
HXLINE(  35)															g116 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g116 = (( (Float)(this290) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b122;
HXDLIN(  35)														int this291 = (this287 & 255);
HXDLIN(  35)														if ((this291 == 0)) {
HXLINE(  35)															b122 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b122 = (( (Float)(this291) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a218;
HXDLIN(  35)														int this292 = ((col16 >> 24) & 255);
HXDLIN(  35)														if ((this292 == 0)) {
HXLINE(  35)															a218 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a218 = (( (Float)(this292) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r216;
HXDLIN(  35)														int this293 = ((col16 >> 16) & 255);
HXDLIN(  35)														if ((this293 == 0)) {
HXLINE(  35)															r216 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r216 = (( (Float)(this293) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g216;
HXDLIN(  35)														int this294 = ((col16 >> 8) & 255);
HXDLIN(  35)														if ((this294 == 0)) {
HXLINE(  35)															g216 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g216 = (( (Float)(this294) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b220;
HXDLIN(  35)														int this295 = (col16 & 255);
HXDLIN(  35)														if ((this295 == 0)) {
HXLINE(  35)															b220 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b220 = (( (Float)(this295) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a316 = (a119 * (( (Float)(1) ) - a218));
HXDLIN(  35)														int r36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r116 * a316) + (r216 * a218))));
HXDLIN(  35)														int g36 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g116 * a316) + (g216 * a218))));
HXDLIN(  35)														int b56 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b122 * a316) + (b220 * a218))));
HXDLIN(  35)														int a51 = ::Std_obj::_hx_int((( (Float)(255) ) * (a316 + a218)));
HXDLIN(  35)														int blended16 = ((((a51 << 24) | (r36 << 16)) | (g36 << 8)) | b56);
HXDLIN(  35)														{
HXLINE(  35)															int _hx_tmp76;
HXDLIN(  35)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)																_hx_tmp76 = ((((((blended16 >> 24) & 255) << 24) | ((blended16 & 255) << 16)) | (((blended16 >> 8) & 255) << 8)) | ((blended16 >> 16) & 255));
            															}
            															else {
HXLINE(  35)																_hx_tmp76 = blended16;
            															}
HXDLIN(  35)															::iterMagic::Iimg_obj::set(undoImage24->image,location16,_hx_tmp76);
            														}
            													}
            													else {
HXLINE(  35)														::Dynamic this296 = undoImage24->image;
HXDLIN(  35)														int index50;
HXDLIN(  35)														if (undoImage24->useVirtualPos) {
HXLINE(  35)															index50 = ::Std_obj::_hx_int(((((( (Float)(y35) ) - undoImage24->virtualY) * ( (Float)(undoImage24->width) )) + x35) - undoImage24->virtualX));
            														}
            														else {
HXLINE(  35)															index50 = ::Std_obj::_hx_int(( (Float)(((y35 * undoImage24->width) + x35)) ));
            														}
HXDLIN(  35)														int _hx_tmp77;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp77 = ((((((c42 >> 24) & 255) << 24) | ((c42 & 255) << 16)) | (((c42 >> 8) & 255) << 8)) | ((c42 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp77 = c42;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this296,index50,_hx_tmp77);
            													}
            												}
            												else {
HXLINE(  35)													if (forceClear8) {
HXLINE(  35)														::Dynamic this297 = undoImage24->image;
HXDLIN(  35)														int x36 = (dx9 - rectLeft8);
HXDLIN(  35)														int y36 = (dy9 - rectTop8);
HXDLIN(  35)														int index51;
HXDLIN(  35)														if (undoImage24->useVirtualPos) {
HXLINE(  35)															index51 = ::Std_obj::_hx_int(((((( (Float)(y36) ) - undoImage24->virtualY) * ( (Float)(undoImage24->width) )) + x36) - undoImage24->virtualX));
            														}
            														else {
HXLINE(  35)															index51 = ::Std_obj::_hx_int(( (Float)(((y36 * undoImage24->width) + x36)) ));
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this297,index51,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						{
HXLINE(  35)							int _g_min16 = xIter38->start;
HXDLIN(  35)							int _g_max16 = xIter38->max;
HXDLIN(  35)							while((_g_min16 < _g_max16)){
HXLINE(  35)								_g_min16 = (_g_min16 + 1);
HXDLIN(  35)								int px8 = (_g_min16 - 1);
HXDLIN(  35)								Float pcx8 = (( (Float)(px8) ) - leftX);
HXDLIN(  35)								{
HXLINE(  35)									int _g_min17 = yIter38->start;
HXDLIN(  35)									int _g_max17 = yIter38->max;
HXDLIN(  35)									while((_g_min17 < _g_max17)){
HXLINE(  35)										_g_min17 = (_g_min17 + 1);
HXDLIN(  35)										int py8 = (_g_min17 - 1);
HXDLIN(  35)										Float pcy8 = (( (Float)(py8) ) - bottomY);
HXDLIN(  35)										Float dot318 = ((pcx8 * bcx8) + (pcy8 * bcy8));
HXDLIN(  35)										Float dot328 = ((pcx8 * acx8) + (pcy8 * acy8));
HXDLIN(  35)										Float ratioA8 = (((dot228 * dot318) - (dot128 * dot328)) * denom18);
HXDLIN(  35)										Float ratioB8 = (((dot118 * dot328) - (dot128 * dot318)) * denom18);
HXDLIN(  35)										Float ratioC8 = ((((Float)1.0) - ratioB8) - ratioA8);
HXDLIN(  35)										bool _hx_tmp78;
HXDLIN(  35)										bool _hx_tmp79;
HXDLIN(  35)										if ((ratioA8 >= 0)) {
HXLINE(  35)											_hx_tmp79 = (ratioB8 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp79 = false;
            										}
HXDLIN(  35)										if (_hx_tmp79) {
HXLINE(  35)											_hx_tmp78 = (ratioC8 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp78 = false;
            										}
HXDLIN(  35)										if (_hx_tmp78) {
HXLINE(  35)											Float u8 = (((au9 * ratioA8) + (bu9 * ratioB8)) + (au * ratioC8));
HXDLIN(  35)											Float v39 = (((av9 * ratioA8) + (bv8 * ratioB8)) + (cv * ratioC8));
HXDLIN(  35)											int x37 = ::Std_obj::_hx_int(((u8 * win_width) + win_x));
HXDLIN(  35)											int y37 = ::Std_obj::_hx_int(((v39 * win_height) + win_y));
HXDLIN(  35)											::Dynamic this298 = texture->image;
HXDLIN(  35)											int index52;
HXDLIN(  35)											if (texture->useVirtualPos) {
HXLINE(  35)												index52 = ::Std_obj::_hx_int(((((( (Float)(y37) ) - texture->virtualY) * ( (Float)(texture->width) )) + x37) - texture->virtualX));
            											}
            											else {
HXLINE(  35)												index52 = ::Std_obj::_hx_int(( (Float)(((y37 * texture->width) + x37)) ));
            											}
HXDLIN(  35)											int c43 = ::iterMagic::Iimg_obj::get(this298,index52);
HXDLIN(  35)											int col17;
HXDLIN(  35)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)												col17 = ((((((c43 >> 24) & 255) << 24) | ((c43 & 255) << 16)) | (((c43 >> 8) & 255) << 8)) | ((c43 >> 16) & 255));
            											}
            											else {
HXLINE(  35)												col17 = c43;
            											}
HXDLIN(  35)											{
HXLINE(  35)												int c44 = col17;
HXDLIN(  35)												bool _hx_tmp80;
HXDLIN(  35)												if ((((c44 >> 24) & 255) < 254)) {
HXLINE(  35)													_hx_tmp80 = temp->transparent;
            												}
            												else {
HXLINE(  35)													_hx_tmp80 = false;
            												}
HXDLIN(  35)												if (_hx_tmp80) {
HXLINE(  35)													int location17;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														location17 = ::Std_obj::_hx_int(((((( (Float)(py8) ) - temp->virtualY) * ( (Float)(temp->width) )) + px8) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														location17 = ::Std_obj::_hx_int(( (Float)(((py8 * temp->width) + px8)) ));
            													}
HXDLIN(  35)													int this299 = ::iterMagic::Iimg_obj::get(temp->image,location17);
HXDLIN(  35)													int this300;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														this300 = ((((((this299 >> 24) & 255) << 24) | ((this299 & 255) << 16)) | (((this299 >> 8) & 255) << 8)) | ((this299 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														this300 = this299;
            													}
HXDLIN(  35)													Float a120;
HXDLIN(  35)													int this301 = ((this300 >> 24) & 255);
HXDLIN(  35)													if ((this301 == 0)) {
HXLINE(  35)														a120 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a120 = (( (Float)(this301) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r117;
HXDLIN(  35)													int this302 = ((this300 >> 16) & 255);
HXDLIN(  35)													if ((this302 == 0)) {
HXLINE(  35)														r117 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r117 = (( (Float)(this302) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g117;
HXDLIN(  35)													int this303 = ((this300 >> 8) & 255);
HXDLIN(  35)													if ((this303 == 0)) {
HXLINE(  35)														g117 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g117 = (( (Float)(this303) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b123;
HXDLIN(  35)													int this304 = (this300 & 255);
HXDLIN(  35)													if ((this304 == 0)) {
HXLINE(  35)														b123 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b123 = (( (Float)(this304) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a219;
HXDLIN(  35)													int this305 = ((col17 >> 24) & 255);
HXDLIN(  35)													if ((this305 == 0)) {
HXLINE(  35)														a219 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a219 = (( (Float)(this305) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r217;
HXDLIN(  35)													int this306 = ((col17 >> 16) & 255);
HXDLIN(  35)													if ((this306 == 0)) {
HXLINE(  35)														r217 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r217 = (( (Float)(this306) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g217;
HXDLIN(  35)													int this307 = ((col17 >> 8) & 255);
HXDLIN(  35)													if ((this307 == 0)) {
HXLINE(  35)														g217 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g217 = (( (Float)(this307) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b221;
HXDLIN(  35)													int this308 = (col17 & 255);
HXDLIN(  35)													if ((this308 == 0)) {
HXLINE(  35)														b221 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b221 = (( (Float)(this308) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a317 = (a120 * (( (Float)(1) ) - a219));
HXDLIN(  35)													int r37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r117 * a317) + (r217 * a219))));
HXDLIN(  35)													int g37 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g117 * a317) + (g217 * a219))));
HXDLIN(  35)													int b57 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b123 * a317) + (b221 * a219))));
HXDLIN(  35)													int a52 = ::Std_obj::_hx_int((( (Float)(255) ) * (a317 + a219)));
HXDLIN(  35)													int blended17 = ((((a52 << 24) | (r37 << 16)) | (g37 << 8)) | b57);
HXDLIN(  35)													{
HXLINE(  35)														int _hx_tmp81;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp81 = ((((((blended17 >> 24) & 255) << 24) | ((blended17 & 255) << 16)) | (((blended17 >> 8) & 255) << 8)) | ((blended17 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp81 = blended17;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(temp->image,location17,_hx_tmp81);
            													}
            												}
            												else {
HXLINE(  35)													::Dynamic this309 = temp->image;
HXDLIN(  35)													int index53;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														index53 = ::Std_obj::_hx_int(((((( (Float)(py8) ) - temp->virtualY) * ( (Float)(temp->width) )) + px8) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														index53 = ::Std_obj::_hx_int(( (Float)(((py8 * temp->width) + px8)) ));
            													}
HXDLIN(  35)													int _hx_tmp82;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														_hx_tmp82 = ((((((c44 >> 24) & 255) << 24) | ((c44 & 255) << 16)) | (((c44 >> 8) & 255) << 8)) | ((c44 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														_hx_tmp82 = c44;
            													}
HXDLIN(  35)													::iterMagic::Iimg_obj::set(this309,index53,_hx_tmp82);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						if ((hasHit == false)) {
HXLINE(  35)							 ::pi_xy::algo::HitTri v40 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,leftX,ay2,rightX,by2,leftX,bottomY,true);
HXDLIN(  35)							if (hasUndo8) {
HXLINE(  35)								v40->undoImage = undoImage24;
HXDLIN(  35)								v40->undoX = xIter38->start;
HXDLIN(  35)								v40->undoY = yIter38->start;
            							}
            						}
            					}
HXDLIN(  35)					{
HXLINE(  35)						Float au10 = bu;
HXDLIN(  35)						Float av10 = av;
HXDLIN(  35)						Float bu10 = bu;
HXDLIN(  35)						Float bv9 = cv;
HXDLIN(  35)						bool hasUndo9 = false;
HXDLIN(  35)						Float temp10 = au10;
HXLINE( 422)						au10 = bu10;
HXLINE( 423)						bu10 = temp10;
HXLINE( 424)						temp10 = av10;
HXLINE( 425)						av10 = bv9;
HXLINE( 426)						bv9 = temp10;
HXLINE(  35)						Float bcx9 = (rightX - leftX);
HXDLIN(  35)						Float bcy9 = (cy2 - bottomY);
HXDLIN(  35)						Float acx9 = (rightX - leftX);
HXDLIN(  35)						Float acy9 = (by2 - bottomY);
HXDLIN(  35)						Float dot119 = ((bcx9 * bcx9) + (bcy9 * bcy9));
HXDLIN(  35)						Float dot129 = ((bcx9 * acx9) + (bcy9 * acy9));
HXDLIN(  35)						Float dot229 = ((acx9 * acx9) + (acy9 * acy9));
HXDLIN(  35)						Float denom19 = (( (Float)(1) ) / ((dot119 * dot229) - (dot129 * dot129)));
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart xIter39;
HXDLIN(  35)						if ((rightX > rightX)) {
HXLINE(  35)							if ((rightX > leftX)) {
HXLINE(  35)								int min29;
HXDLIN(  35)								if ((rightX > leftX)) {
HXLINE(  35)									min29 = ::Math_obj::floor(leftX);
            								}
            								else {
HXLINE(  35)									min29 = ::Math_obj::floor(rightX);
            								}
HXDLIN(  35)								int ii_min64 = min29;
HXDLIN(  35)								int ii_max64 = ::Math_obj::ceil(rightX);
HXDLIN(  35)								xIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min64,ii_max64);
            							}
            							else {
HXLINE(  35)								int ii_min65 = ::Math_obj::floor(rightX);
HXDLIN(  35)								int ii_max65 = ::Math_obj::ceil(leftX);
HXDLIN(  35)								xIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min65,ii_max65);
            							}
            						}
            						else {
HXLINE(  35)							if ((rightX > leftX)) {
HXLINE(  35)								int min30;
HXDLIN(  35)								if ((rightX > leftX)) {
HXLINE(  35)									min30 = ::Math_obj::floor(leftX);
            								}
            								else {
HXLINE(  35)									min30 = ::Math_obj::ceil(rightX);
            								}
HXDLIN(  35)								int ii_min66 = min30;
HXDLIN(  35)								int ii_max66 = ::Math_obj::ceil(rightX);
HXDLIN(  35)								xIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min66,ii_max66);
            							}
            							else {
HXLINE(  35)								int ii_min67 = ::Math_obj::floor(rightX);
HXDLIN(  35)								int ii_max67 = ::Math_obj::ceil(leftX);
HXDLIN(  35)								xIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min67,ii_max67);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart yIter39;
HXDLIN(  35)						if ((by2 > cy2)) {
HXLINE(  35)							if ((by2 > bottomY)) {
HXLINE(  35)								int min31;
HXDLIN(  35)								if ((cy2 > bottomY)) {
HXLINE(  35)									min31 = ::Math_obj::floor(bottomY);
            								}
            								else {
HXLINE(  35)									min31 = ::Math_obj::floor(cy2);
            								}
HXDLIN(  35)								int ii_min68 = min31;
HXDLIN(  35)								int ii_max68 = ::Math_obj::ceil(by2);
HXDLIN(  35)								yIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min68,ii_max68);
            							}
            							else {
HXLINE(  35)								int ii_min69 = ::Math_obj::floor(cy2);
HXDLIN(  35)								int ii_max69 = ::Math_obj::ceil(bottomY);
HXDLIN(  35)								yIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min69,ii_max69);
            							}
            						}
            						else {
HXLINE(  35)							if ((cy2 > bottomY)) {
HXLINE(  35)								int min32;
HXDLIN(  35)								if ((by2 > bottomY)) {
HXLINE(  35)									min32 = ::Math_obj::floor(bottomY);
            								}
            								else {
HXLINE(  35)									min32 = ::Math_obj::ceil(by2);
            								}
HXDLIN(  35)								int ii_min70 = min32;
HXDLIN(  35)								int ii_max70 = ::Math_obj::ceil(cy2);
HXDLIN(  35)								yIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min70,ii_max70);
            							}
            							else {
HXLINE(  35)								int ii_min71 = ::Math_obj::floor(by2);
HXDLIN(  35)								int ii_max71 = ::Math_obj::ceil(bottomY);
HXDLIN(  35)								yIter39 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min71,ii_max71);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::ImageStruct undoImage27 = null();
HXDLIN(  35)						if (hasUndo9) {
HXLINE(  35)							int width10 = ((xIter39->max - xIter39->start) + 1);
HXDLIN(  35)							int height10 = ((yIter39->max - yIter39->start) + 1);
HXDLIN(  35)							 ::Dynamic imageType10 = null();
HXDLIN(  35)							 ::pi_xy::ImageStruct this310 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  35)							if (::hx::IsNull( imageType10 )) {
HXLINE(  54)								imageType10 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE(  35)							::Dynamic undoImage28;
HXDLIN(  35)							switch((int)(( (int)(imageType10) ))){
            								case (int)0: {
HXLINE(  35)									 ::iterMagic::BytesImg byt10 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::BytesImg b58 = byt10;
HXDLIN(  35)									{
HXLINE(  35)										b58->width = width10;
HXDLIN(  35)										b58->height = height10;
HXDLIN(  35)										b58->length = ::Std_obj::_hx_int(( (Float)((width10 * height10)) ));
HXDLIN(  35)										b58->data = ::haxe::io::Bytes_obj::alloc((b58->length * 4));
HXDLIN(  35)										{
HXLINE(  35)											int len20 = b58->length;
HXDLIN(  35)											int w10 = 0;
HXDLIN(  35)											{
HXLINE(  35)												int _g196 = 0;
HXDLIN(  35)												int _g197 = b58->height;
HXDLIN(  35)												while((_g196 < _g197)){
HXLINE(  35)													_g196 = (_g196 + 1);
HXDLIN(  35)													int y38 = (_g196 - 1);
HXDLIN(  35)													{
HXLINE(  35)														int _g198 = 0;
HXDLIN(  35)														int _g199 = b58->width;
HXDLIN(  35)														while((_g198 < _g199)){
HXLINE(  35)															_g198 = (_g198 + 1);
HXDLIN(  35)															int x38 = (_g198 - 1);
HXDLIN(  35)															{
HXLINE(  35)																w10 = (w10 + 1);
HXDLIN(  35)																b58->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w10 = (w10 + 1);
HXDLIN(  35)																b58->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w10 = (w10 + 1);
HXDLIN(  35)																b58->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w10 = (w10 + 1);
HXDLIN(  35)																b58->data->b[(w10 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage28 = b58;
            								}
            								break;
            								case (int)1: {
HXLINE(  35)									 ::iterMagic::ArrIntImg arrI10 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::ArrIntImg a53 = arrI10;
HXDLIN(  35)									{
HXLINE(  35)										a53->width = width10;
HXDLIN(  35)										a53->height = height10;
HXDLIN(  35)										a53->data = ::Array_obj< int >::__new(0);
HXDLIN(  35)										a53->length = ::Std_obj::_hx_int(( (Float)((width10 * height10)) ));
HXDLIN(  35)										{
HXLINE(  35)											int _g200 = 0;
HXDLIN(  35)											int _g201 = a53->length;
HXDLIN(  35)											while((_g200 < _g201)){
HXLINE(  35)												_g200 = (_g200 + 1);
HXDLIN(  35)												int i60 = (_g200 - 1);
HXDLIN(  35)												a53->data[i60] = 0;
            											}
            										}
            									}
HXDLIN(  35)									undoImage28 = a53;
            								}
            								break;
            								case (int)2: {
HXLINE(  35)									 ::iterMagic::U32ArrImg u32a10 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::U32ArrImg b59 = u32a10;
HXDLIN(  35)									{
HXLINE(  35)										b59->width = width10;
HXDLIN(  35)										b59->height = height10;
HXDLIN(  35)										b59->length = ::Std_obj::_hx_int(( (Float)((width10 * height10)) ));
HXDLIN(  35)										int size10 = (b59->length * 4);
HXDLIN(  35)										b59->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size10),0,size10);
HXDLIN(  35)										{
HXLINE(  35)											int _g202 = 0;
HXDLIN(  35)											int _g203 = b59->length;
HXDLIN(  35)											while((_g202 < _g203)){
HXLINE(  35)												_g202 = (_g202 + 1);
HXDLIN(  35)												int i61 = (_g202 - 1);
HXDLIN(  35)												{
HXLINE(  35)													 ::haxe::io::ArrayBufferViewImpl this311 = b59->data;
HXDLIN(  35)													bool undoImage29;
HXDLIN(  35)													if ((i61 >= 0)) {
HXLINE(  35)														undoImage29 = (i61 < (this311->byteLength >> 2));
            													}
            													else {
HXLINE(  35)														undoImage29 = false;
            													}
HXDLIN(  35)													if (undoImage29) {
HXLINE(  35)														 ::haxe::io::Bytes _this10 = this311->bytes;
HXDLIN(  35)														int pos10 = ((i61 << 2) + this311->byteOffset);
HXDLIN(  35)														_this10->b[pos10] = ( (unsigned char)(0) );
HXDLIN(  35)														_this10->b[(pos10 + 1)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this10->b[(pos10 + 2)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this10->b[(pos10 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage28 = b59;
            								}
            								break;
            								case (int)3: {
HXLINE(  35)									 ::iterMagic::VecIntImg vec10 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::VecIntImg v41 = vec10;
HXDLIN(  35)									{
HXLINE(  35)										v41->width = width10;
HXDLIN(  35)										v41->height = height10;
HXDLIN(  35)										v41->length = ::Std_obj::_hx_int(( (Float)((width10 * height10)) ));
HXDLIN(  35)										v41->data = ::Array_obj< int >::__new(v41->length);
HXDLIN(  35)										{
HXLINE(  35)											int _g204 = 0;
HXDLIN(  35)											int _g205 = v41->length;
HXDLIN(  35)											while((_g204 < _g205)){
HXLINE(  35)												_g204 = (_g204 + 1);
HXDLIN(  35)												int i62 = (_g204 - 1);
HXDLIN(  35)												v41->data->__unsafe_set(i62,0);
            											}
            										}
            									}
HXDLIN(  35)									undoImage28 = v41;
            								}
            								break;
            								case (int)4: {
HXLINE(  35)									 ::iterMagic::StackIntImg sInt10 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::StackIntImg b60 = sInt10;
HXDLIN(  35)									{
HXLINE(  35)										b60->width = width10;
HXDLIN(  35)										b60->height = height10;
HXDLIN(  35)										b60->length = ::Std_obj::_hx_int(( (Float)((width10 * height10)) ));
HXDLIN(  35)										b60->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  35)										{
HXLINE(  35)											int len21 = b60->length;
HXDLIN(  35)											 ::haxe::ds::GenericStack_Int d10 = b60->data;
HXDLIN(  35)											if (::hx::IsNull( d10->head )) {
HXLINE(  35)												int _g206 = 0;
HXDLIN(  35)												int _g207 = len21;
HXDLIN(  35)												while((_g206 < _g207)){
HXLINE(  35)													_g206 = (_g206 + 1);
HXDLIN(  35)													int i63 = (_g206 - 1);
HXDLIN(  35)													d10->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d10->head);
            												}
            											}
            											else {
HXLINE(  35)												int _g208 = 0;
HXDLIN(  35)												int _g209 = len21;
HXDLIN(  35)												while((_g208 < _g209)){
HXLINE(  35)													_g208 = (_g208 + 1);
HXDLIN(  35)													int i64 = (_g208 - 1);
HXDLIN(  35)													{
HXLINE(  35)														 ::haxe::ds::GenericCell_Int l10 = b60->data->head;
HXDLIN(  35)														 ::haxe::ds::GenericCell_Int prev10 = null();
HXDLIN(  35)														{
HXLINE(  35)															int _g210 = 0;
HXDLIN(  35)															int _g211 = i64;
HXDLIN(  35)															while((_g210 < _g211)){
HXLINE(  35)																_g210 = (_g210 + 1);
HXDLIN(  35)																int i65 = (_g210 - 1);
HXLINE( 345)																prev10 = l10;
HXLINE( 346)																l10 = l10->next;
            															}
            														}
HXLINE(  35)														if (::hx::IsNull( prev10 )) {
HXLINE(  35)															b60->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l10->next);
HXDLIN(  35)															l10 = null();
            														}
            														else {
HXLINE(  35)															prev10->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l10->next);
HXDLIN(  35)															l10 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage28 = b60;
            								}
            								break;
            							}
HXDLIN(  35)							this310->image = undoImage28;
HXDLIN(  35)							this310->width = width10;
HXDLIN(  35)							this310->height = height10;
HXDLIN(  35)							this310->imageType = ( (int)(imageType10) );
HXDLIN(  35)							undoImage27 = this310;
HXDLIN(  35)							{
HXLINE(  35)								int rectLeft9 = xIter39->start;
HXDLIN(  35)								int rectTop9 = yIter39->start;
HXDLIN(  35)								int rectRight9 = xIter39->max;
HXDLIN(  35)								bool forceClear9 = false;
HXDLIN(  35)								{
HXLINE(  35)									int _g212 = rectTop9;
HXDLIN(  35)									int _g213 = yIter39->max;
HXDLIN(  35)									while((_g212 < _g213)){
HXLINE(  35)										_g212 = (_g212 + 1);
HXDLIN(  35)										int dy10 = (_g212 - 1);
HXDLIN(  35)										{
HXLINE(  35)											int _g214 = rectLeft9;
HXDLIN(  35)											int _g215 = rectRight9;
HXDLIN(  35)											while((_g214 < _g215)){
HXLINE(  35)												_g214 = (_g214 + 1);
HXDLIN(  35)												int dx10 = (_g214 - 1);
HXDLIN(  35)												::Dynamic this312 = temp->image;
HXDLIN(  35)												int index54;
HXDLIN(  35)												if (temp->useVirtualPos) {
HXLINE(  35)													index54 = ::Std_obj::_hx_int(((((( (Float)(dy10) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx10) - temp->virtualX));
            												}
            												else {
HXLINE(  35)													index54 = ::Std_obj::_hx_int(( (Float)(((dy10 * temp->width) + dx10)) ));
            												}
HXDLIN(  35)												int c45 = ::iterMagic::Iimg_obj::get(this312,index54);
HXDLIN(  35)												int col18;
HXDLIN(  35)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)													col18 = ((((((c45 >> 24) & 255) << 24) | ((c45 & 255) << 16)) | (((c45 >> 8) & 255) << 8)) | ((c45 >> 16) & 255));
            												}
            												else {
HXLINE(  35)													col18 = c45;
            												}
HXDLIN(  35)												bool _hx_tmp83;
HXDLIN(  35)												if (temp->useMask) {
HXLINE(  35)													_hx_tmp83 = ::hx::IsNotNull( temp->mask );
            												}
            												else {
HXLINE(  35)													_hx_tmp83 = false;
            												}
HXDLIN(  35)												if (_hx_tmp83) {
HXLINE(  35)													 ::pi_xy::ImageStruct this313 = temp->mask;
HXDLIN(  35)													::Dynamic this314 = this313->image;
HXDLIN(  35)													int index55;
HXDLIN(  35)													if (this313->useVirtualPos) {
HXLINE(  35)														index55 = ::Std_obj::_hx_int(((((( (Float)(dy10) ) - this313->virtualY) * ( (Float)(this313->width) )) + dx10) - this313->virtualX));
            													}
            													else {
HXLINE(  35)														index55 = ::Std_obj::_hx_int(( (Float)(((dy10 * this313->width) + dx10)) ));
            													}
HXDLIN(  35)													int c46 = ::iterMagic::Iimg_obj::get(this314,index55);
HXDLIN(  35)													int v42;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														v42 = ((((((c46 >> 24) & 255) << 24) | ((c46 & 255) << 16)) | (((c46 >> 8) & 255) << 8)) | ((c46 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														v42 = c46;
            													}
HXDLIN(  35)													int maskPixel9 = v42;
HXDLIN(  35)													int this315 = col18;
HXDLIN(  35)													if ((maskPixel9 == 0)) {
HXLINE(  35)														col18 = this315;
            													}
            													else {
HXLINE(  35)														Float m09;
HXDLIN(  35)														int this316 = ((maskPixel9 >> 24) & 255);
HXDLIN(  35)														if ((this316 == 0)) {
HXLINE(  35)															m09 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m09 = (( (Float)(this316) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m19;
HXDLIN(  35)														int this317 = ((maskPixel9 >> 16) & 255);
HXDLIN(  35)														if ((this317 == 0)) {
HXLINE(  35)															m19 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m19 = (( (Float)(this317) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m29;
HXDLIN(  35)														int this318 = ((maskPixel9 >> 8) & 255);
HXDLIN(  35)														if ((this318 == 0)) {
HXLINE(  35)															m29 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m29 = (( (Float)(this318) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m39;
HXDLIN(  35)														int this319 = (maskPixel9 & 255);
HXDLIN(  35)														if ((this319 == 0)) {
HXLINE(  35)															m39 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m39 = (( (Float)(this319) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														int ch09 = ::Std_obj::_hx_int(((((Float)1.) - m09) * ( (Float)(((this315 >> 24) & 255)) )));
HXDLIN(  35)														int ch19 = ::Std_obj::_hx_int(((((Float)1.) - m19) * ( (Float)(((this315 >> 16) & 255)) )));
HXDLIN(  35)														int ch29 = ::Std_obj::_hx_int(((((Float)1.) - m29) * ( (Float)(((this315 >> 8) & 255)) )));
HXDLIN(  35)														int ch39 = ::Std_obj::_hx_int(((((Float)1.) - m39) * ( (Float)((this315 & 255)) )));
HXDLIN(  35)														col18 = ((((::Math_obj::round((( (Float)(ch09) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch19) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch29) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch39) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  35)												if ((col18 != 0)) {
HXLINE(  35)													int x39 = (dx10 - rectLeft9);
HXDLIN(  35)													int y39 = (dy10 - rectTop9);
HXDLIN(  35)													int c47 = col18;
HXDLIN(  35)													bool _hx_tmp84;
HXDLIN(  35)													if ((((c47 >> 24) & 255) < 254)) {
HXLINE(  35)														_hx_tmp84 = undoImage27->transparent;
            													}
            													else {
HXLINE(  35)														_hx_tmp84 = false;
            													}
HXDLIN(  35)													if (_hx_tmp84) {
HXLINE(  35)														int location18;
HXDLIN(  35)														if (undoImage27->useVirtualPos) {
HXLINE(  35)															location18 = ::Std_obj::_hx_int(((((( (Float)(y39) ) - undoImage27->virtualY) * ( (Float)(undoImage27->width) )) + x39) - undoImage27->virtualX));
            														}
            														else {
HXLINE(  35)															location18 = ::Std_obj::_hx_int(( (Float)(((y39 * undoImage27->width) + x39)) ));
            														}
HXDLIN(  35)														int this320 = ::iterMagic::Iimg_obj::get(undoImage27->image,location18);
HXDLIN(  35)														int this321;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															this321 = ((((((this320 >> 24) & 255) << 24) | ((this320 & 255) << 16)) | (((this320 >> 8) & 255) << 8)) | ((this320 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															this321 = this320;
            														}
HXDLIN(  35)														Float a121;
HXDLIN(  35)														int this322 = ((this321 >> 24) & 255);
HXDLIN(  35)														if ((this322 == 0)) {
HXLINE(  35)															a121 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a121 = (( (Float)(this322) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r118;
HXDLIN(  35)														int this323 = ((this321 >> 16) & 255);
HXDLIN(  35)														if ((this323 == 0)) {
HXLINE(  35)															r118 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r118 = (( (Float)(this323) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g118;
HXDLIN(  35)														int this324 = ((this321 >> 8) & 255);
HXDLIN(  35)														if ((this324 == 0)) {
HXLINE(  35)															g118 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g118 = (( (Float)(this324) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b124;
HXDLIN(  35)														int this325 = (this321 & 255);
HXDLIN(  35)														if ((this325 == 0)) {
HXLINE(  35)															b124 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b124 = (( (Float)(this325) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a220;
HXDLIN(  35)														int this326 = ((col18 >> 24) & 255);
HXDLIN(  35)														if ((this326 == 0)) {
HXLINE(  35)															a220 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a220 = (( (Float)(this326) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r218;
HXDLIN(  35)														int this327 = ((col18 >> 16) & 255);
HXDLIN(  35)														if ((this327 == 0)) {
HXLINE(  35)															r218 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r218 = (( (Float)(this327) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g218;
HXDLIN(  35)														int this328 = ((col18 >> 8) & 255);
HXDLIN(  35)														if ((this328 == 0)) {
HXLINE(  35)															g218 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g218 = (( (Float)(this328) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b222;
HXDLIN(  35)														int this329 = (col18 & 255);
HXDLIN(  35)														if ((this329 == 0)) {
HXLINE(  35)															b222 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b222 = (( (Float)(this329) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a318 = (a121 * (( (Float)(1) ) - a220));
HXDLIN(  35)														int r38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r118 * a318) + (r218 * a220))));
HXDLIN(  35)														int g38 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g118 * a318) + (g218 * a220))));
HXDLIN(  35)														int b61 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b124 * a318) + (b222 * a220))));
HXDLIN(  35)														int a54 = ::Std_obj::_hx_int((( (Float)(255) ) * (a318 + a220)));
HXDLIN(  35)														int blended18 = ((((a54 << 24) | (r38 << 16)) | (g38 << 8)) | b61);
HXDLIN(  35)														{
HXLINE(  35)															int _hx_tmp85;
HXDLIN(  35)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)																_hx_tmp85 = ((((((blended18 >> 24) & 255) << 24) | ((blended18 & 255) << 16)) | (((blended18 >> 8) & 255) << 8)) | ((blended18 >> 16) & 255));
            															}
            															else {
HXLINE(  35)																_hx_tmp85 = blended18;
            															}
HXDLIN(  35)															::iterMagic::Iimg_obj::set(undoImage27->image,location18,_hx_tmp85);
            														}
            													}
            													else {
HXLINE(  35)														::Dynamic this330 = undoImage27->image;
HXDLIN(  35)														int index56;
HXDLIN(  35)														if (undoImage27->useVirtualPos) {
HXLINE(  35)															index56 = ::Std_obj::_hx_int(((((( (Float)(y39) ) - undoImage27->virtualY) * ( (Float)(undoImage27->width) )) + x39) - undoImage27->virtualX));
            														}
            														else {
HXLINE(  35)															index56 = ::Std_obj::_hx_int(( (Float)(((y39 * undoImage27->width) + x39)) ));
            														}
HXDLIN(  35)														int _hx_tmp86;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp86 = ((((((c47 >> 24) & 255) << 24) | ((c47 & 255) << 16)) | (((c47 >> 8) & 255) << 8)) | ((c47 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp86 = c47;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this330,index56,_hx_tmp86);
            													}
            												}
            												else {
HXLINE(  35)													if (forceClear9) {
HXLINE(  35)														::Dynamic this331 = undoImage27->image;
HXDLIN(  35)														int x40 = (dx10 - rectLeft9);
HXDLIN(  35)														int y40 = (dy10 - rectTop9);
HXDLIN(  35)														int index57;
HXDLIN(  35)														if (undoImage27->useVirtualPos) {
HXLINE(  35)															index57 = ::Std_obj::_hx_int(((((( (Float)(y40) ) - undoImage27->virtualY) * ( (Float)(undoImage27->width) )) + x40) - undoImage27->virtualX));
            														}
            														else {
HXLINE(  35)															index57 = ::Std_obj::_hx_int(( (Float)(((y40 * undoImage27->width) + x40)) ));
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this331,index57,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						{
HXLINE(  35)							int _g_min18 = xIter39->start;
HXDLIN(  35)							int _g_max18 = xIter39->max;
HXDLIN(  35)							while((_g_min18 < _g_max18)){
HXLINE(  35)								_g_min18 = (_g_min18 + 1);
HXDLIN(  35)								int px9 = (_g_min18 - 1);
HXDLIN(  35)								Float pcx9 = (( (Float)(px9) ) - leftX);
HXDLIN(  35)								{
HXLINE(  35)									int _g_min19 = yIter39->start;
HXDLIN(  35)									int _g_max19 = yIter39->max;
HXDLIN(  35)									while((_g_min19 < _g_max19)){
HXLINE(  35)										_g_min19 = (_g_min19 + 1);
HXDLIN(  35)										int py9 = (_g_min19 - 1);
HXDLIN(  35)										Float pcy9 = (( (Float)(py9) ) - bottomY);
HXDLIN(  35)										Float dot319 = ((pcx9 * bcx9) + (pcy9 * bcy9));
HXDLIN(  35)										Float dot329 = ((pcx9 * acx9) + (pcy9 * acy9));
HXDLIN(  35)										Float ratioA9 = (((dot229 * dot319) - (dot129 * dot329)) * denom19);
HXDLIN(  35)										Float ratioB9 = (((dot119 * dot329) - (dot129 * dot319)) * denom19);
HXDLIN(  35)										Float ratioC9 = ((((Float)1.0) - ratioB9) - ratioA9);
HXDLIN(  35)										bool _hx_tmp87;
HXDLIN(  35)										bool _hx_tmp88;
HXDLIN(  35)										if ((ratioA9 >= 0)) {
HXLINE(  35)											_hx_tmp88 = (ratioB9 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp88 = false;
            										}
HXDLIN(  35)										if (_hx_tmp88) {
HXLINE(  35)											_hx_tmp87 = (ratioC9 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp87 = false;
            										}
HXDLIN(  35)										if (_hx_tmp87) {
HXLINE(  35)											Float u9 = (((au10 * ratioA9) + (bu10 * ratioB9)) + (au * ratioC9));
HXDLIN(  35)											Float v43 = (((av10 * ratioA9) + (bv9 * ratioB9)) + (cv * ratioC9));
HXDLIN(  35)											int x41 = ::Std_obj::_hx_int(((u9 * win_width) + win_x));
HXDLIN(  35)											int y41 = ::Std_obj::_hx_int(((v43 * win_height) + win_y));
HXDLIN(  35)											::Dynamic this332 = texture->image;
HXDLIN(  35)											int index58;
HXDLIN(  35)											if (texture->useVirtualPos) {
HXLINE(  35)												index58 = ::Std_obj::_hx_int(((((( (Float)(y41) ) - texture->virtualY) * ( (Float)(texture->width) )) + x41) - texture->virtualX));
            											}
            											else {
HXLINE(  35)												index58 = ::Std_obj::_hx_int(( (Float)(((y41 * texture->width) + x41)) ));
            											}
HXDLIN(  35)											int c48 = ::iterMagic::Iimg_obj::get(this332,index58);
HXDLIN(  35)											int col19;
HXDLIN(  35)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)												col19 = ((((((c48 >> 24) & 255) << 24) | ((c48 & 255) << 16)) | (((c48 >> 8) & 255) << 8)) | ((c48 >> 16) & 255));
            											}
            											else {
HXLINE(  35)												col19 = c48;
            											}
HXDLIN(  35)											{
HXLINE(  35)												int c49 = col19;
HXDLIN(  35)												bool _hx_tmp89;
HXDLIN(  35)												if ((((c49 >> 24) & 255) < 254)) {
HXLINE(  35)													_hx_tmp89 = temp->transparent;
            												}
            												else {
HXLINE(  35)													_hx_tmp89 = false;
            												}
HXDLIN(  35)												if (_hx_tmp89) {
HXLINE(  35)													int location19;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														location19 = ::Std_obj::_hx_int(((((( (Float)(py9) ) - temp->virtualY) * ( (Float)(temp->width) )) + px9) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														location19 = ::Std_obj::_hx_int(( (Float)(((py9 * temp->width) + px9)) ));
            													}
HXDLIN(  35)													int this333 = ::iterMagic::Iimg_obj::get(temp->image,location19);
HXDLIN(  35)													int this334;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														this334 = ((((((this333 >> 24) & 255) << 24) | ((this333 & 255) << 16)) | (((this333 >> 8) & 255) << 8)) | ((this333 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														this334 = this333;
            													}
HXDLIN(  35)													Float a122;
HXDLIN(  35)													int this335 = ((this334 >> 24) & 255);
HXDLIN(  35)													if ((this335 == 0)) {
HXLINE(  35)														a122 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a122 = (( (Float)(this335) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r119;
HXDLIN(  35)													int this336 = ((this334 >> 16) & 255);
HXDLIN(  35)													if ((this336 == 0)) {
HXLINE(  35)														r119 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r119 = (( (Float)(this336) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g119;
HXDLIN(  35)													int this337 = ((this334 >> 8) & 255);
HXDLIN(  35)													if ((this337 == 0)) {
HXLINE(  35)														g119 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g119 = (( (Float)(this337) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b125;
HXDLIN(  35)													int this338 = (this334 & 255);
HXDLIN(  35)													if ((this338 == 0)) {
HXLINE(  35)														b125 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b125 = (( (Float)(this338) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a221;
HXDLIN(  35)													int this339 = ((col19 >> 24) & 255);
HXDLIN(  35)													if ((this339 == 0)) {
HXLINE(  35)														a221 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a221 = (( (Float)(this339) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r219;
HXDLIN(  35)													int this340 = ((col19 >> 16) & 255);
HXDLIN(  35)													if ((this340 == 0)) {
HXLINE(  35)														r219 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r219 = (( (Float)(this340) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g219;
HXDLIN(  35)													int this341 = ((col19 >> 8) & 255);
HXDLIN(  35)													if ((this341 == 0)) {
HXLINE(  35)														g219 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g219 = (( (Float)(this341) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b223;
HXDLIN(  35)													int this342 = (col19 & 255);
HXDLIN(  35)													if ((this342 == 0)) {
HXLINE(  35)														b223 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b223 = (( (Float)(this342) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a319 = (a122 * (( (Float)(1) ) - a221));
HXDLIN(  35)													int r39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r119 * a319) + (r219 * a221))));
HXDLIN(  35)													int g39 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g119 * a319) + (g219 * a221))));
HXDLIN(  35)													int b62 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b125 * a319) + (b223 * a221))));
HXDLIN(  35)													int a55 = ::Std_obj::_hx_int((( (Float)(255) ) * (a319 + a221)));
HXDLIN(  35)													int blended19 = ((((a55 << 24) | (r39 << 16)) | (g39 << 8)) | b62);
HXDLIN(  35)													{
HXLINE(  35)														int _hx_tmp90;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp90 = ((((((blended19 >> 24) & 255) << 24) | ((blended19 & 255) << 16)) | (((blended19 >> 8) & 255) << 8)) | ((blended19 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp90 = blended19;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(temp->image,location19,_hx_tmp90);
            													}
            												}
            												else {
HXLINE(  35)													::Dynamic this343 = temp->image;
HXDLIN(  35)													int index59;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														index59 = ::Std_obj::_hx_int(((((( (Float)(py9) ) - temp->virtualY) * ( (Float)(temp->width) )) + px9) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														index59 = ::Std_obj::_hx_int(( (Float)(((py9 * temp->width) + px9)) ));
            													}
HXDLIN(  35)													int _hx_tmp91;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														_hx_tmp91 = ((((((c49 >> 24) & 255) << 24) | ((c49 & 255) << 16)) | (((c49 >> 8) & 255) << 8)) | ((c49 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														_hx_tmp91 = c49;
            													}
HXDLIN(  35)													::iterMagic::Iimg_obj::set(this343,index59,_hx_tmp91);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						if ((hasHit == false)) {
HXLINE(  35)							 ::pi_xy::algo::HitTri v44 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,rightX,by2,rightX,cy2,leftX,bottomY,true);
HXDLIN(  35)							if (hasUndo9) {
HXLINE(  35)								v44->undoImage = undoImage27;
HXDLIN(  35)								v44->undoX = xIter39->start;
HXDLIN(  35)								v44->undoY = yIter39->start;
            							}
            						}
            					}
HXDLIN(  35)					if ((hasHit == true)) {
HXLINE(  35)						 ::pi_xy::algo::HitQuad v45 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,leftX,ay2,rightX,by2,rightX,cy2,leftX,bottomY,true);
            					}
            				}
HXLINE( 273)				au = bu;
HXLINE( 274)				bu = ((Float)1.);
HXLINE(  35)				{
HXLINE(  35)					Float ay3 = (topY - ( (Float)(1) ));
HXDLIN(  35)					Float bx2 = widNew;
HXDLIN(  35)					Float by3 = (topY - ( (Float)(1) ));
HXDLIN(  35)					Float cx2 = widNew;
HXDLIN(  35)					Float cy3 = (bottomY + 1);
HXDLIN(  35)					{
HXLINE(  35)						Float au11 = au;
HXDLIN(  35)						Float av11 = av;
HXDLIN(  35)						Float bu11 = bu;
HXDLIN(  35)						Float bv10 = av;
HXDLIN(  35)						bool hasUndo10 = false;
HXDLIN(  35)						Float temp11 = au11;
HXLINE( 422)						au11 = bu11;
HXLINE( 423)						bu11 = temp11;
HXLINE( 424)						temp11 = av11;
HXLINE( 425)						av11 = bv10;
HXLINE( 426)						bv10 = temp11;
HXLINE(  35)						Float bcx10 = (bx2 - rightX);
HXDLIN(  35)						Float bcy10 = (by3 - bottomY);
HXDLIN(  35)						Float acx10 = (rightX - rightX);
HXDLIN(  35)						Float acy10 = (ay3 - bottomY);
HXDLIN(  35)						Float dot1110 = ((bcx10 * bcx10) + (bcy10 * bcy10));
HXDLIN(  35)						Float dot1210 = ((bcx10 * acx10) + (bcy10 * acy10));
HXDLIN(  35)						Float dot2210 = ((acx10 * acx10) + (acy10 * acy10));
HXDLIN(  35)						Float denom110 = (( (Float)(1) ) / ((dot1110 * dot2210) - (dot1210 * dot1210)));
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart xIter310;
HXDLIN(  35)						if ((rightX > bx2)) {
HXLINE(  35)							if ((rightX > rightX)) {
HXLINE(  35)								int min33;
HXDLIN(  35)								if ((bx2 > rightX)) {
HXLINE(  35)									min33 = ::Math_obj::floor(rightX);
            								}
            								else {
HXLINE(  35)									min33 = ::Math_obj::floor(bx2);
            								}
HXDLIN(  35)								int ii_min72 = min33;
HXDLIN(  35)								int ii_max72 = ::Math_obj::ceil(rightX);
HXDLIN(  35)								xIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min72,ii_max72);
            							}
            							else {
HXLINE(  35)								int ii_min73 = ::Math_obj::floor(bx2);
HXDLIN(  35)								int ii_max73 = ::Math_obj::ceil(rightX);
HXDLIN(  35)								xIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min73,ii_max73);
            							}
            						}
            						else {
HXLINE(  35)							if ((bx2 > rightX)) {
HXLINE(  35)								int min34;
HXDLIN(  35)								if ((rightX > rightX)) {
HXLINE(  35)									min34 = ::Math_obj::floor(rightX);
            								}
            								else {
HXLINE(  35)									min34 = ::Math_obj::ceil(rightX);
            								}
HXDLIN(  35)								int ii_min74 = min34;
HXDLIN(  35)								int ii_max74 = ::Math_obj::ceil(bx2);
HXDLIN(  35)								xIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min74,ii_max74);
            							}
            							else {
HXLINE(  35)								int ii_min75 = ::Math_obj::floor(rightX);
HXDLIN(  35)								int ii_max75 = ::Math_obj::ceil(rightX);
HXDLIN(  35)								xIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min75,ii_max75);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart yIter310;
HXDLIN(  35)						if ((ay3 > by3)) {
HXLINE(  35)							if ((ay3 > bottomY)) {
HXLINE(  35)								int min35;
HXDLIN(  35)								if ((by3 > bottomY)) {
HXLINE(  35)									min35 = ::Math_obj::floor(bottomY);
            								}
            								else {
HXLINE(  35)									min35 = ::Math_obj::floor(by3);
            								}
HXDLIN(  35)								int ii_min76 = min35;
HXDLIN(  35)								int ii_max76 = ::Math_obj::ceil(ay3);
HXDLIN(  35)								yIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min76,ii_max76);
            							}
            							else {
HXLINE(  35)								int ii_min77 = ::Math_obj::floor(by3);
HXDLIN(  35)								int ii_max77 = ::Math_obj::ceil(bottomY);
HXDLIN(  35)								yIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min77,ii_max77);
            							}
            						}
            						else {
HXLINE(  35)							if ((by3 > bottomY)) {
HXLINE(  35)								int min36;
HXDLIN(  35)								if ((ay3 > bottomY)) {
HXLINE(  35)									min36 = ::Math_obj::floor(bottomY);
            								}
            								else {
HXLINE(  35)									min36 = ::Math_obj::ceil(ay3);
            								}
HXDLIN(  35)								int ii_min78 = min36;
HXDLIN(  35)								int ii_max78 = ::Math_obj::ceil(by3);
HXDLIN(  35)								yIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min78,ii_max78);
            							}
            							else {
HXLINE(  35)								int ii_min79 = ::Math_obj::floor(ay3);
HXDLIN(  35)								int ii_max79 = ::Math_obj::ceil(bottomY);
HXDLIN(  35)								yIter310 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min79,ii_max79);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::ImageStruct undoImage30 = null();
HXDLIN(  35)						if (hasUndo10) {
HXLINE(  35)							int width11 = ((xIter310->max - xIter310->start) + 1);
HXDLIN(  35)							int height11 = ((yIter310->max - yIter310->start) + 1);
HXDLIN(  35)							 ::Dynamic imageType11 = null();
HXDLIN(  35)							 ::pi_xy::ImageStruct this344 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  35)							if (::hx::IsNull( imageType11 )) {
HXLINE(  54)								imageType11 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE(  35)							::Dynamic undoImage31;
HXDLIN(  35)							switch((int)(( (int)(imageType11) ))){
            								case (int)0: {
HXLINE(  35)									 ::iterMagic::BytesImg byt11 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::BytesImg b63 = byt11;
HXDLIN(  35)									{
HXLINE(  35)										b63->width = width11;
HXDLIN(  35)										b63->height = height11;
HXDLIN(  35)										b63->length = ::Std_obj::_hx_int(( (Float)((width11 * height11)) ));
HXDLIN(  35)										b63->data = ::haxe::io::Bytes_obj::alloc((b63->length * 4));
HXDLIN(  35)										{
HXLINE(  35)											int len22 = b63->length;
HXDLIN(  35)											int w11 = 0;
HXDLIN(  35)											{
HXLINE(  35)												int _g216 = 0;
HXDLIN(  35)												int _g217 = b63->height;
HXDLIN(  35)												while((_g216 < _g217)){
HXLINE(  35)													_g216 = (_g216 + 1);
HXDLIN(  35)													int y42 = (_g216 - 1);
HXDLIN(  35)													{
HXLINE(  35)														int _g218 = 0;
HXDLIN(  35)														int _g219 = b63->width;
HXDLIN(  35)														while((_g218 < _g219)){
HXLINE(  35)															_g218 = (_g218 + 1);
HXDLIN(  35)															int x42 = (_g218 - 1);
HXDLIN(  35)															{
HXLINE(  35)																w11 = (w11 + 1);
HXDLIN(  35)																b63->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w11 = (w11 + 1);
HXDLIN(  35)																b63->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w11 = (w11 + 1);
HXDLIN(  35)																b63->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w11 = (w11 + 1);
HXDLIN(  35)																b63->data->b[(w11 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage31 = b63;
            								}
            								break;
            								case (int)1: {
HXLINE(  35)									 ::iterMagic::ArrIntImg arrI11 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::ArrIntImg a56 = arrI11;
HXDLIN(  35)									{
HXLINE(  35)										a56->width = width11;
HXDLIN(  35)										a56->height = height11;
HXDLIN(  35)										a56->data = ::Array_obj< int >::__new(0);
HXDLIN(  35)										a56->length = ::Std_obj::_hx_int(( (Float)((width11 * height11)) ));
HXDLIN(  35)										{
HXLINE(  35)											int _g220 = 0;
HXDLIN(  35)											int _g221 = a56->length;
HXDLIN(  35)											while((_g220 < _g221)){
HXLINE(  35)												_g220 = (_g220 + 1);
HXDLIN(  35)												int i66 = (_g220 - 1);
HXDLIN(  35)												a56->data[i66] = 0;
            											}
            										}
            									}
HXDLIN(  35)									undoImage31 = a56;
            								}
            								break;
            								case (int)2: {
HXLINE(  35)									 ::iterMagic::U32ArrImg u32a11 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::U32ArrImg b64 = u32a11;
HXDLIN(  35)									{
HXLINE(  35)										b64->width = width11;
HXDLIN(  35)										b64->height = height11;
HXDLIN(  35)										b64->length = ::Std_obj::_hx_int(( (Float)((width11 * height11)) ));
HXDLIN(  35)										int size11 = (b64->length * 4);
HXDLIN(  35)										b64->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size11),0,size11);
HXDLIN(  35)										{
HXLINE(  35)											int _g222 = 0;
HXDLIN(  35)											int _g223 = b64->length;
HXDLIN(  35)											while((_g222 < _g223)){
HXLINE(  35)												_g222 = (_g222 + 1);
HXDLIN(  35)												int i67 = (_g222 - 1);
HXDLIN(  35)												{
HXLINE(  35)													 ::haxe::io::ArrayBufferViewImpl this345 = b64->data;
HXDLIN(  35)													bool undoImage32;
HXDLIN(  35)													if ((i67 >= 0)) {
HXLINE(  35)														undoImage32 = (i67 < (this345->byteLength >> 2));
            													}
            													else {
HXLINE(  35)														undoImage32 = false;
            													}
HXDLIN(  35)													if (undoImage32) {
HXLINE(  35)														 ::haxe::io::Bytes _this11 = this345->bytes;
HXDLIN(  35)														int pos11 = ((i67 << 2) + this345->byteOffset);
HXDLIN(  35)														_this11->b[pos11] = ( (unsigned char)(0) );
HXDLIN(  35)														_this11->b[(pos11 + 1)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this11->b[(pos11 + 2)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this11->b[(pos11 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage31 = b64;
            								}
            								break;
            								case (int)3: {
HXLINE(  35)									 ::iterMagic::VecIntImg vec11 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::VecIntImg v46 = vec11;
HXDLIN(  35)									{
HXLINE(  35)										v46->width = width11;
HXDLIN(  35)										v46->height = height11;
HXDLIN(  35)										v46->length = ::Std_obj::_hx_int(( (Float)((width11 * height11)) ));
HXDLIN(  35)										v46->data = ::Array_obj< int >::__new(v46->length);
HXDLIN(  35)										{
HXLINE(  35)											int _g224 = 0;
HXDLIN(  35)											int _g225 = v46->length;
HXDLIN(  35)											while((_g224 < _g225)){
HXLINE(  35)												_g224 = (_g224 + 1);
HXDLIN(  35)												int i68 = (_g224 - 1);
HXDLIN(  35)												v46->data->__unsafe_set(i68,0);
            											}
            										}
            									}
HXDLIN(  35)									undoImage31 = v46;
            								}
            								break;
            								case (int)4: {
HXLINE(  35)									 ::iterMagic::StackIntImg sInt11 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::StackIntImg b65 = sInt11;
HXDLIN(  35)									{
HXLINE(  35)										b65->width = width11;
HXDLIN(  35)										b65->height = height11;
HXDLIN(  35)										b65->length = ::Std_obj::_hx_int(( (Float)((width11 * height11)) ));
HXDLIN(  35)										b65->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  35)										{
HXLINE(  35)											int len23 = b65->length;
HXDLIN(  35)											 ::haxe::ds::GenericStack_Int d11 = b65->data;
HXDLIN(  35)											if (::hx::IsNull( d11->head )) {
HXLINE(  35)												int _g226 = 0;
HXDLIN(  35)												int _g227 = len23;
HXDLIN(  35)												while((_g226 < _g227)){
HXLINE(  35)													_g226 = (_g226 + 1);
HXDLIN(  35)													int i69 = (_g226 - 1);
HXDLIN(  35)													d11->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d11->head);
            												}
            											}
            											else {
HXLINE(  35)												int _g228 = 0;
HXDLIN(  35)												int _g229 = len23;
HXDLIN(  35)												while((_g228 < _g229)){
HXLINE(  35)													_g228 = (_g228 + 1);
HXDLIN(  35)													int i70 = (_g228 - 1);
HXDLIN(  35)													{
HXLINE(  35)														 ::haxe::ds::GenericCell_Int l11 = b65->data->head;
HXDLIN(  35)														 ::haxe::ds::GenericCell_Int prev11 = null();
HXDLIN(  35)														{
HXLINE(  35)															int _g230 = 0;
HXDLIN(  35)															int _g231 = i70;
HXDLIN(  35)															while((_g230 < _g231)){
HXLINE(  35)																_g230 = (_g230 + 1);
HXDLIN(  35)																int i71 = (_g230 - 1);
HXLINE( 345)																prev11 = l11;
HXLINE( 346)																l11 = l11->next;
            															}
            														}
HXLINE(  35)														if (::hx::IsNull( prev11 )) {
HXLINE(  35)															b65->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l11->next);
HXDLIN(  35)															l11 = null();
            														}
            														else {
HXLINE(  35)															prev11->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l11->next);
HXDLIN(  35)															l11 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage31 = b65;
            								}
            								break;
            							}
HXDLIN(  35)							this344->image = undoImage31;
HXDLIN(  35)							this344->width = width11;
HXDLIN(  35)							this344->height = height11;
HXDLIN(  35)							this344->imageType = ( (int)(imageType11) );
HXDLIN(  35)							undoImage30 = this344;
HXDLIN(  35)							{
HXLINE(  35)								int rectLeft10 = xIter310->start;
HXDLIN(  35)								int rectTop10 = yIter310->start;
HXDLIN(  35)								int rectRight10 = xIter310->max;
HXDLIN(  35)								bool forceClear10 = false;
HXDLIN(  35)								{
HXLINE(  35)									int _g232 = rectTop10;
HXDLIN(  35)									int _g233 = yIter310->max;
HXDLIN(  35)									while((_g232 < _g233)){
HXLINE(  35)										_g232 = (_g232 + 1);
HXDLIN(  35)										int dy11 = (_g232 - 1);
HXDLIN(  35)										{
HXLINE(  35)											int _g234 = rectLeft10;
HXDLIN(  35)											int _g235 = rectRight10;
HXDLIN(  35)											while((_g234 < _g235)){
HXLINE(  35)												_g234 = (_g234 + 1);
HXDLIN(  35)												int dx11 = (_g234 - 1);
HXDLIN(  35)												::Dynamic this346 = temp->image;
HXDLIN(  35)												int index60;
HXDLIN(  35)												if (temp->useVirtualPos) {
HXLINE(  35)													index60 = ::Std_obj::_hx_int(((((( (Float)(dy11) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx11) - temp->virtualX));
            												}
            												else {
HXLINE(  35)													index60 = ::Std_obj::_hx_int(( (Float)(((dy11 * temp->width) + dx11)) ));
            												}
HXDLIN(  35)												int c50 = ::iterMagic::Iimg_obj::get(this346,index60);
HXDLIN(  35)												int col20;
HXDLIN(  35)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)													col20 = ((((((c50 >> 24) & 255) << 24) | ((c50 & 255) << 16)) | (((c50 >> 8) & 255) << 8)) | ((c50 >> 16) & 255));
            												}
            												else {
HXLINE(  35)													col20 = c50;
            												}
HXDLIN(  35)												bool _hx_tmp92;
HXDLIN(  35)												if (temp->useMask) {
HXLINE(  35)													_hx_tmp92 = ::hx::IsNotNull( temp->mask );
            												}
            												else {
HXLINE(  35)													_hx_tmp92 = false;
            												}
HXDLIN(  35)												if (_hx_tmp92) {
HXLINE(  35)													 ::pi_xy::ImageStruct this347 = temp->mask;
HXDLIN(  35)													::Dynamic this348 = this347->image;
HXDLIN(  35)													int index61;
HXDLIN(  35)													if (this347->useVirtualPos) {
HXLINE(  35)														index61 = ::Std_obj::_hx_int(((((( (Float)(dy11) ) - this347->virtualY) * ( (Float)(this347->width) )) + dx11) - this347->virtualX));
            													}
            													else {
HXLINE(  35)														index61 = ::Std_obj::_hx_int(( (Float)(((dy11 * this347->width) + dx11)) ));
            													}
HXDLIN(  35)													int c51 = ::iterMagic::Iimg_obj::get(this348,index61);
HXDLIN(  35)													int v47;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														v47 = ((((((c51 >> 24) & 255) << 24) | ((c51 & 255) << 16)) | (((c51 >> 8) & 255) << 8)) | ((c51 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														v47 = c51;
            													}
HXDLIN(  35)													int maskPixel10 = v47;
HXDLIN(  35)													int this349 = col20;
HXDLIN(  35)													if ((maskPixel10 == 0)) {
HXLINE(  35)														col20 = this349;
            													}
            													else {
HXLINE(  35)														Float m010;
HXDLIN(  35)														int this350 = ((maskPixel10 >> 24) & 255);
HXDLIN(  35)														if ((this350 == 0)) {
HXLINE(  35)															m010 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m010 = (( (Float)(this350) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m110;
HXDLIN(  35)														int this351 = ((maskPixel10 >> 16) & 255);
HXDLIN(  35)														if ((this351 == 0)) {
HXLINE(  35)															m110 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m110 = (( (Float)(this351) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m210;
HXDLIN(  35)														int this352 = ((maskPixel10 >> 8) & 255);
HXDLIN(  35)														if ((this352 == 0)) {
HXLINE(  35)															m210 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m210 = (( (Float)(this352) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m310;
HXDLIN(  35)														int this353 = (maskPixel10 & 255);
HXDLIN(  35)														if ((this353 == 0)) {
HXLINE(  35)															m310 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m310 = (( (Float)(this353) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														int ch010 = ::Std_obj::_hx_int(((((Float)1.) - m010) * ( (Float)(((this349 >> 24) & 255)) )));
HXDLIN(  35)														int ch110 = ::Std_obj::_hx_int(((((Float)1.) - m110) * ( (Float)(((this349 >> 16) & 255)) )));
HXDLIN(  35)														int ch210 = ::Std_obj::_hx_int(((((Float)1.) - m210) * ( (Float)(((this349 >> 8) & 255)) )));
HXDLIN(  35)														int ch310 = ::Std_obj::_hx_int(((((Float)1.) - m310) * ( (Float)((this349 & 255)) )));
HXDLIN(  35)														col20 = ((((::Math_obj::round((( (Float)(ch010) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch110) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch210) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch310) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  35)												if ((col20 != 0)) {
HXLINE(  35)													int x43 = (dx11 - rectLeft10);
HXDLIN(  35)													int y43 = (dy11 - rectTop10);
HXDLIN(  35)													int c52 = col20;
HXDLIN(  35)													bool _hx_tmp93;
HXDLIN(  35)													if ((((c52 >> 24) & 255) < 254)) {
HXLINE(  35)														_hx_tmp93 = undoImage30->transparent;
            													}
            													else {
HXLINE(  35)														_hx_tmp93 = false;
            													}
HXDLIN(  35)													if (_hx_tmp93) {
HXLINE(  35)														int location20;
HXDLIN(  35)														if (undoImage30->useVirtualPos) {
HXLINE(  35)															location20 = ::Std_obj::_hx_int(((((( (Float)(y43) ) - undoImage30->virtualY) * ( (Float)(undoImage30->width) )) + x43) - undoImage30->virtualX));
            														}
            														else {
HXLINE(  35)															location20 = ::Std_obj::_hx_int(( (Float)(((y43 * undoImage30->width) + x43)) ));
            														}
HXDLIN(  35)														int this354 = ::iterMagic::Iimg_obj::get(undoImage30->image,location20);
HXDLIN(  35)														int this355;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															this355 = ((((((this354 >> 24) & 255) << 24) | ((this354 & 255) << 16)) | (((this354 >> 8) & 255) << 8)) | ((this354 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															this355 = this354;
            														}
HXDLIN(  35)														Float a123;
HXDLIN(  35)														int this356 = ((this355 >> 24) & 255);
HXDLIN(  35)														if ((this356 == 0)) {
HXLINE(  35)															a123 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a123 = (( (Float)(this356) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r120;
HXDLIN(  35)														int this357 = ((this355 >> 16) & 255);
HXDLIN(  35)														if ((this357 == 0)) {
HXLINE(  35)															r120 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r120 = (( (Float)(this357) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g120;
HXDLIN(  35)														int this358 = ((this355 >> 8) & 255);
HXDLIN(  35)														if ((this358 == 0)) {
HXLINE(  35)															g120 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g120 = (( (Float)(this358) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b126;
HXDLIN(  35)														int this359 = (this355 & 255);
HXDLIN(  35)														if ((this359 == 0)) {
HXLINE(  35)															b126 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b126 = (( (Float)(this359) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a222;
HXDLIN(  35)														int this360 = ((col20 >> 24) & 255);
HXDLIN(  35)														if ((this360 == 0)) {
HXLINE(  35)															a222 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a222 = (( (Float)(this360) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r220;
HXDLIN(  35)														int this361 = ((col20 >> 16) & 255);
HXDLIN(  35)														if ((this361 == 0)) {
HXLINE(  35)															r220 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r220 = (( (Float)(this361) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g220;
HXDLIN(  35)														int this362 = ((col20 >> 8) & 255);
HXDLIN(  35)														if ((this362 == 0)) {
HXLINE(  35)															g220 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g220 = (( (Float)(this362) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b224;
HXDLIN(  35)														int this363 = (col20 & 255);
HXDLIN(  35)														if ((this363 == 0)) {
HXLINE(  35)															b224 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b224 = (( (Float)(this363) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a320 = (a123 * (( (Float)(1) ) - a222));
HXDLIN(  35)														int r40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r120 * a320) + (r220 * a222))));
HXDLIN(  35)														int g40 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g120 * a320) + (g220 * a222))));
HXDLIN(  35)														int b66 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b126 * a320) + (b224 * a222))));
HXDLIN(  35)														int a57 = ::Std_obj::_hx_int((( (Float)(255) ) * (a320 + a222)));
HXDLIN(  35)														int blended20 = ((((a57 << 24) | (r40 << 16)) | (g40 << 8)) | b66);
HXDLIN(  35)														{
HXLINE(  35)															int _hx_tmp94;
HXDLIN(  35)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)																_hx_tmp94 = ((((((blended20 >> 24) & 255) << 24) | ((blended20 & 255) << 16)) | (((blended20 >> 8) & 255) << 8)) | ((blended20 >> 16) & 255));
            															}
            															else {
HXLINE(  35)																_hx_tmp94 = blended20;
            															}
HXDLIN(  35)															::iterMagic::Iimg_obj::set(undoImage30->image,location20,_hx_tmp94);
            														}
            													}
            													else {
HXLINE(  35)														::Dynamic this364 = undoImage30->image;
HXDLIN(  35)														int index62;
HXDLIN(  35)														if (undoImage30->useVirtualPos) {
HXLINE(  35)															index62 = ::Std_obj::_hx_int(((((( (Float)(y43) ) - undoImage30->virtualY) * ( (Float)(undoImage30->width) )) + x43) - undoImage30->virtualX));
            														}
            														else {
HXLINE(  35)															index62 = ::Std_obj::_hx_int(( (Float)(((y43 * undoImage30->width) + x43)) ));
            														}
HXDLIN(  35)														int _hx_tmp95;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp95 = ((((((c52 >> 24) & 255) << 24) | ((c52 & 255) << 16)) | (((c52 >> 8) & 255) << 8)) | ((c52 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp95 = c52;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this364,index62,_hx_tmp95);
            													}
            												}
            												else {
HXLINE(  35)													if (forceClear10) {
HXLINE(  35)														::Dynamic this365 = undoImage30->image;
HXDLIN(  35)														int x44 = (dx11 - rectLeft10);
HXDLIN(  35)														int y44 = (dy11 - rectTop10);
HXDLIN(  35)														int index63;
HXDLIN(  35)														if (undoImage30->useVirtualPos) {
HXLINE(  35)															index63 = ::Std_obj::_hx_int(((((( (Float)(y44) ) - undoImage30->virtualY) * ( (Float)(undoImage30->width) )) + x44) - undoImage30->virtualX));
            														}
            														else {
HXLINE(  35)															index63 = ::Std_obj::_hx_int(( (Float)(((y44 * undoImage30->width) + x44)) ));
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this365,index63,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						{
HXLINE(  35)							int _g_min20 = xIter310->start;
HXDLIN(  35)							int _g_max20 = xIter310->max;
HXDLIN(  35)							while((_g_min20 < _g_max20)){
HXLINE(  35)								_g_min20 = (_g_min20 + 1);
HXDLIN(  35)								int px10 = (_g_min20 - 1);
HXDLIN(  35)								Float pcx10 = (( (Float)(px10) ) - rightX);
HXDLIN(  35)								{
HXLINE(  35)									int _g_min21 = yIter310->start;
HXDLIN(  35)									int _g_max21 = yIter310->max;
HXDLIN(  35)									while((_g_min21 < _g_max21)){
HXLINE(  35)										_g_min21 = (_g_min21 + 1);
HXDLIN(  35)										int py10 = (_g_min21 - 1);
HXDLIN(  35)										Float pcy10 = (( (Float)(py10) ) - bottomY);
HXDLIN(  35)										Float dot3110 = ((pcx10 * bcx10) + (pcy10 * bcy10));
HXDLIN(  35)										Float dot3210 = ((pcx10 * acx10) + (pcy10 * acy10));
HXDLIN(  35)										Float ratioA10 = (((dot2210 * dot3110) - (dot1210 * dot3210)) * denom110);
HXDLIN(  35)										Float ratioB10 = (((dot1110 * dot3210) - (dot1210 * dot3110)) * denom110);
HXDLIN(  35)										Float ratioC10 = ((((Float)1.0) - ratioB10) - ratioA10);
HXDLIN(  35)										bool _hx_tmp96;
HXDLIN(  35)										bool _hx_tmp97;
HXDLIN(  35)										if ((ratioA10 >= 0)) {
HXLINE(  35)											_hx_tmp97 = (ratioB10 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp97 = false;
            										}
HXDLIN(  35)										if (_hx_tmp97) {
HXLINE(  35)											_hx_tmp96 = (ratioC10 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp96 = false;
            										}
HXDLIN(  35)										if (_hx_tmp96) {
HXLINE(  35)											Float u10 = (((au11 * ratioA10) + (bu11 * ratioB10)) + (au * ratioC10));
HXDLIN(  35)											Float v48 = (((av11 * ratioA10) + (bv10 * ratioB10)) + (cv * ratioC10));
HXDLIN(  35)											int x45 = ::Std_obj::_hx_int(((u10 * win_width) + win_x));
HXDLIN(  35)											int y45 = ::Std_obj::_hx_int(((v48 * win_height) + win_y));
HXDLIN(  35)											::Dynamic this366 = texture->image;
HXDLIN(  35)											int index64;
HXDLIN(  35)											if (texture->useVirtualPos) {
HXLINE(  35)												index64 = ::Std_obj::_hx_int(((((( (Float)(y45) ) - texture->virtualY) * ( (Float)(texture->width) )) + x45) - texture->virtualX));
            											}
            											else {
HXLINE(  35)												index64 = ::Std_obj::_hx_int(( (Float)(((y45 * texture->width) + x45)) ));
            											}
HXDLIN(  35)											int c53 = ::iterMagic::Iimg_obj::get(this366,index64);
HXDLIN(  35)											int col21;
HXDLIN(  35)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)												col21 = ((((((c53 >> 24) & 255) << 24) | ((c53 & 255) << 16)) | (((c53 >> 8) & 255) << 8)) | ((c53 >> 16) & 255));
            											}
            											else {
HXLINE(  35)												col21 = c53;
            											}
HXDLIN(  35)											{
HXLINE(  35)												int c54 = col21;
HXDLIN(  35)												bool _hx_tmp98;
HXDLIN(  35)												if ((((c54 >> 24) & 255) < 254)) {
HXLINE(  35)													_hx_tmp98 = temp->transparent;
            												}
            												else {
HXLINE(  35)													_hx_tmp98 = false;
            												}
HXDLIN(  35)												if (_hx_tmp98) {
HXLINE(  35)													int location21;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														location21 = ::Std_obj::_hx_int(((((( (Float)(py10) ) - temp->virtualY) * ( (Float)(temp->width) )) + px10) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														location21 = ::Std_obj::_hx_int(( (Float)(((py10 * temp->width) + px10)) ));
            													}
HXDLIN(  35)													int this367 = ::iterMagic::Iimg_obj::get(temp->image,location21);
HXDLIN(  35)													int this368;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														this368 = ((((((this367 >> 24) & 255) << 24) | ((this367 & 255) << 16)) | (((this367 >> 8) & 255) << 8)) | ((this367 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														this368 = this367;
            													}
HXDLIN(  35)													Float a124;
HXDLIN(  35)													int this369 = ((this368 >> 24) & 255);
HXDLIN(  35)													if ((this369 == 0)) {
HXLINE(  35)														a124 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a124 = (( (Float)(this369) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r121;
HXDLIN(  35)													int this370 = ((this368 >> 16) & 255);
HXDLIN(  35)													if ((this370 == 0)) {
HXLINE(  35)														r121 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r121 = (( (Float)(this370) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g121;
HXDLIN(  35)													int this371 = ((this368 >> 8) & 255);
HXDLIN(  35)													if ((this371 == 0)) {
HXLINE(  35)														g121 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g121 = (( (Float)(this371) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b127;
HXDLIN(  35)													int this372 = (this368 & 255);
HXDLIN(  35)													if ((this372 == 0)) {
HXLINE(  35)														b127 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b127 = (( (Float)(this372) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a223;
HXDLIN(  35)													int this373 = ((col21 >> 24) & 255);
HXDLIN(  35)													if ((this373 == 0)) {
HXLINE(  35)														a223 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a223 = (( (Float)(this373) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r221;
HXDLIN(  35)													int this374 = ((col21 >> 16) & 255);
HXDLIN(  35)													if ((this374 == 0)) {
HXLINE(  35)														r221 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r221 = (( (Float)(this374) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g221;
HXDLIN(  35)													int this375 = ((col21 >> 8) & 255);
HXDLIN(  35)													if ((this375 == 0)) {
HXLINE(  35)														g221 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g221 = (( (Float)(this375) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b225;
HXDLIN(  35)													int this376 = (col21 & 255);
HXDLIN(  35)													if ((this376 == 0)) {
HXLINE(  35)														b225 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b225 = (( (Float)(this376) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a321 = (a124 * (( (Float)(1) ) - a223));
HXDLIN(  35)													int r41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r121 * a321) + (r221 * a223))));
HXDLIN(  35)													int g41 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g121 * a321) + (g221 * a223))));
HXDLIN(  35)													int b67 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b127 * a321) + (b225 * a223))));
HXDLIN(  35)													int a58 = ::Std_obj::_hx_int((( (Float)(255) ) * (a321 + a223)));
HXDLIN(  35)													int blended21 = ((((a58 << 24) | (r41 << 16)) | (g41 << 8)) | b67);
HXDLIN(  35)													{
HXLINE(  35)														int _hx_tmp99;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp99 = ((((((blended21 >> 24) & 255) << 24) | ((blended21 & 255) << 16)) | (((blended21 >> 8) & 255) << 8)) | ((blended21 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp99 = blended21;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(temp->image,location21,_hx_tmp99);
            													}
            												}
            												else {
HXLINE(  35)													::Dynamic this377 = temp->image;
HXDLIN(  35)													int index65;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														index65 = ::Std_obj::_hx_int(((((( (Float)(py10) ) - temp->virtualY) * ( (Float)(temp->width) )) + px10) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														index65 = ::Std_obj::_hx_int(( (Float)(((py10 * temp->width) + px10)) ));
            													}
HXDLIN(  35)													int _hx_tmp100;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														_hx_tmp100 = ((((((c54 >> 24) & 255) << 24) | ((c54 & 255) << 16)) | (((c54 >> 8) & 255) << 8)) | ((c54 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														_hx_tmp100 = c54;
            													}
HXDLIN(  35)													::iterMagic::Iimg_obj::set(this377,index65,_hx_tmp100);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						if ((hasHit == false)) {
HXLINE(  35)							 ::pi_xy::algo::HitTri v49 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,rightX,ay3,bx2,by3,rightX,bottomY,true);
HXDLIN(  35)							if (hasUndo10) {
HXLINE(  35)								v49->undoImage = undoImage30;
HXDLIN(  35)								v49->undoX = xIter310->start;
HXDLIN(  35)								v49->undoY = yIter310->start;
            							}
            						}
            					}
HXDLIN(  35)					{
HXLINE(  35)						Float au12 = bu;
HXDLIN(  35)						Float av12 = av;
HXDLIN(  35)						Float bu12 = bu;
HXDLIN(  35)						Float bv11 = cv;
HXDLIN(  35)						bool hasUndo11 = false;
HXDLIN(  35)						Float temp12 = au12;
HXLINE( 422)						au12 = bu12;
HXLINE( 423)						bu12 = temp12;
HXLINE( 424)						temp12 = av12;
HXLINE( 425)						av12 = bv11;
HXLINE( 426)						bv11 = temp12;
HXLINE(  35)						Float bcx11 = (cx2 - rightX);
HXDLIN(  35)						Float bcy11 = (cy3 - bottomY);
HXDLIN(  35)						Float acx11 = (bx2 - rightX);
HXDLIN(  35)						Float acy11 = (by3 - bottomY);
HXDLIN(  35)						Float dot1111 = ((bcx11 * bcx11) + (bcy11 * bcy11));
HXDLIN(  35)						Float dot1211 = ((bcx11 * acx11) + (bcy11 * acy11));
HXDLIN(  35)						Float dot2211 = ((acx11 * acx11) + (acy11 * acy11));
HXDLIN(  35)						Float denom111 = (( (Float)(1) ) / ((dot1111 * dot2211) - (dot1211 * dot1211)));
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart xIter311;
HXDLIN(  35)						if ((bx2 > cx2)) {
HXLINE(  35)							if ((bx2 > rightX)) {
HXLINE(  35)								int min37;
HXDLIN(  35)								if ((cx2 > rightX)) {
HXLINE(  35)									min37 = ::Math_obj::floor(rightX);
            								}
            								else {
HXLINE(  35)									min37 = ::Math_obj::floor(cx2);
            								}
HXDLIN(  35)								int ii_min80 = min37;
HXDLIN(  35)								int ii_max80 = ::Math_obj::ceil(bx2);
HXDLIN(  35)								xIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min80,ii_max80);
            							}
            							else {
HXLINE(  35)								int ii_min81 = ::Math_obj::floor(cx2);
HXDLIN(  35)								int ii_max81 = ::Math_obj::ceil(rightX);
HXDLIN(  35)								xIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min81,ii_max81);
            							}
            						}
            						else {
HXLINE(  35)							if ((cx2 > rightX)) {
HXLINE(  35)								int min38;
HXDLIN(  35)								if ((bx2 > rightX)) {
HXLINE(  35)									min38 = ::Math_obj::floor(rightX);
            								}
            								else {
HXLINE(  35)									min38 = ::Math_obj::ceil(bx2);
            								}
HXDLIN(  35)								int ii_min82 = min38;
HXDLIN(  35)								int ii_max82 = ::Math_obj::ceil(cx2);
HXDLIN(  35)								xIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min82,ii_max82);
            							}
            							else {
HXLINE(  35)								int ii_min83 = ::Math_obj::floor(bx2);
HXDLIN(  35)								int ii_max83 = ::Math_obj::ceil(rightX);
HXDLIN(  35)								xIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min83,ii_max83);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart yIter311;
HXDLIN(  35)						if ((by3 > cy3)) {
HXLINE(  35)							if ((by3 > bottomY)) {
HXLINE(  35)								int min39;
HXDLIN(  35)								if ((cy3 > bottomY)) {
HXLINE(  35)									min39 = ::Math_obj::floor(bottomY);
            								}
            								else {
HXLINE(  35)									min39 = ::Math_obj::floor(cy3);
            								}
HXDLIN(  35)								int ii_min84 = min39;
HXDLIN(  35)								int ii_max84 = ::Math_obj::ceil(by3);
HXDLIN(  35)								yIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min84,ii_max84);
            							}
            							else {
HXLINE(  35)								int ii_min85 = ::Math_obj::floor(cy3);
HXDLIN(  35)								int ii_max85 = ::Math_obj::ceil(bottomY);
HXDLIN(  35)								yIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min85,ii_max85);
            							}
            						}
            						else {
HXLINE(  35)							if ((cy3 > bottomY)) {
HXLINE(  35)								int min40;
HXDLIN(  35)								if ((by3 > bottomY)) {
HXLINE(  35)									min40 = ::Math_obj::floor(bottomY);
            								}
            								else {
HXLINE(  35)									min40 = ::Math_obj::ceil(by3);
            								}
HXDLIN(  35)								int ii_min86 = min40;
HXDLIN(  35)								int ii_max86 = ::Math_obj::ceil(cy3);
HXDLIN(  35)								yIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min86,ii_max86);
            							}
            							else {
HXLINE(  35)								int ii_min87 = ::Math_obj::floor(by3);
HXDLIN(  35)								int ii_max87 = ::Math_obj::ceil(bottomY);
HXDLIN(  35)								yIter311 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min87,ii_max87);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::ImageStruct undoImage33 = null();
HXDLIN(  35)						if (hasUndo11) {
HXLINE(  35)							int width12 = ((xIter311->max - xIter311->start) + 1);
HXDLIN(  35)							int height12 = ((yIter311->max - yIter311->start) + 1);
HXDLIN(  35)							 ::Dynamic imageType12 = null();
HXDLIN(  35)							 ::pi_xy::ImageStruct this378 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  35)							if (::hx::IsNull( imageType12 )) {
HXLINE(  54)								imageType12 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE(  35)							::Dynamic undoImage34;
HXDLIN(  35)							switch((int)(( (int)(imageType12) ))){
            								case (int)0: {
HXLINE(  35)									 ::iterMagic::BytesImg byt12 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::BytesImg b68 = byt12;
HXDLIN(  35)									{
HXLINE(  35)										b68->width = width12;
HXDLIN(  35)										b68->height = height12;
HXDLIN(  35)										b68->length = ::Std_obj::_hx_int(( (Float)((width12 * height12)) ));
HXDLIN(  35)										b68->data = ::haxe::io::Bytes_obj::alloc((b68->length * 4));
HXDLIN(  35)										{
HXLINE(  35)											int len24 = b68->length;
HXDLIN(  35)											int w12 = 0;
HXDLIN(  35)											{
HXLINE(  35)												int _g236 = 0;
HXDLIN(  35)												int _g237 = b68->height;
HXDLIN(  35)												while((_g236 < _g237)){
HXLINE(  35)													_g236 = (_g236 + 1);
HXDLIN(  35)													int y46 = (_g236 - 1);
HXDLIN(  35)													{
HXLINE(  35)														int _g238 = 0;
HXDLIN(  35)														int _g239 = b68->width;
HXDLIN(  35)														while((_g238 < _g239)){
HXLINE(  35)															_g238 = (_g238 + 1);
HXDLIN(  35)															int x46 = (_g238 - 1);
HXDLIN(  35)															{
HXLINE(  35)																w12 = (w12 + 1);
HXDLIN(  35)																b68->data->b[(w12 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w12 = (w12 + 1);
HXDLIN(  35)																b68->data->b[(w12 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w12 = (w12 + 1);
HXDLIN(  35)																b68->data->b[(w12 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w12 = (w12 + 1);
HXDLIN(  35)																b68->data->b[(w12 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage34 = b68;
            								}
            								break;
            								case (int)1: {
HXLINE(  35)									 ::iterMagic::ArrIntImg arrI12 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::ArrIntImg a59 = arrI12;
HXDLIN(  35)									{
HXLINE(  35)										a59->width = width12;
HXDLIN(  35)										a59->height = height12;
HXDLIN(  35)										a59->data = ::Array_obj< int >::__new(0);
HXDLIN(  35)										a59->length = ::Std_obj::_hx_int(( (Float)((width12 * height12)) ));
HXDLIN(  35)										{
HXLINE(  35)											int _g240 = 0;
HXDLIN(  35)											int _g241 = a59->length;
HXDLIN(  35)											while((_g240 < _g241)){
HXLINE(  35)												_g240 = (_g240 + 1);
HXDLIN(  35)												int i72 = (_g240 - 1);
HXDLIN(  35)												a59->data[i72] = 0;
            											}
            										}
            									}
HXDLIN(  35)									undoImage34 = a59;
            								}
            								break;
            								case (int)2: {
HXLINE(  35)									 ::iterMagic::U32ArrImg u32a12 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::U32ArrImg b69 = u32a12;
HXDLIN(  35)									{
HXLINE(  35)										b69->width = width12;
HXDLIN(  35)										b69->height = height12;
HXDLIN(  35)										b69->length = ::Std_obj::_hx_int(( (Float)((width12 * height12)) ));
HXDLIN(  35)										int size12 = (b69->length * 4);
HXDLIN(  35)										b69->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size12),0,size12);
HXDLIN(  35)										{
HXLINE(  35)											int _g242 = 0;
HXDLIN(  35)											int _g243 = b69->length;
HXDLIN(  35)											while((_g242 < _g243)){
HXLINE(  35)												_g242 = (_g242 + 1);
HXDLIN(  35)												int i73 = (_g242 - 1);
HXDLIN(  35)												{
HXLINE(  35)													 ::haxe::io::ArrayBufferViewImpl this379 = b69->data;
HXDLIN(  35)													bool undoImage35;
HXDLIN(  35)													if ((i73 >= 0)) {
HXLINE(  35)														undoImage35 = (i73 < (this379->byteLength >> 2));
            													}
            													else {
HXLINE(  35)														undoImage35 = false;
            													}
HXDLIN(  35)													if (undoImage35) {
HXLINE(  35)														 ::haxe::io::Bytes _this12 = this379->bytes;
HXDLIN(  35)														int pos12 = ((i73 << 2) + this379->byteOffset);
HXDLIN(  35)														_this12->b[pos12] = ( (unsigned char)(0) );
HXDLIN(  35)														_this12->b[(pos12 + 1)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this12->b[(pos12 + 2)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this12->b[(pos12 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage34 = b69;
            								}
            								break;
            								case (int)3: {
HXLINE(  35)									 ::iterMagic::VecIntImg vec12 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::VecIntImg v50 = vec12;
HXDLIN(  35)									{
HXLINE(  35)										v50->width = width12;
HXDLIN(  35)										v50->height = height12;
HXDLIN(  35)										v50->length = ::Std_obj::_hx_int(( (Float)((width12 * height12)) ));
HXDLIN(  35)										v50->data = ::Array_obj< int >::__new(v50->length);
HXDLIN(  35)										{
HXLINE(  35)											int _g244 = 0;
HXDLIN(  35)											int _g245 = v50->length;
HXDLIN(  35)											while((_g244 < _g245)){
HXLINE(  35)												_g244 = (_g244 + 1);
HXDLIN(  35)												int i74 = (_g244 - 1);
HXDLIN(  35)												v50->data->__unsafe_set(i74,0);
            											}
            										}
            									}
HXDLIN(  35)									undoImage34 = v50;
            								}
            								break;
            								case (int)4: {
HXLINE(  35)									 ::iterMagic::StackIntImg sInt12 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::StackIntImg b70 = sInt12;
HXDLIN(  35)									{
HXLINE(  35)										b70->width = width12;
HXDLIN(  35)										b70->height = height12;
HXDLIN(  35)										b70->length = ::Std_obj::_hx_int(( (Float)((width12 * height12)) ));
HXDLIN(  35)										b70->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  35)										{
HXLINE(  35)											int len25 = b70->length;
HXDLIN(  35)											 ::haxe::ds::GenericStack_Int d12 = b70->data;
HXDLIN(  35)											if (::hx::IsNull( d12->head )) {
HXLINE(  35)												int _g246 = 0;
HXDLIN(  35)												int _g247 = len25;
HXDLIN(  35)												while((_g246 < _g247)){
HXLINE(  35)													_g246 = (_g246 + 1);
HXDLIN(  35)													int i75 = (_g246 - 1);
HXDLIN(  35)													d12->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d12->head);
            												}
            											}
            											else {
HXLINE(  35)												int _g248 = 0;
HXDLIN(  35)												int _g249 = len25;
HXDLIN(  35)												while((_g248 < _g249)){
HXLINE(  35)													_g248 = (_g248 + 1);
HXDLIN(  35)													int i76 = (_g248 - 1);
HXDLIN(  35)													{
HXLINE(  35)														 ::haxe::ds::GenericCell_Int l12 = b70->data->head;
HXDLIN(  35)														 ::haxe::ds::GenericCell_Int prev12 = null();
HXDLIN(  35)														{
HXLINE(  35)															int _g250 = 0;
HXDLIN(  35)															int _g251 = i76;
HXDLIN(  35)															while((_g250 < _g251)){
HXLINE(  35)																_g250 = (_g250 + 1);
HXDLIN(  35)																int i77 = (_g250 - 1);
HXLINE( 345)																prev12 = l12;
HXLINE( 346)																l12 = l12->next;
            															}
            														}
HXLINE(  35)														if (::hx::IsNull( prev12 )) {
HXLINE(  35)															b70->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l12->next);
HXDLIN(  35)															l12 = null();
            														}
            														else {
HXLINE(  35)															prev12->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l12->next);
HXDLIN(  35)															l12 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage34 = b70;
            								}
            								break;
            							}
HXDLIN(  35)							this378->image = undoImage34;
HXDLIN(  35)							this378->width = width12;
HXDLIN(  35)							this378->height = height12;
HXDLIN(  35)							this378->imageType = ( (int)(imageType12) );
HXDLIN(  35)							undoImage33 = this378;
HXDLIN(  35)							{
HXLINE(  35)								int rectLeft11 = xIter311->start;
HXDLIN(  35)								int rectTop11 = yIter311->start;
HXDLIN(  35)								int rectRight11 = xIter311->max;
HXDLIN(  35)								bool forceClear11 = false;
HXDLIN(  35)								{
HXLINE(  35)									int _g252 = rectTop11;
HXDLIN(  35)									int _g253 = yIter311->max;
HXDLIN(  35)									while((_g252 < _g253)){
HXLINE(  35)										_g252 = (_g252 + 1);
HXDLIN(  35)										int dy12 = (_g252 - 1);
HXDLIN(  35)										{
HXLINE(  35)											int _g254 = rectLeft11;
HXDLIN(  35)											int _g255 = rectRight11;
HXDLIN(  35)											while((_g254 < _g255)){
HXLINE(  35)												_g254 = (_g254 + 1);
HXDLIN(  35)												int dx12 = (_g254 - 1);
HXDLIN(  35)												::Dynamic this380 = temp->image;
HXDLIN(  35)												int index66;
HXDLIN(  35)												if (temp->useVirtualPos) {
HXLINE(  35)													index66 = ::Std_obj::_hx_int(((((( (Float)(dy12) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx12) - temp->virtualX));
            												}
            												else {
HXLINE(  35)													index66 = ::Std_obj::_hx_int(( (Float)(((dy12 * temp->width) + dx12)) ));
            												}
HXDLIN(  35)												int c55 = ::iterMagic::Iimg_obj::get(this380,index66);
HXDLIN(  35)												int col22;
HXDLIN(  35)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)													col22 = ((((((c55 >> 24) & 255) << 24) | ((c55 & 255) << 16)) | (((c55 >> 8) & 255) << 8)) | ((c55 >> 16) & 255));
            												}
            												else {
HXLINE(  35)													col22 = c55;
            												}
HXDLIN(  35)												bool _hx_tmp101;
HXDLIN(  35)												if (temp->useMask) {
HXLINE(  35)													_hx_tmp101 = ::hx::IsNotNull( temp->mask );
            												}
            												else {
HXLINE(  35)													_hx_tmp101 = false;
            												}
HXDLIN(  35)												if (_hx_tmp101) {
HXLINE(  35)													 ::pi_xy::ImageStruct this381 = temp->mask;
HXDLIN(  35)													::Dynamic this382 = this381->image;
HXDLIN(  35)													int index67;
HXDLIN(  35)													if (this381->useVirtualPos) {
HXLINE(  35)														index67 = ::Std_obj::_hx_int(((((( (Float)(dy12) ) - this381->virtualY) * ( (Float)(this381->width) )) + dx12) - this381->virtualX));
            													}
            													else {
HXLINE(  35)														index67 = ::Std_obj::_hx_int(( (Float)(((dy12 * this381->width) + dx12)) ));
            													}
HXDLIN(  35)													int c56 = ::iterMagic::Iimg_obj::get(this382,index67);
HXDLIN(  35)													int v51;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														v51 = ((((((c56 >> 24) & 255) << 24) | ((c56 & 255) << 16)) | (((c56 >> 8) & 255) << 8)) | ((c56 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														v51 = c56;
            													}
HXDLIN(  35)													int maskPixel11 = v51;
HXDLIN(  35)													int this383 = col22;
HXDLIN(  35)													if ((maskPixel11 == 0)) {
HXLINE(  35)														col22 = this383;
            													}
            													else {
HXLINE(  35)														Float m011;
HXDLIN(  35)														int this384 = ((maskPixel11 >> 24) & 255);
HXDLIN(  35)														if ((this384 == 0)) {
HXLINE(  35)															m011 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m011 = (( (Float)(this384) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m111;
HXDLIN(  35)														int this385 = ((maskPixel11 >> 16) & 255);
HXDLIN(  35)														if ((this385 == 0)) {
HXLINE(  35)															m111 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m111 = (( (Float)(this385) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m211;
HXDLIN(  35)														int this386 = ((maskPixel11 >> 8) & 255);
HXDLIN(  35)														if ((this386 == 0)) {
HXLINE(  35)															m211 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m211 = (( (Float)(this386) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m311;
HXDLIN(  35)														int this387 = (maskPixel11 & 255);
HXDLIN(  35)														if ((this387 == 0)) {
HXLINE(  35)															m311 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m311 = (( (Float)(this387) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														int ch011 = ::Std_obj::_hx_int(((((Float)1.) - m011) * ( (Float)(((this383 >> 24) & 255)) )));
HXDLIN(  35)														int ch111 = ::Std_obj::_hx_int(((((Float)1.) - m111) * ( (Float)(((this383 >> 16) & 255)) )));
HXDLIN(  35)														int ch211 = ::Std_obj::_hx_int(((((Float)1.) - m211) * ( (Float)(((this383 >> 8) & 255)) )));
HXDLIN(  35)														int ch311 = ::Std_obj::_hx_int(((((Float)1.) - m311) * ( (Float)((this383 & 255)) )));
HXDLIN(  35)														col22 = ((((::Math_obj::round((( (Float)(ch011) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch111) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch211) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch311) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  35)												if ((col22 != 0)) {
HXLINE(  35)													int x47 = (dx12 - rectLeft11);
HXDLIN(  35)													int y47 = (dy12 - rectTop11);
HXDLIN(  35)													int c57 = col22;
HXDLIN(  35)													bool _hx_tmp102;
HXDLIN(  35)													if ((((c57 >> 24) & 255) < 254)) {
HXLINE(  35)														_hx_tmp102 = undoImage33->transparent;
            													}
            													else {
HXLINE(  35)														_hx_tmp102 = false;
            													}
HXDLIN(  35)													if (_hx_tmp102) {
HXLINE(  35)														int location22;
HXDLIN(  35)														if (undoImage33->useVirtualPos) {
HXLINE(  35)															location22 = ::Std_obj::_hx_int(((((( (Float)(y47) ) - undoImage33->virtualY) * ( (Float)(undoImage33->width) )) + x47) - undoImage33->virtualX));
            														}
            														else {
HXLINE(  35)															location22 = ::Std_obj::_hx_int(( (Float)(((y47 * undoImage33->width) + x47)) ));
            														}
HXDLIN(  35)														int this388 = ::iterMagic::Iimg_obj::get(undoImage33->image,location22);
HXDLIN(  35)														int this389;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															this389 = ((((((this388 >> 24) & 255) << 24) | ((this388 & 255) << 16)) | (((this388 >> 8) & 255) << 8)) | ((this388 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															this389 = this388;
            														}
HXDLIN(  35)														Float a125;
HXDLIN(  35)														int this390 = ((this389 >> 24) & 255);
HXDLIN(  35)														if ((this390 == 0)) {
HXLINE(  35)															a125 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a125 = (( (Float)(this390) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r122;
HXDLIN(  35)														int this391 = ((this389 >> 16) & 255);
HXDLIN(  35)														if ((this391 == 0)) {
HXLINE(  35)															r122 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r122 = (( (Float)(this391) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g122;
HXDLIN(  35)														int this392 = ((this389 >> 8) & 255);
HXDLIN(  35)														if ((this392 == 0)) {
HXLINE(  35)															g122 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g122 = (( (Float)(this392) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b128;
HXDLIN(  35)														int this393 = (this389 & 255);
HXDLIN(  35)														if ((this393 == 0)) {
HXLINE(  35)															b128 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b128 = (( (Float)(this393) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a224;
HXDLIN(  35)														int this394 = ((col22 >> 24) & 255);
HXDLIN(  35)														if ((this394 == 0)) {
HXLINE(  35)															a224 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a224 = (( (Float)(this394) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r222;
HXDLIN(  35)														int this395 = ((col22 >> 16) & 255);
HXDLIN(  35)														if ((this395 == 0)) {
HXLINE(  35)															r222 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r222 = (( (Float)(this395) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g222;
HXDLIN(  35)														int this396 = ((col22 >> 8) & 255);
HXDLIN(  35)														if ((this396 == 0)) {
HXLINE(  35)															g222 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g222 = (( (Float)(this396) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b226;
HXDLIN(  35)														int this397 = (col22 & 255);
HXDLIN(  35)														if ((this397 == 0)) {
HXLINE(  35)															b226 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b226 = (( (Float)(this397) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a322 = (a125 * (( (Float)(1) ) - a224));
HXDLIN(  35)														int r42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r122 * a322) + (r222 * a224))));
HXDLIN(  35)														int g42 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g122 * a322) + (g222 * a224))));
HXDLIN(  35)														int b71 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b128 * a322) + (b226 * a224))));
HXDLIN(  35)														int a60 = ::Std_obj::_hx_int((( (Float)(255) ) * (a322 + a224)));
HXDLIN(  35)														int blended22 = ((((a60 << 24) | (r42 << 16)) | (g42 << 8)) | b71);
HXDLIN(  35)														{
HXLINE(  35)															int _hx_tmp103;
HXDLIN(  35)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)																_hx_tmp103 = ((((((blended22 >> 24) & 255) << 24) | ((blended22 & 255) << 16)) | (((blended22 >> 8) & 255) << 8)) | ((blended22 >> 16) & 255));
            															}
            															else {
HXLINE(  35)																_hx_tmp103 = blended22;
            															}
HXDLIN(  35)															::iterMagic::Iimg_obj::set(undoImage33->image,location22,_hx_tmp103);
            														}
            													}
            													else {
HXLINE(  35)														::Dynamic this398 = undoImage33->image;
HXDLIN(  35)														int index68;
HXDLIN(  35)														if (undoImage33->useVirtualPos) {
HXLINE(  35)															index68 = ::Std_obj::_hx_int(((((( (Float)(y47) ) - undoImage33->virtualY) * ( (Float)(undoImage33->width) )) + x47) - undoImage33->virtualX));
            														}
            														else {
HXLINE(  35)															index68 = ::Std_obj::_hx_int(( (Float)(((y47 * undoImage33->width) + x47)) ));
            														}
HXDLIN(  35)														int _hx_tmp104;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp104 = ((((((c57 >> 24) & 255) << 24) | ((c57 & 255) << 16)) | (((c57 >> 8) & 255) << 8)) | ((c57 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp104 = c57;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this398,index68,_hx_tmp104);
            													}
            												}
            												else {
HXLINE(  35)													if (forceClear11) {
HXLINE(  35)														::Dynamic this399 = undoImage33->image;
HXDLIN(  35)														int x48 = (dx12 - rectLeft11);
HXDLIN(  35)														int y48 = (dy12 - rectTop11);
HXDLIN(  35)														int index69;
HXDLIN(  35)														if (undoImage33->useVirtualPos) {
HXLINE(  35)															index69 = ::Std_obj::_hx_int(((((( (Float)(y48) ) - undoImage33->virtualY) * ( (Float)(undoImage33->width) )) + x48) - undoImage33->virtualX));
            														}
            														else {
HXLINE(  35)															index69 = ::Std_obj::_hx_int(( (Float)(((y48 * undoImage33->width) + x48)) ));
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this399,index69,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						{
HXLINE(  35)							int _g_min22 = xIter311->start;
HXDLIN(  35)							int _g_max22 = xIter311->max;
HXDLIN(  35)							while((_g_min22 < _g_max22)){
HXLINE(  35)								_g_min22 = (_g_min22 + 1);
HXDLIN(  35)								int px11 = (_g_min22 - 1);
HXDLIN(  35)								Float pcx11 = (( (Float)(px11) ) - rightX);
HXDLIN(  35)								{
HXLINE(  35)									int _g_min23 = yIter311->start;
HXDLIN(  35)									int _g_max23 = yIter311->max;
HXDLIN(  35)									while((_g_min23 < _g_max23)){
HXLINE(  35)										_g_min23 = (_g_min23 + 1);
HXDLIN(  35)										int py11 = (_g_min23 - 1);
HXDLIN(  35)										Float pcy11 = (( (Float)(py11) ) - bottomY);
HXDLIN(  35)										Float dot3111 = ((pcx11 * bcx11) + (pcy11 * bcy11));
HXDLIN(  35)										Float dot3211 = ((pcx11 * acx11) + (pcy11 * acy11));
HXDLIN(  35)										Float ratioA11 = (((dot2211 * dot3111) - (dot1211 * dot3211)) * denom111);
HXDLIN(  35)										Float ratioB11 = (((dot1111 * dot3211) - (dot1211 * dot3111)) * denom111);
HXDLIN(  35)										Float ratioC11 = ((((Float)1.0) - ratioB11) - ratioA11);
HXDLIN(  35)										bool _hx_tmp105;
HXDLIN(  35)										bool _hx_tmp106;
HXDLIN(  35)										if ((ratioA11 >= 0)) {
HXLINE(  35)											_hx_tmp106 = (ratioB11 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp106 = false;
            										}
HXDLIN(  35)										if (_hx_tmp106) {
HXLINE(  35)											_hx_tmp105 = (ratioC11 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp105 = false;
            										}
HXDLIN(  35)										if (_hx_tmp105) {
HXLINE(  35)											Float u11 = (((au12 * ratioA11) + (bu12 * ratioB11)) + (au * ratioC11));
HXDLIN(  35)											Float v52 = (((av12 * ratioA11) + (bv11 * ratioB11)) + (cv * ratioC11));
HXDLIN(  35)											int x49 = ::Std_obj::_hx_int(((u11 * win_width) + win_x));
HXDLIN(  35)											int y49 = ::Std_obj::_hx_int(((v52 * win_height) + win_y));
HXDLIN(  35)											::Dynamic this400 = texture->image;
HXDLIN(  35)											int index70;
HXDLIN(  35)											if (texture->useVirtualPos) {
HXLINE(  35)												index70 = ::Std_obj::_hx_int(((((( (Float)(y49) ) - texture->virtualY) * ( (Float)(texture->width) )) + x49) - texture->virtualX));
            											}
            											else {
HXLINE(  35)												index70 = ::Std_obj::_hx_int(( (Float)(((y49 * texture->width) + x49)) ));
            											}
HXDLIN(  35)											int c58 = ::iterMagic::Iimg_obj::get(this400,index70);
HXDLIN(  35)											int col23;
HXDLIN(  35)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)												col23 = ((((((c58 >> 24) & 255) << 24) | ((c58 & 255) << 16)) | (((c58 >> 8) & 255) << 8)) | ((c58 >> 16) & 255));
            											}
            											else {
HXLINE(  35)												col23 = c58;
            											}
HXDLIN(  35)											{
HXLINE(  35)												int c59 = col23;
HXDLIN(  35)												bool _hx_tmp107;
HXDLIN(  35)												if ((((c59 >> 24) & 255) < 254)) {
HXLINE(  35)													_hx_tmp107 = temp->transparent;
            												}
            												else {
HXLINE(  35)													_hx_tmp107 = false;
            												}
HXDLIN(  35)												if (_hx_tmp107) {
HXLINE(  35)													int location23;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														location23 = ::Std_obj::_hx_int(((((( (Float)(py11) ) - temp->virtualY) * ( (Float)(temp->width) )) + px11) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														location23 = ::Std_obj::_hx_int(( (Float)(((py11 * temp->width) + px11)) ));
            													}
HXDLIN(  35)													int this401 = ::iterMagic::Iimg_obj::get(temp->image,location23);
HXDLIN(  35)													int this402;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														this402 = ((((((this401 >> 24) & 255) << 24) | ((this401 & 255) << 16)) | (((this401 >> 8) & 255) << 8)) | ((this401 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														this402 = this401;
            													}
HXDLIN(  35)													Float a126;
HXDLIN(  35)													int this403 = ((this402 >> 24) & 255);
HXDLIN(  35)													if ((this403 == 0)) {
HXLINE(  35)														a126 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a126 = (( (Float)(this403) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r123;
HXDLIN(  35)													int this404 = ((this402 >> 16) & 255);
HXDLIN(  35)													if ((this404 == 0)) {
HXLINE(  35)														r123 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r123 = (( (Float)(this404) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g123;
HXDLIN(  35)													int this405 = ((this402 >> 8) & 255);
HXDLIN(  35)													if ((this405 == 0)) {
HXLINE(  35)														g123 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g123 = (( (Float)(this405) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b129;
HXDLIN(  35)													int this406 = (this402 & 255);
HXDLIN(  35)													if ((this406 == 0)) {
HXLINE(  35)														b129 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b129 = (( (Float)(this406) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a225;
HXDLIN(  35)													int this407 = ((col23 >> 24) & 255);
HXDLIN(  35)													if ((this407 == 0)) {
HXLINE(  35)														a225 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a225 = (( (Float)(this407) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r223;
HXDLIN(  35)													int this408 = ((col23 >> 16) & 255);
HXDLIN(  35)													if ((this408 == 0)) {
HXLINE(  35)														r223 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r223 = (( (Float)(this408) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g223;
HXDLIN(  35)													int this409 = ((col23 >> 8) & 255);
HXDLIN(  35)													if ((this409 == 0)) {
HXLINE(  35)														g223 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g223 = (( (Float)(this409) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b227;
HXDLIN(  35)													int this410 = (col23 & 255);
HXDLIN(  35)													if ((this410 == 0)) {
HXLINE(  35)														b227 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b227 = (( (Float)(this410) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a323 = (a126 * (( (Float)(1) ) - a225));
HXDLIN(  35)													int r43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r123 * a323) + (r223 * a225))));
HXDLIN(  35)													int g43 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g123 * a323) + (g223 * a225))));
HXDLIN(  35)													int b72 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b129 * a323) + (b227 * a225))));
HXDLIN(  35)													int a61 = ::Std_obj::_hx_int((( (Float)(255) ) * (a323 + a225)));
HXDLIN(  35)													int blended23 = ((((a61 << 24) | (r43 << 16)) | (g43 << 8)) | b72);
HXDLIN(  35)													{
HXLINE(  35)														int _hx_tmp108;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp108 = ((((((blended23 >> 24) & 255) << 24) | ((blended23 & 255) << 16)) | (((blended23 >> 8) & 255) << 8)) | ((blended23 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp108 = blended23;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(temp->image,location23,_hx_tmp108);
            													}
            												}
            												else {
HXLINE(  35)													::Dynamic this411 = temp->image;
HXDLIN(  35)													int index71;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														index71 = ::Std_obj::_hx_int(((((( (Float)(py11) ) - temp->virtualY) * ( (Float)(temp->width) )) + px11) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														index71 = ::Std_obj::_hx_int(( (Float)(((py11 * temp->width) + px11)) ));
            													}
HXDLIN(  35)													int _hx_tmp109;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														_hx_tmp109 = ((((((c59 >> 24) & 255) << 24) | ((c59 & 255) << 16)) | (((c59 >> 8) & 255) << 8)) | ((c59 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														_hx_tmp109 = c59;
            													}
HXDLIN(  35)													::iterMagic::Iimg_obj::set(this411,index71,_hx_tmp109);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						if ((hasHit == false)) {
HXLINE(  35)							 ::pi_xy::algo::HitTri v53 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx2,by3,cx2,cy3,rightX,bottomY,true);
HXDLIN(  35)							if (hasUndo11) {
HXLINE(  35)								v53->undoImage = undoImage33;
HXDLIN(  35)								v53->undoX = xIter311->start;
HXDLIN(  35)								v53->undoY = yIter311->start;
            							}
            						}
            					}
HXDLIN(  35)					if ((hasHit == true)) {
HXLINE(  35)						 ::pi_xy::algo::HitQuad v54 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,rightX,ay3,bx2,by3,cx2,cy3,rightX,bottomY,true);
            					}
            				}
HXLINE( 281)				av = ((top + tall) * sh);
HXLINE( 282)				bu = (left * sw);
HXLINE( 283)				cv = ((Float)1.);
HXLINE(  35)				{
HXLINE(  35)					Float cy4 = hiNew;
HXDLIN(  35)					Float dy13 = hiNew;
HXDLIN(  35)					{
HXLINE(  35)						Float au13 = ((Float)0.);
HXDLIN(  35)						Float av13 = av;
HXDLIN(  35)						Float bu13 = bu;
HXDLIN(  35)						Float bv12 = av;
HXDLIN(  35)						bool hasUndo12 = false;
HXDLIN(  35)						Float temp13 = au13;
HXLINE( 422)						au13 = bu13;
HXLINE( 423)						bu13 = temp13;
HXLINE( 424)						temp13 = av13;
HXLINE( 425)						av13 = bv12;
HXLINE( 426)						bv12 = temp13;
HXLINE(  35)						Float bcx12 = leftX;
HXDLIN(  35)						Float bcy12 = (bottomY - dy13);
HXDLIN(  35)						Float acx12 = ( (Float)(0) );
HXDLIN(  35)						Float acy12 = (bottomY - dy13);
HXDLIN(  35)						Float dot1112 = ((bcx12 * bcx12) + (bcy12 * bcy12));
HXDLIN(  35)						Float dot1212 = ((bcx12 * acx12) + (bcy12 * acy12));
HXDLIN(  35)						Float dot2212 = ((acx12 * acx12) + (acy12 * acy12));
HXDLIN(  35)						Float denom112 = (( (Float)(1) ) / ((dot1112 * dot2212) - (dot1212 * dot1212)));
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart xIter312;
HXDLIN(  35)						if ((0 > leftX)) {
HXLINE(  35)							int ii_min88 = ::Math_obj::floor(leftX);
HXDLIN(  35)							int ii_max88 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  35)							xIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min88,ii_max88);
            						}
            						else {
HXLINE(  35)							if ((leftX > 0)) {
HXLINE(  35)								int ii_min89 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  35)								int ii_max89 = ::Math_obj::ceil(leftX);
HXDLIN(  35)								xIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min89,ii_max89);
            							}
            							else {
HXLINE(  35)								int ii_min90 = ::Math_obj::floor(( (Float)(0) ));
HXDLIN(  35)								int ii_max90 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  35)								xIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min90,ii_max90);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart yIter312;
HXDLIN(  35)						if ((bottomY > bottomY)) {
HXLINE(  35)							if ((bottomY > dy13)) {
HXLINE(  35)								int min41;
HXDLIN(  35)								if ((bottomY > dy13)) {
HXLINE(  35)									min41 = ::Math_obj::floor(dy13);
            								}
            								else {
HXLINE(  35)									min41 = ::Math_obj::floor(bottomY);
            								}
HXDLIN(  35)								int ii_min91 = min41;
HXDLIN(  35)								int ii_max91 = ::Math_obj::ceil(bottomY);
HXDLIN(  35)								yIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min91,ii_max91);
            							}
            							else {
HXLINE(  35)								int ii_min92 = ::Math_obj::floor(bottomY);
HXDLIN(  35)								int ii_max92 = ::Math_obj::ceil(dy13);
HXDLIN(  35)								yIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min92,ii_max92);
            							}
            						}
            						else {
HXLINE(  35)							if ((bottomY > dy13)) {
HXLINE(  35)								int min42;
HXDLIN(  35)								if ((bottomY > dy13)) {
HXLINE(  35)									min42 = ::Math_obj::floor(dy13);
            								}
            								else {
HXLINE(  35)									min42 = ::Math_obj::ceil(bottomY);
            								}
HXDLIN(  35)								int ii_min93 = min42;
HXDLIN(  35)								int ii_max93 = ::Math_obj::ceil(bottomY);
HXDLIN(  35)								yIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min93,ii_max93);
            							}
            							else {
HXLINE(  35)								int ii_min94 = ::Math_obj::floor(bottomY);
HXDLIN(  35)								int ii_max94 = ::Math_obj::ceil(dy13);
HXDLIN(  35)								yIter312 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min94,ii_max94);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::ImageStruct undoImage36 = null();
HXDLIN(  35)						if (hasUndo12) {
HXLINE(  35)							int width13 = ((xIter312->max - xIter312->start) + 1);
HXDLIN(  35)							int height13 = ((yIter312->max - yIter312->start) + 1);
HXDLIN(  35)							 ::Dynamic imageType13 = null();
HXDLIN(  35)							 ::pi_xy::ImageStruct this412 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  35)							if (::hx::IsNull( imageType13 )) {
HXLINE(  54)								imageType13 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE(  35)							::Dynamic undoImage37;
HXDLIN(  35)							switch((int)(( (int)(imageType13) ))){
            								case (int)0: {
HXLINE(  35)									 ::iterMagic::BytesImg byt13 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::BytesImg b73 = byt13;
HXDLIN(  35)									{
HXLINE(  35)										b73->width = width13;
HXDLIN(  35)										b73->height = height13;
HXDLIN(  35)										b73->length = ::Std_obj::_hx_int(( (Float)((width13 * height13)) ));
HXDLIN(  35)										b73->data = ::haxe::io::Bytes_obj::alloc((b73->length * 4));
HXDLIN(  35)										{
HXLINE(  35)											int len26 = b73->length;
HXDLIN(  35)											int w13 = 0;
HXDLIN(  35)											{
HXLINE(  35)												int _g256 = 0;
HXDLIN(  35)												int _g257 = b73->height;
HXDLIN(  35)												while((_g256 < _g257)){
HXLINE(  35)													_g256 = (_g256 + 1);
HXDLIN(  35)													int y50 = (_g256 - 1);
HXDLIN(  35)													{
HXLINE(  35)														int _g258 = 0;
HXDLIN(  35)														int _g259 = b73->width;
HXDLIN(  35)														while((_g258 < _g259)){
HXLINE(  35)															_g258 = (_g258 + 1);
HXDLIN(  35)															int x50 = (_g258 - 1);
HXDLIN(  35)															{
HXLINE(  35)																w13 = (w13 + 1);
HXDLIN(  35)																b73->data->b[(w13 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w13 = (w13 + 1);
HXDLIN(  35)																b73->data->b[(w13 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w13 = (w13 + 1);
HXDLIN(  35)																b73->data->b[(w13 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w13 = (w13 + 1);
HXDLIN(  35)																b73->data->b[(w13 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage37 = b73;
            								}
            								break;
            								case (int)1: {
HXLINE(  35)									 ::iterMagic::ArrIntImg arrI13 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::ArrIntImg a62 = arrI13;
HXDLIN(  35)									{
HXLINE(  35)										a62->width = width13;
HXDLIN(  35)										a62->height = height13;
HXDLIN(  35)										a62->data = ::Array_obj< int >::__new(0);
HXDLIN(  35)										a62->length = ::Std_obj::_hx_int(( (Float)((width13 * height13)) ));
HXDLIN(  35)										{
HXLINE(  35)											int _g260 = 0;
HXDLIN(  35)											int _g261 = a62->length;
HXDLIN(  35)											while((_g260 < _g261)){
HXLINE(  35)												_g260 = (_g260 + 1);
HXDLIN(  35)												int i78 = (_g260 - 1);
HXDLIN(  35)												a62->data[i78] = 0;
            											}
            										}
            									}
HXDLIN(  35)									undoImage37 = a62;
            								}
            								break;
            								case (int)2: {
HXLINE(  35)									 ::iterMagic::U32ArrImg u32a13 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::U32ArrImg b74 = u32a13;
HXDLIN(  35)									{
HXLINE(  35)										b74->width = width13;
HXDLIN(  35)										b74->height = height13;
HXDLIN(  35)										b74->length = ::Std_obj::_hx_int(( (Float)((width13 * height13)) ));
HXDLIN(  35)										int size13 = (b74->length * 4);
HXDLIN(  35)										b74->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size13),0,size13);
HXDLIN(  35)										{
HXLINE(  35)											int _g262 = 0;
HXDLIN(  35)											int _g263 = b74->length;
HXDLIN(  35)											while((_g262 < _g263)){
HXLINE(  35)												_g262 = (_g262 + 1);
HXDLIN(  35)												int i79 = (_g262 - 1);
HXDLIN(  35)												{
HXLINE(  35)													 ::haxe::io::ArrayBufferViewImpl this413 = b74->data;
HXDLIN(  35)													bool undoImage38;
HXDLIN(  35)													if ((i79 >= 0)) {
HXLINE(  35)														undoImage38 = (i79 < (this413->byteLength >> 2));
            													}
            													else {
HXLINE(  35)														undoImage38 = false;
            													}
HXDLIN(  35)													if (undoImage38) {
HXLINE(  35)														 ::haxe::io::Bytes _this13 = this413->bytes;
HXDLIN(  35)														int pos13 = ((i79 << 2) + this413->byteOffset);
HXDLIN(  35)														_this13->b[pos13] = ( (unsigned char)(0) );
HXDLIN(  35)														_this13->b[(pos13 + 1)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this13->b[(pos13 + 2)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this13->b[(pos13 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage37 = b74;
            								}
            								break;
            								case (int)3: {
HXLINE(  35)									 ::iterMagic::VecIntImg vec13 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::VecIntImg v55 = vec13;
HXDLIN(  35)									{
HXLINE(  35)										v55->width = width13;
HXDLIN(  35)										v55->height = height13;
HXDLIN(  35)										v55->length = ::Std_obj::_hx_int(( (Float)((width13 * height13)) ));
HXDLIN(  35)										v55->data = ::Array_obj< int >::__new(v55->length);
HXDLIN(  35)										{
HXLINE(  35)											int _g264 = 0;
HXDLIN(  35)											int _g265 = v55->length;
HXDLIN(  35)											while((_g264 < _g265)){
HXLINE(  35)												_g264 = (_g264 + 1);
HXDLIN(  35)												int i80 = (_g264 - 1);
HXDLIN(  35)												v55->data->__unsafe_set(i80,0);
            											}
            										}
            									}
HXDLIN(  35)									undoImage37 = v55;
            								}
            								break;
            								case (int)4: {
HXLINE(  35)									 ::iterMagic::StackIntImg sInt13 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::StackIntImg b75 = sInt13;
HXDLIN(  35)									{
HXLINE(  35)										b75->width = width13;
HXDLIN(  35)										b75->height = height13;
HXDLIN(  35)										b75->length = ::Std_obj::_hx_int(( (Float)((width13 * height13)) ));
HXDLIN(  35)										b75->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  35)										{
HXLINE(  35)											int len27 = b75->length;
HXDLIN(  35)											 ::haxe::ds::GenericStack_Int d13 = b75->data;
HXDLIN(  35)											if (::hx::IsNull( d13->head )) {
HXLINE(  35)												int _g266 = 0;
HXDLIN(  35)												int _g267 = len27;
HXDLIN(  35)												while((_g266 < _g267)){
HXLINE(  35)													_g266 = (_g266 + 1);
HXDLIN(  35)													int i81 = (_g266 - 1);
HXDLIN(  35)													d13->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d13->head);
            												}
            											}
            											else {
HXLINE(  35)												int _g268 = 0;
HXDLIN(  35)												int _g269 = len27;
HXDLIN(  35)												while((_g268 < _g269)){
HXLINE(  35)													_g268 = (_g268 + 1);
HXDLIN(  35)													int i82 = (_g268 - 1);
HXDLIN(  35)													{
HXLINE(  35)														 ::haxe::ds::GenericCell_Int l13 = b75->data->head;
HXDLIN(  35)														 ::haxe::ds::GenericCell_Int prev13 = null();
HXDLIN(  35)														{
HXLINE(  35)															int _g270 = 0;
HXDLIN(  35)															int _g271 = i82;
HXDLIN(  35)															while((_g270 < _g271)){
HXLINE(  35)																_g270 = (_g270 + 1);
HXDLIN(  35)																int i83 = (_g270 - 1);
HXLINE( 345)																prev13 = l13;
HXLINE( 346)																l13 = l13->next;
            															}
            														}
HXLINE(  35)														if (::hx::IsNull( prev13 )) {
HXLINE(  35)															b75->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l13->next);
HXDLIN(  35)															l13 = null();
            														}
            														else {
HXLINE(  35)															prev13->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l13->next);
HXDLIN(  35)															l13 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage37 = b75;
            								}
            								break;
            							}
HXDLIN(  35)							this412->image = undoImage37;
HXDLIN(  35)							this412->width = width13;
HXDLIN(  35)							this412->height = height13;
HXDLIN(  35)							this412->imageType = ( (int)(imageType13) );
HXDLIN(  35)							undoImage36 = this412;
HXDLIN(  35)							{
HXLINE(  35)								int rectLeft12 = xIter312->start;
HXDLIN(  35)								int rectTop12 = yIter312->start;
HXDLIN(  35)								int rectRight12 = xIter312->max;
HXDLIN(  35)								bool forceClear12 = false;
HXDLIN(  35)								{
HXLINE(  35)									int _g272 = rectTop12;
HXDLIN(  35)									int _g273 = yIter312->max;
HXDLIN(  35)									while((_g272 < _g273)){
HXLINE(  35)										_g272 = (_g272 + 1);
HXDLIN(  35)										int dy14 = (_g272 - 1);
HXDLIN(  35)										{
HXLINE(  35)											int _g274 = rectLeft12;
HXDLIN(  35)											int _g275 = rectRight12;
HXDLIN(  35)											while((_g274 < _g275)){
HXLINE(  35)												_g274 = (_g274 + 1);
HXDLIN(  35)												int dx13 = (_g274 - 1);
HXDLIN(  35)												::Dynamic this414 = temp->image;
HXDLIN(  35)												int index72;
HXDLIN(  35)												if (temp->useVirtualPos) {
HXLINE(  35)													index72 = ::Std_obj::_hx_int(((((( (Float)(dy14) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx13) - temp->virtualX));
            												}
            												else {
HXLINE(  35)													index72 = ::Std_obj::_hx_int(( (Float)(((dy14 * temp->width) + dx13)) ));
            												}
HXDLIN(  35)												int c60 = ::iterMagic::Iimg_obj::get(this414,index72);
HXDLIN(  35)												int col24;
HXDLIN(  35)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)													col24 = ((((((c60 >> 24) & 255) << 24) | ((c60 & 255) << 16)) | (((c60 >> 8) & 255) << 8)) | ((c60 >> 16) & 255));
            												}
            												else {
HXLINE(  35)													col24 = c60;
            												}
HXDLIN(  35)												bool _hx_tmp110;
HXDLIN(  35)												if (temp->useMask) {
HXLINE(  35)													_hx_tmp110 = ::hx::IsNotNull( temp->mask );
            												}
            												else {
HXLINE(  35)													_hx_tmp110 = false;
            												}
HXDLIN(  35)												if (_hx_tmp110) {
HXLINE(  35)													 ::pi_xy::ImageStruct this415 = temp->mask;
HXDLIN(  35)													::Dynamic this416 = this415->image;
HXDLIN(  35)													int index73;
HXDLIN(  35)													if (this415->useVirtualPos) {
HXLINE(  35)														index73 = ::Std_obj::_hx_int(((((( (Float)(dy14) ) - this415->virtualY) * ( (Float)(this415->width) )) + dx13) - this415->virtualX));
            													}
            													else {
HXLINE(  35)														index73 = ::Std_obj::_hx_int(( (Float)(((dy14 * this415->width) + dx13)) ));
            													}
HXDLIN(  35)													int c61 = ::iterMagic::Iimg_obj::get(this416,index73);
HXDLIN(  35)													int v56;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														v56 = ((((((c61 >> 24) & 255) << 24) | ((c61 & 255) << 16)) | (((c61 >> 8) & 255) << 8)) | ((c61 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														v56 = c61;
            													}
HXDLIN(  35)													int maskPixel12 = v56;
HXDLIN(  35)													int this417 = col24;
HXDLIN(  35)													if ((maskPixel12 == 0)) {
HXLINE(  35)														col24 = this417;
            													}
            													else {
HXLINE(  35)														Float m012;
HXDLIN(  35)														int this418 = ((maskPixel12 >> 24) & 255);
HXDLIN(  35)														if ((this418 == 0)) {
HXLINE(  35)															m012 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m012 = (( (Float)(this418) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m112;
HXDLIN(  35)														int this419 = ((maskPixel12 >> 16) & 255);
HXDLIN(  35)														if ((this419 == 0)) {
HXLINE(  35)															m112 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m112 = (( (Float)(this419) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m212;
HXDLIN(  35)														int this420 = ((maskPixel12 >> 8) & 255);
HXDLIN(  35)														if ((this420 == 0)) {
HXLINE(  35)															m212 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m212 = (( (Float)(this420) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m312;
HXDLIN(  35)														int this421 = (maskPixel12 & 255);
HXDLIN(  35)														if ((this421 == 0)) {
HXLINE(  35)															m312 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m312 = (( (Float)(this421) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														int ch012 = ::Std_obj::_hx_int(((((Float)1.) - m012) * ( (Float)(((this417 >> 24) & 255)) )));
HXDLIN(  35)														int ch112 = ::Std_obj::_hx_int(((((Float)1.) - m112) * ( (Float)(((this417 >> 16) & 255)) )));
HXDLIN(  35)														int ch212 = ::Std_obj::_hx_int(((((Float)1.) - m212) * ( (Float)(((this417 >> 8) & 255)) )));
HXDLIN(  35)														int ch312 = ::Std_obj::_hx_int(((((Float)1.) - m312) * ( (Float)((this417 & 255)) )));
HXDLIN(  35)														col24 = ((((::Math_obj::round((( (Float)(ch012) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch112) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch212) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch312) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  35)												if ((col24 != 0)) {
HXLINE(  35)													int x51 = (dx13 - rectLeft12);
HXDLIN(  35)													int y51 = (dy14 - rectTop12);
HXDLIN(  35)													int c62 = col24;
HXDLIN(  35)													bool _hx_tmp111;
HXDLIN(  35)													if ((((c62 >> 24) & 255) < 254)) {
HXLINE(  35)														_hx_tmp111 = undoImage36->transparent;
            													}
            													else {
HXLINE(  35)														_hx_tmp111 = false;
            													}
HXDLIN(  35)													if (_hx_tmp111) {
HXLINE(  35)														int location24;
HXDLIN(  35)														if (undoImage36->useVirtualPos) {
HXLINE(  35)															location24 = ::Std_obj::_hx_int(((((( (Float)(y51) ) - undoImage36->virtualY) * ( (Float)(undoImage36->width) )) + x51) - undoImage36->virtualX));
            														}
            														else {
HXLINE(  35)															location24 = ::Std_obj::_hx_int(( (Float)(((y51 * undoImage36->width) + x51)) ));
            														}
HXDLIN(  35)														int this422 = ::iterMagic::Iimg_obj::get(undoImage36->image,location24);
HXDLIN(  35)														int this423;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															this423 = ((((((this422 >> 24) & 255) << 24) | ((this422 & 255) << 16)) | (((this422 >> 8) & 255) << 8)) | ((this422 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															this423 = this422;
            														}
HXDLIN(  35)														Float a127;
HXDLIN(  35)														int this424 = ((this423 >> 24) & 255);
HXDLIN(  35)														if ((this424 == 0)) {
HXLINE(  35)															a127 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a127 = (( (Float)(this424) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r124;
HXDLIN(  35)														int this425 = ((this423 >> 16) & 255);
HXDLIN(  35)														if ((this425 == 0)) {
HXLINE(  35)															r124 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r124 = (( (Float)(this425) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g124;
HXDLIN(  35)														int this426 = ((this423 >> 8) & 255);
HXDLIN(  35)														if ((this426 == 0)) {
HXLINE(  35)															g124 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g124 = (( (Float)(this426) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b130;
HXDLIN(  35)														int this427 = (this423 & 255);
HXDLIN(  35)														if ((this427 == 0)) {
HXLINE(  35)															b130 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b130 = (( (Float)(this427) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a226;
HXDLIN(  35)														int this428 = ((col24 >> 24) & 255);
HXDLIN(  35)														if ((this428 == 0)) {
HXLINE(  35)															a226 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a226 = (( (Float)(this428) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r224;
HXDLIN(  35)														int this429 = ((col24 >> 16) & 255);
HXDLIN(  35)														if ((this429 == 0)) {
HXLINE(  35)															r224 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r224 = (( (Float)(this429) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g224;
HXDLIN(  35)														int this430 = ((col24 >> 8) & 255);
HXDLIN(  35)														if ((this430 == 0)) {
HXLINE(  35)															g224 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g224 = (( (Float)(this430) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b228;
HXDLIN(  35)														int this431 = (col24 & 255);
HXDLIN(  35)														if ((this431 == 0)) {
HXLINE(  35)															b228 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b228 = (( (Float)(this431) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a324 = (a127 * (( (Float)(1) ) - a226));
HXDLIN(  35)														int r44 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r124 * a324) + (r224 * a226))));
HXDLIN(  35)														int g44 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g124 * a324) + (g224 * a226))));
HXDLIN(  35)														int b76 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b130 * a324) + (b228 * a226))));
HXDLIN(  35)														int a63 = ::Std_obj::_hx_int((( (Float)(255) ) * (a324 + a226)));
HXDLIN(  35)														int blended24 = ((((a63 << 24) | (r44 << 16)) | (g44 << 8)) | b76);
HXDLIN(  35)														{
HXLINE(  35)															int _hx_tmp112;
HXDLIN(  35)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)																_hx_tmp112 = ((((((blended24 >> 24) & 255) << 24) | ((blended24 & 255) << 16)) | (((blended24 >> 8) & 255) << 8)) | ((blended24 >> 16) & 255));
            															}
            															else {
HXLINE(  35)																_hx_tmp112 = blended24;
            															}
HXDLIN(  35)															::iterMagic::Iimg_obj::set(undoImage36->image,location24,_hx_tmp112);
            														}
            													}
            													else {
HXLINE(  35)														::Dynamic this432 = undoImage36->image;
HXDLIN(  35)														int index74;
HXDLIN(  35)														if (undoImage36->useVirtualPos) {
HXLINE(  35)															index74 = ::Std_obj::_hx_int(((((( (Float)(y51) ) - undoImage36->virtualY) * ( (Float)(undoImage36->width) )) + x51) - undoImage36->virtualX));
            														}
            														else {
HXLINE(  35)															index74 = ::Std_obj::_hx_int(( (Float)(((y51 * undoImage36->width) + x51)) ));
            														}
HXDLIN(  35)														int _hx_tmp113;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp113 = ((((((c62 >> 24) & 255) << 24) | ((c62 & 255) << 16)) | (((c62 >> 8) & 255) << 8)) | ((c62 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp113 = c62;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this432,index74,_hx_tmp113);
            													}
            												}
            												else {
HXLINE(  35)													if (forceClear12) {
HXLINE(  35)														::Dynamic this433 = undoImage36->image;
HXDLIN(  35)														int x52 = (dx13 - rectLeft12);
HXDLIN(  35)														int y52 = (dy14 - rectTop12);
HXDLIN(  35)														int index75;
HXDLIN(  35)														if (undoImage36->useVirtualPos) {
HXLINE(  35)															index75 = ::Std_obj::_hx_int(((((( (Float)(y52) ) - undoImage36->virtualY) * ( (Float)(undoImage36->width) )) + x52) - undoImage36->virtualX));
            														}
            														else {
HXLINE(  35)															index75 = ::Std_obj::_hx_int(( (Float)(((y52 * undoImage36->width) + x52)) ));
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this433,index75,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						{
HXLINE(  35)							int _g_min24 = xIter312->start;
HXDLIN(  35)							int _g_max24 = xIter312->max;
HXDLIN(  35)							while((_g_min24 < _g_max24)){
HXLINE(  35)								_g_min24 = (_g_min24 + 1);
HXDLIN(  35)								int px12 = (_g_min24 - 1);
HXDLIN(  35)								Float pcx12 = ( (Float)(px12) );
HXDLIN(  35)								{
HXLINE(  35)									int _g_min25 = yIter312->start;
HXDLIN(  35)									int _g_max25 = yIter312->max;
HXDLIN(  35)									while((_g_min25 < _g_max25)){
HXLINE(  35)										_g_min25 = (_g_min25 + 1);
HXDLIN(  35)										int py12 = (_g_min25 - 1);
HXDLIN(  35)										Float pcy12 = (( (Float)(py12) ) - dy13);
HXDLIN(  35)										Float dot3112 = ((pcx12 * bcx12) + (pcy12 * bcy12));
HXDLIN(  35)										Float dot3212 = ((pcx12 * acx12) + (pcy12 * acy12));
HXDLIN(  35)										Float ratioA12 = (((dot2212 * dot3112) - (dot1212 * dot3212)) * denom112);
HXDLIN(  35)										Float ratioB12 = (((dot1112 * dot3212) - (dot1212 * dot3112)) * denom112);
HXDLIN(  35)										Float ratioC12 = ((((Float)1.0) - ratioB12) - ratioA12);
HXDLIN(  35)										bool _hx_tmp114;
HXDLIN(  35)										bool _hx_tmp115;
HXDLIN(  35)										if ((ratioA12 >= 0)) {
HXLINE(  35)											_hx_tmp115 = (ratioB12 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp115 = false;
            										}
HXDLIN(  35)										if (_hx_tmp115) {
HXLINE(  35)											_hx_tmp114 = (ratioC12 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp114 = false;
            										}
HXDLIN(  35)										if (_hx_tmp114) {
HXLINE(  35)											Float u12 = (((au13 * ratioA12) + (bu13 * ratioB12)) + (((Float)0.) * ratioC12));
HXDLIN(  35)											Float v57 = (((av13 * ratioA12) + (bv12 * ratioB12)) + (cv * ratioC12));
HXDLIN(  35)											int x53 = ::Std_obj::_hx_int(((u12 * win_width) + win_x));
HXDLIN(  35)											int y53 = ::Std_obj::_hx_int(((v57 * win_height) + win_y));
HXDLIN(  35)											::Dynamic this434 = texture->image;
HXDLIN(  35)											int index76;
HXDLIN(  35)											if (texture->useVirtualPos) {
HXLINE(  35)												index76 = ::Std_obj::_hx_int(((((( (Float)(y53) ) - texture->virtualY) * ( (Float)(texture->width) )) + x53) - texture->virtualX));
            											}
            											else {
HXLINE(  35)												index76 = ::Std_obj::_hx_int(( (Float)(((y53 * texture->width) + x53)) ));
            											}
HXDLIN(  35)											int c63 = ::iterMagic::Iimg_obj::get(this434,index76);
HXDLIN(  35)											int col25;
HXDLIN(  35)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)												col25 = ((((((c63 >> 24) & 255) << 24) | ((c63 & 255) << 16)) | (((c63 >> 8) & 255) << 8)) | ((c63 >> 16) & 255));
            											}
            											else {
HXLINE(  35)												col25 = c63;
            											}
HXDLIN(  35)											{
HXLINE(  35)												int c64 = col25;
HXDLIN(  35)												bool _hx_tmp116;
HXDLIN(  35)												if ((((c64 >> 24) & 255) < 254)) {
HXLINE(  35)													_hx_tmp116 = temp->transparent;
            												}
            												else {
HXLINE(  35)													_hx_tmp116 = false;
            												}
HXDLIN(  35)												if (_hx_tmp116) {
HXLINE(  35)													int location25;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														location25 = ::Std_obj::_hx_int(((((( (Float)(py12) ) - temp->virtualY) * ( (Float)(temp->width) )) + px12) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														location25 = ::Std_obj::_hx_int(( (Float)(((py12 * temp->width) + px12)) ));
            													}
HXDLIN(  35)													int this435 = ::iterMagic::Iimg_obj::get(temp->image,location25);
HXDLIN(  35)													int this436;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														this436 = ((((((this435 >> 24) & 255) << 24) | ((this435 & 255) << 16)) | (((this435 >> 8) & 255) << 8)) | ((this435 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														this436 = this435;
            													}
HXDLIN(  35)													Float a128;
HXDLIN(  35)													int this437 = ((this436 >> 24) & 255);
HXDLIN(  35)													if ((this437 == 0)) {
HXLINE(  35)														a128 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a128 = (( (Float)(this437) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r125;
HXDLIN(  35)													int this438 = ((this436 >> 16) & 255);
HXDLIN(  35)													if ((this438 == 0)) {
HXLINE(  35)														r125 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r125 = (( (Float)(this438) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g125;
HXDLIN(  35)													int this439 = ((this436 >> 8) & 255);
HXDLIN(  35)													if ((this439 == 0)) {
HXLINE(  35)														g125 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g125 = (( (Float)(this439) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b131;
HXDLIN(  35)													int this440 = (this436 & 255);
HXDLIN(  35)													if ((this440 == 0)) {
HXLINE(  35)														b131 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b131 = (( (Float)(this440) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a227;
HXDLIN(  35)													int this441 = ((col25 >> 24) & 255);
HXDLIN(  35)													if ((this441 == 0)) {
HXLINE(  35)														a227 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a227 = (( (Float)(this441) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r225;
HXDLIN(  35)													int this442 = ((col25 >> 16) & 255);
HXDLIN(  35)													if ((this442 == 0)) {
HXLINE(  35)														r225 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r225 = (( (Float)(this442) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g225;
HXDLIN(  35)													int this443 = ((col25 >> 8) & 255);
HXDLIN(  35)													if ((this443 == 0)) {
HXLINE(  35)														g225 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g225 = (( (Float)(this443) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b229;
HXDLIN(  35)													int this444 = (col25 & 255);
HXDLIN(  35)													if ((this444 == 0)) {
HXLINE(  35)														b229 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b229 = (( (Float)(this444) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a325 = (a128 * (( (Float)(1) ) - a227));
HXDLIN(  35)													int r45 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r125 * a325) + (r225 * a227))));
HXDLIN(  35)													int g45 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g125 * a325) + (g225 * a227))));
HXDLIN(  35)													int b77 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b131 * a325) + (b229 * a227))));
HXDLIN(  35)													int a64 = ::Std_obj::_hx_int((( (Float)(255) ) * (a325 + a227)));
HXDLIN(  35)													int blended25 = ((((a64 << 24) | (r45 << 16)) | (g45 << 8)) | b77);
HXDLIN(  35)													{
HXLINE(  35)														int _hx_tmp117;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp117 = ((((((blended25 >> 24) & 255) << 24) | ((blended25 & 255) << 16)) | (((blended25 >> 8) & 255) << 8)) | ((blended25 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp117 = blended25;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(temp->image,location25,_hx_tmp117);
            													}
            												}
            												else {
HXLINE(  35)													::Dynamic this445 = temp->image;
HXDLIN(  35)													int index77;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														index77 = ::Std_obj::_hx_int(((((( (Float)(py12) ) - temp->virtualY) * ( (Float)(temp->width) )) + px12) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														index77 = ::Std_obj::_hx_int(( (Float)(((py12 * temp->width) + px12)) ));
            													}
HXDLIN(  35)													int _hx_tmp118;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														_hx_tmp118 = ((((((c64 >> 24) & 255) << 24) | ((c64 & 255) << 16)) | (((c64 >> 8) & 255) << 8)) | ((c64 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														_hx_tmp118 = c64;
            													}
HXDLIN(  35)													::iterMagic::Iimg_obj::set(this445,index77,_hx_tmp118);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						if ((hasHit == false)) {
HXLINE(  35)							 ::pi_xy::algo::HitTri v58 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,( (Float)(0) ),bottomY,leftX,bottomY,( (Float)(0) ),dy13,true);
HXDLIN(  35)							if (hasUndo12) {
HXLINE(  35)								v58->undoImage = undoImage36;
HXDLIN(  35)								v58->undoX = xIter312->start;
HXDLIN(  35)								v58->undoY = yIter312->start;
            							}
            						}
            					}
HXDLIN(  35)					{
HXLINE(  35)						Float au14 = bu;
HXDLIN(  35)						Float av14 = av;
HXDLIN(  35)						Float bu14 = bu;
HXDLIN(  35)						Float bv13 = cv;
HXDLIN(  35)						bool hasUndo13 = false;
HXDLIN(  35)						Float temp14 = au14;
HXLINE( 422)						au14 = bu14;
HXLINE( 423)						bu14 = temp14;
HXLINE( 424)						temp14 = av14;
HXLINE( 425)						av14 = bv13;
HXLINE( 426)						bv13 = temp14;
HXLINE(  35)						Float bcx13 = leftX;
HXDLIN(  35)						Float bcy13 = (cy4 - dy13);
HXDLIN(  35)						Float acx13 = leftX;
HXDLIN(  35)						Float acy13 = (bottomY - dy13);
HXDLIN(  35)						Float dot1113 = ((bcx13 * bcx13) + (bcy13 * bcy13));
HXDLIN(  35)						Float dot1213 = ((bcx13 * acx13) + (bcy13 * acy13));
HXDLIN(  35)						Float dot2213 = ((acx13 * acx13) + (acy13 * acy13));
HXDLIN(  35)						Float denom113 = (( (Float)(1) ) / ((dot1113 * dot2213) - (dot1213 * dot1213)));
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart xIter313;
HXDLIN(  35)						if ((leftX > leftX)) {
HXLINE(  35)							if ((leftX > 0)) {
HXLINE(  35)								int min43;
HXDLIN(  35)								if ((leftX > 0)) {
HXLINE(  35)									min43 = ::Math_obj::floor(( (Float)(0) ));
            								}
            								else {
HXLINE(  35)									min43 = ::Math_obj::floor(leftX);
            								}
HXDLIN(  35)								int ii_min95 = min43;
HXDLIN(  35)								int ii_max95 = ::Math_obj::ceil(leftX);
HXDLIN(  35)								xIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min95,ii_max95);
            							}
            							else {
HXLINE(  35)								int ii_min96 = ::Math_obj::floor(leftX);
HXDLIN(  35)								int ii_max96 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  35)								xIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min96,ii_max96);
            							}
            						}
            						else {
HXLINE(  35)							if ((leftX > 0)) {
HXLINE(  35)								int min44;
HXDLIN(  35)								if ((leftX > 0)) {
HXLINE(  35)									min44 = ::Math_obj::floor(( (Float)(0) ));
            								}
            								else {
HXLINE(  35)									min44 = ::Math_obj::ceil(leftX);
            								}
HXDLIN(  35)								int ii_min97 = min44;
HXDLIN(  35)								int ii_max97 = ::Math_obj::ceil(leftX);
HXDLIN(  35)								xIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min97,ii_max97);
            							}
            							else {
HXLINE(  35)								int ii_min98 = ::Math_obj::floor(leftX);
HXDLIN(  35)								int ii_max98 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  35)								xIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min98,ii_max98);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart yIter313;
HXDLIN(  35)						if ((bottomY > cy4)) {
HXLINE(  35)							if ((bottomY > dy13)) {
HXLINE(  35)								int min45;
HXDLIN(  35)								if ((cy4 > dy13)) {
HXLINE(  35)									min45 = ::Math_obj::floor(dy13);
            								}
            								else {
HXLINE(  35)									min45 = ::Math_obj::floor(cy4);
            								}
HXDLIN(  35)								int ii_min99 = min45;
HXDLIN(  35)								int ii_max99 = ::Math_obj::ceil(bottomY);
HXDLIN(  35)								yIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min99,ii_max99);
            							}
            							else {
HXLINE(  35)								int ii_min100 = ::Math_obj::floor(cy4);
HXDLIN(  35)								int ii_max100 = ::Math_obj::ceil(dy13);
HXDLIN(  35)								yIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min100,ii_max100);
            							}
            						}
            						else {
HXLINE(  35)							if ((cy4 > dy13)) {
HXLINE(  35)								int min46;
HXDLIN(  35)								if ((bottomY > dy13)) {
HXLINE(  35)									min46 = ::Math_obj::floor(dy13);
            								}
            								else {
HXLINE(  35)									min46 = ::Math_obj::ceil(bottomY);
            								}
HXDLIN(  35)								int ii_min101 = min46;
HXDLIN(  35)								int ii_max101 = ::Math_obj::ceil(cy4);
HXDLIN(  35)								yIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min101,ii_max101);
            							}
            							else {
HXLINE(  35)								int ii_min102 = ::Math_obj::floor(bottomY);
HXDLIN(  35)								int ii_max102 = ::Math_obj::ceil(dy13);
HXDLIN(  35)								yIter313 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min102,ii_max102);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::ImageStruct undoImage39 = null();
HXDLIN(  35)						if (hasUndo13) {
HXLINE(  35)							int width14 = ((xIter313->max - xIter313->start) + 1);
HXDLIN(  35)							int height14 = ((yIter313->max - yIter313->start) + 1);
HXDLIN(  35)							 ::Dynamic imageType14 = null();
HXDLIN(  35)							 ::pi_xy::ImageStruct this446 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  35)							if (::hx::IsNull( imageType14 )) {
HXLINE(  54)								imageType14 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE(  35)							::Dynamic undoImage40;
HXDLIN(  35)							switch((int)(( (int)(imageType14) ))){
            								case (int)0: {
HXLINE(  35)									 ::iterMagic::BytesImg byt14 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::BytesImg b78 = byt14;
HXDLIN(  35)									{
HXLINE(  35)										b78->width = width14;
HXDLIN(  35)										b78->height = height14;
HXDLIN(  35)										b78->length = ::Std_obj::_hx_int(( (Float)((width14 * height14)) ));
HXDLIN(  35)										b78->data = ::haxe::io::Bytes_obj::alloc((b78->length * 4));
HXDLIN(  35)										{
HXLINE(  35)											int len28 = b78->length;
HXDLIN(  35)											int w14 = 0;
HXDLIN(  35)											{
HXLINE(  35)												int _g276 = 0;
HXDLIN(  35)												int _g277 = b78->height;
HXDLIN(  35)												while((_g276 < _g277)){
HXLINE(  35)													_g276 = (_g276 + 1);
HXDLIN(  35)													int y54 = (_g276 - 1);
HXDLIN(  35)													{
HXLINE(  35)														int _g278 = 0;
HXDLIN(  35)														int _g279 = b78->width;
HXDLIN(  35)														while((_g278 < _g279)){
HXLINE(  35)															_g278 = (_g278 + 1);
HXDLIN(  35)															int x54 = (_g278 - 1);
HXDLIN(  35)															{
HXLINE(  35)																w14 = (w14 + 1);
HXDLIN(  35)																b78->data->b[(w14 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w14 = (w14 + 1);
HXDLIN(  35)																b78->data->b[(w14 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w14 = (w14 + 1);
HXDLIN(  35)																b78->data->b[(w14 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w14 = (w14 + 1);
HXDLIN(  35)																b78->data->b[(w14 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage40 = b78;
            								}
            								break;
            								case (int)1: {
HXLINE(  35)									 ::iterMagic::ArrIntImg arrI14 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::ArrIntImg a65 = arrI14;
HXDLIN(  35)									{
HXLINE(  35)										a65->width = width14;
HXDLIN(  35)										a65->height = height14;
HXDLIN(  35)										a65->data = ::Array_obj< int >::__new(0);
HXDLIN(  35)										a65->length = ::Std_obj::_hx_int(( (Float)((width14 * height14)) ));
HXDLIN(  35)										{
HXLINE(  35)											int _g280 = 0;
HXDLIN(  35)											int _g281 = a65->length;
HXDLIN(  35)											while((_g280 < _g281)){
HXLINE(  35)												_g280 = (_g280 + 1);
HXDLIN(  35)												int i84 = (_g280 - 1);
HXDLIN(  35)												a65->data[i84] = 0;
            											}
            										}
            									}
HXDLIN(  35)									undoImage40 = a65;
            								}
            								break;
            								case (int)2: {
HXLINE(  35)									 ::iterMagic::U32ArrImg u32a14 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::U32ArrImg b79 = u32a14;
HXDLIN(  35)									{
HXLINE(  35)										b79->width = width14;
HXDLIN(  35)										b79->height = height14;
HXDLIN(  35)										b79->length = ::Std_obj::_hx_int(( (Float)((width14 * height14)) ));
HXDLIN(  35)										int size14 = (b79->length * 4);
HXDLIN(  35)										b79->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size14),0,size14);
HXDLIN(  35)										{
HXLINE(  35)											int _g282 = 0;
HXDLIN(  35)											int _g283 = b79->length;
HXDLIN(  35)											while((_g282 < _g283)){
HXLINE(  35)												_g282 = (_g282 + 1);
HXDLIN(  35)												int i85 = (_g282 - 1);
HXDLIN(  35)												{
HXLINE(  35)													 ::haxe::io::ArrayBufferViewImpl this447 = b79->data;
HXDLIN(  35)													bool undoImage41;
HXDLIN(  35)													if ((i85 >= 0)) {
HXLINE(  35)														undoImage41 = (i85 < (this447->byteLength >> 2));
            													}
            													else {
HXLINE(  35)														undoImage41 = false;
            													}
HXDLIN(  35)													if (undoImage41) {
HXLINE(  35)														 ::haxe::io::Bytes _this14 = this447->bytes;
HXDLIN(  35)														int pos14 = ((i85 << 2) + this447->byteOffset);
HXDLIN(  35)														_this14->b[pos14] = ( (unsigned char)(0) );
HXDLIN(  35)														_this14->b[(pos14 + 1)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this14->b[(pos14 + 2)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this14->b[(pos14 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage40 = b79;
            								}
            								break;
            								case (int)3: {
HXLINE(  35)									 ::iterMagic::VecIntImg vec14 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::VecIntImg v59 = vec14;
HXDLIN(  35)									{
HXLINE(  35)										v59->width = width14;
HXDLIN(  35)										v59->height = height14;
HXDLIN(  35)										v59->length = ::Std_obj::_hx_int(( (Float)((width14 * height14)) ));
HXDLIN(  35)										v59->data = ::Array_obj< int >::__new(v59->length);
HXDLIN(  35)										{
HXLINE(  35)											int _g284 = 0;
HXDLIN(  35)											int _g285 = v59->length;
HXDLIN(  35)											while((_g284 < _g285)){
HXLINE(  35)												_g284 = (_g284 + 1);
HXDLIN(  35)												int i86 = (_g284 - 1);
HXDLIN(  35)												v59->data->__unsafe_set(i86,0);
            											}
            										}
            									}
HXDLIN(  35)									undoImage40 = v59;
            								}
            								break;
            								case (int)4: {
HXLINE(  35)									 ::iterMagic::StackIntImg sInt14 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::StackIntImg b80 = sInt14;
HXDLIN(  35)									{
HXLINE(  35)										b80->width = width14;
HXDLIN(  35)										b80->height = height14;
HXDLIN(  35)										b80->length = ::Std_obj::_hx_int(( (Float)((width14 * height14)) ));
HXDLIN(  35)										b80->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  35)										{
HXLINE(  35)											int len29 = b80->length;
HXDLIN(  35)											 ::haxe::ds::GenericStack_Int d14 = b80->data;
HXDLIN(  35)											if (::hx::IsNull( d14->head )) {
HXLINE(  35)												int _g286 = 0;
HXDLIN(  35)												int _g287 = len29;
HXDLIN(  35)												while((_g286 < _g287)){
HXLINE(  35)													_g286 = (_g286 + 1);
HXDLIN(  35)													int i87 = (_g286 - 1);
HXDLIN(  35)													d14->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d14->head);
            												}
            											}
            											else {
HXLINE(  35)												int _g288 = 0;
HXDLIN(  35)												int _g289 = len29;
HXDLIN(  35)												while((_g288 < _g289)){
HXLINE(  35)													_g288 = (_g288 + 1);
HXDLIN(  35)													int i88 = (_g288 - 1);
HXDLIN(  35)													{
HXLINE(  35)														 ::haxe::ds::GenericCell_Int l14 = b80->data->head;
HXDLIN(  35)														 ::haxe::ds::GenericCell_Int prev14 = null();
HXDLIN(  35)														{
HXLINE(  35)															int _g290 = 0;
HXDLIN(  35)															int _g291 = i88;
HXDLIN(  35)															while((_g290 < _g291)){
HXLINE(  35)																_g290 = (_g290 + 1);
HXDLIN(  35)																int i89 = (_g290 - 1);
HXLINE( 345)																prev14 = l14;
HXLINE( 346)																l14 = l14->next;
            															}
            														}
HXLINE(  35)														if (::hx::IsNull( prev14 )) {
HXLINE(  35)															b80->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l14->next);
HXDLIN(  35)															l14 = null();
            														}
            														else {
HXLINE(  35)															prev14->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l14->next);
HXDLIN(  35)															l14 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage40 = b80;
            								}
            								break;
            							}
HXDLIN(  35)							this446->image = undoImage40;
HXDLIN(  35)							this446->width = width14;
HXDLIN(  35)							this446->height = height14;
HXDLIN(  35)							this446->imageType = ( (int)(imageType14) );
HXDLIN(  35)							undoImage39 = this446;
HXDLIN(  35)							{
HXLINE(  35)								int rectLeft13 = xIter313->start;
HXDLIN(  35)								int rectTop13 = yIter313->start;
HXDLIN(  35)								int rectRight13 = xIter313->max;
HXDLIN(  35)								bool forceClear13 = false;
HXDLIN(  35)								{
HXLINE(  35)									int _g292 = rectTop13;
HXDLIN(  35)									int _g293 = yIter313->max;
HXDLIN(  35)									while((_g292 < _g293)){
HXLINE(  35)										_g292 = (_g292 + 1);
HXDLIN(  35)										int dy15 = (_g292 - 1);
HXDLIN(  35)										{
HXLINE(  35)											int _g294 = rectLeft13;
HXDLIN(  35)											int _g295 = rectRight13;
HXDLIN(  35)											while((_g294 < _g295)){
HXLINE(  35)												_g294 = (_g294 + 1);
HXDLIN(  35)												int dx14 = (_g294 - 1);
HXDLIN(  35)												::Dynamic this448 = temp->image;
HXDLIN(  35)												int index78;
HXDLIN(  35)												if (temp->useVirtualPos) {
HXLINE(  35)													index78 = ::Std_obj::_hx_int(((((( (Float)(dy15) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx14) - temp->virtualX));
            												}
            												else {
HXLINE(  35)													index78 = ::Std_obj::_hx_int(( (Float)(((dy15 * temp->width) + dx14)) ));
            												}
HXDLIN(  35)												int c65 = ::iterMagic::Iimg_obj::get(this448,index78);
HXDLIN(  35)												int col26;
HXDLIN(  35)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)													col26 = ((((((c65 >> 24) & 255) << 24) | ((c65 & 255) << 16)) | (((c65 >> 8) & 255) << 8)) | ((c65 >> 16) & 255));
            												}
            												else {
HXLINE(  35)													col26 = c65;
            												}
HXDLIN(  35)												bool _hx_tmp119;
HXDLIN(  35)												if (temp->useMask) {
HXLINE(  35)													_hx_tmp119 = ::hx::IsNotNull( temp->mask );
            												}
            												else {
HXLINE(  35)													_hx_tmp119 = false;
            												}
HXDLIN(  35)												if (_hx_tmp119) {
HXLINE(  35)													 ::pi_xy::ImageStruct this449 = temp->mask;
HXDLIN(  35)													::Dynamic this450 = this449->image;
HXDLIN(  35)													int index79;
HXDLIN(  35)													if (this449->useVirtualPos) {
HXLINE(  35)														index79 = ::Std_obj::_hx_int(((((( (Float)(dy15) ) - this449->virtualY) * ( (Float)(this449->width) )) + dx14) - this449->virtualX));
            													}
            													else {
HXLINE(  35)														index79 = ::Std_obj::_hx_int(( (Float)(((dy15 * this449->width) + dx14)) ));
            													}
HXDLIN(  35)													int c66 = ::iterMagic::Iimg_obj::get(this450,index79);
HXDLIN(  35)													int v60;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														v60 = ((((((c66 >> 24) & 255) << 24) | ((c66 & 255) << 16)) | (((c66 >> 8) & 255) << 8)) | ((c66 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														v60 = c66;
            													}
HXDLIN(  35)													int maskPixel13 = v60;
HXDLIN(  35)													int this451 = col26;
HXDLIN(  35)													if ((maskPixel13 == 0)) {
HXLINE(  35)														col26 = this451;
            													}
            													else {
HXLINE(  35)														Float m013;
HXDLIN(  35)														int this452 = ((maskPixel13 >> 24) & 255);
HXDLIN(  35)														if ((this452 == 0)) {
HXLINE(  35)															m013 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m013 = (( (Float)(this452) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m113;
HXDLIN(  35)														int this453 = ((maskPixel13 >> 16) & 255);
HXDLIN(  35)														if ((this453 == 0)) {
HXLINE(  35)															m113 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m113 = (( (Float)(this453) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m213;
HXDLIN(  35)														int this454 = ((maskPixel13 >> 8) & 255);
HXDLIN(  35)														if ((this454 == 0)) {
HXLINE(  35)															m213 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m213 = (( (Float)(this454) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m313;
HXDLIN(  35)														int this455 = (maskPixel13 & 255);
HXDLIN(  35)														if ((this455 == 0)) {
HXLINE(  35)															m313 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m313 = (( (Float)(this455) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														int ch013 = ::Std_obj::_hx_int(((((Float)1.) - m013) * ( (Float)(((this451 >> 24) & 255)) )));
HXDLIN(  35)														int ch113 = ::Std_obj::_hx_int(((((Float)1.) - m113) * ( (Float)(((this451 >> 16) & 255)) )));
HXDLIN(  35)														int ch213 = ::Std_obj::_hx_int(((((Float)1.) - m213) * ( (Float)(((this451 >> 8) & 255)) )));
HXDLIN(  35)														int ch313 = ::Std_obj::_hx_int(((((Float)1.) - m313) * ( (Float)((this451 & 255)) )));
HXDLIN(  35)														col26 = ((((::Math_obj::round((( (Float)(ch013) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch113) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch213) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch313) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  35)												if ((col26 != 0)) {
HXLINE(  35)													int x55 = (dx14 - rectLeft13);
HXDLIN(  35)													int y55 = (dy15 - rectTop13);
HXDLIN(  35)													int c67 = col26;
HXDLIN(  35)													bool _hx_tmp120;
HXDLIN(  35)													if ((((c67 >> 24) & 255) < 254)) {
HXLINE(  35)														_hx_tmp120 = undoImage39->transparent;
            													}
            													else {
HXLINE(  35)														_hx_tmp120 = false;
            													}
HXDLIN(  35)													if (_hx_tmp120) {
HXLINE(  35)														int location26;
HXDLIN(  35)														if (undoImage39->useVirtualPos) {
HXLINE(  35)															location26 = ::Std_obj::_hx_int(((((( (Float)(y55) ) - undoImage39->virtualY) * ( (Float)(undoImage39->width) )) + x55) - undoImage39->virtualX));
            														}
            														else {
HXLINE(  35)															location26 = ::Std_obj::_hx_int(( (Float)(((y55 * undoImage39->width) + x55)) ));
            														}
HXDLIN(  35)														int this456 = ::iterMagic::Iimg_obj::get(undoImage39->image,location26);
HXDLIN(  35)														int this457;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															this457 = ((((((this456 >> 24) & 255) << 24) | ((this456 & 255) << 16)) | (((this456 >> 8) & 255) << 8)) | ((this456 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															this457 = this456;
            														}
HXDLIN(  35)														Float a129;
HXDLIN(  35)														int this458 = ((this457 >> 24) & 255);
HXDLIN(  35)														if ((this458 == 0)) {
HXLINE(  35)															a129 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a129 = (( (Float)(this458) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r126;
HXDLIN(  35)														int this459 = ((this457 >> 16) & 255);
HXDLIN(  35)														if ((this459 == 0)) {
HXLINE(  35)															r126 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r126 = (( (Float)(this459) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g126;
HXDLIN(  35)														int this460 = ((this457 >> 8) & 255);
HXDLIN(  35)														if ((this460 == 0)) {
HXLINE(  35)															g126 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g126 = (( (Float)(this460) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b132;
HXDLIN(  35)														int this461 = (this457 & 255);
HXDLIN(  35)														if ((this461 == 0)) {
HXLINE(  35)															b132 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b132 = (( (Float)(this461) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a228;
HXDLIN(  35)														int this462 = ((col26 >> 24) & 255);
HXDLIN(  35)														if ((this462 == 0)) {
HXLINE(  35)															a228 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a228 = (( (Float)(this462) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r226;
HXDLIN(  35)														int this463 = ((col26 >> 16) & 255);
HXDLIN(  35)														if ((this463 == 0)) {
HXLINE(  35)															r226 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r226 = (( (Float)(this463) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g226;
HXDLIN(  35)														int this464 = ((col26 >> 8) & 255);
HXDLIN(  35)														if ((this464 == 0)) {
HXLINE(  35)															g226 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g226 = (( (Float)(this464) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b230;
HXDLIN(  35)														int this465 = (col26 & 255);
HXDLIN(  35)														if ((this465 == 0)) {
HXLINE(  35)															b230 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b230 = (( (Float)(this465) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a326 = (a129 * (( (Float)(1) ) - a228));
HXDLIN(  35)														int r46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r126 * a326) + (r226 * a228))));
HXDLIN(  35)														int g46 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g126 * a326) + (g226 * a228))));
HXDLIN(  35)														int b81 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b132 * a326) + (b230 * a228))));
HXDLIN(  35)														int a66 = ::Std_obj::_hx_int((( (Float)(255) ) * (a326 + a228)));
HXDLIN(  35)														int blended26 = ((((a66 << 24) | (r46 << 16)) | (g46 << 8)) | b81);
HXDLIN(  35)														{
HXLINE(  35)															int _hx_tmp121;
HXDLIN(  35)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)																_hx_tmp121 = ((((((blended26 >> 24) & 255) << 24) | ((blended26 & 255) << 16)) | (((blended26 >> 8) & 255) << 8)) | ((blended26 >> 16) & 255));
            															}
            															else {
HXLINE(  35)																_hx_tmp121 = blended26;
            															}
HXDLIN(  35)															::iterMagic::Iimg_obj::set(undoImage39->image,location26,_hx_tmp121);
            														}
            													}
            													else {
HXLINE(  35)														::Dynamic this466 = undoImage39->image;
HXDLIN(  35)														int index80;
HXDLIN(  35)														if (undoImage39->useVirtualPos) {
HXLINE(  35)															index80 = ::Std_obj::_hx_int(((((( (Float)(y55) ) - undoImage39->virtualY) * ( (Float)(undoImage39->width) )) + x55) - undoImage39->virtualX));
            														}
            														else {
HXLINE(  35)															index80 = ::Std_obj::_hx_int(( (Float)(((y55 * undoImage39->width) + x55)) ));
            														}
HXDLIN(  35)														int _hx_tmp122;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp122 = ((((((c67 >> 24) & 255) << 24) | ((c67 & 255) << 16)) | (((c67 >> 8) & 255) << 8)) | ((c67 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp122 = c67;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this466,index80,_hx_tmp122);
            													}
            												}
            												else {
HXLINE(  35)													if (forceClear13) {
HXLINE(  35)														::Dynamic this467 = undoImage39->image;
HXDLIN(  35)														int x56 = (dx14 - rectLeft13);
HXDLIN(  35)														int y56 = (dy15 - rectTop13);
HXDLIN(  35)														int index81;
HXDLIN(  35)														if (undoImage39->useVirtualPos) {
HXLINE(  35)															index81 = ::Std_obj::_hx_int(((((( (Float)(y56) ) - undoImage39->virtualY) * ( (Float)(undoImage39->width) )) + x56) - undoImage39->virtualX));
            														}
            														else {
HXLINE(  35)															index81 = ::Std_obj::_hx_int(( (Float)(((y56 * undoImage39->width) + x56)) ));
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this467,index81,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						{
HXLINE(  35)							int _g_min26 = xIter313->start;
HXDLIN(  35)							int _g_max26 = xIter313->max;
HXDLIN(  35)							while((_g_min26 < _g_max26)){
HXLINE(  35)								_g_min26 = (_g_min26 + 1);
HXDLIN(  35)								int px13 = (_g_min26 - 1);
HXDLIN(  35)								Float pcx13 = ( (Float)(px13) );
HXDLIN(  35)								{
HXLINE(  35)									int _g_min27 = yIter313->start;
HXDLIN(  35)									int _g_max27 = yIter313->max;
HXDLIN(  35)									while((_g_min27 < _g_max27)){
HXLINE(  35)										_g_min27 = (_g_min27 + 1);
HXDLIN(  35)										int py13 = (_g_min27 - 1);
HXDLIN(  35)										Float pcy13 = (( (Float)(py13) ) - dy13);
HXDLIN(  35)										Float dot3113 = ((pcx13 * bcx13) + (pcy13 * bcy13));
HXDLIN(  35)										Float dot3213 = ((pcx13 * acx13) + (pcy13 * acy13));
HXDLIN(  35)										Float ratioA13 = (((dot2213 * dot3113) - (dot1213 * dot3213)) * denom113);
HXDLIN(  35)										Float ratioB13 = (((dot1113 * dot3213) - (dot1213 * dot3113)) * denom113);
HXDLIN(  35)										Float ratioC13 = ((((Float)1.0) - ratioB13) - ratioA13);
HXDLIN(  35)										bool _hx_tmp123;
HXDLIN(  35)										bool _hx_tmp124;
HXDLIN(  35)										if ((ratioA13 >= 0)) {
HXLINE(  35)											_hx_tmp124 = (ratioB13 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp124 = false;
            										}
HXDLIN(  35)										if (_hx_tmp124) {
HXLINE(  35)											_hx_tmp123 = (ratioC13 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp123 = false;
            										}
HXDLIN(  35)										if (_hx_tmp123) {
HXLINE(  35)											Float u13 = (((au14 * ratioA13) + (bu14 * ratioB13)) + (((Float)0.) * ratioC13));
HXDLIN(  35)											Float v61 = (((av14 * ratioA13) + (bv13 * ratioB13)) + (cv * ratioC13));
HXDLIN(  35)											int x57 = ::Std_obj::_hx_int(((u13 * win_width) + win_x));
HXDLIN(  35)											int y57 = ::Std_obj::_hx_int(((v61 * win_height) + win_y));
HXDLIN(  35)											::Dynamic this468 = texture->image;
HXDLIN(  35)											int index82;
HXDLIN(  35)											if (texture->useVirtualPos) {
HXLINE(  35)												index82 = ::Std_obj::_hx_int(((((( (Float)(y57) ) - texture->virtualY) * ( (Float)(texture->width) )) + x57) - texture->virtualX));
            											}
            											else {
HXLINE(  35)												index82 = ::Std_obj::_hx_int(( (Float)(((y57 * texture->width) + x57)) ));
            											}
HXDLIN(  35)											int c68 = ::iterMagic::Iimg_obj::get(this468,index82);
HXDLIN(  35)											int col27;
HXDLIN(  35)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)												col27 = ((((((c68 >> 24) & 255) << 24) | ((c68 & 255) << 16)) | (((c68 >> 8) & 255) << 8)) | ((c68 >> 16) & 255));
            											}
            											else {
HXLINE(  35)												col27 = c68;
            											}
HXDLIN(  35)											{
HXLINE(  35)												int c69 = col27;
HXDLIN(  35)												bool _hx_tmp125;
HXDLIN(  35)												if ((((c69 >> 24) & 255) < 254)) {
HXLINE(  35)													_hx_tmp125 = temp->transparent;
            												}
            												else {
HXLINE(  35)													_hx_tmp125 = false;
            												}
HXDLIN(  35)												if (_hx_tmp125) {
HXLINE(  35)													int location27;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														location27 = ::Std_obj::_hx_int(((((( (Float)(py13) ) - temp->virtualY) * ( (Float)(temp->width) )) + px13) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														location27 = ::Std_obj::_hx_int(( (Float)(((py13 * temp->width) + px13)) ));
            													}
HXDLIN(  35)													int this469 = ::iterMagic::Iimg_obj::get(temp->image,location27);
HXDLIN(  35)													int this470;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														this470 = ((((((this469 >> 24) & 255) << 24) | ((this469 & 255) << 16)) | (((this469 >> 8) & 255) << 8)) | ((this469 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														this470 = this469;
            													}
HXDLIN(  35)													Float a130;
HXDLIN(  35)													int this471 = ((this470 >> 24) & 255);
HXDLIN(  35)													if ((this471 == 0)) {
HXLINE(  35)														a130 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a130 = (( (Float)(this471) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r127;
HXDLIN(  35)													int this472 = ((this470 >> 16) & 255);
HXDLIN(  35)													if ((this472 == 0)) {
HXLINE(  35)														r127 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r127 = (( (Float)(this472) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g127;
HXDLIN(  35)													int this473 = ((this470 >> 8) & 255);
HXDLIN(  35)													if ((this473 == 0)) {
HXLINE(  35)														g127 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g127 = (( (Float)(this473) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b133;
HXDLIN(  35)													int this474 = (this470 & 255);
HXDLIN(  35)													if ((this474 == 0)) {
HXLINE(  35)														b133 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b133 = (( (Float)(this474) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a229;
HXDLIN(  35)													int this475 = ((col27 >> 24) & 255);
HXDLIN(  35)													if ((this475 == 0)) {
HXLINE(  35)														a229 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a229 = (( (Float)(this475) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r227;
HXDLIN(  35)													int this476 = ((col27 >> 16) & 255);
HXDLIN(  35)													if ((this476 == 0)) {
HXLINE(  35)														r227 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r227 = (( (Float)(this476) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g227;
HXDLIN(  35)													int this477 = ((col27 >> 8) & 255);
HXDLIN(  35)													if ((this477 == 0)) {
HXLINE(  35)														g227 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g227 = (( (Float)(this477) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b231;
HXDLIN(  35)													int this478 = (col27 & 255);
HXDLIN(  35)													if ((this478 == 0)) {
HXLINE(  35)														b231 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b231 = (( (Float)(this478) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a327 = (a130 * (( (Float)(1) ) - a229));
HXDLIN(  35)													int r47 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r127 * a327) + (r227 * a229))));
HXDLIN(  35)													int g47 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g127 * a327) + (g227 * a229))));
HXDLIN(  35)													int b82 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b133 * a327) + (b231 * a229))));
HXDLIN(  35)													int a67 = ::Std_obj::_hx_int((( (Float)(255) ) * (a327 + a229)));
HXDLIN(  35)													int blended27 = ((((a67 << 24) | (r47 << 16)) | (g47 << 8)) | b82);
HXDLIN(  35)													{
HXLINE(  35)														int _hx_tmp126;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp126 = ((((((blended27 >> 24) & 255) << 24) | ((blended27 & 255) << 16)) | (((blended27 >> 8) & 255) << 8)) | ((blended27 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp126 = blended27;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(temp->image,location27,_hx_tmp126);
            													}
            												}
            												else {
HXLINE(  35)													::Dynamic this479 = temp->image;
HXDLIN(  35)													int index83;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														index83 = ::Std_obj::_hx_int(((((( (Float)(py13) ) - temp->virtualY) * ( (Float)(temp->width) )) + px13) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														index83 = ::Std_obj::_hx_int(( (Float)(((py13 * temp->width) + px13)) ));
            													}
HXDLIN(  35)													int _hx_tmp127;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														_hx_tmp127 = ((((((c69 >> 24) & 255) << 24) | ((c69 & 255) << 16)) | (((c69 >> 8) & 255) << 8)) | ((c69 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														_hx_tmp127 = c69;
            													}
HXDLIN(  35)													::iterMagic::Iimg_obj::set(this479,index83,_hx_tmp127);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						if ((hasHit == false)) {
HXLINE(  35)							 ::pi_xy::algo::HitTri v62 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,leftX,bottomY,leftX,cy4,( (Float)(0) ),dy13,true);
HXDLIN(  35)							if (hasUndo13) {
HXLINE(  35)								v62->undoImage = undoImage39;
HXDLIN(  35)								v62->undoX = xIter313->start;
HXDLIN(  35)								v62->undoY = yIter313->start;
            							}
            						}
            					}
HXDLIN(  35)					if ((hasHit == true)) {
HXLINE(  35)						 ::pi_xy::algo::HitQuad v63 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,( (Float)(0) ),bottomY,leftX,bottomY,leftX,cy4,( (Float)(0) ),dy13,true);
            					}
            				}
HXLINE( 289)				au = bu;
HXLINE( 290)				bu = ((left + fat) * sw);
HXLINE(  35)				{
HXLINE(  35)					Float cy5 = hiNew;
HXDLIN(  35)					Float dy16 = hiNew;
HXDLIN(  35)					{
HXLINE(  35)						Float au15 = au;
HXDLIN(  35)						Float av15 = av;
HXDLIN(  35)						Float bu15 = bu;
HXDLIN(  35)						Float bv14 = av;
HXDLIN(  35)						bool hasUndo14 = false;
HXDLIN(  35)						Float temp15 = au15;
HXLINE( 422)						au15 = bu15;
HXLINE( 423)						bu15 = temp15;
HXLINE( 424)						temp15 = av15;
HXLINE( 425)						av15 = bv14;
HXLINE( 426)						bv14 = temp15;
HXLINE(  35)						Float bcx14 = (rightX - leftX);
HXDLIN(  35)						Float bcy14 = (bottomY - dy16);
HXDLIN(  35)						Float acx14 = (leftX - leftX);
HXDLIN(  35)						Float acy14 = (bottomY - dy16);
HXDLIN(  35)						Float dot1114 = ((bcx14 * bcx14) + (bcy14 * bcy14));
HXDLIN(  35)						Float dot1214 = ((bcx14 * acx14) + (bcy14 * acy14));
HXDLIN(  35)						Float dot2214 = ((acx14 * acx14) + (acy14 * acy14));
HXDLIN(  35)						Float denom114 = (( (Float)(1) ) / ((dot1114 * dot2214) - (dot1214 * dot1214)));
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart xIter314;
HXDLIN(  35)						if ((leftX > rightX)) {
HXLINE(  35)							if ((leftX > leftX)) {
HXLINE(  35)								int min47;
HXDLIN(  35)								if ((rightX > leftX)) {
HXLINE(  35)									min47 = ::Math_obj::floor(leftX);
            								}
            								else {
HXLINE(  35)									min47 = ::Math_obj::floor(rightX);
            								}
HXDLIN(  35)								int ii_min103 = min47;
HXDLIN(  35)								int ii_max103 = ::Math_obj::ceil(leftX);
HXDLIN(  35)								xIter314 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min103,ii_max103);
            							}
            							else {
HXLINE(  35)								int ii_min104 = ::Math_obj::floor(rightX);
HXDLIN(  35)								int ii_max104 = ::Math_obj::ceil(leftX);
HXDLIN(  35)								xIter314 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min104,ii_max104);
            							}
            						}
            						else {
HXLINE(  35)							if ((rightX > leftX)) {
HXLINE(  35)								int min48;
HXDLIN(  35)								if ((leftX > leftX)) {
HXLINE(  35)									min48 = ::Math_obj::floor(leftX);
            								}
            								else {
HXLINE(  35)									min48 = ::Math_obj::ceil(leftX);
            								}
HXDLIN(  35)								int ii_min105 = min48;
HXDLIN(  35)								int ii_max105 = ::Math_obj::ceil(rightX);
HXDLIN(  35)								xIter314 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min105,ii_max105);
            							}
            							else {
HXLINE(  35)								int ii_min106 = ::Math_obj::floor(leftX);
HXDLIN(  35)								int ii_max106 = ::Math_obj::ceil(leftX);
HXDLIN(  35)								xIter314 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min106,ii_max106);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart yIter314;
HXDLIN(  35)						if ((bottomY > bottomY)) {
HXLINE(  35)							if ((bottomY > dy16)) {
HXLINE(  35)								int min49;
HXDLIN(  35)								if ((bottomY > dy16)) {
HXLINE(  35)									min49 = ::Math_obj::floor(dy16);
            								}
            								else {
HXLINE(  35)									min49 = ::Math_obj::floor(bottomY);
            								}
HXDLIN(  35)								int ii_min107 = min49;
HXDLIN(  35)								int ii_max107 = ::Math_obj::ceil(bottomY);
HXDLIN(  35)								yIter314 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min107,ii_max107);
            							}
            							else {
HXLINE(  35)								int ii_min108 = ::Math_obj::floor(bottomY);
HXDLIN(  35)								int ii_max108 = ::Math_obj::ceil(dy16);
HXDLIN(  35)								yIter314 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min108,ii_max108);
            							}
            						}
            						else {
HXLINE(  35)							if ((bottomY > dy16)) {
HXLINE(  35)								int min50;
HXDLIN(  35)								if ((bottomY > dy16)) {
HXLINE(  35)									min50 = ::Math_obj::floor(dy16);
            								}
            								else {
HXLINE(  35)									min50 = ::Math_obj::ceil(bottomY);
            								}
HXDLIN(  35)								int ii_min109 = min50;
HXDLIN(  35)								int ii_max109 = ::Math_obj::ceil(bottomY);
HXDLIN(  35)								yIter314 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min109,ii_max109);
            							}
            							else {
HXLINE(  35)								int ii_min110 = ::Math_obj::floor(bottomY);
HXDLIN(  35)								int ii_max110 = ::Math_obj::ceil(dy16);
HXDLIN(  35)								yIter314 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min110,ii_max110);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::ImageStruct undoImage42 = null();
HXDLIN(  35)						if (hasUndo14) {
HXLINE(  35)							int width15 = ((xIter314->max - xIter314->start) + 1);
HXDLIN(  35)							int height15 = ((yIter314->max - yIter314->start) + 1);
HXDLIN(  35)							 ::Dynamic imageType15 = null();
HXDLIN(  35)							 ::pi_xy::ImageStruct this480 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  35)							if (::hx::IsNull( imageType15 )) {
HXLINE(  54)								imageType15 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE(  35)							::Dynamic undoImage43;
HXDLIN(  35)							switch((int)(( (int)(imageType15) ))){
            								case (int)0: {
HXLINE(  35)									 ::iterMagic::BytesImg byt15 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::BytesImg b83 = byt15;
HXDLIN(  35)									{
HXLINE(  35)										b83->width = width15;
HXDLIN(  35)										b83->height = height15;
HXDLIN(  35)										b83->length = ::Std_obj::_hx_int(( (Float)((width15 * height15)) ));
HXDLIN(  35)										b83->data = ::haxe::io::Bytes_obj::alloc((b83->length * 4));
HXDLIN(  35)										{
HXLINE(  35)											int len30 = b83->length;
HXDLIN(  35)											int w15 = 0;
HXDLIN(  35)											{
HXLINE(  35)												int _g296 = 0;
HXDLIN(  35)												int _g297 = b83->height;
HXDLIN(  35)												while((_g296 < _g297)){
HXLINE(  35)													_g296 = (_g296 + 1);
HXDLIN(  35)													int y58 = (_g296 - 1);
HXDLIN(  35)													{
HXLINE(  35)														int _g298 = 0;
HXDLIN(  35)														int _g299 = b83->width;
HXDLIN(  35)														while((_g298 < _g299)){
HXLINE(  35)															_g298 = (_g298 + 1);
HXDLIN(  35)															int x58 = (_g298 - 1);
HXDLIN(  35)															{
HXLINE(  35)																w15 = (w15 + 1);
HXDLIN(  35)																b83->data->b[(w15 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w15 = (w15 + 1);
HXDLIN(  35)																b83->data->b[(w15 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w15 = (w15 + 1);
HXDLIN(  35)																b83->data->b[(w15 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w15 = (w15 + 1);
HXDLIN(  35)																b83->data->b[(w15 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage43 = b83;
            								}
            								break;
            								case (int)1: {
HXLINE(  35)									 ::iterMagic::ArrIntImg arrI15 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::ArrIntImg a68 = arrI15;
HXDLIN(  35)									{
HXLINE(  35)										a68->width = width15;
HXDLIN(  35)										a68->height = height15;
HXDLIN(  35)										a68->data = ::Array_obj< int >::__new(0);
HXDLIN(  35)										a68->length = ::Std_obj::_hx_int(( (Float)((width15 * height15)) ));
HXDLIN(  35)										{
HXLINE(  35)											int _g300 = 0;
HXDLIN(  35)											int _g301 = a68->length;
HXDLIN(  35)											while((_g300 < _g301)){
HXLINE(  35)												_g300 = (_g300 + 1);
HXDLIN(  35)												int i90 = (_g300 - 1);
HXDLIN(  35)												a68->data[i90] = 0;
            											}
            										}
            									}
HXDLIN(  35)									undoImage43 = a68;
            								}
            								break;
            								case (int)2: {
HXLINE(  35)									 ::iterMagic::U32ArrImg u32a15 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::U32ArrImg b84 = u32a15;
HXDLIN(  35)									{
HXLINE(  35)										b84->width = width15;
HXDLIN(  35)										b84->height = height15;
HXDLIN(  35)										b84->length = ::Std_obj::_hx_int(( (Float)((width15 * height15)) ));
HXDLIN(  35)										int size15 = (b84->length * 4);
HXDLIN(  35)										b84->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size15),0,size15);
HXDLIN(  35)										{
HXLINE(  35)											int _g302 = 0;
HXDLIN(  35)											int _g303 = b84->length;
HXDLIN(  35)											while((_g302 < _g303)){
HXLINE(  35)												_g302 = (_g302 + 1);
HXDLIN(  35)												int i91 = (_g302 - 1);
HXDLIN(  35)												{
HXLINE(  35)													 ::haxe::io::ArrayBufferViewImpl this481 = b84->data;
HXDLIN(  35)													bool undoImage44;
HXDLIN(  35)													if ((i91 >= 0)) {
HXLINE(  35)														undoImage44 = (i91 < (this481->byteLength >> 2));
            													}
            													else {
HXLINE(  35)														undoImage44 = false;
            													}
HXDLIN(  35)													if (undoImage44) {
HXLINE(  35)														 ::haxe::io::Bytes _this15 = this481->bytes;
HXDLIN(  35)														int pos15 = ((i91 << 2) + this481->byteOffset);
HXDLIN(  35)														_this15->b[pos15] = ( (unsigned char)(0) );
HXDLIN(  35)														_this15->b[(pos15 + 1)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this15->b[(pos15 + 2)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this15->b[(pos15 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage43 = b84;
            								}
            								break;
            								case (int)3: {
HXLINE(  35)									 ::iterMagic::VecIntImg vec15 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::VecIntImg v64 = vec15;
HXDLIN(  35)									{
HXLINE(  35)										v64->width = width15;
HXDLIN(  35)										v64->height = height15;
HXDLIN(  35)										v64->length = ::Std_obj::_hx_int(( (Float)((width15 * height15)) ));
HXDLIN(  35)										v64->data = ::Array_obj< int >::__new(v64->length);
HXDLIN(  35)										{
HXLINE(  35)											int _g304 = 0;
HXDLIN(  35)											int _g305 = v64->length;
HXDLIN(  35)											while((_g304 < _g305)){
HXLINE(  35)												_g304 = (_g304 + 1);
HXDLIN(  35)												int i92 = (_g304 - 1);
HXDLIN(  35)												v64->data->__unsafe_set(i92,0);
            											}
            										}
            									}
HXDLIN(  35)									undoImage43 = v64;
            								}
            								break;
            								case (int)4: {
HXLINE(  35)									 ::iterMagic::StackIntImg sInt15 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::StackIntImg b85 = sInt15;
HXDLIN(  35)									{
HXLINE(  35)										b85->width = width15;
HXDLIN(  35)										b85->height = height15;
HXDLIN(  35)										b85->length = ::Std_obj::_hx_int(( (Float)((width15 * height15)) ));
HXDLIN(  35)										b85->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  35)										{
HXLINE(  35)											int len31 = b85->length;
HXDLIN(  35)											 ::haxe::ds::GenericStack_Int d15 = b85->data;
HXDLIN(  35)											if (::hx::IsNull( d15->head )) {
HXLINE(  35)												int _g306 = 0;
HXDLIN(  35)												int _g307 = len31;
HXDLIN(  35)												while((_g306 < _g307)){
HXLINE(  35)													_g306 = (_g306 + 1);
HXDLIN(  35)													int i93 = (_g306 - 1);
HXDLIN(  35)													d15->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d15->head);
            												}
            											}
            											else {
HXLINE(  35)												int _g308 = 0;
HXDLIN(  35)												int _g309 = len31;
HXDLIN(  35)												while((_g308 < _g309)){
HXLINE(  35)													_g308 = (_g308 + 1);
HXDLIN(  35)													int i94 = (_g308 - 1);
HXDLIN(  35)													{
HXLINE(  35)														 ::haxe::ds::GenericCell_Int l15 = b85->data->head;
HXDLIN(  35)														 ::haxe::ds::GenericCell_Int prev15 = null();
HXDLIN(  35)														{
HXLINE(  35)															int _g310 = 0;
HXDLIN(  35)															int _g311 = i94;
HXDLIN(  35)															while((_g310 < _g311)){
HXLINE(  35)																_g310 = (_g310 + 1);
HXDLIN(  35)																int i95 = (_g310 - 1);
HXLINE( 345)																prev15 = l15;
HXLINE( 346)																l15 = l15->next;
            															}
            														}
HXLINE(  35)														if (::hx::IsNull( prev15 )) {
HXLINE(  35)															b85->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l15->next);
HXDLIN(  35)															l15 = null();
            														}
            														else {
HXLINE(  35)															prev15->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l15->next);
HXDLIN(  35)															l15 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage43 = b85;
            								}
            								break;
            							}
HXDLIN(  35)							this480->image = undoImage43;
HXDLIN(  35)							this480->width = width15;
HXDLIN(  35)							this480->height = height15;
HXDLIN(  35)							this480->imageType = ( (int)(imageType15) );
HXDLIN(  35)							undoImage42 = this480;
HXDLIN(  35)							{
HXLINE(  35)								int rectLeft14 = xIter314->start;
HXDLIN(  35)								int rectTop14 = yIter314->start;
HXDLIN(  35)								int rectRight14 = xIter314->max;
HXDLIN(  35)								bool forceClear14 = false;
HXDLIN(  35)								{
HXLINE(  35)									int _g312 = rectTop14;
HXDLIN(  35)									int _g313 = yIter314->max;
HXDLIN(  35)									while((_g312 < _g313)){
HXLINE(  35)										_g312 = (_g312 + 1);
HXDLIN(  35)										int dy17 = (_g312 - 1);
HXDLIN(  35)										{
HXLINE(  35)											int _g314 = rectLeft14;
HXDLIN(  35)											int _g315 = rectRight14;
HXDLIN(  35)											while((_g314 < _g315)){
HXLINE(  35)												_g314 = (_g314 + 1);
HXDLIN(  35)												int dx15 = (_g314 - 1);
HXDLIN(  35)												::Dynamic this482 = temp->image;
HXDLIN(  35)												int index84;
HXDLIN(  35)												if (temp->useVirtualPos) {
HXLINE(  35)													index84 = ::Std_obj::_hx_int(((((( (Float)(dy17) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx15) - temp->virtualX));
            												}
            												else {
HXLINE(  35)													index84 = ::Std_obj::_hx_int(( (Float)(((dy17 * temp->width) + dx15)) ));
            												}
HXDLIN(  35)												int c70 = ::iterMagic::Iimg_obj::get(this482,index84);
HXDLIN(  35)												int col28;
HXDLIN(  35)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)													col28 = ((((((c70 >> 24) & 255) << 24) | ((c70 & 255) << 16)) | (((c70 >> 8) & 255) << 8)) | ((c70 >> 16) & 255));
            												}
            												else {
HXLINE(  35)													col28 = c70;
            												}
HXDLIN(  35)												bool _hx_tmp128;
HXDLIN(  35)												if (temp->useMask) {
HXLINE(  35)													_hx_tmp128 = ::hx::IsNotNull( temp->mask );
            												}
            												else {
HXLINE(  35)													_hx_tmp128 = false;
            												}
HXDLIN(  35)												if (_hx_tmp128) {
HXLINE(  35)													 ::pi_xy::ImageStruct this483 = temp->mask;
HXDLIN(  35)													::Dynamic this484 = this483->image;
HXDLIN(  35)													int index85;
HXDLIN(  35)													if (this483->useVirtualPos) {
HXLINE(  35)														index85 = ::Std_obj::_hx_int(((((( (Float)(dy17) ) - this483->virtualY) * ( (Float)(this483->width) )) + dx15) - this483->virtualX));
            													}
            													else {
HXLINE(  35)														index85 = ::Std_obj::_hx_int(( (Float)(((dy17 * this483->width) + dx15)) ));
            													}
HXDLIN(  35)													int c71 = ::iterMagic::Iimg_obj::get(this484,index85);
HXDLIN(  35)													int v65;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														v65 = ((((((c71 >> 24) & 255) << 24) | ((c71 & 255) << 16)) | (((c71 >> 8) & 255) << 8)) | ((c71 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														v65 = c71;
            													}
HXDLIN(  35)													int maskPixel14 = v65;
HXDLIN(  35)													int this485 = col28;
HXDLIN(  35)													if ((maskPixel14 == 0)) {
HXLINE(  35)														col28 = this485;
            													}
            													else {
HXLINE(  35)														Float m014;
HXDLIN(  35)														int this486 = ((maskPixel14 >> 24) & 255);
HXDLIN(  35)														if ((this486 == 0)) {
HXLINE(  35)															m014 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m014 = (( (Float)(this486) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m114;
HXDLIN(  35)														int this487 = ((maskPixel14 >> 16) & 255);
HXDLIN(  35)														if ((this487 == 0)) {
HXLINE(  35)															m114 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m114 = (( (Float)(this487) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m214;
HXDLIN(  35)														int this488 = ((maskPixel14 >> 8) & 255);
HXDLIN(  35)														if ((this488 == 0)) {
HXLINE(  35)															m214 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m214 = (( (Float)(this488) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m314;
HXDLIN(  35)														int this489 = (maskPixel14 & 255);
HXDLIN(  35)														if ((this489 == 0)) {
HXLINE(  35)															m314 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m314 = (( (Float)(this489) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														int ch014 = ::Std_obj::_hx_int(((((Float)1.) - m014) * ( (Float)(((this485 >> 24) & 255)) )));
HXDLIN(  35)														int ch114 = ::Std_obj::_hx_int(((((Float)1.) - m114) * ( (Float)(((this485 >> 16) & 255)) )));
HXDLIN(  35)														int ch214 = ::Std_obj::_hx_int(((((Float)1.) - m214) * ( (Float)(((this485 >> 8) & 255)) )));
HXDLIN(  35)														int ch314 = ::Std_obj::_hx_int(((((Float)1.) - m314) * ( (Float)((this485 & 255)) )));
HXDLIN(  35)														col28 = ((((::Math_obj::round((( (Float)(ch014) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch114) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch214) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch314) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  35)												if ((col28 != 0)) {
HXLINE(  35)													int x59 = (dx15 - rectLeft14);
HXDLIN(  35)													int y59 = (dy17 - rectTop14);
HXDLIN(  35)													int c72 = col28;
HXDLIN(  35)													bool _hx_tmp129;
HXDLIN(  35)													if ((((c72 >> 24) & 255) < 254)) {
HXLINE(  35)														_hx_tmp129 = undoImage42->transparent;
            													}
            													else {
HXLINE(  35)														_hx_tmp129 = false;
            													}
HXDLIN(  35)													if (_hx_tmp129) {
HXLINE(  35)														int location28;
HXDLIN(  35)														if (undoImage42->useVirtualPos) {
HXLINE(  35)															location28 = ::Std_obj::_hx_int(((((( (Float)(y59) ) - undoImage42->virtualY) * ( (Float)(undoImage42->width) )) + x59) - undoImage42->virtualX));
            														}
            														else {
HXLINE(  35)															location28 = ::Std_obj::_hx_int(( (Float)(((y59 * undoImage42->width) + x59)) ));
            														}
HXDLIN(  35)														int this490 = ::iterMagic::Iimg_obj::get(undoImage42->image,location28);
HXDLIN(  35)														int this491;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															this491 = ((((((this490 >> 24) & 255) << 24) | ((this490 & 255) << 16)) | (((this490 >> 8) & 255) << 8)) | ((this490 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															this491 = this490;
            														}
HXDLIN(  35)														Float a131;
HXDLIN(  35)														int this492 = ((this491 >> 24) & 255);
HXDLIN(  35)														if ((this492 == 0)) {
HXLINE(  35)															a131 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a131 = (( (Float)(this492) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r128;
HXDLIN(  35)														int this493 = ((this491 >> 16) & 255);
HXDLIN(  35)														if ((this493 == 0)) {
HXLINE(  35)															r128 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r128 = (( (Float)(this493) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g128;
HXDLIN(  35)														int this494 = ((this491 >> 8) & 255);
HXDLIN(  35)														if ((this494 == 0)) {
HXLINE(  35)															g128 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g128 = (( (Float)(this494) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b134;
HXDLIN(  35)														int this495 = (this491 & 255);
HXDLIN(  35)														if ((this495 == 0)) {
HXLINE(  35)															b134 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b134 = (( (Float)(this495) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a230;
HXDLIN(  35)														int this496 = ((col28 >> 24) & 255);
HXDLIN(  35)														if ((this496 == 0)) {
HXLINE(  35)															a230 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a230 = (( (Float)(this496) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r228;
HXDLIN(  35)														int this497 = ((col28 >> 16) & 255);
HXDLIN(  35)														if ((this497 == 0)) {
HXLINE(  35)															r228 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r228 = (( (Float)(this497) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g228;
HXDLIN(  35)														int this498 = ((col28 >> 8) & 255);
HXDLIN(  35)														if ((this498 == 0)) {
HXLINE(  35)															g228 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g228 = (( (Float)(this498) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b232;
HXDLIN(  35)														int this499 = (col28 & 255);
HXDLIN(  35)														if ((this499 == 0)) {
HXLINE(  35)															b232 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b232 = (( (Float)(this499) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a328 = (a131 * (( (Float)(1) ) - a230));
HXDLIN(  35)														int r48 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r128 * a328) + (r228 * a230))));
HXDLIN(  35)														int g48 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g128 * a328) + (g228 * a230))));
HXDLIN(  35)														int b86 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b134 * a328) + (b232 * a230))));
HXDLIN(  35)														int a69 = ::Std_obj::_hx_int((( (Float)(255) ) * (a328 + a230)));
HXDLIN(  35)														int blended28 = ((((a69 << 24) | (r48 << 16)) | (g48 << 8)) | b86);
HXDLIN(  35)														{
HXLINE(  35)															int _hx_tmp130;
HXDLIN(  35)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)																_hx_tmp130 = ((((((blended28 >> 24) & 255) << 24) | ((blended28 & 255) << 16)) | (((blended28 >> 8) & 255) << 8)) | ((blended28 >> 16) & 255));
            															}
            															else {
HXLINE(  35)																_hx_tmp130 = blended28;
            															}
HXDLIN(  35)															::iterMagic::Iimg_obj::set(undoImage42->image,location28,_hx_tmp130);
            														}
            													}
            													else {
HXLINE(  35)														::Dynamic this500 = undoImage42->image;
HXDLIN(  35)														int index86;
HXDLIN(  35)														if (undoImage42->useVirtualPos) {
HXLINE(  35)															index86 = ::Std_obj::_hx_int(((((( (Float)(y59) ) - undoImage42->virtualY) * ( (Float)(undoImage42->width) )) + x59) - undoImage42->virtualX));
            														}
            														else {
HXLINE(  35)															index86 = ::Std_obj::_hx_int(( (Float)(((y59 * undoImage42->width) + x59)) ));
            														}
HXDLIN(  35)														int _hx_tmp131;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp131 = ((((((c72 >> 24) & 255) << 24) | ((c72 & 255) << 16)) | (((c72 >> 8) & 255) << 8)) | ((c72 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp131 = c72;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this500,index86,_hx_tmp131);
            													}
            												}
            												else {
HXLINE(  35)													if (forceClear14) {
HXLINE(  35)														::Dynamic this501 = undoImage42->image;
HXDLIN(  35)														int x60 = (dx15 - rectLeft14);
HXDLIN(  35)														int y60 = (dy17 - rectTop14);
HXDLIN(  35)														int index87;
HXDLIN(  35)														if (undoImage42->useVirtualPos) {
HXLINE(  35)															index87 = ::Std_obj::_hx_int(((((( (Float)(y60) ) - undoImage42->virtualY) * ( (Float)(undoImage42->width) )) + x60) - undoImage42->virtualX));
            														}
            														else {
HXLINE(  35)															index87 = ::Std_obj::_hx_int(( (Float)(((y60 * undoImage42->width) + x60)) ));
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this501,index87,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						{
HXLINE(  35)							int _g_min28 = xIter314->start;
HXDLIN(  35)							int _g_max28 = xIter314->max;
HXDLIN(  35)							while((_g_min28 < _g_max28)){
HXLINE(  35)								_g_min28 = (_g_min28 + 1);
HXDLIN(  35)								int px14 = (_g_min28 - 1);
HXDLIN(  35)								Float pcx14 = (( (Float)(px14) ) - leftX);
HXDLIN(  35)								{
HXLINE(  35)									int _g_min29 = yIter314->start;
HXDLIN(  35)									int _g_max29 = yIter314->max;
HXDLIN(  35)									while((_g_min29 < _g_max29)){
HXLINE(  35)										_g_min29 = (_g_min29 + 1);
HXDLIN(  35)										int py14 = (_g_min29 - 1);
HXDLIN(  35)										Float pcy14 = (( (Float)(py14) ) - dy16);
HXDLIN(  35)										Float dot3114 = ((pcx14 * bcx14) + (pcy14 * bcy14));
HXDLIN(  35)										Float dot3214 = ((pcx14 * acx14) + (pcy14 * acy14));
HXDLIN(  35)										Float ratioA14 = (((dot2214 * dot3114) - (dot1214 * dot3214)) * denom114);
HXDLIN(  35)										Float ratioB14 = (((dot1114 * dot3214) - (dot1214 * dot3114)) * denom114);
HXDLIN(  35)										Float ratioC14 = ((((Float)1.0) - ratioB14) - ratioA14);
HXDLIN(  35)										bool _hx_tmp132;
HXDLIN(  35)										bool _hx_tmp133;
HXDLIN(  35)										if ((ratioA14 >= 0)) {
HXLINE(  35)											_hx_tmp133 = (ratioB14 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp133 = false;
            										}
HXDLIN(  35)										if (_hx_tmp133) {
HXLINE(  35)											_hx_tmp132 = (ratioC14 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp132 = false;
            										}
HXDLIN(  35)										if (_hx_tmp132) {
HXLINE(  35)											Float u14 = (((au15 * ratioA14) + (bu15 * ratioB14)) + (au * ratioC14));
HXDLIN(  35)											Float v66 = (((av15 * ratioA14) + (bv14 * ratioB14)) + (cv * ratioC14));
HXDLIN(  35)											int x61 = ::Std_obj::_hx_int(((u14 * win_width) + win_x));
HXDLIN(  35)											int y61 = ::Std_obj::_hx_int(((v66 * win_height) + win_y));
HXDLIN(  35)											::Dynamic this502 = texture->image;
HXDLIN(  35)											int index88;
HXDLIN(  35)											if (texture->useVirtualPos) {
HXLINE(  35)												index88 = ::Std_obj::_hx_int(((((( (Float)(y61) ) - texture->virtualY) * ( (Float)(texture->width) )) + x61) - texture->virtualX));
            											}
            											else {
HXLINE(  35)												index88 = ::Std_obj::_hx_int(( (Float)(((y61 * texture->width) + x61)) ));
            											}
HXDLIN(  35)											int c73 = ::iterMagic::Iimg_obj::get(this502,index88);
HXDLIN(  35)											int col29;
HXDLIN(  35)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)												col29 = ((((((c73 >> 24) & 255) << 24) | ((c73 & 255) << 16)) | (((c73 >> 8) & 255) << 8)) | ((c73 >> 16) & 255));
            											}
            											else {
HXLINE(  35)												col29 = c73;
            											}
HXDLIN(  35)											{
HXLINE(  35)												int c74 = col29;
HXDLIN(  35)												bool _hx_tmp134;
HXDLIN(  35)												if ((((c74 >> 24) & 255) < 254)) {
HXLINE(  35)													_hx_tmp134 = temp->transparent;
            												}
            												else {
HXLINE(  35)													_hx_tmp134 = false;
            												}
HXDLIN(  35)												if (_hx_tmp134) {
HXLINE(  35)													int location29;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														location29 = ::Std_obj::_hx_int(((((( (Float)(py14) ) - temp->virtualY) * ( (Float)(temp->width) )) + px14) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														location29 = ::Std_obj::_hx_int(( (Float)(((py14 * temp->width) + px14)) ));
            													}
HXDLIN(  35)													int this503 = ::iterMagic::Iimg_obj::get(temp->image,location29);
HXDLIN(  35)													int this504;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														this504 = ((((((this503 >> 24) & 255) << 24) | ((this503 & 255) << 16)) | (((this503 >> 8) & 255) << 8)) | ((this503 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														this504 = this503;
            													}
HXDLIN(  35)													Float a132;
HXDLIN(  35)													int this505 = ((this504 >> 24) & 255);
HXDLIN(  35)													if ((this505 == 0)) {
HXLINE(  35)														a132 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a132 = (( (Float)(this505) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r129;
HXDLIN(  35)													int this506 = ((this504 >> 16) & 255);
HXDLIN(  35)													if ((this506 == 0)) {
HXLINE(  35)														r129 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r129 = (( (Float)(this506) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g129;
HXDLIN(  35)													int this507 = ((this504 >> 8) & 255);
HXDLIN(  35)													if ((this507 == 0)) {
HXLINE(  35)														g129 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g129 = (( (Float)(this507) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b135;
HXDLIN(  35)													int this508 = (this504 & 255);
HXDLIN(  35)													if ((this508 == 0)) {
HXLINE(  35)														b135 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b135 = (( (Float)(this508) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a231;
HXDLIN(  35)													int this509 = ((col29 >> 24) & 255);
HXDLIN(  35)													if ((this509 == 0)) {
HXLINE(  35)														a231 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a231 = (( (Float)(this509) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r229;
HXDLIN(  35)													int this510 = ((col29 >> 16) & 255);
HXDLIN(  35)													if ((this510 == 0)) {
HXLINE(  35)														r229 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r229 = (( (Float)(this510) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g229;
HXDLIN(  35)													int this511 = ((col29 >> 8) & 255);
HXDLIN(  35)													if ((this511 == 0)) {
HXLINE(  35)														g229 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g229 = (( (Float)(this511) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b233;
HXDLIN(  35)													int this512 = (col29 & 255);
HXDLIN(  35)													if ((this512 == 0)) {
HXLINE(  35)														b233 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b233 = (( (Float)(this512) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a329 = (a132 * (( (Float)(1) ) - a231));
HXDLIN(  35)													int r49 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r129 * a329) + (r229 * a231))));
HXDLIN(  35)													int g49 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g129 * a329) + (g229 * a231))));
HXDLIN(  35)													int b87 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b135 * a329) + (b233 * a231))));
HXDLIN(  35)													int a70 = ::Std_obj::_hx_int((( (Float)(255) ) * (a329 + a231)));
HXDLIN(  35)													int blended29 = ((((a70 << 24) | (r49 << 16)) | (g49 << 8)) | b87);
HXDLIN(  35)													{
HXLINE(  35)														int _hx_tmp135;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp135 = ((((((blended29 >> 24) & 255) << 24) | ((blended29 & 255) << 16)) | (((blended29 >> 8) & 255) << 8)) | ((blended29 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp135 = blended29;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(temp->image,location29,_hx_tmp135);
            													}
            												}
            												else {
HXLINE(  35)													::Dynamic this513 = temp->image;
HXDLIN(  35)													int index89;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														index89 = ::Std_obj::_hx_int(((((( (Float)(py14) ) - temp->virtualY) * ( (Float)(temp->width) )) + px14) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														index89 = ::Std_obj::_hx_int(( (Float)(((py14 * temp->width) + px14)) ));
            													}
HXDLIN(  35)													int _hx_tmp136;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														_hx_tmp136 = ((((((c74 >> 24) & 255) << 24) | ((c74 & 255) << 16)) | (((c74 >> 8) & 255) << 8)) | ((c74 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														_hx_tmp136 = c74;
            													}
HXDLIN(  35)													::iterMagic::Iimg_obj::set(this513,index89,_hx_tmp136);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						if ((hasHit == false)) {
HXLINE(  35)							 ::pi_xy::algo::HitTri v67 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,leftX,bottomY,rightX,bottomY,leftX,dy16,true);
HXDLIN(  35)							if (hasUndo14) {
HXLINE(  35)								v67->undoImage = undoImage42;
HXDLIN(  35)								v67->undoX = xIter314->start;
HXDLIN(  35)								v67->undoY = yIter314->start;
            							}
            						}
            					}
HXDLIN(  35)					{
HXLINE(  35)						Float au16 = bu;
HXDLIN(  35)						Float av16 = av;
HXDLIN(  35)						Float bu16 = bu;
HXDLIN(  35)						Float bv15 = cv;
HXDLIN(  35)						bool hasUndo15 = false;
HXDLIN(  35)						Float temp16 = au16;
HXLINE( 422)						au16 = bu16;
HXLINE( 423)						bu16 = temp16;
HXLINE( 424)						temp16 = av16;
HXLINE( 425)						av16 = bv15;
HXLINE( 426)						bv15 = temp16;
HXLINE(  35)						Float bcx15 = (rightX - leftX);
HXDLIN(  35)						Float bcy15 = (cy5 - dy16);
HXDLIN(  35)						Float acx15 = (rightX - leftX);
HXDLIN(  35)						Float acy15 = (bottomY - dy16);
HXDLIN(  35)						Float dot1115 = ((bcx15 * bcx15) + (bcy15 * bcy15));
HXDLIN(  35)						Float dot1215 = ((bcx15 * acx15) + (bcy15 * acy15));
HXDLIN(  35)						Float dot2215 = ((acx15 * acx15) + (acy15 * acy15));
HXDLIN(  35)						Float denom115 = (( (Float)(1) ) / ((dot1115 * dot2215) - (dot1215 * dot1215)));
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart xIter315;
HXDLIN(  35)						if ((rightX > rightX)) {
HXLINE(  35)							if ((rightX > leftX)) {
HXLINE(  35)								int min51;
HXDLIN(  35)								if ((rightX > leftX)) {
HXLINE(  35)									min51 = ::Math_obj::floor(leftX);
            								}
            								else {
HXLINE(  35)									min51 = ::Math_obj::floor(rightX);
            								}
HXDLIN(  35)								int ii_min111 = min51;
HXDLIN(  35)								int ii_max111 = ::Math_obj::ceil(rightX);
HXDLIN(  35)								xIter315 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min111,ii_max111);
            							}
            							else {
HXLINE(  35)								int ii_min112 = ::Math_obj::floor(rightX);
HXDLIN(  35)								int ii_max112 = ::Math_obj::ceil(leftX);
HXDLIN(  35)								xIter315 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min112,ii_max112);
            							}
            						}
            						else {
HXLINE(  35)							if ((rightX > leftX)) {
HXLINE(  35)								int min52;
HXDLIN(  35)								if ((rightX > leftX)) {
HXLINE(  35)									min52 = ::Math_obj::floor(leftX);
            								}
            								else {
HXLINE(  35)									min52 = ::Math_obj::ceil(rightX);
            								}
HXDLIN(  35)								int ii_min113 = min52;
HXDLIN(  35)								int ii_max113 = ::Math_obj::ceil(rightX);
HXDLIN(  35)								xIter315 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min113,ii_max113);
            							}
            							else {
HXLINE(  35)								int ii_min114 = ::Math_obj::floor(rightX);
HXDLIN(  35)								int ii_max114 = ::Math_obj::ceil(leftX);
HXDLIN(  35)								xIter315 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min114,ii_max114);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart yIter315;
HXDLIN(  35)						if ((bottomY > cy5)) {
HXLINE(  35)							if ((bottomY > dy16)) {
HXLINE(  35)								int min53;
HXDLIN(  35)								if ((cy5 > dy16)) {
HXLINE(  35)									min53 = ::Math_obj::floor(dy16);
            								}
            								else {
HXLINE(  35)									min53 = ::Math_obj::floor(cy5);
            								}
HXDLIN(  35)								int ii_min115 = min53;
HXDLIN(  35)								int ii_max115 = ::Math_obj::ceil(bottomY);
HXDLIN(  35)								yIter315 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min115,ii_max115);
            							}
            							else {
HXLINE(  35)								int ii_min116 = ::Math_obj::floor(cy5);
HXDLIN(  35)								int ii_max116 = ::Math_obj::ceil(dy16);
HXDLIN(  35)								yIter315 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min116,ii_max116);
            							}
            						}
            						else {
HXLINE(  35)							if ((cy5 > dy16)) {
HXLINE(  35)								int min54;
HXDLIN(  35)								if ((bottomY > dy16)) {
HXLINE(  35)									min54 = ::Math_obj::floor(dy16);
            								}
            								else {
HXLINE(  35)									min54 = ::Math_obj::ceil(bottomY);
            								}
HXDLIN(  35)								int ii_min117 = min54;
HXDLIN(  35)								int ii_max117 = ::Math_obj::ceil(cy5);
HXDLIN(  35)								yIter315 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min117,ii_max117);
            							}
            							else {
HXLINE(  35)								int ii_min118 = ::Math_obj::floor(bottomY);
HXDLIN(  35)								int ii_max118 = ::Math_obj::ceil(dy16);
HXDLIN(  35)								yIter315 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min118,ii_max118);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::ImageStruct undoImage45 = null();
HXDLIN(  35)						if (hasUndo15) {
HXLINE(  35)							int width16 = ((xIter315->max - xIter315->start) + 1);
HXDLIN(  35)							int height16 = ((yIter315->max - yIter315->start) + 1);
HXDLIN(  35)							 ::Dynamic imageType16 = null();
HXDLIN(  35)							 ::pi_xy::ImageStruct this514 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  35)							if (::hx::IsNull( imageType16 )) {
HXLINE(  54)								imageType16 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE(  35)							::Dynamic undoImage46;
HXDLIN(  35)							switch((int)(( (int)(imageType16) ))){
            								case (int)0: {
HXLINE(  35)									 ::iterMagic::BytesImg byt16 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::BytesImg b88 = byt16;
HXDLIN(  35)									{
HXLINE(  35)										b88->width = width16;
HXDLIN(  35)										b88->height = height16;
HXDLIN(  35)										b88->length = ::Std_obj::_hx_int(( (Float)((width16 * height16)) ));
HXDLIN(  35)										b88->data = ::haxe::io::Bytes_obj::alloc((b88->length * 4));
HXDLIN(  35)										{
HXLINE(  35)											int len32 = b88->length;
HXDLIN(  35)											int w16 = 0;
HXDLIN(  35)											{
HXLINE(  35)												int _g316 = 0;
HXDLIN(  35)												int _g317 = b88->height;
HXDLIN(  35)												while((_g316 < _g317)){
HXLINE(  35)													_g316 = (_g316 + 1);
HXDLIN(  35)													int y62 = (_g316 - 1);
HXDLIN(  35)													{
HXLINE(  35)														int _g318 = 0;
HXDLIN(  35)														int _g319 = b88->width;
HXDLIN(  35)														while((_g318 < _g319)){
HXLINE(  35)															_g318 = (_g318 + 1);
HXDLIN(  35)															int x62 = (_g318 - 1);
HXDLIN(  35)															{
HXLINE(  35)																w16 = (w16 + 1);
HXDLIN(  35)																b88->data->b[(w16 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w16 = (w16 + 1);
HXDLIN(  35)																b88->data->b[(w16 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w16 = (w16 + 1);
HXDLIN(  35)																b88->data->b[(w16 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w16 = (w16 + 1);
HXDLIN(  35)																b88->data->b[(w16 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage46 = b88;
            								}
            								break;
            								case (int)1: {
HXLINE(  35)									 ::iterMagic::ArrIntImg arrI16 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::ArrIntImg a71 = arrI16;
HXDLIN(  35)									{
HXLINE(  35)										a71->width = width16;
HXDLIN(  35)										a71->height = height16;
HXDLIN(  35)										a71->data = ::Array_obj< int >::__new(0);
HXDLIN(  35)										a71->length = ::Std_obj::_hx_int(( (Float)((width16 * height16)) ));
HXDLIN(  35)										{
HXLINE(  35)											int _g320 = 0;
HXDLIN(  35)											int _g321 = a71->length;
HXDLIN(  35)											while((_g320 < _g321)){
HXLINE(  35)												_g320 = (_g320 + 1);
HXDLIN(  35)												int i96 = (_g320 - 1);
HXDLIN(  35)												a71->data[i96] = 0;
            											}
            										}
            									}
HXDLIN(  35)									undoImage46 = a71;
            								}
            								break;
            								case (int)2: {
HXLINE(  35)									 ::iterMagic::U32ArrImg u32a16 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::U32ArrImg b89 = u32a16;
HXDLIN(  35)									{
HXLINE(  35)										b89->width = width16;
HXDLIN(  35)										b89->height = height16;
HXDLIN(  35)										b89->length = ::Std_obj::_hx_int(( (Float)((width16 * height16)) ));
HXDLIN(  35)										int size16 = (b89->length * 4);
HXDLIN(  35)										b89->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size16),0,size16);
HXDLIN(  35)										{
HXLINE(  35)											int _g322 = 0;
HXDLIN(  35)											int _g323 = b89->length;
HXDLIN(  35)											while((_g322 < _g323)){
HXLINE(  35)												_g322 = (_g322 + 1);
HXDLIN(  35)												int i97 = (_g322 - 1);
HXDLIN(  35)												{
HXLINE(  35)													 ::haxe::io::ArrayBufferViewImpl this515 = b89->data;
HXDLIN(  35)													bool undoImage47;
HXDLIN(  35)													if ((i97 >= 0)) {
HXLINE(  35)														undoImage47 = (i97 < (this515->byteLength >> 2));
            													}
            													else {
HXLINE(  35)														undoImage47 = false;
            													}
HXDLIN(  35)													if (undoImage47) {
HXLINE(  35)														 ::haxe::io::Bytes _this16 = this515->bytes;
HXDLIN(  35)														int pos16 = ((i97 << 2) + this515->byteOffset);
HXDLIN(  35)														_this16->b[pos16] = ( (unsigned char)(0) );
HXDLIN(  35)														_this16->b[(pos16 + 1)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this16->b[(pos16 + 2)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this16->b[(pos16 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage46 = b89;
            								}
            								break;
            								case (int)3: {
HXLINE(  35)									 ::iterMagic::VecIntImg vec16 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::VecIntImg v68 = vec16;
HXDLIN(  35)									{
HXLINE(  35)										v68->width = width16;
HXDLIN(  35)										v68->height = height16;
HXDLIN(  35)										v68->length = ::Std_obj::_hx_int(( (Float)((width16 * height16)) ));
HXDLIN(  35)										v68->data = ::Array_obj< int >::__new(v68->length);
HXDLIN(  35)										{
HXLINE(  35)											int _g324 = 0;
HXDLIN(  35)											int _g325 = v68->length;
HXDLIN(  35)											while((_g324 < _g325)){
HXLINE(  35)												_g324 = (_g324 + 1);
HXDLIN(  35)												int i98 = (_g324 - 1);
HXDLIN(  35)												v68->data->__unsafe_set(i98,0);
            											}
            										}
            									}
HXDLIN(  35)									undoImage46 = v68;
            								}
            								break;
            								case (int)4: {
HXLINE(  35)									 ::iterMagic::StackIntImg sInt16 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::StackIntImg b90 = sInt16;
HXDLIN(  35)									{
HXLINE(  35)										b90->width = width16;
HXDLIN(  35)										b90->height = height16;
HXDLIN(  35)										b90->length = ::Std_obj::_hx_int(( (Float)((width16 * height16)) ));
HXDLIN(  35)										b90->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  35)										{
HXLINE(  35)											int len33 = b90->length;
HXDLIN(  35)											 ::haxe::ds::GenericStack_Int d16 = b90->data;
HXDLIN(  35)											if (::hx::IsNull( d16->head )) {
HXLINE(  35)												int _g326 = 0;
HXDLIN(  35)												int _g327 = len33;
HXDLIN(  35)												while((_g326 < _g327)){
HXLINE(  35)													_g326 = (_g326 + 1);
HXDLIN(  35)													int i99 = (_g326 - 1);
HXDLIN(  35)													d16->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d16->head);
            												}
            											}
            											else {
HXLINE(  35)												int _g328 = 0;
HXDLIN(  35)												int _g329 = len33;
HXDLIN(  35)												while((_g328 < _g329)){
HXLINE(  35)													_g328 = (_g328 + 1);
HXDLIN(  35)													int i100 = (_g328 - 1);
HXDLIN(  35)													{
HXLINE(  35)														 ::haxe::ds::GenericCell_Int l16 = b90->data->head;
HXDLIN(  35)														 ::haxe::ds::GenericCell_Int prev16 = null();
HXDLIN(  35)														{
HXLINE(  35)															int _g330 = 0;
HXDLIN(  35)															int _g331 = i100;
HXDLIN(  35)															while((_g330 < _g331)){
HXLINE(  35)																_g330 = (_g330 + 1);
HXDLIN(  35)																int i101 = (_g330 - 1);
HXLINE( 345)																prev16 = l16;
HXLINE( 346)																l16 = l16->next;
            															}
            														}
HXLINE(  35)														if (::hx::IsNull( prev16 )) {
HXLINE(  35)															b90->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l16->next);
HXDLIN(  35)															l16 = null();
            														}
            														else {
HXLINE(  35)															prev16->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l16->next);
HXDLIN(  35)															l16 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage46 = b90;
            								}
            								break;
            							}
HXDLIN(  35)							this514->image = undoImage46;
HXDLIN(  35)							this514->width = width16;
HXDLIN(  35)							this514->height = height16;
HXDLIN(  35)							this514->imageType = ( (int)(imageType16) );
HXDLIN(  35)							undoImage45 = this514;
HXDLIN(  35)							{
HXLINE(  35)								int rectLeft15 = xIter315->start;
HXDLIN(  35)								int rectTop15 = yIter315->start;
HXDLIN(  35)								int rectRight15 = xIter315->max;
HXDLIN(  35)								bool forceClear15 = false;
HXDLIN(  35)								{
HXLINE(  35)									int _g332 = rectTop15;
HXDLIN(  35)									int _g333 = yIter315->max;
HXDLIN(  35)									while((_g332 < _g333)){
HXLINE(  35)										_g332 = (_g332 + 1);
HXDLIN(  35)										int dy18 = (_g332 - 1);
HXDLIN(  35)										{
HXLINE(  35)											int _g334 = rectLeft15;
HXDLIN(  35)											int _g335 = rectRight15;
HXDLIN(  35)											while((_g334 < _g335)){
HXLINE(  35)												_g334 = (_g334 + 1);
HXDLIN(  35)												int dx16 = (_g334 - 1);
HXDLIN(  35)												::Dynamic this516 = temp->image;
HXDLIN(  35)												int index90;
HXDLIN(  35)												if (temp->useVirtualPos) {
HXLINE(  35)													index90 = ::Std_obj::_hx_int(((((( (Float)(dy18) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx16) - temp->virtualX));
            												}
            												else {
HXLINE(  35)													index90 = ::Std_obj::_hx_int(( (Float)(((dy18 * temp->width) + dx16)) ));
            												}
HXDLIN(  35)												int c75 = ::iterMagic::Iimg_obj::get(this516,index90);
HXDLIN(  35)												int col30;
HXDLIN(  35)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)													col30 = ((((((c75 >> 24) & 255) << 24) | ((c75 & 255) << 16)) | (((c75 >> 8) & 255) << 8)) | ((c75 >> 16) & 255));
            												}
            												else {
HXLINE(  35)													col30 = c75;
            												}
HXDLIN(  35)												bool _hx_tmp137;
HXDLIN(  35)												if (temp->useMask) {
HXLINE(  35)													_hx_tmp137 = ::hx::IsNotNull( temp->mask );
            												}
            												else {
HXLINE(  35)													_hx_tmp137 = false;
            												}
HXDLIN(  35)												if (_hx_tmp137) {
HXLINE(  35)													 ::pi_xy::ImageStruct this517 = temp->mask;
HXDLIN(  35)													::Dynamic this518 = this517->image;
HXDLIN(  35)													int index91;
HXDLIN(  35)													if (this517->useVirtualPos) {
HXLINE(  35)														index91 = ::Std_obj::_hx_int(((((( (Float)(dy18) ) - this517->virtualY) * ( (Float)(this517->width) )) + dx16) - this517->virtualX));
            													}
            													else {
HXLINE(  35)														index91 = ::Std_obj::_hx_int(( (Float)(((dy18 * this517->width) + dx16)) ));
            													}
HXDLIN(  35)													int c76 = ::iterMagic::Iimg_obj::get(this518,index91);
HXDLIN(  35)													int v69;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														v69 = ((((((c76 >> 24) & 255) << 24) | ((c76 & 255) << 16)) | (((c76 >> 8) & 255) << 8)) | ((c76 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														v69 = c76;
            													}
HXDLIN(  35)													int maskPixel15 = v69;
HXDLIN(  35)													int this519 = col30;
HXDLIN(  35)													if ((maskPixel15 == 0)) {
HXLINE(  35)														col30 = this519;
            													}
            													else {
HXLINE(  35)														Float m015;
HXDLIN(  35)														int this520 = ((maskPixel15 >> 24) & 255);
HXDLIN(  35)														if ((this520 == 0)) {
HXLINE(  35)															m015 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m015 = (( (Float)(this520) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m115;
HXDLIN(  35)														int this521 = ((maskPixel15 >> 16) & 255);
HXDLIN(  35)														if ((this521 == 0)) {
HXLINE(  35)															m115 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m115 = (( (Float)(this521) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m215;
HXDLIN(  35)														int this522 = ((maskPixel15 >> 8) & 255);
HXDLIN(  35)														if ((this522 == 0)) {
HXLINE(  35)															m215 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m215 = (( (Float)(this522) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m315;
HXDLIN(  35)														int this523 = (maskPixel15 & 255);
HXDLIN(  35)														if ((this523 == 0)) {
HXLINE(  35)															m315 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m315 = (( (Float)(this523) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														int ch015 = ::Std_obj::_hx_int(((((Float)1.) - m015) * ( (Float)(((this519 >> 24) & 255)) )));
HXDLIN(  35)														int ch115 = ::Std_obj::_hx_int(((((Float)1.) - m115) * ( (Float)(((this519 >> 16) & 255)) )));
HXDLIN(  35)														int ch215 = ::Std_obj::_hx_int(((((Float)1.) - m215) * ( (Float)(((this519 >> 8) & 255)) )));
HXDLIN(  35)														int ch315 = ::Std_obj::_hx_int(((((Float)1.) - m315) * ( (Float)((this519 & 255)) )));
HXDLIN(  35)														col30 = ((((::Math_obj::round((( (Float)(ch015) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch115) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch215) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch315) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  35)												if ((col30 != 0)) {
HXLINE(  35)													int x63 = (dx16 - rectLeft15);
HXDLIN(  35)													int y63 = (dy18 - rectTop15);
HXDLIN(  35)													int c77 = col30;
HXDLIN(  35)													bool _hx_tmp138;
HXDLIN(  35)													if ((((c77 >> 24) & 255) < 254)) {
HXLINE(  35)														_hx_tmp138 = undoImage45->transparent;
            													}
            													else {
HXLINE(  35)														_hx_tmp138 = false;
            													}
HXDLIN(  35)													if (_hx_tmp138) {
HXLINE(  35)														int location30;
HXDLIN(  35)														if (undoImage45->useVirtualPos) {
HXLINE(  35)															location30 = ::Std_obj::_hx_int(((((( (Float)(y63) ) - undoImage45->virtualY) * ( (Float)(undoImage45->width) )) + x63) - undoImage45->virtualX));
            														}
            														else {
HXLINE(  35)															location30 = ::Std_obj::_hx_int(( (Float)(((y63 * undoImage45->width) + x63)) ));
            														}
HXDLIN(  35)														int this524 = ::iterMagic::Iimg_obj::get(undoImage45->image,location30);
HXDLIN(  35)														int this525;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															this525 = ((((((this524 >> 24) & 255) << 24) | ((this524 & 255) << 16)) | (((this524 >> 8) & 255) << 8)) | ((this524 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															this525 = this524;
            														}
HXDLIN(  35)														Float a133;
HXDLIN(  35)														int this526 = ((this525 >> 24) & 255);
HXDLIN(  35)														if ((this526 == 0)) {
HXLINE(  35)															a133 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a133 = (( (Float)(this526) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r130;
HXDLIN(  35)														int this527 = ((this525 >> 16) & 255);
HXDLIN(  35)														if ((this527 == 0)) {
HXLINE(  35)															r130 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r130 = (( (Float)(this527) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g130;
HXDLIN(  35)														int this528 = ((this525 >> 8) & 255);
HXDLIN(  35)														if ((this528 == 0)) {
HXLINE(  35)															g130 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g130 = (( (Float)(this528) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b136;
HXDLIN(  35)														int this529 = (this525 & 255);
HXDLIN(  35)														if ((this529 == 0)) {
HXLINE(  35)															b136 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b136 = (( (Float)(this529) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a232;
HXDLIN(  35)														int this530 = ((col30 >> 24) & 255);
HXDLIN(  35)														if ((this530 == 0)) {
HXLINE(  35)															a232 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a232 = (( (Float)(this530) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r230;
HXDLIN(  35)														int this531 = ((col30 >> 16) & 255);
HXDLIN(  35)														if ((this531 == 0)) {
HXLINE(  35)															r230 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r230 = (( (Float)(this531) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g230;
HXDLIN(  35)														int this532 = ((col30 >> 8) & 255);
HXDLIN(  35)														if ((this532 == 0)) {
HXLINE(  35)															g230 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g230 = (( (Float)(this532) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b234;
HXDLIN(  35)														int this533 = (col30 & 255);
HXDLIN(  35)														if ((this533 == 0)) {
HXLINE(  35)															b234 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b234 = (( (Float)(this533) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a330 = (a133 * (( (Float)(1) ) - a232));
HXDLIN(  35)														int r50 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r130 * a330) + (r230 * a232))));
HXDLIN(  35)														int g50 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g130 * a330) + (g230 * a232))));
HXDLIN(  35)														int b91 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b136 * a330) + (b234 * a232))));
HXDLIN(  35)														int a72 = ::Std_obj::_hx_int((( (Float)(255) ) * (a330 + a232)));
HXDLIN(  35)														int blended30 = ((((a72 << 24) | (r50 << 16)) | (g50 << 8)) | b91);
HXDLIN(  35)														{
HXLINE(  35)															int _hx_tmp139;
HXDLIN(  35)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)																_hx_tmp139 = ((((((blended30 >> 24) & 255) << 24) | ((blended30 & 255) << 16)) | (((blended30 >> 8) & 255) << 8)) | ((blended30 >> 16) & 255));
            															}
            															else {
HXLINE(  35)																_hx_tmp139 = blended30;
            															}
HXDLIN(  35)															::iterMagic::Iimg_obj::set(undoImage45->image,location30,_hx_tmp139);
            														}
            													}
            													else {
HXLINE(  35)														::Dynamic this534 = undoImage45->image;
HXDLIN(  35)														int index92;
HXDLIN(  35)														if (undoImage45->useVirtualPos) {
HXLINE(  35)															index92 = ::Std_obj::_hx_int(((((( (Float)(y63) ) - undoImage45->virtualY) * ( (Float)(undoImage45->width) )) + x63) - undoImage45->virtualX));
            														}
            														else {
HXLINE(  35)															index92 = ::Std_obj::_hx_int(( (Float)(((y63 * undoImage45->width) + x63)) ));
            														}
HXDLIN(  35)														int _hx_tmp140;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp140 = ((((((c77 >> 24) & 255) << 24) | ((c77 & 255) << 16)) | (((c77 >> 8) & 255) << 8)) | ((c77 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp140 = c77;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this534,index92,_hx_tmp140);
            													}
            												}
            												else {
HXLINE(  35)													if (forceClear15) {
HXLINE(  35)														::Dynamic this535 = undoImage45->image;
HXDLIN(  35)														int x64 = (dx16 - rectLeft15);
HXDLIN(  35)														int y64 = (dy18 - rectTop15);
HXDLIN(  35)														int index93;
HXDLIN(  35)														if (undoImage45->useVirtualPos) {
HXLINE(  35)															index93 = ::Std_obj::_hx_int(((((( (Float)(y64) ) - undoImage45->virtualY) * ( (Float)(undoImage45->width) )) + x64) - undoImage45->virtualX));
            														}
            														else {
HXLINE(  35)															index93 = ::Std_obj::_hx_int(( (Float)(((y64 * undoImage45->width) + x64)) ));
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this535,index93,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						{
HXLINE(  35)							int _g_min30 = xIter315->start;
HXDLIN(  35)							int _g_max30 = xIter315->max;
HXDLIN(  35)							while((_g_min30 < _g_max30)){
HXLINE(  35)								_g_min30 = (_g_min30 + 1);
HXDLIN(  35)								int px15 = (_g_min30 - 1);
HXDLIN(  35)								Float pcx15 = (( (Float)(px15) ) - leftX);
HXDLIN(  35)								{
HXLINE(  35)									int _g_min31 = yIter315->start;
HXDLIN(  35)									int _g_max31 = yIter315->max;
HXDLIN(  35)									while((_g_min31 < _g_max31)){
HXLINE(  35)										_g_min31 = (_g_min31 + 1);
HXDLIN(  35)										int py15 = (_g_min31 - 1);
HXDLIN(  35)										Float pcy15 = (( (Float)(py15) ) - dy16);
HXDLIN(  35)										Float dot3115 = ((pcx15 * bcx15) + (pcy15 * bcy15));
HXDLIN(  35)										Float dot3215 = ((pcx15 * acx15) + (pcy15 * acy15));
HXDLIN(  35)										Float ratioA15 = (((dot2215 * dot3115) - (dot1215 * dot3215)) * denom115);
HXDLIN(  35)										Float ratioB15 = (((dot1115 * dot3215) - (dot1215 * dot3115)) * denom115);
HXDLIN(  35)										Float ratioC15 = ((((Float)1.0) - ratioB15) - ratioA15);
HXDLIN(  35)										bool _hx_tmp141;
HXDLIN(  35)										bool _hx_tmp142;
HXDLIN(  35)										if ((ratioA15 >= 0)) {
HXLINE(  35)											_hx_tmp142 = (ratioB15 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp142 = false;
            										}
HXDLIN(  35)										if (_hx_tmp142) {
HXLINE(  35)											_hx_tmp141 = (ratioC15 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp141 = false;
            										}
HXDLIN(  35)										if (_hx_tmp141) {
HXLINE(  35)											Float u15 = (((au16 * ratioA15) + (bu16 * ratioB15)) + (au * ratioC15));
HXDLIN(  35)											Float v70 = (((av16 * ratioA15) + (bv15 * ratioB15)) + (cv * ratioC15));
HXDLIN(  35)											int x65 = ::Std_obj::_hx_int(((u15 * win_width) + win_x));
HXDLIN(  35)											int y65 = ::Std_obj::_hx_int(((v70 * win_height) + win_y));
HXDLIN(  35)											::Dynamic this536 = texture->image;
HXDLIN(  35)											int index94;
HXDLIN(  35)											if (texture->useVirtualPos) {
HXLINE(  35)												index94 = ::Std_obj::_hx_int(((((( (Float)(y65) ) - texture->virtualY) * ( (Float)(texture->width) )) + x65) - texture->virtualX));
            											}
            											else {
HXLINE(  35)												index94 = ::Std_obj::_hx_int(( (Float)(((y65 * texture->width) + x65)) ));
            											}
HXDLIN(  35)											int c78 = ::iterMagic::Iimg_obj::get(this536,index94);
HXDLIN(  35)											int col31;
HXDLIN(  35)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)												col31 = ((((((c78 >> 24) & 255) << 24) | ((c78 & 255) << 16)) | (((c78 >> 8) & 255) << 8)) | ((c78 >> 16) & 255));
            											}
            											else {
HXLINE(  35)												col31 = c78;
            											}
HXDLIN(  35)											{
HXLINE(  35)												int c79 = col31;
HXDLIN(  35)												bool _hx_tmp143;
HXDLIN(  35)												if ((((c79 >> 24) & 255) < 254)) {
HXLINE(  35)													_hx_tmp143 = temp->transparent;
            												}
            												else {
HXLINE(  35)													_hx_tmp143 = false;
            												}
HXDLIN(  35)												if (_hx_tmp143) {
HXLINE(  35)													int location31;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														location31 = ::Std_obj::_hx_int(((((( (Float)(py15) ) - temp->virtualY) * ( (Float)(temp->width) )) + px15) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														location31 = ::Std_obj::_hx_int(( (Float)(((py15 * temp->width) + px15)) ));
            													}
HXDLIN(  35)													int this537 = ::iterMagic::Iimg_obj::get(temp->image,location31);
HXDLIN(  35)													int this538;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														this538 = ((((((this537 >> 24) & 255) << 24) | ((this537 & 255) << 16)) | (((this537 >> 8) & 255) << 8)) | ((this537 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														this538 = this537;
            													}
HXDLIN(  35)													Float a134;
HXDLIN(  35)													int this539 = ((this538 >> 24) & 255);
HXDLIN(  35)													if ((this539 == 0)) {
HXLINE(  35)														a134 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a134 = (( (Float)(this539) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r131;
HXDLIN(  35)													int this540 = ((this538 >> 16) & 255);
HXDLIN(  35)													if ((this540 == 0)) {
HXLINE(  35)														r131 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r131 = (( (Float)(this540) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g131;
HXDLIN(  35)													int this541 = ((this538 >> 8) & 255);
HXDLIN(  35)													if ((this541 == 0)) {
HXLINE(  35)														g131 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g131 = (( (Float)(this541) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b137;
HXDLIN(  35)													int this542 = (this538 & 255);
HXDLIN(  35)													if ((this542 == 0)) {
HXLINE(  35)														b137 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b137 = (( (Float)(this542) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a233;
HXDLIN(  35)													int this543 = ((col31 >> 24) & 255);
HXDLIN(  35)													if ((this543 == 0)) {
HXLINE(  35)														a233 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a233 = (( (Float)(this543) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r231;
HXDLIN(  35)													int this544 = ((col31 >> 16) & 255);
HXDLIN(  35)													if ((this544 == 0)) {
HXLINE(  35)														r231 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r231 = (( (Float)(this544) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g231;
HXDLIN(  35)													int this545 = ((col31 >> 8) & 255);
HXDLIN(  35)													if ((this545 == 0)) {
HXLINE(  35)														g231 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g231 = (( (Float)(this545) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b235;
HXDLIN(  35)													int this546 = (col31 & 255);
HXDLIN(  35)													if ((this546 == 0)) {
HXLINE(  35)														b235 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b235 = (( (Float)(this546) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a331 = (a134 * (( (Float)(1) ) - a233));
HXDLIN(  35)													int r51 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r131 * a331) + (r231 * a233))));
HXDLIN(  35)													int g51 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g131 * a331) + (g231 * a233))));
HXDLIN(  35)													int b92 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b137 * a331) + (b235 * a233))));
HXDLIN(  35)													int a73 = ::Std_obj::_hx_int((( (Float)(255) ) * (a331 + a233)));
HXDLIN(  35)													int blended31 = ((((a73 << 24) | (r51 << 16)) | (g51 << 8)) | b92);
HXDLIN(  35)													{
HXLINE(  35)														int _hx_tmp144;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp144 = ((((((blended31 >> 24) & 255) << 24) | ((blended31 & 255) << 16)) | (((blended31 >> 8) & 255) << 8)) | ((blended31 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp144 = blended31;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(temp->image,location31,_hx_tmp144);
            													}
            												}
            												else {
HXLINE(  35)													::Dynamic this547 = temp->image;
HXDLIN(  35)													int index95;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														index95 = ::Std_obj::_hx_int(((((( (Float)(py15) ) - temp->virtualY) * ( (Float)(temp->width) )) + px15) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														index95 = ::Std_obj::_hx_int(( (Float)(((py15 * temp->width) + px15)) ));
            													}
HXDLIN(  35)													int _hx_tmp145;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														_hx_tmp145 = ((((((c79 >> 24) & 255) << 24) | ((c79 & 255) << 16)) | (((c79 >> 8) & 255) << 8)) | ((c79 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														_hx_tmp145 = c79;
            													}
HXDLIN(  35)													::iterMagic::Iimg_obj::set(this547,index95,_hx_tmp145);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						if ((hasHit == false)) {
HXLINE(  35)							 ::pi_xy::algo::HitTri v71 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,rightX,bottomY,rightX,cy5,leftX,dy16,true);
HXDLIN(  35)							if (hasUndo15) {
HXLINE(  35)								v71->undoImage = undoImage45;
HXDLIN(  35)								v71->undoX = xIter315->start;
HXDLIN(  35)								v71->undoY = yIter315->start;
            							}
            						}
            					}
HXDLIN(  35)					if ((hasHit == true)) {
HXLINE(  35)						 ::pi_xy::algo::HitQuad v72 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,leftX,bottomY,rightX,bottomY,rightX,cy5,leftX,dy16,true);
            					}
            				}
HXLINE( 296)				au = bu;
HXLINE( 297)				bu = ((Float)1.);
HXLINE(  35)				{
HXLINE(  35)					Float bx3 = widNew;
HXDLIN(  35)					Float cx3 = widNew;
HXDLIN(  35)					Float cy6 = hiNew;
HXDLIN(  35)					Float dy19 = hiNew;
HXDLIN(  35)					{
HXLINE(  35)						Float au17 = au;
HXDLIN(  35)						Float av17 = av;
HXDLIN(  35)						Float bu17 = bu;
HXDLIN(  35)						Float bv16 = av;
HXDLIN(  35)						bool hasUndo16 = false;
HXDLIN(  35)						Float temp17 = au17;
HXLINE( 422)						au17 = bu17;
HXLINE( 423)						bu17 = temp17;
HXLINE( 424)						temp17 = av17;
HXLINE( 425)						av17 = bv16;
HXLINE( 426)						bv16 = temp17;
HXLINE(  35)						Float bcx16 = (bx3 - rightX);
HXDLIN(  35)						Float bcy16 = (bottomY - dy19);
HXDLIN(  35)						Float acx16 = (rightX - rightX);
HXDLIN(  35)						Float acy16 = (bottomY - dy19);
HXDLIN(  35)						Float dot1116 = ((bcx16 * bcx16) + (bcy16 * bcy16));
HXDLIN(  35)						Float dot1216 = ((bcx16 * acx16) + (bcy16 * acy16));
HXDLIN(  35)						Float dot2216 = ((acx16 * acx16) + (acy16 * acy16));
HXDLIN(  35)						Float denom116 = (( (Float)(1) ) / ((dot1116 * dot2216) - (dot1216 * dot1216)));
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart xIter316;
HXDLIN(  35)						if ((rightX > bx3)) {
HXLINE(  35)							if ((rightX > rightX)) {
HXLINE(  35)								int min55;
HXDLIN(  35)								if ((bx3 > rightX)) {
HXLINE(  35)									min55 = ::Math_obj::floor(rightX);
            								}
            								else {
HXLINE(  35)									min55 = ::Math_obj::floor(bx3);
            								}
HXDLIN(  35)								int ii_min119 = min55;
HXDLIN(  35)								int ii_max119 = ::Math_obj::ceil(rightX);
HXDLIN(  35)								xIter316 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min119,ii_max119);
            							}
            							else {
HXLINE(  35)								int ii_min120 = ::Math_obj::floor(bx3);
HXDLIN(  35)								int ii_max120 = ::Math_obj::ceil(rightX);
HXDLIN(  35)								xIter316 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min120,ii_max120);
            							}
            						}
            						else {
HXLINE(  35)							if ((bx3 > rightX)) {
HXLINE(  35)								int min56;
HXDLIN(  35)								if ((rightX > rightX)) {
HXLINE(  35)									min56 = ::Math_obj::floor(rightX);
            								}
            								else {
HXLINE(  35)									min56 = ::Math_obj::ceil(rightX);
            								}
HXDLIN(  35)								int ii_min121 = min56;
HXDLIN(  35)								int ii_max121 = ::Math_obj::ceil(bx3);
HXDLIN(  35)								xIter316 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min121,ii_max121);
            							}
            							else {
HXLINE(  35)								int ii_min122 = ::Math_obj::floor(rightX);
HXDLIN(  35)								int ii_max122 = ::Math_obj::ceil(rightX);
HXDLIN(  35)								xIter316 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min122,ii_max122);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart yIter316;
HXDLIN(  35)						if ((bottomY > bottomY)) {
HXLINE(  35)							if ((bottomY > dy19)) {
HXLINE(  35)								int min57;
HXDLIN(  35)								if ((bottomY > dy19)) {
HXLINE(  35)									min57 = ::Math_obj::floor(dy19);
            								}
            								else {
HXLINE(  35)									min57 = ::Math_obj::floor(bottomY);
            								}
HXDLIN(  35)								int ii_min123 = min57;
HXDLIN(  35)								int ii_max123 = ::Math_obj::ceil(bottomY);
HXDLIN(  35)								yIter316 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min123,ii_max123);
            							}
            							else {
HXLINE(  35)								int ii_min124 = ::Math_obj::floor(bottomY);
HXDLIN(  35)								int ii_max124 = ::Math_obj::ceil(dy19);
HXDLIN(  35)								yIter316 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min124,ii_max124);
            							}
            						}
            						else {
HXLINE(  35)							if ((bottomY > dy19)) {
HXLINE(  35)								int min58;
HXDLIN(  35)								if ((bottomY > dy19)) {
HXLINE(  35)									min58 = ::Math_obj::floor(dy19);
            								}
            								else {
HXLINE(  35)									min58 = ::Math_obj::ceil(bottomY);
            								}
HXDLIN(  35)								int ii_min125 = min58;
HXDLIN(  35)								int ii_max125 = ::Math_obj::ceil(bottomY);
HXDLIN(  35)								yIter316 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min125,ii_max125);
            							}
            							else {
HXLINE(  35)								int ii_min126 = ::Math_obj::floor(bottomY);
HXDLIN(  35)								int ii_max126 = ::Math_obj::ceil(dy19);
HXDLIN(  35)								yIter316 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min126,ii_max126);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::ImageStruct undoImage48 = null();
HXDLIN(  35)						if (hasUndo16) {
HXLINE(  35)							int width17 = ((xIter316->max - xIter316->start) + 1);
HXDLIN(  35)							int height17 = ((yIter316->max - yIter316->start) + 1);
HXDLIN(  35)							 ::Dynamic imageType17 = null();
HXDLIN(  35)							 ::pi_xy::ImageStruct this548 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  35)							if (::hx::IsNull( imageType17 )) {
HXLINE(  54)								imageType17 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE(  35)							::Dynamic undoImage49;
HXDLIN(  35)							switch((int)(( (int)(imageType17) ))){
            								case (int)0: {
HXLINE(  35)									 ::iterMagic::BytesImg byt17 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::BytesImg b93 = byt17;
HXDLIN(  35)									{
HXLINE(  35)										b93->width = width17;
HXDLIN(  35)										b93->height = height17;
HXDLIN(  35)										b93->length = ::Std_obj::_hx_int(( (Float)((width17 * height17)) ));
HXDLIN(  35)										b93->data = ::haxe::io::Bytes_obj::alloc((b93->length * 4));
HXDLIN(  35)										{
HXLINE(  35)											int len34 = b93->length;
HXDLIN(  35)											int w17 = 0;
HXDLIN(  35)											{
HXLINE(  35)												int _g336 = 0;
HXDLIN(  35)												int _g337 = b93->height;
HXDLIN(  35)												while((_g336 < _g337)){
HXLINE(  35)													_g336 = (_g336 + 1);
HXDLIN(  35)													int y66 = (_g336 - 1);
HXDLIN(  35)													{
HXLINE(  35)														int _g338 = 0;
HXDLIN(  35)														int _g339 = b93->width;
HXDLIN(  35)														while((_g338 < _g339)){
HXLINE(  35)															_g338 = (_g338 + 1);
HXDLIN(  35)															int x66 = (_g338 - 1);
HXDLIN(  35)															{
HXLINE(  35)																w17 = (w17 + 1);
HXDLIN(  35)																b93->data->b[(w17 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w17 = (w17 + 1);
HXDLIN(  35)																b93->data->b[(w17 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w17 = (w17 + 1);
HXDLIN(  35)																b93->data->b[(w17 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w17 = (w17 + 1);
HXDLIN(  35)																b93->data->b[(w17 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage49 = b93;
            								}
            								break;
            								case (int)1: {
HXLINE(  35)									 ::iterMagic::ArrIntImg arrI17 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::ArrIntImg a74 = arrI17;
HXDLIN(  35)									{
HXLINE(  35)										a74->width = width17;
HXDLIN(  35)										a74->height = height17;
HXDLIN(  35)										a74->data = ::Array_obj< int >::__new(0);
HXDLIN(  35)										a74->length = ::Std_obj::_hx_int(( (Float)((width17 * height17)) ));
HXDLIN(  35)										{
HXLINE(  35)											int _g340 = 0;
HXDLIN(  35)											int _g341 = a74->length;
HXDLIN(  35)											while((_g340 < _g341)){
HXLINE(  35)												_g340 = (_g340 + 1);
HXDLIN(  35)												int i102 = (_g340 - 1);
HXDLIN(  35)												a74->data[i102] = 0;
            											}
            										}
            									}
HXDLIN(  35)									undoImage49 = a74;
            								}
            								break;
            								case (int)2: {
HXLINE(  35)									 ::iterMagic::U32ArrImg u32a17 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::U32ArrImg b94 = u32a17;
HXDLIN(  35)									{
HXLINE(  35)										b94->width = width17;
HXDLIN(  35)										b94->height = height17;
HXDLIN(  35)										b94->length = ::Std_obj::_hx_int(( (Float)((width17 * height17)) ));
HXDLIN(  35)										int size17 = (b94->length * 4);
HXDLIN(  35)										b94->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size17),0,size17);
HXDLIN(  35)										{
HXLINE(  35)											int _g342 = 0;
HXDLIN(  35)											int _g343 = b94->length;
HXDLIN(  35)											while((_g342 < _g343)){
HXLINE(  35)												_g342 = (_g342 + 1);
HXDLIN(  35)												int i103 = (_g342 - 1);
HXDLIN(  35)												{
HXLINE(  35)													 ::haxe::io::ArrayBufferViewImpl this549 = b94->data;
HXDLIN(  35)													bool undoImage50;
HXDLIN(  35)													if ((i103 >= 0)) {
HXLINE(  35)														undoImage50 = (i103 < (this549->byteLength >> 2));
            													}
            													else {
HXLINE(  35)														undoImage50 = false;
            													}
HXDLIN(  35)													if (undoImage50) {
HXLINE(  35)														 ::haxe::io::Bytes _this17 = this549->bytes;
HXDLIN(  35)														int pos17 = ((i103 << 2) + this549->byteOffset);
HXDLIN(  35)														_this17->b[pos17] = ( (unsigned char)(0) );
HXDLIN(  35)														_this17->b[(pos17 + 1)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this17->b[(pos17 + 2)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this17->b[(pos17 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage49 = b94;
            								}
            								break;
            								case (int)3: {
HXLINE(  35)									 ::iterMagic::VecIntImg vec17 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::VecIntImg v73 = vec17;
HXDLIN(  35)									{
HXLINE(  35)										v73->width = width17;
HXDLIN(  35)										v73->height = height17;
HXDLIN(  35)										v73->length = ::Std_obj::_hx_int(( (Float)((width17 * height17)) ));
HXDLIN(  35)										v73->data = ::Array_obj< int >::__new(v73->length);
HXDLIN(  35)										{
HXLINE(  35)											int _g344 = 0;
HXDLIN(  35)											int _g345 = v73->length;
HXDLIN(  35)											while((_g344 < _g345)){
HXLINE(  35)												_g344 = (_g344 + 1);
HXDLIN(  35)												int i104 = (_g344 - 1);
HXDLIN(  35)												v73->data->__unsafe_set(i104,0);
            											}
            										}
            									}
HXDLIN(  35)									undoImage49 = v73;
            								}
            								break;
            								case (int)4: {
HXLINE(  35)									 ::iterMagic::StackIntImg sInt17 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::StackIntImg b95 = sInt17;
HXDLIN(  35)									{
HXLINE(  35)										b95->width = width17;
HXDLIN(  35)										b95->height = height17;
HXDLIN(  35)										b95->length = ::Std_obj::_hx_int(( (Float)((width17 * height17)) ));
HXDLIN(  35)										b95->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  35)										{
HXLINE(  35)											int len35 = b95->length;
HXDLIN(  35)											 ::haxe::ds::GenericStack_Int d17 = b95->data;
HXDLIN(  35)											if (::hx::IsNull( d17->head )) {
HXLINE(  35)												int _g346 = 0;
HXDLIN(  35)												int _g347 = len35;
HXDLIN(  35)												while((_g346 < _g347)){
HXLINE(  35)													_g346 = (_g346 + 1);
HXDLIN(  35)													int i105 = (_g346 - 1);
HXDLIN(  35)													d17->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d17->head);
            												}
            											}
            											else {
HXLINE(  35)												int _g348 = 0;
HXDLIN(  35)												int _g349 = len35;
HXDLIN(  35)												while((_g348 < _g349)){
HXLINE(  35)													_g348 = (_g348 + 1);
HXDLIN(  35)													int i106 = (_g348 - 1);
HXDLIN(  35)													{
HXLINE(  35)														 ::haxe::ds::GenericCell_Int l17 = b95->data->head;
HXDLIN(  35)														 ::haxe::ds::GenericCell_Int prev17 = null();
HXDLIN(  35)														{
HXLINE(  35)															int _g350 = 0;
HXDLIN(  35)															int _g351 = i106;
HXDLIN(  35)															while((_g350 < _g351)){
HXLINE(  35)																_g350 = (_g350 + 1);
HXDLIN(  35)																int i107 = (_g350 - 1);
HXLINE( 345)																prev17 = l17;
HXLINE( 346)																l17 = l17->next;
            															}
            														}
HXLINE(  35)														if (::hx::IsNull( prev17 )) {
HXLINE(  35)															b95->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l17->next);
HXDLIN(  35)															l17 = null();
            														}
            														else {
HXLINE(  35)															prev17->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l17->next);
HXDLIN(  35)															l17 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage49 = b95;
            								}
            								break;
            							}
HXDLIN(  35)							this548->image = undoImage49;
HXDLIN(  35)							this548->width = width17;
HXDLIN(  35)							this548->height = height17;
HXDLIN(  35)							this548->imageType = ( (int)(imageType17) );
HXDLIN(  35)							undoImage48 = this548;
HXDLIN(  35)							{
HXLINE(  35)								int rectLeft16 = xIter316->start;
HXDLIN(  35)								int rectTop16 = yIter316->start;
HXDLIN(  35)								int rectRight16 = xIter316->max;
HXDLIN(  35)								bool forceClear16 = false;
HXDLIN(  35)								{
HXLINE(  35)									int _g352 = rectTop16;
HXDLIN(  35)									int _g353 = yIter316->max;
HXDLIN(  35)									while((_g352 < _g353)){
HXLINE(  35)										_g352 = (_g352 + 1);
HXDLIN(  35)										int dy20 = (_g352 - 1);
HXDLIN(  35)										{
HXLINE(  35)											int _g354 = rectLeft16;
HXDLIN(  35)											int _g355 = rectRight16;
HXDLIN(  35)											while((_g354 < _g355)){
HXLINE(  35)												_g354 = (_g354 + 1);
HXDLIN(  35)												int dx17 = (_g354 - 1);
HXDLIN(  35)												::Dynamic this550 = temp->image;
HXDLIN(  35)												int index96;
HXDLIN(  35)												if (temp->useVirtualPos) {
HXLINE(  35)													index96 = ::Std_obj::_hx_int(((((( (Float)(dy20) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx17) - temp->virtualX));
            												}
            												else {
HXLINE(  35)													index96 = ::Std_obj::_hx_int(( (Float)(((dy20 * temp->width) + dx17)) ));
            												}
HXDLIN(  35)												int c80 = ::iterMagic::Iimg_obj::get(this550,index96);
HXDLIN(  35)												int col32;
HXDLIN(  35)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)													col32 = ((((((c80 >> 24) & 255) << 24) | ((c80 & 255) << 16)) | (((c80 >> 8) & 255) << 8)) | ((c80 >> 16) & 255));
            												}
            												else {
HXLINE(  35)													col32 = c80;
            												}
HXDLIN(  35)												bool _hx_tmp146;
HXDLIN(  35)												if (temp->useMask) {
HXLINE(  35)													_hx_tmp146 = ::hx::IsNotNull( temp->mask );
            												}
            												else {
HXLINE(  35)													_hx_tmp146 = false;
            												}
HXDLIN(  35)												if (_hx_tmp146) {
HXLINE(  35)													 ::pi_xy::ImageStruct this551 = temp->mask;
HXDLIN(  35)													::Dynamic this552 = this551->image;
HXDLIN(  35)													int index97;
HXDLIN(  35)													if (this551->useVirtualPos) {
HXLINE(  35)														index97 = ::Std_obj::_hx_int(((((( (Float)(dy20) ) - this551->virtualY) * ( (Float)(this551->width) )) + dx17) - this551->virtualX));
            													}
            													else {
HXLINE(  35)														index97 = ::Std_obj::_hx_int(( (Float)(((dy20 * this551->width) + dx17)) ));
            													}
HXDLIN(  35)													int c81 = ::iterMagic::Iimg_obj::get(this552,index97);
HXDLIN(  35)													int v74;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														v74 = ((((((c81 >> 24) & 255) << 24) | ((c81 & 255) << 16)) | (((c81 >> 8) & 255) << 8)) | ((c81 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														v74 = c81;
            													}
HXDLIN(  35)													int maskPixel16 = v74;
HXDLIN(  35)													int this553 = col32;
HXDLIN(  35)													if ((maskPixel16 == 0)) {
HXLINE(  35)														col32 = this553;
            													}
            													else {
HXLINE(  35)														Float m016;
HXDLIN(  35)														int this554 = ((maskPixel16 >> 24) & 255);
HXDLIN(  35)														if ((this554 == 0)) {
HXLINE(  35)															m016 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m016 = (( (Float)(this554) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m116;
HXDLIN(  35)														int this555 = ((maskPixel16 >> 16) & 255);
HXDLIN(  35)														if ((this555 == 0)) {
HXLINE(  35)															m116 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m116 = (( (Float)(this555) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m216;
HXDLIN(  35)														int this556 = ((maskPixel16 >> 8) & 255);
HXDLIN(  35)														if ((this556 == 0)) {
HXLINE(  35)															m216 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m216 = (( (Float)(this556) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m316;
HXDLIN(  35)														int this557 = (maskPixel16 & 255);
HXDLIN(  35)														if ((this557 == 0)) {
HXLINE(  35)															m316 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m316 = (( (Float)(this557) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														int ch016 = ::Std_obj::_hx_int(((((Float)1.) - m016) * ( (Float)(((this553 >> 24) & 255)) )));
HXDLIN(  35)														int ch116 = ::Std_obj::_hx_int(((((Float)1.) - m116) * ( (Float)(((this553 >> 16) & 255)) )));
HXDLIN(  35)														int ch216 = ::Std_obj::_hx_int(((((Float)1.) - m216) * ( (Float)(((this553 >> 8) & 255)) )));
HXDLIN(  35)														int ch316 = ::Std_obj::_hx_int(((((Float)1.) - m316) * ( (Float)((this553 & 255)) )));
HXDLIN(  35)														col32 = ((((::Math_obj::round((( (Float)(ch016) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch116) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch216) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch316) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  35)												if ((col32 != 0)) {
HXLINE(  35)													int x67 = (dx17 - rectLeft16);
HXDLIN(  35)													int y67 = (dy20 - rectTop16);
HXDLIN(  35)													int c82 = col32;
HXDLIN(  35)													bool _hx_tmp147;
HXDLIN(  35)													if ((((c82 >> 24) & 255) < 254)) {
HXLINE(  35)														_hx_tmp147 = undoImage48->transparent;
            													}
            													else {
HXLINE(  35)														_hx_tmp147 = false;
            													}
HXDLIN(  35)													if (_hx_tmp147) {
HXLINE(  35)														int location32;
HXDLIN(  35)														if (undoImage48->useVirtualPos) {
HXLINE(  35)															location32 = ::Std_obj::_hx_int(((((( (Float)(y67) ) - undoImage48->virtualY) * ( (Float)(undoImage48->width) )) + x67) - undoImage48->virtualX));
            														}
            														else {
HXLINE(  35)															location32 = ::Std_obj::_hx_int(( (Float)(((y67 * undoImage48->width) + x67)) ));
            														}
HXDLIN(  35)														int this558 = ::iterMagic::Iimg_obj::get(undoImage48->image,location32);
HXDLIN(  35)														int this559;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															this559 = ((((((this558 >> 24) & 255) << 24) | ((this558 & 255) << 16)) | (((this558 >> 8) & 255) << 8)) | ((this558 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															this559 = this558;
            														}
HXDLIN(  35)														Float a135;
HXDLIN(  35)														int this560 = ((this559 >> 24) & 255);
HXDLIN(  35)														if ((this560 == 0)) {
HXLINE(  35)															a135 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a135 = (( (Float)(this560) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r132;
HXDLIN(  35)														int this561 = ((this559 >> 16) & 255);
HXDLIN(  35)														if ((this561 == 0)) {
HXLINE(  35)															r132 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r132 = (( (Float)(this561) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g132;
HXDLIN(  35)														int this562 = ((this559 >> 8) & 255);
HXDLIN(  35)														if ((this562 == 0)) {
HXLINE(  35)															g132 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g132 = (( (Float)(this562) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b138;
HXDLIN(  35)														int this563 = (this559 & 255);
HXDLIN(  35)														if ((this563 == 0)) {
HXLINE(  35)															b138 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b138 = (( (Float)(this563) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a234;
HXDLIN(  35)														int this564 = ((col32 >> 24) & 255);
HXDLIN(  35)														if ((this564 == 0)) {
HXLINE(  35)															a234 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a234 = (( (Float)(this564) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r232;
HXDLIN(  35)														int this565 = ((col32 >> 16) & 255);
HXDLIN(  35)														if ((this565 == 0)) {
HXLINE(  35)															r232 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r232 = (( (Float)(this565) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g232;
HXDLIN(  35)														int this566 = ((col32 >> 8) & 255);
HXDLIN(  35)														if ((this566 == 0)) {
HXLINE(  35)															g232 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g232 = (( (Float)(this566) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b236;
HXDLIN(  35)														int this567 = (col32 & 255);
HXDLIN(  35)														if ((this567 == 0)) {
HXLINE(  35)															b236 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b236 = (( (Float)(this567) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a332 = (a135 * (( (Float)(1) ) - a234));
HXDLIN(  35)														int r52 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r132 * a332) + (r232 * a234))));
HXDLIN(  35)														int g52 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g132 * a332) + (g232 * a234))));
HXDLIN(  35)														int b96 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b138 * a332) + (b236 * a234))));
HXDLIN(  35)														int a75 = ::Std_obj::_hx_int((( (Float)(255) ) * (a332 + a234)));
HXDLIN(  35)														int blended32 = ((((a75 << 24) | (r52 << 16)) | (g52 << 8)) | b96);
HXDLIN(  35)														{
HXLINE(  35)															int _hx_tmp148;
HXDLIN(  35)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)																_hx_tmp148 = ((((((blended32 >> 24) & 255) << 24) | ((blended32 & 255) << 16)) | (((blended32 >> 8) & 255) << 8)) | ((blended32 >> 16) & 255));
            															}
            															else {
HXLINE(  35)																_hx_tmp148 = blended32;
            															}
HXDLIN(  35)															::iterMagic::Iimg_obj::set(undoImage48->image,location32,_hx_tmp148);
            														}
            													}
            													else {
HXLINE(  35)														::Dynamic this568 = undoImage48->image;
HXDLIN(  35)														int index98;
HXDLIN(  35)														if (undoImage48->useVirtualPos) {
HXLINE(  35)															index98 = ::Std_obj::_hx_int(((((( (Float)(y67) ) - undoImage48->virtualY) * ( (Float)(undoImage48->width) )) + x67) - undoImage48->virtualX));
            														}
            														else {
HXLINE(  35)															index98 = ::Std_obj::_hx_int(( (Float)(((y67 * undoImage48->width) + x67)) ));
            														}
HXDLIN(  35)														int _hx_tmp149;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp149 = ((((((c82 >> 24) & 255) << 24) | ((c82 & 255) << 16)) | (((c82 >> 8) & 255) << 8)) | ((c82 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp149 = c82;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this568,index98,_hx_tmp149);
            													}
            												}
            												else {
HXLINE(  35)													if (forceClear16) {
HXLINE(  35)														::Dynamic this569 = undoImage48->image;
HXDLIN(  35)														int x68 = (dx17 - rectLeft16);
HXDLIN(  35)														int y68 = (dy20 - rectTop16);
HXDLIN(  35)														int index99;
HXDLIN(  35)														if (undoImage48->useVirtualPos) {
HXLINE(  35)															index99 = ::Std_obj::_hx_int(((((( (Float)(y68) ) - undoImage48->virtualY) * ( (Float)(undoImage48->width) )) + x68) - undoImage48->virtualX));
            														}
            														else {
HXLINE(  35)															index99 = ::Std_obj::_hx_int(( (Float)(((y68 * undoImage48->width) + x68)) ));
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this569,index99,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						{
HXLINE(  35)							int _g_min32 = xIter316->start;
HXDLIN(  35)							int _g_max32 = xIter316->max;
HXDLIN(  35)							while((_g_min32 < _g_max32)){
HXLINE(  35)								_g_min32 = (_g_min32 + 1);
HXDLIN(  35)								int px16 = (_g_min32 - 1);
HXDLIN(  35)								Float pcx16 = (( (Float)(px16) ) - rightX);
HXDLIN(  35)								{
HXLINE(  35)									int _g_min33 = yIter316->start;
HXDLIN(  35)									int _g_max33 = yIter316->max;
HXDLIN(  35)									while((_g_min33 < _g_max33)){
HXLINE(  35)										_g_min33 = (_g_min33 + 1);
HXDLIN(  35)										int py16 = (_g_min33 - 1);
HXDLIN(  35)										Float pcy16 = (( (Float)(py16) ) - dy19);
HXDLIN(  35)										Float dot3116 = ((pcx16 * bcx16) + (pcy16 * bcy16));
HXDLIN(  35)										Float dot3216 = ((pcx16 * acx16) + (pcy16 * acy16));
HXDLIN(  35)										Float ratioA16 = (((dot2216 * dot3116) - (dot1216 * dot3216)) * denom116);
HXDLIN(  35)										Float ratioB16 = (((dot1116 * dot3216) - (dot1216 * dot3116)) * denom116);
HXDLIN(  35)										Float ratioC16 = ((((Float)1.0) - ratioB16) - ratioA16);
HXDLIN(  35)										bool _hx_tmp150;
HXDLIN(  35)										bool _hx_tmp151;
HXDLIN(  35)										if ((ratioA16 >= 0)) {
HXLINE(  35)											_hx_tmp151 = (ratioB16 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp151 = false;
            										}
HXDLIN(  35)										if (_hx_tmp151) {
HXLINE(  35)											_hx_tmp150 = (ratioC16 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp150 = false;
            										}
HXDLIN(  35)										if (_hx_tmp150) {
HXLINE(  35)											Float u16 = (((au17 * ratioA16) + (bu17 * ratioB16)) + (au * ratioC16));
HXDLIN(  35)											Float v75 = (((av17 * ratioA16) + (bv16 * ratioB16)) + (cv * ratioC16));
HXDLIN(  35)											int x69 = ::Std_obj::_hx_int(((u16 * win_width) + win_x));
HXDLIN(  35)											int y69 = ::Std_obj::_hx_int(((v75 * win_height) + win_y));
HXDLIN(  35)											::Dynamic this570 = texture->image;
HXDLIN(  35)											int index100;
HXDLIN(  35)											if (texture->useVirtualPos) {
HXLINE(  35)												index100 = ::Std_obj::_hx_int(((((( (Float)(y69) ) - texture->virtualY) * ( (Float)(texture->width) )) + x69) - texture->virtualX));
            											}
            											else {
HXLINE(  35)												index100 = ::Std_obj::_hx_int(( (Float)(((y69 * texture->width) + x69)) ));
            											}
HXDLIN(  35)											int c83 = ::iterMagic::Iimg_obj::get(this570,index100);
HXDLIN(  35)											int col33;
HXDLIN(  35)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)												col33 = ((((((c83 >> 24) & 255) << 24) | ((c83 & 255) << 16)) | (((c83 >> 8) & 255) << 8)) | ((c83 >> 16) & 255));
            											}
            											else {
HXLINE(  35)												col33 = c83;
            											}
HXDLIN(  35)											{
HXLINE(  35)												int c84 = col33;
HXDLIN(  35)												bool _hx_tmp152;
HXDLIN(  35)												if ((((c84 >> 24) & 255) < 254)) {
HXLINE(  35)													_hx_tmp152 = temp->transparent;
            												}
            												else {
HXLINE(  35)													_hx_tmp152 = false;
            												}
HXDLIN(  35)												if (_hx_tmp152) {
HXLINE(  35)													int location33;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														location33 = ::Std_obj::_hx_int(((((( (Float)(py16) ) - temp->virtualY) * ( (Float)(temp->width) )) + px16) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														location33 = ::Std_obj::_hx_int(( (Float)(((py16 * temp->width) + px16)) ));
            													}
HXDLIN(  35)													int this571 = ::iterMagic::Iimg_obj::get(temp->image,location33);
HXDLIN(  35)													int this572;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														this572 = ((((((this571 >> 24) & 255) << 24) | ((this571 & 255) << 16)) | (((this571 >> 8) & 255) << 8)) | ((this571 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														this572 = this571;
            													}
HXDLIN(  35)													Float a136;
HXDLIN(  35)													int this573 = ((this572 >> 24) & 255);
HXDLIN(  35)													if ((this573 == 0)) {
HXLINE(  35)														a136 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a136 = (( (Float)(this573) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r133;
HXDLIN(  35)													int this574 = ((this572 >> 16) & 255);
HXDLIN(  35)													if ((this574 == 0)) {
HXLINE(  35)														r133 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r133 = (( (Float)(this574) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g133;
HXDLIN(  35)													int this575 = ((this572 >> 8) & 255);
HXDLIN(  35)													if ((this575 == 0)) {
HXLINE(  35)														g133 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g133 = (( (Float)(this575) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b139;
HXDLIN(  35)													int this576 = (this572 & 255);
HXDLIN(  35)													if ((this576 == 0)) {
HXLINE(  35)														b139 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b139 = (( (Float)(this576) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a235;
HXDLIN(  35)													int this577 = ((col33 >> 24) & 255);
HXDLIN(  35)													if ((this577 == 0)) {
HXLINE(  35)														a235 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a235 = (( (Float)(this577) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r233;
HXDLIN(  35)													int this578 = ((col33 >> 16) & 255);
HXDLIN(  35)													if ((this578 == 0)) {
HXLINE(  35)														r233 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r233 = (( (Float)(this578) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g233;
HXDLIN(  35)													int this579 = ((col33 >> 8) & 255);
HXDLIN(  35)													if ((this579 == 0)) {
HXLINE(  35)														g233 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g233 = (( (Float)(this579) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b237;
HXDLIN(  35)													int this580 = (col33 & 255);
HXDLIN(  35)													if ((this580 == 0)) {
HXLINE(  35)														b237 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b237 = (( (Float)(this580) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a333 = (a136 * (( (Float)(1) ) - a235));
HXDLIN(  35)													int r53 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r133 * a333) + (r233 * a235))));
HXDLIN(  35)													int g53 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g133 * a333) + (g233 * a235))));
HXDLIN(  35)													int b97 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b139 * a333) + (b237 * a235))));
HXDLIN(  35)													int a76 = ::Std_obj::_hx_int((( (Float)(255) ) * (a333 + a235)));
HXDLIN(  35)													int blended33 = ((((a76 << 24) | (r53 << 16)) | (g53 << 8)) | b97);
HXDLIN(  35)													{
HXLINE(  35)														int _hx_tmp153;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp153 = ((((((blended33 >> 24) & 255) << 24) | ((blended33 & 255) << 16)) | (((blended33 >> 8) & 255) << 8)) | ((blended33 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp153 = blended33;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(temp->image,location33,_hx_tmp153);
            													}
            												}
            												else {
HXLINE(  35)													::Dynamic this581 = temp->image;
HXDLIN(  35)													int index101;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														index101 = ::Std_obj::_hx_int(((((( (Float)(py16) ) - temp->virtualY) * ( (Float)(temp->width) )) + px16) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														index101 = ::Std_obj::_hx_int(( (Float)(((py16 * temp->width) + px16)) ));
            													}
HXDLIN(  35)													int _hx_tmp154;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														_hx_tmp154 = ((((((c84 >> 24) & 255) << 24) | ((c84 & 255) << 16)) | (((c84 >> 8) & 255) << 8)) | ((c84 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														_hx_tmp154 = c84;
            													}
HXDLIN(  35)													::iterMagic::Iimg_obj::set(this581,index101,_hx_tmp154);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						if ((hasHit == false)) {
HXLINE(  35)							 ::pi_xy::algo::HitTri v76 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,rightX,bottomY,bx3,bottomY,rightX,dy19,true);
HXDLIN(  35)							if (hasUndo16) {
HXLINE(  35)								v76->undoImage = undoImage48;
HXDLIN(  35)								v76->undoX = xIter316->start;
HXDLIN(  35)								v76->undoY = yIter316->start;
            							}
            						}
            					}
HXDLIN(  35)					{
HXLINE(  35)						Float au18 = bu;
HXDLIN(  35)						Float av18 = av;
HXDLIN(  35)						Float bu18 = bu;
HXDLIN(  35)						Float bv17 = cv;
HXDLIN(  35)						bool hasUndo17 = false;
HXDLIN(  35)						Float temp18 = au18;
HXLINE( 422)						au18 = bu18;
HXLINE( 423)						bu18 = temp18;
HXLINE( 424)						temp18 = av18;
HXLINE( 425)						av18 = bv17;
HXLINE( 426)						bv17 = temp18;
HXLINE(  35)						Float bcx17 = (cx3 - rightX);
HXDLIN(  35)						Float bcy17 = (cy6 - dy19);
HXDLIN(  35)						Float acx17 = (bx3 - rightX);
HXDLIN(  35)						Float acy17 = (bottomY - dy19);
HXDLIN(  35)						Float dot1117 = ((bcx17 * bcx17) + (bcy17 * bcy17));
HXDLIN(  35)						Float dot1217 = ((bcx17 * acx17) + (bcy17 * acy17));
HXDLIN(  35)						Float dot2217 = ((acx17 * acx17) + (acy17 * acy17));
HXDLIN(  35)						Float denom117 = (( (Float)(1) ) / ((dot1117 * dot2217) - (dot1217 * dot1217)));
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart xIter317;
HXDLIN(  35)						if ((bx3 > cx3)) {
HXLINE(  35)							if ((bx3 > rightX)) {
HXLINE(  35)								int min59;
HXDLIN(  35)								if ((cx3 > rightX)) {
HXLINE(  35)									min59 = ::Math_obj::floor(rightX);
            								}
            								else {
HXLINE(  35)									min59 = ::Math_obj::floor(cx3);
            								}
HXDLIN(  35)								int ii_min127 = min59;
HXDLIN(  35)								int ii_max127 = ::Math_obj::ceil(bx3);
HXDLIN(  35)								xIter317 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min127,ii_max127);
            							}
            							else {
HXLINE(  35)								int ii_min128 = ::Math_obj::floor(cx3);
HXDLIN(  35)								int ii_max128 = ::Math_obj::ceil(rightX);
HXDLIN(  35)								xIter317 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min128,ii_max128);
            							}
            						}
            						else {
HXLINE(  35)							if ((cx3 > rightX)) {
HXLINE(  35)								int min60;
HXDLIN(  35)								if ((bx3 > rightX)) {
HXLINE(  35)									min60 = ::Math_obj::floor(rightX);
            								}
            								else {
HXLINE(  35)									min60 = ::Math_obj::ceil(bx3);
            								}
HXDLIN(  35)								int ii_min129 = min60;
HXDLIN(  35)								int ii_max129 = ::Math_obj::ceil(cx3);
HXDLIN(  35)								xIter317 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min129,ii_max129);
            							}
            							else {
HXLINE(  35)								int ii_min130 = ::Math_obj::floor(bx3);
HXDLIN(  35)								int ii_max130 = ::Math_obj::ceil(rightX);
HXDLIN(  35)								xIter317 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min130,ii_max130);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::iter::IntIterStart yIter317;
HXDLIN(  35)						if ((bottomY > cy6)) {
HXLINE(  35)							if ((bottomY > dy19)) {
HXLINE(  35)								int min61;
HXDLIN(  35)								if ((cy6 > dy19)) {
HXLINE(  35)									min61 = ::Math_obj::floor(dy19);
            								}
            								else {
HXLINE(  35)									min61 = ::Math_obj::floor(cy6);
            								}
HXDLIN(  35)								int ii_min131 = min61;
HXDLIN(  35)								int ii_max131 = ::Math_obj::ceil(bottomY);
HXDLIN(  35)								yIter317 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min131,ii_max131);
            							}
            							else {
HXLINE(  35)								int ii_min132 = ::Math_obj::floor(cy6);
HXDLIN(  35)								int ii_max132 = ::Math_obj::ceil(dy19);
HXDLIN(  35)								yIter317 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min132,ii_max132);
            							}
            						}
            						else {
HXLINE(  35)							if ((cy6 > dy19)) {
HXLINE(  35)								int min62;
HXDLIN(  35)								if ((bottomY > dy19)) {
HXLINE(  35)									min62 = ::Math_obj::floor(dy19);
            								}
            								else {
HXLINE(  35)									min62 = ::Math_obj::ceil(bottomY);
            								}
HXDLIN(  35)								int ii_min133 = min62;
HXDLIN(  35)								int ii_max133 = ::Math_obj::ceil(cy6);
HXDLIN(  35)								yIter317 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min133,ii_max133);
            							}
            							else {
HXLINE(  35)								int ii_min134 = ::Math_obj::floor(bottomY);
HXDLIN(  35)								int ii_max134 = ::Math_obj::ceil(dy19);
HXDLIN(  35)								yIter317 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min134,ii_max134);
            							}
            						}
HXDLIN(  35)						 ::pi_xy::ImageStruct undoImage51 = null();
HXDLIN(  35)						if (hasUndo17) {
HXLINE(  35)							int width18 = ((xIter317->max - xIter317->start) + 1);
HXDLIN(  35)							int height18 = ((yIter317->max - yIter317->start) + 1);
HXDLIN(  35)							 ::Dynamic imageType18 = null();
HXDLIN(  35)							 ::pi_xy::ImageStruct this582 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  35)							if (::hx::IsNull( imageType18 )) {
HXLINE(  54)								imageType18 = ::pi_xy::ImageStruct_obj::defaultType;
            							}
HXLINE(  35)							::Dynamic undoImage52;
HXDLIN(  35)							switch((int)(( (int)(imageType18) ))){
            								case (int)0: {
HXLINE(  35)									 ::iterMagic::BytesImg byt18 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::BytesImg b98 = byt18;
HXDLIN(  35)									{
HXLINE(  35)										b98->width = width18;
HXDLIN(  35)										b98->height = height18;
HXDLIN(  35)										b98->length = ::Std_obj::_hx_int(( (Float)((width18 * height18)) ));
HXDLIN(  35)										b98->data = ::haxe::io::Bytes_obj::alloc((b98->length * 4));
HXDLIN(  35)										{
HXLINE(  35)											int len36 = b98->length;
HXDLIN(  35)											int w18 = 0;
HXDLIN(  35)											{
HXLINE(  35)												int _g356 = 0;
HXDLIN(  35)												int _g357 = b98->height;
HXDLIN(  35)												while((_g356 < _g357)){
HXLINE(  35)													_g356 = (_g356 + 1);
HXDLIN(  35)													int y70 = (_g356 - 1);
HXDLIN(  35)													{
HXLINE(  35)														int _g358 = 0;
HXDLIN(  35)														int _g359 = b98->width;
HXDLIN(  35)														while((_g358 < _g359)){
HXLINE(  35)															_g358 = (_g358 + 1);
HXDLIN(  35)															int x70 = (_g358 - 1);
HXDLIN(  35)															{
HXLINE(  35)																w18 = (w18 + 1);
HXDLIN(  35)																b98->data->b[(w18 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w18 = (w18 + 1);
HXDLIN(  35)																b98->data->b[(w18 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w18 = (w18 + 1);
HXDLIN(  35)																b98->data->b[(w18 - 1)] = ( (unsigned char)(0) );
            															}
HXDLIN(  35)															{
HXLINE(  35)																w18 = (w18 + 1);
HXDLIN(  35)																b98->data->b[(w18 - 1)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage52 = b98;
            								}
            								break;
            								case (int)1: {
HXLINE(  35)									 ::iterMagic::ArrIntImg arrI18 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::ArrIntImg a77 = arrI18;
HXDLIN(  35)									{
HXLINE(  35)										a77->width = width18;
HXDLIN(  35)										a77->height = height18;
HXDLIN(  35)										a77->data = ::Array_obj< int >::__new(0);
HXDLIN(  35)										a77->length = ::Std_obj::_hx_int(( (Float)((width18 * height18)) ));
HXDLIN(  35)										{
HXLINE(  35)											int _g360 = 0;
HXDLIN(  35)											int _g361 = a77->length;
HXDLIN(  35)											while((_g360 < _g361)){
HXLINE(  35)												_g360 = (_g360 + 1);
HXDLIN(  35)												int i108 = (_g360 - 1);
HXDLIN(  35)												a77->data[i108] = 0;
            											}
            										}
            									}
HXDLIN(  35)									undoImage52 = a77;
            								}
            								break;
            								case (int)2: {
HXLINE(  35)									 ::iterMagic::U32ArrImg u32a18 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::U32ArrImg b99 = u32a18;
HXDLIN(  35)									{
HXLINE(  35)										b99->width = width18;
HXDLIN(  35)										b99->height = height18;
HXDLIN(  35)										b99->length = ::Std_obj::_hx_int(( (Float)((width18 * height18)) ));
HXDLIN(  35)										int size18 = (b99->length * 4);
HXDLIN(  35)										b99->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size18),0,size18);
HXDLIN(  35)										{
HXLINE(  35)											int _g362 = 0;
HXDLIN(  35)											int _g363 = b99->length;
HXDLIN(  35)											while((_g362 < _g363)){
HXLINE(  35)												_g362 = (_g362 + 1);
HXDLIN(  35)												int i109 = (_g362 - 1);
HXDLIN(  35)												{
HXLINE(  35)													 ::haxe::io::ArrayBufferViewImpl this583 = b99->data;
HXDLIN(  35)													bool undoImage53;
HXDLIN(  35)													if ((i109 >= 0)) {
HXLINE(  35)														undoImage53 = (i109 < (this583->byteLength >> 2));
            													}
            													else {
HXLINE(  35)														undoImage53 = false;
            													}
HXDLIN(  35)													if (undoImage53) {
HXLINE(  35)														 ::haxe::io::Bytes _this18 = this583->bytes;
HXDLIN(  35)														int pos18 = ((i109 << 2) + this583->byteOffset);
HXDLIN(  35)														_this18->b[pos18] = ( (unsigned char)(0) );
HXDLIN(  35)														_this18->b[(pos18 + 1)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this18->b[(pos18 + 2)] = ( (unsigned char)(0) );
HXDLIN(  35)														_this18->b[(pos18 + 3)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage52 = b99;
            								}
            								break;
            								case (int)3: {
HXLINE(  35)									 ::iterMagic::VecIntImg vec18 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::VecIntImg v77 = vec18;
HXDLIN(  35)									{
HXLINE(  35)										v77->width = width18;
HXDLIN(  35)										v77->height = height18;
HXDLIN(  35)										v77->length = ::Std_obj::_hx_int(( (Float)((width18 * height18)) ));
HXDLIN(  35)										v77->data = ::Array_obj< int >::__new(v77->length);
HXDLIN(  35)										{
HXLINE(  35)											int _g364 = 0;
HXDLIN(  35)											int _g365 = v77->length;
HXDLIN(  35)											while((_g364 < _g365)){
HXLINE(  35)												_g364 = (_g364 + 1);
HXDLIN(  35)												int i110 = (_g364 - 1);
HXDLIN(  35)												v77->data->__unsafe_set(i110,0);
            											}
            										}
            									}
HXDLIN(  35)									undoImage52 = v77;
            								}
            								break;
            								case (int)4: {
HXLINE(  35)									 ::iterMagic::StackIntImg sInt18 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  35)									 ::iterMagic::StackIntImg b100 = sInt18;
HXDLIN(  35)									{
HXLINE(  35)										b100->width = width18;
HXDLIN(  35)										b100->height = height18;
HXDLIN(  35)										b100->length = ::Std_obj::_hx_int(( (Float)((width18 * height18)) ));
HXDLIN(  35)										b100->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  35)										{
HXLINE(  35)											int len37 = b100->length;
HXDLIN(  35)											 ::haxe::ds::GenericStack_Int d18 = b100->data;
HXDLIN(  35)											if (::hx::IsNull( d18->head )) {
HXLINE(  35)												int _g366 = 0;
HXDLIN(  35)												int _g367 = len37;
HXDLIN(  35)												while((_g366 < _g367)){
HXLINE(  35)													_g366 = (_g366 + 1);
HXDLIN(  35)													int i111 = (_g366 - 1);
HXDLIN(  35)													d18->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d18->head);
            												}
            											}
            											else {
HXLINE(  35)												int _g368 = 0;
HXDLIN(  35)												int _g369 = len37;
HXDLIN(  35)												while((_g368 < _g369)){
HXLINE(  35)													_g368 = (_g368 + 1);
HXDLIN(  35)													int i112 = (_g368 - 1);
HXDLIN(  35)													{
HXLINE(  35)														 ::haxe::ds::GenericCell_Int l18 = b100->data->head;
HXDLIN(  35)														 ::haxe::ds::GenericCell_Int prev18 = null();
HXDLIN(  35)														{
HXLINE(  35)															int _g370 = 0;
HXDLIN(  35)															int _g371 = i112;
HXDLIN(  35)															while((_g370 < _g371)){
HXLINE(  35)																_g370 = (_g370 + 1);
HXDLIN(  35)																int i113 = (_g370 - 1);
HXLINE( 345)																prev18 = l18;
HXLINE( 346)																l18 = l18->next;
            															}
            														}
HXLINE(  35)														if (::hx::IsNull( prev18 )) {
HXLINE(  35)															b100->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l18->next);
HXDLIN(  35)															l18 = null();
            														}
            														else {
HXLINE(  35)															prev18->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l18->next);
HXDLIN(  35)															l18 = null();
            														}
            													}
            												}
            											}
            										}
            									}
HXDLIN(  35)									undoImage52 = b100;
            								}
            								break;
            							}
HXDLIN(  35)							this582->image = undoImage52;
HXDLIN(  35)							this582->width = width18;
HXDLIN(  35)							this582->height = height18;
HXDLIN(  35)							this582->imageType = ( (int)(imageType18) );
HXDLIN(  35)							undoImage51 = this582;
HXDLIN(  35)							{
HXLINE(  35)								int rectLeft17 = xIter317->start;
HXDLIN(  35)								int rectTop17 = yIter317->start;
HXDLIN(  35)								int rectRight17 = xIter317->max;
HXDLIN(  35)								bool forceClear17 = false;
HXDLIN(  35)								{
HXLINE(  35)									int _g372 = rectTop17;
HXDLIN(  35)									int _g373 = yIter317->max;
HXDLIN(  35)									while((_g372 < _g373)){
HXLINE(  35)										_g372 = (_g372 + 1);
HXDLIN(  35)										int dy21 = (_g372 - 1);
HXDLIN(  35)										{
HXLINE(  35)											int _g374 = rectLeft17;
HXDLIN(  35)											int _g375 = rectRight17;
HXDLIN(  35)											while((_g374 < _g375)){
HXLINE(  35)												_g374 = (_g374 + 1);
HXDLIN(  35)												int dx18 = (_g374 - 1);
HXDLIN(  35)												::Dynamic this584 = temp->image;
HXDLIN(  35)												int index102;
HXDLIN(  35)												if (temp->useVirtualPos) {
HXLINE(  35)													index102 = ::Std_obj::_hx_int(((((( (Float)(dy21) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx18) - temp->virtualX));
            												}
            												else {
HXLINE(  35)													index102 = ::Std_obj::_hx_int(( (Float)(((dy21 * temp->width) + dx18)) ));
            												}
HXDLIN(  35)												int c85 = ::iterMagic::Iimg_obj::get(this584,index102);
HXDLIN(  35)												int col34;
HXDLIN(  35)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)													col34 = ((((((c85 >> 24) & 255) << 24) | ((c85 & 255) << 16)) | (((c85 >> 8) & 255) << 8)) | ((c85 >> 16) & 255));
            												}
            												else {
HXLINE(  35)													col34 = c85;
            												}
HXDLIN(  35)												bool _hx_tmp155;
HXDLIN(  35)												if (temp->useMask) {
HXLINE(  35)													_hx_tmp155 = ::hx::IsNotNull( temp->mask );
            												}
            												else {
HXLINE(  35)													_hx_tmp155 = false;
            												}
HXDLIN(  35)												if (_hx_tmp155) {
HXLINE(  35)													 ::pi_xy::ImageStruct this585 = temp->mask;
HXDLIN(  35)													::Dynamic this586 = this585->image;
HXDLIN(  35)													int index103;
HXDLIN(  35)													if (this585->useVirtualPos) {
HXLINE(  35)														index103 = ::Std_obj::_hx_int(((((( (Float)(dy21) ) - this585->virtualY) * ( (Float)(this585->width) )) + dx18) - this585->virtualX));
            													}
            													else {
HXLINE(  35)														index103 = ::Std_obj::_hx_int(( (Float)(((dy21 * this585->width) + dx18)) ));
            													}
HXDLIN(  35)													int c86 = ::iterMagic::Iimg_obj::get(this586,index103);
HXDLIN(  35)													int v78;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														v78 = ((((((c86 >> 24) & 255) << 24) | ((c86 & 255) << 16)) | (((c86 >> 8) & 255) << 8)) | ((c86 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														v78 = c86;
            													}
HXDLIN(  35)													int maskPixel17 = v78;
HXDLIN(  35)													int this587 = col34;
HXDLIN(  35)													if ((maskPixel17 == 0)) {
HXLINE(  35)														col34 = this587;
            													}
            													else {
HXLINE(  35)														Float m017;
HXDLIN(  35)														int this588 = ((maskPixel17 >> 24) & 255);
HXDLIN(  35)														if ((this588 == 0)) {
HXLINE(  35)															m017 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m017 = (( (Float)(this588) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m117;
HXDLIN(  35)														int this589 = ((maskPixel17 >> 16) & 255);
HXDLIN(  35)														if ((this589 == 0)) {
HXLINE(  35)															m117 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m117 = (( (Float)(this589) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m217;
HXDLIN(  35)														int this590 = ((maskPixel17 >> 8) & 255);
HXDLIN(  35)														if ((this590 == 0)) {
HXLINE(  35)															m217 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m217 = (( (Float)(this590) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float m317;
HXDLIN(  35)														int this591 = (maskPixel17 & 255);
HXDLIN(  35)														if ((this591 == 0)) {
HXLINE(  35)															m317 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															m317 = (( (Float)(this591) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														int ch017 = ::Std_obj::_hx_int(((((Float)1.) - m017) * ( (Float)(((this587 >> 24) & 255)) )));
HXDLIN(  35)														int ch117 = ::Std_obj::_hx_int(((((Float)1.) - m117) * ( (Float)(((this587 >> 16) & 255)) )));
HXDLIN(  35)														int ch217 = ::Std_obj::_hx_int(((((Float)1.) - m217) * ( (Float)(((this587 >> 8) & 255)) )));
HXDLIN(  35)														int ch317 = ::Std_obj::_hx_int(((((Float)1.) - m317) * ( (Float)((this587 & 255)) )));
HXDLIN(  35)														col34 = ((((::Math_obj::round((( (Float)(ch017) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch117) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch217) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch317) ) * ( (Float)(255) ))));
            													}
            												}
HXDLIN(  35)												if ((col34 != 0)) {
HXLINE(  35)													int x71 = (dx18 - rectLeft17);
HXDLIN(  35)													int y71 = (dy21 - rectTop17);
HXDLIN(  35)													int c87 = col34;
HXDLIN(  35)													bool _hx_tmp156;
HXDLIN(  35)													if ((((c87 >> 24) & 255) < 254)) {
HXLINE(  35)														_hx_tmp156 = undoImage51->transparent;
            													}
            													else {
HXLINE(  35)														_hx_tmp156 = false;
            													}
HXDLIN(  35)													if (_hx_tmp156) {
HXLINE(  35)														int location34;
HXDLIN(  35)														if (undoImage51->useVirtualPos) {
HXLINE(  35)															location34 = ::Std_obj::_hx_int(((((( (Float)(y71) ) - undoImage51->virtualY) * ( (Float)(undoImage51->width) )) + x71) - undoImage51->virtualX));
            														}
            														else {
HXLINE(  35)															location34 = ::Std_obj::_hx_int(( (Float)(((y71 * undoImage51->width) + x71)) ));
            														}
HXDLIN(  35)														int this592 = ::iterMagic::Iimg_obj::get(undoImage51->image,location34);
HXDLIN(  35)														int this593;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															this593 = ((((((this592 >> 24) & 255) << 24) | ((this592 & 255) << 16)) | (((this592 >> 8) & 255) << 8)) | ((this592 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															this593 = this592;
            														}
HXDLIN(  35)														Float a137;
HXDLIN(  35)														int this594 = ((this593 >> 24) & 255);
HXDLIN(  35)														if ((this594 == 0)) {
HXLINE(  35)															a137 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a137 = (( (Float)(this594) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r134;
HXDLIN(  35)														int this595 = ((this593 >> 16) & 255);
HXDLIN(  35)														if ((this595 == 0)) {
HXLINE(  35)															r134 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r134 = (( (Float)(this595) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g134;
HXDLIN(  35)														int this596 = ((this593 >> 8) & 255);
HXDLIN(  35)														if ((this596 == 0)) {
HXLINE(  35)															g134 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g134 = (( (Float)(this596) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b140;
HXDLIN(  35)														int this597 = (this593 & 255);
HXDLIN(  35)														if ((this597 == 0)) {
HXLINE(  35)															b140 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b140 = (( (Float)(this597) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a236;
HXDLIN(  35)														int this598 = ((col34 >> 24) & 255);
HXDLIN(  35)														if ((this598 == 0)) {
HXLINE(  35)															a236 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															a236 = (( (Float)(this598) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float r234;
HXDLIN(  35)														int this599 = ((col34 >> 16) & 255);
HXDLIN(  35)														if ((this599 == 0)) {
HXLINE(  35)															r234 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															r234 = (( (Float)(this599) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float g234;
HXDLIN(  35)														int this600 = ((col34 >> 8) & 255);
HXDLIN(  35)														if ((this600 == 0)) {
HXLINE(  35)															g234 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															g234 = (( (Float)(this600) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float b238;
HXDLIN(  35)														int this601 = (col34 & 255);
HXDLIN(  35)														if ((this601 == 0)) {
HXLINE(  35)															b238 = ((Float)0.);
            														}
            														else {
HXLINE(  35)															b238 = (( (Float)(this601) ) / ( (Float)(255) ));
            														}
HXDLIN(  35)														Float a334 = (a137 * (( (Float)(1) ) - a236));
HXDLIN(  35)														int r54 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r134 * a334) + (r234 * a236))));
HXDLIN(  35)														int g54 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g134 * a334) + (g234 * a236))));
HXDLIN(  35)														int b101 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b140 * a334) + (b238 * a236))));
HXDLIN(  35)														int a78 = ::Std_obj::_hx_int((( (Float)(255) ) * (a334 + a236)));
HXDLIN(  35)														int blended34 = ((((a78 << 24) | (r54 << 16)) | (g54 << 8)) | b101);
HXDLIN(  35)														{
HXLINE(  35)															int _hx_tmp157;
HXDLIN(  35)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)																_hx_tmp157 = ((((((blended34 >> 24) & 255) << 24) | ((blended34 & 255) << 16)) | (((blended34 >> 8) & 255) << 8)) | ((blended34 >> 16) & 255));
            															}
            															else {
HXLINE(  35)																_hx_tmp157 = blended34;
            															}
HXDLIN(  35)															::iterMagic::Iimg_obj::set(undoImage51->image,location34,_hx_tmp157);
            														}
            													}
            													else {
HXLINE(  35)														::Dynamic this602 = undoImage51->image;
HXDLIN(  35)														int index104;
HXDLIN(  35)														if (undoImage51->useVirtualPos) {
HXLINE(  35)															index104 = ::Std_obj::_hx_int(((((( (Float)(y71) ) - undoImage51->virtualY) * ( (Float)(undoImage51->width) )) + x71) - undoImage51->virtualX));
            														}
            														else {
HXLINE(  35)															index104 = ::Std_obj::_hx_int(( (Float)(((y71 * undoImage51->width) + x71)) ));
            														}
HXDLIN(  35)														int _hx_tmp158;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp158 = ((((((c87 >> 24) & 255) << 24) | ((c87 & 255) << 16)) | (((c87 >> 8) & 255) << 8)) | ((c87 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp158 = c87;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this602,index104,_hx_tmp158);
            													}
            												}
            												else {
HXLINE(  35)													if (forceClear17) {
HXLINE(  35)														::Dynamic this603 = undoImage51->image;
HXDLIN(  35)														int x72 = (dx18 - rectLeft17);
HXDLIN(  35)														int y72 = (dy21 - rectTop17);
HXDLIN(  35)														int index105;
HXDLIN(  35)														if (undoImage51->useVirtualPos) {
HXLINE(  35)															index105 = ::Std_obj::_hx_int(((((( (Float)(y72) ) - undoImage51->virtualY) * ( (Float)(undoImage51->width) )) + x72) - undoImage51->virtualX));
            														}
            														else {
HXLINE(  35)															index105 = ::Std_obj::_hx_int(( (Float)(((y72 * undoImage51->width) + x72)) ));
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(this603,index105,0);
            													}
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						{
HXLINE(  35)							int _g_min34 = xIter317->start;
HXDLIN(  35)							int _g_max34 = xIter317->max;
HXDLIN(  35)							while((_g_min34 < _g_max34)){
HXLINE(  35)								_g_min34 = (_g_min34 + 1);
HXDLIN(  35)								int px17 = (_g_min34 - 1);
HXDLIN(  35)								Float pcx17 = (( (Float)(px17) ) - rightX);
HXDLIN(  35)								{
HXLINE(  35)									int _g_min35 = yIter317->start;
HXDLIN(  35)									int _g_max35 = yIter317->max;
HXDLIN(  35)									while((_g_min35 < _g_max35)){
HXLINE(  35)										_g_min35 = (_g_min35 + 1);
HXDLIN(  35)										int py17 = (_g_min35 - 1);
HXDLIN(  35)										Float pcy17 = (( (Float)(py17) ) - dy19);
HXDLIN(  35)										Float dot3117 = ((pcx17 * bcx17) + (pcy17 * bcy17));
HXDLIN(  35)										Float dot3217 = ((pcx17 * acx17) + (pcy17 * acy17));
HXDLIN(  35)										Float ratioA17 = (((dot2217 * dot3117) - (dot1217 * dot3217)) * denom117);
HXDLIN(  35)										Float ratioB17 = (((dot1117 * dot3217) - (dot1217 * dot3117)) * denom117);
HXDLIN(  35)										Float ratioC17 = ((((Float)1.0) - ratioB17) - ratioA17);
HXDLIN(  35)										bool _hx_tmp159;
HXDLIN(  35)										bool _hx_tmp160;
HXDLIN(  35)										if ((ratioA17 >= 0)) {
HXLINE(  35)											_hx_tmp160 = (ratioB17 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp160 = false;
            										}
HXDLIN(  35)										if (_hx_tmp160) {
HXLINE(  35)											_hx_tmp159 = (ratioC17 >= 0);
            										}
            										else {
HXLINE(  35)											_hx_tmp159 = false;
            										}
HXDLIN(  35)										if (_hx_tmp159) {
HXLINE(  35)											Float u17 = (((au18 * ratioA17) + (bu18 * ratioB17)) + (au * ratioC17));
HXDLIN(  35)											Float v79 = (((av18 * ratioA17) + (bv17 * ratioB17)) + (cv * ratioC17));
HXDLIN(  35)											int x73 = ::Std_obj::_hx_int(((u17 * win_width) + win_x));
HXDLIN(  35)											int y73 = ::Std_obj::_hx_int(((v79 * win_height) + win_y));
HXDLIN(  35)											::Dynamic this604 = texture->image;
HXDLIN(  35)											int index106;
HXDLIN(  35)											if (texture->useVirtualPos) {
HXLINE(  35)												index106 = ::Std_obj::_hx_int(((((( (Float)(y73) ) - texture->virtualY) * ( (Float)(texture->width) )) + x73) - texture->virtualX));
            											}
            											else {
HXLINE(  35)												index106 = ::Std_obj::_hx_int(( (Float)(((y73 * texture->width) + x73)) ));
            											}
HXDLIN(  35)											int c88 = ::iterMagic::Iimg_obj::get(this604,index106);
HXDLIN(  35)											int col35;
HXDLIN(  35)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)												col35 = ((((((c88 >> 24) & 255) << 24) | ((c88 & 255) << 16)) | (((c88 >> 8) & 255) << 8)) | ((c88 >> 16) & 255));
            											}
            											else {
HXLINE(  35)												col35 = c88;
            											}
HXDLIN(  35)											{
HXLINE(  35)												int c89 = col35;
HXDLIN(  35)												bool _hx_tmp161;
HXDLIN(  35)												if ((((c89 >> 24) & 255) < 254)) {
HXLINE(  35)													_hx_tmp161 = temp->transparent;
            												}
            												else {
HXLINE(  35)													_hx_tmp161 = false;
            												}
HXDLIN(  35)												if (_hx_tmp161) {
HXLINE(  35)													int location35;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														location35 = ::Std_obj::_hx_int(((((( (Float)(py17) ) - temp->virtualY) * ( (Float)(temp->width) )) + px17) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														location35 = ::Std_obj::_hx_int(( (Float)(((py17 * temp->width) + px17)) ));
            													}
HXDLIN(  35)													int this605 = ::iterMagic::Iimg_obj::get(temp->image,location35);
HXDLIN(  35)													int this606;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														this606 = ((((((this605 >> 24) & 255) << 24) | ((this605 & 255) << 16)) | (((this605 >> 8) & 255) << 8)) | ((this605 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														this606 = this605;
            													}
HXDLIN(  35)													Float a138;
HXDLIN(  35)													int this607 = ((this606 >> 24) & 255);
HXDLIN(  35)													if ((this607 == 0)) {
HXLINE(  35)														a138 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a138 = (( (Float)(this607) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r135;
HXDLIN(  35)													int this608 = ((this606 >> 16) & 255);
HXDLIN(  35)													if ((this608 == 0)) {
HXLINE(  35)														r135 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r135 = (( (Float)(this608) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g135;
HXDLIN(  35)													int this609 = ((this606 >> 8) & 255);
HXDLIN(  35)													if ((this609 == 0)) {
HXLINE(  35)														g135 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g135 = (( (Float)(this609) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b141;
HXDLIN(  35)													int this610 = (this606 & 255);
HXDLIN(  35)													if ((this610 == 0)) {
HXLINE(  35)														b141 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b141 = (( (Float)(this610) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a237;
HXDLIN(  35)													int this611 = ((col35 >> 24) & 255);
HXDLIN(  35)													if ((this611 == 0)) {
HXLINE(  35)														a237 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														a237 = (( (Float)(this611) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float r235;
HXDLIN(  35)													int this612 = ((col35 >> 16) & 255);
HXDLIN(  35)													if ((this612 == 0)) {
HXLINE(  35)														r235 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														r235 = (( (Float)(this612) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float g235;
HXDLIN(  35)													int this613 = ((col35 >> 8) & 255);
HXDLIN(  35)													if ((this613 == 0)) {
HXLINE(  35)														g235 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														g235 = (( (Float)(this613) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float b239;
HXDLIN(  35)													int this614 = (col35 & 255);
HXDLIN(  35)													if ((this614 == 0)) {
HXLINE(  35)														b239 = ((Float)0.);
            													}
            													else {
HXLINE(  35)														b239 = (( (Float)(this614) ) / ( (Float)(255) ));
            													}
HXDLIN(  35)													Float a335 = (a138 * (( (Float)(1) ) - a237));
HXDLIN(  35)													int r55 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r135 * a335) + (r235 * a237))));
HXDLIN(  35)													int g55 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g135 * a335) + (g235 * a237))));
HXDLIN(  35)													int b102 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b141 * a335) + (b239 * a237))));
HXDLIN(  35)													int a79 = ::Std_obj::_hx_int((( (Float)(255) ) * (a335 + a237)));
HXDLIN(  35)													int blended35 = ((((a79 << 24) | (r55 << 16)) | (g55 << 8)) | b102);
HXDLIN(  35)													{
HXLINE(  35)														int _hx_tmp162;
HXDLIN(  35)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)															_hx_tmp162 = ((((((blended35 >> 24) & 255) << 24) | ((blended35 & 255) << 16)) | (((blended35 >> 8) & 255) << 8)) | ((blended35 >> 16) & 255));
            														}
            														else {
HXLINE(  35)															_hx_tmp162 = blended35;
            														}
HXDLIN(  35)														::iterMagic::Iimg_obj::set(temp->image,location35,_hx_tmp162);
            													}
            												}
            												else {
HXLINE(  35)													::Dynamic this615 = temp->image;
HXDLIN(  35)													int index107;
HXDLIN(  35)													if (temp->useVirtualPos) {
HXLINE(  35)														index107 = ::Std_obj::_hx_int(((((( (Float)(py17) ) - temp->virtualY) * ( (Float)(temp->width) )) + px17) - temp->virtualX));
            													}
            													else {
HXLINE(  35)														index107 = ::Std_obj::_hx_int(( (Float)(((py17 * temp->width) + px17)) ));
            													}
HXDLIN(  35)													int _hx_tmp163;
HXDLIN(  35)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)														_hx_tmp163 = ((((((c89 >> 24) & 255) << 24) | ((c89 & 255) << 16)) | (((c89 >> 8) & 255) << 8)) | ((c89 >> 16) & 255));
            													}
            													else {
HXLINE(  35)														_hx_tmp163 = c89;
            													}
HXDLIN(  35)													::iterMagic::Iimg_obj::set(this615,index107,_hx_tmp163);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
HXDLIN(  35)						if ((hasHit == false)) {
HXLINE(  35)							 ::pi_xy::algo::HitTri v80 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,bx3,bottomY,cx3,cy6,rightX,dy19,true);
HXDLIN(  35)							if (hasUndo17) {
HXLINE(  35)								v80->undoImage = undoImage51;
HXDLIN(  35)								v80->undoX = xIter317->start;
HXDLIN(  35)								v80->undoY = yIter317->start;
            							}
            						}
            					}
HXDLIN(  35)					if ((hasHit == true)) {
HXLINE(  35)						 ::pi_xy::algo::HitQuad v81 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,rightX,bottomY,bx3,bottomY,cx3,cy6,rightX,dy19,true);
            					}
            				}
HXDLIN(  35)				 ::pi_xy::algo::HitQuad hit;
HXDLIN(  35)				if ((hasHit == true)) {
HXLINE(  35)					 ::pi_xy::algo::HitQuad v82 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  35)					hit = v82;
            				}
            				else {
HXLINE(  35)					hit = null();
            				}
HXDLIN(  35)				{
HXLINE(  35)					int x74 = ::Std_obj::_hx_int(x);
HXDLIN(  35)					int y74 = ::Std_obj::_hx_int(y);
HXDLIN(  35)					bool forceClear18 = false;
HXDLIN(  35)					{
HXLINE(  35)						int _g376 = 0;
HXDLIN(  35)						int _g377 = temp->height;
HXDLIN(  35)						while((_g376 < _g377)){
HXLINE(  35)							_g376 = (_g376 + 1);
HXDLIN(  35)							int dy22 = (_g376 - 1);
HXDLIN(  35)							{
HXLINE(  35)								int _g378 = 0;
HXDLIN(  35)								int _g379 = temp->width;
HXDLIN(  35)								while((_g378 < _g379)){
HXLINE(  35)									_g378 = (_g378 + 1);
HXDLIN(  35)									int dx19 = (_g378 - 1);
HXDLIN(  35)									::Dynamic this616 = temp->image;
HXDLIN(  35)									int index108;
HXDLIN(  35)									if (temp->useVirtualPos) {
HXLINE(  35)										index108 = ::Std_obj::_hx_int(((((( (Float)(dy22) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx19) - temp->virtualX));
            									}
            									else {
HXLINE(  35)										index108 = ::Std_obj::_hx_int(( (Float)(((dy22 * temp->width) + dx19)) ));
            									}
HXDLIN(  35)									int c90 = ::iterMagic::Iimg_obj::get(this616,index108);
HXDLIN(  35)									int col36;
HXDLIN(  35)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)										col36 = ((((((c90 >> 24) & 255) << 24) | ((c90 & 255) << 16)) | (((c90 >> 8) & 255) << 8)) | ((c90 >> 16) & 255));
            									}
            									else {
HXLINE(  35)										col36 = c90;
            									}
HXDLIN(  35)									bool _hx_tmp164;
HXDLIN(  35)									if (temp->useMask) {
HXLINE(  35)										_hx_tmp164 = ::hx::IsNotNull( temp->mask );
            									}
            									else {
HXLINE(  35)										_hx_tmp164 = false;
            									}
HXDLIN(  35)									if (_hx_tmp164) {
HXLINE(  35)										 ::pi_xy::ImageStruct this617 = temp->mask;
HXDLIN(  35)										::Dynamic this618 = this617->image;
HXDLIN(  35)										int index109;
HXDLIN(  35)										if (this617->useVirtualPos) {
HXLINE(  35)											index109 = ::Std_obj::_hx_int(((((( (Float)(dy22) ) - this617->virtualY) * ( (Float)(this617->width) )) + dx19) - this617->virtualX));
            										}
            										else {
HXLINE(  35)											index109 = ::Std_obj::_hx_int(( (Float)(((dy22 * this617->width) + dx19)) ));
            										}
HXDLIN(  35)										int c91 = ::iterMagic::Iimg_obj::get(this618,index109);
HXDLIN(  35)										int v83;
HXDLIN(  35)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)											v83 = ((((((c91 >> 24) & 255) << 24) | ((c91 & 255) << 16)) | (((c91 >> 8) & 255) << 8)) | ((c91 >> 16) & 255));
            										}
            										else {
HXLINE(  35)											v83 = c91;
            										}
HXDLIN(  35)										int maskPixel18 = v83;
HXDLIN(  35)										int this619 = col36;
HXDLIN(  35)										if ((maskPixel18 == 0)) {
HXLINE(  35)											col36 = this619;
            										}
            										else {
HXLINE(  35)											Float m018;
HXDLIN(  35)											int this620 = ((maskPixel18 >> 24) & 255);
HXDLIN(  35)											if ((this620 == 0)) {
HXLINE(  35)												m018 = ((Float)0.);
            											}
            											else {
HXLINE(  35)												m018 = (( (Float)(this620) ) / ( (Float)(255) ));
            											}
HXDLIN(  35)											Float m118;
HXDLIN(  35)											int this621 = ((maskPixel18 >> 16) & 255);
HXDLIN(  35)											if ((this621 == 0)) {
HXLINE(  35)												m118 = ((Float)0.);
            											}
            											else {
HXLINE(  35)												m118 = (( (Float)(this621) ) / ( (Float)(255) ));
            											}
HXDLIN(  35)											Float m218;
HXDLIN(  35)											int this622 = ((maskPixel18 >> 8) & 255);
HXDLIN(  35)											if ((this622 == 0)) {
HXLINE(  35)												m218 = ((Float)0.);
            											}
            											else {
HXLINE(  35)												m218 = (( (Float)(this622) ) / ( (Float)(255) ));
            											}
HXDLIN(  35)											Float m318;
HXDLIN(  35)											int this623 = (maskPixel18 & 255);
HXDLIN(  35)											if ((this623 == 0)) {
HXLINE(  35)												m318 = ((Float)0.);
            											}
            											else {
HXLINE(  35)												m318 = (( (Float)(this623) ) / ( (Float)(255) ));
            											}
HXDLIN(  35)											int ch018 = ::Std_obj::_hx_int(((((Float)1.) - m018) * ( (Float)(((this619 >> 24) & 255)) )));
HXDLIN(  35)											int ch118 = ::Std_obj::_hx_int(((((Float)1.) - m118) * ( (Float)(((this619 >> 16) & 255)) )));
HXDLIN(  35)											int ch218 = ::Std_obj::_hx_int(((((Float)1.) - m218) * ( (Float)(((this619 >> 8) & 255)) )));
HXDLIN(  35)											int ch318 = ::Std_obj::_hx_int(((((Float)1.) - m318) * ( (Float)((this619 & 255)) )));
HXDLIN(  35)											col36 = ((((::Math_obj::round((( (Float)(ch018) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch118) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch218) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch318) ) * ( (Float)(255) ))));
            										}
            									}
HXDLIN(  35)									if ((col36 != 0)) {
HXLINE(  35)										int x75 = (x74 + dx19);
HXDLIN(  35)										int y75 = (y74 + dy22);
HXDLIN(  35)										int c92 = col36;
HXDLIN(  35)										bool _hx_tmp165;
HXDLIN(  35)										if ((((c92 >> 24) & 255) < 254)) {
HXLINE(  35)											_hx_tmp165 = this1->transparent;
            										}
            										else {
HXLINE(  35)											_hx_tmp165 = false;
            										}
HXDLIN(  35)										if (_hx_tmp165) {
HXLINE(  35)											int location36;
HXDLIN(  35)											if (this1->useVirtualPos) {
HXLINE(  35)												location36 = ::Std_obj::_hx_int(((((( (Float)(y75) ) - this1->virtualY) * ( (Float)(this1->width) )) + x75) - this1->virtualX));
            											}
            											else {
HXLINE(  35)												location36 = ::Std_obj::_hx_int(( (Float)(((y75 * this1->width) + x75)) ));
            											}
HXDLIN(  35)											int this624 = ::iterMagic::Iimg_obj::get(this1->image,location36);
HXDLIN(  35)											int this625;
HXDLIN(  35)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)												this625 = ((((((this624 >> 24) & 255) << 24) | ((this624 & 255) << 16)) | (((this624 >> 8) & 255) << 8)) | ((this624 >> 16) & 255));
            											}
            											else {
HXLINE(  35)												this625 = this624;
            											}
HXDLIN(  35)											Float a139;
HXDLIN(  35)											int this626 = ((this625 >> 24) & 255);
HXDLIN(  35)											if ((this626 == 0)) {
HXLINE(  35)												a139 = ((Float)0.);
            											}
            											else {
HXLINE(  35)												a139 = (( (Float)(this626) ) / ( (Float)(255) ));
            											}
HXDLIN(  35)											Float r136;
HXDLIN(  35)											int this627 = ((this625 >> 16) & 255);
HXDLIN(  35)											if ((this627 == 0)) {
HXLINE(  35)												r136 = ((Float)0.);
            											}
            											else {
HXLINE(  35)												r136 = (( (Float)(this627) ) / ( (Float)(255) ));
            											}
HXDLIN(  35)											Float g136;
HXDLIN(  35)											int this628 = ((this625 >> 8) & 255);
HXDLIN(  35)											if ((this628 == 0)) {
HXLINE(  35)												g136 = ((Float)0.);
            											}
            											else {
HXLINE(  35)												g136 = (( (Float)(this628) ) / ( (Float)(255) ));
            											}
HXDLIN(  35)											Float b142;
HXDLIN(  35)											int this629 = (this625 & 255);
HXDLIN(  35)											if ((this629 == 0)) {
HXLINE(  35)												b142 = ((Float)0.);
            											}
            											else {
HXLINE(  35)												b142 = (( (Float)(this629) ) / ( (Float)(255) ));
            											}
HXDLIN(  35)											Float a238;
HXDLIN(  35)											int this630 = ((col36 >> 24) & 255);
HXDLIN(  35)											if ((this630 == 0)) {
HXLINE(  35)												a238 = ((Float)0.);
            											}
            											else {
HXLINE(  35)												a238 = (( (Float)(this630) ) / ( (Float)(255) ));
            											}
HXDLIN(  35)											Float r236;
HXDLIN(  35)											int this631 = ((col36 >> 16) & 255);
HXDLIN(  35)											if ((this631 == 0)) {
HXLINE(  35)												r236 = ((Float)0.);
            											}
            											else {
HXLINE(  35)												r236 = (( (Float)(this631) ) / ( (Float)(255) ));
            											}
HXDLIN(  35)											Float g236;
HXDLIN(  35)											int this632 = ((col36 >> 8) & 255);
HXDLIN(  35)											if ((this632 == 0)) {
HXLINE(  35)												g236 = ((Float)0.);
            											}
            											else {
HXLINE(  35)												g236 = (( (Float)(this632) ) / ( (Float)(255) ));
            											}
HXDLIN(  35)											Float b240;
HXDLIN(  35)											int this633 = (col36 & 255);
HXDLIN(  35)											if ((this633 == 0)) {
HXLINE(  35)												b240 = ((Float)0.);
            											}
            											else {
HXLINE(  35)												b240 = (( (Float)(this633) ) / ( (Float)(255) ));
            											}
HXDLIN(  35)											Float a336 = (a139 * (( (Float)(1) ) - a238));
HXDLIN(  35)											int r56 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r136 * a336) + (r236 * a238))));
HXDLIN(  35)											int g56 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g136 * a336) + (g236 * a238))));
HXDLIN(  35)											int b103 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b142 * a336) + (b240 * a238))));
HXDLIN(  35)											int a80 = ::Std_obj::_hx_int((( (Float)(255) ) * (a336 + a238)));
HXDLIN(  35)											int blended36 = ((((a80 << 24) | (r56 << 16)) | (g56 << 8)) | b103);
HXDLIN(  35)											{
HXLINE(  35)												int _hx_tmp166;
HXDLIN(  35)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)													_hx_tmp166 = ((((((blended36 >> 24) & 255) << 24) | ((blended36 & 255) << 16)) | (((blended36 >> 8) & 255) << 8)) | ((blended36 >> 16) & 255));
            												}
            												else {
HXLINE(  35)													_hx_tmp166 = blended36;
            												}
HXDLIN(  35)												::iterMagic::Iimg_obj::set(this1->image,location36,_hx_tmp166);
            											}
            										}
            										else {
HXLINE(  35)											::Dynamic this634 = this1->image;
HXDLIN(  35)											int index110;
HXDLIN(  35)											if (this1->useVirtualPos) {
HXLINE(  35)												index110 = ::Std_obj::_hx_int(((((( (Float)(y75) ) - this1->virtualY) * ( (Float)(this1->width) )) + x75) - this1->virtualX));
            											}
            											else {
HXLINE(  35)												index110 = ::Std_obj::_hx_int(( (Float)(((y75 * this1->width) + x75)) ));
            											}
HXDLIN(  35)											int _hx_tmp167;
HXDLIN(  35)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  35)												_hx_tmp167 = ((((((c92 >> 24) & 255) << 24) | ((c92 & 255) << 16)) | (((c92 >> 8) & 255) << 8)) | ((c92 >> 16) & 255));
            											}
            											else {
HXLINE(  35)												_hx_tmp167 = c92;
            											}
HXDLIN(  35)											::iterMagic::Iimg_obj::set(this634,index110,_hx_tmp167);
            										}
            									}
            									else {
HXLINE(  35)										if (forceClear18) {
HXLINE(  35)											::Dynamic this635 = this1->image;
HXDLIN(  35)											int x76 = (x74 + dx19);
HXDLIN(  35)											int y76 = (y74 + dy22);
HXDLIN(  35)											int index111;
HXDLIN(  35)											if (this1->useVirtualPos) {
HXLINE(  35)												index111 = ::Std_obj::_hx_int(((((( (Float)(y76) ) - this1->virtualY) * ( (Float)(this1->width) )) + x76) - this1->virtualX));
            											}
            											else {
HXLINE(  35)												index111 = ::Std_obj::_hx_int(( (Float)(((y76 * this1->width) + x76)) ));
            											}
HXDLIN(  35)											::iterMagic::Iimg_obj::set(this635,index111,0);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXLINE( 142)				temp = null();
HXLINE(  35)				if (::hx::IsNotNull( hit )) {
HXLINE(  35)					 ::pi_xy::algo::HitQuad hit1 = hit;
HXDLIN(  35)					hit1->ax = (hit1->ax + x);
HXDLIN(  35)					 ::pi_xy::algo::HitQuad hit2 = hit;
HXDLIN(  35)					hit2->ay = (hit2->ay + y);
HXDLIN(  35)					 ::pi_xy::algo::HitQuad hit3 = hit;
HXDLIN(  35)					hit3->bx = (hit3->bx + x);
HXDLIN(  35)					 ::pi_xy::algo::HitQuad hit4 = hit;
HXDLIN(  35)					hit4->by = (hit4->by + y);
HXDLIN(  35)					 ::pi_xy::algo::HitQuad hit5 = hit;
HXDLIN(  35)					hit5->cx = (hit5->cx + x);
HXDLIN(  35)					 ::pi_xy::algo::HitQuad hit6 = hit;
HXDLIN(  35)					hit6->cy = (hit6->cy + y);
HXDLIN(  35)					 ::pi_xy::algo::HitQuad hit7 = hit;
HXDLIN(  35)					hit7->dx = (hit7->dx + x);
HXDLIN(  35)					 ::pi_xy::algo::HitQuad hit8 = hit;
HXDLIN(  35)					hit8->dy = (hit8->dy + y);
            				}
            			}
            			else {
HXLINE(  37)				HX_STACK_DO_THROW(HX_("not yet implemented",bd,44,24,01));
            			}
            		}
HXLINE(  42)		return pixelImage;
            	}


 ::Dynamic NineSlicePicture_obj::setImage(::String name, ::Dynamic _tmp_value){
            	HX_STACKFRAME(&_hx_pos_c19e8e9a0f2b0013_44_setImage)
HXLINE(  45)		 ::pi_xy::ImageStruct value = ( ( ::pi_xy::ImageStruct)(_tmp_value) );
HXDLIN(  45)		if ((name.toLowerCase() == HX_("imagetexture",e0,1a,58,c1))) {
HXLINE(  46)			if (::hx::IsNull( value )) {
HXLINE(  46)				HX_STACK_DO_THROW((HX_("failed to find image resource",18,8d,60,87) + name));
            			}
HXLINE(  47)			this->imageTexture = value;
            		}
HXLINE(  49)		return value;
            	}



::hx::ObjectPtr< NineSlicePicture_obj > NineSlicePicture_obj::__new( ::Dynamic opacity, ::Dynamic visibility, ::Dynamic strokeColor, ::Dynamic strokeWidth,::Array< ::String > strokeDashGapArray, ::Dynamic fill, ::Dynamic left, ::Dynamic top, ::Dynamic initWid, ::Dynamic initHi, ::Dynamic initLeft, ::Dynamic initTop, ::Dynamic initFat, ::Dynamic initTall, ::Dynamic newWid, ::Dynamic newHi, ::Dynamic newLeft, ::Dynamic newTop, ::Dynamic newFat, ::Dynamic newTall, ::pi_xy::ImageStruct imageTexture, ::Dynamic pictureX, ::Dynamic pictureY, ::Dynamic pictureWidth, ::Dynamic pictureHeight, ::Dynamic rounded) {
	::hx::ObjectPtr< NineSlicePicture_obj > __this = new NineSlicePicture_obj();
	__this->__construct(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,initWid,initHi,initLeft,initTop,initFat,initTall,newWid,newHi,newLeft,newTop,newFat,newTall,imageTexture,pictureX,pictureY,pictureWidth,pictureHeight,rounded);
	return __this;
}

::hx::ObjectPtr< NineSlicePicture_obj > NineSlicePicture_obj::__alloc(::hx::Ctx *_hx_ctx, ::Dynamic opacity, ::Dynamic visibility, ::Dynamic strokeColor, ::Dynamic strokeWidth,::Array< ::String > strokeDashGapArray, ::Dynamic fill, ::Dynamic left, ::Dynamic top, ::Dynamic initWid, ::Dynamic initHi, ::Dynamic initLeft, ::Dynamic initTop, ::Dynamic initFat, ::Dynamic initTall, ::Dynamic newWid, ::Dynamic newHi, ::Dynamic newLeft, ::Dynamic newTop, ::Dynamic newFat, ::Dynamic newTall, ::pi_xy::ImageStruct imageTexture, ::Dynamic pictureX, ::Dynamic pictureY, ::Dynamic pictureWidth, ::Dynamic pictureHeight, ::Dynamic rounded) {
	NineSlicePicture_obj *__this = (NineSlicePicture_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(NineSlicePicture_obj), true, "pi_xy.triangleGML.NineSlicePicture"));
	*(void **)__this = NineSlicePicture_obj::_hx_vtable;
	__this->__construct(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,initWid,initHi,initLeft,initTop,initFat,initTall,newWid,newHi,newLeft,newTop,newFat,newTall,imageTexture,pictureX,pictureY,pictureWidth,pictureHeight,rounded);
	return __this;
}

NineSlicePicture_obj::NineSlicePicture_obj()
{
}

::hx::Val NineSlicePicture_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"setImage") ) { return ::hx::Val( setImage_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"srcPicture") ) { return ::hx::Val( srcPicture ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"setParameter") ) { return ::hx::Val( setParameter_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val NineSlicePicture_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 10:
		if (HX_FIELD_EQ(inName,"srcPicture") ) { srcPicture=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void NineSlicePicture_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("srcPicture",3a,16,56,b7));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo NineSlicePicture_obj_sMemberStorageInfo[] = {
	{::hx::fsBool,(int)offsetof(NineSlicePicture_obj,srcPicture),HX_("srcPicture",3a,16,56,b7)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *NineSlicePicture_obj_sStaticStorageInfo = 0;
#endif

static ::String NineSlicePicture_obj_sMemberFields[] = {
	HX_("srcPicture",3a,16,56,b7),
	HX_("setParameter",a7,f5,ff,6c),
	HX_("render",56,6b,29,05),
	HX_("setImage",59,88,9d,cb),
	::String(null()) };

::hx::Class NineSlicePicture_obj::__mClass;

void NineSlicePicture_obj::__register()
{
	NineSlicePicture_obj _hx_dummy;
	NineSlicePicture_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pi_xy.triangleGML.NineSlicePicture",d5,07,09,e1);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(NineSlicePicture_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< NineSlicePicture_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = NineSlicePicture_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = NineSlicePicture_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pi_xy
} // end namespace triangleGML
