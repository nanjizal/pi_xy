// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericCell_Int
#include <haxe/ds/GenericCell_Int.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericStack_Int
#include <haxe/ds/GenericStack_Int.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_iterMagic_ArrIntImg
#include <iterMagic/ArrIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_BytesImg
#include <iterMagic/BytesImg.h>
#endif
#ifndef INCLUDED_iterMagic_Iimg
#include <iterMagic/Iimg.h>
#endif
#ifndef INCLUDED_iterMagic_StackIntImg
#include <iterMagic/StackIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_U32ArrImg
#include <iterMagic/U32ArrImg.h>
#endif
#ifndef INCLUDED_iterMagic_VecIntImg
#include <iterMagic/VecIntImg.h>
#endif
#ifndef INCLUDED_pi_xy_ImageStruct
#include <pi_xy/ImageStruct.h>
#endif
#ifndef INCLUDED_pi_xy__Endian_Endian_Fields_
#include <pi_xy/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitTri
#include <pi_xy/algo/HitTri.h>
#endif
#ifndef INCLUDED_pi_xy_algo_IhitObj
#include <pi_xy/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pi_xy_algo_TriPoints_
#include <pi_xy/algo/TriPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_iter_IntIterStart
#include <pi_xy/iter/IntIterStart.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_CircleForm
#include <pi_xy/triangleGML/CircleForm.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_triGML_BasicShape
#include <pi_xy/triangleGML/triGML/BasicShape.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_triGML_FillForm
#include <pi_xy/triangleGML/triGML/FillForm.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_triGML_GroupShape
#include <pi_xy/triangleGML/triGML/GroupShape.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_triGML_ShapeInterface
#include <pi_xy/triangleGML/triGML/ShapeInterface.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_triGML_shape_form_CircleForm_
#include <pi_xy/triangleGML/triGML/shape/form/CircleForm_.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_925f245d5d5fdd9f_6_new,"pi_xy.triangleGML.CircleForm","new",0x74c3479d,"pi_xy.triangleGML.CircleForm.new","pi_xy/triangleGML/CircleForm.hx",6,0x898a13b1)
HX_LOCAL_STACK_FRAME(_hx_pos_925f245d5d5fdd9f_7_render,"pi_xy.triangleGML.CircleForm","render",0x90d05839,"pi_xy.triangleGML.CircleForm.render","pi_xy/triangleGML/CircleForm.hx",7,0x898a13b1)
HX_LOCAL_STACK_FRAME(_hx_pos_925f245d5d5fdd9f_15_buildCircle,"pi_xy.triangleGML.CircleForm","buildCircle",0x1d42d41b,"pi_xy.triangleGML.CircleForm.buildCircle","pi_xy/triangleGML/CircleForm.hx",15,0x898a13b1)
namespace pi_xy{
namespace triangleGML{

void CircleForm_obj::__construct( ::Dynamic opacity, ::Dynamic visibility, ::Dynamic strokeColor, ::Dynamic strokeWidth,::Array< ::String > strokeDashGapArray, ::Dynamic fill, ::Dynamic left, ::Dynamic top, ::Dynamic diameter){
            	HX_STACKFRAME(&_hx_pos_925f245d5d5fdd9f_6_new)
HXDLIN(   6)		super::__construct(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,diameter);
            	}

Dynamic CircleForm_obj::__CreateEmpty() { return new CircleForm_obj; }

void *CircleForm_obj::_hx_vtable = 0;

Dynamic CircleForm_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< CircleForm_obj > _hx_result = new CircleForm_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7],inArgs[8]);
	return _hx_result;
}

bool CircleForm_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x4f186619) {
		if (inClassId<=(int)0x298c35e0) {
			if (inClassId<=(int)0x1a0bd5c0) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x1a0bd5c0;
			} else {
				return inClassId==(int)0x298c35e0;
			}
		} else {
			return inClassId==(int)0x4f186619;
		}
	} else {
		return inClassId==(int)0x59602077 || inClassId==(int)0x7ff8cec5;
	}
}

 ::Dynamic CircleForm_obj::render( ::Dynamic _tmp_pixelImage){
            	HX_GC_STACKFRAME(&_hx_pos_925f245d5d5fdd9f_7_render)
HXLINE(   8)		 ::pi_xy::ImageStruct pixelImage = ( ( ::pi_xy::ImageStruct)(_tmp_pixelImage) );
HXDLIN(   8)		int width = ::Math_obj::ceil(this->diameter);
HXDLIN(   8)		int height = ::Math_obj::ceil(this->diameter);
HXDLIN(   8)		 ::Dynamic imageType = null();
HXDLIN(   8)		 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(   8)		if (::hx::IsNull( imageType )) {
HXLINE(   8)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXDLIN(   8)		::Dynamic _hx_tmp;
HXDLIN(   8)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE(   8)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(   8)				 ::iterMagic::BytesImg b = byt;
HXDLIN(   8)				{
HXLINE(   8)					b->width = width;
HXDLIN(   8)					b->height = height;
HXDLIN(   8)					b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(   8)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(   8)					{
HXLINE(   8)						int len = b->length;
HXDLIN(   8)						int w = 0;
HXDLIN(   8)						{
HXLINE(   8)							int _g = 0;
HXDLIN(   8)							int _g1 = b->height;
HXDLIN(   8)							while((_g < _g1)){
HXLINE(   8)								_g = (_g + 1);
HXDLIN(   8)								int y = (_g - 1);
HXDLIN(   8)								{
HXLINE(   8)									int _g2 = 0;
HXDLIN(   8)									int _g3 = b->width;
HXDLIN(   8)									while((_g2 < _g3)){
HXLINE(   8)										_g2 = (_g2 + 1);
HXDLIN(   8)										int x = (_g2 - 1);
HXDLIN(   8)										{
HXLINE(   8)											w = (w + 1);
HXDLIN(   8)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(   8)										{
HXLINE(   8)											w = (w + 1);
HXDLIN(   8)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(   8)										{
HXLINE(   8)											w = (w + 1);
HXDLIN(   8)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(   8)										{
HXLINE(   8)											w = (w + 1);
HXDLIN(   8)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(   8)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXLINE(   8)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(   8)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(   8)				{
HXLINE(   8)					a->width = width;
HXDLIN(   8)					a->height = height;
HXDLIN(   8)					a->data = ::Array_obj< int >::__new(0);
HXDLIN(   8)					a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(   8)					{
HXLINE(   8)						int _g4 = 0;
HXDLIN(   8)						int _g5 = a->length;
HXDLIN(   8)						while((_g4 < _g5)){
HXLINE(   8)							_g4 = (_g4 + 1);
HXDLIN(   8)							int i = (_g4 - 1);
HXDLIN(   8)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN(   8)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXLINE(   8)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(   8)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(   8)				{
HXLINE(   8)					b1->width = width;
HXDLIN(   8)					b1->height = height;
HXDLIN(   8)					b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(   8)					int size = (b1->length * 4);
HXDLIN(   8)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(   8)					{
HXLINE(   8)						int _g6 = 0;
HXDLIN(   8)						int _g7 = b1->length;
HXDLIN(   8)						while((_g6 < _g7)){
HXLINE(   8)							_g6 = (_g6 + 1);
HXDLIN(   8)							int i1 = (_g6 - 1);
HXDLIN(   8)							{
HXLINE(   8)								 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN(   8)								bool _hx_tmp1;
HXDLIN(   8)								if ((i1 >= 0)) {
HXLINE(   8)									_hx_tmp1 = (i1 < (this2->byteLength >> 2));
            								}
            								else {
HXLINE(   8)									_hx_tmp1 = false;
            								}
HXDLIN(   8)								if (_hx_tmp1) {
HXLINE(   8)									 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN(   8)									int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN(   8)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(   8)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(   8)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(   8)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(   8)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXLINE(   8)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(   8)				 ::iterMagic::VecIntImg v = vec;
HXDLIN(   8)				{
HXLINE(   8)					v->width = width;
HXDLIN(   8)					v->height = height;
HXDLIN(   8)					v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(   8)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(   8)					{
HXLINE(   8)						int _g8 = 0;
HXDLIN(   8)						int _g9 = v->length;
HXDLIN(   8)						while((_g8 < _g9)){
HXLINE(   8)							_g8 = (_g8 + 1);
HXDLIN(   8)							int i2 = (_g8 - 1);
HXDLIN(   8)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN(   8)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXLINE(   8)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(   8)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(   8)				{
HXLINE(   8)					b2->width = width;
HXDLIN(   8)					b2->height = height;
HXDLIN(   8)					b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(   8)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(   8)					{
HXLINE(   8)						int len1 = b2->length;
HXDLIN(   8)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(   8)						if (::hx::IsNull( d->head )) {
HXLINE(   8)							int _g10 = 0;
HXDLIN(   8)							int _g11 = len1;
HXDLIN(   8)							while((_g10 < _g11)){
HXLINE(   8)								_g10 = (_g10 + 1);
HXDLIN(   8)								int i3 = (_g10 - 1);
HXDLIN(   8)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE(   8)							int _g12 = 0;
HXDLIN(   8)							int _g13 = len1;
HXDLIN(   8)							while((_g12 < _g13)){
HXLINE(   8)								_g12 = (_g12 + 1);
HXDLIN(   8)								int i4 = (_g12 - 1);
HXDLIN(   8)								{
HXLINE(   8)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(   8)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(   8)									{
HXLINE(   8)										int _g14 = 0;
HXDLIN(   8)										int _g15 = i4;
HXDLIN(   8)										while((_g14 < _g15)){
HXLINE(   8)											_g14 = (_g14 + 1);
HXDLIN(   8)											int i5 = (_g14 - 1);
HXDLIN(   8)											prev = l;
HXDLIN(   8)											l = l->next;
            										}
            									}
HXDLIN(   8)									if (::hx::IsNull( prev )) {
HXLINE(   8)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(   8)										l = null();
            									}
            									else {
HXLINE(   8)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(   8)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(   8)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN(   8)		this1->image = _hx_tmp;
HXDLIN(   8)		this1->width = width;
HXDLIN(   8)		this1->height = height;
HXDLIN(   8)		this1->imageType = ( (int)(imageType) );
HXDLIN(   8)		 ::pi_xy::ImageStruct temp = this1;
HXLINE(   9)		temp->transparent = false;
HXLINE(  10)		this->buildCircle(temp);
HXLINE(  11)		{
HXLINE(  11)			int x1 = ::Std_obj::_hx_int((this->left + this->offX));
HXDLIN(  11)			int y1 = ::Std_obj::_hx_int((this->top + this->offY));
HXDLIN(  11)			bool forceClear = false;
HXDLIN(  11)			{
HXLINE(  11)				int _g16 = 0;
HXDLIN(  11)				int _g17 = temp->height;
HXDLIN(  11)				while((_g16 < _g17)){
HXLINE(  11)					_g16 = (_g16 + 1);
HXDLIN(  11)					int dy = (_g16 - 1);
HXDLIN(  11)					{
HXLINE(  11)						int _g18 = 0;
HXDLIN(  11)						int _g19 = temp->width;
HXDLIN(  11)						while((_g18 < _g19)){
HXLINE(  11)							_g18 = (_g18 + 1);
HXDLIN(  11)							int dx = (_g18 - 1);
HXDLIN(  11)							::Dynamic this3 = temp->image;
HXDLIN(  11)							int index;
HXDLIN(  11)							if (temp->useVirtualPos) {
HXLINE(  11)								index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - temp->virtualY) * ( (Float)(temp->width) )) + dx) - temp->virtualX));
            							}
            							else {
HXLINE(  11)								index = ::Std_obj::_hx_int(( (Float)(((dy * temp->width) + dx)) ));
            							}
HXDLIN(  11)							int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN(  11)							int col;
HXDLIN(  11)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  11)								col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            							}
            							else {
HXLINE(  11)								col = c;
            							}
HXDLIN(  11)							bool _hx_tmp2;
HXDLIN(  11)							if (temp->useMask) {
HXLINE(  11)								_hx_tmp2 = ::hx::IsNotNull( temp->mask );
            							}
            							else {
HXLINE(  11)								_hx_tmp2 = false;
            							}
HXDLIN(  11)							if (_hx_tmp2) {
HXLINE(  11)								 ::pi_xy::ImageStruct this4 = temp->mask;
HXDLIN(  11)								::Dynamic this5 = this4->image;
HXDLIN(  11)								int index1;
HXDLIN(  11)								if (this4->useVirtualPos) {
HXLINE(  11)									index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this4->virtualY) * ( (Float)(this4->width) )) + dx) - this4->virtualX));
            								}
            								else {
HXLINE(  11)									index1 = ::Std_obj::_hx_int(( (Float)(((dy * this4->width) + dx)) ));
            								}
HXDLIN(  11)								int c1 = ::iterMagic::Iimg_obj::get(this5,index1);
HXDLIN(  11)								int v1;
HXDLIN(  11)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  11)									v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            								}
            								else {
HXLINE(  11)									v1 = c1;
            								}
HXDLIN(  11)								int maskPixel = v1;
HXDLIN(  11)								int this6 = col;
HXDLIN(  11)								if ((maskPixel == 0)) {
HXLINE(  11)									col = this6;
            								}
            								else {
HXLINE(  11)									Float m0;
HXDLIN(  11)									int this7 = ((maskPixel >> 24) & 255);
HXDLIN(  11)									if ((this7 == 0)) {
HXLINE(  11)										m0 = ((Float)0.);
            									}
            									else {
HXLINE(  11)										m0 = (( (Float)(this7) ) / ( (Float)(255) ));
            									}
HXDLIN(  11)									Float m1;
HXDLIN(  11)									int this8 = ((maskPixel >> 16) & 255);
HXDLIN(  11)									if ((this8 == 0)) {
HXLINE(  11)										m1 = ((Float)0.);
            									}
            									else {
HXLINE(  11)										m1 = (( (Float)(this8) ) / ( (Float)(255) ));
            									}
HXDLIN(  11)									Float m2;
HXDLIN(  11)									int this9 = ((maskPixel >> 8) & 255);
HXDLIN(  11)									if ((this9 == 0)) {
HXLINE(  11)										m2 = ((Float)0.);
            									}
            									else {
HXLINE(  11)										m2 = (( (Float)(this9) ) / ( (Float)(255) ));
            									}
HXDLIN(  11)									Float m3;
HXDLIN(  11)									int this10 = (maskPixel & 255);
HXDLIN(  11)									if ((this10 == 0)) {
HXLINE(  11)										m3 = ((Float)0.);
            									}
            									else {
HXLINE(  11)										m3 = (( (Float)(this10) ) / ( (Float)(255) ));
            									}
HXDLIN(  11)									int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this6 >> 24) & 255)) )));
HXDLIN(  11)									int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this6 >> 16) & 255)) )));
HXDLIN(  11)									int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this6 >> 8) & 255)) )));
HXDLIN(  11)									int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this6 & 255)) )));
HXDLIN(  11)									col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            								}
            							}
HXDLIN(  11)							if ((col != 0)) {
HXLINE(  11)								int x2 = (x1 + dx);
HXDLIN(  11)								int y2 = (y1 + dy);
HXDLIN(  11)								int c2 = col;
HXDLIN(  11)								bool _hx_tmp3;
HXDLIN(  11)								if ((((c2 >> 24) & 255) < 254)) {
HXLINE(  11)									_hx_tmp3 = pixelImage->transparent;
            								}
            								else {
HXLINE(  11)									_hx_tmp3 = false;
            								}
HXDLIN(  11)								if (_hx_tmp3) {
HXLINE(  11)									int location;
HXDLIN(  11)									if (pixelImage->useVirtualPos) {
HXLINE(  11)										location = ::Std_obj::_hx_int(((((( (Float)(y2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x2) - pixelImage->virtualX));
            									}
            									else {
HXLINE(  11)										location = ::Std_obj::_hx_int(( (Float)(((y2 * pixelImage->width) + x2)) ));
            									}
HXDLIN(  11)									int this11 = ::iterMagic::Iimg_obj::get(pixelImage->image,location);
HXDLIN(  11)									int this12;
HXDLIN(  11)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  11)										this12 = ((((((this11 >> 24) & 255) << 24) | ((this11 & 255) << 16)) | (((this11 >> 8) & 255) << 8)) | ((this11 >> 16) & 255));
            									}
            									else {
HXLINE(  11)										this12 = this11;
            									}
HXDLIN(  11)									Float a1;
HXDLIN(  11)									int this13 = ((this12 >> 24) & 255);
HXDLIN(  11)									if ((this13 == 0)) {
HXLINE(  11)										a1 = ((Float)0.);
            									}
            									else {
HXLINE(  11)										a1 = (( (Float)(this13) ) / ( (Float)(255) ));
            									}
HXDLIN(  11)									Float r1;
HXDLIN(  11)									int this14 = ((this12 >> 16) & 255);
HXDLIN(  11)									if ((this14 == 0)) {
HXLINE(  11)										r1 = ((Float)0.);
            									}
            									else {
HXLINE(  11)										r1 = (( (Float)(this14) ) / ( (Float)(255) ));
            									}
HXDLIN(  11)									Float g1;
HXDLIN(  11)									int this15 = ((this12 >> 8) & 255);
HXDLIN(  11)									if ((this15 == 0)) {
HXLINE(  11)										g1 = ((Float)0.);
            									}
            									else {
HXLINE(  11)										g1 = (( (Float)(this15) ) / ( (Float)(255) ));
            									}
HXDLIN(  11)									Float b11;
HXDLIN(  11)									int this16 = (this12 & 255);
HXDLIN(  11)									if ((this16 == 0)) {
HXLINE(  11)										b11 = ((Float)0.);
            									}
            									else {
HXLINE(  11)										b11 = (( (Float)(this16) ) / ( (Float)(255) ));
            									}
HXDLIN(  11)									Float a2;
HXDLIN(  11)									int this17 = ((col >> 24) & 255);
HXDLIN(  11)									if ((this17 == 0)) {
HXLINE(  11)										a2 = ((Float)0.);
            									}
            									else {
HXLINE(  11)										a2 = (( (Float)(this17) ) / ( (Float)(255) ));
            									}
HXDLIN(  11)									Float r2;
HXDLIN(  11)									int this18 = ((col >> 16) & 255);
HXDLIN(  11)									if ((this18 == 0)) {
HXLINE(  11)										r2 = ((Float)0.);
            									}
            									else {
HXLINE(  11)										r2 = (( (Float)(this18) ) / ( (Float)(255) ));
            									}
HXDLIN(  11)									Float g2;
HXDLIN(  11)									int this19 = ((col >> 8) & 255);
HXDLIN(  11)									if ((this19 == 0)) {
HXLINE(  11)										g2 = ((Float)0.);
            									}
            									else {
HXLINE(  11)										g2 = (( (Float)(this19) ) / ( (Float)(255) ));
            									}
HXDLIN(  11)									Float b21;
HXDLIN(  11)									int this20 = (col & 255);
HXDLIN(  11)									if ((this20 == 0)) {
HXLINE(  11)										b21 = ((Float)0.);
            									}
            									else {
HXLINE(  11)										b21 = (( (Float)(this20) ) / ( (Float)(255) ));
            									}
HXDLIN(  11)									Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  11)									int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  11)									int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  11)									int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  11)									int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  11)									int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  11)									{
HXLINE(  11)										int _hx_tmp4;
HXDLIN(  11)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  11)											_hx_tmp4 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            										}
            										else {
HXLINE(  11)											_hx_tmp4 = blended;
            										}
HXDLIN(  11)										::iterMagic::Iimg_obj::set(pixelImage->image,location,_hx_tmp4);
            									}
            								}
            								else {
HXLINE(  11)									::Dynamic this21 = pixelImage->image;
HXDLIN(  11)									int index2;
HXDLIN(  11)									if (pixelImage->useVirtualPos) {
HXLINE(  11)										index2 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x2) - pixelImage->virtualX));
            									}
            									else {
HXLINE(  11)										index2 = ::Std_obj::_hx_int(( (Float)(((y2 * pixelImage->width) + x2)) ));
            									}
HXDLIN(  11)									int _hx_tmp5;
HXDLIN(  11)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  11)										_hx_tmp5 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            									}
            									else {
HXLINE(  11)										_hx_tmp5 = c2;
            									}
HXDLIN(  11)									::iterMagic::Iimg_obj::set(this21,index2,_hx_tmp5);
            								}
            							}
            							else {
HXLINE(  11)								if (forceClear) {
HXLINE(  11)									::Dynamic this22 = pixelImage->image;
HXDLIN(  11)									int x3 = (x1 + dx);
HXDLIN(  11)									int y3 = (y1 + dy);
HXDLIN(  11)									int index3;
HXDLIN(  11)									if (pixelImage->useVirtualPos) {
HXLINE(  11)										index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - pixelImage->virtualY) * ( (Float)(pixelImage->width) )) + x3) - pixelImage->virtualX));
            									}
            									else {
HXLINE(  11)										index3 = ::Std_obj::_hx_int(( (Float)(((y3 * pixelImage->width) + x3)) ));
            									}
HXDLIN(  11)									::iterMagic::Iimg_obj::set(this22,index3,0);
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(  12)		temp = null();
HXLINE(  13)		return pixelImage;
            	}


void CircleForm_obj::buildCircle( ::pi_xy::ImageStruct temp){
            	HX_GC_STACKFRAME(&_hx_pos_925f245d5d5fdd9f_15_buildCircle)
HXLINE(  16)		int w = ::Math_obj::round((this->strokeWidth / ( (Float)(2) )));
HXLINE(  17)		Float r = (this->diameter / ( (Float)(2) ));
HXLINE(  18)		Float innerR = ((this->diameter / ( (Float)(2) )) - ( (Float)((4 * w)) ));
HXLINE(  19)		Float cx = (this->diameter / ( (Float)(2) ));
HXLINE(  20)		Float cy = (this->diameter / ( (Float)(2) ));
HXLINE(  21)		Float phi = ((Float)0.);
HXLINE(  22)		Float innerCx = (cx - (( (Float)(w) ) / ( (Float)(4) )));
HXLINE(  23)		Float innerCy = (cy - (( (Float)(w) ) / ( (Float)(4) )));
HXLINE(  24)		{
HXLINE(  24)			 ::pi_xy::ImageStruct this1 = temp;
HXDLIN(  24)			int color = this->strokeColor;
HXDLIN(  24)			 ::Dynamic phi1 = phi;
HXDLIN(  24)			if (::hx::IsNull( phi1 )) {
HXLINE(  24)				phi1 = 0;
            			}
HXDLIN(  24)			Float rSmall;
HXDLIN(  24)			if ((r > r)) {
HXLINE(  24)				rSmall = r;
            			}
            			else {
HXLINE(  24)				rSmall = r;
            			}
HXDLIN(  24)			 ::Dynamic targetE = ((Float)1.05);
HXDLIN(  24)			if (::hx::IsNull( targetE )) {
HXLINE( 534)				targetE = ((Float)1.05);
            			}
HXLINE(  24)			int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN(  24)			int noSides;
HXDLIN(  24)			if ((result < 12)) {
HXLINE(  24)				noSides = 12;
            			}
            			else {
HXLINE(  24)				if ((result > 500)) {
HXLINE(  24)					noSides = 500;
            				}
            				else {
HXLINE(  24)					noSides = result;
            				}
            			}
HXDLIN(  24)			{
HXLINE(  24)				 ::Dynamic phi2 = phi1;
HXDLIN(  24)				 ::Dynamic sides = noSides;
HXDLIN(  24)				if (::hx::IsNull( sides )) {
HXLINE( 540)					sides = 36;
            				}
HXLINE(  24)				if (::hx::IsNull( phi2 )) {
HXLINE( 539)					phi2 = ((Float)0.);
            				}
HXLINE(  24)				{
HXLINE(  24)					 ::Dynamic phi3 = phi2;
HXDLIN(  24)					 ::Dynamic sides1 = sides;
HXDLIN(  24)					if (::hx::IsNull( sides1 )) {
HXLINE( 212)						sides1 = 36;
            					}
HXLINE(  24)					if (::hx::IsNull( phi3 )) {
HXLINE( 211)						phi3 = ((Float)0.);
            					}
HXLINE(  24)					Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides1) ));
HXDLIN(  24)					Float omega;
HXDLIN(  24)					omega = ((Float)0.);
HXDLIN(  24)					Float lastX = ((Float)0.);
HXDLIN(  24)					Float lastY = ((Float)0.);
HXDLIN(  24)					if (::hx::IsNotEq( phi3,0 )) {
HXLINE(  35)						lastX = ((((r * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi3) ))) - ((r * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi3) )))) + cx);
HXLINE(  36)						lastY = ((((r * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi3) ))) + ((r * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi3) )))) + cy);
            					}
            					else {
HXLINE(  38)						lastX = (cx + (r * ::Math_obj::cos(((( (Float)(sides1) ) * theta) + omega))));
HXLINE(  39)						lastY = (cy + (r * ::Math_obj::sin(((( (Float)(sides1) ) * theta) + omega))));
            					}
HXLINE(  24)					if (::hx::IsNotEq( phi3,0 )) {
HXLINE(  24)						Float cphi = ::Math_obj::cos(( (Float)(phi3) ));
HXDLIN(  24)						Float sphi = ::Math_obj::sin(( (Float)(phi3) ));
HXDLIN(  24)						{
HXLINE(  24)							int _g = 0;
HXDLIN(  24)							int _g1 = (sides1 + 1);
HXDLIN(  24)							while((_g < _g1)){
HXLINE(  24)								_g = (_g + 1);
HXDLIN(  24)								int i = (_g - 1);
HXDLIN(  24)								Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN(  24)								Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + omega) + ((Float)0.01)));
HXDLIN(  24)								Float nextX = ((((r * ctheta) * cphi) - ((r * stheta) * sphi)) + cx);
HXDLIN(  24)								Float nextY = ((((r * ctheta) * sphi) + ((r * stheta) * cphi)) + cy);
HXDLIN(  24)								{
HXLINE(  24)									 ::pi_xy::ImageStruct this2 = this1;
HXDLIN(  24)									bool hasHit = false;
HXDLIN(  24)									bool hasUndo = false;
HXDLIN(  24)									{
HXLINE(  24)										Float bx = lastX;
HXDLIN(  24)										Float by = lastY;
HXDLIN(  24)										Float cx1 = nextX;
HXDLIN(  24)										Float cy1 = nextY;
HXDLIN(  24)										bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN(  24)										if (!(adjustWinding)) {
HXLINE(  24)											Float bx_ = bx;
HXDLIN(  24)											Float by_ = by;
HXLINE(  25)											bx = cx1;
HXLINE(  26)											by = cy1;
HXLINE(  27)											cx1 = bx_;
HXLINE(  28)											cy1 = by_;
            										}
HXLINE(  24)										{
HXLINE(  24)											Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN(  24)											Float sx = (cy1 - cy);
HXDLIN(  24)											Float sy = (cx - cx1);
HXDLIN(  24)											Float t0 = ((cx * by) - (cy * bx));
HXDLIN(  24)											Float tx = (cy - by);
HXDLIN(  24)											Float ty = (bx - cx);
HXDLIN(  24)											Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN(  24)											 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  24)											if ((cx > bx)) {
HXLINE(  24)												if ((cx > cx1)) {
HXLINE(  24)													int min;
HXDLIN(  24)													if ((bx > cx1)) {
HXLINE(  24)														min = ::Math_obj::floor(cx1);
            													}
            													else {
HXLINE(  24)														min = ::Math_obj::floor(bx);
            													}
HXDLIN(  24)													int ii_min = min;
HXDLIN(  24)													int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  24)													xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            												}
            												else {
HXLINE(  24)													int ii_min1 = ::Math_obj::floor(bx);
HXDLIN(  24)													int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN(  24)													xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            												}
            											}
            											else {
HXLINE(  24)												if ((bx > cx1)) {
HXLINE(  24)													int min1;
HXDLIN(  24)													if ((cx > cx1)) {
HXLINE(  24)														min1 = ::Math_obj::floor(cx1);
            													}
            													else {
HXLINE(  24)														min1 = ::Math_obj::ceil(cx);
            													}
HXDLIN(  24)													int ii_min2 = min1;
HXDLIN(  24)													int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN(  24)													xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            												}
            												else {
HXLINE(  24)													int ii_min3 = ::Math_obj::floor(cx);
HXDLIN(  24)													int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN(  24)													xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            												}
            											}
HXDLIN(  24)											 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  24)											if ((cy > by)) {
HXLINE(  24)												if ((cy > cy1)) {
HXLINE(  24)													int min2;
HXDLIN(  24)													if ((by > cy1)) {
HXLINE(  24)														min2 = ::Math_obj::floor(cy1);
            													}
            													else {
HXLINE(  24)														min2 = ::Math_obj::floor(by);
            													}
HXDLIN(  24)													int ii_min4 = min2;
HXDLIN(  24)													int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN(  24)													yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            												}
            												else {
HXLINE(  24)													int ii_min5 = ::Math_obj::floor(by);
HXDLIN(  24)													int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN(  24)													yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            												}
            											}
            											else {
HXLINE(  24)												if ((by > cy1)) {
HXLINE(  24)													int min3;
HXDLIN(  24)													if ((cy > cy1)) {
HXLINE(  24)														min3 = ::Math_obj::floor(cy1);
            													}
            													else {
HXLINE(  24)														min3 = ::Math_obj::ceil(cy);
            													}
HXDLIN(  24)													int ii_min6 = min3;
HXDLIN(  24)													int ii_max6 = ::Math_obj::ceil(by);
HXDLIN(  24)													yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            												}
            												else {
HXLINE(  24)													int ii_min7 = ::Math_obj::floor(cy);
HXDLIN(  24)													int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN(  24)													yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            												}
            											}
HXDLIN(  24)											 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  24)											if (hasUndo) {
HXLINE(  24)												int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  24)												int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  24)												 ::Dynamic imageType = null();
HXDLIN(  24)												 ::pi_xy::ImageStruct this3 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  24)												if (::hx::IsNull( imageType )) {
HXLINE(  54)													imageType = ::pi_xy::ImageStruct_obj::defaultType;
            												}
HXLINE(  24)												::Dynamic undoImage1;
HXDLIN(  24)												switch((int)(( (int)(imageType) ))){
            													case (int)0: {
HXLINE(  24)														 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  24)														 ::iterMagic::BytesImg b = byt;
HXDLIN(  24)														{
HXLINE(  24)															b->width = width;
HXDLIN(  24)															b->height = height;
HXDLIN(  24)															b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  24)															b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  24)															{
HXLINE(  24)																int len = b->length;
HXDLIN(  24)																int w1 = 0;
HXDLIN(  24)																{
HXLINE(  24)																	int _g2 = 0;
HXDLIN(  24)																	int _g3 = b->height;
HXDLIN(  24)																	while((_g2 < _g3)){
HXLINE(  24)																		_g2 = (_g2 + 1);
HXDLIN(  24)																		int y = (_g2 - 1);
HXDLIN(  24)																		{
HXLINE(  24)																			int _g4 = 0;
HXDLIN(  24)																			int _g5 = b->width;
HXDLIN(  24)																			while((_g4 < _g5)){
HXLINE(  24)																				_g4 = (_g4 + 1);
HXDLIN(  24)																				int x = (_g4 - 1);
HXDLIN(  24)																				{
HXLINE(  24)																					w1 = (w1 + 1);
HXDLIN(  24)																					b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																				}
HXDLIN(  24)																				{
HXLINE(  24)																					w1 = (w1 + 1);
HXDLIN(  24)																					b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																				}
HXDLIN(  24)																				{
HXLINE(  24)																					w1 = (w1 + 1);
HXDLIN(  24)																					b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																				}
HXDLIN(  24)																				{
HXLINE(  24)																					w1 = (w1 + 1);
HXDLIN(  24)																					b->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																				}
            																			}
            																		}
            																	}
            																}
            															}
            														}
HXDLIN(  24)														undoImage1 = b;
            													}
            													break;
            													case (int)1: {
HXLINE(  24)														 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  24)														 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  24)														{
HXLINE(  24)															a->width = width;
HXDLIN(  24)															a->height = height;
HXDLIN(  24)															a->data = ::Array_obj< int >::__new(0);
HXDLIN(  24)															a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  24)															{
HXLINE(  24)																int _g6 = 0;
HXDLIN(  24)																int _g7 = a->length;
HXDLIN(  24)																while((_g6 < _g7)){
HXLINE(  24)																	_g6 = (_g6 + 1);
HXDLIN(  24)																	int i1 = (_g6 - 1);
HXDLIN(  24)																	a->data[i1] = 0;
            																}
            															}
            														}
HXDLIN(  24)														undoImage1 = a;
            													}
            													break;
            													case (int)2: {
HXLINE(  24)														 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  24)														 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  24)														{
HXLINE(  24)															b1->width = width;
HXDLIN(  24)															b1->height = height;
HXDLIN(  24)															b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  24)															int size = (b1->length * 4);
HXDLIN(  24)															b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  24)															{
HXLINE(  24)																int _g8 = 0;
HXDLIN(  24)																int _g9 = b1->length;
HXDLIN(  24)																while((_g8 < _g9)){
HXLINE(  24)																	_g8 = (_g8 + 1);
HXDLIN(  24)																	int i2 = (_g8 - 1);
HXDLIN(  24)																	{
HXLINE(  24)																		 ::haxe::io::ArrayBufferViewImpl this4 = b1->data;
HXDLIN(  24)																		bool undoImage2;
HXDLIN(  24)																		if ((i2 >= 0)) {
HXLINE(  24)																			undoImage2 = (i2 < (this4->byteLength >> 2));
            																		}
            																		else {
HXLINE(  24)																			undoImage2 = false;
            																		}
HXDLIN(  24)																		if (undoImage2) {
HXLINE(  24)																			 ::haxe::io::Bytes _this = this4->bytes;
HXDLIN(  24)																			int pos = ((i2 << 2) + this4->byteOffset);
HXDLIN(  24)																			_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  24)																			_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  24)																			_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  24)																			_this->b[(pos + 3)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
HXDLIN(  24)														undoImage1 = b1;
            													}
            													break;
            													case (int)3: {
HXLINE(  24)														 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  24)														 ::iterMagic::VecIntImg v = vec;
HXDLIN(  24)														{
HXLINE(  24)															v->width = width;
HXDLIN(  24)															v->height = height;
HXDLIN(  24)															v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  24)															v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  24)															{
HXLINE(  24)																int _g10 = 0;
HXDLIN(  24)																int _g11 = v->length;
HXDLIN(  24)																while((_g10 < _g11)){
HXLINE(  24)																	_g10 = (_g10 + 1);
HXDLIN(  24)																	int i3 = (_g10 - 1);
HXDLIN(  24)																	v->data->__unsafe_set(i3,0);
            																}
            															}
            														}
HXDLIN(  24)														undoImage1 = v;
            													}
            													break;
            													case (int)4: {
HXLINE(  24)														 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  24)														 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  24)														{
HXLINE(  24)															b2->width = width;
HXDLIN(  24)															b2->height = height;
HXDLIN(  24)															b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  24)															b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  24)															{
HXLINE(  24)																int len1 = b2->length;
HXDLIN(  24)																 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  24)																if (::hx::IsNull( d->head )) {
HXLINE(  24)																	int _g12 = 0;
HXDLIN(  24)																	int _g13 = len1;
HXDLIN(  24)																	while((_g12 < _g13)){
HXLINE(  24)																		_g12 = (_g12 + 1);
HXDLIN(  24)																		int i4 = (_g12 - 1);
HXDLIN(  24)																		d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            																	}
            																}
            																else {
HXLINE(  24)																	int _g14 = 0;
HXDLIN(  24)																	int _g15 = len1;
HXDLIN(  24)																	while((_g14 < _g15)){
HXLINE(  24)																		_g14 = (_g14 + 1);
HXDLIN(  24)																		int i5 = (_g14 - 1);
HXDLIN(  24)																		{
HXLINE(  24)																			 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  24)																			 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  24)																			{
HXLINE(  24)																				int _g16 = 0;
HXDLIN(  24)																				int _g17 = i5;
HXDLIN(  24)																				while((_g16 < _g17)){
HXLINE(  24)																					_g16 = (_g16 + 1);
HXDLIN(  24)																					int i6 = (_g16 - 1);
HXLINE( 345)																					prev = l;
HXLINE( 346)																					l = l->next;
            																				}
            																			}
HXLINE(  24)																			if (::hx::IsNull( prev )) {
HXLINE(  24)																				b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  24)																				l = null();
            																			}
            																			else {
HXLINE(  24)																				prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  24)																				l = null();
            																			}
            																		}
            																	}
            																}
            															}
            														}
HXDLIN(  24)														undoImage1 = b2;
            													}
            													break;
            												}
HXDLIN(  24)												this3->image = undoImage1;
HXDLIN(  24)												this3->width = width;
HXDLIN(  24)												this3->height = height;
HXDLIN(  24)												this3->imageType = ( (int)(imageType) );
HXDLIN(  24)												undoImage = this3;
HXDLIN(  24)												{
HXLINE(  24)													int rectLeft = xIter3->start;
HXDLIN(  24)													int rectTop = yIter3->start;
HXDLIN(  24)													int rectRight = xIter3->max;
HXDLIN(  24)													bool forceClear = false;
HXDLIN(  24)													{
HXLINE(  24)														int _g18 = rectTop;
HXDLIN(  24)														int _g19 = yIter3->max;
HXDLIN(  24)														while((_g18 < _g19)){
HXLINE(  24)															_g18 = (_g18 + 1);
HXDLIN(  24)															int dy = (_g18 - 1);
HXDLIN(  24)															{
HXLINE(  24)																int _g20 = rectLeft;
HXDLIN(  24)																int _g21 = rectRight;
HXDLIN(  24)																while((_g20 < _g21)){
HXLINE(  24)																	_g20 = (_g20 + 1);
HXDLIN(  24)																	int dx = (_g20 - 1);
HXDLIN(  24)																	::Dynamic this5 = this2->image;
HXDLIN(  24)																	int index;
HXDLIN(  24)																	if (this2->useVirtualPos) {
HXLINE(  24)																		index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this2->virtualY) * ( (Float)(this2->width) )) + dx) - this2->virtualX));
            																	}
            																	else {
HXLINE(  24)																		index = ::Std_obj::_hx_int(( (Float)(((dy * this2->width) + dx)) ));
            																	}
HXDLIN(  24)																	int c = ::iterMagic::Iimg_obj::get(this5,index);
HXDLIN(  24)																	int col;
HXDLIN(  24)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)																		col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            																	}
            																	else {
HXLINE(  24)																		col = c;
            																	}
HXDLIN(  24)																	bool _hx_tmp;
HXDLIN(  24)																	if (this2->useMask) {
HXLINE(  24)																		_hx_tmp = ::hx::IsNotNull( this2->mask );
            																	}
            																	else {
HXLINE(  24)																		_hx_tmp = false;
            																	}
HXDLIN(  24)																	if (_hx_tmp) {
HXLINE(  24)																		 ::pi_xy::ImageStruct this6 = this2->mask;
HXDLIN(  24)																		::Dynamic this7 = this6->image;
HXDLIN(  24)																		int index1;
HXDLIN(  24)																		if (this6->useVirtualPos) {
HXLINE(  24)																			index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this6->virtualY) * ( (Float)(this6->width) )) + dx) - this6->virtualX));
            																		}
            																		else {
HXLINE(  24)																			index1 = ::Std_obj::_hx_int(( (Float)(((dy * this6->width) + dx)) ));
            																		}
HXDLIN(  24)																		int c1 = ::iterMagic::Iimg_obj::get(this7,index1);
HXDLIN(  24)																		int v1;
HXDLIN(  24)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)																			v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            																		}
            																		else {
HXLINE(  24)																			v1 = c1;
            																		}
HXDLIN(  24)																		int maskPixel = v1;
HXDLIN(  24)																		int this8 = col;
HXDLIN(  24)																		if ((maskPixel == 0)) {
HXLINE(  24)																			col = this8;
            																		}
            																		else {
HXLINE(  24)																			Float m0;
HXDLIN(  24)																			int this9 = ((maskPixel >> 24) & 255);
HXDLIN(  24)																			if ((this9 == 0)) {
HXLINE(  24)																				m0 = ((Float)0.);
            																			}
            																			else {
HXLINE(  24)																				m0 = (( (Float)(this9) ) / ( (Float)(255) ));
            																			}
HXDLIN(  24)																			Float m1;
HXDLIN(  24)																			int this10 = ((maskPixel >> 16) & 255);
HXDLIN(  24)																			if ((this10 == 0)) {
HXLINE(  24)																				m1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  24)																				m1 = (( (Float)(this10) ) / ( (Float)(255) ));
            																			}
HXDLIN(  24)																			Float m2;
HXDLIN(  24)																			int this11 = ((maskPixel >> 8) & 255);
HXDLIN(  24)																			if ((this11 == 0)) {
HXLINE(  24)																				m2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  24)																				m2 = (( (Float)(this11) ) / ( (Float)(255) ));
            																			}
HXDLIN(  24)																			Float m3;
HXDLIN(  24)																			int this12 = (maskPixel & 255);
HXDLIN(  24)																			if ((this12 == 0)) {
HXLINE(  24)																				m3 = ((Float)0.);
            																			}
            																			else {
HXLINE(  24)																				m3 = (( (Float)(this12) ) / ( (Float)(255) ));
            																			}
HXDLIN(  24)																			int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this8 >> 24) & 255)) )));
HXDLIN(  24)																			int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this8 >> 16) & 255)) )));
HXDLIN(  24)																			int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this8 >> 8) & 255)) )));
HXDLIN(  24)																			int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this8 & 255)) )));
HXDLIN(  24)																			col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            																		}
            																	}
HXDLIN(  24)																	if ((col != 0)) {
HXLINE(  24)																		int x1 = (dx - rectLeft);
HXDLIN(  24)																		int y1 = (dy - rectTop);
HXDLIN(  24)																		int c2 = col;
HXDLIN(  24)																		bool _hx_tmp1;
HXDLIN(  24)																		if ((((c2 >> 24) & 255) < 254)) {
HXLINE(  24)																			_hx_tmp1 = undoImage->transparent;
            																		}
            																		else {
HXLINE(  24)																			_hx_tmp1 = false;
            																		}
HXDLIN(  24)																		if (_hx_tmp1) {
HXLINE(  24)																			int location;
HXDLIN(  24)																			if (undoImage->useVirtualPos) {
HXLINE(  24)																				location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  24)																				location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																			}
HXDLIN(  24)																			int this13 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN(  24)																			int this14;
HXDLIN(  24)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)																				this14 = ((((((this13 >> 24) & 255) << 24) | ((this13 & 255) << 16)) | (((this13 >> 8) & 255) << 8)) | ((this13 >> 16) & 255));
            																			}
            																			else {
HXLINE(  24)																				this14 = this13;
            																			}
HXDLIN(  24)																			Float a1;
HXDLIN(  24)																			int this15 = ((this14 >> 24) & 255);
HXDLIN(  24)																			if ((this15 == 0)) {
HXLINE(  24)																				a1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  24)																				a1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																			}
HXDLIN(  24)																			Float r1;
HXDLIN(  24)																			int this16 = ((this14 >> 16) & 255);
HXDLIN(  24)																			if ((this16 == 0)) {
HXLINE(  24)																				r1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  24)																				r1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																			}
HXDLIN(  24)																			Float g1;
HXDLIN(  24)																			int this17 = ((this14 >> 8) & 255);
HXDLIN(  24)																			if ((this17 == 0)) {
HXLINE(  24)																				g1 = ((Float)0.);
            																			}
            																			else {
HXLINE(  24)																				g1 = (( (Float)(this17) ) / ( (Float)(255) ));
            																			}
HXDLIN(  24)																			Float b11;
HXDLIN(  24)																			int this18 = (this14 & 255);
HXDLIN(  24)																			if ((this18 == 0)) {
HXLINE(  24)																				b11 = ((Float)0.);
            																			}
            																			else {
HXLINE(  24)																				b11 = (( (Float)(this18) ) / ( (Float)(255) ));
            																			}
HXDLIN(  24)																			Float a2;
HXDLIN(  24)																			int this19 = ((col >> 24) & 255);
HXDLIN(  24)																			if ((this19 == 0)) {
HXLINE(  24)																				a2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  24)																				a2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																			}
HXDLIN(  24)																			Float r2;
HXDLIN(  24)																			int this20 = ((col >> 16) & 255);
HXDLIN(  24)																			if ((this20 == 0)) {
HXLINE(  24)																				r2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  24)																				r2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																			}
HXDLIN(  24)																			Float g2;
HXDLIN(  24)																			int this21 = ((col >> 8) & 255);
HXDLIN(  24)																			if ((this21 == 0)) {
HXLINE(  24)																				g2 = ((Float)0.);
            																			}
            																			else {
HXLINE(  24)																				g2 = (( (Float)(this21) ) / ( (Float)(255) ));
            																			}
HXDLIN(  24)																			Float b21;
HXDLIN(  24)																			int this22 = (col & 255);
HXDLIN(  24)																			if ((this22 == 0)) {
HXLINE(  24)																				b21 = ((Float)0.);
            																			}
            																			else {
HXLINE(  24)																				b21 = (( (Float)(this22) ) / ( (Float)(255) ));
            																			}
HXDLIN(  24)																			Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  24)																			int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  24)																			int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  24)																			int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  24)																			int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  24)																			int blended = ((((a4 << 24) | (r3 << 16)) | (g << 8)) | b3);
HXDLIN(  24)																			{
HXLINE(  24)																				int _hx_tmp2;
HXDLIN(  24)																				if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)																					_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																				}
            																				else {
HXLINE(  24)																					_hx_tmp2 = blended;
            																				}
HXDLIN(  24)																				::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																			}
            																		}
            																		else {
HXLINE(  24)																			::Dynamic this23 = undoImage->image;
HXDLIN(  24)																			int index2;
HXDLIN(  24)																			if (undoImage->useVirtualPos) {
HXLINE(  24)																				index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  24)																				index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																			}
HXDLIN(  24)																			int _hx_tmp3;
HXDLIN(  24)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)																				_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																			}
            																			else {
HXLINE(  24)																				_hx_tmp3 = c2;
            																			}
HXDLIN(  24)																			::iterMagic::Iimg_obj::set(this23,index2,_hx_tmp3);
            																		}
            																	}
            																	else {
HXLINE(  24)																		if (forceClear) {
HXLINE(  24)																			::Dynamic this24 = undoImage->image;
HXDLIN(  24)																			int x2 = (dx - rectLeft);
HXDLIN(  24)																			int y2 = (dy - rectTop);
HXDLIN(  24)																			int index3;
HXDLIN(  24)																			if (undoImage->useVirtualPos) {
HXLINE(  24)																				index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																			}
            																			else {
HXLINE(  24)																				index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																			}
HXDLIN(  24)																			::iterMagic::Iimg_obj::set(this24,index3,0);
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  24)											bool found = false;
HXDLIN(  24)											Float s = ((Float)0.);
HXDLIN(  24)											Float t = ((Float)0.);
HXDLIN(  24)											Float sxx = ((Float)0.);
HXDLIN(  24)											Float txx = ((Float)0.);
HXDLIN(  24)											{
HXLINE(  24)												int _g_min = xIter3->start;
HXDLIN(  24)												int _g_max = xIter3->max;
HXDLIN(  24)												while((_g_min < _g_max)){
HXLINE(  24)													_g_min = (_g_min + 1);
HXDLIN(  24)													int x3 = (_g_min - 1);
HXLINE(  60)													sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)													txx = (tx * ( (Float)(x3) ));
HXLINE(  62)													found = false;
HXLINE(  24)													{
HXLINE(  24)														int _g_min1 = yIter3->start;
HXDLIN(  24)														int _g_max1 = yIter3->max;
HXDLIN(  24)														while((_g_min1 < _g_max1)){
HXLINE(  24)															_g_min1 = (_g_min1 + 1);
HXDLIN(  24)															int y3 = (_g_min1 - 1);
HXLINE(  64)															s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)															t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE(  24)															bool _hx_tmp4;
HXDLIN(  24)															if (!((s <= 0))) {
HXLINE(  24)																_hx_tmp4 = (t <= 0);
            															}
            															else {
HXLINE(  24)																_hx_tmp4 = true;
            															}
HXDLIN(  24)															if (_hx_tmp4) {
HXLINE(  24)																if (found) {
HXLINE(  24)																	goto _hx_goto_24;
            																}
            															}
            															else {
HXLINE(  24)																if (((s + t) < A)) {
HXLINE(  24)																	{
HXLINE(  24)																		int c3 = color;
HXDLIN(  24)																		bool _hx_tmp5;
HXDLIN(  24)																		if ((((c3 >> 24) & 255) < 254)) {
HXLINE(  24)																			_hx_tmp5 = this2->transparent;
            																		}
            																		else {
HXLINE(  24)																			_hx_tmp5 = false;
            																		}
HXDLIN(  24)																		if (_hx_tmp5) {
HXLINE(  24)																			int location1;
HXDLIN(  24)																			if (this2->useVirtualPos) {
HXLINE(  24)																				location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																			}
            																			else {
HXLINE(  24)																				location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																			}
HXDLIN(  24)																			int this25 = ::iterMagic::Iimg_obj::get(this2->image,location1);
HXDLIN(  24)																			int this26;
HXDLIN(  24)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)																				this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            																			}
            																			else {
HXLINE(  24)																				this26 = this25;
            																			}
HXDLIN(  24)																			Float a11;
HXDLIN(  24)																			int this27 = ((this26 >> 24) & 255);
HXDLIN(  24)																			if ((this27 == 0)) {
HXLINE(  24)																				a11 = ((Float)0.);
            																			}
            																			else {
HXLINE(  24)																				a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            																			}
HXDLIN(  24)																			Float r11;
HXDLIN(  24)																			int this28 = ((this26 >> 16) & 255);
HXDLIN(  24)																			if ((this28 == 0)) {
HXLINE(  24)																				r11 = ((Float)0.);
            																			}
            																			else {
HXLINE(  24)																				r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																			}
HXDLIN(  24)																			Float g11;
HXDLIN(  24)																			int this29 = ((this26 >> 8) & 255);
HXDLIN(  24)																			if ((this29 == 0)) {
HXLINE(  24)																				g11 = ((Float)0.);
            																			}
            																			else {
HXLINE(  24)																				g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																			}
HXDLIN(  24)																			Float b12;
HXDLIN(  24)																			int this30 = (this26 & 255);
HXDLIN(  24)																			if ((this30 == 0)) {
HXLINE(  24)																				b12 = ((Float)0.);
            																			}
            																			else {
HXLINE(  24)																				b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            																			}
HXDLIN(  24)																			Float a21;
HXDLIN(  24)																			int this31 = ((color >> 24) & 255);
HXDLIN(  24)																			if ((this31 == 0)) {
HXLINE(  24)																				a21 = ((Float)0.);
            																			}
            																			else {
HXLINE(  24)																				a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            																			}
HXDLIN(  24)																			Float r21;
HXDLIN(  24)																			int this32 = ((color >> 16) & 255);
HXDLIN(  24)																			if ((this32 == 0)) {
HXLINE(  24)																				r21 = ((Float)0.);
            																			}
            																			else {
HXLINE(  24)																				r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																			}
HXDLIN(  24)																			Float g21;
HXDLIN(  24)																			int this33 = ((color >> 8) & 255);
HXDLIN(  24)																			if ((this33 == 0)) {
HXLINE(  24)																				g21 = ((Float)0.);
            																			}
            																			else {
HXLINE(  24)																				g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																			}
HXDLIN(  24)																			Float b22;
HXDLIN(  24)																			int this34 = (color & 255);
HXDLIN(  24)																			if ((this34 == 0)) {
HXLINE(  24)																				b22 = ((Float)0.);
            																			}
            																			else {
HXLINE(  24)																				b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            																			}
HXDLIN(  24)																			Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  24)																			int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  24)																			int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  24)																			int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  24)																			int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  24)																			int blended1 = ((((a5 << 24) | (r4 << 16)) | (g3 << 8)) | b4);
HXDLIN(  24)																			{
HXLINE(  24)																				int _hx_tmp6;
HXDLIN(  24)																				if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)																					_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																				}
            																				else {
HXLINE(  24)																					_hx_tmp6 = blended1;
            																				}
HXDLIN(  24)																				::iterMagic::Iimg_obj::set(this2->image,location1,_hx_tmp6);
            																			}
            																		}
            																		else {
HXLINE(  24)																			::Dynamic this35 = this2->image;
HXDLIN(  24)																			int index4;
HXDLIN(  24)																			if (this2->useVirtualPos) {
HXLINE(  24)																				index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this2->virtualY) * ( (Float)(this2->width) )) + x3) - this2->virtualX));
            																			}
            																			else {
HXLINE(  24)																				index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this2->width) + x3)) ));
            																			}
HXDLIN(  24)																			int _hx_tmp7;
HXDLIN(  24)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)																				_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  24)																				_hx_tmp7 = c3;
            																			}
HXDLIN(  24)																			::iterMagic::Iimg_obj::set(this35,index4,_hx_tmp7);
            																		}
            																	}
HXLINE(  73)																	found = true;
            																}
            																else {
HXLINE(  24)																	if (found) {
HXLINE(  24)																		goto _hx_goto_24;
            																	}
            																}
            															}
            														}
            														_hx_goto_24:;
            													}
            												}
            											}
HXDLIN(  24)											if ((hasHit == true)) {
HXLINE(  24)												 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN(  24)												if (hasUndo) {
HXLINE(  24)													v2->undoImage = undoImage;
HXDLIN(  24)													v2->undoX = xIter3->start;
HXDLIN(  24)													v2->undoY = yIter3->start;
            												}
            											}
            										}
            									}
            								}
HXLINE(  51)								lastX = nextX;
HXLINE(  52)								lastY = nextY;
            							}
            						}
            					}
            					else {
HXLINE(  24)						int _g22 = 0;
HXDLIN(  24)						int _g23 = (sides1 + 1);
HXDLIN(  24)						while((_g22 < _g23)){
HXLINE(  24)							_g22 = (_g22 + 1);
HXDLIN(  24)							int i7 = (_g22 - 1);
HXDLIN(  24)							Float nextX1 = (cx + (r * ::Math_obj::cos((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN(  24)							Float nextY1 = (cy + (r * ::Math_obj::sin((((( (Float)(i7) ) * theta) + omega) + ((Float)0.01)))));
HXDLIN(  24)							{
HXLINE(  24)								 ::pi_xy::ImageStruct this36 = this1;
HXDLIN(  24)								bool hasHit1 = false;
HXDLIN(  24)								bool hasUndo1 = false;
HXDLIN(  24)								{
HXLINE(  24)									Float bx1 = lastX;
HXDLIN(  24)									Float by1 = lastY;
HXDLIN(  24)									Float cx2 = nextX1;
HXDLIN(  24)									Float cy2 = nextY1;
HXDLIN(  24)									bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN(  24)									if (!(adjustWinding1)) {
HXLINE(  24)										Float bx_1 = bx1;
HXDLIN(  24)										Float by_1 = by1;
HXLINE(  25)										bx1 = cx2;
HXLINE(  26)										by1 = cy2;
HXLINE(  27)										cx2 = bx_1;
HXLINE(  28)										cy2 = by_1;
            									}
HXLINE(  24)									{
HXLINE(  24)										Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN(  24)										Float sx1 = (cy2 - cy);
HXDLIN(  24)										Float sy1 = (cx - cx2);
HXDLIN(  24)										Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN(  24)										Float tx1 = (cy - by1);
HXDLIN(  24)										Float ty1 = (bx1 - cx);
HXDLIN(  24)										Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN(  24)										 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  24)										if ((cx > bx1)) {
HXLINE(  24)											if ((cx > cx2)) {
HXLINE(  24)												int min4;
HXDLIN(  24)												if ((bx1 > cx2)) {
HXLINE(  24)													min4 = ::Math_obj::floor(cx2);
            												}
            												else {
HXLINE(  24)													min4 = ::Math_obj::floor(bx1);
            												}
HXDLIN(  24)												int ii_min8 = min4;
HXDLIN(  24)												int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN(  24)												xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            											}
            											else {
HXLINE(  24)												int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN(  24)												int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN(  24)												xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            											}
            										}
            										else {
HXLINE(  24)											if ((bx1 > cx2)) {
HXLINE(  24)												int min5;
HXDLIN(  24)												if ((cx > cx2)) {
HXLINE(  24)													min5 = ::Math_obj::floor(cx2);
            												}
            												else {
HXLINE(  24)													min5 = ::Math_obj::ceil(cx);
            												}
HXDLIN(  24)												int ii_min10 = min5;
HXDLIN(  24)												int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN(  24)												xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            											}
            											else {
HXLINE(  24)												int ii_min11 = ::Math_obj::floor(cx);
HXDLIN(  24)												int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN(  24)												xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            											}
            										}
HXDLIN(  24)										 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  24)										if ((cy > by1)) {
HXLINE(  24)											if ((cy > cy2)) {
HXLINE(  24)												int min6;
HXDLIN(  24)												if ((by1 > cy2)) {
HXLINE(  24)													min6 = ::Math_obj::floor(cy2);
            												}
            												else {
HXLINE(  24)													min6 = ::Math_obj::floor(by1);
            												}
HXDLIN(  24)												int ii_min12 = min6;
HXDLIN(  24)												int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN(  24)												yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            											}
            											else {
HXLINE(  24)												int ii_min13 = ::Math_obj::floor(by1);
HXDLIN(  24)												int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN(  24)												yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            											}
            										}
            										else {
HXLINE(  24)											if ((by1 > cy2)) {
HXLINE(  24)												int min7;
HXDLIN(  24)												if ((cy > cy2)) {
HXLINE(  24)													min7 = ::Math_obj::floor(cy2);
            												}
            												else {
HXLINE(  24)													min7 = ::Math_obj::ceil(cy);
            												}
HXDLIN(  24)												int ii_min14 = min7;
HXDLIN(  24)												int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN(  24)												yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            											}
            											else {
HXLINE(  24)												int ii_min15 = ::Math_obj::floor(cy);
HXDLIN(  24)												int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN(  24)												yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            											}
            										}
HXDLIN(  24)										 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  24)										if (hasUndo1) {
HXLINE(  24)											int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  24)											int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  24)											 ::Dynamic imageType1 = null();
HXDLIN(  24)											 ::pi_xy::ImageStruct this37 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  24)											if (::hx::IsNull( imageType1 )) {
HXLINE(  54)												imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            											}
HXLINE(  24)											::Dynamic undoImage4;
HXDLIN(  24)											switch((int)(( (int)(imageType1) ))){
            												case (int)0: {
HXLINE(  24)													 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  24)													 ::iterMagic::BytesImg b5 = byt1;
HXDLIN(  24)													{
HXLINE(  24)														b5->width = width1;
HXDLIN(  24)														b5->height = height1;
HXDLIN(  24)														b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  24)														b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN(  24)														{
HXLINE(  24)															int len2 = b5->length;
HXDLIN(  24)															int w2 = 0;
HXDLIN(  24)															{
HXLINE(  24)																int _g24 = 0;
HXDLIN(  24)																int _g25 = b5->height;
HXDLIN(  24)																while((_g24 < _g25)){
HXLINE(  24)																	_g24 = (_g24 + 1);
HXDLIN(  24)																	int y4 = (_g24 - 1);
HXDLIN(  24)																	{
HXLINE(  24)																		int _g26 = 0;
HXDLIN(  24)																		int _g27 = b5->width;
HXDLIN(  24)																		while((_g26 < _g27)){
HXLINE(  24)																			_g26 = (_g26 + 1);
HXDLIN(  24)																			int x4 = (_g26 - 1);
HXDLIN(  24)																			{
HXLINE(  24)																				w2 = (w2 + 1);
HXDLIN(  24)																				b5->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN(  24)																			{
HXLINE(  24)																				w2 = (w2 + 1);
HXDLIN(  24)																				b5->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN(  24)																			{
HXLINE(  24)																				w2 = (w2 + 1);
HXDLIN(  24)																				b5->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN(  24)																			{
HXLINE(  24)																				w2 = (w2 + 1);
HXDLIN(  24)																				b5->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
HXDLIN(  24)													undoImage4 = b5;
            												}
            												break;
            												case (int)1: {
HXLINE(  24)													 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  24)													 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN(  24)													{
HXLINE(  24)														a6->width = width1;
HXDLIN(  24)														a6->height = height1;
HXDLIN(  24)														a6->data = ::Array_obj< int >::__new(0);
HXDLIN(  24)														a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  24)														{
HXLINE(  24)															int _g28 = 0;
HXDLIN(  24)															int _g29 = a6->length;
HXDLIN(  24)															while((_g28 < _g29)){
HXLINE(  24)																_g28 = (_g28 + 1);
HXDLIN(  24)																int i8 = (_g28 - 1);
HXDLIN(  24)																a6->data[i8] = 0;
            															}
            														}
            													}
HXDLIN(  24)													undoImage4 = a6;
            												}
            												break;
            												case (int)2: {
HXLINE(  24)													 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  24)													 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN(  24)													{
HXLINE(  24)														b6->width = width1;
HXDLIN(  24)														b6->height = height1;
HXDLIN(  24)														b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  24)														int size1 = (b6->length * 4);
HXDLIN(  24)														b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  24)														{
HXLINE(  24)															int _g30 = 0;
HXDLIN(  24)															int _g31 = b6->length;
HXDLIN(  24)															while((_g30 < _g31)){
HXLINE(  24)																_g30 = (_g30 + 1);
HXDLIN(  24)																int i9 = (_g30 - 1);
HXDLIN(  24)																{
HXLINE(  24)																	 ::haxe::io::ArrayBufferViewImpl this38 = b6->data;
HXDLIN(  24)																	bool undoImage5;
HXDLIN(  24)																	if ((i9 >= 0)) {
HXLINE(  24)																		undoImage5 = (i9 < (this38->byteLength >> 2));
            																	}
            																	else {
HXLINE(  24)																		undoImage5 = false;
            																	}
HXDLIN(  24)																	if (undoImage5) {
HXLINE(  24)																		 ::haxe::io::Bytes _this1 = this38->bytes;
HXDLIN(  24)																		int pos1 = ((i9 << 2) + this38->byteOffset);
HXDLIN(  24)																		_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  24)																		_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  24)																		_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  24)																		_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
HXDLIN(  24)													undoImage4 = b6;
            												}
            												break;
            												case (int)3: {
HXLINE(  24)													 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  24)													 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN(  24)													{
HXLINE(  24)														v3->width = width1;
HXDLIN(  24)														v3->height = height1;
HXDLIN(  24)														v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  24)														v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN(  24)														{
HXLINE(  24)															int _g32 = 0;
HXDLIN(  24)															int _g33 = v3->length;
HXDLIN(  24)															while((_g32 < _g33)){
HXLINE(  24)																_g32 = (_g32 + 1);
HXDLIN(  24)																int i10 = (_g32 - 1);
HXDLIN(  24)																v3->data->__unsafe_set(i10,0);
            															}
            														}
            													}
HXDLIN(  24)													undoImage4 = v3;
            												}
            												break;
            												case (int)4: {
HXLINE(  24)													 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  24)													 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN(  24)													{
HXLINE(  24)														b7->width = width1;
HXDLIN(  24)														b7->height = height1;
HXDLIN(  24)														b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  24)														b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  24)														{
HXLINE(  24)															int len3 = b7->length;
HXDLIN(  24)															 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN(  24)															if (::hx::IsNull( d1->head )) {
HXLINE(  24)																int _g34 = 0;
HXDLIN(  24)																int _g35 = len3;
HXDLIN(  24)																while((_g34 < _g35)){
HXLINE(  24)																	_g34 = (_g34 + 1);
HXDLIN(  24)																	int i11 = (_g34 - 1);
HXDLIN(  24)																	d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            																}
            															}
            															else {
HXLINE(  24)																int _g36 = 0;
HXDLIN(  24)																int _g37 = len3;
HXDLIN(  24)																while((_g36 < _g37)){
HXLINE(  24)																	_g36 = (_g36 + 1);
HXDLIN(  24)																	int i12 = (_g36 - 1);
HXDLIN(  24)																	{
HXLINE(  24)																		 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN(  24)																		 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  24)																		{
HXLINE(  24)																			int _g38 = 0;
HXDLIN(  24)																			int _g39 = i12;
HXDLIN(  24)																			while((_g38 < _g39)){
HXLINE(  24)																				_g38 = (_g38 + 1);
HXDLIN(  24)																				int i13 = (_g38 - 1);
HXLINE( 345)																				prev1 = l1;
HXLINE( 346)																				l1 = l1->next;
            																			}
            																		}
HXLINE(  24)																		if (::hx::IsNull( prev1 )) {
HXLINE(  24)																			b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  24)																			l1 = null();
            																		}
            																		else {
HXLINE(  24)																			prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  24)																			l1 = null();
            																		}
            																	}
            																}
            															}
            														}
            													}
HXDLIN(  24)													undoImage4 = b7;
            												}
            												break;
            											}
HXDLIN(  24)											this37->image = undoImage4;
HXDLIN(  24)											this37->width = width1;
HXDLIN(  24)											this37->height = height1;
HXDLIN(  24)											this37->imageType = ( (int)(imageType1) );
HXDLIN(  24)											undoImage3 = this37;
HXDLIN(  24)											{
HXLINE(  24)												int rectLeft1 = xIter31->start;
HXDLIN(  24)												int rectTop1 = yIter31->start;
HXDLIN(  24)												int rectRight1 = xIter31->max;
HXDLIN(  24)												bool forceClear1 = false;
HXDLIN(  24)												{
HXLINE(  24)													int _g40 = rectTop1;
HXDLIN(  24)													int _g41 = yIter31->max;
HXDLIN(  24)													while((_g40 < _g41)){
HXLINE(  24)														_g40 = (_g40 + 1);
HXDLIN(  24)														int dy1 = (_g40 - 1);
HXDLIN(  24)														{
HXLINE(  24)															int _g42 = rectLeft1;
HXDLIN(  24)															int _g43 = rectRight1;
HXDLIN(  24)															while((_g42 < _g43)){
HXLINE(  24)																_g42 = (_g42 + 1);
HXDLIN(  24)																int dx1 = (_g42 - 1);
HXDLIN(  24)																::Dynamic this39 = this36->image;
HXDLIN(  24)																int index5;
HXDLIN(  24)																if (this36->useVirtualPos) {
HXLINE(  24)																	index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx1) - this36->virtualX));
            																}
            																else {
HXLINE(  24)																	index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this36->width) + dx1)) ));
            																}
HXDLIN(  24)																int c4 = ::iterMagic::Iimg_obj::get(this39,index5);
HXDLIN(  24)																int col1;
HXDLIN(  24)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)																	col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            																}
            																else {
HXLINE(  24)																	col1 = c4;
            																}
HXDLIN(  24)																bool _hx_tmp8;
HXDLIN(  24)																if (this36->useMask) {
HXLINE(  24)																	_hx_tmp8 = ::hx::IsNotNull( this36->mask );
            																}
            																else {
HXLINE(  24)																	_hx_tmp8 = false;
            																}
HXDLIN(  24)																if (_hx_tmp8) {
HXLINE(  24)																	 ::pi_xy::ImageStruct this40 = this36->mask;
HXDLIN(  24)																	::Dynamic this41 = this40->image;
HXDLIN(  24)																	int index6;
HXDLIN(  24)																	if (this40->useVirtualPos) {
HXLINE(  24)																		index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this40->virtualY) * ( (Float)(this40->width) )) + dx1) - this40->virtualX));
            																	}
            																	else {
HXLINE(  24)																		index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this40->width) + dx1)) ));
            																	}
HXDLIN(  24)																	int c5 = ::iterMagic::Iimg_obj::get(this41,index6);
HXDLIN(  24)																	int v4;
HXDLIN(  24)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)																		v4 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            																	}
            																	else {
HXLINE(  24)																		v4 = c5;
            																	}
HXDLIN(  24)																	int maskPixel1 = v4;
HXDLIN(  24)																	int this42 = col1;
HXDLIN(  24)																	if ((maskPixel1 == 0)) {
HXLINE(  24)																		col1 = this42;
            																	}
            																	else {
HXLINE(  24)																		Float m01;
HXDLIN(  24)																		int this43 = ((maskPixel1 >> 24) & 255);
HXDLIN(  24)																		if ((this43 == 0)) {
HXLINE(  24)																			m01 = ((Float)0.);
            																		}
            																		else {
HXLINE(  24)																			m01 = (( (Float)(this43) ) / ( (Float)(255) ));
            																		}
HXDLIN(  24)																		Float m11;
HXDLIN(  24)																		int this44 = ((maskPixel1 >> 16) & 255);
HXDLIN(  24)																		if ((this44 == 0)) {
HXLINE(  24)																			m11 = ((Float)0.);
            																		}
            																		else {
HXLINE(  24)																			m11 = (( (Float)(this44) ) / ( (Float)(255) ));
            																		}
HXDLIN(  24)																		Float m21;
HXDLIN(  24)																		int this45 = ((maskPixel1 >> 8) & 255);
HXDLIN(  24)																		if ((this45 == 0)) {
HXLINE(  24)																			m21 = ((Float)0.);
            																		}
            																		else {
HXLINE(  24)																			m21 = (( (Float)(this45) ) / ( (Float)(255) ));
            																		}
HXDLIN(  24)																		Float m31;
HXDLIN(  24)																		int this46 = (maskPixel1 & 255);
HXDLIN(  24)																		if ((this46 == 0)) {
HXLINE(  24)																			m31 = ((Float)0.);
            																		}
            																		else {
HXLINE(  24)																			m31 = (( (Float)(this46) ) / ( (Float)(255) ));
            																		}
HXDLIN(  24)																		int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this42 >> 24) & 255)) )));
HXDLIN(  24)																		int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this42 >> 16) & 255)) )));
HXDLIN(  24)																		int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this42 >> 8) & 255)) )));
HXDLIN(  24)																		int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this42 & 255)) )));
HXDLIN(  24)																		col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            																	}
            																}
HXDLIN(  24)																if ((col1 != 0)) {
HXLINE(  24)																	int x5 = (dx1 - rectLeft1);
HXDLIN(  24)																	int y5 = (dy1 - rectTop1);
HXDLIN(  24)																	int c6 = col1;
HXDLIN(  24)																	bool _hx_tmp9;
HXDLIN(  24)																	if ((((c6 >> 24) & 255) < 254)) {
HXLINE(  24)																		_hx_tmp9 = undoImage3->transparent;
            																	}
            																	else {
HXLINE(  24)																		_hx_tmp9 = false;
            																	}
HXDLIN(  24)																	if (_hx_tmp9) {
HXLINE(  24)																		int location2;
HXDLIN(  24)																		if (undoImage3->useVirtualPos) {
HXLINE(  24)																			location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																		}
            																		else {
HXLINE(  24)																			location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																		}
HXDLIN(  24)																		int this47 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN(  24)																		int this48;
HXDLIN(  24)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)																			this48 = ((((((this47 >> 24) & 255) << 24) | ((this47 & 255) << 16)) | (((this47 >> 8) & 255) << 8)) | ((this47 >> 16) & 255));
            																		}
            																		else {
HXLINE(  24)																			this48 = this47;
            																		}
HXDLIN(  24)																		Float a12;
HXDLIN(  24)																		int this49 = ((this48 >> 24) & 255);
HXDLIN(  24)																		if ((this49 == 0)) {
HXLINE(  24)																			a12 = ((Float)0.);
            																		}
            																		else {
HXLINE(  24)																			a12 = (( (Float)(this49) ) / ( (Float)(255) ));
            																		}
HXDLIN(  24)																		Float r12;
HXDLIN(  24)																		int this50 = ((this48 >> 16) & 255);
HXDLIN(  24)																		if ((this50 == 0)) {
HXLINE(  24)																			r12 = ((Float)0.);
            																		}
            																		else {
HXLINE(  24)																			r12 = (( (Float)(this50) ) / ( (Float)(255) ));
            																		}
HXDLIN(  24)																		Float g12;
HXDLIN(  24)																		int this51 = ((this48 >> 8) & 255);
HXDLIN(  24)																		if ((this51 == 0)) {
HXLINE(  24)																			g12 = ((Float)0.);
            																		}
            																		else {
HXLINE(  24)																			g12 = (( (Float)(this51) ) / ( (Float)(255) ));
            																		}
HXDLIN(  24)																		Float b13;
HXDLIN(  24)																		int this52 = (this48 & 255);
HXDLIN(  24)																		if ((this52 == 0)) {
HXLINE(  24)																			b13 = ((Float)0.);
            																		}
            																		else {
HXLINE(  24)																			b13 = (( (Float)(this52) ) / ( (Float)(255) ));
            																		}
HXDLIN(  24)																		Float a22;
HXDLIN(  24)																		int this53 = ((col1 >> 24) & 255);
HXDLIN(  24)																		if ((this53 == 0)) {
HXLINE(  24)																			a22 = ((Float)0.);
            																		}
            																		else {
HXLINE(  24)																			a22 = (( (Float)(this53) ) / ( (Float)(255) ));
            																		}
HXDLIN(  24)																		Float r22;
HXDLIN(  24)																		int this54 = ((col1 >> 16) & 255);
HXDLIN(  24)																		if ((this54 == 0)) {
HXLINE(  24)																			r22 = ((Float)0.);
            																		}
            																		else {
HXLINE(  24)																			r22 = (( (Float)(this54) ) / ( (Float)(255) ));
            																		}
HXDLIN(  24)																		Float g22;
HXDLIN(  24)																		int this55 = ((col1 >> 8) & 255);
HXDLIN(  24)																		if ((this55 == 0)) {
HXLINE(  24)																			g22 = ((Float)0.);
            																		}
            																		else {
HXLINE(  24)																			g22 = (( (Float)(this55) ) / ( (Float)(255) ));
            																		}
HXDLIN(  24)																		Float b23;
HXDLIN(  24)																		int this56 = (col1 & 255);
HXDLIN(  24)																		if ((this56 == 0)) {
HXLINE(  24)																			b23 = ((Float)0.);
            																		}
            																		else {
HXLINE(  24)																			b23 = (( (Float)(this56) ) / ( (Float)(255) ));
            																		}
HXDLIN(  24)																		Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  24)																		int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  24)																		int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  24)																		int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  24)																		int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  24)																		int blended2 = ((((a7 << 24) | (r5 << 16)) | (g4 << 8)) | b8);
HXDLIN(  24)																		{
HXLINE(  24)																			int _hx_tmp10;
HXDLIN(  24)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)																				_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																			}
            																			else {
HXLINE(  24)																				_hx_tmp10 = blended2;
            																			}
HXDLIN(  24)																			::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            																		}
            																	}
            																	else {
HXLINE(  24)																		::Dynamic this57 = undoImage3->image;
HXDLIN(  24)																		int index7;
HXDLIN(  24)																		if (undoImage3->useVirtualPos) {
HXLINE(  24)																			index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            																		}
            																		else {
HXLINE(  24)																			index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            																		}
HXDLIN(  24)																		int _hx_tmp11;
HXDLIN(  24)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)																			_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            																		}
            																		else {
HXLINE(  24)																			_hx_tmp11 = c6;
            																		}
HXDLIN(  24)																		::iterMagic::Iimg_obj::set(this57,index7,_hx_tmp11);
            																	}
            																}
            																else {
HXLINE(  24)																	if (forceClear1) {
HXLINE(  24)																		::Dynamic this58 = undoImage3->image;
HXDLIN(  24)																		int x6 = (dx1 - rectLeft1);
HXDLIN(  24)																		int y6 = (dy1 - rectTop1);
HXDLIN(  24)																		int index8;
HXDLIN(  24)																		if (undoImage3->useVirtualPos) {
HXLINE(  24)																			index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            																		}
            																		else {
HXLINE(  24)																			index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            																		}
HXDLIN(  24)																		::iterMagic::Iimg_obj::set(this58,index8,0);
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  24)										bool found1 = false;
HXDLIN(  24)										Float s1 = ((Float)0.);
HXDLIN(  24)										Float t1 = ((Float)0.);
HXDLIN(  24)										Float sxx1 = ((Float)0.);
HXDLIN(  24)										Float txx1 = ((Float)0.);
HXDLIN(  24)										{
HXLINE(  24)											int _g_min2 = xIter31->start;
HXDLIN(  24)											int _g_max2 = xIter31->max;
HXDLIN(  24)											while((_g_min2 < _g_max2)){
HXLINE(  24)												_g_min2 = (_g_min2 + 1);
HXDLIN(  24)												int x7 = (_g_min2 - 1);
HXLINE(  60)												sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)												txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)												found1 = false;
HXLINE(  24)												{
HXLINE(  24)													int _g_min3 = yIter31->start;
HXDLIN(  24)													int _g_max3 = yIter31->max;
HXDLIN(  24)													while((_g_min3 < _g_max3)){
HXLINE(  24)														_g_min3 = (_g_min3 + 1);
HXDLIN(  24)														int y7 = (_g_min3 - 1);
HXLINE(  64)														s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)														t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE(  24)														bool _hx_tmp12;
HXDLIN(  24)														if (!((s1 <= 0))) {
HXLINE(  24)															_hx_tmp12 = (t1 <= 0);
            														}
            														else {
HXLINE(  24)															_hx_tmp12 = true;
            														}
HXDLIN(  24)														if (_hx_tmp12) {
HXLINE(  24)															if (found1) {
HXLINE(  24)																goto _hx_goto_37;
            															}
            														}
            														else {
HXLINE(  24)															if (((s1 + t1) < A1)) {
HXLINE(  24)																{
HXLINE(  24)																	int c7 = color;
HXDLIN(  24)																	bool _hx_tmp13;
HXDLIN(  24)																	if ((((c7 >> 24) & 255) < 254)) {
HXLINE(  24)																		_hx_tmp13 = this36->transparent;
            																	}
            																	else {
HXLINE(  24)																		_hx_tmp13 = false;
            																	}
HXDLIN(  24)																	if (_hx_tmp13) {
HXLINE(  24)																		int location3;
HXDLIN(  24)																		if (this36->useVirtualPos) {
HXLINE(  24)																			location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																		}
            																		else {
HXLINE(  24)																			location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																		}
HXDLIN(  24)																		int this59 = ::iterMagic::Iimg_obj::get(this36->image,location3);
HXDLIN(  24)																		int this60;
HXDLIN(  24)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)																			this60 = ((((((this59 >> 24) & 255) << 24) | ((this59 & 255) << 16)) | (((this59 >> 8) & 255) << 8)) | ((this59 >> 16) & 255));
            																		}
            																		else {
HXLINE(  24)																			this60 = this59;
            																		}
HXDLIN(  24)																		Float a13;
HXDLIN(  24)																		int this61 = ((this60 >> 24) & 255);
HXDLIN(  24)																		if ((this61 == 0)) {
HXLINE(  24)																			a13 = ((Float)0.);
            																		}
            																		else {
HXLINE(  24)																			a13 = (( (Float)(this61) ) / ( (Float)(255) ));
            																		}
HXDLIN(  24)																		Float r13;
HXDLIN(  24)																		int this62 = ((this60 >> 16) & 255);
HXDLIN(  24)																		if ((this62 == 0)) {
HXLINE(  24)																			r13 = ((Float)0.);
            																		}
            																		else {
HXLINE(  24)																			r13 = (( (Float)(this62) ) / ( (Float)(255) ));
            																		}
HXDLIN(  24)																		Float g13;
HXDLIN(  24)																		int this63 = ((this60 >> 8) & 255);
HXDLIN(  24)																		if ((this63 == 0)) {
HXLINE(  24)																			g13 = ((Float)0.);
            																		}
            																		else {
HXLINE(  24)																			g13 = (( (Float)(this63) ) / ( (Float)(255) ));
            																		}
HXDLIN(  24)																		Float b14;
HXDLIN(  24)																		int this64 = (this60 & 255);
HXDLIN(  24)																		if ((this64 == 0)) {
HXLINE(  24)																			b14 = ((Float)0.);
            																		}
            																		else {
HXLINE(  24)																			b14 = (( (Float)(this64) ) / ( (Float)(255) ));
            																		}
HXDLIN(  24)																		Float a23;
HXDLIN(  24)																		int this65 = ((color >> 24) & 255);
HXDLIN(  24)																		if ((this65 == 0)) {
HXLINE(  24)																			a23 = ((Float)0.);
            																		}
            																		else {
HXLINE(  24)																			a23 = (( (Float)(this65) ) / ( (Float)(255) ));
            																		}
HXDLIN(  24)																		Float r23;
HXDLIN(  24)																		int this66 = ((color >> 16) & 255);
HXDLIN(  24)																		if ((this66 == 0)) {
HXLINE(  24)																			r23 = ((Float)0.);
            																		}
            																		else {
HXLINE(  24)																			r23 = (( (Float)(this66) ) / ( (Float)(255) ));
            																		}
HXDLIN(  24)																		Float g23;
HXDLIN(  24)																		int this67 = ((color >> 8) & 255);
HXDLIN(  24)																		if ((this67 == 0)) {
HXLINE(  24)																			g23 = ((Float)0.);
            																		}
            																		else {
HXLINE(  24)																			g23 = (( (Float)(this67) ) / ( (Float)(255) ));
            																		}
HXDLIN(  24)																		Float b24;
HXDLIN(  24)																		int this68 = (color & 255);
HXDLIN(  24)																		if ((this68 == 0)) {
HXLINE(  24)																			b24 = ((Float)0.);
            																		}
            																		else {
HXLINE(  24)																			b24 = (( (Float)(this68) ) / ( (Float)(255) ));
            																		}
HXDLIN(  24)																		Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  24)																		int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  24)																		int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  24)																		int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN(  24)																		int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  24)																		int blended3 = ((((a8 << 24) | (r6 << 16)) | (g5 << 8)) | b9);
HXDLIN(  24)																		{
HXLINE(  24)																			int _hx_tmp14;
HXDLIN(  24)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)																				_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																			}
            																			else {
HXLINE(  24)																				_hx_tmp14 = blended3;
            																			}
HXDLIN(  24)																			::iterMagic::Iimg_obj::set(this36->image,location3,_hx_tmp14);
            																		}
            																	}
            																	else {
HXLINE(  24)																		::Dynamic this69 = this36->image;
HXDLIN(  24)																		int index9;
HXDLIN(  24)																		if (this36->useVirtualPos) {
HXLINE(  24)																			index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this36->virtualY) * ( (Float)(this36->width) )) + x7) - this36->virtualX));
            																		}
            																		else {
HXLINE(  24)																			index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this36->width) + x7)) ));
            																		}
HXDLIN(  24)																		int _hx_tmp15;
HXDLIN(  24)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)																			_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            																		}
            																		else {
HXLINE(  24)																			_hx_tmp15 = c7;
            																		}
HXDLIN(  24)																		::iterMagic::Iimg_obj::set(this69,index9,_hx_tmp15);
            																	}
            																}
HXLINE(  73)																found1 = true;
            															}
            															else {
HXLINE(  24)																if (found1) {
HXLINE(  24)																	goto _hx_goto_37;
            																}
            															}
            														}
            													}
            													_hx_goto_37:;
            												}
            											}
            										}
HXDLIN(  24)										if ((hasHit1 == true)) {
HXLINE(  24)											 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN(  24)											if (hasUndo1) {
HXLINE(  24)												v5->undoImage = undoImage3;
HXDLIN(  24)												v5->undoX = xIter31->start;
HXDLIN(  24)												v5->undoY = yIter31->start;
            											}
            										}
            									}
            								}
            							}
HXLINE(  59)							lastX = nextX1;
HXLINE(  60)							lastY = nextY1;
            						}
            					}
            				}
            			}
            		}
HXLINE(  25)		{
HXLINE(  25)			 ::pi_xy::ImageStruct this70 = temp;
HXDLIN(  25)			int color1 = this->fill;
HXDLIN(  25)			 ::Dynamic phi4 = phi;
HXDLIN(  25)			if (::hx::IsNull( phi4 )) {
HXLINE(  25)				phi4 = 0;
            			}
HXDLIN(  25)			Float rSmall1;
HXDLIN(  25)			if ((innerR > innerR)) {
HXLINE(  25)				rSmall1 = innerR;
            			}
            			else {
HXLINE(  25)				rSmall1 = innerR;
            			}
HXDLIN(  25)			 ::Dynamic targetE1 = ((Float)1.05);
HXDLIN(  25)			if (::hx::IsNull( targetE1 )) {
HXLINE( 534)				targetE1 = ((Float)1.05);
            			}
HXLINE(  25)			int result1 = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE1) ) / rSmall1)))));
HXDLIN(  25)			int noSides1;
HXDLIN(  25)			if ((result1 < 12)) {
HXLINE(  25)				noSides1 = 12;
            			}
            			else {
HXLINE(  25)				if ((result1 > 500)) {
HXLINE(  25)					noSides1 = 500;
            				}
            				else {
HXLINE(  25)					noSides1 = result1;
            				}
            			}
HXDLIN(  25)			{
HXLINE(  25)				 ::Dynamic phi5 = phi4;
HXDLIN(  25)				 ::Dynamic sides2 = noSides1;
HXDLIN(  25)				if (::hx::IsNull( sides2 )) {
HXLINE( 540)					sides2 = 36;
            				}
HXLINE(  25)				if (::hx::IsNull( phi5 )) {
HXLINE( 539)					phi5 = ((Float)0.);
            				}
HXLINE(  25)				{
HXLINE(  25)					 ::Dynamic phi6 = phi5;
HXDLIN(  25)					 ::Dynamic sides3 = sides2;
HXDLIN(  25)					if (::hx::IsNull( sides3 )) {
HXLINE( 212)						sides3 = 36;
            					}
HXLINE(  25)					if (::hx::IsNull( phi6 )) {
HXLINE( 211)						phi6 = ((Float)0.);
            					}
HXLINE(  25)					Float theta1 = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides3) ));
HXDLIN(  25)					Float omega1;
HXDLIN(  25)					omega1 = ((Float)0.);
HXDLIN(  25)					Float lastX1 = ((Float)0.);
HXDLIN(  25)					Float lastY1 = ((Float)0.);
HXDLIN(  25)					if (::hx::IsNotEq( phi6,0 )) {
HXLINE(  35)						lastX1 = ((((innerR * ::Math_obj::cos(((( (Float)(sides3) ) * theta1) + omega1))) * ::Math_obj::cos(( (Float)(phi6) ))) - ((innerR * ::Math_obj::sin(((( (Float)(sides3) ) * theta1) + omega1))) * ::Math_obj::sin(( (Float)(phi6) )))) + innerCx);
HXLINE(  36)						lastY1 = ((((innerR * ::Math_obj::cos(((( (Float)(sides3) ) * theta1) + omega1))) * ::Math_obj::sin(( (Float)(phi6) ))) + ((innerR * ::Math_obj::sin(((( (Float)(sides3) ) * theta1) + omega1))) * ::Math_obj::cos(( (Float)(phi6) )))) + innerCy);
            					}
            					else {
HXLINE(  38)						lastX1 = (innerCx + (innerR * ::Math_obj::cos(((( (Float)(sides3) ) * theta1) + omega1))));
HXLINE(  39)						lastY1 = (innerCy + (innerR * ::Math_obj::sin(((( (Float)(sides3) ) * theta1) + omega1))));
            					}
HXLINE(  25)					if (::hx::IsNotEq( phi6,0 )) {
HXLINE(  25)						Float cphi1 = ::Math_obj::cos(( (Float)(phi6) ));
HXDLIN(  25)						Float sphi1 = ::Math_obj::sin(( (Float)(phi6) ));
HXDLIN(  25)						{
HXLINE(  25)							int _g44 = 0;
HXDLIN(  25)							int _g45 = (sides3 + 1);
HXDLIN(  25)							while((_g44 < _g45)){
HXLINE(  25)								_g44 = (_g44 + 1);
HXDLIN(  25)								int i14 = (_g44 - 1);
HXDLIN(  25)								Float stheta1 = ::Math_obj::sin((((( (Float)(i14) ) * theta1) + omega1) + ((Float)0.01)));
HXDLIN(  25)								Float ctheta1 = ::Math_obj::cos((((( (Float)(i14) ) * theta1) + omega1) + ((Float)0.01)));
HXDLIN(  25)								Float nextX2 = ((((innerR * ctheta1) * cphi1) - ((innerR * stheta1) * sphi1)) + innerCx);
HXDLIN(  25)								Float nextY2 = ((((innerR * ctheta1) * sphi1) + ((innerR * stheta1) * cphi1)) + innerCy);
HXDLIN(  25)								{
HXLINE(  25)									 ::pi_xy::ImageStruct this71 = this70;
HXDLIN(  25)									bool hasHit2 = false;
HXDLIN(  25)									bool hasUndo2 = false;
HXDLIN(  25)									{
HXLINE(  25)										Float bx2 = lastX1;
HXDLIN(  25)										Float by2 = lastY1;
HXDLIN(  25)										Float cx3 = nextX2;
HXDLIN(  25)										Float cy3 = nextY2;
HXDLIN(  25)										bool adjustWinding2 = (((((innerCx * by2) - (bx2 * innerCy)) + ((bx2 * cy3) - (cx3 * by2))) + ((cx3 * innerCy) - (innerCx * cy3))) > 0);
HXDLIN(  25)										if (!(adjustWinding2)) {
HXLINE(  25)											Float bx_2 = bx2;
HXDLIN(  25)											Float by_2 = by2;
HXDLIN(  25)											bx2 = cx3;
HXLINE(  26)											by2 = cy3;
HXLINE(  27)											cx3 = bx_2;
HXLINE(  28)											cy3 = by_2;
            										}
HXLINE(  25)										{
HXLINE(  25)											Float s02 = ((innerCy * cx3) - (innerCx * cy3));
HXDLIN(  25)											Float sx2 = (cy3 - innerCy);
HXDLIN(  25)											Float sy2 = (innerCx - cx3);
HXDLIN(  25)											Float t02 = ((innerCx * by2) - (innerCy * bx2));
HXDLIN(  25)											Float tx2 = (innerCy - by2);
HXDLIN(  25)											Float ty2 = (bx2 - innerCx);
HXDLIN(  25)											Float A2 = ((((-(by2) * cx3) + (innerCy * (-(bx2) + cx3))) + (innerCx * (by2 - cy3))) + (bx2 * cy3));
HXDLIN(  25)											 ::pi_xy::iter::IntIterStart xIter32;
HXDLIN(  25)											if ((innerCx > bx2)) {
HXLINE(  25)												if ((innerCx > cx3)) {
HXLINE(  25)													int min8;
HXDLIN(  25)													if ((bx2 > cx3)) {
HXLINE(  25)														min8 = ::Math_obj::floor(cx3);
            													}
            													else {
HXLINE(  25)														min8 = ::Math_obj::floor(bx2);
            													}
HXDLIN(  25)													int ii_min16 = min8;
HXDLIN(  25)													int ii_max16 = ::Math_obj::ceil(innerCx);
HXDLIN(  25)													xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            												}
            												else {
HXLINE(  25)													int ii_min17 = ::Math_obj::floor(bx2);
HXDLIN(  25)													int ii_max17 = ::Math_obj::ceil(cx3);
HXDLIN(  25)													xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            												}
            											}
            											else {
HXLINE(  25)												if ((bx2 > cx3)) {
HXLINE(  25)													int min9;
HXDLIN(  25)													if ((innerCx > cx3)) {
HXLINE(  25)														min9 = ::Math_obj::floor(cx3);
            													}
            													else {
HXLINE(  25)														min9 = ::Math_obj::ceil(innerCx);
            													}
HXDLIN(  25)													int ii_min18 = min9;
HXDLIN(  25)													int ii_max18 = ::Math_obj::ceil(bx2);
HXDLIN(  25)													xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            												}
            												else {
HXLINE(  25)													int ii_min19 = ::Math_obj::floor(innerCx);
HXDLIN(  25)													int ii_max19 = ::Math_obj::ceil(cx3);
HXDLIN(  25)													xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            												}
            											}
HXDLIN(  25)											 ::pi_xy::iter::IntIterStart yIter32;
HXDLIN(  25)											if ((innerCy > by2)) {
HXLINE(  25)												if ((innerCy > cy3)) {
HXLINE(  25)													int min10;
HXDLIN(  25)													if ((by2 > cy3)) {
HXLINE(  25)														min10 = ::Math_obj::floor(cy3);
            													}
            													else {
HXLINE(  25)														min10 = ::Math_obj::floor(by2);
            													}
HXDLIN(  25)													int ii_min20 = min10;
HXDLIN(  25)													int ii_max20 = ::Math_obj::ceil(innerCy);
HXDLIN(  25)													yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            												}
            												else {
HXLINE(  25)													int ii_min21 = ::Math_obj::floor(by2);
HXDLIN(  25)													int ii_max21 = ::Math_obj::ceil(cy3);
HXDLIN(  25)													yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            												}
            											}
            											else {
HXLINE(  25)												if ((by2 > cy3)) {
HXLINE(  25)													int min11;
HXDLIN(  25)													if ((innerCy > cy3)) {
HXLINE(  25)														min11 = ::Math_obj::floor(cy3);
            													}
            													else {
HXLINE(  25)														min11 = ::Math_obj::ceil(innerCy);
            													}
HXDLIN(  25)													int ii_min22 = min11;
HXDLIN(  25)													int ii_max22 = ::Math_obj::ceil(by2);
HXDLIN(  25)													yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            												}
            												else {
HXLINE(  25)													int ii_min23 = ::Math_obj::floor(innerCy);
HXDLIN(  25)													int ii_max23 = ::Math_obj::ceil(cy3);
HXDLIN(  25)													yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            												}
            											}
HXDLIN(  25)											 ::pi_xy::ImageStruct undoImage6 = null();
HXDLIN(  25)											if (hasUndo2) {
HXLINE(  25)												int width2 = ((xIter32->max - xIter32->start) + 1);
HXDLIN(  25)												int height2 = ((yIter32->max - yIter32->start) + 1);
HXDLIN(  25)												 ::Dynamic imageType2 = null();
HXDLIN(  25)												 ::pi_xy::ImageStruct this72 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  25)												if (::hx::IsNull( imageType2 )) {
HXLINE(  54)													imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            												}
HXLINE(  25)												::Dynamic undoImage7;
HXDLIN(  25)												switch((int)(( (int)(imageType2) ))){
            													case (int)0: {
HXLINE(  25)														 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  25)														 ::iterMagic::BytesImg b10 = byt2;
HXDLIN(  25)														{
HXLINE(  25)															b10->width = width2;
HXDLIN(  25)															b10->height = height2;
HXDLIN(  25)															b10->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  25)															b10->data = ::haxe::io::Bytes_obj::alloc((b10->length * 4));
HXDLIN(  25)															{
HXLINE(  25)																int len4 = b10->length;
HXDLIN(  25)																int w3 = 0;
HXDLIN(  25)																{
HXLINE(  25)																	int _g46 = 0;
HXDLIN(  25)																	int _g47 = b10->height;
HXDLIN(  25)																	while((_g46 < _g47)){
HXLINE(  25)																		_g46 = (_g46 + 1);
HXDLIN(  25)																		int y8 = (_g46 - 1);
HXDLIN(  25)																		{
HXLINE(  25)																			int _g48 = 0;
HXDLIN(  25)																			int _g49 = b10->width;
HXDLIN(  25)																			while((_g48 < _g49)){
HXLINE(  25)																				_g48 = (_g48 + 1);
HXDLIN(  25)																				int x8 = (_g48 - 1);
HXDLIN(  25)																				{
HXLINE(  25)																					w3 = (w3 + 1);
HXDLIN(  25)																					b10->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            																				}
HXDLIN(  25)																				{
HXLINE(  25)																					w3 = (w3 + 1);
HXDLIN(  25)																					b10->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            																				}
HXDLIN(  25)																				{
HXLINE(  25)																					w3 = (w3 + 1);
HXDLIN(  25)																					b10->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            																				}
HXDLIN(  25)																				{
HXLINE(  25)																					w3 = (w3 + 1);
HXDLIN(  25)																					b10->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            																				}
            																			}
            																		}
            																	}
            																}
            															}
            														}
HXDLIN(  25)														undoImage7 = b10;
            													}
            													break;
            													case (int)1: {
HXLINE(  25)														 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  25)														 ::iterMagic::ArrIntImg a9 = arrI2;
HXDLIN(  25)														{
HXLINE(  25)															a9->width = width2;
HXDLIN(  25)															a9->height = height2;
HXDLIN(  25)															a9->data = ::Array_obj< int >::__new(0);
HXDLIN(  25)															a9->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  25)															{
HXLINE(  25)																int _g50 = 0;
HXDLIN(  25)																int _g51 = a9->length;
HXDLIN(  25)																while((_g50 < _g51)){
HXLINE(  25)																	_g50 = (_g50 + 1);
HXDLIN(  25)																	int i15 = (_g50 - 1);
HXDLIN(  25)																	a9->data[i15] = 0;
            																}
            															}
            														}
HXDLIN(  25)														undoImage7 = a9;
            													}
            													break;
            													case (int)2: {
HXLINE(  25)														 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  25)														 ::iterMagic::U32ArrImg b15 = u32a2;
HXDLIN(  25)														{
HXLINE(  25)															b15->width = width2;
HXDLIN(  25)															b15->height = height2;
HXDLIN(  25)															b15->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  25)															int size2 = (b15->length * 4);
HXDLIN(  25)															b15->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN(  25)															{
HXLINE(  25)																int _g52 = 0;
HXDLIN(  25)																int _g53 = b15->length;
HXDLIN(  25)																while((_g52 < _g53)){
HXLINE(  25)																	_g52 = (_g52 + 1);
HXDLIN(  25)																	int i16 = (_g52 - 1);
HXDLIN(  25)																	{
HXLINE(  25)																		 ::haxe::io::ArrayBufferViewImpl this73 = b15->data;
HXDLIN(  25)																		bool undoImage8;
HXDLIN(  25)																		if ((i16 >= 0)) {
HXLINE(  25)																			undoImage8 = (i16 < (this73->byteLength >> 2));
            																		}
            																		else {
HXLINE(  25)																			undoImage8 = false;
            																		}
HXDLIN(  25)																		if (undoImage8) {
HXLINE(  25)																			 ::haxe::io::Bytes _this2 = this73->bytes;
HXDLIN(  25)																			int pos2 = ((i16 << 2) + this73->byteOffset);
HXDLIN(  25)																			_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN(  25)																			_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN(  25)																			_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN(  25)																			_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            																		}
            																	}
            																}
            															}
            														}
HXDLIN(  25)														undoImage7 = b15;
            													}
            													break;
            													case (int)3: {
HXLINE(  25)														 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  25)														 ::iterMagic::VecIntImg v6 = vec2;
HXDLIN(  25)														{
HXLINE(  25)															v6->width = width2;
HXDLIN(  25)															v6->height = height2;
HXDLIN(  25)															v6->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  25)															v6->data = ::Array_obj< int >::__new(v6->length);
HXDLIN(  25)															{
HXLINE(  25)																int _g54 = 0;
HXDLIN(  25)																int _g55 = v6->length;
HXDLIN(  25)																while((_g54 < _g55)){
HXLINE(  25)																	_g54 = (_g54 + 1);
HXDLIN(  25)																	int i17 = (_g54 - 1);
HXDLIN(  25)																	v6->data->__unsafe_set(i17,0);
            																}
            															}
            														}
HXDLIN(  25)														undoImage7 = v6;
            													}
            													break;
            													case (int)4: {
HXLINE(  25)														 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  25)														 ::iterMagic::StackIntImg b16 = sInt2;
HXDLIN(  25)														{
HXLINE(  25)															b16->width = width2;
HXDLIN(  25)															b16->height = height2;
HXDLIN(  25)															b16->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  25)															b16->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  25)															{
HXLINE(  25)																int len5 = b16->length;
HXDLIN(  25)																 ::haxe::ds::GenericStack_Int d2 = b16->data;
HXDLIN(  25)																if (::hx::IsNull( d2->head )) {
HXLINE(  25)																	int _g56 = 0;
HXDLIN(  25)																	int _g57 = len5;
HXDLIN(  25)																	while((_g56 < _g57)){
HXLINE(  25)																		_g56 = (_g56 + 1);
HXDLIN(  25)																		int i18 = (_g56 - 1);
HXDLIN(  25)																		d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            																	}
            																}
            																else {
HXLINE(  25)																	int _g58 = 0;
HXDLIN(  25)																	int _g59 = len5;
HXDLIN(  25)																	while((_g58 < _g59)){
HXLINE(  25)																		_g58 = (_g58 + 1);
HXDLIN(  25)																		int i19 = (_g58 - 1);
HXDLIN(  25)																		{
HXLINE(  25)																			 ::haxe::ds::GenericCell_Int l2 = b16->data->head;
HXDLIN(  25)																			 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN(  25)																			{
HXLINE(  25)																				int _g60 = 0;
HXDLIN(  25)																				int _g61 = i19;
HXDLIN(  25)																				while((_g60 < _g61)){
HXLINE(  25)																					_g60 = (_g60 + 1);
HXDLIN(  25)																					int i20 = (_g60 - 1);
HXLINE( 345)																					prev2 = l2;
HXLINE( 346)																					l2 = l2->next;
            																				}
            																			}
HXLINE(  25)																			if (::hx::IsNull( prev2 )) {
HXLINE(  25)																				b16->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  25)																				l2 = null();
            																			}
            																			else {
HXLINE(  25)																				prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  25)																				l2 = null();
            																			}
            																		}
            																	}
            																}
            															}
            														}
HXDLIN(  25)														undoImage7 = b16;
            													}
            													break;
            												}
HXDLIN(  25)												this72->image = undoImage7;
HXDLIN(  25)												this72->width = width2;
HXDLIN(  25)												this72->height = height2;
HXDLIN(  25)												this72->imageType = ( (int)(imageType2) );
HXDLIN(  25)												undoImage6 = this72;
HXDLIN(  25)												{
HXLINE(  25)													int rectLeft2 = xIter32->start;
HXDLIN(  25)													int rectTop2 = yIter32->start;
HXDLIN(  25)													int rectRight2 = xIter32->max;
HXDLIN(  25)													bool forceClear2 = false;
HXDLIN(  25)													{
HXLINE(  25)														int _g62 = rectTop2;
HXDLIN(  25)														int _g63 = yIter32->max;
HXDLIN(  25)														while((_g62 < _g63)){
HXLINE(  25)															_g62 = (_g62 + 1);
HXDLIN(  25)															int dy2 = (_g62 - 1);
HXDLIN(  25)															{
HXLINE(  25)																int _g64 = rectLeft2;
HXDLIN(  25)																int _g65 = rectRight2;
HXDLIN(  25)																while((_g64 < _g65)){
HXLINE(  25)																	_g64 = (_g64 + 1);
HXDLIN(  25)																	int dx2 = (_g64 - 1);
HXDLIN(  25)																	::Dynamic this74 = this71->image;
HXDLIN(  25)																	int index10;
HXDLIN(  25)																	if (this71->useVirtualPos) {
HXLINE(  25)																		index10 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this71->virtualY) * ( (Float)(this71->width) )) + dx2) - this71->virtualX));
            																	}
            																	else {
HXLINE(  25)																		index10 = ::Std_obj::_hx_int(( (Float)(((dy2 * this71->width) + dx2)) ));
            																	}
HXDLIN(  25)																	int c8 = ::iterMagic::Iimg_obj::get(this74,index10);
HXDLIN(  25)																	int col2;
HXDLIN(  25)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)																		col2 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            																	}
            																	else {
HXLINE(  25)																		col2 = c8;
            																	}
HXDLIN(  25)																	bool _hx_tmp16;
HXDLIN(  25)																	if (this71->useMask) {
HXLINE(  25)																		_hx_tmp16 = ::hx::IsNotNull( this71->mask );
            																	}
            																	else {
HXLINE(  25)																		_hx_tmp16 = false;
            																	}
HXDLIN(  25)																	if (_hx_tmp16) {
HXLINE(  25)																		 ::pi_xy::ImageStruct this75 = this71->mask;
HXDLIN(  25)																		::Dynamic this76 = this75->image;
HXDLIN(  25)																		int index11;
HXDLIN(  25)																		if (this75->useVirtualPos) {
HXLINE(  25)																			index11 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this75->virtualY) * ( (Float)(this75->width) )) + dx2) - this75->virtualX));
            																		}
            																		else {
HXLINE(  25)																			index11 = ::Std_obj::_hx_int(( (Float)(((dy2 * this75->width) + dx2)) ));
            																		}
HXDLIN(  25)																		int c9 = ::iterMagic::Iimg_obj::get(this76,index11);
HXDLIN(  25)																		int v7;
HXDLIN(  25)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)																			v7 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            																		}
            																		else {
HXLINE(  25)																			v7 = c9;
            																		}
HXDLIN(  25)																		int maskPixel2 = v7;
HXDLIN(  25)																		int this77 = col2;
HXDLIN(  25)																		if ((maskPixel2 == 0)) {
HXLINE(  25)																			col2 = this77;
            																		}
            																		else {
HXLINE(  25)																			Float m02;
HXDLIN(  25)																			int this78 = ((maskPixel2 >> 24) & 255);
HXDLIN(  25)																			if ((this78 == 0)) {
HXLINE(  25)																				m02 = ((Float)0.);
            																			}
            																			else {
HXLINE(  25)																				m02 = (( (Float)(this78) ) / ( (Float)(255) ));
            																			}
HXDLIN(  25)																			Float m12;
HXDLIN(  25)																			int this79 = ((maskPixel2 >> 16) & 255);
HXDLIN(  25)																			if ((this79 == 0)) {
HXLINE(  25)																				m12 = ((Float)0.);
            																			}
            																			else {
HXLINE(  25)																				m12 = (( (Float)(this79) ) / ( (Float)(255) ));
            																			}
HXDLIN(  25)																			Float m22;
HXDLIN(  25)																			int this80 = ((maskPixel2 >> 8) & 255);
HXDLIN(  25)																			if ((this80 == 0)) {
HXLINE(  25)																				m22 = ((Float)0.);
            																			}
            																			else {
HXLINE(  25)																				m22 = (( (Float)(this80) ) / ( (Float)(255) ));
            																			}
HXDLIN(  25)																			Float m32;
HXDLIN(  25)																			int this81 = (maskPixel2 & 255);
HXDLIN(  25)																			if ((this81 == 0)) {
HXLINE(  25)																				m32 = ((Float)0.);
            																			}
            																			else {
HXLINE(  25)																				m32 = (( (Float)(this81) ) / ( (Float)(255) ));
            																			}
HXDLIN(  25)																			int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this77 >> 24) & 255)) )));
HXDLIN(  25)																			int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this77 >> 16) & 255)) )));
HXDLIN(  25)																			int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this77 >> 8) & 255)) )));
HXDLIN(  25)																			int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this77 & 255)) )));
HXDLIN(  25)																			col2 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            																		}
            																	}
HXDLIN(  25)																	if ((col2 != 0)) {
HXLINE(  25)																		int x9 = (dx2 - rectLeft2);
HXDLIN(  25)																		int y9 = (dy2 - rectTop2);
HXDLIN(  25)																		int c10 = col2;
HXDLIN(  25)																		bool _hx_tmp17;
HXDLIN(  25)																		if ((((c10 >> 24) & 255) < 254)) {
HXLINE(  25)																			_hx_tmp17 = undoImage6->transparent;
            																		}
            																		else {
HXLINE(  25)																			_hx_tmp17 = false;
            																		}
HXDLIN(  25)																		if (_hx_tmp17) {
HXLINE(  25)																			int location4;
HXDLIN(  25)																			if (undoImage6->useVirtualPos) {
HXLINE(  25)																				location4 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x9) - undoImage6->virtualX));
            																			}
            																			else {
HXLINE(  25)																				location4 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage6->width) + x9)) ));
            																			}
HXDLIN(  25)																			int this82 = ::iterMagic::Iimg_obj::get(undoImage6->image,location4);
HXDLIN(  25)																			int this83;
HXDLIN(  25)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)																				this83 = ((((((this82 >> 24) & 255) << 24) | ((this82 & 255) << 16)) | (((this82 >> 8) & 255) << 8)) | ((this82 >> 16) & 255));
            																			}
            																			else {
HXLINE(  25)																				this83 = this82;
            																			}
HXDLIN(  25)																			Float a14;
HXDLIN(  25)																			int this84 = ((this83 >> 24) & 255);
HXDLIN(  25)																			if ((this84 == 0)) {
HXLINE(  25)																				a14 = ((Float)0.);
            																			}
            																			else {
HXLINE(  25)																				a14 = (( (Float)(this84) ) / ( (Float)(255) ));
            																			}
HXDLIN(  25)																			Float r14;
HXDLIN(  25)																			int this85 = ((this83 >> 16) & 255);
HXDLIN(  25)																			if ((this85 == 0)) {
HXLINE(  25)																				r14 = ((Float)0.);
            																			}
            																			else {
HXLINE(  25)																				r14 = (( (Float)(this85) ) / ( (Float)(255) ));
            																			}
HXDLIN(  25)																			Float g14;
HXDLIN(  25)																			int this86 = ((this83 >> 8) & 255);
HXDLIN(  25)																			if ((this86 == 0)) {
HXLINE(  25)																				g14 = ((Float)0.);
            																			}
            																			else {
HXLINE(  25)																				g14 = (( (Float)(this86) ) / ( (Float)(255) ));
            																			}
HXDLIN(  25)																			Float b17;
HXDLIN(  25)																			int this87 = (this83 & 255);
HXDLIN(  25)																			if ((this87 == 0)) {
HXLINE(  25)																				b17 = ((Float)0.);
            																			}
            																			else {
HXLINE(  25)																				b17 = (( (Float)(this87) ) / ( (Float)(255) ));
            																			}
HXDLIN(  25)																			Float a24;
HXDLIN(  25)																			int this88 = ((col2 >> 24) & 255);
HXDLIN(  25)																			if ((this88 == 0)) {
HXLINE(  25)																				a24 = ((Float)0.);
            																			}
            																			else {
HXLINE(  25)																				a24 = (( (Float)(this88) ) / ( (Float)(255) ));
            																			}
HXDLIN(  25)																			Float r24;
HXDLIN(  25)																			int this89 = ((col2 >> 16) & 255);
HXDLIN(  25)																			if ((this89 == 0)) {
HXLINE(  25)																				r24 = ((Float)0.);
            																			}
            																			else {
HXLINE(  25)																				r24 = (( (Float)(this89) ) / ( (Float)(255) ));
            																			}
HXDLIN(  25)																			Float g24;
HXDLIN(  25)																			int this90 = ((col2 >> 8) & 255);
HXDLIN(  25)																			if ((this90 == 0)) {
HXLINE(  25)																				g24 = ((Float)0.);
            																			}
            																			else {
HXLINE(  25)																				g24 = (( (Float)(this90) ) / ( (Float)(255) ));
            																			}
HXDLIN(  25)																			Float b25;
HXDLIN(  25)																			int this91 = (col2 & 255);
HXDLIN(  25)																			if ((this91 == 0)) {
HXLINE(  25)																				b25 = ((Float)0.);
            																			}
            																			else {
HXLINE(  25)																				b25 = (( (Float)(this91) ) / ( (Float)(255) ));
            																			}
HXDLIN(  25)																			Float a34 = (a14 * (( (Float)(1) ) - a24));
HXDLIN(  25)																			int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN(  25)																			int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN(  25)																			int b18 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b17 * a34) + (b25 * a24))));
HXDLIN(  25)																			int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN(  25)																			int blended4 = ((((a10 << 24) | (r7 << 16)) | (g6 << 8)) | b18);
HXDLIN(  25)																			{
HXLINE(  25)																				int _hx_tmp18;
HXDLIN(  25)																				if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)																					_hx_tmp18 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            																				}
            																				else {
HXLINE(  25)																					_hx_tmp18 = blended4;
            																				}
HXDLIN(  25)																				::iterMagic::Iimg_obj::set(undoImage6->image,location4,_hx_tmp18);
            																			}
            																		}
            																		else {
HXLINE(  25)																			::Dynamic this92 = undoImage6->image;
HXDLIN(  25)																			int index12;
HXDLIN(  25)																			if (undoImage6->useVirtualPos) {
HXLINE(  25)																				index12 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x9) - undoImage6->virtualX));
            																			}
            																			else {
HXLINE(  25)																				index12 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage6->width) + x9)) ));
            																			}
HXDLIN(  25)																			int _hx_tmp19;
HXDLIN(  25)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)																				_hx_tmp19 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            																			}
            																			else {
HXLINE(  25)																				_hx_tmp19 = c10;
            																			}
HXDLIN(  25)																			::iterMagic::Iimg_obj::set(this92,index12,_hx_tmp19);
            																		}
            																	}
            																	else {
HXLINE(  25)																		if (forceClear2) {
HXLINE(  25)																			::Dynamic this93 = undoImage6->image;
HXDLIN(  25)																			int x10 = (dx2 - rectLeft2);
HXDLIN(  25)																			int y10 = (dy2 - rectTop2);
HXDLIN(  25)																			int index13;
HXDLIN(  25)																			if (undoImage6->useVirtualPos) {
HXLINE(  25)																				index13 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x10) - undoImage6->virtualX));
            																			}
            																			else {
HXLINE(  25)																				index13 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage6->width) + x10)) ));
            																			}
HXDLIN(  25)																			::iterMagic::Iimg_obj::set(this93,index13,0);
            																		}
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  25)											bool found2 = false;
HXDLIN(  25)											Float s2 = ((Float)0.);
HXDLIN(  25)											Float t2 = ((Float)0.);
HXDLIN(  25)											Float sxx2 = ((Float)0.);
HXDLIN(  25)											Float txx2 = ((Float)0.);
HXDLIN(  25)											{
HXLINE(  25)												int _g_min4 = xIter32->start;
HXDLIN(  25)												int _g_max4 = xIter32->max;
HXDLIN(  25)												while((_g_min4 < _g_max4)){
HXLINE(  25)													_g_min4 = (_g_min4 + 1);
HXDLIN(  25)													int x11 = (_g_min4 - 1);
HXLINE(  60)													sxx2 = (sx2 * ( (Float)(x11) ));
HXLINE(  61)													txx2 = (tx2 * ( (Float)(x11) ));
HXLINE(  62)													found2 = false;
HXLINE(  25)													{
HXLINE(  25)														int _g_min5 = yIter32->start;
HXDLIN(  25)														int _g_max5 = yIter32->max;
HXDLIN(  25)														while((_g_min5 < _g_max5)){
HXLINE(  25)															_g_min5 = (_g_min5 + 1);
HXDLIN(  25)															int y11 = (_g_min5 - 1);
HXLINE(  64)															s2 = ((s02 + sxx2) + (sy2 * ( (Float)(y11) )));
HXLINE(  65)															t2 = ((t02 + txx2) + (ty2 * ( (Float)(y11) )));
HXLINE(  25)															bool _hx_tmp20;
HXDLIN(  25)															if (!((s2 <= 0))) {
HXLINE(  25)																_hx_tmp20 = (t2 <= 0);
            															}
            															else {
HXLINE(  25)																_hx_tmp20 = true;
            															}
HXDLIN(  25)															if (_hx_tmp20) {
HXLINE(  25)																if (found2) {
HXLINE(  25)																	goto _hx_goto_50;
            																}
            															}
            															else {
HXLINE(  25)																if (((s2 + t2) < A2)) {
HXLINE(  25)																	{
HXLINE(  25)																		int c11 = color1;
HXDLIN(  25)																		bool _hx_tmp21;
HXDLIN(  25)																		if ((((c11 >> 24) & 255) < 254)) {
HXLINE(  25)																			_hx_tmp21 = this71->transparent;
            																		}
            																		else {
HXLINE(  25)																			_hx_tmp21 = false;
            																		}
HXDLIN(  25)																		if (_hx_tmp21) {
HXLINE(  25)																			int location5;
HXDLIN(  25)																			if (this71->useVirtualPos) {
HXLINE(  25)																				location5 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - this71->virtualY) * ( (Float)(this71->width) )) + x11) - this71->virtualX));
            																			}
            																			else {
HXLINE(  25)																				location5 = ::Std_obj::_hx_int(( (Float)(((y11 * this71->width) + x11)) ));
            																			}
HXDLIN(  25)																			int this94 = ::iterMagic::Iimg_obj::get(this71->image,location5);
HXDLIN(  25)																			int this95;
HXDLIN(  25)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)																				this95 = ((((((this94 >> 24) & 255) << 24) | ((this94 & 255) << 16)) | (((this94 >> 8) & 255) << 8)) | ((this94 >> 16) & 255));
            																			}
            																			else {
HXLINE(  25)																				this95 = this94;
            																			}
HXDLIN(  25)																			Float a15;
HXDLIN(  25)																			int this96 = ((this95 >> 24) & 255);
HXDLIN(  25)																			if ((this96 == 0)) {
HXLINE(  25)																				a15 = ((Float)0.);
            																			}
            																			else {
HXLINE(  25)																				a15 = (( (Float)(this96) ) / ( (Float)(255) ));
            																			}
HXDLIN(  25)																			Float r15;
HXDLIN(  25)																			int this97 = ((this95 >> 16) & 255);
HXDLIN(  25)																			if ((this97 == 0)) {
HXLINE(  25)																				r15 = ((Float)0.);
            																			}
            																			else {
HXLINE(  25)																				r15 = (( (Float)(this97) ) / ( (Float)(255) ));
            																			}
HXDLIN(  25)																			Float g15;
HXDLIN(  25)																			int this98 = ((this95 >> 8) & 255);
HXDLIN(  25)																			if ((this98 == 0)) {
HXLINE(  25)																				g15 = ((Float)0.);
            																			}
            																			else {
HXLINE(  25)																				g15 = (( (Float)(this98) ) / ( (Float)(255) ));
            																			}
HXDLIN(  25)																			Float b19;
HXDLIN(  25)																			int this99 = (this95 & 255);
HXDLIN(  25)																			if ((this99 == 0)) {
HXLINE(  25)																				b19 = ((Float)0.);
            																			}
            																			else {
HXLINE(  25)																				b19 = (( (Float)(this99) ) / ( (Float)(255) ));
            																			}
HXDLIN(  25)																			Float a25;
HXDLIN(  25)																			int this100 = ((color1 >> 24) & 255);
HXDLIN(  25)																			if ((this100 == 0)) {
HXLINE(  25)																				a25 = ((Float)0.);
            																			}
            																			else {
HXLINE(  25)																				a25 = (( (Float)(this100) ) / ( (Float)(255) ));
            																			}
HXDLIN(  25)																			Float r25;
HXDLIN(  25)																			int this101 = ((color1 >> 16) & 255);
HXDLIN(  25)																			if ((this101 == 0)) {
HXLINE(  25)																				r25 = ((Float)0.);
            																			}
            																			else {
HXLINE(  25)																				r25 = (( (Float)(this101) ) / ( (Float)(255) ));
            																			}
HXDLIN(  25)																			Float g25;
HXDLIN(  25)																			int this102 = ((color1 >> 8) & 255);
HXDLIN(  25)																			if ((this102 == 0)) {
HXLINE(  25)																				g25 = ((Float)0.);
            																			}
            																			else {
HXLINE(  25)																				g25 = (( (Float)(this102) ) / ( (Float)(255) ));
            																			}
HXDLIN(  25)																			Float b26;
HXDLIN(  25)																			int this103 = (color1 & 255);
HXDLIN(  25)																			if ((this103 == 0)) {
HXLINE(  25)																				b26 = ((Float)0.);
            																			}
            																			else {
HXLINE(  25)																				b26 = (( (Float)(this103) ) / ( (Float)(255) ));
            																			}
HXDLIN(  25)																			Float a35 = (a15 * (( (Float)(1) ) - a25));
HXDLIN(  25)																			int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN(  25)																			int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN(  25)																			int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b19 * a35) + (b26 * a25))));
HXDLIN(  25)																			int a16 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN(  25)																			int blended5 = ((((a16 << 24) | (r8 << 16)) | (g7 << 8)) | b20);
HXDLIN(  25)																			{
HXLINE(  25)																				int _hx_tmp22;
HXDLIN(  25)																				if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)																					_hx_tmp22 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            																				}
            																				else {
HXLINE(  25)																					_hx_tmp22 = blended5;
            																				}
HXDLIN(  25)																				::iterMagic::Iimg_obj::set(this71->image,location5,_hx_tmp22);
            																			}
            																		}
            																		else {
HXLINE(  25)																			::Dynamic this104 = this71->image;
HXDLIN(  25)																			int index14;
HXDLIN(  25)																			if (this71->useVirtualPos) {
HXLINE(  25)																				index14 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - this71->virtualY) * ( (Float)(this71->width) )) + x11) - this71->virtualX));
            																			}
            																			else {
HXLINE(  25)																				index14 = ::Std_obj::_hx_int(( (Float)(((y11 * this71->width) + x11)) ));
            																			}
HXDLIN(  25)																			int _hx_tmp23;
HXDLIN(  25)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)																				_hx_tmp23 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            																			}
            																			else {
HXLINE(  25)																				_hx_tmp23 = c11;
            																			}
HXDLIN(  25)																			::iterMagic::Iimg_obj::set(this104,index14,_hx_tmp23);
            																		}
            																	}
HXLINE(  73)																	found2 = true;
            																}
            																else {
HXLINE(  25)																	if (found2) {
HXLINE(  25)																		goto _hx_goto_50;
            																	}
            																}
            															}
            														}
            														_hx_goto_50:;
            													}
            												}
            											}
HXDLIN(  25)											if ((hasHit2 == true)) {
HXLINE(  25)												 ::pi_xy::algo::HitTri v8 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,innerCx,innerCy,bx2,by2,cx3,cy3,true);
HXDLIN(  25)												if (hasUndo2) {
HXLINE(  25)													v8->undoImage = undoImage6;
HXDLIN(  25)													v8->undoX = xIter32->start;
HXDLIN(  25)													v8->undoY = yIter32->start;
            												}
            											}
            										}
            									}
            								}
HXLINE(  51)								lastX1 = nextX2;
HXLINE(  52)								lastY1 = nextY2;
            							}
            						}
            					}
            					else {
HXLINE(  25)						int _g66 = 0;
HXDLIN(  25)						int _g67 = (sides3 + 1);
HXDLIN(  25)						while((_g66 < _g67)){
HXLINE(  25)							_g66 = (_g66 + 1);
HXDLIN(  25)							int i21 = (_g66 - 1);
HXDLIN(  25)							Float nextX3 = (innerCx + (innerR * ::Math_obj::cos((((( (Float)(i21) ) * theta1) + omega1) + ((Float)0.01)))));
HXDLIN(  25)							Float nextY3 = (innerCy + (innerR * ::Math_obj::sin((((( (Float)(i21) ) * theta1) + omega1) + ((Float)0.01)))));
HXDLIN(  25)							{
HXLINE(  25)								 ::pi_xy::ImageStruct this105 = this70;
HXDLIN(  25)								bool hasHit3 = false;
HXDLIN(  25)								bool hasUndo3 = false;
HXDLIN(  25)								{
HXLINE(  25)									Float bx3 = lastX1;
HXDLIN(  25)									Float by3 = lastY1;
HXDLIN(  25)									Float cx4 = nextX3;
HXDLIN(  25)									Float cy4 = nextY3;
HXDLIN(  25)									bool adjustWinding3 = (((((innerCx * by3) - (bx3 * innerCy)) + ((bx3 * cy4) - (cx4 * by3))) + ((cx4 * innerCy) - (innerCx * cy4))) > 0);
HXDLIN(  25)									if (!(adjustWinding3)) {
HXLINE(  25)										Float bx_3 = bx3;
HXDLIN(  25)										Float by_3 = by3;
HXDLIN(  25)										bx3 = cx4;
HXLINE(  26)										by3 = cy4;
HXLINE(  27)										cx4 = bx_3;
HXLINE(  28)										cy4 = by_3;
            									}
HXLINE(  25)									{
HXLINE(  25)										Float s03 = ((innerCy * cx4) - (innerCx * cy4));
HXDLIN(  25)										Float sx3 = (cy4 - innerCy);
HXDLIN(  25)										Float sy3 = (innerCx - cx4);
HXDLIN(  25)										Float t03 = ((innerCx * by3) - (innerCy * bx3));
HXDLIN(  25)										Float tx3 = (innerCy - by3);
HXDLIN(  25)										Float ty3 = (bx3 - innerCx);
HXDLIN(  25)										Float A3 = ((((-(by3) * cx4) + (innerCy * (-(bx3) + cx4))) + (innerCx * (by3 - cy4))) + (bx3 * cy4));
HXDLIN(  25)										 ::pi_xy::iter::IntIterStart xIter33;
HXDLIN(  25)										if ((innerCx > bx3)) {
HXLINE(  25)											if ((innerCx > cx4)) {
HXLINE(  25)												int min12;
HXDLIN(  25)												if ((bx3 > cx4)) {
HXLINE(  25)													min12 = ::Math_obj::floor(cx4);
            												}
            												else {
HXLINE(  25)													min12 = ::Math_obj::floor(bx3);
            												}
HXDLIN(  25)												int ii_min24 = min12;
HXDLIN(  25)												int ii_max24 = ::Math_obj::ceil(innerCx);
HXDLIN(  25)												xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            											}
            											else {
HXLINE(  25)												int ii_min25 = ::Math_obj::floor(bx3);
HXDLIN(  25)												int ii_max25 = ::Math_obj::ceil(cx4);
HXDLIN(  25)												xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            											}
            										}
            										else {
HXLINE(  25)											if ((bx3 > cx4)) {
HXLINE(  25)												int min13;
HXDLIN(  25)												if ((innerCx > cx4)) {
HXLINE(  25)													min13 = ::Math_obj::floor(cx4);
            												}
            												else {
HXLINE(  25)													min13 = ::Math_obj::ceil(innerCx);
            												}
HXDLIN(  25)												int ii_min26 = min13;
HXDLIN(  25)												int ii_max26 = ::Math_obj::ceil(bx3);
HXDLIN(  25)												xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            											}
            											else {
HXLINE(  25)												int ii_min27 = ::Math_obj::floor(innerCx);
HXDLIN(  25)												int ii_max27 = ::Math_obj::ceil(cx4);
HXDLIN(  25)												xIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            											}
            										}
HXDLIN(  25)										 ::pi_xy::iter::IntIterStart yIter33;
HXDLIN(  25)										if ((innerCy > by3)) {
HXLINE(  25)											if ((innerCy > cy4)) {
HXLINE(  25)												int min14;
HXDLIN(  25)												if ((by3 > cy4)) {
HXLINE(  25)													min14 = ::Math_obj::floor(cy4);
            												}
            												else {
HXLINE(  25)													min14 = ::Math_obj::floor(by3);
            												}
HXDLIN(  25)												int ii_min28 = min14;
HXDLIN(  25)												int ii_max28 = ::Math_obj::ceil(innerCy);
HXDLIN(  25)												yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            											}
            											else {
HXLINE(  25)												int ii_min29 = ::Math_obj::floor(by3);
HXDLIN(  25)												int ii_max29 = ::Math_obj::ceil(cy4);
HXDLIN(  25)												yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            											}
            										}
            										else {
HXLINE(  25)											if ((by3 > cy4)) {
HXLINE(  25)												int min15;
HXDLIN(  25)												if ((innerCy > cy4)) {
HXLINE(  25)													min15 = ::Math_obj::floor(cy4);
            												}
            												else {
HXLINE(  25)													min15 = ::Math_obj::ceil(innerCy);
            												}
HXDLIN(  25)												int ii_min30 = min15;
HXDLIN(  25)												int ii_max30 = ::Math_obj::ceil(by3);
HXDLIN(  25)												yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            											}
            											else {
HXLINE(  25)												int ii_min31 = ::Math_obj::floor(innerCy);
HXDLIN(  25)												int ii_max31 = ::Math_obj::ceil(cy4);
HXDLIN(  25)												yIter33 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            											}
            										}
HXDLIN(  25)										 ::pi_xy::ImageStruct undoImage9 = null();
HXDLIN(  25)										if (hasUndo3) {
HXLINE(  25)											int width3 = ((xIter33->max - xIter33->start) + 1);
HXDLIN(  25)											int height3 = ((yIter33->max - yIter33->start) + 1);
HXDLIN(  25)											 ::Dynamic imageType3 = null();
HXDLIN(  25)											 ::pi_xy::ImageStruct this106 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  25)											if (::hx::IsNull( imageType3 )) {
HXLINE(  54)												imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            											}
HXLINE(  25)											::Dynamic undoImage10;
HXDLIN(  25)											switch((int)(( (int)(imageType3) ))){
            												case (int)0: {
HXLINE(  25)													 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  25)													 ::iterMagic::BytesImg b27 = byt3;
HXDLIN(  25)													{
HXLINE(  25)														b27->width = width3;
HXDLIN(  25)														b27->height = height3;
HXDLIN(  25)														b27->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  25)														b27->data = ::haxe::io::Bytes_obj::alloc((b27->length * 4));
HXDLIN(  25)														{
HXLINE(  25)															int len6 = b27->length;
HXDLIN(  25)															int w4 = 0;
HXDLIN(  25)															{
HXLINE(  25)																int _g68 = 0;
HXDLIN(  25)																int _g69 = b27->height;
HXDLIN(  25)																while((_g68 < _g69)){
HXLINE(  25)																	_g68 = (_g68 + 1);
HXDLIN(  25)																	int y12 = (_g68 - 1);
HXDLIN(  25)																	{
HXLINE(  25)																		int _g70 = 0;
HXDLIN(  25)																		int _g71 = b27->width;
HXDLIN(  25)																		while((_g70 < _g71)){
HXLINE(  25)																			_g70 = (_g70 + 1);
HXDLIN(  25)																			int x12 = (_g70 - 1);
HXDLIN(  25)																			{
HXLINE(  25)																				w4 = (w4 + 1);
HXDLIN(  25)																				b27->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN(  25)																			{
HXLINE(  25)																				w4 = (w4 + 1);
HXDLIN(  25)																				b27->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN(  25)																			{
HXLINE(  25)																				w4 = (w4 + 1);
HXDLIN(  25)																				b27->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            																			}
HXDLIN(  25)																			{
HXLINE(  25)																				w4 = (w4 + 1);
HXDLIN(  25)																				b27->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            																			}
            																		}
            																	}
            																}
            															}
            														}
            													}
HXDLIN(  25)													undoImage10 = b27;
            												}
            												break;
            												case (int)1: {
HXLINE(  25)													 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  25)													 ::iterMagic::ArrIntImg a17 = arrI3;
HXDLIN(  25)													{
HXLINE(  25)														a17->width = width3;
HXDLIN(  25)														a17->height = height3;
HXDLIN(  25)														a17->data = ::Array_obj< int >::__new(0);
HXDLIN(  25)														a17->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  25)														{
HXLINE(  25)															int _g72 = 0;
HXDLIN(  25)															int _g73 = a17->length;
HXDLIN(  25)															while((_g72 < _g73)){
HXLINE(  25)																_g72 = (_g72 + 1);
HXDLIN(  25)																int i22 = (_g72 - 1);
HXDLIN(  25)																a17->data[i22] = 0;
            															}
            														}
            													}
HXDLIN(  25)													undoImage10 = a17;
            												}
            												break;
            												case (int)2: {
HXLINE(  25)													 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  25)													 ::iterMagic::U32ArrImg b28 = u32a3;
HXDLIN(  25)													{
HXLINE(  25)														b28->width = width3;
HXDLIN(  25)														b28->height = height3;
HXDLIN(  25)														b28->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  25)														int size3 = (b28->length * 4);
HXDLIN(  25)														b28->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN(  25)														{
HXLINE(  25)															int _g74 = 0;
HXDLIN(  25)															int _g75 = b28->length;
HXDLIN(  25)															while((_g74 < _g75)){
HXLINE(  25)																_g74 = (_g74 + 1);
HXDLIN(  25)																int i23 = (_g74 - 1);
HXDLIN(  25)																{
HXLINE(  25)																	 ::haxe::io::ArrayBufferViewImpl this107 = b28->data;
HXDLIN(  25)																	bool undoImage11;
HXDLIN(  25)																	if ((i23 >= 0)) {
HXLINE(  25)																		undoImage11 = (i23 < (this107->byteLength >> 2));
            																	}
            																	else {
HXLINE(  25)																		undoImage11 = false;
            																	}
HXDLIN(  25)																	if (undoImage11) {
HXLINE(  25)																		 ::haxe::io::Bytes _this3 = this107->bytes;
HXDLIN(  25)																		int pos3 = ((i23 << 2) + this107->byteOffset);
HXDLIN(  25)																		_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN(  25)																		_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN(  25)																		_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN(  25)																		_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
HXDLIN(  25)													undoImage10 = b28;
            												}
            												break;
            												case (int)3: {
HXLINE(  25)													 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  25)													 ::iterMagic::VecIntImg v9 = vec3;
HXDLIN(  25)													{
HXLINE(  25)														v9->width = width3;
HXDLIN(  25)														v9->height = height3;
HXDLIN(  25)														v9->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  25)														v9->data = ::Array_obj< int >::__new(v9->length);
HXDLIN(  25)														{
HXLINE(  25)															int _g76 = 0;
HXDLIN(  25)															int _g77 = v9->length;
HXDLIN(  25)															while((_g76 < _g77)){
HXLINE(  25)																_g76 = (_g76 + 1);
HXDLIN(  25)																int i24 = (_g76 - 1);
HXDLIN(  25)																v9->data->__unsafe_set(i24,0);
            															}
            														}
            													}
HXDLIN(  25)													undoImage10 = v9;
            												}
            												break;
            												case (int)4: {
HXLINE(  25)													 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  25)													 ::iterMagic::StackIntImg b29 = sInt3;
HXDLIN(  25)													{
HXLINE(  25)														b29->width = width3;
HXDLIN(  25)														b29->height = height3;
HXDLIN(  25)														b29->length = ::Std_obj::_hx_int(( (Float)((width3 * height3)) ));
HXDLIN(  25)														b29->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  25)														{
HXLINE(  25)															int len7 = b29->length;
HXDLIN(  25)															 ::haxe::ds::GenericStack_Int d3 = b29->data;
HXDLIN(  25)															if (::hx::IsNull( d3->head )) {
HXLINE(  25)																int _g78 = 0;
HXDLIN(  25)																int _g79 = len7;
HXDLIN(  25)																while((_g78 < _g79)){
HXLINE(  25)																	_g78 = (_g78 + 1);
HXDLIN(  25)																	int i25 = (_g78 - 1);
HXDLIN(  25)																	d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            																}
            															}
            															else {
HXLINE(  25)																int _g80 = 0;
HXDLIN(  25)																int _g81 = len7;
HXDLIN(  25)																while((_g80 < _g81)){
HXLINE(  25)																	_g80 = (_g80 + 1);
HXDLIN(  25)																	int i26 = (_g80 - 1);
HXDLIN(  25)																	{
HXLINE(  25)																		 ::haxe::ds::GenericCell_Int l3 = b29->data->head;
HXDLIN(  25)																		 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN(  25)																		{
HXLINE(  25)																			int _g82 = 0;
HXDLIN(  25)																			int _g83 = i26;
HXDLIN(  25)																			while((_g82 < _g83)){
HXLINE(  25)																				_g82 = (_g82 + 1);
HXDLIN(  25)																				int i27 = (_g82 - 1);
HXLINE( 345)																				prev3 = l3;
HXLINE( 346)																				l3 = l3->next;
            																			}
            																		}
HXLINE(  25)																		if (::hx::IsNull( prev3 )) {
HXLINE(  25)																			b29->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  25)																			l3 = null();
            																		}
            																		else {
HXLINE(  25)																			prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  25)																			l3 = null();
            																		}
            																	}
            																}
            															}
            														}
            													}
HXDLIN(  25)													undoImage10 = b29;
            												}
            												break;
            											}
HXDLIN(  25)											this106->image = undoImage10;
HXDLIN(  25)											this106->width = width3;
HXDLIN(  25)											this106->height = height3;
HXDLIN(  25)											this106->imageType = ( (int)(imageType3) );
HXDLIN(  25)											undoImage9 = this106;
HXDLIN(  25)											{
HXLINE(  25)												int rectLeft3 = xIter33->start;
HXDLIN(  25)												int rectTop3 = yIter33->start;
HXDLIN(  25)												int rectRight3 = xIter33->max;
HXDLIN(  25)												bool forceClear3 = false;
HXDLIN(  25)												{
HXLINE(  25)													int _g84 = rectTop3;
HXDLIN(  25)													int _g85 = yIter33->max;
HXDLIN(  25)													while((_g84 < _g85)){
HXLINE(  25)														_g84 = (_g84 + 1);
HXDLIN(  25)														int dy3 = (_g84 - 1);
HXDLIN(  25)														{
HXLINE(  25)															int _g86 = rectLeft3;
HXDLIN(  25)															int _g87 = rectRight3;
HXDLIN(  25)															while((_g86 < _g87)){
HXLINE(  25)																_g86 = (_g86 + 1);
HXDLIN(  25)																int dx3 = (_g86 - 1);
HXDLIN(  25)																::Dynamic this108 = this105->image;
HXDLIN(  25)																int index15;
HXDLIN(  25)																if (this105->useVirtualPos) {
HXLINE(  25)																	index15 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - this105->virtualY) * ( (Float)(this105->width) )) + dx3) - this105->virtualX));
            																}
            																else {
HXLINE(  25)																	index15 = ::Std_obj::_hx_int(( (Float)(((dy3 * this105->width) + dx3)) ));
            																}
HXDLIN(  25)																int c12 = ::iterMagic::Iimg_obj::get(this108,index15);
HXDLIN(  25)																int col3;
HXDLIN(  25)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)																	col3 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            																}
            																else {
HXLINE(  25)																	col3 = c12;
            																}
HXDLIN(  25)																bool _hx_tmp24;
HXDLIN(  25)																if (this105->useMask) {
HXLINE(  25)																	_hx_tmp24 = ::hx::IsNotNull( this105->mask );
            																}
            																else {
HXLINE(  25)																	_hx_tmp24 = false;
            																}
HXDLIN(  25)																if (_hx_tmp24) {
HXLINE(  25)																	 ::pi_xy::ImageStruct this109 = this105->mask;
HXDLIN(  25)																	::Dynamic this110 = this109->image;
HXDLIN(  25)																	int index16;
HXDLIN(  25)																	if (this109->useVirtualPos) {
HXLINE(  25)																		index16 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - this109->virtualY) * ( (Float)(this109->width) )) + dx3) - this109->virtualX));
            																	}
            																	else {
HXLINE(  25)																		index16 = ::Std_obj::_hx_int(( (Float)(((dy3 * this109->width) + dx3)) ));
            																	}
HXDLIN(  25)																	int c13 = ::iterMagic::Iimg_obj::get(this110,index16);
HXDLIN(  25)																	int v10;
HXDLIN(  25)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)																		v10 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            																	}
            																	else {
HXLINE(  25)																		v10 = c13;
            																	}
HXDLIN(  25)																	int maskPixel3 = v10;
HXDLIN(  25)																	int this111 = col3;
HXDLIN(  25)																	if ((maskPixel3 == 0)) {
HXLINE(  25)																		col3 = this111;
            																	}
            																	else {
HXLINE(  25)																		Float m03;
HXDLIN(  25)																		int this112 = ((maskPixel3 >> 24) & 255);
HXDLIN(  25)																		if ((this112 == 0)) {
HXLINE(  25)																			m03 = ((Float)0.);
            																		}
            																		else {
HXLINE(  25)																			m03 = (( (Float)(this112) ) / ( (Float)(255) ));
            																		}
HXDLIN(  25)																		Float m13;
HXDLIN(  25)																		int this113 = ((maskPixel3 >> 16) & 255);
HXDLIN(  25)																		if ((this113 == 0)) {
HXLINE(  25)																			m13 = ((Float)0.);
            																		}
            																		else {
HXLINE(  25)																			m13 = (( (Float)(this113) ) / ( (Float)(255) ));
            																		}
HXDLIN(  25)																		Float m23;
HXDLIN(  25)																		int this114 = ((maskPixel3 >> 8) & 255);
HXDLIN(  25)																		if ((this114 == 0)) {
HXLINE(  25)																			m23 = ((Float)0.);
            																		}
            																		else {
HXLINE(  25)																			m23 = (( (Float)(this114) ) / ( (Float)(255) ));
            																		}
HXDLIN(  25)																		Float m33;
HXDLIN(  25)																		int this115 = (maskPixel3 & 255);
HXDLIN(  25)																		if ((this115 == 0)) {
HXLINE(  25)																			m33 = ((Float)0.);
            																		}
            																		else {
HXLINE(  25)																			m33 = (( (Float)(this115) ) / ( (Float)(255) ));
            																		}
HXDLIN(  25)																		int ch03 = ::Std_obj::_hx_int(((((Float)1.) - m03) * ( (Float)(((this111 >> 24) & 255)) )));
HXDLIN(  25)																		int ch13 = ::Std_obj::_hx_int(((((Float)1.) - m13) * ( (Float)(((this111 >> 16) & 255)) )));
HXDLIN(  25)																		int ch23 = ::Std_obj::_hx_int(((((Float)1.) - m23) * ( (Float)(((this111 >> 8) & 255)) )));
HXDLIN(  25)																		int ch33 = ::Std_obj::_hx_int(((((Float)1.) - m33) * ( (Float)((this111 & 255)) )));
HXDLIN(  25)																		col3 = ((((::Math_obj::round((( (Float)(ch03) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch13) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch23) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch33) ) * ( (Float)(255) ))));
            																	}
            																}
HXDLIN(  25)																if ((col3 != 0)) {
HXLINE(  25)																	int x13 = (dx3 - rectLeft3);
HXDLIN(  25)																	int y13 = (dy3 - rectTop3);
HXDLIN(  25)																	int c14 = col3;
HXDLIN(  25)																	bool _hx_tmp25;
HXDLIN(  25)																	if ((((c14 >> 24) & 255) < 254)) {
HXLINE(  25)																		_hx_tmp25 = undoImage9->transparent;
            																	}
            																	else {
HXLINE(  25)																		_hx_tmp25 = false;
            																	}
HXDLIN(  25)																	if (_hx_tmp25) {
HXLINE(  25)																		int location6;
HXDLIN(  25)																		if (undoImage9->useVirtualPos) {
HXLINE(  25)																			location6 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x13) - undoImage9->virtualX));
            																		}
            																		else {
HXLINE(  25)																			location6 = ::Std_obj::_hx_int(( (Float)(((y13 * undoImage9->width) + x13)) ));
            																		}
HXDLIN(  25)																		int this116 = ::iterMagic::Iimg_obj::get(undoImage9->image,location6);
HXDLIN(  25)																		int this117;
HXDLIN(  25)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)																			this117 = ((((((this116 >> 24) & 255) << 24) | ((this116 & 255) << 16)) | (((this116 >> 8) & 255) << 8)) | ((this116 >> 16) & 255));
            																		}
            																		else {
HXLINE(  25)																			this117 = this116;
            																		}
HXDLIN(  25)																		Float a18;
HXDLIN(  25)																		int this118 = ((this117 >> 24) & 255);
HXDLIN(  25)																		if ((this118 == 0)) {
HXLINE(  25)																			a18 = ((Float)0.);
            																		}
            																		else {
HXLINE(  25)																			a18 = (( (Float)(this118) ) / ( (Float)(255) ));
            																		}
HXDLIN(  25)																		Float r16;
HXDLIN(  25)																		int this119 = ((this117 >> 16) & 255);
HXDLIN(  25)																		if ((this119 == 0)) {
HXLINE(  25)																			r16 = ((Float)0.);
            																		}
            																		else {
HXLINE(  25)																			r16 = (( (Float)(this119) ) / ( (Float)(255) ));
            																		}
HXDLIN(  25)																		Float g16;
HXDLIN(  25)																		int this120 = ((this117 >> 8) & 255);
HXDLIN(  25)																		if ((this120 == 0)) {
HXLINE(  25)																			g16 = ((Float)0.);
            																		}
            																		else {
HXLINE(  25)																			g16 = (( (Float)(this120) ) / ( (Float)(255) ));
            																		}
HXDLIN(  25)																		Float b110;
HXDLIN(  25)																		int this121 = (this117 & 255);
HXDLIN(  25)																		if ((this121 == 0)) {
HXLINE(  25)																			b110 = ((Float)0.);
            																		}
            																		else {
HXLINE(  25)																			b110 = (( (Float)(this121) ) / ( (Float)(255) ));
            																		}
HXDLIN(  25)																		Float a26;
HXDLIN(  25)																		int this122 = ((col3 >> 24) & 255);
HXDLIN(  25)																		if ((this122 == 0)) {
HXLINE(  25)																			a26 = ((Float)0.);
            																		}
            																		else {
HXLINE(  25)																			a26 = (( (Float)(this122) ) / ( (Float)(255) ));
            																		}
HXDLIN(  25)																		Float r26;
HXDLIN(  25)																		int this123 = ((col3 >> 16) & 255);
HXDLIN(  25)																		if ((this123 == 0)) {
HXLINE(  25)																			r26 = ((Float)0.);
            																		}
            																		else {
HXLINE(  25)																			r26 = (( (Float)(this123) ) / ( (Float)(255) ));
            																		}
HXDLIN(  25)																		Float g26;
HXDLIN(  25)																		int this124 = ((col3 >> 8) & 255);
HXDLIN(  25)																		if ((this124 == 0)) {
HXLINE(  25)																			g26 = ((Float)0.);
            																		}
            																		else {
HXLINE(  25)																			g26 = (( (Float)(this124) ) / ( (Float)(255) ));
            																		}
HXDLIN(  25)																		Float b210;
HXDLIN(  25)																		int this125 = (col3 & 255);
HXDLIN(  25)																		if ((this125 == 0)) {
HXLINE(  25)																			b210 = ((Float)0.);
            																		}
            																		else {
HXLINE(  25)																			b210 = (( (Float)(this125) ) / ( (Float)(255) ));
            																		}
HXDLIN(  25)																		Float a36 = (a18 * (( (Float)(1) ) - a26));
HXDLIN(  25)																		int r9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r16 * a36) + (r26 * a26))));
HXDLIN(  25)																		int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g16 * a36) + (g26 * a26))));
HXDLIN(  25)																		int b30 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a36) + (b210 * a26))));
HXDLIN(  25)																		int a19 = ::Std_obj::_hx_int((( (Float)(255) ) * (a36 + a26)));
HXDLIN(  25)																		int blended6 = ((((a19 << 24) | (r9 << 16)) | (g8 << 8)) | b30);
HXDLIN(  25)																		{
HXLINE(  25)																			int _hx_tmp26;
HXDLIN(  25)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)																				_hx_tmp26 = ((((((blended6 >> 24) & 255) << 24) | ((blended6 & 255) << 16)) | (((blended6 >> 8) & 255) << 8)) | ((blended6 >> 16) & 255));
            																			}
            																			else {
HXLINE(  25)																				_hx_tmp26 = blended6;
            																			}
HXDLIN(  25)																			::iterMagic::Iimg_obj::set(undoImage9->image,location6,_hx_tmp26);
            																		}
            																	}
            																	else {
HXLINE(  25)																		::Dynamic this126 = undoImage9->image;
HXDLIN(  25)																		int index17;
HXDLIN(  25)																		if (undoImage9->useVirtualPos) {
HXLINE(  25)																			index17 = ::Std_obj::_hx_int(((((( (Float)(y13) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x13) - undoImage9->virtualX));
            																		}
            																		else {
HXLINE(  25)																			index17 = ::Std_obj::_hx_int(( (Float)(((y13 * undoImage9->width) + x13)) ));
            																		}
HXDLIN(  25)																		int _hx_tmp27;
HXDLIN(  25)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)																			_hx_tmp27 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            																		}
            																		else {
HXLINE(  25)																			_hx_tmp27 = c14;
            																		}
HXDLIN(  25)																		::iterMagic::Iimg_obj::set(this126,index17,_hx_tmp27);
            																	}
            																}
            																else {
HXLINE(  25)																	if (forceClear3) {
HXLINE(  25)																		::Dynamic this127 = undoImage9->image;
HXDLIN(  25)																		int x14 = (dx3 - rectLeft3);
HXDLIN(  25)																		int y14 = (dy3 - rectTop3);
HXDLIN(  25)																		int index18;
HXDLIN(  25)																		if (undoImage9->useVirtualPos) {
HXLINE(  25)																			index18 = ::Std_obj::_hx_int(((((( (Float)(y14) ) - undoImage9->virtualY) * ( (Float)(undoImage9->width) )) + x14) - undoImage9->virtualX));
            																		}
            																		else {
HXLINE(  25)																			index18 = ::Std_obj::_hx_int(( (Float)(((y14 * undoImage9->width) + x14)) ));
            																		}
HXDLIN(  25)																		::iterMagic::Iimg_obj::set(this127,index18,0);
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  25)										bool found3 = false;
HXDLIN(  25)										Float s3 = ((Float)0.);
HXDLIN(  25)										Float t3 = ((Float)0.);
HXDLIN(  25)										Float sxx3 = ((Float)0.);
HXDLIN(  25)										Float txx3 = ((Float)0.);
HXDLIN(  25)										{
HXLINE(  25)											int _g_min6 = xIter33->start;
HXDLIN(  25)											int _g_max6 = xIter33->max;
HXDLIN(  25)											while((_g_min6 < _g_max6)){
HXLINE(  25)												_g_min6 = (_g_min6 + 1);
HXDLIN(  25)												int x15 = (_g_min6 - 1);
HXLINE(  60)												sxx3 = (sx3 * ( (Float)(x15) ));
HXLINE(  61)												txx3 = (tx3 * ( (Float)(x15) ));
HXLINE(  62)												found3 = false;
HXLINE(  25)												{
HXLINE(  25)													int _g_min7 = yIter33->start;
HXDLIN(  25)													int _g_max7 = yIter33->max;
HXDLIN(  25)													while((_g_min7 < _g_max7)){
HXLINE(  25)														_g_min7 = (_g_min7 + 1);
HXDLIN(  25)														int y15 = (_g_min7 - 1);
HXLINE(  64)														s3 = ((s03 + sxx3) + (sy3 * ( (Float)(y15) )));
HXLINE(  65)														t3 = ((t03 + txx3) + (ty3 * ( (Float)(y15) )));
HXLINE(  25)														bool _hx_tmp28;
HXDLIN(  25)														if (!((s3 <= 0))) {
HXLINE(  25)															_hx_tmp28 = (t3 <= 0);
            														}
            														else {
HXLINE(  25)															_hx_tmp28 = true;
            														}
HXDLIN(  25)														if (_hx_tmp28) {
HXLINE(  25)															if (found3) {
HXLINE(  25)																goto _hx_goto_63;
            															}
            														}
            														else {
HXLINE(  25)															if (((s3 + t3) < A3)) {
HXLINE(  25)																{
HXLINE(  25)																	int c15 = color1;
HXDLIN(  25)																	bool _hx_tmp29;
HXDLIN(  25)																	if ((((c15 >> 24) & 255) < 254)) {
HXLINE(  25)																		_hx_tmp29 = this105->transparent;
            																	}
            																	else {
HXLINE(  25)																		_hx_tmp29 = false;
            																	}
HXDLIN(  25)																	if (_hx_tmp29) {
HXLINE(  25)																		int location7;
HXDLIN(  25)																		if (this105->useVirtualPos) {
HXLINE(  25)																			location7 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - this105->virtualY) * ( (Float)(this105->width) )) + x15) - this105->virtualX));
            																		}
            																		else {
HXLINE(  25)																			location7 = ::Std_obj::_hx_int(( (Float)(((y15 * this105->width) + x15)) ));
            																		}
HXDLIN(  25)																		int this128 = ::iterMagic::Iimg_obj::get(this105->image,location7);
HXDLIN(  25)																		int this129;
HXDLIN(  25)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)																			this129 = ((((((this128 >> 24) & 255) << 24) | ((this128 & 255) << 16)) | (((this128 >> 8) & 255) << 8)) | ((this128 >> 16) & 255));
            																		}
            																		else {
HXLINE(  25)																			this129 = this128;
            																		}
HXDLIN(  25)																		Float a110;
HXDLIN(  25)																		int this130 = ((this129 >> 24) & 255);
HXDLIN(  25)																		if ((this130 == 0)) {
HXLINE(  25)																			a110 = ((Float)0.);
            																		}
            																		else {
HXLINE(  25)																			a110 = (( (Float)(this130) ) / ( (Float)(255) ));
            																		}
HXDLIN(  25)																		Float r17;
HXDLIN(  25)																		int this131 = ((this129 >> 16) & 255);
HXDLIN(  25)																		if ((this131 == 0)) {
HXLINE(  25)																			r17 = ((Float)0.);
            																		}
            																		else {
HXLINE(  25)																			r17 = (( (Float)(this131) ) / ( (Float)(255) ));
            																		}
HXDLIN(  25)																		Float g17;
HXDLIN(  25)																		int this132 = ((this129 >> 8) & 255);
HXDLIN(  25)																		if ((this132 == 0)) {
HXLINE(  25)																			g17 = ((Float)0.);
            																		}
            																		else {
HXLINE(  25)																			g17 = (( (Float)(this132) ) / ( (Float)(255) ));
            																		}
HXDLIN(  25)																		Float b111;
HXDLIN(  25)																		int this133 = (this129 & 255);
HXDLIN(  25)																		if ((this133 == 0)) {
HXLINE(  25)																			b111 = ((Float)0.);
            																		}
            																		else {
HXLINE(  25)																			b111 = (( (Float)(this133) ) / ( (Float)(255) ));
            																		}
HXDLIN(  25)																		Float a27;
HXDLIN(  25)																		int this134 = ((color1 >> 24) & 255);
HXDLIN(  25)																		if ((this134 == 0)) {
HXLINE(  25)																			a27 = ((Float)0.);
            																		}
            																		else {
HXLINE(  25)																			a27 = (( (Float)(this134) ) / ( (Float)(255) ));
            																		}
HXDLIN(  25)																		Float r27;
HXDLIN(  25)																		int this135 = ((color1 >> 16) & 255);
HXDLIN(  25)																		if ((this135 == 0)) {
HXLINE(  25)																			r27 = ((Float)0.);
            																		}
            																		else {
HXLINE(  25)																			r27 = (( (Float)(this135) ) / ( (Float)(255) ));
            																		}
HXDLIN(  25)																		Float g27;
HXDLIN(  25)																		int this136 = ((color1 >> 8) & 255);
HXDLIN(  25)																		if ((this136 == 0)) {
HXLINE(  25)																			g27 = ((Float)0.);
            																		}
            																		else {
HXLINE(  25)																			g27 = (( (Float)(this136) ) / ( (Float)(255) ));
            																		}
HXDLIN(  25)																		Float b211;
HXDLIN(  25)																		int this137 = (color1 & 255);
HXDLIN(  25)																		if ((this137 == 0)) {
HXLINE(  25)																			b211 = ((Float)0.);
            																		}
            																		else {
HXLINE(  25)																			b211 = (( (Float)(this137) ) / ( (Float)(255) ));
            																		}
HXDLIN(  25)																		Float a37 = (a110 * (( (Float)(1) ) - a27));
HXDLIN(  25)																		int r10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r17 * a37) + (r27 * a27))));
HXDLIN(  25)																		int g9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g17 * a37) + (g27 * a27))));
HXDLIN(  25)																		int b31 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a37) + (b211 * a27))));
HXDLIN(  25)																		int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a37 + a27)));
HXDLIN(  25)																		int blended7 = ((((a20 << 24) | (r10 << 16)) | (g9 << 8)) | b31);
HXDLIN(  25)																		{
HXLINE(  25)																			int _hx_tmp30;
HXDLIN(  25)																			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)																				_hx_tmp30 = ((((((blended7 >> 24) & 255) << 24) | ((blended7 & 255) << 16)) | (((blended7 >> 8) & 255) << 8)) | ((blended7 >> 16) & 255));
            																			}
            																			else {
HXLINE(  25)																				_hx_tmp30 = blended7;
            																			}
HXDLIN(  25)																			::iterMagic::Iimg_obj::set(this105->image,location7,_hx_tmp30);
            																		}
            																	}
            																	else {
HXLINE(  25)																		::Dynamic this138 = this105->image;
HXDLIN(  25)																		int index19;
HXDLIN(  25)																		if (this105->useVirtualPos) {
HXLINE(  25)																			index19 = ::Std_obj::_hx_int(((((( (Float)(y15) ) - this105->virtualY) * ( (Float)(this105->width) )) + x15) - this105->virtualX));
            																		}
            																		else {
HXLINE(  25)																			index19 = ::Std_obj::_hx_int(( (Float)(((y15 * this105->width) + x15)) ));
            																		}
HXDLIN(  25)																		int _hx_tmp31;
HXDLIN(  25)																		if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)																			_hx_tmp31 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            																		}
            																		else {
HXLINE(  25)																			_hx_tmp31 = c15;
            																		}
HXDLIN(  25)																		::iterMagic::Iimg_obj::set(this138,index19,_hx_tmp31);
            																	}
            																}
HXLINE(  73)																found3 = true;
            															}
            															else {
HXLINE(  25)																if (found3) {
HXLINE(  25)																	goto _hx_goto_63;
            																}
            															}
            														}
            													}
            													_hx_goto_63:;
            												}
            											}
            										}
HXDLIN(  25)										if ((hasHit3 == true)) {
HXLINE(  25)											 ::pi_xy::algo::HitTri v11 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,innerCx,innerCy,bx3,by3,cx4,cy4,true);
HXDLIN(  25)											if (hasUndo3) {
HXLINE(  25)												v11->undoImage = undoImage9;
HXDLIN(  25)												v11->undoX = xIter33->start;
HXDLIN(  25)												v11->undoY = yIter33->start;
            											}
            										}
            									}
            								}
            							}
HXLINE(  59)							lastX1 = nextX3;
HXLINE(  60)							lastY1 = nextY3;
            						}
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(CircleForm_obj,buildCircle,(void))


::hx::ObjectPtr< CircleForm_obj > CircleForm_obj::__new( ::Dynamic opacity, ::Dynamic visibility, ::Dynamic strokeColor, ::Dynamic strokeWidth,::Array< ::String > strokeDashGapArray, ::Dynamic fill, ::Dynamic left, ::Dynamic top, ::Dynamic diameter) {
	::hx::ObjectPtr< CircleForm_obj > __this = new CircleForm_obj();
	__this->__construct(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,diameter);
	return __this;
}

::hx::ObjectPtr< CircleForm_obj > CircleForm_obj::__alloc(::hx::Ctx *_hx_ctx, ::Dynamic opacity, ::Dynamic visibility, ::Dynamic strokeColor, ::Dynamic strokeWidth,::Array< ::String > strokeDashGapArray, ::Dynamic fill, ::Dynamic left, ::Dynamic top, ::Dynamic diameter) {
	CircleForm_obj *__this = (CircleForm_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(CircleForm_obj), true, "pi_xy.triangleGML.CircleForm"));
	*(void **)__this = CircleForm_obj::_hx_vtable;
	__this->__construct(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,fill,left,top,diameter);
	return __this;
}

CircleForm_obj::CircleForm_obj()
{
}

::hx::Val CircleForm_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"buildCircle") ) { return ::hx::Val( buildCircle_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *CircleForm_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *CircleForm_obj_sStaticStorageInfo = 0;
#endif

static ::String CircleForm_obj_sMemberFields[] = {
	HX_("render",56,6b,29,05),
	HX_("buildCircle",de,57,7e,a6),
	::String(null()) };

::hx::Class CircleForm_obj::__mClass;

void CircleForm_obj::__register()
{
	CircleForm_obj _hx_dummy;
	CircleForm_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pi_xy.triangleGML.CircleForm",2b,35,0e,38);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(CircleForm_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< CircleForm_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = CircleForm_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = CircleForm_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pi_xy
} // end namespace triangleGML
