// Generated by Haxe 4.3.0-rc.1+3cdd184
(function ($global) { "use strict";
Math.__name__ = true;
class Std {
	static string(s) {
		return js_Boot.__string_rec(s,"");
	}
}
Std.__name__ = true;
class StringTools {
	static hex(n,digits) {
		let s = "";
		while(true) {
			s = "0123456789ABCDEF".charAt(n & 15) + s;
			n >>>= 4;
			if(!(n > 0)) {
				break;
			}
		}
		if(digits != null) {
			while(s.length < digits) s = "0" + s;
		}
		return s;
	}
}
StringTools.__name__ = true;
class haxe_Log {
	static formatOutput(v,infos) {
		let str = Std.string(v);
		if(infos == null) {
			return str;
		}
		let pstr = infos.fileName + ":" + infos.lineNumber;
		if(infos.customParams != null) {
			let _g = 0;
			let _g1 = infos.customParams;
			while(_g < _g1.length) str += ", " + Std.string(_g1[_g++]);
		}
		return pstr + ": " + str;
	}
	static trace(v,infos) {
		let str = haxe_Log.formatOutput(v,infos);
		if(typeof(console) != "undefined" && console.log != null) {
			console.log(str);
		}
	}
}
haxe_Log.__name__ = true;
class haxe_ds_GenericCell {
	constructor(elt,next) {
		this.elt = elt;
		this.next = next;
	}
}
haxe_ds_GenericCell.__name__ = true;
class haxe_ds_GenericStack {
	constructor() {
	}
}
haxe_ds_GenericStack.__name__ = true;
class haxe_ds_StringMap {
	constructor() {
		this.h = Object.create(null);
	}
}
haxe_ds_StringMap.__name__ = true;
class haxe_io_Bytes {
	constructor(data) {
		this.length = data.byteLength;
		this.b = new Uint8Array(data);
		this.b.bufferValue = data;
		data.hxBytes = this;
		data.bytes = this.b;
	}
	getInt32(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getInt32(pos,true);
	}
	setInt32(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setInt32(pos,v,true);
	}
}
haxe_io_Bytes.__name__ = true;
class haxe_iterators_ArrayIterator {
	constructor(array) {
		this.current = 0;
		this.array = array;
	}
	hasNext() {
		return this.current < this.array.length;
	}
	next() {
		return this.array[this.current++];
	}
}
haxe_iterators_ArrayIterator.__name__ = true;
class htmlHelper_canvas_CanvasSetup {
	constructor(allowOverSample) {
		if(allowOverSample == null) {
			allowOverSample = true;
		}
		this.factor = 4.;
		this.divertTrace = new htmlHelper_tools_DivertTrace();
		let this1;
		let canvas = window.document.createElement("canvas");
		let style = canvas.style;
		style.paddingLeft = "0px";
		style.paddingTop = "0px";
		style.left = "0px";
		style.top = "0px";
		style.position = "absolute";
		this1 = canvas;
		this.canvasWrapper = this1;
		this.canvasWrapper.width = 1024;
		this.canvasWrapper.height = 768;
		this.canvasWrapper.style.background = "black";
		window.document.body.appendChild(this.canvasWrapper);
		let canvasPlus = new htmlHelper_canvas_CanvasPlus(this.canvasWrapper.getContext("2d",null),10,10);
		canvasPlus.me.lineWidth = 1;
		let tmp = StringTools.hex(16744272,6);
		canvasPlus.me.strokeStyle = "#" + tmp;
		this.surface = canvasPlus;
		if(allowOverSample) {
			this.overSampleCanvas();
		}
	}
	overSampleCanvas() {
		let canvas = this.canvasWrapper;
		let width = canvas.width;
		let height = canvas.height;
		canvas.width = 0 | (width * this.factor | 0);
		canvas.height = 0 | (height * this.factor | 0);
		let style = this.canvasWrapper.style;
		style.width = width + "px";
		style.height = height + "px";
		this.surface.me.scale(this.factor,this.factor);
	}
}
htmlHelper_canvas_CanvasSetup.__name__ = true;
class htmlHelper_canvas_CanvasPlus {
	constructor(me,x,y) {
		if(y == null) {
			y = 0;
		}
		if(x == null) {
			x = 0;
		}
		this.y = 0.;
		this.x = 0.;
		this.x = x;
		this.y = y;
		this.me = me;
	}
}
htmlHelper_canvas_CanvasPlus.__name__ = true;
class htmlHelper_tools_DivertTrace {
	constructor(left,d) {
		if(left == null) {
			left = 610;
		}
		this.textStyle1 = "<span style=\"font-size:14px; color:Grey\">";
		this.textStyle0 = "<span style=\"font-size:12px; color:Silver\">";
		this.traceString = "";
		this.divertTrace(left,d);
	}
	divertTrace(left,d) {
		if(d == null) {
			let doc = window.document;
			this.traceDiv = doc.createElement("div");
			doc.body.appendChild(this.traceDiv);
			let style = this.traceDiv.style;
			style.position = "absolute";
			style.top = "0px";
			style.left = (left == null ? "null" : "" + left) + "px";
			style.height = "500px";
			style.width = "500px";
			style.zIndex = "99";
			style.overflow = "auto";
		} else {
			this.traceDiv = d;
		}
		haxe_Log.trace = $bind(this,this.myTrace);
	}
	myTrace(v,inf) {
		if(Std.string(v) == "") {
			return;
		}
		this.traceString += this.textStyle0 + inf.className + "." + inf.methodName + " ( " + (inf.lineNumber == null ? "null" : "" + inf.lineNumber) + " )" + "</span>" + "<br> - " + this.textStyle1 + Std.string(v) + "</span>" + "<br>";
		this.traceDiv.innerHTML = this.traceString;
	}
}
htmlHelper_tools_DivertTrace.__name__ = true;
class htmlHelper_tools_ImageLoader {
	constructor(imageNames,loaded_) {
		this.images = new haxe_ds_StringMap();
		this.loaded = loaded_;
		this.count = imageNames.length;
		let _g = 0;
		while(_g < imageNames.length) this.load(imageNames[_g++]);
	}
	load(img) {
		let image = window.document.createElement("img");
		let imgStyle = image.style;
		imgStyle.left = "0px";
		imgStyle.top = "0px";
		imgStyle.paddingLeft = "0px";
		imgStyle.paddingTop = "0px";
		let _g = $bind(this,this.store);
		let image1 = image;
		let name = img.split("/").pop();
		image.onload = function(e) {
			_g(image1,name,e);
		};
		imgStyle.position = "absolute";
		image.src = img;
	}
	loadEncoded(imageEncoded,imageNames) {
		this.count = imageNames.length;
		let _g = 0;
		let _g1 = this.count;
		while(_g < _g1) {
			let i = _g++;
			this.encodedLoad(imageEncoded[i],imageNames[i]);
		}
	}
	encodedLoad(imgStr,name) {
		let image = window.document.createElement("img");
		let imgStyle = image.style;
		imgStyle.left = "0px";
		imgStyle.top = "0px";
		imgStyle.paddingLeft = "0px";
		imgStyle.paddingTop = "0px";
		let _g = $bind(this,this.store);
		let image1 = image;
		let name1 = name;
		image.onload = function(e) {
			_g(image1,name1,e);
		};
		imgStyle.position = "absolute";
		image.src = imgStr;
	}
	store(image,name,e) {
		this.count--;
		haxe_Log.trace("store " + name + " " + this.count,{ fileName : "htmlHelper/tools/ImageLoader.hx", lineNumber : 52, className : "htmlHelper.tools.ImageLoader", methodName : "store"});
		this.images.h[name] = image;
		if(this.count == 0) {
			this.loaded();
		}
	}
}
htmlHelper_tools_ImageLoader.__name__ = true;
class iterMagic_ArrIntImg {
	constructor() {
	}
	set(index,value) {
		this.data[index] = value;
		return value;
	}
	get(index) {
		return this.data[index];
	}
}
iterMagic_ArrIntImg.__name__ = true;
class iterMagic_VecIntImg {
	constructor() {
	}
	set(index,value) {
		this.data[index] = value;
		return value;
	}
	get(index) {
		return this.data[index];
	}
}
iterMagic_VecIntImg.__name__ = true;
class iterMagic_BytesImg {
	constructor() {
	}
	set(index,value) {
		this.data.setInt32(index * 4 | 0,value);
		return value;
	}
	get(index) {
		return this.data.getInt32(index * 4 | 0);
	}
}
iterMagic_BytesImg.__name__ = true;
class iterMagic_U32ArrImg {
	constructor() {
	}
	set(index,value) {
		this.data[index] = value;
		return value;
	}
	get(index) {
		return this.data[index];
	}
}
iterMagic_U32ArrImg.__name__ = true;
class iterMagic_StackIntImg {
	constructor() {
	}
	set(index,value) {
		let l = this.data.head;
		let prev = null;
		let _g = 0;
		while(_g < index) {
			++_g;
			prev = l;
			l = l.next;
		}
		if(prev == null) {
			this.data.head = new haxe_ds_GenericCell(value,l.next);
			l = null;
		} else {
			prev.next = new haxe_ds_GenericCell(value,l.next);
			l = null;
		}
		return value;
	}
	get(index) {
		let l = this.data.head;
		let prev = l;
		++index;
		let _g = 0;
		let _g1 = index;
		while(_g < _g1) {
			++_g;
			prev = l;
			l = l.next;
		}
		return prev.elt;
	}
}
iterMagic_StackIntImg.__name__ = true;
class js_Boot {
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		let t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(((o) instanceof Array)) {
				let str = "[";
				s += "\t";
				let _g = 0;
				let _g1 = o.length;
				while(_g < _g1) {
					let i = _g++;
					str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
				}
				str += "]";
				return str;
			}
			let tostr;
			try {
				tostr = o.toString;
			} catch( _g ) {
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				let s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			let str = "{\n";
			s += "\t";
			let hasp = o.hasOwnProperty != null;
			let k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str.length != 2) {
				str += ", \n";
			}
			str += s + k + " : " + js_Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str += "\n" + s + "}";
			return str;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
}
js_Boot.__name__ = true;
class pi_$xy_ImageStruct {
	constructor() {
		this.useMask = false;
		this.useVirtualPos = false;
		this.virtualY = 0;
		this.virtualX = 0;
		this.transparent = false;
		this.isLittle = pi_$xy_Endian_isLittleEndian;
		this.transparent = false;
	}
}
pi_$xy_ImageStruct.__name__ = true;
class pi_$xy_algo_QuadPoints_$ {
}
pi_$xy_algo_QuadPoints_$.__name__ = true;
class pi_$xy_algo_HitQuad extends pi_$xy_algo_QuadPoints_$ {
}
pi_$xy_algo_HitQuad.__name__ = true;
class pi_$xy_algo_TriPoints_$ {
}
pi_$xy_algo_TriPoints_$.__name__ = true;
class pi_$xy_algo_HitTri extends pi_$xy_algo_TriPoints_$ {
}
pi_$xy_algo_HitTri.__name__ = true;
class pi_$xy_application_ConvolutionApp {
	constructor() {
		this.canvasSetup = new htmlHelper_canvas_CanvasSetup();
		this.imageLoader = new htmlHelper_tools_ImageLoader([],$bind(this,this.setup));
		this.imageLoader.loadEncoded([pi_$xy_textureImage_TestTiger_testTiger()],["tiger"]);
	}
	setup() {
		let images = this.imageLoader.images;
		this.surface = this.canvasSetup.surface;
		pi_$xy_ImageStruct.defaultType = 2;
		let imageType = null;
		let this1 = new pi_$xy_ImageStruct();
		imageType = pi_$xy_ImageStruct.defaultType;
		let imageType1 = imageType;
		if(imageType1 == null) {
			imageType1 = 2;
		}
		let tmp;
		switch(imageType1) {
		case 0:
			let b = new iterMagic_BytesImg();
			b.width = 4096;
			b.height = 3072;
			b.length = 12582912;
			b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
			let w = 0;
			let _g = 0;
			let _g1 = b.height;
			while(_g < _g1) {
				++_g;
				let _g1 = 0;
				let _g2 = b.width;
				while(_g1 < _g2) {
					++_g1;
					b.data.b[w++] = 0;
					b.data.b[w++] = 0;
					b.data.b[w++] = 0;
					b.data.b[w++] = 0;
				}
			}
			tmp = b;
			break;
		case 1:
			let a = new iterMagic_ArrIntImg();
			a.width = 4096;
			a.height = 3072;
			a.data = [];
			a.length = 12582912;
			let len = a.length;
			let _g2 = 0;
			while(_g2 < len) a.data[_g2++] = 0;
			tmp = a;
			break;
		case 2:
			let b1 = new iterMagic_U32ArrImg();
			b1.width = 4096;
			b1.height = 3072;
			b1.length = 12582912;
			b1.data = new Uint32Array(b1.length);
			let len1 = b1.length;
			let _g3 = 0;
			while(_g3 < len1) b1.data[_g3++] = 0;
			tmp = b1;
			break;
		case 3:
			let v = new iterMagic_VecIntImg();
			v.width = 4096;
			v.height = 3072;
			v.length = 12582912;
			let this2 = new Array(v.length);
			v.data = this2;
			let len2 = v.length;
			let _g4 = 0;
			while(_g4 < len2) v.data[_g4++] = 0;
			tmp = v;
			break;
		case 4:
			let b2 = new iterMagic_StackIntImg();
			b2.width = 4096;
			b2.height = 3072;
			b2.length = 12582912;
			b2.data = new haxe_ds_GenericStack();
			let len3 = b2.length;
			let d = b2.data;
			if(d.head == null) {
				let _g = 0;
				while(_g < len3) {
					++_g;
					d.head = new haxe_ds_GenericCell(0,d.head);
				}
			} else {
				let _g = 0;
				while(_g < len3) {
					let i = _g++;
					let l = b2.data.head;
					let prev = null;
					let _g1 = 0;
					while(_g1 < i) {
						++_g1;
						prev = l;
						l = l.next;
					}
					if(prev == null) {
						b2.data.head = new haxe_ds_GenericCell(0,l.next);
						l = null;
					} else {
						prev.next = new haxe_ds_GenericCell(0,l.next);
						l = null;
					}
				}
			}
			tmp = b2;
			break;
		}
		this1.image = tmp;
		this1.width = 4096;
		this1.height = 3072;
		this1.imageType = imageType;
		this.pixelimage = this1;
		this.pixelimage.transparent = true;
		let tiger = images.h["tiger"];
		let canvas = window.document.createElement("canvas");
		canvas.width = tiger.width;
		canvas.height = tiger.height;
		canvas.getContext("2d",null).drawImage(tiger,0,0,tiger.width,tiger.height);
		let width = tiger.width;
		let height = tiger.height;
		let imageType2 = null;
		let this3 = new pi_$xy_ImageStruct();
		imageType2 = pi_$xy_ImageStruct.defaultType;
		let imageType3 = imageType2;
		if(imageType3 == null) {
			imageType3 = 2;
		}
		let tmp1;
		switch(imageType3) {
		case 0:
			let b3 = new iterMagic_BytesImg();
			b3.width = width;
			b3.height = height;
			b3.length = width * height | 0;
			b3.data = new haxe_io_Bytes(new ArrayBuffer(b3.length * 4));
			let w1 = 0;
			let _g5 = 0;
			let _g6 = b3.height;
			while(_g5 < _g6) {
				++_g5;
				let _g = 0;
				let _g1 = b3.width;
				while(_g < _g1) {
					++_g;
					b3.data.b[w1++] = 0;
					b3.data.b[w1++] = 0;
					b3.data.b[w1++] = 0;
					b3.data.b[w1++] = 0;
				}
			}
			tmp1 = b3;
			break;
		case 1:
			let a1 = new iterMagic_ArrIntImg();
			a1.width = width;
			a1.height = height;
			a1.data = [];
			a1.length = width * height | 0;
			let len4 = a1.length;
			let _g7 = 0;
			while(_g7 < len4) a1.data[_g7++] = 0;
			tmp1 = a1;
			break;
		case 2:
			let b4 = new iterMagic_U32ArrImg();
			b4.width = width;
			b4.height = height;
			b4.length = width * height | 0;
			b4.data = new Uint32Array(b4.length);
			let len5 = b4.length;
			let _g8 = 0;
			while(_g8 < len5) b4.data[_g8++] = 0;
			tmp1 = b4;
			break;
		case 3:
			let v1 = new iterMagic_VecIntImg();
			v1.width = width;
			v1.height = height;
			v1.length = width * height | 0;
			let this4 = new Array(v1.length);
			v1.data = this4;
			let len6 = v1.length;
			let _g9 = 0;
			while(_g9 < len6) v1.data[_g9++] = 0;
			tmp1 = v1;
			break;
		case 4:
			let b5 = new iterMagic_StackIntImg();
			b5.width = width;
			b5.height = height;
			b5.length = width * height | 0;
			b5.data = new haxe_ds_GenericStack();
			let len7 = b5.length;
			let d1 = b5.data;
			if(d1.head == null) {
				let _g = 0;
				while(_g < len7) {
					++_g;
					d1.head = new haxe_ds_GenericCell(0,d1.head);
				}
			} else {
				let _g = 0;
				while(_g < len7) {
					let i = _g++;
					let l = b5.data.head;
					let prev = null;
					let _g1 = 0;
					while(_g1 < i) {
						++_g1;
						prev = l;
						l = l.next;
					}
					if(prev == null) {
						b5.data.head = new haxe_ds_GenericCell(0,l.next);
						l = null;
					} else {
						prev.next = new haxe_ds_GenericCell(0,l.next);
						l = null;
					}
				}
			}
			tmp1 = b5;
			break;
		}
		this3.image = tmp1;
		this3.width = width;
		this3.height = height;
		this3.imageType = imageType2;
		let pixelImage = this3;
		pixelImage.transparent = false;
		let ctx = canvas.getContext("2d",null);
		let base = pixelImage;
		let imageData = base.useVirtualPos ? ctx.getImageData(base.virtualX,base.virtualY,pixelImage.width,pixelImage.height) : ctx.getImageData(0,0,pixelImage.width,pixelImage.height);
		let data = imageData.data;
		let temp = new Uint32Array(data.buffer);
		let _g10 = 0;
		let _g11 = pixelImage.image.length;
		while(_g10 < _g11) {
			let i = _g10++;
			pixelImage.image.set(i,temp[i]);
		}
		canvas = null;
		let width1 = pixelImage.width * 5;
		let height1 = pixelImage.height * 5;
		let imageType4 = null;
		let this5 = new pi_$xy_ImageStruct();
		imageType4 = pi_$xy_ImageStruct.defaultType;
		let imageType5 = imageType4;
		if(imageType5 == null) {
			imageType5 = 2;
		}
		let tmp2;
		switch(imageType5) {
		case 0:
			let b6 = new iterMagic_BytesImg();
			b6.width = width1;
			b6.height = height1;
			b6.length = width1 * height1 | 0;
			b6.data = new haxe_io_Bytes(new ArrayBuffer(b6.length * 4));
			let w2 = 0;
			let _g12 = 0;
			let _g13 = b6.height;
			while(_g12 < _g13) {
				++_g12;
				let _g = 0;
				let _g1 = b6.width;
				while(_g < _g1) {
					++_g;
					b6.data.b[w2++] = 0;
					b6.data.b[w2++] = 0;
					b6.data.b[w2++] = 0;
					b6.data.b[w2++] = 0;
				}
			}
			tmp2 = b6;
			break;
		case 1:
			let a2 = new iterMagic_ArrIntImg();
			a2.width = width1;
			a2.height = height1;
			a2.data = [];
			a2.length = width1 * height1 | 0;
			let len8 = a2.length;
			let _g14 = 0;
			while(_g14 < len8) a2.data[_g14++] = 0;
			tmp2 = a2;
			break;
		case 2:
			let b7 = new iterMagic_U32ArrImg();
			b7.width = width1;
			b7.height = height1;
			b7.length = width1 * height1 | 0;
			b7.data = new Uint32Array(b7.length);
			let len9 = b7.length;
			let _g15 = 0;
			while(_g15 < len9) b7.data[_g15++] = 0;
			tmp2 = b7;
			break;
		case 3:
			let v2 = new iterMagic_VecIntImg();
			v2.width = width1;
			v2.height = height1;
			v2.length = width1 * height1 | 0;
			let this6 = new Array(v2.length);
			v2.data = this6;
			let len10 = v2.length;
			let _g16 = 0;
			while(_g16 < len10) v2.data[_g16++] = 0;
			tmp2 = v2;
			break;
		case 4:
			let b8 = new iterMagic_StackIntImg();
			b8.width = width1;
			b8.height = height1;
			b8.length = width1 * height1 | 0;
			b8.data = new haxe_ds_GenericStack();
			let len11 = b8.length;
			let d2 = b8.data;
			if(d2.head == null) {
				let _g = 0;
				while(_g < len11) {
					++_g;
					d2.head = new haxe_ds_GenericCell(0,d2.head);
				}
			} else {
				let _g = 0;
				while(_g < len11) {
					let i = _g++;
					let l = b8.data.head;
					let prev = null;
					let _g1 = 0;
					while(_g1 < i) {
						++_g1;
						prev = l;
						l = l.next;
					}
					if(prev == null) {
						b8.data.head = new haxe_ds_GenericCell(0,l.next);
						l = null;
					} else {
						prev.next = new haxe_ds_GenericCell(0,l.next);
						l = null;
					}
				}
			}
			tmp2 = b8;
			break;
		}
		this5.image = tmp2;
		this5.width = width1;
		this5.height = height1;
		this5.imageType = imageType4;
		let pix0 = this5;
		let x = 0;
		let y = 0;
		let wid = pixelImage.width * 5;
		let hi = pixelImage.height * 5;
		if(hi == null) {
			hi = 0.;
		}
		if(wid == null) {
			wid = 0.;
		}
		let width2 = pixelImage.width;
		let height2 = pixelImage.height;
		let win_x = 0;
		let win_y = 0;
		if(wid == 0.) {
			wid = pixelImage.width;
		}
		if(hi == 0.) {
			hi = pixelImage.height;
		}
		let bx = x + wid;
		let cx = x + wid;
		let cy = y + hi;
		let dy = y + hi;
		let bcx = bx - x;
		let bcy = y - dy;
		let acx = x - x;
		let acy = y - dy;
		let dot11 = bcx * bcx + bcy * bcy;
		let dot12 = bcx * acx + bcy * acy;
		let dot22 = acx * acx + acy * acy;
		let denom1 = 1 / (dot11 * dot22 - dot12 * dot12);
		let xIter3 = x > bx ? new pi_$xy_iter_IntIterStart(Math.floor(bx),Math.ceil(x)) : bx > x ? new pi_$xy_iter_IntIterStart(Math.ceil(x),Math.ceil(bx)) : new pi_$xy_iter_IntIterStart(Math.floor(x),Math.ceil(x));
		let yIter3 = y > dy ? new pi_$xy_iter_IntIterStart(y > dy ? Math.floor(dy) : Math.ceil(y),Math.ceil(y)) : new pi_$xy_iter_IntIterStart(Math.floor(y),Math.ceil(dy));
		let max = xIter3.max;
		let _g_min = xIter3.start;
		while(_g_min < max) {
			let px = _g_min++;
			let pcx = px - x;
			let max = yIter3.max;
			let _g_min1 = yIter3.start;
			while(_g_min1 < max) {
				let py = _g_min1++;
				let pcy = py - dy;
				let dot31 = pcx * bcx + pcy * bcy;
				let dot32 = pcx * acx + pcy * acy;
				let ratioA = (dot22 * dot31 - dot12 * dot32) * denom1;
				let ratioB = (dot11 * dot32 - dot12 * dot31) * denom1;
				let ratioC = 1.0 - ratioB - ratioA;
				if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
					let x = (ratioA + 0. * ratioB + 0. * ratioC) * width2 + win_x | 0;
					let y = (0. * ratioA + 0. * ratioB + ratioC) * height2 + win_y | 0;
					let c = pixelImage.image.get(pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0);
					let col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					let c1 = col;
					if((c1 >> 24 & 255) < 254 && pix0.transparent) {
						let location = pix0.useVirtualPos ? (py - pix0.virtualY) * pix0.width + px - pix0.virtualX | 0 : py * pix0.width + px | 0;
						let this1 = pix0.image.get(location);
						let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
						let this3 = this2 >> 24 & 255;
						let this4 = this2 >> 16 & 255;
						let this5 = this2 >> 8 & 255;
						let this6 = this2 & 255;
						let this7 = col >> 24 & 255;
						let a2 = this7 == 0 ? 0. : this7 / 255;
						let this8 = col >> 16 & 255;
						let this9 = col >> 8 & 255;
						let this10 = col & 255;
						let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
						let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
						pix0.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						pix0.image.set(pix0.useVirtualPos ? (py - pix0.virtualY) * pix0.width + px - pix0.virtualX | 0 : py * pix0.width + px | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
					}
				}
			}
		}
		let bcx1 = cx - x;
		let bcy1 = cy - dy;
		let acx1 = bx - x;
		let acy1 = y - dy;
		let dot111 = bcx1 * bcx1 + bcy1 * bcy1;
		let dot121 = bcx1 * acx1 + bcy1 * acy1;
		let dot221 = acx1 * acx1 + acy1 * acy1;
		let denom11 = 1 / (dot111 * dot221 - dot121 * dot121);
		let xIter31 = bx > cx ? bx > x ? new pi_$xy_iter_IntIterStart(cx > x ? Math.floor(x) : Math.floor(cx),Math.ceil(bx)) : new pi_$xy_iter_IntIterStart(Math.floor(cx),Math.ceil(x)) : cx > x ? new pi_$xy_iter_IntIterStart(bx > x ? Math.floor(x) : Math.ceil(bx),Math.ceil(cx)) : new pi_$xy_iter_IntIterStart(Math.floor(bx),Math.ceil(x));
		let yIter31 = y > cy ? y > dy ? new pi_$xy_iter_IntIterStart(cy > dy ? Math.floor(dy) : Math.floor(cy),Math.ceil(y)) : new pi_$xy_iter_IntIterStart(Math.floor(cy),Math.ceil(dy)) : cy > dy ? new pi_$xy_iter_IntIterStart(y > dy ? Math.floor(dy) : Math.ceil(y),Math.ceil(cy)) : new pi_$xy_iter_IntIterStart(Math.floor(y),Math.ceil(dy));
		let max1 = xIter31.max;
		let _g_min1 = xIter31.start;
		while(_g_min1 < max1) {
			let px = _g_min1++;
			let pcx = px - x;
			let max = yIter31.max;
			let _g_min = yIter31.start;
			while(_g_min < max) {
				let py = _g_min++;
				let pcy = py - dy;
				let dot31 = pcx * bcx1 + pcy * bcy1;
				let dot32 = pcx * acx1 + pcy * acy1;
				let ratioA = (dot221 * dot31 - dot121 * dot32) * denom11;
				let ratioB = (dot111 * dot32 - dot121 * dot31) * denom11;
				let ratioC = 1.0 - ratioB - ratioA;
				if(ratioA >= 0 && ratioB >= 0 && ratioC >= 0) {
					let x = (ratioA + ratioB + 0. * ratioC) * width2 + win_x | 0;
					let y = (ratioA + 0. * ratioB + ratioC) * height2 + win_y | 0;
					let c = pixelImage.image.get(pixelImage.useVirtualPos ? (y - pixelImage.virtualY) * pixelImage.width + x - pixelImage.virtualX | 0 : y * pixelImage.width + x | 0);
					let col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					let c1 = col;
					if((c1 >> 24 & 255) < 254 && pix0.transparent) {
						let location = pix0.useVirtualPos ? (py - pix0.virtualY) * pix0.width + px - pix0.virtualX | 0 : py * pix0.width + px | 0;
						let this1 = pix0.image.get(location);
						let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
						let this3 = this2 >> 24 & 255;
						let this4 = this2 >> 16 & 255;
						let this5 = this2 >> 8 & 255;
						let this6 = this2 & 255;
						let this7 = col >> 24 & 255;
						let a2 = this7 == 0 ? 0. : this7 / 255;
						let this8 = col >> 16 & 255;
						let this9 = col >> 8 & 255;
						let this10 = col & 255;
						let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
						let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
						pix0.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						pix0.image.set(pix0.useVirtualPos ? (py - pix0.virtualY) * pix0.width + px - pix0.virtualX | 0 : py * pix0.width + px | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
					}
				}
			}
		}
		let this7 = this.pixelimage;
		let _g17 = 0;
		let _g18 = pix0.height;
		while(_g17 < _g18) {
			let dy = _g17++;
			let _g = 0;
			let _g1 = pix0.width;
			while(_g < _g1) {
				let dx = _g++;
				let c = pix0.image.get(pix0.useVirtualPos ? (dy - pix0.virtualY) * pix0.width + dx - pix0.virtualX | 0 : dy * pix0.width + dx | 0);
				let col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				if(pix0.useMask && pix0.mask != null) {
					let this1 = pix0.mask;
					let c = this1.image.get(this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0);
					let maskPixel = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					let this2 = col;
					if(maskPixel == 0) {
						col = this2;
					} else {
						let this1 = maskPixel >> 24 & 255;
						let this3 = maskPixel >> 16 & 255;
						let this4 = maskPixel >> 8 & 255;
						let this5 = maskPixel & 255;
						col = Math.round(((1. - (this1 == 0 ? 0. : this1 / 255)) * (this2 >> 24 & 255) | 0) * 255) << 24 | Math.round(((1. - (this3 == 0 ? 0. : this3 / 255)) * (this2 >> 16 & 255) | 0) * 255) << 16 | Math.round(((1. - (this4 == 0 ? 0. : this4 / 255)) * (this2 >> 8 & 255) | 0) * 255) << 8 | Math.round(((1. - (this5 == 0 ? 0. : this5 / 255)) * (this2 & 255) | 0) * 255);
					}
				}
				if(col != 0) {
					let x = 100 + dx;
					let y = 100 + dy;
					let c = col;
					if((c >> 24 & 255) < 254 && this7.transparent) {
						let location = this7.useVirtualPos ? (y - this7.virtualY) * this7.width + x - this7.virtualX | 0 : y * this7.width + x | 0;
						let this1 = this7.image.get(location);
						let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
						let this3 = this2 >> 24 & 255;
						let this4 = this2 >> 16 & 255;
						let this5 = this2 >> 8 & 255;
						let this6 = this2 & 255;
						let this8 = col >> 24 & 255;
						let a2 = this8 == 0 ? 0. : this8 / 255;
						let this9 = col >> 16 & 255;
						let this10 = col >> 8 & 255;
						let this11 = col & 255;
						let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
						let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this11 == 0 ? 0. : this11 / 255) * a2) | 0);
						this7.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this7.image.set(this7.useVirtualPos ? (y - this7.virtualY) * this7.width + x - this7.virtualX | 0 : y * this7.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
			}
		}
		let a0 = 0;
		let b0 = 0;
		let c0 = 0;
		let d0 = 0;
		let e0 = 0;
		let f0 = 0;
		let g0 = 0;
		let h0 = 0;
		let i0 = 0;
		let r_ = 0.;
		let g_ = 0.;
		let b_ = 0.;
		let a_ = 0.;
		let width3 = pix0.width;
		let height3 = pix0.height;
		let imageType6 = null;
		let this8 = new pi_$xy_ImageStruct();
		imageType6 = pi_$xy_ImageStruct.defaultType;
		let imageType7 = imageType6;
		if(imageType7 == null) {
			imageType7 = 2;
		}
		let tmp3;
		switch(imageType7) {
		case 0:
			let b9 = new iterMagic_BytesImg();
			b9.width = width3;
			b9.height = height3;
			b9.length = width3 * height3 | 0;
			b9.data = new haxe_io_Bytes(new ArrayBuffer(b9.length * 4));
			let w3 = 0;
			let _g19 = 0;
			let _g20 = b9.height;
			while(_g19 < _g20) {
				++_g19;
				let _g = 0;
				let _g1 = b9.width;
				while(_g < _g1) {
					++_g;
					b9.data.b[w3++] = 0;
					b9.data.b[w3++] = 0;
					b9.data.b[w3++] = 0;
					b9.data.b[w3++] = 0;
				}
			}
			tmp3 = b9;
			break;
		case 1:
			let a3 = new iterMagic_ArrIntImg();
			a3.width = width3;
			a3.height = height3;
			a3.data = [];
			a3.length = width3 * height3 | 0;
			let len12 = a3.length;
			let _g21 = 0;
			while(_g21 < len12) a3.data[_g21++] = 0;
			tmp3 = a3;
			break;
		case 2:
			let b10 = new iterMagic_U32ArrImg();
			b10.width = width3;
			b10.height = height3;
			b10.length = width3 * height3 | 0;
			b10.data = new Uint32Array(b10.length);
			let len13 = b10.length;
			let _g22 = 0;
			while(_g22 < len13) b10.data[_g22++] = 0;
			tmp3 = b10;
			break;
		case 3:
			let v3 = new iterMagic_VecIntImg();
			v3.width = width3;
			v3.height = height3;
			v3.length = width3 * height3 | 0;
			let this9 = new Array(v3.length);
			v3.data = this9;
			let len14 = v3.length;
			let _g23 = 0;
			while(_g23 < len14) v3.data[_g23++] = 0;
			tmp3 = v3;
			break;
		case 4:
			let b11 = new iterMagic_StackIntImg();
			b11.width = width3;
			b11.height = height3;
			b11.length = width3 * height3 | 0;
			b11.data = new haxe_ds_GenericStack();
			let len15 = b11.length;
			let d3 = b11.data;
			if(d3.head == null) {
				let _g = 0;
				while(_g < len15) {
					++_g;
					d3.head = new haxe_ds_GenericCell(0,d3.head);
				}
			} else {
				let _g = 0;
				while(_g < len15) {
					let i = _g++;
					let l = b11.data.head;
					let prev = null;
					let _g1 = 0;
					while(_g1 < i) {
						++_g1;
						prev = l;
						l = l.next;
					}
					if(prev == null) {
						b11.data.head = new haxe_ds_GenericCell(0,l.next);
						l = null;
					} else {
						prev.next = new haxe_ds_GenericCell(0,l.next);
						l = null;
					}
				}
			}
			tmp3 = b11;
			break;
		}
		this8.image = tmp3;
		this8.width = width3;
		this8.height = height3;
		this8.imageType = imageType6;
		let out = this8;
		let width4 = pix0.width + 2;
		let height4 = pix0.height + 2;
		let imageType8 = null;
		let this10 = new pi_$xy_ImageStruct();
		imageType8 = pi_$xy_ImageStruct.defaultType;
		let imageType9 = imageType8;
		if(imageType9 == null) {
			imageType9 = 2;
		}
		let here;
		switch(imageType9) {
		case 0:
			let b12 = new iterMagic_BytesImg();
			b12.width = width4;
			b12.height = height4;
			b12.length = width4 * height4 | 0;
			b12.data = new haxe_io_Bytes(new ArrayBuffer(b12.length * 4));
			let w4 = 0;
			let _g24 = 0;
			let _g25 = b12.height;
			while(_g24 < _g25) {
				++_g24;
				let _g = 0;
				let _g1 = b12.width;
				while(_g < _g1) {
					++_g;
					b12.data.b[w4++] = 0;
					b12.data.b[w4++] = 0;
					b12.data.b[w4++] = 0;
					b12.data.b[w4++] = 0;
				}
			}
			here = b12;
			break;
		case 1:
			let a4 = new iterMagic_ArrIntImg();
			a4.width = width4;
			a4.height = height4;
			a4.data = [];
			a4.length = width4 * height4 | 0;
			let len16 = a4.length;
			let _g26 = 0;
			while(_g26 < len16) a4.data[_g26++] = 0;
			here = a4;
			break;
		case 2:
			let b13 = new iterMagic_U32ArrImg();
			b13.width = width4;
			b13.height = height4;
			b13.length = width4 * height4 | 0;
			b13.data = new Uint32Array(b13.length);
			let len17 = b13.length;
			let _g27 = 0;
			while(_g27 < len17) b13.data[_g27++] = 0;
			here = b13;
			break;
		case 3:
			let v4 = new iterMagic_VecIntImg();
			v4.width = width4;
			v4.height = height4;
			v4.length = width4 * height4 | 0;
			let this11 = new Array(v4.length);
			v4.data = this11;
			let len18 = v4.length;
			let _g28 = 0;
			while(_g28 < len18) v4.data[_g28++] = 0;
			here = v4;
			break;
		case 4:
			let b14 = new iterMagic_StackIntImg();
			b14.width = width4;
			b14.height = height4;
			b14.length = width4 * height4 | 0;
			b14.data = new haxe_ds_GenericStack();
			let len19 = b14.length;
			let d4 = b14.data;
			if(d4.head == null) {
				let _g = 0;
				while(_g < len19) {
					++_g;
					d4.head = new haxe_ds_GenericCell(0,d4.head);
				}
			} else {
				let _g = 0;
				while(_g < len19) {
					let i = _g++;
					let l = b14.data.head;
					let prev = null;
					let _g1 = 0;
					while(_g1 < i) {
						++_g1;
						prev = l;
						l = l.next;
					}
					if(prev == null) {
						b14.data.head = new haxe_ds_GenericCell(0,l.next);
						l = null;
					} else {
						prev.next = new haxe_ds_GenericCell(0,l.next);
						l = null;
					}
				}
			}
			here = b14;
			break;
		}
		this10.image = here;
		this10.width = width4;
		this10.height = height4;
		this10.imageType = imageType8;
		let img = this10;
		let _g29 = 0;
		let _g30 = pix0.height;
		while(_g29 < _g30) {
			let dy = _g29++;
			let _g = 0;
			let _g1 = pix0.width;
			while(_g < _g1) {
				let dx = _g++;
				let c = pix0.image.get(pix0.useVirtualPos ? (dy - pix0.virtualY) * pix0.width + dx - pix0.virtualX | 0 : dy * pix0.width + dx | 0);
				let col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				if(pix0.useMask && pix0.mask != null) {
					let this1 = pix0.mask;
					let c = this1.image.get(this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0);
					let maskPixel = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					let this2 = col;
					if(maskPixel == 0) {
						col = this2;
					} else {
						let this1 = maskPixel >> 24 & 255;
						let this3 = maskPixel >> 16 & 255;
						let this4 = maskPixel >> 8 & 255;
						let this5 = maskPixel & 255;
						col = Math.round(((1. - (this1 == 0 ? 0. : this1 / 255)) * (this2 >> 24 & 255) | 0) * 255) << 24 | Math.round(((1. - (this3 == 0 ? 0. : this3 / 255)) * (this2 >> 16 & 255) | 0) * 255) << 16 | Math.round(((1. - (this4 == 0 ? 0. : this4 / 255)) * (this2 >> 8 & 255) | 0) * 255) << 8 | Math.round(((1. - (this5 == 0 ? 0. : this5 / 255)) * (this2 & 255) | 0) * 255);
					}
				}
				if(col != 0) {
					let x = 1 + dx;
					let y = 1 + dy;
					let c = col;
					if((c >> 24 & 255) < 254 && img.transparent) {
						let location = img.useVirtualPos ? (y - img.virtualY) * img.width + x - img.virtualX | 0 : y * img.width + x | 0;
						let this1 = img.image.get(location);
						let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
						let this3 = this2 >> 24 & 255;
						let this4 = this2 >> 16 & 255;
						let this5 = this2 >> 8 & 255;
						let this6 = this2 & 255;
						let this7 = col >> 24 & 255;
						let a2 = this7 == 0 ? 0. : this7 / 255;
						let this8 = col >> 16 & 255;
						let this9 = col >> 8 & 255;
						let this10 = col & 255;
						let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
						let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
						img.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						img.image.set(img.useVirtualPos ? (y - img.virtualY) * img.width + x - img.virtualX | 0 : y * img.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
			}
		}
		let _g31 = 0;
		let _g32 = pix0.width;
		while(_g31 < _g32) {
			let x = _g31++;
			let _g = 0;
			while(_g < 1) {
				let y = _g++;
				let x1 = x + 1;
				let c = pix0.image.get(pix0.useVirtualPos ? (0 - pix0.virtualY) * pix0.width + x - pix0.virtualX | 0 : 0 * pix0.width + x | 0);
				let color = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				let c1 = color;
				if((c1 >> 24 & 255) < 254 && img.transparent) {
					let location = img.useVirtualPos ? (y - img.virtualY) * img.width + x1 - img.virtualX | 0 : y * img.width + x1 | 0;
					let this1 = img.image.get(location);
					let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
					let this3 = this2 >> 24 & 255;
					let this4 = this2 >> 16 & 255;
					let this5 = this2 >> 8 & 255;
					let this6 = this2 & 255;
					let this7 = color >> 24 & 255;
					let a2 = this7 == 0 ? 0. : this7 / 255;
					let this8 = color >> 16 & 255;
					let this9 = color >> 8 & 255;
					let this10 = color & 255;
					let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
					let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
					img.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					img.image.set(img.useVirtualPos ? (y - img.virtualY) * img.width + x1 - img.virtualX | 0 : y * img.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
				}
				let x2 = x + 1;
				let y1 = img.height - y - 1;
				let y2 = pix0.height - 1;
				let c2 = pix0.image.get(pix0.useVirtualPos ? (y2 - pix0.virtualY) * pix0.width + x - pix0.virtualX | 0 : y2 * pix0.width + x | 0);
				let color1 = pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
				let c3 = color1;
				if((c3 >> 24 & 255) < 254 && img.transparent) {
					let location = img.useVirtualPos ? (y1 - img.virtualY) * img.width + x2 - img.virtualX | 0 : y1 * img.width + x2 | 0;
					let this1 = img.image.get(location);
					let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
					let this3 = this2 >> 24 & 255;
					let this4 = this2 >> 16 & 255;
					let this5 = this2 >> 8 & 255;
					let this6 = this2 & 255;
					let this7 = color1 >> 24 & 255;
					let a2 = this7 == 0 ? 0. : this7 / 255;
					let this8 = color1 >> 16 & 255;
					let this9 = color1 >> 8 & 255;
					let this10 = color1 & 255;
					let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
					let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
					img.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					img.image.set(img.useVirtualPos ? (y1 - img.virtualY) * img.width + x2 - img.virtualX | 0 : y1 * img.width + x2 | 0,pi_$xy_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3);
				}
			}
		}
		let _g33 = 0;
		let _g34 = pix0.height;
		while(_g33 < _g34) {
			let y = _g33++;
			let _g = 0;
			while(_g < 1) {
				let x = _g++;
				let y1 = y + 1;
				let c = pix0.image.get(pix0.useVirtualPos ? (y - pix0.virtualY) * pix0.width - pix0.virtualX | 0 : y * pix0.width | 0);
				let color = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				let c1 = color;
				if((c1 >> 24 & 255) < 254 && img.transparent) {
					let location = img.useVirtualPos ? (y1 - img.virtualY) * img.width + x - img.virtualX | 0 : y1 * img.width + x | 0;
					let this1 = img.image.get(location);
					let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
					let this3 = this2 >> 24 & 255;
					let this4 = this2 >> 16 & 255;
					let this5 = this2 >> 8 & 255;
					let this6 = this2 & 255;
					let this7 = color >> 24 & 255;
					let a2 = this7 == 0 ? 0. : this7 / 255;
					let this8 = color >> 16 & 255;
					let this9 = color >> 8 & 255;
					let this10 = color & 255;
					let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
					let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
					img.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					img.image.set(img.useVirtualPos ? (y1 - img.virtualY) * img.width + x - img.virtualX | 0 : y1 * img.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
				}
				let x1 = img.width - x - 1;
				let y2 = y + 1;
				let x2 = pix0.width - 1;
				let c2 = pix0.image.get(pix0.useVirtualPos ? (0 - pix0.virtualY) * pix0.width + x2 - pix0.virtualX | 0 : 0 * pix0.width + x2 | 0);
				let color1 = pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
				let c3 = color1;
				if((c3 >> 24 & 255) < 254 && img.transparent) {
					let location = img.useVirtualPos ? (y2 - img.virtualY) * img.width + x1 - img.virtualX | 0 : y2 * img.width + x1 | 0;
					let this1 = img.image.get(location);
					let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
					let this3 = this2 >> 24 & 255;
					let this4 = this2 >> 16 & 255;
					let this5 = this2 >> 8 & 255;
					let this6 = this2 & 255;
					let this7 = color1 >> 24 & 255;
					let a2 = this7 == 0 ? 0. : this7 / 255;
					let this8 = color1 >> 16 & 255;
					let this9 = color1 >> 8 & 255;
					let this10 = color1 & 255;
					let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
					let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
					img.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					img.image.set(img.useVirtualPos ? (y2 - img.virtualY) * img.width + x1 - img.virtualX | 0 : y2 * img.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3);
				}
			}
		}
		let _g35 = 0;
		while(_g35 < 1) {
			let x = _g35++;
			let _g = 0;
			while(_g < 1) {
				let y = _g++;
				let c = pix0.image.get(pix0.useVirtualPos ? (0 - pix0.virtualY) * pix0.width - pix0.virtualX | 0 : 0 * pix0.width | 0);
				let color = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				let c1 = color;
				if((c1 >> 24 & 255) < 254 && img.transparent) {
					let location = img.useVirtualPos ? (y - img.virtualY) * img.width + x - img.virtualX | 0 : y * img.width + x | 0;
					let this1 = img.image.get(location);
					let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
					let this3 = this2 >> 24 & 255;
					let this4 = this2 >> 16 & 255;
					let this5 = this2 >> 8 & 255;
					let this6 = this2 & 255;
					let this7 = color >> 24 & 255;
					let a2 = this7 == 0 ? 0. : this7 / 255;
					let this8 = color >> 16 & 255;
					let this9 = color >> 8 & 255;
					let this10 = color & 255;
					let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
					let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
					img.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					img.image.set(img.useVirtualPos ? (y - img.virtualY) * img.width + x - img.virtualX | 0 : y * img.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
				}
				let x1 = x + 1 + pix0.width;
				let x2 = pix0.width - 1;
				let c2 = pix0.image.get(pix0.useVirtualPos ? (0 - pix0.virtualY) * pix0.width + x2 - pix0.virtualX | 0 : 0 * pix0.width + x2 | 0);
				let color1 = pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
				let c3 = color1;
				if((c3 >> 24 & 255) < 254 && img.transparent) {
					let location = img.useVirtualPos ? (y - img.virtualY) * img.width + x1 - img.virtualX | 0 : y * img.width + x1 | 0;
					let this1 = img.image.get(location);
					let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
					let this3 = this2 >> 24 & 255;
					let this4 = this2 >> 16 & 255;
					let this5 = this2 >> 8 & 255;
					let this6 = this2 & 255;
					let this7 = color1 >> 24 & 255;
					let a2 = this7 == 0 ? 0. : this7 / 255;
					let this8 = color1 >> 16 & 255;
					let this9 = color1 >> 8 & 255;
					let this10 = color1 & 255;
					let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
					let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
					img.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					img.image.set(img.useVirtualPos ? (y - img.virtualY) * img.width + x1 - img.virtualX | 0 : y * img.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3);
				}
				let x3 = x + 1 + pix0.width;
				let y1 = y + 1 + pix0.height;
				let x4 = pix0.width - 1;
				let y2 = pix0.height - 1;
				let c4 = pix0.image.get(pix0.useVirtualPos ? (y2 - pix0.virtualY) * pix0.width + x4 - pix0.virtualX | 0 : y2 * pix0.width + x4 | 0);
				let color2 = pi_$xy_Endian_isLittleEndian ? (c4 >> 24 & 255) << 24 | (c4 & 255) << 16 | (c4 >> 8 & 255) << 8 | c4 >> 16 & 255 : c4;
				let c5 = color2;
				if((c5 >> 24 & 255) < 254 && img.transparent) {
					let location = img.useVirtualPos ? (y1 - img.virtualY) * img.width + x3 - img.virtualX | 0 : y1 * img.width + x3 | 0;
					let this1 = img.image.get(location);
					let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
					let this3 = this2 >> 24 & 255;
					let this4 = this2 >> 16 & 255;
					let this5 = this2 >> 8 & 255;
					let this6 = this2 & 255;
					let this7 = color2 >> 24 & 255;
					let a2 = this7 == 0 ? 0. : this7 / 255;
					let this8 = color2 >> 16 & 255;
					let this9 = color2 >> 8 & 255;
					let this10 = color2 & 255;
					let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
					let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
					img.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					img.image.set(img.useVirtualPos ? (y1 - img.virtualY) * img.width + x3 - img.virtualX | 0 : y1 * img.width + x3 | 0,pi_$xy_Endian_isLittleEndian ? (c5 >> 24 & 255) << 24 | (c5 & 255) << 16 | (c5 >> 8 & 255) << 8 | c5 >> 16 & 255 : c5);
				}
				let y3 = y + 1 + pix0.width;
				let y4 = pix0.height - 1;
				let c6 = pix0.image.get(pix0.useVirtualPos ? (y4 - pix0.virtualY) * pix0.width - pix0.virtualX | 0 : y4 * pix0.width | 0);
				let color3 = pi_$xy_Endian_isLittleEndian ? (c6 >> 24 & 255) << 24 | (c6 & 255) << 16 | (c6 >> 8 & 255) << 8 | c6 >> 16 & 255 : c6;
				let c7 = color3;
				if((c7 >> 24 & 255) < 254 && img.transparent) {
					let location = img.useVirtualPos ? (y3 - img.virtualY) * img.width + x - img.virtualX | 0 : y3 * img.width + x | 0;
					let this1 = img.image.get(location);
					let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
					let this3 = this2 >> 24 & 255;
					let this4 = this2 >> 16 & 255;
					let this5 = this2 >> 8 & 255;
					let this6 = this2 & 255;
					let this7 = color3 >> 24 & 255;
					let a2 = this7 == 0 ? 0. : this7 / 255;
					let this8 = color3 >> 16 & 255;
					let this9 = color3 >> 8 & 255;
					let this10 = color3 & 255;
					let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
					let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
					img.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					img.image.set(img.useVirtualPos ? (y3 - img.virtualY) * img.width + x - img.virtualX | 0 : y3 * img.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c7 >> 24 & 255) << 24 | (c7 & 255) << 16 | (c7 >> 8 & 255) << 8 | c7 >> 16 & 255 : c7);
				}
			}
		}
		let _g36 = 1;
		let _g37 = pix0.height - 2;
		while(_g36 < _g37) {
			let y = _g36++;
			let _g = 1;
			let _g1 = pix0.width - 2;
			while(_g < _g1) {
				let x = _g++;
				if(x == 1) {
					let x1 = x - 1;
					let y1 = y - 1;
					let c = img.image.get(img.useVirtualPos ? (y1 - img.virtualY) * img.width + x1 - img.virtualX | 0 : y1 * img.width + x1 | 0);
					a0 = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					let y2 = y - 1;
					let c1 = img.image.get(img.useVirtualPos ? (y2 - img.virtualY) * img.width + x - img.virtualX | 0 : y2 * img.width + x | 0);
					b0 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
					let x2 = x + 1;
					let y3 = y - 1;
					let c2 = img.image.get(img.useVirtualPos ? (y3 - img.virtualY) * img.width + x2 - img.virtualX | 0 : y3 * img.width + x2 | 0);
					c0 = pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
					let x3 = x - 1;
					let c3 = img.image.get(img.useVirtualPos ? (y - img.virtualY) * img.width + x3 - img.virtualX | 0 : y * img.width + x3 | 0);
					d0 = pi_$xy_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3;
					let c4 = img.image.get(img.useVirtualPos ? (y - img.virtualY) * img.width + x - img.virtualX | 0 : y * img.width + x | 0);
					e0 = pi_$xy_Endian_isLittleEndian ? (c4 >> 24 & 255) << 24 | (c4 & 255) << 16 | (c4 >> 8 & 255) << 8 | c4 >> 16 & 255 : c4;
					let x4 = x + 1;
					let c5 = img.image.get(img.useVirtualPos ? (y - img.virtualY) * img.width + x4 - img.virtualX | 0 : y * img.width + x4 | 0);
					f0 = pi_$xy_Endian_isLittleEndian ? (c5 >> 24 & 255) << 24 | (c5 & 255) << 16 | (c5 >> 8 & 255) << 8 | c5 >> 16 & 255 : c5;
					let x5 = x - 1;
					let y4 = y + 1;
					let c6 = img.image.get(img.useVirtualPos ? (y4 - img.virtualY) * img.width + x5 - img.virtualX | 0 : y4 * img.width + x5 | 0);
					g0 = pi_$xy_Endian_isLittleEndian ? (c6 >> 24 & 255) << 24 | (c6 & 255) << 16 | (c6 >> 8 & 255) << 8 | c6 >> 16 & 255 : c6;
					let y5 = y + 1;
					let c7 = img.image.get(img.useVirtualPos ? (y5 - img.virtualY) * img.width + x - img.virtualX | 0 : y5 * img.width + x | 0);
					h0 = pi_$xy_Endian_isLittleEndian ? (c7 >> 24 & 255) << 24 | (c7 & 255) << 16 | (c7 >> 8 & 255) << 8 | c7 >> 16 & 255 : c7;
					let x6 = x + 1;
					let y6 = y + 1;
					let c8 = img.image.get(img.useVirtualPos ? (y6 - img.virtualY) * img.width + x6 - img.virtualX | 0 : y6 * img.width + x6 | 0);
					i0 = pi_$xy_Endian_isLittleEndian ? (c8 >> 24 & 255) << 24 | (c8 & 255) << 16 | (c8 >> 8 & 255) << 8 | c8 >> 16 & 255 : c8;
				} else {
					a0 = b0;
					b0 = c0;
					let x1 = x + 1;
					let y1 = y - 1;
					let c = img.image.get(img.useVirtualPos ? (y1 - img.virtualY) * img.width + x1 - img.virtualX | 0 : y1 * img.width + x1 | 0);
					c0 = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					d0 = e0;
					e0 = f0;
					let x2 = x + 1;
					let c1 = img.image.get(img.useVirtualPos ? (y - img.virtualY) * img.width + x2 - img.virtualX | 0 : y * img.width + x2 | 0);
					f0 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
					g0 = h0;
					h0 = i0;
					let x3 = x + 1;
					let y2 = y + 1;
					let c2 = img.image.get(img.useVirtualPos ? (y2 - img.virtualY) * img.width + x3 - img.virtualX | 0 : y2 * img.width + x3 | 0);
					i0 = pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
				}
				r_ = 0.;
				if(a0 != 0) {
					r_ = (a0 >> 16 & 255) / 255 * 0.111111111111111105;
				}
				if(b0 != 0) {
					r_ += (b0 >> 16 & 255) / 255 * 0.111111111111111105;
				}
				if(c0 != 0) {
					r_ += (c0 >> 16 & 255) / 255 * 0.111111111111111105;
				}
				if(d0 != 0) {
					r_ += (d0 >> 16 & 255) / 255 * 0.111111111111111105;
				}
				if(e0 != 0) {
					r_ += (e0 >> 16 & 255) / 255 * 0.111111111111111105;
				}
				if(f0 != 0) {
					r_ += (f0 >> 16 & 255) / 255 * 0.111111111111111105;
				}
				if(g0 != 0) {
					r_ += (g0 >> 16 & 255) / 255 * 0.111111111111111105;
				}
				if(h0 != 0) {
					r_ += (h0 >> 16 & 255) / 255 * 0.111111111111111105;
				}
				if(i0 != 0) {
					r_ += (i0 >> 16 & 255) / 255 * 0.111111111111111105;
				}
				g_ = 0.;
				if(a0 != 0) {
					g_ = (a0 >> 8 & 255) / 255 * 0.111111111111111105;
				}
				if(b0 != 0) {
					g_ += (b0 >> 8 & 255) / 255 * 0.111111111111111105;
				}
				if(c0 != 0) {
					g_ += (c0 >> 8 & 255) / 255 * 0.111111111111111105;
				}
				if(d0 != 0) {
					g_ += (d0 >> 8 & 255) / 255 * 0.111111111111111105;
				}
				if(e0 != 0) {
					g_ += (e0 >> 8 & 255) / 255 * 0.111111111111111105;
				}
				if(f0 != 0) {
					g_ += (f0 >> 8 & 255) / 255 * 0.111111111111111105;
				}
				if(g0 != 0) {
					g_ += (g0 >> 8 & 255) / 255 * 0.111111111111111105;
				}
				if(h0 != 0) {
					g_ += (h0 >> 8 & 255) / 255 * 0.111111111111111105;
				}
				if(i0 != 0) {
					g_ += (i0 >> 8 & 255) / 255 * 0.111111111111111105;
				}
				b_ = 0.;
				if(a0 != 0) {
					b_ = (a0 & 255) / 255 * 0.111111111111111105;
				}
				if(b0 != 0) {
					b_ += (b0 & 255) / 255 * 0.111111111111111105;
				}
				if(c0 != 0) {
					b_ += (c0 & 255) / 255 * 0.111111111111111105;
				}
				if(d0 != 0) {
					b_ += (d0 & 255) / 255 * 0.111111111111111105;
				}
				if(e0 != 0) {
					b_ += (e0 & 255) / 255 * 0.111111111111111105;
				}
				if(f0 != 0) {
					b_ += (f0 & 255) / 255 * 0.111111111111111105;
				}
				if(g0 != 0) {
					b_ += (g0 & 255) / 255 * 0.111111111111111105;
				}
				if(h0 != 0) {
					b_ += (h0 & 255) / 255 * 0.111111111111111105;
				}
				if(i0 != 0) {
					b_ += (i0 & 255) / 255 * 0.111111111111111105;
				}
				a_ = (e0 >> 24 & 255) / 255;
				let x1 = x - 1;
				let y1 = y - 1;
				let color = Math.round(a_ * 255) << 24 | Math.round(r_ * 255) << 16 | Math.round(g_ * 255) << 8 | Math.round(b_ * 255);
				let c = color;
				if((c >> 24 & 255) < 254 && out.transparent) {
					let location = out.useVirtualPos ? (y1 - out.virtualY) * out.width + x1 - out.virtualX | 0 : y1 * out.width + x1 | 0;
					let this1 = out.image.get(location);
					let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
					let this3 = this2 >> 24 & 255;
					let this4 = this2 >> 16 & 255;
					let this5 = this2 >> 8 & 255;
					let this6 = this2 & 255;
					let this7 = color >> 24 & 255;
					let a2 = this7 == 0 ? 0. : this7 / 255;
					let this8 = color >> 16 & 255;
					let this9 = color >> 8 & 255;
					let this10 = color & 255;
					let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
					let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
					out.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					out.image.set(out.useVirtualPos ? (y1 - out.virtualY) * out.width + x1 - out.virtualX | 0 : y1 * out.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
				}
			}
		}
		let blured = out;
		let a01 = 0;
		let b01 = 0;
		let c01 = 0;
		let d01 = 0;
		let e01 = 0;
		let f01 = 0;
		let h01 = 0;
		let i01 = 0;
		let r_1 = 0.;
		let g_1 = 0.;
		let b_1 = 0.;
		let a_1 = 0.;
		let width5 = pix0.width;
		let height5 = pix0.height;
		let imageType10 = null;
		let this12 = new pi_$xy_ImageStruct();
		imageType10 = pi_$xy_ImageStruct.defaultType;
		let imageType11 = imageType10;
		if(imageType11 == null) {
			imageType11 = 2;
		}
		let tmp4;
		switch(imageType11) {
		case 0:
			let b15 = new iterMagic_BytesImg();
			b15.width = width5;
			b15.height = height5;
			b15.length = width5 * height5 | 0;
			b15.data = new haxe_io_Bytes(new ArrayBuffer(b15.length * 4));
			let w5 = 0;
			let _g38 = 0;
			let _g39 = b15.height;
			while(_g38 < _g39) {
				++_g38;
				let _g = 0;
				let _g1 = b15.width;
				while(_g < _g1) {
					++_g;
					b15.data.b[w5++] = 0;
					b15.data.b[w5++] = 0;
					b15.data.b[w5++] = 0;
					b15.data.b[w5++] = 0;
				}
			}
			tmp4 = b15;
			break;
		case 1:
			let a5 = new iterMagic_ArrIntImg();
			a5.width = width5;
			a5.height = height5;
			a5.data = [];
			a5.length = width5 * height5 | 0;
			let len20 = a5.length;
			let _g40 = 0;
			while(_g40 < len20) a5.data[_g40++] = 0;
			tmp4 = a5;
			break;
		case 2:
			let b16 = new iterMagic_U32ArrImg();
			b16.width = width5;
			b16.height = height5;
			b16.length = width5 * height5 | 0;
			b16.data = new Uint32Array(b16.length);
			let len21 = b16.length;
			let _g41 = 0;
			while(_g41 < len21) b16.data[_g41++] = 0;
			tmp4 = b16;
			break;
		case 3:
			let v5 = new iterMagic_VecIntImg();
			v5.width = width5;
			v5.height = height5;
			v5.length = width5 * height5 | 0;
			let this13 = new Array(v5.length);
			v5.data = this13;
			let len22 = v5.length;
			let _g42 = 0;
			while(_g42 < len22) v5.data[_g42++] = 0;
			tmp4 = v5;
			break;
		case 4:
			let b17 = new iterMagic_StackIntImg();
			b17.width = width5;
			b17.height = height5;
			b17.length = width5 * height5 | 0;
			b17.data = new haxe_ds_GenericStack();
			let len23 = b17.length;
			let d5 = b17.data;
			if(d5.head == null) {
				let _g = 0;
				while(_g < len23) {
					++_g;
					d5.head = new haxe_ds_GenericCell(0,d5.head);
				}
			} else {
				let _g = 0;
				while(_g < len23) {
					let i = _g++;
					let l = b17.data.head;
					let prev = null;
					let _g1 = 0;
					while(_g1 < i) {
						++_g1;
						prev = l;
						l = l.next;
					}
					if(prev == null) {
						b17.data.head = new haxe_ds_GenericCell(0,l.next);
						l = null;
					} else {
						prev.next = new haxe_ds_GenericCell(0,l.next);
						l = null;
					}
				}
			}
			tmp4 = b17;
			break;
		}
		this12.image = tmp4;
		this12.width = width5;
		this12.height = height5;
		this12.imageType = imageType10;
		let out1 = this12;
		let width6 = pix0.width + 2;
		let height6 = pix0.height + 2;
		let imageType12 = null;
		let this14 = new pi_$xy_ImageStruct();
		imageType12 = pi_$xy_ImageStruct.defaultType;
		let imageType13 = imageType12;
		if(imageType13 == null) {
			imageType13 = 2;
		}
		let here1;
		switch(imageType13) {
		case 0:
			let b18 = new iterMagic_BytesImg();
			b18.width = width6;
			b18.height = height6;
			b18.length = width6 * height6 | 0;
			b18.data = new haxe_io_Bytes(new ArrayBuffer(b18.length * 4));
			let w6 = 0;
			let _g43 = 0;
			let _g44 = b18.height;
			while(_g43 < _g44) {
				++_g43;
				let _g = 0;
				let _g1 = b18.width;
				while(_g < _g1) {
					++_g;
					b18.data.b[w6++] = 0;
					b18.data.b[w6++] = 0;
					b18.data.b[w6++] = 0;
					b18.data.b[w6++] = 0;
				}
			}
			here1 = b18;
			break;
		case 1:
			let a6 = new iterMagic_ArrIntImg();
			a6.width = width6;
			a6.height = height6;
			a6.data = [];
			a6.length = width6 * height6 | 0;
			let len24 = a6.length;
			let _g45 = 0;
			while(_g45 < len24) a6.data[_g45++] = 0;
			here1 = a6;
			break;
		case 2:
			let b19 = new iterMagic_U32ArrImg();
			b19.width = width6;
			b19.height = height6;
			b19.length = width6 * height6 | 0;
			b19.data = new Uint32Array(b19.length);
			let len25 = b19.length;
			let _g46 = 0;
			while(_g46 < len25) b19.data[_g46++] = 0;
			here1 = b19;
			break;
		case 3:
			let v6 = new iterMagic_VecIntImg();
			v6.width = width6;
			v6.height = height6;
			v6.length = width6 * height6 | 0;
			let this15 = new Array(v6.length);
			v6.data = this15;
			let len26 = v6.length;
			let _g47 = 0;
			while(_g47 < len26) v6.data[_g47++] = 0;
			here1 = v6;
			break;
		case 4:
			let b20 = new iterMagic_StackIntImg();
			b20.width = width6;
			b20.height = height6;
			b20.length = width6 * height6 | 0;
			b20.data = new haxe_ds_GenericStack();
			let len27 = b20.length;
			let d6 = b20.data;
			if(d6.head == null) {
				let _g = 0;
				while(_g < len27) {
					++_g;
					d6.head = new haxe_ds_GenericCell(0,d6.head);
				}
			} else {
				let _g = 0;
				while(_g < len27) {
					let i = _g++;
					let l = b20.data.head;
					let prev = null;
					let _g1 = 0;
					while(_g1 < i) {
						++_g1;
						prev = l;
						l = l.next;
					}
					if(prev == null) {
						b20.data.head = new haxe_ds_GenericCell(0,l.next);
						l = null;
					} else {
						prev.next = new haxe_ds_GenericCell(0,l.next);
						l = null;
					}
				}
			}
			here1 = b20;
			break;
		}
		this14.image = here1;
		this14.width = width6;
		this14.height = height6;
		this14.imageType = imageType12;
		let img1 = this14;
		let _g48 = 0;
		let _g49 = pix0.height;
		while(_g48 < _g49) {
			let dy = _g48++;
			let _g = 0;
			let _g1 = pix0.width;
			while(_g < _g1) {
				let dx = _g++;
				let c = pix0.image.get(pix0.useVirtualPos ? (dy - pix0.virtualY) * pix0.width + dx - pix0.virtualX | 0 : dy * pix0.width + dx | 0);
				let col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				if(pix0.useMask && pix0.mask != null) {
					let this1 = pix0.mask;
					let c = this1.image.get(this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0);
					let maskPixel = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					let this2 = col;
					if(maskPixel == 0) {
						col = this2;
					} else {
						let this1 = maskPixel >> 24 & 255;
						let this3 = maskPixel >> 16 & 255;
						let this4 = maskPixel >> 8 & 255;
						let this5 = maskPixel & 255;
						col = Math.round(((1. - (this1 == 0 ? 0. : this1 / 255)) * (this2 >> 24 & 255) | 0) * 255) << 24 | Math.round(((1. - (this3 == 0 ? 0. : this3 / 255)) * (this2 >> 16 & 255) | 0) * 255) << 16 | Math.round(((1. - (this4 == 0 ? 0. : this4 / 255)) * (this2 >> 8 & 255) | 0) * 255) << 8 | Math.round(((1. - (this5 == 0 ? 0. : this5 / 255)) * (this2 & 255) | 0) * 255);
					}
				}
				if(col != 0) {
					let x = 1 + dx;
					let y = 1 + dy;
					let c = col;
					if((c >> 24 & 255) < 254 && img1.transparent) {
						let location = img1.useVirtualPos ? (y - img1.virtualY) * img1.width + x - img1.virtualX | 0 : y * img1.width + x | 0;
						let this1 = img1.image.get(location);
						let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
						let this3 = this2 >> 24 & 255;
						let this4 = this2 >> 16 & 255;
						let this5 = this2 >> 8 & 255;
						let this6 = this2 & 255;
						let this7 = col >> 24 & 255;
						let a2 = this7 == 0 ? 0. : this7 / 255;
						let this8 = col >> 16 & 255;
						let this9 = col >> 8 & 255;
						let this10 = col & 255;
						let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
						let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
						img1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						img1.image.set(img1.useVirtualPos ? (y - img1.virtualY) * img1.width + x - img1.virtualX | 0 : y * img1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
			}
		}
		let _g50 = 0;
		let _g51 = pix0.width;
		while(_g50 < _g51) {
			let x = _g50++;
			let _g = 0;
			while(_g < 1) {
				let y = _g++;
				let x1 = x + 1;
				let c = pix0.image.get(pix0.useVirtualPos ? (0 - pix0.virtualY) * pix0.width + x - pix0.virtualX | 0 : 0 * pix0.width + x | 0);
				let color = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				let c1 = color;
				if((c1 >> 24 & 255) < 254 && img1.transparent) {
					let location = img1.useVirtualPos ? (y - img1.virtualY) * img1.width + x1 - img1.virtualX | 0 : y * img1.width + x1 | 0;
					let this1 = img1.image.get(location);
					let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
					let this3 = this2 >> 24 & 255;
					let this4 = this2 >> 16 & 255;
					let this5 = this2 >> 8 & 255;
					let this6 = this2 & 255;
					let this7 = color >> 24 & 255;
					let a2 = this7 == 0 ? 0. : this7 / 255;
					let this8 = color >> 16 & 255;
					let this9 = color >> 8 & 255;
					let this10 = color & 255;
					let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
					let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
					img1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					img1.image.set(img1.useVirtualPos ? (y - img1.virtualY) * img1.width + x1 - img1.virtualX | 0 : y * img1.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
				}
				let x2 = x + 1;
				let y1 = img1.height - y - 1;
				let y2 = pix0.height - 1;
				let c2 = pix0.image.get(pix0.useVirtualPos ? (y2 - pix0.virtualY) * pix0.width + x - pix0.virtualX | 0 : y2 * pix0.width + x | 0);
				let color1 = pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
				let c3 = color1;
				if((c3 >> 24 & 255) < 254 && img1.transparent) {
					let location = img1.useVirtualPos ? (y1 - img1.virtualY) * img1.width + x2 - img1.virtualX | 0 : y1 * img1.width + x2 | 0;
					let this1 = img1.image.get(location);
					let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
					let this3 = this2 >> 24 & 255;
					let this4 = this2 >> 16 & 255;
					let this5 = this2 >> 8 & 255;
					let this6 = this2 & 255;
					let this7 = color1 >> 24 & 255;
					let a2 = this7 == 0 ? 0. : this7 / 255;
					let this8 = color1 >> 16 & 255;
					let this9 = color1 >> 8 & 255;
					let this10 = color1 & 255;
					let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
					let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
					img1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					img1.image.set(img1.useVirtualPos ? (y1 - img1.virtualY) * img1.width + x2 - img1.virtualX | 0 : y1 * img1.width + x2 | 0,pi_$xy_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3);
				}
			}
		}
		let _g52 = 0;
		let _g53 = pix0.height;
		while(_g52 < _g53) {
			let y = _g52++;
			let _g = 0;
			while(_g < 1) {
				let x = _g++;
				let y1 = y + 1;
				let c = pix0.image.get(pix0.useVirtualPos ? (y - pix0.virtualY) * pix0.width - pix0.virtualX | 0 : y * pix0.width | 0);
				let color = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				let c1 = color;
				if((c1 >> 24 & 255) < 254 && img1.transparent) {
					let location = img1.useVirtualPos ? (y1 - img1.virtualY) * img1.width + x - img1.virtualX | 0 : y1 * img1.width + x | 0;
					let this1 = img1.image.get(location);
					let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
					let this3 = this2 >> 24 & 255;
					let this4 = this2 >> 16 & 255;
					let this5 = this2 >> 8 & 255;
					let this6 = this2 & 255;
					let this7 = color >> 24 & 255;
					let a2 = this7 == 0 ? 0. : this7 / 255;
					let this8 = color >> 16 & 255;
					let this9 = color >> 8 & 255;
					let this10 = color & 255;
					let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
					let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
					img1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					img1.image.set(img1.useVirtualPos ? (y1 - img1.virtualY) * img1.width + x - img1.virtualX | 0 : y1 * img1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
				}
				let x1 = img1.width - x - 1;
				let y2 = y + 1;
				let x2 = pix0.width - 1;
				let c2 = pix0.image.get(pix0.useVirtualPos ? (0 - pix0.virtualY) * pix0.width + x2 - pix0.virtualX | 0 : 0 * pix0.width + x2 | 0);
				let color1 = pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
				let c3 = color1;
				if((c3 >> 24 & 255) < 254 && img1.transparent) {
					let location = img1.useVirtualPos ? (y2 - img1.virtualY) * img1.width + x1 - img1.virtualX | 0 : y2 * img1.width + x1 | 0;
					let this1 = img1.image.get(location);
					let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
					let this3 = this2 >> 24 & 255;
					let this4 = this2 >> 16 & 255;
					let this5 = this2 >> 8 & 255;
					let this6 = this2 & 255;
					let this7 = color1 >> 24 & 255;
					let a2 = this7 == 0 ? 0. : this7 / 255;
					let this8 = color1 >> 16 & 255;
					let this9 = color1 >> 8 & 255;
					let this10 = color1 & 255;
					let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
					let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
					img1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					img1.image.set(img1.useVirtualPos ? (y2 - img1.virtualY) * img1.width + x1 - img1.virtualX | 0 : y2 * img1.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3);
				}
			}
		}
		let _g54 = 0;
		while(_g54 < 1) {
			let x = _g54++;
			let _g = 0;
			while(_g < 1) {
				let y = _g++;
				let c = pix0.image.get(pix0.useVirtualPos ? (0 - pix0.virtualY) * pix0.width - pix0.virtualX | 0 : 0 * pix0.width | 0);
				let color = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				let c1 = color;
				if((c1 >> 24 & 255) < 254 && img1.transparent) {
					let location = img1.useVirtualPos ? (y - img1.virtualY) * img1.width + x - img1.virtualX | 0 : y * img1.width + x | 0;
					let this1 = img1.image.get(location);
					let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
					let this3 = this2 >> 24 & 255;
					let this4 = this2 >> 16 & 255;
					let this5 = this2 >> 8 & 255;
					let this6 = this2 & 255;
					let this7 = color >> 24 & 255;
					let a2 = this7 == 0 ? 0. : this7 / 255;
					let this8 = color >> 16 & 255;
					let this9 = color >> 8 & 255;
					let this10 = color & 255;
					let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
					let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
					img1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					img1.image.set(img1.useVirtualPos ? (y - img1.virtualY) * img1.width + x - img1.virtualX | 0 : y * img1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
				}
				let x1 = x + 1 + pix0.width;
				let x2 = pix0.width - 1;
				let c2 = pix0.image.get(pix0.useVirtualPos ? (0 - pix0.virtualY) * pix0.width + x2 - pix0.virtualX | 0 : 0 * pix0.width + x2 | 0);
				let color1 = pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
				let c3 = color1;
				if((c3 >> 24 & 255) < 254 && img1.transparent) {
					let location = img1.useVirtualPos ? (y - img1.virtualY) * img1.width + x1 - img1.virtualX | 0 : y * img1.width + x1 | 0;
					let this1 = img1.image.get(location);
					let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
					let this3 = this2 >> 24 & 255;
					let this4 = this2 >> 16 & 255;
					let this5 = this2 >> 8 & 255;
					let this6 = this2 & 255;
					let this7 = color1 >> 24 & 255;
					let a2 = this7 == 0 ? 0. : this7 / 255;
					let this8 = color1 >> 16 & 255;
					let this9 = color1 >> 8 & 255;
					let this10 = color1 & 255;
					let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
					let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
					img1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					img1.image.set(img1.useVirtualPos ? (y - img1.virtualY) * img1.width + x1 - img1.virtualX | 0 : y * img1.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3);
				}
				let x3 = x + 1 + pix0.width;
				let y1 = y + 1 + pix0.height;
				let x4 = pix0.width - 1;
				let y2 = pix0.height - 1;
				let c4 = pix0.image.get(pix0.useVirtualPos ? (y2 - pix0.virtualY) * pix0.width + x4 - pix0.virtualX | 0 : y2 * pix0.width + x4 | 0);
				let color2 = pi_$xy_Endian_isLittleEndian ? (c4 >> 24 & 255) << 24 | (c4 & 255) << 16 | (c4 >> 8 & 255) << 8 | c4 >> 16 & 255 : c4;
				let c5 = color2;
				if((c5 >> 24 & 255) < 254 && img1.transparent) {
					let location = img1.useVirtualPos ? (y1 - img1.virtualY) * img1.width + x3 - img1.virtualX | 0 : y1 * img1.width + x3 | 0;
					let this1 = img1.image.get(location);
					let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
					let this3 = this2 >> 24 & 255;
					let this4 = this2 >> 16 & 255;
					let this5 = this2 >> 8 & 255;
					let this6 = this2 & 255;
					let this7 = color2 >> 24 & 255;
					let a2 = this7 == 0 ? 0. : this7 / 255;
					let this8 = color2 >> 16 & 255;
					let this9 = color2 >> 8 & 255;
					let this10 = color2 & 255;
					let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
					let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
					img1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					img1.image.set(img1.useVirtualPos ? (y1 - img1.virtualY) * img1.width + x3 - img1.virtualX | 0 : y1 * img1.width + x3 | 0,pi_$xy_Endian_isLittleEndian ? (c5 >> 24 & 255) << 24 | (c5 & 255) << 16 | (c5 >> 8 & 255) << 8 | c5 >> 16 & 255 : c5);
				}
				let y3 = y + 1 + pix0.width;
				let y4 = pix0.height - 1;
				let c6 = pix0.image.get(pix0.useVirtualPos ? (y4 - pix0.virtualY) * pix0.width - pix0.virtualX | 0 : y4 * pix0.width | 0);
				let color3 = pi_$xy_Endian_isLittleEndian ? (c6 >> 24 & 255) << 24 | (c6 & 255) << 16 | (c6 >> 8 & 255) << 8 | c6 >> 16 & 255 : c6;
				let c7 = color3;
				if((c7 >> 24 & 255) < 254 && img1.transparent) {
					let location = img1.useVirtualPos ? (y3 - img1.virtualY) * img1.width + x - img1.virtualX | 0 : y3 * img1.width + x | 0;
					let this1 = img1.image.get(location);
					let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
					let this3 = this2 >> 24 & 255;
					let this4 = this2 >> 16 & 255;
					let this5 = this2 >> 8 & 255;
					let this6 = this2 & 255;
					let this7 = color3 >> 24 & 255;
					let a2 = this7 == 0 ? 0. : this7 / 255;
					let this8 = color3 >> 16 & 255;
					let this9 = color3 >> 8 & 255;
					let this10 = color3 & 255;
					let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
					let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
					img1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					img1.image.set(img1.useVirtualPos ? (y3 - img1.virtualY) * img1.width + x - img1.virtualX | 0 : y3 * img1.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c7 >> 24 & 255) << 24 | (c7 & 255) << 16 | (c7 >> 8 & 255) << 8 | c7 >> 16 & 255 : c7);
				}
			}
		}
		let _g55 = 1;
		let _g56 = pix0.height - 2;
		while(_g55 < _g56) {
			let y = _g55++;
			let _g = 1;
			let _g1 = pix0.width - 2;
			while(_g < _g1) {
				let x = _g++;
				if(x == 1) {
					let x1 = x - 1;
					let y1 = y - 1;
					let c = img1.image.get(img1.useVirtualPos ? (y1 - img1.virtualY) * img1.width + x1 - img1.virtualX | 0 : y1 * img1.width + x1 | 0);
					a01 = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					let y2 = y - 1;
					let c1 = img1.image.get(img1.useVirtualPos ? (y2 - img1.virtualY) * img1.width + x - img1.virtualX | 0 : y2 * img1.width + x | 0);
					b01 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
					let x2 = x + 1;
					let y3 = y - 1;
					let c2 = img1.image.get(img1.useVirtualPos ? (y3 - img1.virtualY) * img1.width + x2 - img1.virtualX | 0 : y3 * img1.width + x2 | 0);
					c01 = pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
					let x3 = x - 1;
					let c3 = img1.image.get(img1.useVirtualPos ? (y - img1.virtualY) * img1.width + x3 - img1.virtualX | 0 : y * img1.width + x3 | 0);
					d01 = pi_$xy_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3;
					let c4 = img1.image.get(img1.useVirtualPos ? (y - img1.virtualY) * img1.width + x - img1.virtualX | 0 : y * img1.width + x | 0);
					e01 = pi_$xy_Endian_isLittleEndian ? (c4 >> 24 & 255) << 24 | (c4 & 255) << 16 | (c4 >> 8 & 255) << 8 | c4 >> 16 & 255 : c4;
					let x4 = x + 1;
					let c5 = img1.image.get(img1.useVirtualPos ? (y - img1.virtualY) * img1.width + x4 - img1.virtualX | 0 : y * img1.width + x4 | 0);
					f01 = pi_$xy_Endian_isLittleEndian ? (c5 >> 24 & 255) << 24 | (c5 & 255) << 16 | (c5 >> 8 & 255) << 8 | c5 >> 16 & 255 : c5;
					let x5 = x - 1;
					let y4 = y + 1;
					img1.image.get(img1.useVirtualPos ? (y4 - img1.virtualY) * img1.width + x5 - img1.virtualX | 0 : y4 * img1.width + x5 | 0);
					let y5 = y + 1;
					let c6 = img1.image.get(img1.useVirtualPos ? (y5 - img1.virtualY) * img1.width + x - img1.virtualX | 0 : y5 * img1.width + x | 0);
					h01 = pi_$xy_Endian_isLittleEndian ? (c6 >> 24 & 255) << 24 | (c6 & 255) << 16 | (c6 >> 8 & 255) << 8 | c6 >> 16 & 255 : c6;
					let x6 = x + 1;
					let y6 = y + 1;
					let c7 = img1.image.get(img1.useVirtualPos ? (y6 - img1.virtualY) * img1.width + x6 - img1.virtualX | 0 : y6 * img1.width + x6 | 0);
					i01 = pi_$xy_Endian_isLittleEndian ? (c7 >> 24 & 255) << 24 | (c7 & 255) << 16 | (c7 >> 8 & 255) << 8 | c7 >> 16 & 255 : c7;
				} else {
					a01 = b01;
					b01 = c01;
					let x1 = x + 1;
					let y1 = y - 1;
					let c = img1.image.get(img1.useVirtualPos ? (y1 - img1.virtualY) * img1.width + x1 - img1.virtualX | 0 : y1 * img1.width + x1 | 0);
					c01 = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					d01 = e01;
					e01 = f01;
					let x2 = x + 1;
					let c1 = img1.image.get(img1.useVirtualPos ? (y - img1.virtualY) * img1.width + x2 - img1.virtualX | 0 : y * img1.width + x2 | 0);
					f01 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
					h01 = i01;
					let x3 = x + 1;
					let y2 = y + 1;
					let c2 = img1.image.get(img1.useVirtualPos ? (y2 - img1.virtualY) * img1.width + x3 - img1.virtualX | 0 : y2 * img1.width + x3 | 0);
					i01 = pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
				}
				r_1 = 0.;
				if(a01 != 0) {
					r_1 = (a01 >> 16 & 255) / 255 * -0.66666666666666663;
				}
				if(b01 != 0) {
					r_1 += (b01 >> 16 & 255) / 255 * 0.333333333333333315;
				}
				if(d01 != 0) {
					r_1 += (d01 >> 16 & 255) / 255 * -0.333333333333333315;
				}
				if(e01 != 0) {
					r_1 += (e01 >> 16 & 255) / 255 * 0.333333333333333315;
				}
				if(f01 != 0) {
					r_1 += (f01 >> 16 & 255) / 255 * 0.333333333333333315;
				}
				if(h01 != 0) {
					r_1 += (h01 >> 16 & 255) / 255 * 0.333333333333333315;
				}
				if(i01 != 0) {
					r_1 += (i01 >> 16 & 255) / 255 * 0.66666666666666663;
				}
				g_1 = 0.;
				if(a01 != 0) {
					g_1 = (a01 >> 8 & 255) / 255 * -0.66666666666666663;
				}
				if(b01 != 0) {
					g_1 += (b01 >> 8 & 255) / 255 * 0.333333333333333315;
				}
				if(d01 != 0) {
					g_1 += (d01 >> 8 & 255) / 255 * -0.333333333333333315;
				}
				if(e01 != 0) {
					g_1 += (e01 >> 8 & 255) / 255 * 0.333333333333333315;
				}
				if(f01 != 0) {
					g_1 += (f01 >> 8 & 255) / 255 * 0.333333333333333315;
				}
				if(h01 != 0) {
					g_1 += (h01 >> 8 & 255) / 255 * 0.333333333333333315;
				}
				if(i01 != 0) {
					g_1 += (i01 >> 8 & 255) / 255 * 0.66666666666666663;
				}
				b_1 = 0.;
				if(a01 != 0) {
					b_1 = (a01 & 255) / 255 * -0.66666666666666663;
				}
				if(b01 != 0) {
					b_1 += (b01 & 255) / 255 * 0.333333333333333315;
				}
				if(d01 != 0) {
					b_1 += (d01 & 255) / 255 * -0.333333333333333315;
				}
				if(e01 != 0) {
					b_1 += (e01 & 255) / 255 * 0.333333333333333315;
				}
				if(f01 != 0) {
					b_1 += (f01 & 255) / 255 * 0.333333333333333315;
				}
				if(h01 != 0) {
					b_1 += (h01 & 255) / 255 * 0.333333333333333315;
				}
				if(i01 != 0) {
					b_1 += (i01 & 255) / 255 * 0.66666666666666663;
				}
				a_1 = (e01 >> 24 & 255) / 255;
				let x1 = x - 1;
				let y1 = y - 1;
				let color = Math.round(a_1 * 255) << 24 | Math.round(r_1 * 255) << 16 | Math.round(g_1 * 255) << 8 | Math.round(b_1 * 255);
				let c = color;
				if((c >> 24 & 255) < 254 && out1.transparent) {
					let location = out1.useVirtualPos ? (y1 - out1.virtualY) * out1.width + x1 - out1.virtualX | 0 : y1 * out1.width + x1 | 0;
					let this1 = out1.image.get(location);
					let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
					let this3 = this2 >> 24 & 255;
					let this4 = this2 >> 16 & 255;
					let this5 = this2 >> 8 & 255;
					let this6 = this2 & 255;
					let this7 = color >> 24 & 255;
					let a2 = this7 == 0 ? 0. : this7 / 255;
					let this8 = color >> 16 & 255;
					let this9 = color >> 8 & 255;
					let this10 = color & 255;
					let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
					let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
					out1.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
				} else {
					out1.image.set(out1.useVirtualPos ? (y1 - out1.virtualY) * out1.width + x1 - out1.virtualX | 0 : y1 * out1.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
				}
			}
		}
		let imageType14 = null;
		let this16 = new pi_$xy_ImageStruct();
		imageType14 = pi_$xy_ImageStruct.defaultType;
		let imageType15 = imageType14;
		if(imageType15 == null) {
			imageType15 = 2;
		}
		let tmp5;
		switch(imageType15) {
		case 0:
			let b21 = new iterMagic_BytesImg();
			b21.width = 1;
			b21.height = 1;
			b21.length = 1;
			b21.data = new haxe_io_Bytes(new ArrayBuffer(b21.length * 4));
			let w7 = 0;
			let _g57 = 0;
			let _g58 = b21.height;
			while(_g57 < _g58) {
				++_g57;
				let _g = 0;
				let _g1 = b21.width;
				while(_g < _g1) {
					++_g;
					b21.data.b[w7++] = 0;
					b21.data.b[w7++] = 0;
					b21.data.b[w7++] = 0;
					b21.data.b[w7++] = 0;
				}
			}
			tmp5 = b21;
			break;
		case 1:
			let a7 = new iterMagic_ArrIntImg();
			a7.width = 1;
			a7.height = 1;
			a7.data = [];
			a7.length = 1;
			let len28 = a7.length;
			let _g59 = 0;
			while(_g59 < len28) a7.data[_g59++] = 0;
			tmp5 = a7;
			break;
		case 2:
			let b22 = new iterMagic_U32ArrImg();
			b22.width = 1;
			b22.height = 1;
			b22.length = 1;
			b22.data = new Uint32Array(b22.length);
			let len29 = b22.length;
			let _g60 = 0;
			while(_g60 < len29) b22.data[_g60++] = 0;
			tmp5 = b22;
			break;
		case 3:
			let v7 = new iterMagic_VecIntImg();
			v7.width = 1;
			v7.height = 1;
			v7.length = 1;
			let this17 = new Array(v7.length);
			v7.data = this17;
			let len30 = v7.length;
			let _g61 = 0;
			while(_g61 < len30) v7.data[_g61++] = 0;
			tmp5 = v7;
			break;
		case 4:
			let b23 = new iterMagic_StackIntImg();
			b23.width = 1;
			b23.height = 1;
			b23.length = 1;
			b23.data = new haxe_ds_GenericStack();
			let len31 = b23.length;
			let d7 = b23.data;
			if(d7.head == null) {
				let _g = 0;
				while(_g < len31) {
					++_g;
					d7.head = new haxe_ds_GenericCell(0,d7.head);
				}
			} else {
				let _g = 0;
				while(_g < len31) {
					let i = _g++;
					let l = b23.data.head;
					let prev = null;
					let _g1 = 0;
					while(_g1 < i) {
						++_g1;
						prev = l;
						l = l.next;
					}
					if(prev == null) {
						b23.data.head = new haxe_ds_GenericCell(0,l.next);
						l = null;
					} else {
						prev.next = new haxe_ds_GenericCell(0,l.next);
						l = null;
					}
				}
			}
			tmp5 = b23;
			break;
		}
		this16.image = tmp5;
		this16.width = 1;
		this16.height = 1;
		this16.imageType = imageType14;
		let _g62 = 0;
		while(_g62 < 10) {
			++_g62;
			let this1 = blured;
			let a0 = 0;
			let b0 = 0;
			let c0 = 0;
			let d0 = 0;
			let e0 = 0;
			let f0 = 0;
			let g0 = 0;
			let h0 = 0;
			let i0 = 0;
			let r_ = 0.;
			let g_ = 0.;
			let b_ = 0.;
			let a_ = 0.;
			let width = this1.width;
			let height = this1.height;
			let imageType = null;
			let this2 = new pi_$xy_ImageStruct();
			imageType = pi_$xy_ImageStruct.defaultType;
			let imageType1 = imageType;
			if(imageType1 == null) {
				imageType1 = 2;
			}
			let bluredN;
			switch(imageType1) {
			case 0:
				let b = new iterMagic_BytesImg();
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
				let w = 0;
				let _g = 0;
				let _g1 = b.height;
				while(_g < _g1) {
					++_g;
					let _g1 = 0;
					let _g2 = b.width;
					while(_g1 < _g2) {
						++_g1;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
					}
				}
				bluredN = b;
				break;
			case 1:
				let a = new iterMagic_ArrIntImg();
				a.width = width;
				a.height = height;
				a.data = [];
				a.length = width * height | 0;
				let len = a.length;
				let _g2 = 0;
				while(_g2 < len) a.data[_g2++] = 0;
				bluredN = a;
				break;
			case 2:
				let b1 = new iterMagic_U32ArrImg();
				b1.width = width;
				b1.height = height;
				b1.length = width * height | 0;
				b1.data = new Uint32Array(b1.length);
				let len1 = b1.length;
				let _g3 = 0;
				while(_g3 < len1) b1.data[_g3++] = 0;
				bluredN = b1;
				break;
			case 3:
				let v = new iterMagic_VecIntImg();
				v.width = width;
				v.height = height;
				v.length = width * height | 0;
				let this3 = new Array(v.length);
				v.data = this3;
				let len2 = v.length;
				let _g4 = 0;
				while(_g4 < len2) v.data[_g4++] = 0;
				bluredN = v;
				break;
			case 4:
				let b2 = new iterMagic_StackIntImg();
				b2.width = width;
				b2.height = height;
				b2.length = width * height | 0;
				b2.data = new haxe_ds_GenericStack();
				let len3 = b2.length;
				let d = b2.data;
				if(d.head == null) {
					let _g = 0;
					while(_g < len3) {
						++_g;
						d.head = new haxe_ds_GenericCell(0,d.head);
					}
				} else {
					let _g = 0;
					while(_g < len3) {
						let i = _g++;
						let l = b2.data.head;
						let prev = null;
						let _g1 = 0;
						while(_g1 < i) {
							++_g1;
							prev = l;
							l = l.next;
						}
						if(prev == null) {
							b2.data.head = new haxe_ds_GenericCell(0,l.next);
							l = null;
						} else {
							prev.next = new haxe_ds_GenericCell(0,l.next);
							l = null;
						}
					}
				}
				bluredN = b2;
				break;
			}
			this2.image = bluredN;
			this2.width = width;
			this2.height = height;
			this2.imageType = imageType;
			let out = this2;
			let width1 = this1.width + 2;
			let height1 = this1.height + 2;
			let imageType2 = null;
			let this4 = new pi_$xy_ImageStruct();
			imageType2 = pi_$xy_ImageStruct.defaultType;
			let imageType3 = imageType2;
			if(imageType3 == null) {
				imageType3 = 2;
			}
			let here;
			switch(imageType3) {
			case 0:
				let b3 = new iterMagic_BytesImg();
				b3.width = width1;
				b3.height = height1;
				b3.length = width1 * height1 | 0;
				b3.data = new haxe_io_Bytes(new ArrayBuffer(b3.length * 4));
				let w1 = 0;
				let _g5 = 0;
				let _g6 = b3.height;
				while(_g5 < _g6) {
					++_g5;
					let _g = 0;
					let _g1 = b3.width;
					while(_g < _g1) {
						++_g;
						b3.data.b[w1++] = 0;
						b3.data.b[w1++] = 0;
						b3.data.b[w1++] = 0;
						b3.data.b[w1++] = 0;
					}
				}
				here = b3;
				break;
			case 1:
				let a1 = new iterMagic_ArrIntImg();
				a1.width = width1;
				a1.height = height1;
				a1.data = [];
				a1.length = width1 * height1 | 0;
				let len4 = a1.length;
				let _g7 = 0;
				while(_g7 < len4) a1.data[_g7++] = 0;
				here = a1;
				break;
			case 2:
				let b4 = new iterMagic_U32ArrImg();
				b4.width = width1;
				b4.height = height1;
				b4.length = width1 * height1 | 0;
				b4.data = new Uint32Array(b4.length);
				let len5 = b4.length;
				let _g8 = 0;
				while(_g8 < len5) b4.data[_g8++] = 0;
				here = b4;
				break;
			case 3:
				let v1 = new iterMagic_VecIntImg();
				v1.width = width1;
				v1.height = height1;
				v1.length = width1 * height1 | 0;
				let this5 = new Array(v1.length);
				v1.data = this5;
				let len6 = v1.length;
				let _g9 = 0;
				while(_g9 < len6) v1.data[_g9++] = 0;
				here = v1;
				break;
			case 4:
				let b5 = new iterMagic_StackIntImg();
				b5.width = width1;
				b5.height = height1;
				b5.length = width1 * height1 | 0;
				b5.data = new haxe_ds_GenericStack();
				let len7 = b5.length;
				let d1 = b5.data;
				if(d1.head == null) {
					let _g = 0;
					while(_g < len7) {
						++_g;
						d1.head = new haxe_ds_GenericCell(0,d1.head);
					}
				} else {
					let _g = 0;
					while(_g < len7) {
						let i = _g++;
						let l = b5.data.head;
						let prev = null;
						let _g1 = 0;
						while(_g1 < i) {
							++_g1;
							prev = l;
							l = l.next;
						}
						if(prev == null) {
							b5.data.head = new haxe_ds_GenericCell(0,l.next);
							l = null;
						} else {
							prev.next = new haxe_ds_GenericCell(0,l.next);
							l = null;
						}
					}
				}
				here = b5;
				break;
			}
			this4.image = here;
			this4.width = width1;
			this4.height = height1;
			this4.imageType = imageType2;
			let img = this4;
			let _g10 = 0;
			let _g11 = this1.height;
			while(_g10 < _g11) {
				let dy = _g10++;
				let _g = 0;
				let _g1 = this1.width;
				while(_g < _g1) {
					let dx = _g++;
					let c = this1.image.get(this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0);
					let col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					if(this1.useMask && this1.mask != null) {
						let this2 = this1.mask;
						let c = this2.image.get(this2.useVirtualPos ? (dy - this2.virtualY) * this2.width + dx - this2.virtualX | 0 : dy * this2.width + dx | 0);
						let maskPixel = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						let this3 = col;
						if(maskPixel == 0) {
							col = this3;
						} else {
							let this1 = maskPixel >> 24 & 255;
							let this2 = maskPixel >> 16 & 255;
							let this4 = maskPixel >> 8 & 255;
							let this5 = maskPixel & 255;
							col = Math.round(((1. - (this1 == 0 ? 0. : this1 / 255)) * (this3 >> 24 & 255) | 0) * 255) << 24 | Math.round(((1. - (this2 == 0 ? 0. : this2 / 255)) * (this3 >> 16 & 255) | 0) * 255) << 16 | Math.round(((1. - (this4 == 0 ? 0. : this4 / 255)) * (this3 >> 8 & 255) | 0) * 255) << 8 | Math.round(((1. - (this5 == 0 ? 0. : this5 / 255)) * (this3 & 255) | 0) * 255);
						}
					}
					if(col != 0) {
						let x = 1 + dx;
						let y = 1 + dy;
						let c = col;
						if((c >> 24 & 255) < 254 && img.transparent) {
							let location = img.useVirtualPos ? (y - img.virtualY) * img.width + x - img.virtualX | 0 : y * img.width + x | 0;
							let this1 = img.image.get(location);
							let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
							let this3 = this2 >> 24 & 255;
							let this4 = this2 >> 16 & 255;
							let this5 = this2 >> 8 & 255;
							let this6 = this2 & 255;
							let this7 = col >> 24 & 255;
							let a2 = this7 == 0 ? 0. : this7 / 255;
							let this8 = col >> 16 & 255;
							let this9 = col >> 8 & 255;
							let this10 = col & 255;
							let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
							let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
							img.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
						} else {
							img.image.set(img.useVirtualPos ? (y - img.virtualY) * img.width + x - img.virtualX | 0 : y * img.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
						}
					}
				}
			}
			let _g12 = 0;
			let _g13 = this1.width;
			while(_g12 < _g13) {
				let x = _g12++;
				let _g = 0;
				while(_g < 1) {
					let y = _g++;
					let x1 = x + 1;
					let c = this1.image.get(this1.useVirtualPos ? (0 - this1.virtualY) * this1.width + x - this1.virtualX | 0 : 0 * this1.width + x | 0);
					let color = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					let c1 = color;
					if((c1 >> 24 & 255) < 254 && img.transparent) {
						let location = img.useVirtualPos ? (y - img.virtualY) * img.width + x1 - img.virtualX | 0 : y * img.width + x1 | 0;
						let this1 = img.image.get(location);
						let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
						let this3 = this2 >> 24 & 255;
						let this4 = this2 >> 16 & 255;
						let this5 = this2 >> 8 & 255;
						let this6 = this2 & 255;
						let this7 = color >> 24 & 255;
						let a2 = this7 == 0 ? 0. : this7 / 255;
						let this8 = color >> 16 & 255;
						let this9 = color >> 8 & 255;
						let this10 = color & 255;
						let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
						let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
						img.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						img.image.set(img.useVirtualPos ? (y - img.virtualY) * img.width + x1 - img.virtualX | 0 : y * img.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
					}
					let x2 = x + 1;
					let y1 = img.height - y - 1;
					let y2 = this1.height - 1;
					let c2 = this1.image.get(this1.useVirtualPos ? (y2 - this1.virtualY) * this1.width + x - this1.virtualX | 0 : y2 * this1.width + x | 0);
					let color1 = pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
					let c3 = color1;
					if((c3 >> 24 & 255) < 254 && img.transparent) {
						let location = img.useVirtualPos ? (y1 - img.virtualY) * img.width + x2 - img.virtualX | 0 : y1 * img.width + x2 | 0;
						let this1 = img.image.get(location);
						let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
						let this3 = this2 >> 24 & 255;
						let this4 = this2 >> 16 & 255;
						let this5 = this2 >> 8 & 255;
						let this6 = this2 & 255;
						let this7 = color1 >> 24 & 255;
						let a2 = this7 == 0 ? 0. : this7 / 255;
						let this8 = color1 >> 16 & 255;
						let this9 = color1 >> 8 & 255;
						let this10 = color1 & 255;
						let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
						let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
						img.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						img.image.set(img.useVirtualPos ? (y1 - img.virtualY) * img.width + x2 - img.virtualX | 0 : y1 * img.width + x2 | 0,pi_$xy_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3);
					}
				}
			}
			let _g14 = 0;
			let _g15 = this1.height;
			while(_g14 < _g15) {
				let y = _g14++;
				let _g = 0;
				while(_g < 1) {
					let x = _g++;
					let y1 = y + 1;
					let c = this1.image.get(this1.useVirtualPos ? (y - this1.virtualY) * this1.width - this1.virtualX | 0 : y * this1.width | 0);
					let color = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					let c1 = color;
					if((c1 >> 24 & 255) < 254 && img.transparent) {
						let location = img.useVirtualPos ? (y1 - img.virtualY) * img.width + x - img.virtualX | 0 : y1 * img.width + x | 0;
						let this1 = img.image.get(location);
						let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
						let this3 = this2 >> 24 & 255;
						let this4 = this2 >> 16 & 255;
						let this5 = this2 >> 8 & 255;
						let this6 = this2 & 255;
						let this7 = color >> 24 & 255;
						let a2 = this7 == 0 ? 0. : this7 / 255;
						let this8 = color >> 16 & 255;
						let this9 = color >> 8 & 255;
						let this10 = color & 255;
						let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
						let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
						img.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						img.image.set(img.useVirtualPos ? (y1 - img.virtualY) * img.width + x - img.virtualX | 0 : y1 * img.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
					}
					let x1 = img.width - x - 1;
					let y2 = y + 1;
					let x2 = this1.width - 1;
					let c2 = this1.image.get(this1.useVirtualPos ? (0 - this1.virtualY) * this1.width + x2 - this1.virtualX | 0 : 0 * this1.width + x2 | 0);
					let color1 = pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
					let c3 = color1;
					if((c3 >> 24 & 255) < 254 && img.transparent) {
						let location = img.useVirtualPos ? (y2 - img.virtualY) * img.width + x1 - img.virtualX | 0 : y2 * img.width + x1 | 0;
						let this1 = img.image.get(location);
						let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
						let this3 = this2 >> 24 & 255;
						let this4 = this2 >> 16 & 255;
						let this5 = this2 >> 8 & 255;
						let this6 = this2 & 255;
						let this7 = color1 >> 24 & 255;
						let a2 = this7 == 0 ? 0. : this7 / 255;
						let this8 = color1 >> 16 & 255;
						let this9 = color1 >> 8 & 255;
						let this10 = color1 & 255;
						let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
						let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
						img.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						img.image.set(img.useVirtualPos ? (y2 - img.virtualY) * img.width + x1 - img.virtualX | 0 : y2 * img.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3);
					}
				}
			}
			let _g16 = 0;
			while(_g16 < 1) {
				let x = _g16++;
				let _g = 0;
				while(_g < 1) {
					let y = _g++;
					let c = this1.image.get(this1.useVirtualPos ? (0 - this1.virtualY) * this1.width - this1.virtualX | 0 : 0 * this1.width | 0);
					let color = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					let c1 = color;
					if((c1 >> 24 & 255) < 254 && img.transparent) {
						let location = img.useVirtualPos ? (y - img.virtualY) * img.width + x - img.virtualX | 0 : y * img.width + x | 0;
						let this1 = img.image.get(location);
						let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
						let this3 = this2 >> 24 & 255;
						let this4 = this2 >> 16 & 255;
						let this5 = this2 >> 8 & 255;
						let this6 = this2 & 255;
						let this7 = color >> 24 & 255;
						let a2 = this7 == 0 ? 0. : this7 / 255;
						let this8 = color >> 16 & 255;
						let this9 = color >> 8 & 255;
						let this10 = color & 255;
						let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
						let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
						img.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						img.image.set(img.useVirtualPos ? (y - img.virtualY) * img.width + x - img.virtualX | 0 : y * img.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
					}
					let x1 = x + 1 + this1.width;
					let x2 = this1.width - 1;
					let c2 = this1.image.get(this1.useVirtualPos ? (0 - this1.virtualY) * this1.width + x2 - this1.virtualX | 0 : 0 * this1.width + x2 | 0);
					let color1 = pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
					let c3 = color1;
					if((c3 >> 24 & 255) < 254 && img.transparent) {
						let location = img.useVirtualPos ? (y - img.virtualY) * img.width + x1 - img.virtualX | 0 : y * img.width + x1 | 0;
						let this1 = img.image.get(location);
						let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
						let this3 = this2 >> 24 & 255;
						let this4 = this2 >> 16 & 255;
						let this5 = this2 >> 8 & 255;
						let this6 = this2 & 255;
						let this7 = color1 >> 24 & 255;
						let a2 = this7 == 0 ? 0. : this7 / 255;
						let this8 = color1 >> 16 & 255;
						let this9 = color1 >> 8 & 255;
						let this10 = color1 & 255;
						let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
						let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
						img.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						img.image.set(img.useVirtualPos ? (y - img.virtualY) * img.width + x1 - img.virtualX | 0 : y * img.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3);
					}
					let x3 = x + 1 + this1.width;
					let y1 = y + 1 + this1.height;
					let x4 = this1.width - 1;
					let y2 = this1.height - 1;
					let c4 = this1.image.get(this1.useVirtualPos ? (y2 - this1.virtualY) * this1.width + x4 - this1.virtualX | 0 : y2 * this1.width + x4 | 0);
					let color2 = pi_$xy_Endian_isLittleEndian ? (c4 >> 24 & 255) << 24 | (c4 & 255) << 16 | (c4 >> 8 & 255) << 8 | c4 >> 16 & 255 : c4;
					let c5 = color2;
					if((c5 >> 24 & 255) < 254 && img.transparent) {
						let location = img.useVirtualPos ? (y1 - img.virtualY) * img.width + x3 - img.virtualX | 0 : y1 * img.width + x3 | 0;
						let this1 = img.image.get(location);
						let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
						let this3 = this2 >> 24 & 255;
						let this4 = this2 >> 16 & 255;
						let this5 = this2 >> 8 & 255;
						let this6 = this2 & 255;
						let this7 = color2 >> 24 & 255;
						let a2 = this7 == 0 ? 0. : this7 / 255;
						let this8 = color2 >> 16 & 255;
						let this9 = color2 >> 8 & 255;
						let this10 = color2 & 255;
						let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
						let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
						img.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						img.image.set(img.useVirtualPos ? (y1 - img.virtualY) * img.width + x3 - img.virtualX | 0 : y1 * img.width + x3 | 0,pi_$xy_Endian_isLittleEndian ? (c5 >> 24 & 255) << 24 | (c5 & 255) << 16 | (c5 >> 8 & 255) << 8 | c5 >> 16 & 255 : c5);
					}
					let y3 = y + 1 + this1.width;
					let y4 = this1.height - 1;
					let c6 = this1.image.get(this1.useVirtualPos ? (y4 - this1.virtualY) * this1.width - this1.virtualX | 0 : y4 * this1.width | 0);
					let color3 = pi_$xy_Endian_isLittleEndian ? (c6 >> 24 & 255) << 24 | (c6 & 255) << 16 | (c6 >> 8 & 255) << 8 | c6 >> 16 & 255 : c6;
					let c7 = color3;
					if((c7 >> 24 & 255) < 254 && img.transparent) {
						let location = img.useVirtualPos ? (y3 - img.virtualY) * img.width + x - img.virtualX | 0 : y3 * img.width + x | 0;
						let this1 = img.image.get(location);
						let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
						let this3 = this2 >> 24 & 255;
						let this4 = this2 >> 16 & 255;
						let this5 = this2 >> 8 & 255;
						let this6 = this2 & 255;
						let this7 = color3 >> 24 & 255;
						let a2 = this7 == 0 ? 0. : this7 / 255;
						let this8 = color3 >> 16 & 255;
						let this9 = color3 >> 8 & 255;
						let this10 = color3 & 255;
						let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
						let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
						img.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						img.image.set(img.useVirtualPos ? (y3 - img.virtualY) * img.width + x - img.virtualX | 0 : y3 * img.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c7 >> 24 & 255) << 24 | (c7 & 255) << 16 | (c7 >> 8 & 255) << 8 | c7 >> 16 & 255 : c7);
					}
				}
			}
			let _g17 = 1;
			let _g18 = this1.height - 2;
			while(_g17 < _g18) {
				let y = _g17++;
				let _g = 1;
				let _g1 = this1.width - 2;
				while(_g < _g1) {
					let x = _g++;
					if(x == 1) {
						let x1 = x - 1;
						let y1 = y - 1;
						let c = img.image.get(img.useVirtualPos ? (y1 - img.virtualY) * img.width + x1 - img.virtualX | 0 : y1 * img.width + x1 | 0);
						a0 = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						let y2 = y - 1;
						let c1 = img.image.get(img.useVirtualPos ? (y2 - img.virtualY) * img.width + x - img.virtualX | 0 : y2 * img.width + x | 0);
						b0 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						let x2 = x + 1;
						let y3 = y - 1;
						let c2 = img.image.get(img.useVirtualPos ? (y3 - img.virtualY) * img.width + x2 - img.virtualX | 0 : y3 * img.width + x2 | 0);
						c0 = pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
						let x3 = x - 1;
						let c3 = img.image.get(img.useVirtualPos ? (y - img.virtualY) * img.width + x3 - img.virtualX | 0 : y * img.width + x3 | 0);
						d0 = pi_$xy_Endian_isLittleEndian ? (c3 >> 24 & 255) << 24 | (c3 & 255) << 16 | (c3 >> 8 & 255) << 8 | c3 >> 16 & 255 : c3;
						let c4 = img.image.get(img.useVirtualPos ? (y - img.virtualY) * img.width + x - img.virtualX | 0 : y * img.width + x | 0);
						e0 = pi_$xy_Endian_isLittleEndian ? (c4 >> 24 & 255) << 24 | (c4 & 255) << 16 | (c4 >> 8 & 255) << 8 | c4 >> 16 & 255 : c4;
						let x4 = x + 1;
						let c5 = img.image.get(img.useVirtualPos ? (y - img.virtualY) * img.width + x4 - img.virtualX | 0 : y * img.width + x4 | 0);
						f0 = pi_$xy_Endian_isLittleEndian ? (c5 >> 24 & 255) << 24 | (c5 & 255) << 16 | (c5 >> 8 & 255) << 8 | c5 >> 16 & 255 : c5;
						let x5 = x - 1;
						let y4 = y + 1;
						let c6 = img.image.get(img.useVirtualPos ? (y4 - img.virtualY) * img.width + x5 - img.virtualX | 0 : y4 * img.width + x5 | 0);
						g0 = pi_$xy_Endian_isLittleEndian ? (c6 >> 24 & 255) << 24 | (c6 & 255) << 16 | (c6 >> 8 & 255) << 8 | c6 >> 16 & 255 : c6;
						let y5 = y + 1;
						let c7 = img.image.get(img.useVirtualPos ? (y5 - img.virtualY) * img.width + x - img.virtualX | 0 : y5 * img.width + x | 0);
						h0 = pi_$xy_Endian_isLittleEndian ? (c7 >> 24 & 255) << 24 | (c7 & 255) << 16 | (c7 >> 8 & 255) << 8 | c7 >> 16 & 255 : c7;
						let x6 = x + 1;
						let y6 = y + 1;
						let c8 = img.image.get(img.useVirtualPos ? (y6 - img.virtualY) * img.width + x6 - img.virtualX | 0 : y6 * img.width + x6 | 0);
						i0 = pi_$xy_Endian_isLittleEndian ? (c8 >> 24 & 255) << 24 | (c8 & 255) << 16 | (c8 >> 8 & 255) << 8 | c8 >> 16 & 255 : c8;
					} else {
						a0 = b0;
						b0 = c0;
						let x1 = x + 1;
						let y1 = y - 1;
						let c = img.image.get(img.useVirtualPos ? (y1 - img.virtualY) * img.width + x1 - img.virtualX | 0 : y1 * img.width + x1 | 0);
						c0 = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
						d0 = e0;
						e0 = f0;
						let x2 = x + 1;
						let c1 = img.image.get(img.useVirtualPos ? (y - img.virtualY) * img.width + x2 - img.virtualX | 0 : y * img.width + x2 | 0);
						f0 = pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1;
						g0 = h0;
						h0 = i0;
						let x3 = x + 1;
						let y2 = y + 1;
						let c2 = img.image.get(img.useVirtualPos ? (y2 - img.virtualY) * img.width + x3 - img.virtualX | 0 : y2 * img.width + x3 | 0);
						i0 = pi_$xy_Endian_isLittleEndian ? (c2 >> 24 & 255) << 24 | (c2 & 255) << 16 | (c2 >> 8 & 255) << 8 | c2 >> 16 & 255 : c2;
					}
					r_ = 0.;
					if(a0 != 0) {
						r_ = (a0 >> 16 & 255) / 255 * 0.111111111111111105;
					}
					if(b0 != 0) {
						r_ += (b0 >> 16 & 255) / 255 * 0.111111111111111105;
					}
					if(c0 != 0) {
						r_ += (c0 >> 16 & 255) / 255 * 0.111111111111111105;
					}
					if(d0 != 0) {
						r_ += (d0 >> 16 & 255) / 255 * 0.111111111111111105;
					}
					if(e0 != 0) {
						r_ += (e0 >> 16 & 255) / 255 * 0.111111111111111105;
					}
					if(f0 != 0) {
						r_ += (f0 >> 16 & 255) / 255 * 0.111111111111111105;
					}
					if(g0 != 0) {
						r_ += (g0 >> 16 & 255) / 255 * 0.111111111111111105;
					}
					if(h0 != 0) {
						r_ += (h0 >> 16 & 255) / 255 * 0.111111111111111105;
					}
					if(i0 != 0) {
						r_ += (i0 >> 16 & 255) / 255 * 0.111111111111111105;
					}
					g_ = 0.;
					if(a0 != 0) {
						g_ = (a0 >> 8 & 255) / 255 * 0.111111111111111105;
					}
					if(b0 != 0) {
						g_ += (b0 >> 8 & 255) / 255 * 0.111111111111111105;
					}
					if(c0 != 0) {
						g_ += (c0 >> 8 & 255) / 255 * 0.111111111111111105;
					}
					if(d0 != 0) {
						g_ += (d0 >> 8 & 255) / 255 * 0.111111111111111105;
					}
					if(e0 != 0) {
						g_ += (e0 >> 8 & 255) / 255 * 0.111111111111111105;
					}
					if(f0 != 0) {
						g_ += (f0 >> 8 & 255) / 255 * 0.111111111111111105;
					}
					if(g0 != 0) {
						g_ += (g0 >> 8 & 255) / 255 * 0.111111111111111105;
					}
					if(h0 != 0) {
						g_ += (h0 >> 8 & 255) / 255 * 0.111111111111111105;
					}
					if(i0 != 0) {
						g_ += (i0 >> 8 & 255) / 255 * 0.111111111111111105;
					}
					b_ = 0.;
					if(a0 != 0) {
						b_ = (a0 & 255) / 255 * 0.111111111111111105;
					}
					if(b0 != 0) {
						b_ += (b0 & 255) / 255 * 0.111111111111111105;
					}
					if(c0 != 0) {
						b_ += (c0 & 255) / 255 * 0.111111111111111105;
					}
					if(d0 != 0) {
						b_ += (d0 & 255) / 255 * 0.111111111111111105;
					}
					if(e0 != 0) {
						b_ += (e0 & 255) / 255 * 0.111111111111111105;
					}
					if(f0 != 0) {
						b_ += (f0 & 255) / 255 * 0.111111111111111105;
					}
					if(g0 != 0) {
						b_ += (g0 & 255) / 255 * 0.111111111111111105;
					}
					if(h0 != 0) {
						b_ += (h0 & 255) / 255 * 0.111111111111111105;
					}
					if(i0 != 0) {
						b_ += (i0 & 255) / 255 * 0.111111111111111105;
					}
					a_ = (e0 >> 24 & 255) / 255;
					let x1 = x - 1;
					let y1 = y - 1;
					let color = Math.round(a_ * 255) << 24 | Math.round(r_ * 255) << 16 | Math.round(g_ * 255) << 8 | Math.round(b_ * 255);
					let c = color;
					if((c >> 24 & 255) < 254 && out.transparent) {
						let location = out.useVirtualPos ? (y1 - out.virtualY) * out.width + x1 - out.virtualX | 0 : y1 * out.width + x1 | 0;
						let this1 = out.image.get(location);
						let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
						let this3 = this2 >> 24 & 255;
						let this4 = this2 >> 16 & 255;
						let this5 = this2 >> 8 & 255;
						let this6 = this2 & 255;
						let this7 = color >> 24 & 255;
						let a2 = this7 == 0 ? 0. : this7 / 255;
						let this8 = color >> 16 & 255;
						let this9 = color >> 8 & 255;
						let this10 = color & 255;
						let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
						let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
						out.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						out.image.set(out.useVirtualPos ? (y1 - out.virtualY) * out.width + x1 - out.virtualX | 0 : y1 * out.width + x1 | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
			}
			blured = null;
			blured = out;
		}
		let this18 = this.pixelimage;
		let x1 = 100 + pix0.width + 20;
		let _g63 = 0;
		let _g64 = blured.height;
		while(_g63 < _g64) {
			let dy = _g63++;
			let _g = 0;
			let _g1 = blured.width;
			while(_g < _g1) {
				let dx = _g++;
				let c = blured.image.get(blured.useVirtualPos ? (dy - blured.virtualY) * blured.width + dx - blured.virtualX | 0 : dy * blured.width + dx | 0);
				let col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				if(blured.useMask && blured.mask != null) {
					let this1 = blured.mask;
					let c = this1.image.get(this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0);
					let maskPixel = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					let this2 = col;
					if(maskPixel == 0) {
						col = this2;
					} else {
						let this1 = maskPixel >> 24 & 255;
						let this3 = maskPixel >> 16 & 255;
						let this4 = maskPixel >> 8 & 255;
						let this5 = maskPixel & 255;
						col = Math.round(((1. - (this1 == 0 ? 0. : this1 / 255)) * (this2 >> 24 & 255) | 0) * 255) << 24 | Math.round(((1. - (this3 == 0 ? 0. : this3 / 255)) * (this2 >> 16 & 255) | 0) * 255) << 16 | Math.round(((1. - (this4 == 0 ? 0. : this4 / 255)) * (this2 >> 8 & 255) | 0) * 255) << 8 | Math.round(((1. - (this5 == 0 ? 0. : this5 / 255)) * (this2 & 255) | 0) * 255);
					}
				}
				if(col != 0) {
					let x = x1 + dx;
					let y = 100 + dy;
					let c = col;
					if((c >> 24 & 255) < 254 && this18.transparent) {
						let location = this18.useVirtualPos ? (y - this18.virtualY) * this18.width + x - this18.virtualX | 0 : y * this18.width + x | 0;
						let this1 = this18.image.get(location);
						let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
						let this3 = this2 >> 24 & 255;
						let this4 = this2 >> 16 & 255;
						let this5 = this2 >> 8 & 255;
						let this6 = this2 & 255;
						let this7 = col >> 24 & 255;
						let a2 = this7 == 0 ? 0. : this7 / 255;
						let this8 = col >> 16 & 255;
						let this9 = col >> 8 & 255;
						let this10 = col & 255;
						let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
						let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
						this18.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this18.image.set(this18.useVirtualPos ? (y - this18.virtualY) * this18.width + x - this18.virtualX | 0 : y * this18.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
			}
		}
		let this19 = this.pixelimage;
		let x2 = 100 + 2 * (pix0.width + 20);
		let _g65 = 0;
		let _g66 = out1.height;
		while(_g65 < _g66) {
			let dy = _g65++;
			let _g = 0;
			let _g1 = out1.width;
			while(_g < _g1) {
				let dx = _g++;
				let c = out1.image.get(out1.useVirtualPos ? (dy - out1.virtualY) * out1.width + dx - out1.virtualX | 0 : dy * out1.width + dx | 0);
				let col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				if(out1.useMask && out1.mask != null) {
					let this1 = out1.mask;
					let c = this1.image.get(this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0);
					let maskPixel = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					let this2 = col;
					if(maskPixel == 0) {
						col = this2;
					} else {
						let this1 = maskPixel >> 24 & 255;
						let this3 = maskPixel >> 16 & 255;
						let this4 = maskPixel >> 8 & 255;
						let this5 = maskPixel & 255;
						col = Math.round(((1. - (this1 == 0 ? 0. : this1 / 255)) * (this2 >> 24 & 255) | 0) * 255) << 24 | Math.round(((1. - (this3 == 0 ? 0. : this3 / 255)) * (this2 >> 16 & 255) | 0) * 255) << 16 | Math.round(((1. - (this4 == 0 ? 0. : this4 / 255)) * (this2 >> 8 & 255) | 0) * 255) << 8 | Math.round(((1. - (this5 == 0 ? 0. : this5 / 255)) * (this2 & 255) | 0) * 255);
					}
				}
				if(col != 0) {
					let x = x2 + dx;
					let y = 100 + dy;
					let c = col;
					if((c >> 24 & 255) < 254 && this19.transparent) {
						let location = this19.useVirtualPos ? (y - this19.virtualY) * this19.width + x - this19.virtualX | 0 : y * this19.width + x | 0;
						let this1 = this19.image.get(location);
						let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
						let this3 = this2 >> 24 & 255;
						let this4 = this2 >> 16 & 255;
						let this5 = this2 >> 8 & 255;
						let this6 = this2 & 255;
						let this7 = col >> 24 & 255;
						let a2 = this7 == 0 ? 0. : this7 / 255;
						let this8 = col >> 16 & 255;
						let this9 = col >> 8 & 255;
						let this10 = col & 255;
						let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
						let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
						this19.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this19.image.set(this19.useVirtualPos ? (y - this19.virtualY) * this19.width + x - this19.virtualX | 0 : y * this19.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
			}
		}
		let p = 0;
		let q = 0;
		let width7 = pix0.width;
		let height7 = pix0.height;
		let imageType16 = null;
		let this20 = new pi_$xy_ImageStruct();
		imageType16 = pi_$xy_ImageStruct.defaultType;
		let imageType17 = imageType16;
		if(imageType17 == null) {
			imageType17 = 2;
		}
		let tmp6;
		switch(imageType17) {
		case 0:
			let b24 = new iterMagic_BytesImg();
			b24.width = width7;
			b24.height = height7;
			b24.length = width7 * height7 | 0;
			b24.data = new haxe_io_Bytes(new ArrayBuffer(b24.length * 4));
			let w8 = 0;
			let _g67 = 0;
			let _g68 = b24.height;
			while(_g67 < _g68) {
				++_g67;
				let _g = 0;
				let _g1 = b24.width;
				while(_g < _g1) {
					++_g;
					b24.data.b[w8++] = 0;
					b24.data.b[w8++] = 0;
					b24.data.b[w8++] = 0;
					b24.data.b[w8++] = 0;
				}
			}
			tmp6 = b24;
			break;
		case 1:
			let a8 = new iterMagic_ArrIntImg();
			a8.width = width7;
			a8.height = height7;
			a8.data = [];
			a8.length = width7 * height7 | 0;
			let len32 = a8.length;
			let _g69 = 0;
			while(_g69 < len32) a8.data[_g69++] = 0;
			tmp6 = a8;
			break;
		case 2:
			let b25 = new iterMagic_U32ArrImg();
			b25.width = width7;
			b25.height = height7;
			b25.length = width7 * height7 | 0;
			b25.data = new Uint32Array(b25.length);
			let len33 = b25.length;
			let _g70 = 0;
			while(_g70 < len33) b25.data[_g70++] = 0;
			tmp6 = b25;
			break;
		case 3:
			let v8 = new iterMagic_VecIntImg();
			v8.width = width7;
			v8.height = height7;
			v8.length = width7 * height7 | 0;
			let this21 = new Array(v8.length);
			v8.data = this21;
			let len34 = v8.length;
			let _g71 = 0;
			while(_g71 < len34) v8.data[_g71++] = 0;
			tmp6 = v8;
			break;
		case 4:
			let b26 = new iterMagic_StackIntImg();
			b26.width = width7;
			b26.height = height7;
			b26.length = width7 * height7 | 0;
			b26.data = new haxe_ds_GenericStack();
			let len35 = b26.length;
			let d8 = b26.data;
			if(d8.head == null) {
				let _g = 0;
				while(_g < len35) {
					++_g;
					d8.head = new haxe_ds_GenericCell(0,d8.head);
				}
			} else {
				let _g = 0;
				while(_g < len35) {
					let i = _g++;
					let l = b26.data.head;
					let prev = null;
					let _g1 = 0;
					while(_g1 < i) {
						++_g1;
						prev = l;
						l = l.next;
					}
					if(prev == null) {
						b26.data.head = new haxe_ds_GenericCell(0,l.next);
						l = null;
					} else {
						prev.next = new haxe_ds_GenericCell(0,l.next);
						l = null;
					}
				}
			}
			tmp6 = b26;
			break;
		}
		this20.image = tmp6;
		this20.width = width7;
		this20.height = height7;
		this20.imageType = imageType16;
		let out2 = this20;
		let wid1 = pix0.width - 1;
		let hi1 = pix0.height - 1;
		while(true) {
			let c = pix0.image.get(pix0.useVirtualPos ? (q - pix0.virtualY) * pix0.width + p - pix0.virtualX | 0 : q * pix0.width + p | 0);
			let color = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
			let l = 0.;
			let v = 0;
			let color1;
			l = (color >> 24 & 255) / 255 * (0.21 * ((color >> 16 & 255) / 255) + 0.72 * ((color >> 8 & 255) / 255) + 0.07 * ((color & 255) / 255));
			v = Math.round(l * 255);
			color1 = -16777216 | v << 16 | v << 8 | v;
			let c1 = color1;
			if((c1 >> 24 & 255) < 254 && out2.transparent) {
				let location = out2.useVirtualPos ? (q - out2.virtualY) * out2.width + p - out2.virtualX | 0 : q * out2.width + p | 0;
				let this1 = out2.image.get(location);
				let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
				let this3 = this2 >> 24 & 255;
				let this4 = this2 >> 16 & 255;
				let this5 = this2 >> 8 & 255;
				let this6 = this2 & 255;
				let this7 = color1 >> 24 & 255;
				let a2 = this7 == 0 ? 0. : this7 / 255;
				let this8 = color1 >> 16 & 255;
				let this9 = color1 >> 8 & 255;
				let this10 = color1 & 255;
				let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
				let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
				out2.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
			} else {
				out2.image.set(out2.useVirtualPos ? (q - out2.virtualY) * out2.width + p - out2.virtualX | 0 : q * out2.width + p | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
			}
			++p;
			if(p > wid1) {
				p = 0;
				++q;
			}
			if(q > hi1) {
				break;
			}
		}
		let this22 = this.pixelimage;
		let y1 = 100 + pix0.height + 20;
		let _g72 = 0;
		let _g73 = out2.height;
		while(_g72 < _g73) {
			let dy = _g72++;
			let _g = 0;
			let _g1 = out2.width;
			while(_g < _g1) {
				let dx = _g++;
				let c = out2.image.get(out2.useVirtualPos ? (dy - out2.virtualY) * out2.width + dx - out2.virtualX | 0 : dy * out2.width + dx | 0);
				let col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				if(out2.useMask && out2.mask != null) {
					let this1 = out2.mask;
					let c = this1.image.get(this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0);
					let maskPixel = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					let this2 = col;
					if(maskPixel == 0) {
						col = this2;
					} else {
						let this1 = maskPixel >> 24 & 255;
						let this3 = maskPixel >> 16 & 255;
						let this4 = maskPixel >> 8 & 255;
						let this5 = maskPixel & 255;
						col = Math.round(((1. - (this1 == 0 ? 0. : this1 / 255)) * (this2 >> 24 & 255) | 0) * 255) << 24 | Math.round(((1. - (this3 == 0 ? 0. : this3 / 255)) * (this2 >> 16 & 255) | 0) * 255) << 16 | Math.round(((1. - (this4 == 0 ? 0. : this4 / 255)) * (this2 >> 8 & 255) | 0) * 255) << 8 | Math.round(((1. - (this5 == 0 ? 0. : this5 / 255)) * (this2 & 255) | 0) * 255);
					}
				}
				if(col != 0) {
					let x = 100 + dx;
					let y = y1 + dy;
					let c = col;
					if((c >> 24 & 255) < 254 && this22.transparent) {
						let location = this22.useVirtualPos ? (y - this22.virtualY) * this22.width + x - this22.virtualX | 0 : y * this22.width + x | 0;
						let this1 = this22.image.get(location);
						let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
						let this3 = this2 >> 24 & 255;
						let this4 = this2 >> 16 & 255;
						let this5 = this2 >> 8 & 255;
						let this6 = this2 & 255;
						let this7 = col >> 24 & 255;
						let a2 = this7 == 0 ? 0. : this7 / 255;
						let this8 = col >> 16 & 255;
						let this9 = col >> 8 & 255;
						let this10 = col & 255;
						let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
						let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
						this22.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this22.image.set(this22.useVirtualPos ? (y - this22.virtualY) * this22.width + x - this22.virtualX | 0 : y * this22.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
			}
		}
		let p1 = 0;
		let q1 = 0;
		let width8 = pix0.width;
		let height8 = pix0.height;
		let imageType18 = null;
		let this23 = new pi_$xy_ImageStruct();
		imageType18 = pi_$xy_ImageStruct.defaultType;
		let imageType19 = imageType18;
		if(imageType19 == null) {
			imageType19 = 2;
		}
		let tmp7;
		switch(imageType19) {
		case 0:
			let b27 = new iterMagic_BytesImg();
			b27.width = width8;
			b27.height = height8;
			b27.length = width8 * height8 | 0;
			b27.data = new haxe_io_Bytes(new ArrayBuffer(b27.length * 4));
			let w9 = 0;
			let _g74 = 0;
			let _g75 = b27.height;
			while(_g74 < _g75) {
				++_g74;
				let _g = 0;
				let _g1 = b27.width;
				while(_g < _g1) {
					++_g;
					b27.data.b[w9++] = 0;
					b27.data.b[w9++] = 0;
					b27.data.b[w9++] = 0;
					b27.data.b[w9++] = 0;
				}
			}
			tmp7 = b27;
			break;
		case 1:
			let a9 = new iterMagic_ArrIntImg();
			a9.width = width8;
			a9.height = height8;
			a9.data = [];
			a9.length = width8 * height8 | 0;
			let len36 = a9.length;
			let _g76 = 0;
			while(_g76 < len36) a9.data[_g76++] = 0;
			tmp7 = a9;
			break;
		case 2:
			let b28 = new iterMagic_U32ArrImg();
			b28.width = width8;
			b28.height = height8;
			b28.length = width8 * height8 | 0;
			b28.data = new Uint32Array(b28.length);
			let len37 = b28.length;
			let _g77 = 0;
			while(_g77 < len37) b28.data[_g77++] = 0;
			tmp7 = b28;
			break;
		case 3:
			let v9 = new iterMagic_VecIntImg();
			v9.width = width8;
			v9.height = height8;
			v9.length = width8 * height8 | 0;
			let this24 = new Array(v9.length);
			v9.data = this24;
			let len38 = v9.length;
			let _g78 = 0;
			while(_g78 < len38) v9.data[_g78++] = 0;
			tmp7 = v9;
			break;
		case 4:
			let b29 = new iterMagic_StackIntImg();
			b29.width = width8;
			b29.height = height8;
			b29.length = width8 * height8 | 0;
			b29.data = new haxe_ds_GenericStack();
			let len39 = b29.length;
			let d9 = b29.data;
			if(d9.head == null) {
				let _g = 0;
				while(_g < len39) {
					++_g;
					d9.head = new haxe_ds_GenericCell(0,d9.head);
				}
			} else {
				let _g = 0;
				while(_g < len39) {
					let i = _g++;
					let l = b29.data.head;
					let prev = null;
					let _g1 = 0;
					while(_g1 < i) {
						++_g1;
						prev = l;
						l = l.next;
					}
					if(prev == null) {
						b29.data.head = new haxe_ds_GenericCell(0,l.next);
						l = null;
					} else {
						prev.next = new haxe_ds_GenericCell(0,l.next);
						l = null;
					}
				}
			}
			tmp7 = b29;
			break;
		}
		this23.image = tmp7;
		this23.width = width8;
		this23.height = height8;
		this23.imageType = imageType18;
		let out3 = this23;
		let wid2 = pix0.width - 1;
		let hi2 = pix0.height - 1;
		while(true) {
			let c = pix0.image.get(pix0.useVirtualPos ? (q1 - pix0.virtualY) * pix0.width + p1 - pix0.virtualX | 0 : q1 * pix0.width + p1 | 0);
			let a = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
			let color = Math.round((0.8 * ((a >> 24 & 255) / 255) + 0.199999999999999956) * 255) << 24 | Math.round((0.8 * ((a >> 16 & 255) / 255) + 0.199999999999999956) * 255) << 16 | Math.round(0.8 * ((a >> 8 & 255) / 255) * 255) << 8 | Math.round(0.8 * ((a & 255) / 255) * 255);
			let c1 = color;
			if((c1 >> 24 & 255) < 254 && out3.transparent) {
				let location = out3.useVirtualPos ? (q1 - out3.virtualY) * out3.width + p1 - out3.virtualX | 0 : q1 * out3.width + p1 | 0;
				let this1 = out3.image.get(location);
				let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
				let this3 = this2 >> 24 & 255;
				let this4 = this2 >> 16 & 255;
				let this5 = this2 >> 8 & 255;
				let this6 = this2 & 255;
				let this7 = color >> 24 & 255;
				let a2 = this7 == 0 ? 0. : this7 / 255;
				let this8 = color >> 16 & 255;
				let this9 = color >> 8 & 255;
				let this10 = color & 255;
				let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
				let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
				out3.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
			} else {
				out3.image.set(out3.useVirtualPos ? (q1 - out3.virtualY) * out3.width + p1 - out3.virtualX | 0 : q1 * out3.width + p1 | 0,pi_$xy_Endian_isLittleEndian ? (c1 >> 24 & 255) << 24 | (c1 & 255) << 16 | (c1 >> 8 & 255) << 8 | c1 >> 16 & 255 : c1);
			}
			++p1;
			if(p1 > wid2) {
				p1 = 0;
				++q1;
			}
			if(q1 > hi2) {
				break;
			}
		}
		let this25 = this.pixelimage;
		let x3 = 100 + pix0.width + 20;
		let y2 = 100 + pix0.height + 20;
		let _g79 = 0;
		let _g80 = out3.height;
		while(_g79 < _g80) {
			let dy = _g79++;
			let _g = 0;
			let _g1 = out3.width;
			while(_g < _g1) {
				let dx = _g++;
				let c = out3.image.get(out3.useVirtualPos ? (dy - out3.virtualY) * out3.width + dx - out3.virtualX | 0 : dy * out3.width + dx | 0);
				let col = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
				if(out3.useMask && out3.mask != null) {
					let this1 = out3.mask;
					let c = this1.image.get(this1.useVirtualPos ? (dy - this1.virtualY) * this1.width + dx - this1.virtualX | 0 : dy * this1.width + dx | 0);
					let maskPixel = pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c;
					let this2 = col;
					if(maskPixel == 0) {
						col = this2;
					} else {
						let this1 = maskPixel >> 24 & 255;
						let this3 = maskPixel >> 16 & 255;
						let this4 = maskPixel >> 8 & 255;
						let this5 = maskPixel & 255;
						col = Math.round(((1. - (this1 == 0 ? 0. : this1 / 255)) * (this2 >> 24 & 255) | 0) * 255) << 24 | Math.round(((1. - (this3 == 0 ? 0. : this3 / 255)) * (this2 >> 16 & 255) | 0) * 255) << 16 | Math.round(((1. - (this4 == 0 ? 0. : this4 / 255)) * (this2 >> 8 & 255) | 0) * 255) << 8 | Math.round(((1. - (this5 == 0 ? 0. : this5 / 255)) * (this2 & 255) | 0) * 255);
					}
				}
				if(col != 0) {
					let x = x3 + dx;
					let y = y2 + dy;
					let c = col;
					if((c >> 24 & 255) < 254 && this25.transparent) {
						let location = this25.useVirtualPos ? (y - this25.virtualY) * this25.width + x - this25.virtualX | 0 : y * this25.width + x | 0;
						let this1 = this25.image.get(location);
						let this2 = pi_$xy_Endian_isLittleEndian ? (this1 >> 24 & 255) << 24 | (this1 & 255) << 16 | (this1 >> 8 & 255) << 8 | this1 >> 16 & 255 : this1;
						let this3 = this2 >> 24 & 255;
						let this4 = this2 >> 16 & 255;
						let this5 = this2 >> 8 & 255;
						let this6 = this2 & 255;
						let this7 = col >> 24 & 255;
						let a2 = this7 == 0 ? 0. : this7 / 255;
						let this8 = col >> 16 & 255;
						let this9 = col >> 8 & 255;
						let this10 = col & 255;
						let a3 = (this3 == 0 ? 0. : this3 / 255) * (1 - a2);
						let blended = (255 * (a3 + a2) | 0) << 24 | (255 * ((this4 == 0 ? 0. : this4 / 255) * a3 + (this8 == 0 ? 0. : this8 / 255) * a2) | 0) << 16 | (255 * ((this5 == 0 ? 0. : this5 / 255) * a3 + (this9 == 0 ? 0. : this9 / 255) * a2) | 0) << 8 | (255 * ((this6 == 0 ? 0. : this6 / 255) * a3 + (this10 == 0 ? 0. : this10 / 255) * a2) | 0);
						this25.image.set(location,pi_$xy_Endian_isLittleEndian ? (blended >> 24 & 255) << 24 | (blended & 255) << 16 | (blended >> 8 & 255) << 8 | blended >> 16 & 255 : blended);
					} else {
						this25.image.set(this25.useVirtualPos ? (y - this25.virtualY) * this25.width + x - this25.virtualX | 0 : y * this25.width + x | 0,pi_$xy_Endian_isLittleEndian ? (c >> 24 & 255) << 24 | (c & 255) << 16 | (c >> 8 & 255) << 8 | c >> 16 & 255 : c);
					}
				}
			}
		}
		let this26 = this.pixelimage;
		let ctx1 = this.surface.me;
		let base1 = this26;
		if(base1.useMask && base1.mask != null) {
			let width = this26.width;
			let height = this26.height;
			let imageType = null;
			let this1 = new pi_$xy_ImageStruct();
			imageType = pi_$xy_ImageStruct.defaultType;
			let imageType1 = imageType;
			if(imageType1 == null) {
				imageType1 = 2;
			}
			let tmp;
			switch(imageType1) {
			case 0:
				let b = new iterMagic_BytesImg();
				b.width = width;
				b.height = height;
				b.length = width * height | 0;
				b.data = new haxe_io_Bytes(new ArrayBuffer(b.length * 4));
				let w = 0;
				let _g = 0;
				let _g1 = b.height;
				while(_g < _g1) {
					++_g;
					let _g1 = 0;
					let _g2 = b.width;
					while(_g1 < _g2) {
						++_g1;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
						b.data.b[w++] = 0;
					}
				}
				tmp = b;
				break;
			case 1:
				let a = new iterMagic_ArrIntImg();
				a.width = width;
				a.height = height;
				a.data = [];
				a.length = width * height | 0;
				let len = a.length;
				let _g2 = 0;
				while(_g2 < len) a.data[_g2++] = 0;
				tmp = a;
				break;
			case 2:
				let b1 = new iterMagic_U32ArrImg();
				b1.width = width;
				b1.height = height;
				b1.length = width * height | 0;
				b1.data = new Uint32Array(b1.length);
				let len1 = b1.length;
				let _g3 = 0;
				while(_g3 < len1) b1.data[_g3++] = 0;
				tmp = b1;
				break;
			case 3:
				let v = new iterMagic_VecIntImg();
				v.width = width;
				v.height = height;
				v.length = width * height | 0;
				let this2 = new Array(v.length);
				v.data = this2;
				let len2 = v.length;
				let _g4 = 0;
				while(_g4 < len2) v.data[_g4++] = 0;
				tmp = v;
				break;
			case 4:
				let b2 = new iterMagic_StackIntImg();
				b2.width = width;
				b2.height = height;
				b2.length = width * height | 0;
				b2.data = new haxe_ds_GenericStack();
				let len3 = b2.length;
				let d = b2.data;
				if(d.head == null) {
					let _g = 0;
					while(_g < len3) {
						++_g;
						d.head = new haxe_ds_GenericCell(0,d.head);
					}
				} else {
					let _g = 0;
					while(_g < len3) {
						let i = _g++;
						let l = b2.data.head;
						let prev = null;
						let _g1 = 0;
						while(_g1 < i) {
							++_g1;
							prev = l;
							l = l.next;
						}
						if(prev == null) {
							b2.data.head = new haxe_ds_GenericCell(0,l.next);
							l = null;
						} else {
							prev.next = new haxe_ds_GenericCell(0,l.next);
							l = null;
						}
					}
				}
				tmp = b2;
				break;
			}
			this1.image = tmp;
			this1.width = width;
			this1.height = height;
			this1.imageType = imageType;
			let temp = this1;
			let _g5 = 0;
			let _g6 = this26.image.length;
			while(_g5 < _g6) {
				let i = _g5++;
				let p0 = this26.image.get(i);
				let m1 = this26.mask.image.get(i);
				let value;
				if(m1 == 0) {
					value = p0;
				} else {
					let this1 = m1 >> 24 & 255;
					let this2 = m1 >> 16 & 255;
					let this3 = m1 >> 8 & 255;
					let this4 = m1 & 255;
					value = Math.round(((1. - (this1 == 0 ? 0. : this1 / 255)) * (p0 >> 24 & 255) | 0) * 255) << 24 | Math.round(((1. - (this2 == 0 ? 0. : this2 / 255)) * (p0 >> 16 & 255) | 0) * 255) << 16 | Math.round(((1. - (this3 == 0 ? 0. : this3 / 255)) * (p0 >> 8 & 255) | 0) * 255) << 8 | Math.round(((1. - (this4 == 0 ? 0. : this4 / 255)) * (p0 & 255) | 0) * 255);
				}
				temp.image.set(i,value);
			}
			let temp1 = new Uint32Array(temp.width * temp.height | 0);
			let _g7 = 0;
			let _g8 = temp.image.length;
			while(_g7 < _g8) {
				let i = _g7++;
				temp1[i] = temp.image.get(i);
			}
			let data = new Uint8ClampedArray(new Uint8Array(temp1.buffer).buffer);
			let imageData = new ImageData(data,this26.width,this26.height);
			if(base1.useVirtualPos) {
				ctx1.putImageData(imageData,0 - base1.virtualX,0 - base1.virtualY);
			} else {
				ctx1.putImageData(imageData,0,0);
			}
		} else {
			let temp = new Uint32Array(this26.width * this26.height | 0);
			let _g = 0;
			let _g1 = this26.image.length;
			while(_g < _g1) {
				let i = _g++;
				temp[i] = this26.image.get(i);
			}
			let data = new Uint8ClampedArray(new Uint8Array(temp.buffer).buffer);
			let imageData = new ImageData(data,this26.width,this26.height);
			if(base1.useVirtualPos) {
				ctx1.putImageData(imageData,0 - base1.virtualX,0 - base1.virtualY);
			} else {
				ctx1.putImageData(imageData,0,0);
			}
		}
	}
}
pi_$xy_application_ConvolutionApp.__name__ = true;
function pi_$xy_application_ConvolutionApp_main() {
	new pi_$xy_application_ConvolutionApp();
}
class pi_$xy_iter_IntIterStart {
	constructor(min_,max_) {
		this.start = min_;
		this.max = max_;
	}
}
pi_$xy_iter_IntIterStart.__name__ = true;
function pi_$xy_textureImage_TestTiger_testTiger() {
	return "data:image/png;base64,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";
}
var $_;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
{
	String.__name__ = true;
	Array.__name__ = true;
}
js_Boot.__toStr = ({ }).toString;
var pi_$xy_Endian_isLittleEndian = (function($this) {
	var $r;
	let a8 = new Uint8Array(4);
	new Uint32Array(a8.buffer)[0] = -3407855;
	$r = a8[0] != 255;
	return $r;
}(this));
pi_$xy_ImageStruct.defaultType = 2;
pi_$xy_application_ConvolutionApp_main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
