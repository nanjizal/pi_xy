// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericCell_Int
#include <haxe/ds/GenericCell_Int.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericStack_Int
#include <haxe/ds/GenericStack_Int.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_iterMagic_ArrIntImg
#include <iterMagic/ArrIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_BytesImg
#include <iterMagic/BytesImg.h>
#endif
#ifndef INCLUDED_iterMagic_Iimg
#include <iterMagic/Iimg.h>
#endif
#ifndef INCLUDED_iterMagic_StackIntImg
#include <iterMagic/StackIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_U32ArrImg
#include <iterMagic/U32ArrImg.h>
#endif
#ifndef INCLUDED_iterMagic_VecIntImg
#include <iterMagic/VecIntImg.h>
#endif
#ifndef INCLUDED_pi_xy_ImageStruct
#include <pi_xy/ImageStruct.h>
#endif
#ifndef INCLUDED_pi_xy__Endian_Endian_Fields_
#include <pi_xy/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitQuad
#include <pi_xy/algo/HitQuad.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitTri
#include <pi_xy/algo/HitTri.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitTriArray
#include <pi_xy/algo/HitTriArray.h>
#endif
#ifndef INCLUDED_pi_xy_algo_IhitObj
#include <pi_xy/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pi_xy_algo_QuadPoints_
#include <pi_xy/algo/QuadPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_TriPoints_
#include <pi_xy/algo/TriPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_iter_IntIterStart
#include <pi_xy/iter/IntIterStart.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_ArrowShape
#include <pi_xy/triangleGML/ArrowShape.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_triGML_BasicShape
#include <pi_xy/triangleGML/triGML/BasicShape.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_triGML_GroupShape
#include <pi_xy/triangleGML/triGML/GroupShape.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_triGML_ShapeInterface
#include <pi_xy/triangleGML/triGML/ShapeInterface.h>
#endif
#ifndef INCLUDED_pi_xy_triangleGML_triGML_shape_contour_ArrowShape_
#include <pi_xy/triangleGML/triGML/shape/contour/ArrowShape_.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_c32be548b7ff77c8_6_new,"pi_xy.triangleGML.ArrowShape","new",0xc66f22c1,"pi_xy.triangleGML.ArrowShape.new","pi_xy/triangleGML/ArrowShape.hx",6,0x1cd8e90d)
HX_LOCAL_STACK_FRAME(_hx_pos_c32be548b7ff77c8_9_render,"pi_xy.triangleGML.ArrowShape","render",0x358b0b95,"pi_xy.triangleGML.ArrowShape.render","pi_xy/triangleGML/ArrowShape.hx",9,0x1cd8e90d)
namespace pi_xy{
namespace triangleGML{

void ArrowShape_obj::__construct( ::Dynamic opacity, ::Dynamic visibility, ::Dynamic strokeColor, ::Dynamic strokeWidth,::Array< ::String > strokeDashGapArray, ::Dynamic both, ::Dynamic flare, ::Dynamic reverseFlare, ::Dynamic x1, ::Dynamic y1, ::Dynamic x2, ::Dynamic y2, ::Dynamic arrowWidth, ::Dynamic arrowHeight){
            	HX_STACKFRAME(&_hx_pos_c32be548b7ff77c8_6_new)
HXDLIN(   6)		super::__construct(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,both,flare,reverseFlare,x1,y1,x2,y2,arrowWidth,arrowHeight);
            	}

Dynamic ArrowShape_obj::__CreateEmpty() { return new ArrowShape_obj; }

void *ArrowShape_obj::_hx_vtable = 0;

Dynamic ArrowShape_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< ArrowShape_obj > _hx_result = new ArrowShape_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7],inArgs[8],inArgs[9],inArgs[10],inArgs[11],inArgs[12],inArgs[13]);
	return _hx_result;
}

bool ArrowShape_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x4b4b811c) {
		if (inClassId<=(int)0x1a0bd5c0) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x1a0bd5c0;
		} else {
			return inClassId==(int)0x4b4b811c;
		}
	} else {
		return inClassId==(int)0x556e999b || inClassId==(int)0x7ff8cec5;
	}
}

 ::Dynamic ArrowShape_obj::render( ::Dynamic _tmp_pixelImage){
            	HX_GC_STACKFRAME(&_hx_pos_c32be548b7ff77c8_9_render)
HXLINE(  10)		 ::pi_xy::ImageStruct pixelImage = ( ( ::pi_xy::ImageStruct)(_tmp_pixelImage) );
HXDLIN(  10)		Float px = (this->x1 + this->offX);
HXLINE(  11)		Float qx = (this->x2 + this->offX);
HXLINE(  12)		Float py = (this->y1 + this->offY);
HXLINE(  13)		Float qy = (this->y2 + this->offY);
HXLINE(  15)		bool arrowFixed;
HXDLIN(  15)		if (!((this->arrowHeight > ((Float)0.)))) {
HXLINE(  15)			arrowFixed = (this->arrowWidth > ((Float)0.));
            		}
            		else {
HXLINE(  15)			arrowFixed = true;
            		}
HXLINE(  16)		bool hasSoftEdge = (this->edgeSoft != 0);
HXLINE(  17)		bool doubleSided = this->both;
HXLINE(  18)		::haxe::Log_obj::trace(HX_("render arrow",7f,95,bc,2b),::hx::SourceInfo(HX_("src/pi_xy/triangleGML/ArrowShape.hx",a2,5e,aa,d5),18,HX_("pi_xy.triangleGML.ArrowShape",4f,ae,1c,34),HX_("render",56,6b,29,05)));
HXLINE(  19)		::haxe::Log_obj::trace(HX_("arrowHeight",90,f2,2a,bd),::hx::SourceInfo(HX_("src/pi_xy/triangleGML/ArrowShape.hx",a2,5e,aa,d5),19,HX_("pi_xy.triangleGML.ArrowShape",4f,ae,1c,34),HX_("render",56,6b,29,05)));
HXLINE(  20)		::haxe::Log_obj::trace(HX_("arrowWidth",7d,93,05,3e),::hx::SourceInfo(HX_("src/pi_xy/triangleGML/ArrowShape.hx",a2,5e,aa,d5),20,HX_("pi_xy.triangleGML.ArrowShape",4f,ae,1c,34),HX_("render",56,6b,29,05)));
HXLINE(  22)		 ::Dynamic _hx_tmp = ::haxe::Log_obj::trace;
HXDLIN(  22)		::String _hx_tmp1 = (HX_("fixed arrow ",63,cb,04,ac) + ::Std_obj::string(arrowFixed));
HXDLIN(  22)		_hx_tmp(_hx_tmp1,::hx::SourceInfo(HX_("src/pi_xy/triangleGML/ArrowShape.hx",a2,5e,aa,d5),22,HX_("pi_xy.triangleGML.ArrowShape",4f,ae,1c,34),HX_("render",56,6b,29,05)));
HXLINE(  23)		 ::Dynamic _hx_tmp2 = ::haxe::Log_obj::trace;
HXDLIN(  23)		::String _hx_tmp3 = (HX_("arrow soft edge ",84,42,fb,1b) + ::Std_obj::string(hasSoftEdge));
HXDLIN(  23)		_hx_tmp2(_hx_tmp3,::hx::SourceInfo(HX_("src/pi_xy/triangleGML/ArrowShape.hx",a2,5e,aa,d5),23,HX_("pi_xy.triangleGML.ArrowShape",4f,ae,1c,34),HX_("render",56,6b,29,05)));
HXLINE(  24)		 ::Dynamic _hx_tmp4 = ::haxe::Log_obj::trace;
HXDLIN(  24)		::String _hx_tmp5 = (HX_("arrow double sided ",2b,6d,d8,16) + ::Std_obj::string(this->both));
HXDLIN(  24)		_hx_tmp4(_hx_tmp5,::hx::SourceInfo(HX_("src/pi_xy/triangleGML/ArrowShape.hx",a2,5e,aa,d5),24,HX_("pi_xy.triangleGML.ArrowShape",4f,ae,1c,34),HX_("render",56,6b,29,05)));
HXLINE(  25)		{
HXLINE(  25)			 ::pi_xy::ImageStruct this1 = pixelImage;
HXDLIN(  25)			Float qx1 = this->arrowWidth;
HXDLIN(  25)			Float qy1 = this->arrowHeight;
HXDLIN(  25)			Float thick = this->strokeWidth;
HXDLIN(  25)			int color = this->strokeColor;
HXDLIN(  25)			bool hasHit = true;
HXDLIN(  25)			{
HXLINE(  25)				Float goldenRatio = ((Float)1.61803398875);
HXDLIN(  25)				Float o = (qy1 - py);
HXDLIN(  25)				Float a = (qx1 - px);
HXDLIN(  25)				Float h = ::Math_obj::pow(((o * o) + (a * a)),((Float)0.5));
HXDLIN(  25)				Float theta = ::Math_obj::atan2(o,a);
HXDLIN(  25)				Float thicker = ((( (Float)(2) ) * thick) * goldenRatio);
HXDLIN(  25)				Float sin = ::Math_obj::sin(theta);
HXDLIN(  25)				Float cos = ::Math_obj::cos(theta);
HXDLIN(  25)				Float radius = (thick / ( (Float)(2) ));
HXDLIN(  25)				Float radius2 = (thicker / ( (Float)(2) ));
HXDLIN(  25)				Float h2 = (h / goldenRatio);
HXDLIN(  25)				 ::pi_xy::algo::HitQuad hitQuad;
HXDLIN(  25)				{
HXLINE(  25)					Float sin1 = ::Math_obj::sin(theta);
HXDLIN(  25)					Float cos1 = ::Math_obj::cos(theta);
HXDLIN(  25)					Float radius1 = (thick / ( (Float)(2) ));
HXDLIN(  25)					Float dx = ((Float)0.1);
HXDLIN(  25)					Float dy = radius1;
HXDLIN(  25)					Float cx = h2;
HXDLIN(  25)					Float cy = radius1;
HXDLIN(  25)					Float bx = h2;
HXDLIN(  25)					Float by = -(radius1);
HXDLIN(  25)					Float ax = ((Float)0.1);
HXDLIN(  25)					Float ay = -(radius1);
HXDLIN(  25)					Float temp = ((Float)0.);
HXLINE(  28)					temp = (px + ((ax * cos1) - (ay * sin1)));
HXLINE(  29)					ay = (py + ((ay * cos1) + (ax * sin1)));
HXLINE(  30)					ax = temp;
HXLINE(  32)					temp = (px + ((bx * cos1) - (by * sin1)));
HXLINE(  33)					by = (py + ((by * cos1) + (bx * sin1)));
HXLINE(  34)					bx = temp;
HXLINE(  36)					temp = (px + ((cx * cos1) - (cy * sin1)));
HXLINE(  37)					cy = (py + ((cy * cos1) + (cx * sin1)));
HXLINE(  38)					cx = temp;
HXLINE(  40)					temp = (px + ((dx * cos1) - (dy * sin1)));
HXLINE(  41)					dy = (py + ((dy * cos1) + (dx * sin1)));
HXLINE(  42)					dx = temp;
HXLINE(  25)					Float bx1 = bx;
HXDLIN(  25)					Float by1 = by;
HXDLIN(  25)					Float cx1 = dx;
HXDLIN(  25)					Float cy1 = dy;
HXDLIN(  25)					bool hasUndo = false;
HXDLIN(  25)					bool adjustWinding = (((((ax * by1) - (bx1 * ay)) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ay) - (ax * cy1))) > 0);
HXDLIN(  25)					if (!(adjustWinding)) {
HXLINE(  25)						Float bx_ = bx1;
HXDLIN(  25)						Float by_ = by1;
HXDLIN(  25)						bx1 = cx1;
HXLINE(  26)						by1 = cy1;
HXLINE(  27)						cx1 = bx_;
HXLINE(  28)						cy1 = by_;
            					}
HXLINE(  25)					Float s0 = ((ay * cx1) - (ax * cy1));
HXDLIN(  25)					Float sx = (cy1 - ay);
HXDLIN(  25)					Float sy = (ax - cx1);
HXDLIN(  25)					Float t0 = ((ax * by1) - (ay * bx1));
HXDLIN(  25)					Float tx = (ay - by1);
HXDLIN(  25)					Float ty = (bx1 - ax);
HXDLIN(  25)					Float A = ((((-(by1) * cx1) + (ay * (-(bx1) + cx1))) + (ax * (by1 - cy1))) + (bx1 * cy1));
HXDLIN(  25)					 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  25)					if ((ax > bx1)) {
HXLINE(  25)						if ((ax > cx1)) {
HXLINE(  25)							int min;
HXDLIN(  25)							if ((bx1 > cx1)) {
HXLINE(  25)								min = ::Math_obj::floor(cx1);
            							}
            							else {
HXLINE(  25)								min = ::Math_obj::floor(bx1);
            							}
HXDLIN(  25)							int ii_min = min;
HXDLIN(  25)							int ii_max = ::Math_obj::ceil(ax);
HXDLIN(  25)							xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            						}
            						else {
HXLINE(  25)							int ii_min1 = ::Math_obj::floor(bx1);
HXDLIN(  25)							int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN(  25)							xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            						}
            					}
            					else {
HXLINE(  25)						if ((bx1 > cx1)) {
HXLINE(  25)							int min1;
HXDLIN(  25)							if ((ax > cx1)) {
HXLINE(  25)								min1 = ::Math_obj::floor(cx1);
            							}
            							else {
HXLINE(  25)								min1 = ::Math_obj::ceil(ax);
            							}
HXDLIN(  25)							int ii_min2 = min1;
HXDLIN(  25)							int ii_max2 = ::Math_obj::ceil(bx1);
HXDLIN(  25)							xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            						}
            						else {
HXLINE(  25)							int ii_min3 = ::Math_obj::floor(ax);
HXDLIN(  25)							int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN(  25)							xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            						}
            					}
HXDLIN(  25)					 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  25)					if ((ay > by1)) {
HXLINE(  25)						if ((ay > cy1)) {
HXLINE(  25)							int min2;
HXDLIN(  25)							if ((by1 > cy1)) {
HXLINE(  25)								min2 = ::Math_obj::floor(cy1);
            							}
            							else {
HXLINE(  25)								min2 = ::Math_obj::floor(by1);
            							}
HXDLIN(  25)							int ii_min4 = min2;
HXDLIN(  25)							int ii_max4 = ::Math_obj::ceil(ay);
HXDLIN(  25)							yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            						}
            						else {
HXLINE(  25)							int ii_min5 = ::Math_obj::floor(by1);
HXDLIN(  25)							int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN(  25)							yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            						}
            					}
            					else {
HXLINE(  25)						if ((by1 > cy1)) {
HXLINE(  25)							int min3;
HXDLIN(  25)							if ((ay > cy1)) {
HXLINE(  25)								min3 = ::Math_obj::floor(cy1);
            							}
            							else {
HXLINE(  25)								min3 = ::Math_obj::ceil(ay);
            							}
HXDLIN(  25)							int ii_min6 = min3;
HXDLIN(  25)							int ii_max6 = ::Math_obj::ceil(by1);
HXDLIN(  25)							yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            						}
            						else {
HXLINE(  25)							int ii_min7 = ::Math_obj::floor(ay);
HXDLIN(  25)							int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN(  25)							yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            						}
            					}
HXDLIN(  25)					 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  25)					if (hasUndo) {
HXLINE(  25)						int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  25)						int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  25)						 ::Dynamic imageType = null();
HXDLIN(  25)						 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  25)						if (::hx::IsNull( imageType )) {
HXLINE(  54)							imageType = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE(  25)						::Dynamic undoImage1;
HXDLIN(  25)						switch((int)(( (int)(imageType) ))){
            							case (int)0: {
HXLINE(  25)								 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  25)								 ::iterMagic::BytesImg b = byt;
HXDLIN(  25)								{
HXLINE(  25)									b->width = width;
HXDLIN(  25)									b->height = height;
HXDLIN(  25)									b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  25)									b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  25)									{
HXLINE(  25)										int len = b->length;
HXDLIN(  25)										int w = 0;
HXDLIN(  25)										{
HXLINE(  25)											int _g = 0;
HXDLIN(  25)											int _g1 = b->height;
HXDLIN(  25)											while((_g < _g1)){
HXLINE(  25)												_g = (_g + 1);
HXDLIN(  25)												int y = (_g - 1);
HXDLIN(  25)												{
HXLINE(  25)													int _g2 = 0;
HXDLIN(  25)													int _g3 = b->width;
HXDLIN(  25)													while((_g2 < _g3)){
HXLINE(  25)														_g2 = (_g2 + 1);
HXDLIN(  25)														int x = (_g2 - 1);
HXDLIN(  25)														{
HXLINE(  25)															w = (w + 1);
HXDLIN(  25)															b->data->b[(w - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  25)														{
HXLINE(  25)															w = (w + 1);
HXDLIN(  25)															b->data->b[(w - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  25)														{
HXLINE(  25)															w = (w + 1);
HXDLIN(  25)															b->data->b[(w - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  25)														{
HXLINE(  25)															w = (w + 1);
HXDLIN(  25)															b->data->b[(w - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  25)								undoImage1 = b;
            							}
            							break;
            							case (int)1: {
HXLINE(  25)								 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  25)								 ::iterMagic::ArrIntImg a1 = arrI;
HXDLIN(  25)								{
HXLINE(  25)									a1->width = width;
HXDLIN(  25)									a1->height = height;
HXDLIN(  25)									a1->data = ::Array_obj< int >::__new(0);
HXDLIN(  25)									a1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  25)									{
HXLINE(  25)										int _g4 = 0;
HXDLIN(  25)										int _g5 = a1->length;
HXDLIN(  25)										while((_g4 < _g5)){
HXLINE(  25)											_g4 = (_g4 + 1);
HXDLIN(  25)											int i = (_g4 - 1);
HXDLIN(  25)											a1->data[i] = 0;
            										}
            									}
            								}
HXDLIN(  25)								undoImage1 = a1;
            							}
            							break;
            							case (int)2: {
HXLINE(  25)								 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  25)								 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  25)								{
HXLINE(  25)									b1->width = width;
HXDLIN(  25)									b1->height = height;
HXDLIN(  25)									b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  25)									int size = (b1->length * 4);
HXDLIN(  25)									b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  25)									{
HXLINE(  25)										int _g6 = 0;
HXDLIN(  25)										int _g7 = b1->length;
HXDLIN(  25)										while((_g6 < _g7)){
HXLINE(  25)											_g6 = (_g6 + 1);
HXDLIN(  25)											int i1 = (_g6 - 1);
HXDLIN(  25)											{
HXLINE(  25)												 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  25)												bool undoImage2;
HXDLIN(  25)												if ((i1 >= 0)) {
HXLINE(  25)													undoImage2 = (i1 < (this3->byteLength >> 2));
            												}
            												else {
HXLINE(  25)													undoImage2 = false;
            												}
HXDLIN(  25)												if (undoImage2) {
HXLINE(  25)													 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  25)													int pos = ((i1 << 2) + this3->byteOffset);
HXDLIN(  25)													_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  25)													_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  25)													_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  25)													_this->b[(pos + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN(  25)								undoImage1 = b1;
            							}
            							break;
            							case (int)3: {
HXLINE(  25)								 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  25)								 ::iterMagic::VecIntImg v = vec;
HXDLIN(  25)								{
HXLINE(  25)									v->width = width;
HXDLIN(  25)									v->height = height;
HXDLIN(  25)									v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  25)									v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  25)									{
HXLINE(  25)										int _g8 = 0;
HXDLIN(  25)										int _g9 = v->length;
HXDLIN(  25)										while((_g8 < _g9)){
HXLINE(  25)											_g8 = (_g8 + 1);
HXDLIN(  25)											int i2 = (_g8 - 1);
HXDLIN(  25)											v->data->__unsafe_set(i2,0);
            										}
            									}
            								}
HXDLIN(  25)								undoImage1 = v;
            							}
            							break;
            							case (int)4: {
HXLINE(  25)								 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  25)								 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  25)								{
HXLINE(  25)									b2->width = width;
HXDLIN(  25)									b2->height = height;
HXDLIN(  25)									b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  25)									b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  25)									{
HXLINE(  25)										int len1 = b2->length;
HXDLIN(  25)										 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  25)										if (::hx::IsNull( d->head )) {
HXLINE(  25)											int _g10 = 0;
HXDLIN(  25)											int _g11 = len1;
HXDLIN(  25)											while((_g10 < _g11)){
HXLINE(  25)												_g10 = (_g10 + 1);
HXDLIN(  25)												int i3 = (_g10 - 1);
HXDLIN(  25)												d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            											}
            										}
            										else {
HXLINE(  25)											int _g12 = 0;
HXDLIN(  25)											int _g13 = len1;
HXDLIN(  25)											while((_g12 < _g13)){
HXLINE(  25)												_g12 = (_g12 + 1);
HXDLIN(  25)												int i4 = (_g12 - 1);
HXDLIN(  25)												{
HXLINE(  25)													 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  25)													 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  25)													{
HXLINE(  25)														int _g14 = 0;
HXDLIN(  25)														int _g15 = i4;
HXDLIN(  25)														while((_g14 < _g15)){
HXLINE(  25)															_g14 = (_g14 + 1);
HXDLIN(  25)															int i5 = (_g14 - 1);
HXLINE( 345)															prev = l;
HXLINE( 346)															l = l->next;
            														}
            													}
HXLINE(  25)													if (::hx::IsNull( prev )) {
HXLINE(  25)														b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  25)														l = null();
            													}
            													else {
HXLINE(  25)														prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  25)														l = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  25)								undoImage1 = b2;
            							}
            							break;
            						}
HXDLIN(  25)						this2->image = undoImage1;
HXDLIN(  25)						this2->width = width;
HXDLIN(  25)						this2->height = height;
HXDLIN(  25)						this2->imageType = ( (int)(imageType) );
HXDLIN(  25)						undoImage = this2;
HXDLIN(  25)						{
HXLINE(  25)							int rectLeft = xIter3->start;
HXDLIN(  25)							int rectTop = yIter3->start;
HXDLIN(  25)							int rectRight = xIter3->max;
HXDLIN(  25)							bool forceClear = false;
HXDLIN(  25)							{
HXLINE(  25)								int _g16 = rectTop;
HXDLIN(  25)								int _g17 = yIter3->max;
HXDLIN(  25)								while((_g16 < _g17)){
HXLINE(  25)									_g16 = (_g16 + 1);
HXDLIN(  25)									int dy1 = (_g16 - 1);
HXDLIN(  25)									{
HXLINE(  25)										int _g18 = rectLeft;
HXDLIN(  25)										int _g19 = rectRight;
HXDLIN(  25)										while((_g18 < _g19)){
HXLINE(  25)											_g18 = (_g18 + 1);
HXDLIN(  25)											int dx1 = (_g18 - 1);
HXDLIN(  25)											::Dynamic this4 = this1->image;
HXDLIN(  25)											int index;
HXDLIN(  25)											if (this1->useVirtualPos) {
HXLINE(  25)												index = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx1) - this1->virtualX));
            											}
            											else {
HXLINE(  25)												index = ::Std_obj::_hx_int(( (Float)(((dy1 * this1->width) + dx1)) ));
            											}
HXDLIN(  25)											int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN(  25)											int col;
HXDLIN(  25)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)												col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            											}
            											else {
HXLINE(  25)												col = c;
            											}
HXDLIN(  25)											bool hitQuad1;
HXDLIN(  25)											if (this1->useMask) {
HXLINE(  25)												hitQuad1 = ::hx::IsNotNull( this1->mask );
            											}
            											else {
HXLINE(  25)												hitQuad1 = false;
            											}
HXDLIN(  25)											if (hitQuad1) {
HXLINE(  25)												 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN(  25)												::Dynamic this6 = this5->image;
HXDLIN(  25)												int index1;
HXDLIN(  25)												if (this5->useVirtualPos) {
HXLINE(  25)													index1 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx1) - this5->virtualX));
            												}
            												else {
HXLINE(  25)													index1 = ::Std_obj::_hx_int(( (Float)(((dy1 * this5->width) + dx1)) ));
            												}
HXDLIN(  25)												int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN(  25)												int v1;
HXDLIN(  25)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)													v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            												}
            												else {
HXLINE(  25)													v1 = c1;
            												}
HXDLIN(  25)												int maskPixel = v1;
HXDLIN(  25)												int this7 = col;
HXDLIN(  25)												if ((maskPixel == 0)) {
HXLINE(  25)													col = this7;
            												}
            												else {
HXLINE(  25)													Float m0;
HXDLIN(  25)													int this8 = ((maskPixel >> 24) & 255);
HXDLIN(  25)													if ((this8 == 0)) {
HXLINE(  25)														m0 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float m1;
HXDLIN(  25)													int this9 = ((maskPixel >> 16) & 255);
HXDLIN(  25)													if ((this9 == 0)) {
HXLINE(  25)														m1 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float m2;
HXDLIN(  25)													int this10 = ((maskPixel >> 8) & 255);
HXDLIN(  25)													if ((this10 == 0)) {
HXLINE(  25)														m2 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float m3;
HXDLIN(  25)													int this11 = (maskPixel & 255);
HXDLIN(  25)													if ((this11 == 0)) {
HXLINE(  25)														m3 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN(  25)													int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN(  25)													int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN(  25)													int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN(  25)													col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  25)											if ((col != 0)) {
HXLINE(  25)												int x1 = (dx1 - rectLeft);
HXDLIN(  25)												int y1 = (dy1 - rectTop);
HXDLIN(  25)												int c2 = col;
HXDLIN(  25)												bool hitQuad2;
HXDLIN(  25)												if ((((c2 >> 24) & 255) < 254)) {
HXLINE(  25)													hitQuad2 = undoImage->transparent;
            												}
            												else {
HXLINE(  25)													hitQuad2 = false;
            												}
HXDLIN(  25)												if (hitQuad2) {
HXLINE(  25)													int location;
HXDLIN(  25)													if (undoImage->useVirtualPos) {
HXLINE(  25)														location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            													}
            													else {
HXLINE(  25)														location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            													}
HXDLIN(  25)													int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN(  25)													int this13;
HXDLIN(  25)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)														this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            													}
            													else {
HXLINE(  25)														this13 = this12;
            													}
HXDLIN(  25)													Float a11;
HXDLIN(  25)													int this14 = ((this13 >> 24) & 255);
HXDLIN(  25)													if ((this14 == 0)) {
HXLINE(  25)														a11 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														a11 = (( (Float)(this14) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float r1;
HXDLIN(  25)													int this15 = ((this13 >> 16) & 255);
HXDLIN(  25)													if ((this15 == 0)) {
HXLINE(  25)														r1 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float g1;
HXDLIN(  25)													int this16 = ((this13 >> 8) & 255);
HXDLIN(  25)													if ((this16 == 0)) {
HXLINE(  25)														g1 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float b11;
HXDLIN(  25)													int this17 = (this13 & 255);
HXDLIN(  25)													if ((this17 == 0)) {
HXLINE(  25)														b11 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float a2;
HXDLIN(  25)													int this18 = ((col >> 24) & 255);
HXDLIN(  25)													if ((this18 == 0)) {
HXLINE(  25)														a2 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float r2;
HXDLIN(  25)													int this19 = ((col >> 16) & 255);
HXDLIN(  25)													if ((this19 == 0)) {
HXLINE(  25)														r2 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float g2;
HXDLIN(  25)													int this20 = ((col >> 8) & 255);
HXDLIN(  25)													if ((this20 == 0)) {
HXLINE(  25)														g2 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float b21;
HXDLIN(  25)													int this21 = (col & 255);
HXDLIN(  25)													if ((this21 == 0)) {
HXLINE(  25)														b21 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float a3 = (a11 * (( (Float)(1) ) - a2));
HXDLIN(  25)													int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  25)													int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  25)													int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  25)													int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  25)													int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  25)													{
HXLINE(  25)														int hitQuad3;
HXDLIN(  25)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)															hitQuad3 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            														}
            														else {
HXLINE(  25)															hitQuad3 = blended;
            														}
HXDLIN(  25)														::iterMagic::Iimg_obj::set(undoImage->image,location,hitQuad3);
            													}
            												}
            												else {
HXLINE(  25)													::Dynamic this22 = undoImage->image;
HXDLIN(  25)													int index2;
HXDLIN(  25)													if (undoImage->useVirtualPos) {
HXLINE(  25)														index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            													}
            													else {
HXLINE(  25)														index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            													}
HXDLIN(  25)													int hitQuad4;
HXDLIN(  25)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)														hitQuad4 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            													}
            													else {
HXLINE(  25)														hitQuad4 = c2;
            													}
HXDLIN(  25)													::iterMagic::Iimg_obj::set(this22,index2,hitQuad4);
            												}
            											}
            											else {
HXLINE(  25)												if (forceClear) {
HXLINE(  25)													::Dynamic this23 = undoImage->image;
HXDLIN(  25)													int x2 = (dx1 - rectLeft);
HXDLIN(  25)													int y2 = (dy1 - rectTop);
HXDLIN(  25)													int index3;
HXDLIN(  25)													if (undoImage->useVirtualPos) {
HXLINE(  25)														index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            													}
            													else {
HXLINE(  25)														index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            													}
HXDLIN(  25)													::iterMagic::Iimg_obj::set(this23,index3,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  25)					bool found = false;
HXDLIN(  25)					Float s = ((Float)0.);
HXDLIN(  25)					Float t = ((Float)0.);
HXDLIN(  25)					Float sxx = ((Float)0.);
HXDLIN(  25)					Float txx = ((Float)0.);
HXDLIN(  25)					{
HXLINE(  25)						int _g_min = xIter3->start;
HXDLIN(  25)						int _g_max = xIter3->max;
HXDLIN(  25)						while((_g_min < _g_max)){
HXLINE(  25)							_g_min = (_g_min + 1);
HXDLIN(  25)							int x3 = (_g_min - 1);
HXLINE(  60)							sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)							txx = (tx * ( (Float)(x3) ));
HXLINE(  62)							found = false;
HXLINE(  25)							{
HXLINE(  25)								int _g_min1 = yIter3->start;
HXDLIN(  25)								int _g_max1 = yIter3->max;
HXDLIN(  25)								while((_g_min1 < _g_max1)){
HXLINE(  25)									_g_min1 = (_g_min1 + 1);
HXDLIN(  25)									int y3 = (_g_min1 - 1);
HXLINE(  64)									s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)									t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE(  25)									bool hitQuad5;
HXDLIN(  25)									if (!((s <= 0))) {
HXLINE(  25)										hitQuad5 = (t <= 0);
            									}
            									else {
HXLINE(  25)										hitQuad5 = true;
            									}
HXDLIN(  25)									if (hitQuad5) {
HXLINE(  25)										if (found) {
HXLINE(  25)											goto _hx_goto_12;
            										}
            									}
            									else {
HXLINE(  25)										if (((s + t) < A)) {
HXLINE(  25)											{
HXLINE(  25)												int c3 = color;
HXDLIN(  25)												bool hitQuad6;
HXDLIN(  25)												if ((((c3 >> 24) & 255) < 254)) {
HXLINE(  25)													hitQuad6 = this1->transparent;
            												}
            												else {
HXLINE(  25)													hitQuad6 = false;
            												}
HXDLIN(  25)												if (hitQuad6) {
HXLINE(  25)													int location1;
HXDLIN(  25)													if (this1->useVirtualPos) {
HXLINE(  25)														location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            													}
            													else {
HXLINE(  25)														location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            													}
HXDLIN(  25)													int this24 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN(  25)													int this25;
HXDLIN(  25)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)														this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            													}
            													else {
HXLINE(  25)														this25 = this24;
            													}
HXDLIN(  25)													Float a12;
HXDLIN(  25)													int this26 = ((this25 >> 24) & 255);
HXDLIN(  25)													if ((this26 == 0)) {
HXLINE(  25)														a12 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														a12 = (( (Float)(this26) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float r11;
HXDLIN(  25)													int this27 = ((this25 >> 16) & 255);
HXDLIN(  25)													if ((this27 == 0)) {
HXLINE(  25)														r11 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float g11;
HXDLIN(  25)													int this28 = ((this25 >> 8) & 255);
HXDLIN(  25)													if ((this28 == 0)) {
HXLINE(  25)														g11 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float b12;
HXDLIN(  25)													int this29 = (this25 & 255);
HXDLIN(  25)													if ((this29 == 0)) {
HXLINE(  25)														b12 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float a21;
HXDLIN(  25)													int this30 = ((color >> 24) & 255);
HXDLIN(  25)													if ((this30 == 0)) {
HXLINE(  25)														a21 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float r21;
HXDLIN(  25)													int this31 = ((color >> 16) & 255);
HXDLIN(  25)													if ((this31 == 0)) {
HXLINE(  25)														r21 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float g21;
HXDLIN(  25)													int this32 = ((color >> 8) & 255);
HXDLIN(  25)													if ((this32 == 0)) {
HXLINE(  25)														g21 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float b22;
HXDLIN(  25)													int this33 = (color & 255);
HXDLIN(  25)													if ((this33 == 0)) {
HXLINE(  25)														b22 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float a31 = (a12 * (( (Float)(1) ) - a21));
HXDLIN(  25)													int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  25)													int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  25)													int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  25)													int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  25)													int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  25)													{
HXLINE(  25)														int hitQuad7;
HXDLIN(  25)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)															hitQuad7 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            														}
            														else {
HXLINE(  25)															hitQuad7 = blended1;
            														}
HXDLIN(  25)														::iterMagic::Iimg_obj::set(this1->image,location1,hitQuad7);
            													}
            												}
            												else {
HXLINE(  25)													::Dynamic this34 = this1->image;
HXDLIN(  25)													int index4;
HXDLIN(  25)													if (this1->useVirtualPos) {
HXLINE(  25)														index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            													}
            													else {
HXLINE(  25)														index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            													}
HXDLIN(  25)													int hitQuad8;
HXDLIN(  25)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)														hitQuad8 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            													}
            													else {
HXLINE(  25)														hitQuad8 = c3;
            													}
HXDLIN(  25)													::iterMagic::Iimg_obj::set(this34,index4,hitQuad8);
            												}
            											}
HXLINE(  73)											found = true;
            										}
            										else {
HXLINE(  25)											if (found) {
HXLINE(  25)												goto _hx_goto_12;
            											}
            										}
            									}
            								}
            								_hx_goto_12:;
            							}
            						}
            					}
HXDLIN(  25)					 ::pi_xy::iter::IntIterStart v_yIter3;
HXDLIN(  25)					 ::pi_xy::iter::IntIterStart v_xIter3;
HXDLIN(  25)					int v_undoY;
HXDLIN(  25)					int v_undoX;
HXDLIN(  25)					Float v_ty;
HXDLIN(  25)					Float v_tx;
HXDLIN(  25)					Float v_t0;
HXDLIN(  25)					Float v_sy;
HXDLIN(  25)					Float v_sx;
HXDLIN(  25)					Float v_s0;
HXDLIN(  25)					Float v_A;
HXDLIN(  25)					Float ax1 = ax;
HXDLIN(  25)					Float ay1 = ay;
HXDLIN(  25)					 ::pi_xy::ImageStruct v_undoImage = null();
HXDLIN(  25)					Float bx2 = bx1;
HXDLIN(  25)					Float by2 = by1;
HXDLIN(  25)					Float cx2 = cx1;
HXDLIN(  25)					Float cy2 = cy1;
HXDLIN(  25)					bool adjustWinding1 = (((((ax1 * by2) - (bx2 * ay1)) + ((bx2 * cy2) - (cx2 * by2))) + ((cx2 * ay1) - (ax1 * cy2))) > 0);
HXDLIN(  25)					if (!(adjustWinding1)) {
HXLINE(  25)						Float bx_1 = bx2;
HXDLIN(  25)						Float by_1 = by2;
HXLINE(  24)						bx2 = cx2;
HXLINE(  25)						by2 = cy2;
HXLINE(  26)						cx2 = bx_1;
HXLINE(  27)						cy2 = by_1;
            					}
HXLINE(  25)					Float v_ax = ax1;
HXDLIN(  25)					Float v_ay = ay1;
HXDLIN(  25)					Float v_bx = bx2;
HXDLIN(  25)					Float v_by = by2;
HXDLIN(  25)					Float v_cx = cx2;
HXDLIN(  25)					Float v_cy = cy2;
HXDLIN(  25)					bool v_preCalculated = true;
HXDLIN(  25)					{
HXLINE(  25)						v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN(  25)						v_sx = (v_cy - v_ay);
HXDLIN(  25)						v_sy = (v_ax - v_cx);
HXDLIN(  25)						v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN(  25)						v_tx = (v_ay - v_by);
HXDLIN(  25)						v_ty = (v_bx - v_ax);
HXDLIN(  25)						v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN(  25)						Float a6 = v_ax;
HXDLIN(  25)						Float b5 = v_bx;
HXDLIN(  25)						Float c4 = v_cx;
HXDLIN(  25)						if ((a6 > b5)) {
HXLINE(  25)							if ((a6 > c4)) {
HXLINE(  25)								int min4;
HXDLIN(  25)								if ((b5 > c4)) {
HXLINE(  25)									min4 = ::Math_obj::floor(c4);
            								}
            								else {
HXLINE(  25)									min4 = ::Math_obj::floor(b5);
            								}
HXDLIN(  25)								int ii_min8 = min4;
HXDLIN(  25)								int ii_max8 = ::Math_obj::ceil(a6);
HXDLIN(  25)								v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            							}
            							else {
HXLINE(  25)								int ii_min9 = ::Math_obj::floor(b5);
HXDLIN(  25)								int ii_max9 = ::Math_obj::ceil(c4);
HXDLIN(  25)								v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            							}
            						}
            						else {
HXLINE(  25)							if ((b5 > c4)) {
HXLINE(  25)								int min5;
HXDLIN(  25)								if ((a6 > c4)) {
HXLINE(  25)									min5 = ::Math_obj::floor(c4);
            								}
            								else {
HXLINE(  25)									min5 = ::Math_obj::ceil(a6);
            								}
HXDLIN(  25)								int ii_min10 = min5;
HXDLIN(  25)								int ii_max10 = ::Math_obj::ceil(b5);
HXDLIN(  25)								v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            							}
            							else {
HXLINE(  25)								int ii_min11 = ::Math_obj::floor(a6);
HXDLIN(  25)								int ii_max11 = ::Math_obj::ceil(c4);
HXDLIN(  25)								v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            							}
            						}
HXDLIN(  25)						Float a7 = v_ay;
HXDLIN(  25)						Float b6 = v_by;
HXDLIN(  25)						Float c5 = v_cy;
HXDLIN(  25)						if ((a7 > b6)) {
HXLINE(  25)							if ((a7 > c5)) {
HXLINE(  25)								int min6;
HXDLIN(  25)								if ((b6 > c5)) {
HXLINE(  25)									min6 = ::Math_obj::floor(c5);
            								}
            								else {
HXLINE(  25)									min6 = ::Math_obj::floor(b6);
            								}
HXDLIN(  25)								int ii_min12 = min6;
HXDLIN(  25)								int ii_max12 = ::Math_obj::ceil(a7);
HXDLIN(  25)								v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            							}
            							else {
HXLINE(  25)								int ii_min13 = ::Math_obj::floor(b6);
HXDLIN(  25)								int ii_max13 = ::Math_obj::ceil(c5);
HXDLIN(  25)								v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            							}
            						}
            						else {
HXLINE(  25)							if ((b6 > c5)) {
HXLINE(  25)								int min7;
HXDLIN(  25)								if ((a7 > c5)) {
HXLINE(  25)									min7 = ::Math_obj::floor(c5);
            								}
            								else {
HXLINE(  25)									min7 = ::Math_obj::ceil(a7);
            								}
HXDLIN(  25)								int ii_min14 = min7;
HXDLIN(  25)								int ii_max14 = ::Math_obj::ceil(b6);
HXDLIN(  25)								v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            							}
            							else {
HXLINE(  25)								int ii_min15 = ::Math_obj::floor(a7);
HXDLIN(  25)								int ii_max15 = ::Math_obj::ceil(c5);
HXDLIN(  25)								v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            							}
            						}
            					}
HXDLIN(  25)					if (hasUndo) {
HXLINE(  25)						v_undoImage = undoImage;
HXDLIN(  25)						v_undoX = xIter3->start;
HXDLIN(  25)						v_undoY = yIter3->start;
            					}
HXDLIN(  25)					Float bx3 = cx;
HXDLIN(  25)					Float by3 = cy;
HXDLIN(  25)					Float cx3 = dx;
HXDLIN(  25)					Float cy3 = dy;
HXDLIN(  25)					bool hasUndo1 = false;
HXDLIN(  25)					bool adjustWinding2 = (((((bx * by3) - (bx3 * by)) + ((bx3 * cy3) - (cx3 * by3))) + ((cx3 * by) - (bx * cy3))) > 0);
HXDLIN(  25)					if (!(adjustWinding2)) {
HXLINE(  25)						Float bx_2 = bx3;
HXDLIN(  25)						Float by_2 = by3;
HXDLIN(  25)						bx3 = cx3;
HXLINE(  26)						by3 = cy3;
HXLINE(  27)						cx3 = bx_2;
HXLINE(  28)						cy3 = by_2;
            					}
HXLINE(  25)					Float s01 = ((by * cx3) - (bx * cy3));
HXDLIN(  25)					Float sx1 = (cy3 - by);
HXDLIN(  25)					Float sy1 = (bx - cx3);
HXDLIN(  25)					Float t01 = ((bx * by3) - (by * bx3));
HXDLIN(  25)					Float tx1 = (by - by3);
HXDLIN(  25)					Float ty1 = (bx3 - bx);
HXDLIN(  25)					Float A1 = ((((-(by3) * cx3) + (by * (-(bx3) + cx3))) + (bx * (by3 - cy3))) + (bx3 * cy3));
HXDLIN(  25)					 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  25)					if ((bx > bx3)) {
HXLINE(  25)						if ((bx > cx3)) {
HXLINE(  25)							int min8;
HXDLIN(  25)							if ((bx3 > cx3)) {
HXLINE(  25)								min8 = ::Math_obj::floor(cx3);
            							}
            							else {
HXLINE(  25)								min8 = ::Math_obj::floor(bx3);
            							}
HXDLIN(  25)							int ii_min16 = min8;
HXDLIN(  25)							int ii_max16 = ::Math_obj::ceil(bx);
HXDLIN(  25)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            						}
            						else {
HXLINE(  25)							int ii_min17 = ::Math_obj::floor(bx3);
HXDLIN(  25)							int ii_max17 = ::Math_obj::ceil(cx3);
HXDLIN(  25)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            						}
            					}
            					else {
HXLINE(  25)						if ((bx3 > cx3)) {
HXLINE(  25)							int min9;
HXDLIN(  25)							if ((bx > cx3)) {
HXLINE(  25)								min9 = ::Math_obj::floor(cx3);
            							}
            							else {
HXLINE(  25)								min9 = ::Math_obj::ceil(bx);
            							}
HXDLIN(  25)							int ii_min18 = min9;
HXDLIN(  25)							int ii_max18 = ::Math_obj::ceil(bx3);
HXDLIN(  25)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            						}
            						else {
HXLINE(  25)							int ii_min19 = ::Math_obj::floor(bx);
HXDLIN(  25)							int ii_max19 = ::Math_obj::ceil(cx3);
HXDLIN(  25)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            						}
            					}
HXDLIN(  25)					 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  25)					if ((by > by3)) {
HXLINE(  25)						if ((by > cy3)) {
HXLINE(  25)							int min10;
HXDLIN(  25)							if ((by3 > cy3)) {
HXLINE(  25)								min10 = ::Math_obj::floor(cy3);
            							}
            							else {
HXLINE(  25)								min10 = ::Math_obj::floor(by3);
            							}
HXDLIN(  25)							int ii_min20 = min10;
HXDLIN(  25)							int ii_max20 = ::Math_obj::ceil(by);
HXDLIN(  25)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            						}
            						else {
HXLINE(  25)							int ii_min21 = ::Math_obj::floor(by3);
HXDLIN(  25)							int ii_max21 = ::Math_obj::ceil(cy3);
HXDLIN(  25)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            						}
            					}
            					else {
HXLINE(  25)						if ((by3 > cy3)) {
HXLINE(  25)							int min11;
HXDLIN(  25)							if ((by > cy3)) {
HXLINE(  25)								min11 = ::Math_obj::floor(cy3);
            							}
            							else {
HXLINE(  25)								min11 = ::Math_obj::ceil(by);
            							}
HXDLIN(  25)							int ii_min22 = min11;
HXDLIN(  25)							int ii_max22 = ::Math_obj::ceil(by3);
HXDLIN(  25)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            						}
            						else {
HXLINE(  25)							int ii_min23 = ::Math_obj::floor(by);
HXDLIN(  25)							int ii_max23 = ::Math_obj::ceil(cy3);
HXDLIN(  25)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            						}
            					}
HXDLIN(  25)					 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  25)					if (hasUndo1) {
HXLINE(  25)						int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  25)						int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  25)						 ::Dynamic imageType1 = null();
HXDLIN(  25)						 ::pi_xy::ImageStruct this35 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  25)						if (::hx::IsNull( imageType1 )) {
HXLINE(  54)							imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE(  25)						::Dynamic undoImage4;
HXDLIN(  25)						switch((int)(( (int)(imageType1) ))){
            							case (int)0: {
HXLINE(  25)								 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  25)								 ::iterMagic::BytesImg b7 = byt1;
HXDLIN(  25)								{
HXLINE(  25)									b7->width = width1;
HXDLIN(  25)									b7->height = height1;
HXDLIN(  25)									b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  25)									b7->data = ::haxe::io::Bytes_obj::alloc((b7->length * 4));
HXDLIN(  25)									{
HXLINE(  25)										int len2 = b7->length;
HXDLIN(  25)										int w1 = 0;
HXDLIN(  25)										{
HXLINE(  25)											int _g20 = 0;
HXDLIN(  25)											int _g21 = b7->height;
HXDLIN(  25)											while((_g20 < _g21)){
HXLINE(  25)												_g20 = (_g20 + 1);
HXDLIN(  25)												int y4 = (_g20 - 1);
HXDLIN(  25)												{
HXLINE(  25)													int _g22 = 0;
HXDLIN(  25)													int _g23 = b7->width;
HXDLIN(  25)													while((_g22 < _g23)){
HXLINE(  25)														_g22 = (_g22 + 1);
HXDLIN(  25)														int x4 = (_g22 - 1);
HXDLIN(  25)														{
HXLINE(  25)															w1 = (w1 + 1);
HXDLIN(  25)															b7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  25)														{
HXLINE(  25)															w1 = (w1 + 1);
HXDLIN(  25)															b7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  25)														{
HXLINE(  25)															w1 = (w1 + 1);
HXDLIN(  25)															b7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  25)														{
HXLINE(  25)															w1 = (w1 + 1);
HXDLIN(  25)															b7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  25)								undoImage4 = b7;
            							}
            							break;
            							case (int)1: {
HXLINE(  25)								 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  25)								 ::iterMagic::ArrIntImg a8 = arrI1;
HXDLIN(  25)								{
HXLINE(  25)									a8->width = width1;
HXDLIN(  25)									a8->height = height1;
HXDLIN(  25)									a8->data = ::Array_obj< int >::__new(0);
HXDLIN(  25)									a8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  25)									{
HXLINE(  25)										int _g24 = 0;
HXDLIN(  25)										int _g25 = a8->length;
HXDLIN(  25)										while((_g24 < _g25)){
HXLINE(  25)											_g24 = (_g24 + 1);
HXDLIN(  25)											int i6 = (_g24 - 1);
HXDLIN(  25)											a8->data[i6] = 0;
            										}
            									}
            								}
HXDLIN(  25)								undoImage4 = a8;
            							}
            							break;
            							case (int)2: {
HXLINE(  25)								 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  25)								 ::iterMagic::U32ArrImg b8 = u32a1;
HXDLIN(  25)								{
HXLINE(  25)									b8->width = width1;
HXDLIN(  25)									b8->height = height1;
HXDLIN(  25)									b8->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  25)									int size1 = (b8->length * 4);
HXDLIN(  25)									b8->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  25)									{
HXLINE(  25)										int _g26 = 0;
HXDLIN(  25)										int _g27 = b8->length;
HXDLIN(  25)										while((_g26 < _g27)){
HXLINE(  25)											_g26 = (_g26 + 1);
HXDLIN(  25)											int i7 = (_g26 - 1);
HXDLIN(  25)											{
HXLINE(  25)												 ::haxe::io::ArrayBufferViewImpl this36 = b8->data;
HXDLIN(  25)												bool undoImage5;
HXDLIN(  25)												if ((i7 >= 0)) {
HXLINE(  25)													undoImage5 = (i7 < (this36->byteLength >> 2));
            												}
            												else {
HXLINE(  25)													undoImage5 = false;
            												}
HXDLIN(  25)												if (undoImage5) {
HXLINE(  25)													 ::haxe::io::Bytes _this1 = this36->bytes;
HXDLIN(  25)													int pos1 = ((i7 << 2) + this36->byteOffset);
HXDLIN(  25)													_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  25)													_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  25)													_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  25)													_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN(  25)								undoImage4 = b8;
            							}
            							break;
            							case (int)3: {
HXLINE(  25)								 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  25)								 ::iterMagic::VecIntImg v2 = vec1;
HXDLIN(  25)								{
HXLINE(  25)									v2->width = width1;
HXDLIN(  25)									v2->height = height1;
HXDLIN(  25)									v2->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  25)									v2->data = ::Array_obj< int >::__new(v2->length);
HXDLIN(  25)									{
HXLINE(  25)										int _g28 = 0;
HXDLIN(  25)										int _g29 = v2->length;
HXDLIN(  25)										while((_g28 < _g29)){
HXLINE(  25)											_g28 = (_g28 + 1);
HXDLIN(  25)											int i8 = (_g28 - 1);
HXDLIN(  25)											v2->data->__unsafe_set(i8,0);
            										}
            									}
            								}
HXDLIN(  25)								undoImage4 = v2;
            							}
            							break;
            							case (int)4: {
HXLINE(  25)								 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  25)								 ::iterMagic::StackIntImg b9 = sInt1;
HXDLIN(  25)								{
HXLINE(  25)									b9->width = width1;
HXDLIN(  25)									b9->height = height1;
HXDLIN(  25)									b9->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  25)									b9->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  25)									{
HXLINE(  25)										int len3 = b9->length;
HXDLIN(  25)										 ::haxe::ds::GenericStack_Int d1 = b9->data;
HXDLIN(  25)										if (::hx::IsNull( d1->head )) {
HXLINE(  25)											int _g30 = 0;
HXDLIN(  25)											int _g31 = len3;
HXDLIN(  25)											while((_g30 < _g31)){
HXLINE(  25)												_g30 = (_g30 + 1);
HXDLIN(  25)												int i9 = (_g30 - 1);
HXDLIN(  25)												d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            											}
            										}
            										else {
HXLINE(  25)											int _g32 = 0;
HXDLIN(  25)											int _g33 = len3;
HXDLIN(  25)											while((_g32 < _g33)){
HXLINE(  25)												_g32 = (_g32 + 1);
HXDLIN(  25)												int i10 = (_g32 - 1);
HXDLIN(  25)												{
HXLINE(  25)													 ::haxe::ds::GenericCell_Int l1 = b9->data->head;
HXDLIN(  25)													 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  25)													{
HXLINE(  25)														int _g34 = 0;
HXDLIN(  25)														int _g35 = i10;
HXDLIN(  25)														while((_g34 < _g35)){
HXLINE(  25)															_g34 = (_g34 + 1);
HXDLIN(  25)															int i11 = (_g34 - 1);
HXLINE( 345)															prev1 = l1;
HXLINE( 346)															l1 = l1->next;
            														}
            													}
HXLINE(  25)													if (::hx::IsNull( prev1 )) {
HXLINE(  25)														b9->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  25)														l1 = null();
            													}
            													else {
HXLINE(  25)														prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  25)														l1 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  25)								undoImage4 = b9;
            							}
            							break;
            						}
HXDLIN(  25)						this35->image = undoImage4;
HXDLIN(  25)						this35->width = width1;
HXDLIN(  25)						this35->height = height1;
HXDLIN(  25)						this35->imageType = ( (int)(imageType1) );
HXDLIN(  25)						undoImage3 = this35;
HXDLIN(  25)						{
HXLINE(  25)							int rectLeft1 = xIter31->start;
HXDLIN(  25)							int rectTop1 = yIter31->start;
HXDLIN(  25)							int rectRight1 = xIter31->max;
HXDLIN(  25)							bool forceClear1 = false;
HXDLIN(  25)							{
HXLINE(  25)								int _g36 = rectTop1;
HXDLIN(  25)								int _g37 = yIter31->max;
HXDLIN(  25)								while((_g36 < _g37)){
HXLINE(  25)									_g36 = (_g36 + 1);
HXDLIN(  25)									int dy2 = (_g36 - 1);
HXDLIN(  25)									{
HXLINE(  25)										int _g38 = rectLeft1;
HXDLIN(  25)										int _g39 = rectRight1;
HXDLIN(  25)										while((_g38 < _g39)){
HXLINE(  25)											_g38 = (_g38 + 1);
HXDLIN(  25)											int dx2 = (_g38 - 1);
HXDLIN(  25)											::Dynamic this37 = this1->image;
HXDLIN(  25)											int index5;
HXDLIN(  25)											if (this1->useVirtualPos) {
HXLINE(  25)												index5 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx2) - this1->virtualX));
            											}
            											else {
HXLINE(  25)												index5 = ::Std_obj::_hx_int(( (Float)(((dy2 * this1->width) + dx2)) ));
            											}
HXDLIN(  25)											int c6 = ::iterMagic::Iimg_obj::get(this37,index5);
HXDLIN(  25)											int col1;
HXDLIN(  25)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)												col1 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            											}
            											else {
HXLINE(  25)												col1 = c6;
            											}
HXDLIN(  25)											bool hitQuad9;
HXDLIN(  25)											if (this1->useMask) {
HXLINE(  25)												hitQuad9 = ::hx::IsNotNull( this1->mask );
            											}
            											else {
HXLINE(  25)												hitQuad9 = false;
            											}
HXDLIN(  25)											if (hitQuad9) {
HXLINE(  25)												 ::pi_xy::ImageStruct this38 = this1->mask;
HXDLIN(  25)												::Dynamic this39 = this38->image;
HXDLIN(  25)												int index6;
HXDLIN(  25)												if (this38->useVirtualPos) {
HXLINE(  25)													index6 = ::Std_obj::_hx_int(((((( (Float)(dy2) ) - this38->virtualY) * ( (Float)(this38->width) )) + dx2) - this38->virtualX));
            												}
            												else {
HXLINE(  25)													index6 = ::Std_obj::_hx_int(( (Float)(((dy2 * this38->width) + dx2)) ));
            												}
HXDLIN(  25)												int c7 = ::iterMagic::Iimg_obj::get(this39,index6);
HXDLIN(  25)												int v3;
HXDLIN(  25)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)													v3 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            												}
            												else {
HXLINE(  25)													v3 = c7;
            												}
HXDLIN(  25)												int maskPixel1 = v3;
HXDLIN(  25)												int this40 = col1;
HXDLIN(  25)												if ((maskPixel1 == 0)) {
HXLINE(  25)													col1 = this40;
            												}
            												else {
HXLINE(  25)													Float m01;
HXDLIN(  25)													int this41 = ((maskPixel1 >> 24) & 255);
HXDLIN(  25)													if ((this41 == 0)) {
HXLINE(  25)														m01 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														m01 = (( (Float)(this41) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float m11;
HXDLIN(  25)													int this42 = ((maskPixel1 >> 16) & 255);
HXDLIN(  25)													if ((this42 == 0)) {
HXLINE(  25)														m11 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														m11 = (( (Float)(this42) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float m21;
HXDLIN(  25)													int this43 = ((maskPixel1 >> 8) & 255);
HXDLIN(  25)													if ((this43 == 0)) {
HXLINE(  25)														m21 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														m21 = (( (Float)(this43) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float m31;
HXDLIN(  25)													int this44 = (maskPixel1 & 255);
HXDLIN(  25)													if ((this44 == 0)) {
HXLINE(  25)														m31 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														m31 = (( (Float)(this44) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this40 >> 24) & 255)) )));
HXDLIN(  25)													int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this40 >> 16) & 255)) )));
HXDLIN(  25)													int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this40 >> 8) & 255)) )));
HXDLIN(  25)													int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this40 & 255)) )));
HXDLIN(  25)													col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  25)											if ((col1 != 0)) {
HXLINE(  25)												int x5 = (dx2 - rectLeft1);
HXDLIN(  25)												int y5 = (dy2 - rectTop1);
HXDLIN(  25)												int c8 = col1;
HXDLIN(  25)												bool hitQuad10;
HXDLIN(  25)												if ((((c8 >> 24) & 255) < 254)) {
HXLINE(  25)													hitQuad10 = undoImage3->transparent;
            												}
            												else {
HXLINE(  25)													hitQuad10 = false;
            												}
HXDLIN(  25)												if (hitQuad10) {
HXLINE(  25)													int location2;
HXDLIN(  25)													if (undoImage3->useVirtualPos) {
HXLINE(  25)														location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            													}
            													else {
HXLINE(  25)														location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            													}
HXDLIN(  25)													int this45 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN(  25)													int this46;
HXDLIN(  25)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)														this46 = ((((((this45 >> 24) & 255) << 24) | ((this45 & 255) << 16)) | (((this45 >> 8) & 255) << 8)) | ((this45 >> 16) & 255));
            													}
            													else {
HXLINE(  25)														this46 = this45;
            													}
HXDLIN(  25)													Float a13;
HXDLIN(  25)													int this47 = ((this46 >> 24) & 255);
HXDLIN(  25)													if ((this47 == 0)) {
HXLINE(  25)														a13 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														a13 = (( (Float)(this47) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float r12;
HXDLIN(  25)													int this48 = ((this46 >> 16) & 255);
HXDLIN(  25)													if ((this48 == 0)) {
HXLINE(  25)														r12 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														r12 = (( (Float)(this48) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float g12;
HXDLIN(  25)													int this49 = ((this46 >> 8) & 255);
HXDLIN(  25)													if ((this49 == 0)) {
HXLINE(  25)														g12 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														g12 = (( (Float)(this49) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float b13;
HXDLIN(  25)													int this50 = (this46 & 255);
HXDLIN(  25)													if ((this50 == 0)) {
HXLINE(  25)														b13 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														b13 = (( (Float)(this50) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float a22;
HXDLIN(  25)													int this51 = ((col1 >> 24) & 255);
HXDLIN(  25)													if ((this51 == 0)) {
HXLINE(  25)														a22 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														a22 = (( (Float)(this51) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float r22;
HXDLIN(  25)													int this52 = ((col1 >> 16) & 255);
HXDLIN(  25)													if ((this52 == 0)) {
HXLINE(  25)														r22 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														r22 = (( (Float)(this52) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float g22;
HXDLIN(  25)													int this53 = ((col1 >> 8) & 255);
HXDLIN(  25)													if ((this53 == 0)) {
HXLINE(  25)														g22 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														g22 = (( (Float)(this53) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float b23;
HXDLIN(  25)													int this54 = (col1 & 255);
HXDLIN(  25)													if ((this54 == 0)) {
HXLINE(  25)														b23 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														b23 = (( (Float)(this54) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float a32 = (a13 * (( (Float)(1) ) - a22));
HXDLIN(  25)													int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  25)													int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  25)													int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  25)													int a9 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  25)													int blended2 = ((((a9 << 24) | (r4 << 16)) | (g4 << 8)) | b10);
HXDLIN(  25)													{
HXLINE(  25)														int hitQuad11;
HXDLIN(  25)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)															hitQuad11 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            														}
            														else {
HXLINE(  25)															hitQuad11 = blended2;
            														}
HXDLIN(  25)														::iterMagic::Iimg_obj::set(undoImage3->image,location2,hitQuad11);
            													}
            												}
            												else {
HXLINE(  25)													::Dynamic this55 = undoImage3->image;
HXDLIN(  25)													int index7;
HXDLIN(  25)													if (undoImage3->useVirtualPos) {
HXLINE(  25)														index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            													}
            													else {
HXLINE(  25)														index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            													}
HXDLIN(  25)													int hitQuad12;
HXDLIN(  25)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)														hitQuad12 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            													}
            													else {
HXLINE(  25)														hitQuad12 = c8;
            													}
HXDLIN(  25)													::iterMagic::Iimg_obj::set(this55,index7,hitQuad12);
            												}
            											}
            											else {
HXLINE(  25)												if (forceClear1) {
HXLINE(  25)													::Dynamic this56 = undoImage3->image;
HXDLIN(  25)													int x6 = (dx2 - rectLeft1);
HXDLIN(  25)													int y6 = (dy2 - rectTop1);
HXDLIN(  25)													int index8;
HXDLIN(  25)													if (undoImage3->useVirtualPos) {
HXLINE(  25)														index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            													}
            													else {
HXLINE(  25)														index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            													}
HXDLIN(  25)													::iterMagic::Iimg_obj::set(this56,index8,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  25)					bool found1 = false;
HXDLIN(  25)					Float s1 = ((Float)0.);
HXDLIN(  25)					Float t1 = ((Float)0.);
HXDLIN(  25)					Float sxx1 = ((Float)0.);
HXDLIN(  25)					Float txx1 = ((Float)0.);
HXDLIN(  25)					{
HXLINE(  25)						int _g_min2 = xIter31->start;
HXDLIN(  25)						int _g_max2 = xIter31->max;
HXDLIN(  25)						while((_g_min2 < _g_max2)){
HXLINE(  25)							_g_min2 = (_g_min2 + 1);
HXDLIN(  25)							int x7 = (_g_min2 - 1);
HXLINE(  60)							sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)							txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)							found1 = false;
HXLINE(  25)							{
HXLINE(  25)								int _g_min3 = yIter31->start;
HXDLIN(  25)								int _g_max3 = yIter31->max;
HXDLIN(  25)								while((_g_min3 < _g_max3)){
HXLINE(  25)									_g_min3 = (_g_min3 + 1);
HXDLIN(  25)									int y7 = (_g_min3 - 1);
HXLINE(  64)									s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)									t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE(  25)									bool hitQuad13;
HXDLIN(  25)									if (!((s1 <= 0))) {
HXLINE(  25)										hitQuad13 = (t1 <= 0);
            									}
            									else {
HXLINE(  25)										hitQuad13 = true;
            									}
HXDLIN(  25)									if (hitQuad13) {
HXLINE(  25)										if (found1) {
HXLINE(  25)											goto _hx_goto_24;
            										}
            									}
            									else {
HXLINE(  25)										if (((s1 + t1) < A1)) {
HXLINE(  25)											{
HXLINE(  25)												int c9 = color;
HXDLIN(  25)												bool hitQuad14;
HXDLIN(  25)												if ((((c9 >> 24) & 255) < 254)) {
HXLINE(  25)													hitQuad14 = this1->transparent;
            												}
            												else {
HXLINE(  25)													hitQuad14 = false;
            												}
HXDLIN(  25)												if (hitQuad14) {
HXLINE(  25)													int location3;
HXDLIN(  25)													if (this1->useVirtualPos) {
HXLINE(  25)														location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this1->virtualY) * ( (Float)(this1->width) )) + x7) - this1->virtualX));
            													}
            													else {
HXLINE(  25)														location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this1->width) + x7)) ));
            													}
HXDLIN(  25)													int this57 = ::iterMagic::Iimg_obj::get(this1->image,location3);
HXDLIN(  25)													int this58;
HXDLIN(  25)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)														this58 = ((((((this57 >> 24) & 255) << 24) | ((this57 & 255) << 16)) | (((this57 >> 8) & 255) << 8)) | ((this57 >> 16) & 255));
            													}
            													else {
HXLINE(  25)														this58 = this57;
            													}
HXDLIN(  25)													Float a14;
HXDLIN(  25)													int this59 = ((this58 >> 24) & 255);
HXDLIN(  25)													if ((this59 == 0)) {
HXLINE(  25)														a14 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														a14 = (( (Float)(this59) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float r13;
HXDLIN(  25)													int this60 = ((this58 >> 16) & 255);
HXDLIN(  25)													if ((this60 == 0)) {
HXLINE(  25)														r13 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														r13 = (( (Float)(this60) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float g13;
HXDLIN(  25)													int this61 = ((this58 >> 8) & 255);
HXDLIN(  25)													if ((this61 == 0)) {
HXLINE(  25)														g13 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														g13 = (( (Float)(this61) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float b14;
HXDLIN(  25)													int this62 = (this58 & 255);
HXDLIN(  25)													if ((this62 == 0)) {
HXLINE(  25)														b14 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														b14 = (( (Float)(this62) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float a23;
HXDLIN(  25)													int this63 = ((color >> 24) & 255);
HXDLIN(  25)													if ((this63 == 0)) {
HXLINE(  25)														a23 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														a23 = (( (Float)(this63) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float r23;
HXDLIN(  25)													int this64 = ((color >> 16) & 255);
HXDLIN(  25)													if ((this64 == 0)) {
HXLINE(  25)														r23 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														r23 = (( (Float)(this64) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float g23;
HXDLIN(  25)													int this65 = ((color >> 8) & 255);
HXDLIN(  25)													if ((this65 == 0)) {
HXLINE(  25)														g23 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														g23 = (( (Float)(this65) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float b24;
HXDLIN(  25)													int this66 = (color & 255);
HXDLIN(  25)													if ((this66 == 0)) {
HXLINE(  25)														b24 = ((Float)0.);
            													}
            													else {
HXLINE(  25)														b24 = (( (Float)(this66) ) / ( (Float)(255) ));
            													}
HXDLIN(  25)													Float a33 = (a14 * (( (Float)(1) ) - a23));
HXDLIN(  25)													int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  25)													int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  25)													int b15 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN(  25)													int a10 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  25)													int blended3 = ((((a10 << 24) | (r5 << 16)) | (g5 << 8)) | b15);
HXDLIN(  25)													{
HXLINE(  25)														int hitQuad15;
HXDLIN(  25)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)															hitQuad15 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            														}
            														else {
HXLINE(  25)															hitQuad15 = blended3;
            														}
HXDLIN(  25)														::iterMagic::Iimg_obj::set(this1->image,location3,hitQuad15);
            													}
            												}
            												else {
HXLINE(  25)													::Dynamic this67 = this1->image;
HXDLIN(  25)													int index9;
HXDLIN(  25)													if (this1->useVirtualPos) {
HXLINE(  25)														index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this1->virtualY) * ( (Float)(this1->width) )) + x7) - this1->virtualX));
            													}
            													else {
HXLINE(  25)														index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this1->width) + x7)) ));
            													}
HXDLIN(  25)													int hitQuad16;
HXDLIN(  25)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)														hitQuad16 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            													}
            													else {
HXLINE(  25)														hitQuad16 = c9;
            													}
HXDLIN(  25)													::iterMagic::Iimg_obj::set(this67,index9,hitQuad16);
            												}
            											}
HXLINE(  73)											found1 = true;
            										}
            										else {
HXLINE(  25)											if (found1) {
HXLINE(  25)												goto _hx_goto_24;
            											}
            										}
            									}
            								}
            								_hx_goto_24:;
            							}
            						}
            					}
HXDLIN(  25)					 ::pi_xy::iter::IntIterStart v_yIter31;
HXDLIN(  25)					 ::pi_xy::iter::IntIterStart v_xIter31;
HXDLIN(  25)					int v_undoY1;
HXDLIN(  25)					int v_undoX1;
HXDLIN(  25)					Float v_ty1;
HXDLIN(  25)					Float v_tx1;
HXDLIN(  25)					Float v_t01;
HXDLIN(  25)					Float v_sy1;
HXDLIN(  25)					Float v_sx1;
HXDLIN(  25)					Float v_s01;
HXDLIN(  25)					Float v_A1;
HXDLIN(  25)					Float ax2 = bx;
HXDLIN(  25)					Float ay2 = by;
HXDLIN(  25)					 ::pi_xy::ImageStruct v_undoImage1 = null();
HXDLIN(  25)					Float bx4 = bx3;
HXDLIN(  25)					Float by4 = by3;
HXDLIN(  25)					Float cx4 = cx3;
HXDLIN(  25)					Float cy4 = cy3;
HXDLIN(  25)					bool adjustWinding3 = (((((ax2 * by4) - (bx4 * ay2)) + ((bx4 * cy4) - (cx4 * by4))) + ((cx4 * ay2) - (ax2 * cy4))) > 0);
HXDLIN(  25)					if (!(adjustWinding3)) {
HXLINE(  25)						Float bx_3 = bx4;
HXDLIN(  25)						Float by_3 = by4;
HXLINE(  24)						bx4 = cx4;
HXLINE(  25)						by4 = cy4;
HXLINE(  26)						cx4 = bx_3;
HXLINE(  27)						cy4 = by_3;
            					}
HXLINE(  25)					Float v_ax1 = ax2;
HXDLIN(  25)					Float v_ay1 = ay2;
HXDLIN(  25)					Float v_bx1 = bx4;
HXDLIN(  25)					Float v_by1 = by4;
HXDLIN(  25)					Float v_cx1 = cx4;
HXDLIN(  25)					Float v_cy1 = cy4;
HXDLIN(  25)					bool v_preCalculated1 = true;
HXDLIN(  25)					{
HXLINE(  25)						v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN(  25)						v_sx1 = (v_cy1 - v_ay1);
HXDLIN(  25)						v_sy1 = (v_ax1 - v_cx1);
HXDLIN(  25)						v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN(  25)						v_tx1 = (v_ay1 - v_by1);
HXDLIN(  25)						v_ty1 = (v_bx1 - v_ax1);
HXDLIN(  25)						v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN(  25)						Float a15 = v_ax1;
HXDLIN(  25)						Float b16 = v_bx1;
HXDLIN(  25)						Float c10 = v_cx1;
HXDLIN(  25)						if ((a15 > b16)) {
HXLINE(  25)							if ((a15 > c10)) {
HXLINE(  25)								int min12;
HXDLIN(  25)								if ((b16 > c10)) {
HXLINE(  25)									min12 = ::Math_obj::floor(c10);
            								}
            								else {
HXLINE(  25)									min12 = ::Math_obj::floor(b16);
            								}
HXDLIN(  25)								int ii_min24 = min12;
HXDLIN(  25)								int ii_max24 = ::Math_obj::ceil(a15);
HXDLIN(  25)								v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            							}
            							else {
HXLINE(  25)								int ii_min25 = ::Math_obj::floor(b16);
HXDLIN(  25)								int ii_max25 = ::Math_obj::ceil(c10);
HXDLIN(  25)								v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            							}
            						}
            						else {
HXLINE(  25)							if ((b16 > c10)) {
HXLINE(  25)								int min13;
HXDLIN(  25)								if ((a15 > c10)) {
HXLINE(  25)									min13 = ::Math_obj::floor(c10);
            								}
            								else {
HXLINE(  25)									min13 = ::Math_obj::ceil(a15);
            								}
HXDLIN(  25)								int ii_min26 = min13;
HXDLIN(  25)								int ii_max26 = ::Math_obj::ceil(b16);
HXDLIN(  25)								v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            							}
            							else {
HXLINE(  25)								int ii_min27 = ::Math_obj::floor(a15);
HXDLIN(  25)								int ii_max27 = ::Math_obj::ceil(c10);
HXDLIN(  25)								v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            							}
            						}
HXDLIN(  25)						Float a16 = v_ay1;
HXDLIN(  25)						Float b17 = v_by1;
HXDLIN(  25)						Float c11 = v_cy1;
HXDLIN(  25)						if ((a16 > b17)) {
HXLINE(  25)							if ((a16 > c11)) {
HXLINE(  25)								int min14;
HXDLIN(  25)								if ((b17 > c11)) {
HXLINE(  25)									min14 = ::Math_obj::floor(c11);
            								}
            								else {
HXLINE(  25)									min14 = ::Math_obj::floor(b17);
            								}
HXDLIN(  25)								int ii_min28 = min14;
HXDLIN(  25)								int ii_max28 = ::Math_obj::ceil(a16);
HXDLIN(  25)								v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            							}
            							else {
HXLINE(  25)								int ii_min29 = ::Math_obj::floor(b17);
HXDLIN(  25)								int ii_max29 = ::Math_obj::ceil(c11);
HXDLIN(  25)								v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min29,ii_max29);
            							}
            						}
            						else {
HXLINE(  25)							if ((b17 > c11)) {
HXLINE(  25)								int min15;
HXDLIN(  25)								if ((a16 > c11)) {
HXLINE(  25)									min15 = ::Math_obj::floor(c11);
            								}
            								else {
HXLINE(  25)									min15 = ::Math_obj::ceil(a16);
            								}
HXDLIN(  25)								int ii_min30 = min15;
HXDLIN(  25)								int ii_max30 = ::Math_obj::ceil(b17);
HXDLIN(  25)								v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min30,ii_max30);
            							}
            							else {
HXLINE(  25)								int ii_min31 = ::Math_obj::floor(a16);
HXDLIN(  25)								int ii_max31 = ::Math_obj::ceil(c11);
HXDLIN(  25)								v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min31,ii_max31);
            							}
            						}
            					}
HXDLIN(  25)					if (hasUndo1) {
HXLINE(  25)						v_undoImage1 = undoImage3;
HXDLIN(  25)						v_undoX1 = xIter31->start;
HXDLIN(  25)						v_undoY1 = yIter31->start;
            					}
HXDLIN(  25)					 ::pi_xy::algo::HitQuad v4 =  ::pi_xy::algo::HitQuad_obj::__alloc( HX_CTX ,ax,ay,bx,by,cx,cy,dx,dy,true);
HXDLIN(  25)					hitQuad = v4;
            				}
HXDLIN(  25)				Float cx5 = h2;
HXDLIN(  25)				Float cy5 = radius2;
HXDLIN(  25)				Float bx5 = h2;
HXDLIN(  25)				Float by5 = -(radius2);
HXDLIN(  25)				Float temp1 = ((Float)0.);
HXLINE(  40)				temp1 = (px + ((bx5 * cos) - (by5 * sin)));
HXLINE(  41)				by5 = (py + ((by5 * cos) + (bx5 * sin)));
HXLINE(  42)				bx5 = temp1;
HXLINE(  43)				temp1 = (px + ((cx5 * cos) - (cy5 * sin)));
HXLINE(  44)				cy5 = (py + ((cy5 * cos) + (cx5 * sin)));
HXLINE(  45)				cx5 = temp1;
HXLINE(  25)				Float bx6 = bx5;
HXDLIN(  25)				Float by6 = by5;
HXDLIN(  25)				Float cx6 = cx5;
HXDLIN(  25)				Float cy6 = cy5;
HXDLIN(  25)				bool hasUndo2 = false;
HXDLIN(  25)				bool adjustWinding4 = (((((qx1 * by6) - (bx6 * qy1)) + ((bx6 * cy6) - (cx6 * by6))) + ((cx6 * qy1) - (qx1 * cy6))) > 0);
HXDLIN(  25)				if (!(adjustWinding4)) {
HXLINE(  25)					Float bx_4 = bx6;
HXDLIN(  25)					Float by_4 = by6;
HXDLIN(  25)					bx6 = cx6;
HXLINE(  26)					by6 = cy6;
HXLINE(  27)					cx6 = bx_4;
HXLINE(  28)					cy6 = by_4;
            				}
HXLINE(  25)				Float s02 = ((qy1 * cx6) - (qx1 * cy6));
HXDLIN(  25)				Float sx2 = (cy6 - qy1);
HXDLIN(  25)				Float sy2 = (qx1 - cx6);
HXDLIN(  25)				Float t02 = ((qx1 * by6) - (qy1 * bx6));
HXDLIN(  25)				Float tx2 = (qy1 - by6);
HXDLIN(  25)				Float ty2 = (bx6 - qx1);
HXDLIN(  25)				Float A2 = ((((-(by6) * cx6) + (qy1 * (-(bx6) + cx6))) + (qx1 * (by6 - cy6))) + (bx6 * cy6));
HXDLIN(  25)				 ::pi_xy::iter::IntIterStart xIter32;
HXDLIN(  25)				if ((qx1 > bx6)) {
HXLINE(  25)					if ((qx1 > cx6)) {
HXLINE(  25)						int min16;
HXDLIN(  25)						if ((bx6 > cx6)) {
HXLINE(  25)							min16 = ::Math_obj::floor(cx6);
            						}
            						else {
HXLINE(  25)							min16 = ::Math_obj::floor(bx6);
            						}
HXDLIN(  25)						int ii_min32 = min16;
HXDLIN(  25)						int ii_max32 = ::Math_obj::ceil(qx1);
HXDLIN(  25)						xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min32,ii_max32);
            					}
            					else {
HXLINE(  25)						int ii_min33 = ::Math_obj::floor(bx6);
HXDLIN(  25)						int ii_max33 = ::Math_obj::ceil(cx6);
HXDLIN(  25)						xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min33,ii_max33);
            					}
            				}
            				else {
HXLINE(  25)					if ((bx6 > cx6)) {
HXLINE(  25)						int min17;
HXDLIN(  25)						if ((qx1 > cx6)) {
HXLINE(  25)							min17 = ::Math_obj::floor(cx6);
            						}
            						else {
HXLINE(  25)							min17 = ::Math_obj::ceil(qx1);
            						}
HXDLIN(  25)						int ii_min34 = min17;
HXDLIN(  25)						int ii_max34 = ::Math_obj::ceil(bx6);
HXDLIN(  25)						xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min34,ii_max34);
            					}
            					else {
HXLINE(  25)						int ii_min35 = ::Math_obj::floor(qx1);
HXDLIN(  25)						int ii_max35 = ::Math_obj::ceil(cx6);
HXDLIN(  25)						xIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min35,ii_max35);
            					}
            				}
HXDLIN(  25)				 ::pi_xy::iter::IntIterStart yIter32;
HXDLIN(  25)				if ((qy1 > by6)) {
HXLINE(  25)					if ((qy1 > cy6)) {
HXLINE(  25)						int min18;
HXDLIN(  25)						if ((by6 > cy6)) {
HXLINE(  25)							min18 = ::Math_obj::floor(cy6);
            						}
            						else {
HXLINE(  25)							min18 = ::Math_obj::floor(by6);
            						}
HXDLIN(  25)						int ii_min36 = min18;
HXDLIN(  25)						int ii_max36 = ::Math_obj::ceil(qy1);
HXDLIN(  25)						yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min36,ii_max36);
            					}
            					else {
HXLINE(  25)						int ii_min37 = ::Math_obj::floor(by6);
HXDLIN(  25)						int ii_max37 = ::Math_obj::ceil(cy6);
HXDLIN(  25)						yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min37,ii_max37);
            					}
            				}
            				else {
HXLINE(  25)					if ((by6 > cy6)) {
HXLINE(  25)						int min19;
HXDLIN(  25)						if ((qy1 > cy6)) {
HXLINE(  25)							min19 = ::Math_obj::floor(cy6);
            						}
            						else {
HXLINE(  25)							min19 = ::Math_obj::ceil(qy1);
            						}
HXDLIN(  25)						int ii_min38 = min19;
HXDLIN(  25)						int ii_max38 = ::Math_obj::ceil(by6);
HXDLIN(  25)						yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min38,ii_max38);
            					}
            					else {
HXLINE(  25)						int ii_min39 = ::Math_obj::floor(qy1);
HXDLIN(  25)						int ii_max39 = ::Math_obj::ceil(cy6);
HXDLIN(  25)						yIter32 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min39,ii_max39);
            					}
            				}
HXDLIN(  25)				 ::pi_xy::ImageStruct undoImage6 = null();
HXDLIN(  25)				if (hasUndo2) {
HXLINE(  25)					int width2 = ((xIter32->max - xIter32->start) + 1);
HXDLIN(  25)					int height2 = ((yIter32->max - yIter32->start) + 1);
HXDLIN(  25)					 ::Dynamic imageType2 = null();
HXDLIN(  25)					 ::pi_xy::ImageStruct this68 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  25)					if (::hx::IsNull( imageType2 )) {
HXLINE(  54)						imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE(  25)					::Dynamic undoImage7;
HXDLIN(  25)					switch((int)(( (int)(imageType2) ))){
            						case (int)0: {
HXLINE(  25)							 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  25)							 ::iterMagic::BytesImg b18 = byt2;
HXDLIN(  25)							{
HXLINE(  25)								b18->width = width2;
HXDLIN(  25)								b18->height = height2;
HXDLIN(  25)								b18->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  25)								b18->data = ::haxe::io::Bytes_obj::alloc((b18->length * 4));
HXDLIN(  25)								{
HXLINE(  25)									int len4 = b18->length;
HXDLIN(  25)									int w2 = 0;
HXDLIN(  25)									{
HXLINE(  25)										int _g40 = 0;
HXDLIN(  25)										int _g41 = b18->height;
HXDLIN(  25)										while((_g40 < _g41)){
HXLINE(  25)											_g40 = (_g40 + 1);
HXDLIN(  25)											int y8 = (_g40 - 1);
HXDLIN(  25)											{
HXLINE(  25)												int _g42 = 0;
HXDLIN(  25)												int _g43 = b18->width;
HXDLIN(  25)												while((_g42 < _g43)){
HXLINE(  25)													_g42 = (_g42 + 1);
HXDLIN(  25)													int x8 = (_g42 - 1);
HXDLIN(  25)													{
HXLINE(  25)														w2 = (w2 + 1);
HXDLIN(  25)														b18->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  25)													{
HXLINE(  25)														w2 = (w2 + 1);
HXDLIN(  25)														b18->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  25)													{
HXLINE(  25)														w2 = (w2 + 1);
HXDLIN(  25)														b18->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  25)													{
HXLINE(  25)														w2 = (w2 + 1);
HXDLIN(  25)														b18->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  25)							undoImage7 = b18;
            						}
            						break;
            						case (int)1: {
HXLINE(  25)							 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  25)							 ::iterMagic::ArrIntImg a17 = arrI2;
HXDLIN(  25)							{
HXLINE(  25)								a17->width = width2;
HXDLIN(  25)								a17->height = height2;
HXDLIN(  25)								a17->data = ::Array_obj< int >::__new(0);
HXDLIN(  25)								a17->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  25)								{
HXLINE(  25)									int _g44 = 0;
HXDLIN(  25)									int _g45 = a17->length;
HXDLIN(  25)									while((_g44 < _g45)){
HXLINE(  25)										_g44 = (_g44 + 1);
HXDLIN(  25)										int i12 = (_g44 - 1);
HXDLIN(  25)										a17->data[i12] = 0;
            									}
            								}
            							}
HXDLIN(  25)							undoImage7 = a17;
            						}
            						break;
            						case (int)2: {
HXLINE(  25)							 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  25)							 ::iterMagic::U32ArrImg b19 = u32a2;
HXDLIN(  25)							{
HXLINE(  25)								b19->width = width2;
HXDLIN(  25)								b19->height = height2;
HXDLIN(  25)								b19->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  25)								int size2 = (b19->length * 4);
HXDLIN(  25)								b19->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN(  25)								{
HXLINE(  25)									int _g46 = 0;
HXDLIN(  25)									int _g47 = b19->length;
HXDLIN(  25)									while((_g46 < _g47)){
HXLINE(  25)										_g46 = (_g46 + 1);
HXDLIN(  25)										int i13 = (_g46 - 1);
HXDLIN(  25)										{
HXLINE(  25)											 ::haxe::io::ArrayBufferViewImpl this69 = b19->data;
HXDLIN(  25)											bool undoImage8;
HXDLIN(  25)											if ((i13 >= 0)) {
HXLINE(  25)												undoImage8 = (i13 < (this69->byteLength >> 2));
            											}
            											else {
HXLINE(  25)												undoImage8 = false;
            											}
HXDLIN(  25)											if (undoImage8) {
HXLINE(  25)												 ::haxe::io::Bytes _this2 = this69->bytes;
HXDLIN(  25)												int pos2 = ((i13 << 2) + this69->byteOffset);
HXDLIN(  25)												_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN(  25)												_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN(  25)												_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN(  25)												_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN(  25)							undoImage7 = b19;
            						}
            						break;
            						case (int)3: {
HXLINE(  25)							 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  25)							 ::iterMagic::VecIntImg v5 = vec2;
HXDLIN(  25)							{
HXLINE(  25)								v5->width = width2;
HXDLIN(  25)								v5->height = height2;
HXDLIN(  25)								v5->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  25)								v5->data = ::Array_obj< int >::__new(v5->length);
HXDLIN(  25)								{
HXLINE(  25)									int _g48 = 0;
HXDLIN(  25)									int _g49 = v5->length;
HXDLIN(  25)									while((_g48 < _g49)){
HXLINE(  25)										_g48 = (_g48 + 1);
HXDLIN(  25)										int i14 = (_g48 - 1);
HXDLIN(  25)										v5->data->__unsafe_set(i14,0);
            									}
            								}
            							}
HXDLIN(  25)							undoImage7 = v5;
            						}
            						break;
            						case (int)4: {
HXLINE(  25)							 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  25)							 ::iterMagic::StackIntImg b20 = sInt2;
HXDLIN(  25)							{
HXLINE(  25)								b20->width = width2;
HXDLIN(  25)								b20->height = height2;
HXDLIN(  25)								b20->length = ::Std_obj::_hx_int(( (Float)((width2 * height2)) ));
HXDLIN(  25)								b20->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  25)								{
HXLINE(  25)									int len5 = b20->length;
HXDLIN(  25)									 ::haxe::ds::GenericStack_Int d2 = b20->data;
HXDLIN(  25)									if (::hx::IsNull( d2->head )) {
HXLINE(  25)										int _g50 = 0;
HXDLIN(  25)										int _g51 = len5;
HXDLIN(  25)										while((_g50 < _g51)){
HXLINE(  25)											_g50 = (_g50 + 1);
HXDLIN(  25)											int i15 = (_g50 - 1);
HXDLIN(  25)											d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            										}
            									}
            									else {
HXLINE(  25)										int _g52 = 0;
HXDLIN(  25)										int _g53 = len5;
HXDLIN(  25)										while((_g52 < _g53)){
HXLINE(  25)											_g52 = (_g52 + 1);
HXDLIN(  25)											int i16 = (_g52 - 1);
HXDLIN(  25)											{
HXLINE(  25)												 ::haxe::ds::GenericCell_Int l2 = b20->data->head;
HXDLIN(  25)												 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN(  25)												{
HXLINE(  25)													int _g54 = 0;
HXDLIN(  25)													int _g55 = i16;
HXDLIN(  25)													while((_g54 < _g55)){
HXLINE(  25)														_g54 = (_g54 + 1);
HXDLIN(  25)														int i17 = (_g54 - 1);
HXLINE( 345)														prev2 = l2;
HXLINE( 346)														l2 = l2->next;
            													}
            												}
HXLINE(  25)												if (::hx::IsNull( prev2 )) {
HXLINE(  25)													b20->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  25)													l2 = null();
            												}
            												else {
HXLINE(  25)													prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  25)													l2 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  25)							undoImage7 = b20;
            						}
            						break;
            					}
HXDLIN(  25)					this68->image = undoImage7;
HXDLIN(  25)					this68->width = width2;
HXDLIN(  25)					this68->height = height2;
HXDLIN(  25)					this68->imageType = ( (int)(imageType2) );
HXDLIN(  25)					undoImage6 = this68;
HXDLIN(  25)					{
HXLINE(  25)						int rectLeft2 = xIter32->start;
HXDLIN(  25)						int rectTop2 = yIter32->start;
HXDLIN(  25)						int rectRight2 = xIter32->max;
HXDLIN(  25)						bool forceClear2 = false;
HXDLIN(  25)						{
HXLINE(  25)							int _g56 = rectTop2;
HXDLIN(  25)							int _g57 = yIter32->max;
HXDLIN(  25)							while((_g56 < _g57)){
HXLINE(  25)								_g56 = (_g56 + 1);
HXDLIN(  25)								int dy3 = (_g56 - 1);
HXDLIN(  25)								{
HXLINE(  25)									int _g58 = rectLeft2;
HXDLIN(  25)									int _g59 = rectRight2;
HXDLIN(  25)									while((_g58 < _g59)){
HXLINE(  25)										_g58 = (_g58 + 1);
HXDLIN(  25)										int dx3 = (_g58 - 1);
HXDLIN(  25)										::Dynamic this70 = this1->image;
HXDLIN(  25)										int index10;
HXDLIN(  25)										if (this1->useVirtualPos) {
HXLINE(  25)											index10 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx3) - this1->virtualX));
            										}
            										else {
HXLINE(  25)											index10 = ::Std_obj::_hx_int(( (Float)(((dy3 * this1->width) + dx3)) ));
            										}
HXDLIN(  25)										int c12 = ::iterMagic::Iimg_obj::get(this70,index10);
HXDLIN(  25)										int col2;
HXDLIN(  25)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)											col2 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            										}
            										else {
HXLINE(  25)											col2 = c12;
            										}
HXDLIN(  25)										bool _hx_tmp6;
HXDLIN(  25)										if (this1->useMask) {
HXLINE(  25)											_hx_tmp6 = ::hx::IsNotNull( this1->mask );
            										}
            										else {
HXLINE(  25)											_hx_tmp6 = false;
            										}
HXDLIN(  25)										if (_hx_tmp6) {
HXLINE(  25)											 ::pi_xy::ImageStruct this71 = this1->mask;
HXDLIN(  25)											::Dynamic this72 = this71->image;
HXDLIN(  25)											int index11;
HXDLIN(  25)											if (this71->useVirtualPos) {
HXLINE(  25)												index11 = ::Std_obj::_hx_int(((((( (Float)(dy3) ) - this71->virtualY) * ( (Float)(this71->width) )) + dx3) - this71->virtualX));
            											}
            											else {
HXLINE(  25)												index11 = ::Std_obj::_hx_int(( (Float)(((dy3 * this71->width) + dx3)) ));
            											}
HXDLIN(  25)											int c13 = ::iterMagic::Iimg_obj::get(this72,index11);
HXDLIN(  25)											int v6;
HXDLIN(  25)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)												v6 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            											}
            											else {
HXLINE(  25)												v6 = c13;
            											}
HXDLIN(  25)											int maskPixel2 = v6;
HXDLIN(  25)											int this73 = col2;
HXDLIN(  25)											if ((maskPixel2 == 0)) {
HXLINE(  25)												col2 = this73;
            											}
            											else {
HXLINE(  25)												Float m02;
HXDLIN(  25)												int this74 = ((maskPixel2 >> 24) & 255);
HXDLIN(  25)												if ((this74 == 0)) {
HXLINE(  25)													m02 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													m02 = (( (Float)(this74) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												Float m12;
HXDLIN(  25)												int this75 = ((maskPixel2 >> 16) & 255);
HXDLIN(  25)												if ((this75 == 0)) {
HXLINE(  25)													m12 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													m12 = (( (Float)(this75) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												Float m22;
HXDLIN(  25)												int this76 = ((maskPixel2 >> 8) & 255);
HXDLIN(  25)												if ((this76 == 0)) {
HXLINE(  25)													m22 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													m22 = (( (Float)(this76) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												Float m32;
HXDLIN(  25)												int this77 = (maskPixel2 & 255);
HXDLIN(  25)												if ((this77 == 0)) {
HXLINE(  25)													m32 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													m32 = (( (Float)(this77) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												int ch02 = ::Std_obj::_hx_int(((((Float)1.) - m02) * ( (Float)(((this73 >> 24) & 255)) )));
HXDLIN(  25)												int ch12 = ::Std_obj::_hx_int(((((Float)1.) - m12) * ( (Float)(((this73 >> 16) & 255)) )));
HXDLIN(  25)												int ch22 = ::Std_obj::_hx_int(((((Float)1.) - m22) * ( (Float)(((this73 >> 8) & 255)) )));
HXDLIN(  25)												int ch32 = ::Std_obj::_hx_int(((((Float)1.) - m32) * ( (Float)((this73 & 255)) )));
HXDLIN(  25)												col2 = ((((::Math_obj::round((( (Float)(ch02) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch12) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch22) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch32) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN(  25)										if ((col2 != 0)) {
HXLINE(  25)											int x9 = (dx3 - rectLeft2);
HXDLIN(  25)											int y9 = (dy3 - rectTop2);
HXDLIN(  25)											int c14 = col2;
HXDLIN(  25)											bool _hx_tmp7;
HXDLIN(  25)											if ((((c14 >> 24) & 255) < 254)) {
HXLINE(  25)												_hx_tmp7 = undoImage6->transparent;
            											}
            											else {
HXLINE(  25)												_hx_tmp7 = false;
            											}
HXDLIN(  25)											if (_hx_tmp7) {
HXLINE(  25)												int location4;
HXDLIN(  25)												if (undoImage6->useVirtualPos) {
HXLINE(  25)													location4 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x9) - undoImage6->virtualX));
            												}
            												else {
HXLINE(  25)													location4 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage6->width) + x9)) ));
            												}
HXDLIN(  25)												int this78 = ::iterMagic::Iimg_obj::get(undoImage6->image,location4);
HXDLIN(  25)												int this79;
HXDLIN(  25)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)													this79 = ((((((this78 >> 24) & 255) << 24) | ((this78 & 255) << 16)) | (((this78 >> 8) & 255) << 8)) | ((this78 >> 16) & 255));
            												}
            												else {
HXLINE(  25)													this79 = this78;
            												}
HXDLIN(  25)												Float a18;
HXDLIN(  25)												int this80 = ((this79 >> 24) & 255);
HXDLIN(  25)												if ((this80 == 0)) {
HXLINE(  25)													a18 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													a18 = (( (Float)(this80) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												Float r14;
HXDLIN(  25)												int this81 = ((this79 >> 16) & 255);
HXDLIN(  25)												if ((this81 == 0)) {
HXLINE(  25)													r14 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													r14 = (( (Float)(this81) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												Float g14;
HXDLIN(  25)												int this82 = ((this79 >> 8) & 255);
HXDLIN(  25)												if ((this82 == 0)) {
HXLINE(  25)													g14 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													g14 = (( (Float)(this82) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												Float b110;
HXDLIN(  25)												int this83 = (this79 & 255);
HXDLIN(  25)												if ((this83 == 0)) {
HXLINE(  25)													b110 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													b110 = (( (Float)(this83) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												Float a24;
HXDLIN(  25)												int this84 = ((col2 >> 24) & 255);
HXDLIN(  25)												if ((this84 == 0)) {
HXLINE(  25)													a24 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													a24 = (( (Float)(this84) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												Float r24;
HXDLIN(  25)												int this85 = ((col2 >> 16) & 255);
HXDLIN(  25)												if ((this85 == 0)) {
HXLINE(  25)													r24 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													r24 = (( (Float)(this85) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												Float g24;
HXDLIN(  25)												int this86 = ((col2 >> 8) & 255);
HXDLIN(  25)												if ((this86 == 0)) {
HXLINE(  25)													g24 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													g24 = (( (Float)(this86) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												Float b25;
HXDLIN(  25)												int this87 = (col2 & 255);
HXDLIN(  25)												if ((this87 == 0)) {
HXLINE(  25)													b25 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													b25 = (( (Float)(this87) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												Float a34 = (a18 * (( (Float)(1) ) - a24));
HXDLIN(  25)												int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN(  25)												int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN(  25)												int b26 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a34) + (b25 * a24))));
HXDLIN(  25)												int a19 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN(  25)												int blended4 = ((((a19 << 24) | (r6 << 16)) | (g6 << 8)) | b26);
HXDLIN(  25)												{
HXLINE(  25)													int _hx_tmp8;
HXDLIN(  25)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)														_hx_tmp8 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            													}
            													else {
HXLINE(  25)														_hx_tmp8 = blended4;
            													}
HXDLIN(  25)													::iterMagic::Iimg_obj::set(undoImage6->image,location4,_hx_tmp8);
            												}
            											}
            											else {
HXLINE(  25)												::Dynamic this88 = undoImage6->image;
HXDLIN(  25)												int index12;
HXDLIN(  25)												if (undoImage6->useVirtualPos) {
HXLINE(  25)													index12 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x9) - undoImage6->virtualX));
            												}
            												else {
HXLINE(  25)													index12 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage6->width) + x9)) ));
            												}
HXDLIN(  25)												int _hx_tmp9;
HXDLIN(  25)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)													_hx_tmp9 = ((((((c14 >> 24) & 255) << 24) | ((c14 & 255) << 16)) | (((c14 >> 8) & 255) << 8)) | ((c14 >> 16) & 255));
            												}
            												else {
HXLINE(  25)													_hx_tmp9 = c14;
            												}
HXDLIN(  25)												::iterMagic::Iimg_obj::set(this88,index12,_hx_tmp9);
            											}
            										}
            										else {
HXLINE(  25)											if (forceClear2) {
HXLINE(  25)												::Dynamic this89 = undoImage6->image;
HXDLIN(  25)												int x10 = (dx3 - rectLeft2);
HXDLIN(  25)												int y10 = (dy3 - rectTop2);
HXDLIN(  25)												int index13;
HXDLIN(  25)												if (undoImage6->useVirtualPos) {
HXLINE(  25)													index13 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - undoImage6->virtualY) * ( (Float)(undoImage6->width) )) + x10) - undoImage6->virtualX));
            												}
            												else {
HXLINE(  25)													index13 = ::Std_obj::_hx_int(( (Float)(((y10 * undoImage6->width) + x10)) ));
            												}
HXDLIN(  25)												::iterMagic::Iimg_obj::set(this89,index13,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  25)				bool found2 = false;
HXDLIN(  25)				Float s2 = ((Float)0.);
HXDLIN(  25)				Float t2 = ((Float)0.);
HXDLIN(  25)				Float sxx2 = ((Float)0.);
HXDLIN(  25)				Float txx2 = ((Float)0.);
HXDLIN(  25)				{
HXLINE(  25)					int _g_min4 = xIter32->start;
HXDLIN(  25)					int _g_max4 = xIter32->max;
HXDLIN(  25)					while((_g_min4 < _g_max4)){
HXLINE(  25)						_g_min4 = (_g_min4 + 1);
HXDLIN(  25)						int x11 = (_g_min4 - 1);
HXLINE(  60)						sxx2 = (sx2 * ( (Float)(x11) ));
HXLINE(  61)						txx2 = (tx2 * ( (Float)(x11) ));
HXLINE(  62)						found2 = false;
HXLINE(  25)						{
HXLINE(  25)							int _g_min5 = yIter32->start;
HXDLIN(  25)							int _g_max5 = yIter32->max;
HXDLIN(  25)							while((_g_min5 < _g_max5)){
HXLINE(  25)								_g_min5 = (_g_min5 + 1);
HXDLIN(  25)								int y11 = (_g_min5 - 1);
HXLINE(  64)								s2 = ((s02 + sxx2) + (sy2 * ( (Float)(y11) )));
HXLINE(  65)								t2 = ((t02 + txx2) + (ty2 * ( (Float)(y11) )));
HXLINE(  25)								bool _hx_tmp10;
HXDLIN(  25)								if (!((s2 <= 0))) {
HXLINE(  25)									_hx_tmp10 = (t2 <= 0);
            								}
            								else {
HXLINE(  25)									_hx_tmp10 = true;
            								}
HXDLIN(  25)								if (_hx_tmp10) {
HXLINE(  25)									if (found2) {
HXLINE(  25)										goto _hx_goto_36;
            									}
            								}
            								else {
HXLINE(  25)									if (((s2 + t2) < A2)) {
HXLINE(  25)										{
HXLINE(  25)											int c15 = color;
HXDLIN(  25)											bool _hx_tmp11;
HXDLIN(  25)											if ((((c15 >> 24) & 255) < 254)) {
HXLINE(  25)												_hx_tmp11 = this1->transparent;
            											}
            											else {
HXLINE(  25)												_hx_tmp11 = false;
            											}
HXDLIN(  25)											if (_hx_tmp11) {
HXLINE(  25)												int location5;
HXDLIN(  25)												if (this1->useVirtualPos) {
HXLINE(  25)													location5 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - this1->virtualY) * ( (Float)(this1->width) )) + x11) - this1->virtualX));
            												}
            												else {
HXLINE(  25)													location5 = ::Std_obj::_hx_int(( (Float)(((y11 * this1->width) + x11)) ));
            												}
HXDLIN(  25)												int this90 = ::iterMagic::Iimg_obj::get(this1->image,location5);
HXDLIN(  25)												int this91;
HXDLIN(  25)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)													this91 = ((((((this90 >> 24) & 255) << 24) | ((this90 & 255) << 16)) | (((this90 >> 8) & 255) << 8)) | ((this90 >> 16) & 255));
            												}
            												else {
HXLINE(  25)													this91 = this90;
            												}
HXDLIN(  25)												Float a110;
HXDLIN(  25)												int this92 = ((this91 >> 24) & 255);
HXDLIN(  25)												if ((this92 == 0)) {
HXLINE(  25)													a110 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													a110 = (( (Float)(this92) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												Float r15;
HXDLIN(  25)												int this93 = ((this91 >> 16) & 255);
HXDLIN(  25)												if ((this93 == 0)) {
HXLINE(  25)													r15 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													r15 = (( (Float)(this93) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												Float g15;
HXDLIN(  25)												int this94 = ((this91 >> 8) & 255);
HXDLIN(  25)												if ((this94 == 0)) {
HXLINE(  25)													g15 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													g15 = (( (Float)(this94) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												Float b111;
HXDLIN(  25)												int this95 = (this91 & 255);
HXDLIN(  25)												if ((this95 == 0)) {
HXLINE(  25)													b111 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													b111 = (( (Float)(this95) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												Float a25;
HXDLIN(  25)												int this96 = ((color >> 24) & 255);
HXDLIN(  25)												if ((this96 == 0)) {
HXLINE(  25)													a25 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													a25 = (( (Float)(this96) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												Float r25;
HXDLIN(  25)												int this97 = ((color >> 16) & 255);
HXDLIN(  25)												if ((this97 == 0)) {
HXLINE(  25)													r25 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													r25 = (( (Float)(this97) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												Float g25;
HXDLIN(  25)												int this98 = ((color >> 8) & 255);
HXDLIN(  25)												if ((this98 == 0)) {
HXLINE(  25)													g25 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													g25 = (( (Float)(this98) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												Float b27;
HXDLIN(  25)												int this99 = (color & 255);
HXDLIN(  25)												if ((this99 == 0)) {
HXLINE(  25)													b27 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													b27 = (( (Float)(this99) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												Float a35 = (a110 * (( (Float)(1) ) - a25));
HXDLIN(  25)												int r7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r15 * a35) + (r25 * a25))));
HXDLIN(  25)												int g7 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g15 * a35) + (g25 * a25))));
HXDLIN(  25)												int b28 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a35) + (b27 * a25))));
HXDLIN(  25)												int a20 = ::Std_obj::_hx_int((( (Float)(255) ) * (a35 + a25)));
HXDLIN(  25)												int blended5 = ((((a20 << 24) | (r7 << 16)) | (g7 << 8)) | b28);
HXDLIN(  25)												{
HXLINE(  25)													int _hx_tmp12;
HXDLIN(  25)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)														_hx_tmp12 = ((((((blended5 >> 24) & 255) << 24) | ((blended5 & 255) << 16)) | (((blended5 >> 8) & 255) << 8)) | ((blended5 >> 16) & 255));
            													}
            													else {
HXLINE(  25)														_hx_tmp12 = blended5;
            													}
HXDLIN(  25)													::iterMagic::Iimg_obj::set(this1->image,location5,_hx_tmp12);
            												}
            											}
            											else {
HXLINE(  25)												::Dynamic this100 = this1->image;
HXDLIN(  25)												int index14;
HXDLIN(  25)												if (this1->useVirtualPos) {
HXLINE(  25)													index14 = ::Std_obj::_hx_int(((((( (Float)(y11) ) - this1->virtualY) * ( (Float)(this1->width) )) + x11) - this1->virtualX));
            												}
            												else {
HXLINE(  25)													index14 = ::Std_obj::_hx_int(( (Float)(((y11 * this1->width) + x11)) ));
            												}
HXDLIN(  25)												int _hx_tmp13;
HXDLIN(  25)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)													_hx_tmp13 = ((((((c15 >> 24) & 255) << 24) | ((c15 & 255) << 16)) | (((c15 >> 8) & 255) << 8)) | ((c15 >> 16) & 255));
            												}
            												else {
HXLINE(  25)													_hx_tmp13 = c15;
            												}
HXDLIN(  25)												::iterMagic::Iimg_obj::set(this100,index14,_hx_tmp13);
            											}
            										}
HXLINE(  73)										found2 = true;
            									}
            									else {
HXLINE(  25)										if (found2) {
HXLINE(  25)											goto _hx_goto_36;
            										}
            									}
            								}
            							}
            							_hx_goto_36:;
            						}
            					}
            				}
HXDLIN(  25)				 ::pi_xy::algo::HitTri hitTri;
HXDLIN(  25)				if ((hasHit == true)) {
HXLINE(  25)					 ::pi_xy::algo::HitTri v7 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,qx1,qy1,bx6,by6,cx6,cy6,true);
HXDLIN(  25)					if (hasUndo2) {
HXLINE(  25)						v7->undoImage = undoImage6;
HXDLIN(  25)						v7->undoX = xIter32->start;
HXDLIN(  25)						v7->undoY = yIter32->start;
            					}
HXDLIN(  25)					hitTri = v7;
            				}
            				else {
HXLINE(  25)					hitTri = null();
            				}
HXDLIN(  25)				if (hasHit) {
HXLINE(  25)					 ::pi_xy::algo::HitTriArray hitArr =  ::pi_xy::algo::HitTriArray_obj::__alloc( HX_CTX ,::Array_obj< ::Dynamic>::__new(1)->init(0,hitTri));
HXDLIN(  25)					if (::hx::IsNotNull( hitQuad )) {
HXLINE(  25)						hitArr->triArr->push(hitQuad->triABD);
            					}
HXDLIN(  25)					hitArr->triArr->push(hitQuad->triBCD);
            				}
            			}
            		}
HXLINE(  63)		return pixelImage;
            	}



::hx::ObjectPtr< ArrowShape_obj > ArrowShape_obj::__new( ::Dynamic opacity, ::Dynamic visibility, ::Dynamic strokeColor, ::Dynamic strokeWidth,::Array< ::String > strokeDashGapArray, ::Dynamic both, ::Dynamic flare, ::Dynamic reverseFlare, ::Dynamic x1, ::Dynamic y1, ::Dynamic x2, ::Dynamic y2, ::Dynamic arrowWidth, ::Dynamic arrowHeight) {
	::hx::ObjectPtr< ArrowShape_obj > __this = new ArrowShape_obj();
	__this->__construct(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,both,flare,reverseFlare,x1,y1,x2,y2,arrowWidth,arrowHeight);
	return __this;
}

::hx::ObjectPtr< ArrowShape_obj > ArrowShape_obj::__alloc(::hx::Ctx *_hx_ctx, ::Dynamic opacity, ::Dynamic visibility, ::Dynamic strokeColor, ::Dynamic strokeWidth,::Array< ::String > strokeDashGapArray, ::Dynamic both, ::Dynamic flare, ::Dynamic reverseFlare, ::Dynamic x1, ::Dynamic y1, ::Dynamic x2, ::Dynamic y2, ::Dynamic arrowWidth, ::Dynamic arrowHeight) {
	ArrowShape_obj *__this = (ArrowShape_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(ArrowShape_obj), true, "pi_xy.triangleGML.ArrowShape"));
	*(void **)__this = ArrowShape_obj::_hx_vtable;
	__this->__construct(opacity,visibility,strokeColor,strokeWidth,strokeDashGapArray,both,flare,reverseFlare,x1,y1,x2,y2,arrowWidth,arrowHeight);
	return __this;
}

ArrowShape_obj::ArrowShape_obj()
{
}

::hx::Val ArrowShape_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *ArrowShape_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *ArrowShape_obj_sStaticStorageInfo = 0;
#endif

static ::String ArrowShape_obj_sMemberFields[] = {
	HX_("render",56,6b,29,05),
	::String(null()) };

::hx::Class ArrowShape_obj::__mClass;

void ArrowShape_obj::__register()
{
	ArrowShape_obj _hx_dummy;
	ArrowShape_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pi_xy.triangleGML.ArrowShape",4f,ae,1c,34);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(ArrowShape_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< ArrowShape_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ArrowShape_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ArrowShape_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pi_xy
} // end namespace triangleGML
