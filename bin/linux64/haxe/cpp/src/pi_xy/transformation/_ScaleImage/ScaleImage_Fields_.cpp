// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericCell_Int
#include <haxe/ds/GenericCell_Int.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericStack_Int
#include <haxe/ds/GenericStack_Int.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_iterMagic_ArrIntImg
#include <iterMagic/ArrIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_BytesImg
#include <iterMagic/BytesImg.h>
#endif
#ifndef INCLUDED_iterMagic_Iimg
#include <iterMagic/Iimg.h>
#endif
#ifndef INCLUDED_iterMagic_StackIntImg
#include <iterMagic/StackIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_U32ArrImg
#include <iterMagic/U32ArrImg.h>
#endif
#ifndef INCLUDED_iterMagic_VecIntImg
#include <iterMagic/VecIntImg.h>
#endif
#ifndef INCLUDED_pi_xy_ImageStruct
#include <pi_xy/ImageStruct.h>
#endif
#ifndef INCLUDED_pi_xy__Endian_Endian_Fields_
#include <pi_xy/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitQuad
#include <pi_xy/algo/HitQuad.h>
#endif
#ifndef INCLUDED_pi_xy_algo_IhitObj
#include <pi_xy/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pi_xy_algo_QuadPoints_
#include <pi_xy/algo/QuadPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_iter_IntIterStart
#include <pi_xy/iter/IntIterStart.h>
#endif
#ifndef INCLUDED_pi_xy_transformation__ScaleImage_ScaleImage_Fields_
#include <pi_xy/transformation/_ScaleImage/ScaleImage_Fields_.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_ea4a3e2e149112ec_9_scaleUpInteger,"pi_xy.transformation._ScaleImage.ScaleImage_Fields_","scaleUpInteger",0xef4de213,"pi_xy.transformation._ScaleImage.ScaleImage_Fields_.scaleUpInteger","pi_xy/transformation/ScaleImage.hx",9,0xd5af684f)
HX_LOCAL_STACK_FRAME(_hx_pos_ea4a3e2e149112ec_38_scalingXY,"pi_xy.transformation._ScaleImage.ScaleImage_Fields_","scalingXY",0xf26477ee,"pi_xy.transformation._ScaleImage.ScaleImage_Fields_.scalingXY","pi_xy/transformation/ScaleImage.hx",38,0xd5af684f)
namespace pi_xy{
namespace transformation{
namespace _ScaleImage{

void ScaleImage_Fields__obj::__construct() { }

Dynamic ScaleImage_Fields__obj::__CreateEmpty() { return new ScaleImage_Fields__obj; }

void *ScaleImage_Fields__obj::_hx_vtable = 0;

Dynamic ScaleImage_Fields__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< ScaleImage_Fields__obj > _hx_result = new ScaleImage_Fields__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool ScaleImage_Fields__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x0be548a0;
}

 ::pi_xy::ImageStruct ScaleImage_Fields__obj::scaleUpInteger( ::pi_xy::ImageStruct thisImage,::hx::Null< int >  __o_scaleW,::hx::Null< int >  __o_scaleH,::hx::Null< bool >  __o_transparent,::hx::Null< bool >  __o_includeMask){
            		int scaleW = __o_scaleW.Default(2);
            		int scaleH = __o_scaleH.Default(2);
            		bool transparent = __o_transparent.Default(false);
            		bool includeMask = __o_includeMask.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_ea4a3e2e149112ec_9_scaleUpInteger)
HXLINE(  10)		int p = 0;
HXLINE(  11)		int xx = p;
HXLINE(  12)		int q = 0;
HXLINE(  13)		int wNew = ::Std_obj::_hx_int(( (Float)((thisImage->width * scaleW)) ));
HXLINE(  14)		int hNew = ::Std_obj::_hx_int(( (Float)((thisImage->height * scaleH)) ));
HXLINE(  15)		 ::Dynamic imageType = null();
HXDLIN(  15)		 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  15)		if (::hx::IsNull( imageType )) {
HXLINE(  15)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXDLIN(  15)		::Dynamic _hx_tmp;
HXDLIN(  15)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE(  15)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  15)				 ::iterMagic::BytesImg b = byt;
HXDLIN(  15)				{
HXLINE(  15)					b->width = wNew;
HXDLIN(  15)					b->height = hNew;
HXDLIN(  15)					b->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN(  15)					b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  15)					{
HXLINE(  15)						int len = b->length;
HXDLIN(  15)						int w = 0;
HXDLIN(  15)						{
HXLINE(  15)							int _g = 0;
HXDLIN(  15)							int _g1 = b->height;
HXDLIN(  15)							while((_g < _g1)){
HXLINE(  15)								_g = (_g + 1);
HXDLIN(  15)								int y = (_g - 1);
HXDLIN(  15)								{
HXLINE(  15)									int _g2 = 0;
HXDLIN(  15)									int _g3 = b->width;
HXDLIN(  15)									while((_g2 < _g3)){
HXLINE(  15)										_g2 = (_g2 + 1);
HXDLIN(  15)										int x = (_g2 - 1);
HXDLIN(  15)										{
HXLINE(  15)											w = (w + 1);
HXDLIN(  15)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  15)										{
HXLINE(  15)											w = (w + 1);
HXDLIN(  15)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  15)										{
HXLINE(  15)											w = (w + 1);
HXDLIN(  15)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(  15)										{
HXLINE(  15)											w = (w + 1);
HXDLIN(  15)											b->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  15)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXLINE(  15)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  15)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  15)				{
HXLINE(  15)					a->width = wNew;
HXDLIN(  15)					a->height = hNew;
HXDLIN(  15)					a->data = ::Array_obj< int >::__new(0);
HXDLIN(  15)					a->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN(  15)					{
HXLINE(  15)						int _g4 = 0;
HXDLIN(  15)						int _g5 = a->length;
HXDLIN(  15)						while((_g4 < _g5)){
HXLINE(  15)							_g4 = (_g4 + 1);
HXDLIN(  15)							int i = (_g4 - 1);
HXDLIN(  15)							a->data[i] = 0;
            						}
            					}
            				}
HXDLIN(  15)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXLINE(  15)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  15)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  15)				{
HXLINE(  15)					b1->width = wNew;
HXDLIN(  15)					b1->height = hNew;
HXDLIN(  15)					b1->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN(  15)					int size = (b1->length * 4);
HXDLIN(  15)					b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  15)					{
HXLINE(  15)						int _g6 = 0;
HXDLIN(  15)						int _g7 = b1->length;
HXDLIN(  15)						while((_g6 < _g7)){
HXLINE(  15)							_g6 = (_g6 + 1);
HXDLIN(  15)							int i1 = (_g6 - 1);
HXDLIN(  15)							{
HXLINE(  15)								 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN(  15)								bool _hx_tmp1;
HXDLIN(  15)								if ((i1 >= 0)) {
HXLINE(  15)									_hx_tmp1 = (i1 < (this2->byteLength >> 2));
            								}
            								else {
HXLINE(  15)									_hx_tmp1 = false;
            								}
HXDLIN(  15)								if (_hx_tmp1) {
HXLINE(  15)									 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  15)									int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN(  15)									_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  15)									_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  15)									_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  15)									_this->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(  15)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXLINE(  15)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  15)				 ::iterMagic::VecIntImg v = vec;
HXDLIN(  15)				{
HXLINE(  15)					v->width = wNew;
HXDLIN(  15)					v->height = hNew;
HXDLIN(  15)					v->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN(  15)					v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  15)					{
HXLINE(  15)						int _g8 = 0;
HXDLIN(  15)						int _g9 = v->length;
HXDLIN(  15)						while((_g8 < _g9)){
HXLINE(  15)							_g8 = (_g8 + 1);
HXDLIN(  15)							int i2 = (_g8 - 1);
HXDLIN(  15)							v->data->__unsafe_set(i2,0);
            						}
            					}
            				}
HXDLIN(  15)				_hx_tmp = v;
            			}
            			break;
            			case (int)4: {
HXLINE(  15)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  15)				 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  15)				{
HXLINE(  15)					b2->width = wNew;
HXDLIN(  15)					b2->height = hNew;
HXDLIN(  15)					b2->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN(  15)					b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  15)					{
HXLINE(  15)						int len1 = b2->length;
HXDLIN(  15)						 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  15)						if (::hx::IsNull( d->head )) {
HXLINE(  15)							int _g10 = 0;
HXDLIN(  15)							int _g11 = len1;
HXDLIN(  15)							while((_g10 < _g11)){
HXLINE(  15)								_g10 = (_g10 + 1);
HXDLIN(  15)								int i3 = (_g10 - 1);
HXDLIN(  15)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE(  15)							int _g12 = 0;
HXDLIN(  15)							int _g13 = len1;
HXDLIN(  15)							while((_g12 < _g13)){
HXLINE(  15)								_g12 = (_g12 + 1);
HXDLIN(  15)								int i4 = (_g12 - 1);
HXDLIN(  15)								{
HXLINE(  15)									 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  15)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  15)									{
HXLINE(  15)										int _g14 = 0;
HXDLIN(  15)										int _g15 = i4;
HXDLIN(  15)										while((_g14 < _g15)){
HXLINE(  15)											_g14 = (_g14 + 1);
HXDLIN(  15)											int i5 = (_g14 - 1);
HXDLIN(  15)											prev = l;
HXDLIN(  15)											l = l->next;
            										}
            									}
HXDLIN(  15)									if (::hx::IsNull( prev )) {
HXLINE(  15)										b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  15)										l = null();
            									}
            									else {
HXLINE(  15)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  15)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  15)				_hx_tmp = b2;
            			}
            			break;
            		}
HXDLIN(  15)		this1->image = _hx_tmp;
HXDLIN(  15)		this1->width = wNew;
HXDLIN(  15)		this1->height = hNew;
HXDLIN(  15)		this1->imageType = ( (int)(imageType) );
HXDLIN(  15)		 ::pi_xy::ImageStruct nextImage = this1;
HXLINE(  16)		int maxX = wNew;
HXLINE(  17)		int maxY = hNew;
HXLINE(  18)		do {
HXLINE(  19)			int x1 = ::Std_obj::_hx_int((( (Float)(p) ) / ( (Float)(scaleW) )));
HXDLIN(  19)			int y1 = ::Std_obj::_hx_int((( (Float)(q) ) / ( (Float)(scaleH) )));
HXDLIN(  19)			::Dynamic this3 = thisImage->image;
HXDLIN(  19)			int index;
HXDLIN(  19)			if (thisImage->useVirtualPos) {
HXLINE(  19)				index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - thisImage->virtualY) * ( (Float)(thisImage->width) )) + x1) - thisImage->virtualX));
            			}
            			else {
HXLINE(  19)				index = ::Std_obj::_hx_int(( (Float)(((y1 * thisImage->width) + x1)) ));
            			}
HXDLIN(  19)			int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN(  19)			int color;
HXDLIN(  19)			if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  19)				color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            			}
            			else {
HXLINE(  19)				color = c;
            			}
HXLINE(  20)			{
HXLINE(  20)				p = (p + 1);
HXDLIN(  20)				int x2 = (p - 1);
HXDLIN(  20)				int c1 = color;
HXDLIN(  20)				bool _hx_tmp2;
HXDLIN(  20)				if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  20)					_hx_tmp2 = nextImage->transparent;
            				}
            				else {
HXLINE(  20)					_hx_tmp2 = false;
            				}
HXDLIN(  20)				if (_hx_tmp2) {
HXLINE(  20)					int location;
HXDLIN(  20)					if (nextImage->useVirtualPos) {
HXLINE(  20)						location = ::Std_obj::_hx_int(((((( (Float)(q) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x2) - nextImage->virtualX));
            					}
            					else {
HXLINE(  20)						location = ::Std_obj::_hx_int(( (Float)(((q * nextImage->width) + x2)) ));
            					}
HXDLIN(  20)					int this4 = ::iterMagic::Iimg_obj::get(nextImage->image,location);
HXDLIN(  20)					int this5;
HXDLIN(  20)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  20)						this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            					}
            					else {
HXLINE(  20)						this5 = this4;
            					}
HXDLIN(  20)					Float a1;
HXDLIN(  20)					int this6 = ((this5 >> 24) & 255);
HXDLIN(  20)					if ((this6 == 0)) {
HXLINE(  20)						a1 = ((Float)0.);
            					}
            					else {
HXLINE(  20)						a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            					}
HXDLIN(  20)					Float r1;
HXDLIN(  20)					int this7 = ((this5 >> 16) & 255);
HXDLIN(  20)					if ((this7 == 0)) {
HXLINE(  20)						r1 = ((Float)0.);
            					}
            					else {
HXLINE(  20)						r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            					}
HXDLIN(  20)					Float g1;
HXDLIN(  20)					int this8 = ((this5 >> 8) & 255);
HXDLIN(  20)					if ((this8 == 0)) {
HXLINE(  20)						g1 = ((Float)0.);
            					}
            					else {
HXLINE(  20)						g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            					}
HXDLIN(  20)					Float b11;
HXDLIN(  20)					int this9 = (this5 & 255);
HXDLIN(  20)					if ((this9 == 0)) {
HXLINE(  20)						b11 = ((Float)0.);
            					}
            					else {
HXLINE(  20)						b11 = (( (Float)(this9) ) / ( (Float)(255) ));
            					}
HXDLIN(  20)					Float a2;
HXDLIN(  20)					int this10 = ((color >> 24) & 255);
HXDLIN(  20)					if ((this10 == 0)) {
HXLINE(  20)						a2 = ((Float)0.);
            					}
            					else {
HXLINE(  20)						a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            					}
HXDLIN(  20)					Float r2;
HXDLIN(  20)					int this11 = ((color >> 16) & 255);
HXDLIN(  20)					if ((this11 == 0)) {
HXLINE(  20)						r2 = ((Float)0.);
            					}
            					else {
HXLINE(  20)						r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            					}
HXDLIN(  20)					Float g2;
HXDLIN(  20)					int this12 = ((color >> 8) & 255);
HXDLIN(  20)					if ((this12 == 0)) {
HXLINE(  20)						g2 = ((Float)0.);
            					}
            					else {
HXLINE(  20)						g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            					}
HXDLIN(  20)					Float b21;
HXDLIN(  20)					int this13 = (color & 255);
HXDLIN(  20)					if ((this13 == 0)) {
HXLINE(  20)						b21 = ((Float)0.);
            					}
            					else {
HXLINE(  20)						b21 = (( (Float)(this13) ) / ( (Float)(255) ));
            					}
HXDLIN(  20)					Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  20)					int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  20)					int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  20)					int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  20)					int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  20)					int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  20)					{
HXLINE(  20)						int _hx_tmp3;
HXDLIN(  20)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  20)							_hx_tmp3 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            						}
            						else {
HXLINE(  20)							_hx_tmp3 = blended;
            						}
HXDLIN(  20)						::iterMagic::Iimg_obj::set(nextImage->image,location,_hx_tmp3);
            					}
            				}
            				else {
HXLINE(  20)					::Dynamic this14 = nextImage->image;
HXDLIN(  20)					int index1;
HXDLIN(  20)					if (nextImage->useVirtualPos) {
HXLINE(  20)						index1 = ::Std_obj::_hx_int(((((( (Float)(q) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x2) - nextImage->virtualX));
            					}
            					else {
HXLINE(  20)						index1 = ::Std_obj::_hx_int(( (Float)(((q * nextImage->width) + x2)) ));
            					}
HXDLIN(  20)					int _hx_tmp4;
HXDLIN(  20)					if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  20)						_hx_tmp4 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            					}
            					else {
HXLINE(  20)						_hx_tmp4 = c1;
            					}
HXDLIN(  20)					::iterMagic::Iimg_obj::set(this14,index1,_hx_tmp4);
            				}
            			}
HXLINE(  21)			if ((p > maxX)) {
HXLINE(  22)				p = xx;
HXLINE(  23)				q = (q + 1);
            			}
            		} while((q <= maxY));
;
HXLINE(  27)		bool _hx_tmp5;
HXDLIN(  27)		if (::hx::IsNotNull( thisImage->mask )) {
HXLINE(  27)			_hx_tmp5 = includeMask;
            		}
            		else {
HXLINE(  27)			_hx_tmp5 = false;
            		}
HXDLIN(  27)		if (_hx_tmp5) {
HXLINE(  28)			 ::pi_xy::ImageStruct v1 = ::pi_xy::transformation::_ScaleImage::ScaleImage_Fields__obj::scaleUpInteger(thisImage->mask,scaleW,scaleH,thisImage->mask->transparent,includeMask);
HXDLIN(  28)			nextImage->useMask = true;
HXDLIN(  28)			nextImage->mask = v1;
            		}
HXLINE(  30)		return nextImage;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(ScaleImage_Fields__obj,scaleUpInteger,return )

 ::pi_xy::ImageStruct ScaleImage_Fields__obj::scalingXY( ::pi_xy::ImageStruct thisImage,Float sx,Float sy,::hx::Null< bool >  __o_transparent,::hx::Null< bool >  __o_includeMask){
            		bool transparent = __o_transparent.Default(false);
            		bool includeMask = __o_includeMask.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_ea4a3e2e149112ec_38_scalingXY)
HXLINE(  39)		int scaleW = ::Std_obj::_hx_int(sx);
HXLINE(  40)		int scaleH = ::Std_obj::_hx_int(sy);
HXLINE(  41)		bool ifScaleUpInt;
HXDLIN(  41)		bool ifScaleUpInt1;
HXDLIN(  41)		bool ifScaleUpInt2;
HXDLIN(  41)		if ((scaleW == sx)) {
HXLINE(  41)			ifScaleUpInt2 = (sx > ((Float)0.));
            		}
            		else {
HXLINE(  41)			ifScaleUpInt2 = false;
            		}
HXDLIN(  41)		if (ifScaleUpInt2) {
HXLINE(  41)			ifScaleUpInt1 = (scaleH == sy);
            		}
            		else {
HXLINE(  41)			ifScaleUpInt1 = false;
            		}
HXDLIN(  41)		if (ifScaleUpInt1) {
HXLINE(  41)			ifScaleUpInt = (sy > ((Float)0.));
            		}
            		else {
HXLINE(  41)			ifScaleUpInt = false;
            		}
HXLINE(  42)		if (ifScaleUpInt) {
HXLINE(  43)			bool includeMask1 = false;
HXDLIN(  43)			 ::pi_xy::ImageStruct thisImage1 = thisImage;
HXDLIN(  43)			int p = 0;
HXDLIN(  43)			int xx = p;
HXDLIN(  43)			int q = 0;
HXDLIN(  43)			int wNew = ::Std_obj::_hx_int(( (Float)((thisImage1->width * scaleW)) ));
HXDLIN(  43)			int hNew = ::Std_obj::_hx_int(( (Float)((thisImage1->height * scaleH)) ));
HXDLIN(  43)			 ::Dynamic imageType = null();
HXDLIN(  43)			 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  43)			if (::hx::IsNull( imageType )) {
HXLINE(  54)				imageType = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE(  43)			::Dynamic _hx_tmp;
HXDLIN(  43)			switch((int)(( (int)(imageType) ))){
            				case (int)0: {
HXLINE(  43)					 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  43)					 ::iterMagic::BytesImg b = byt;
HXDLIN(  43)					{
HXLINE(  43)						b->width = wNew;
HXDLIN(  43)						b->height = hNew;
HXDLIN(  43)						b->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN(  43)						b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  43)						{
HXLINE(  43)							int len = b->length;
HXDLIN(  43)							int w = 0;
HXDLIN(  43)							{
HXLINE(  43)								int _g = 0;
HXDLIN(  43)								int _g1 = b->height;
HXDLIN(  43)								while((_g < _g1)){
HXLINE(  43)									_g = (_g + 1);
HXDLIN(  43)									int y = (_g - 1);
HXDLIN(  43)									{
HXLINE(  43)										int _g2 = 0;
HXDLIN(  43)										int _g3 = b->width;
HXDLIN(  43)										while((_g2 < _g3)){
HXLINE(  43)											_g2 = (_g2 + 1);
HXDLIN(  43)											int x = (_g2 - 1);
HXDLIN(  43)											{
HXLINE(  43)												w = (w + 1);
HXDLIN(  43)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  43)											{
HXLINE(  43)												w = (w + 1);
HXDLIN(  43)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  43)											{
HXLINE(  43)												w = (w + 1);
HXDLIN(  43)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  43)											{
HXLINE(  43)												w = (w + 1);
HXDLIN(  43)												b->data->b[(w - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  43)					_hx_tmp = b;
            				}
            				break;
            				case (int)1: {
HXLINE(  43)					 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  43)					 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  43)					{
HXLINE(  43)						a->width = wNew;
HXDLIN(  43)						a->height = hNew;
HXDLIN(  43)						a->data = ::Array_obj< int >::__new(0);
HXDLIN(  43)						a->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN(  43)						{
HXLINE(  43)							int _g4 = 0;
HXDLIN(  43)							int _g5 = a->length;
HXDLIN(  43)							while((_g4 < _g5)){
HXLINE(  43)								_g4 = (_g4 + 1);
HXDLIN(  43)								int i = (_g4 - 1);
HXDLIN(  43)								a->data[i] = 0;
            							}
            						}
            					}
HXDLIN(  43)					_hx_tmp = a;
            				}
            				break;
            				case (int)2: {
HXLINE(  43)					 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  43)					 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  43)					{
HXLINE(  43)						b1->width = wNew;
HXDLIN(  43)						b1->height = hNew;
HXDLIN(  43)						b1->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN(  43)						int size = (b1->length * 4);
HXDLIN(  43)						b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  43)						{
HXLINE(  43)							int _g6 = 0;
HXDLIN(  43)							int _g7 = b1->length;
HXDLIN(  43)							while((_g6 < _g7)){
HXLINE(  43)								_g6 = (_g6 + 1);
HXDLIN(  43)								int i1 = (_g6 - 1);
HXDLIN(  43)								{
HXLINE(  43)									 ::haxe::io::ArrayBufferViewImpl this2 = b1->data;
HXDLIN(  43)									bool _hx_tmp1;
HXDLIN(  43)									if ((i1 >= 0)) {
HXLINE(  43)										_hx_tmp1 = (i1 < (this2->byteLength >> 2));
            									}
            									else {
HXLINE(  43)										_hx_tmp1 = false;
            									}
HXDLIN(  43)									if (_hx_tmp1) {
HXLINE(  43)										 ::haxe::io::Bytes _this = this2->bytes;
HXDLIN(  43)										int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN(  43)										_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  43)										_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  43)										_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  43)										_this->b[(pos + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN(  43)					_hx_tmp = b1;
            				}
            				break;
            				case (int)3: {
HXLINE(  43)					 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  43)					 ::iterMagic::VecIntImg v = vec;
HXDLIN(  43)					{
HXLINE(  43)						v->width = wNew;
HXDLIN(  43)						v->height = hNew;
HXDLIN(  43)						v->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN(  43)						v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  43)						{
HXLINE(  43)							int _g8 = 0;
HXDLIN(  43)							int _g9 = v->length;
HXDLIN(  43)							while((_g8 < _g9)){
HXLINE(  43)								_g8 = (_g8 + 1);
HXDLIN(  43)								int i2 = (_g8 - 1);
HXDLIN(  43)								v->data->__unsafe_set(i2,0);
            							}
            						}
            					}
HXDLIN(  43)					_hx_tmp = v;
            				}
            				break;
            				case (int)4: {
HXLINE(  43)					 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  43)					 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  43)					{
HXLINE(  43)						b2->width = wNew;
HXDLIN(  43)						b2->height = hNew;
HXDLIN(  43)						b2->length = ::Std_obj::_hx_int(( (Float)((wNew * hNew)) ));
HXDLIN(  43)						b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  43)						{
HXLINE(  43)							int len1 = b2->length;
HXDLIN(  43)							 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  43)							if (::hx::IsNull( d->head )) {
HXLINE(  43)								int _g10 = 0;
HXDLIN(  43)								int _g11 = len1;
HXDLIN(  43)								while((_g10 < _g11)){
HXLINE(  43)									_g10 = (_g10 + 1);
HXDLIN(  43)									int i3 = (_g10 - 1);
HXDLIN(  43)									d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            								}
            							}
            							else {
HXLINE(  43)								int _g12 = 0;
HXDLIN(  43)								int _g13 = len1;
HXDLIN(  43)								while((_g12 < _g13)){
HXLINE(  43)									_g12 = (_g12 + 1);
HXDLIN(  43)									int i4 = (_g12 - 1);
HXDLIN(  43)									{
HXLINE(  43)										 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  43)										 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  43)										{
HXLINE(  43)											int _g14 = 0;
HXDLIN(  43)											int _g15 = i4;
HXDLIN(  43)											while((_g14 < _g15)){
HXLINE(  43)												_g14 = (_g14 + 1);
HXDLIN(  43)												int i5 = (_g14 - 1);
HXLINE( 345)												prev = l;
HXLINE( 346)												l = l->next;
            											}
            										}
HXLINE(  43)										if (::hx::IsNull( prev )) {
HXLINE(  43)											b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  43)											l = null();
            										}
            										else {
HXLINE(  43)											prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  43)											l = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  43)					_hx_tmp = b2;
            				}
            				break;
            			}
HXDLIN(  43)			this1->image = _hx_tmp;
HXDLIN(  43)			this1->width = wNew;
HXDLIN(  43)			this1->height = hNew;
HXDLIN(  43)			this1->imageType = ( (int)(imageType) );
HXDLIN(  43)			 ::pi_xy::ImageStruct nextImage = this1;
HXDLIN(  43)			int maxX = wNew;
HXDLIN(  43)			int maxY = hNew;
HXDLIN(  43)			do {
HXLINE(  43)				int x1 = ::Std_obj::_hx_int((( (Float)(p) ) / ( (Float)(scaleW) )));
HXDLIN(  43)				int y1 = ::Std_obj::_hx_int((( (Float)(q) ) / ( (Float)(scaleH) )));
HXDLIN(  43)				::Dynamic this3 = thisImage1->image;
HXDLIN(  43)				int index;
HXDLIN(  43)				if (thisImage1->useVirtualPos) {
HXLINE(  43)					index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - thisImage1->virtualY) * ( (Float)(thisImage1->width) )) + x1) - thisImage1->virtualX));
            				}
            				else {
HXLINE(  43)					index = ::Std_obj::_hx_int(( (Float)(((y1 * thisImage1->width) + x1)) ));
            				}
HXDLIN(  43)				int c = ::iterMagic::Iimg_obj::get(this3,index);
HXDLIN(  43)				int color;
HXDLIN(  43)				if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  43)					color = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            				}
            				else {
HXLINE(  43)					color = c;
            				}
HXDLIN(  43)				{
HXLINE(  43)					p = (p + 1);
HXDLIN(  43)					int x2 = (p - 1);
HXDLIN(  43)					int c1 = color;
HXDLIN(  43)					bool _hx_tmp2;
HXDLIN(  43)					if ((((c1 >> 24) & 255) < 254)) {
HXLINE(  43)						_hx_tmp2 = nextImage->transparent;
            					}
            					else {
HXLINE(  43)						_hx_tmp2 = false;
            					}
HXDLIN(  43)					if (_hx_tmp2) {
HXLINE(  43)						int location;
HXDLIN(  43)						if (nextImage->useVirtualPos) {
HXLINE(  43)							location = ::Std_obj::_hx_int(((((( (Float)(q) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x2) - nextImage->virtualX));
            						}
            						else {
HXLINE(  43)							location = ::Std_obj::_hx_int(( (Float)(((q * nextImage->width) + x2)) ));
            						}
HXDLIN(  43)						int this4 = ::iterMagic::Iimg_obj::get(nextImage->image,location);
HXDLIN(  43)						int this5;
HXDLIN(  43)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  43)							this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            						}
            						else {
HXLINE(  43)							this5 = this4;
            						}
HXDLIN(  43)						Float a1;
HXDLIN(  43)						int this6 = ((this5 >> 24) & 255);
HXDLIN(  43)						if ((this6 == 0)) {
HXLINE(  43)							a1 = ((Float)0.);
            						}
            						else {
HXLINE(  43)							a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            						}
HXDLIN(  43)						Float r1;
HXDLIN(  43)						int this7 = ((this5 >> 16) & 255);
HXDLIN(  43)						if ((this7 == 0)) {
HXLINE(  43)							r1 = ((Float)0.);
            						}
            						else {
HXLINE(  43)							r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            						}
HXDLIN(  43)						Float g1;
HXDLIN(  43)						int this8 = ((this5 >> 8) & 255);
HXDLIN(  43)						if ((this8 == 0)) {
HXLINE(  43)							g1 = ((Float)0.);
            						}
            						else {
HXLINE(  43)							g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            						}
HXDLIN(  43)						Float b11;
HXDLIN(  43)						int this9 = (this5 & 255);
HXDLIN(  43)						if ((this9 == 0)) {
HXLINE(  43)							b11 = ((Float)0.);
            						}
            						else {
HXLINE(  43)							b11 = (( (Float)(this9) ) / ( (Float)(255) ));
            						}
HXDLIN(  43)						Float a2;
HXDLIN(  43)						int this10 = ((color >> 24) & 255);
HXDLIN(  43)						if ((this10 == 0)) {
HXLINE(  43)							a2 = ((Float)0.);
            						}
            						else {
HXLINE(  43)							a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            						}
HXDLIN(  43)						Float r2;
HXDLIN(  43)						int this11 = ((color >> 16) & 255);
HXDLIN(  43)						if ((this11 == 0)) {
HXLINE(  43)							r2 = ((Float)0.);
            						}
            						else {
HXLINE(  43)							r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            						}
HXDLIN(  43)						Float g2;
HXDLIN(  43)						int this12 = ((color >> 8) & 255);
HXDLIN(  43)						if ((this12 == 0)) {
HXLINE(  43)							g2 = ((Float)0.);
            						}
            						else {
HXLINE(  43)							g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            						}
HXDLIN(  43)						Float b21;
HXDLIN(  43)						int this13 = (color & 255);
HXDLIN(  43)						if ((this13 == 0)) {
HXLINE(  43)							b21 = ((Float)0.);
            						}
            						else {
HXLINE(  43)							b21 = (( (Float)(this13) ) / ( (Float)(255) ));
            						}
HXDLIN(  43)						Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  43)						int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  43)						int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  43)						int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  43)						int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  43)						int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  43)						{
HXLINE(  43)							int _hx_tmp3;
HXDLIN(  43)							if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  43)								_hx_tmp3 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            							}
            							else {
HXLINE(  43)								_hx_tmp3 = blended;
            							}
HXDLIN(  43)							::iterMagic::Iimg_obj::set(nextImage->image,location,_hx_tmp3);
            						}
            					}
            					else {
HXLINE(  43)						::Dynamic this14 = nextImage->image;
HXDLIN(  43)						int index1;
HXDLIN(  43)						if (nextImage->useVirtualPos) {
HXLINE(  43)							index1 = ::Std_obj::_hx_int(((((( (Float)(q) ) - nextImage->virtualY) * ( (Float)(nextImage->width) )) + x2) - nextImage->virtualX));
            						}
            						else {
HXLINE(  43)							index1 = ::Std_obj::_hx_int(( (Float)(((q * nextImage->width) + x2)) ));
            						}
HXDLIN(  43)						int _hx_tmp4;
HXDLIN(  43)						if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  43)							_hx_tmp4 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            						}
            						else {
HXLINE(  43)							_hx_tmp4 = c1;
            						}
HXDLIN(  43)						::iterMagic::Iimg_obj::set(this14,index1,_hx_tmp4);
            					}
            				}
HXDLIN(  43)				if ((p > maxX)) {
HXLINE(  22)					p = xx;
HXLINE(  43)					q = (q + 1);
            				}
            			} while((q <= maxY));
;
HXDLIN(  43)			bool _hx_tmp5;
HXDLIN(  43)			if (::hx::IsNotNull( thisImage1->mask )) {
HXLINE(  43)				_hx_tmp5 = includeMask1;
            			}
            			else {
HXLINE(  43)				_hx_tmp5 = false;
            			}
HXDLIN(  43)			if (_hx_tmp5) {
HXLINE(  43)				 ::pi_xy::ImageStruct v1 = ::pi_xy::transformation::_ScaleImage::ScaleImage_Fields__obj::scaleUpInteger(thisImage1->mask,scaleW,scaleH,thisImage1->mask->transparent,includeMask1);
HXDLIN(  43)				nextImage->useMask = true;
HXDLIN(  43)				nextImage->mask = v1;
            			}
HXDLIN(  43)			return nextImage;
            		}
            		else {
HXLINE(  45)			Float w1 = (( (Float)(thisImage->width) ) * sx);
HXLINE(  46)			Float h = (( (Float)(thisImage->height) ) * sy);
HXLINE(  47)			int wid = ::Math_obj::ceil(w1);
HXLINE(  48)			int hi = ::Math_obj::ceil(h);
HXLINE(  49)			 ::Dynamic imageType1 = null();
HXDLIN(  49)			 ::pi_xy::ImageStruct this15 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  49)			if (::hx::IsNull( imageType1 )) {
HXLINE(  54)				imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            			}
HXLINE(  49)			::Dynamic _hx_tmp6;
HXDLIN(  49)			switch((int)(( (int)(imageType1) ))){
            				case (int)0: {
HXLINE(  49)					 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  49)					 ::iterMagic::BytesImg b4 = byt1;
HXDLIN(  49)					{
HXLINE(  49)						b4->width = wid;
HXDLIN(  49)						b4->height = hi;
HXDLIN(  49)						b4->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  49)						b4->data = ::haxe::io::Bytes_obj::alloc((b4->length * 4));
HXDLIN(  49)						{
HXLINE(  49)							int len2 = b4->length;
HXDLIN(  49)							int w2 = 0;
HXDLIN(  49)							{
HXLINE(  49)								int _g16 = 0;
HXDLIN(  49)								int _g17 = b4->height;
HXDLIN(  49)								while((_g16 < _g17)){
HXLINE(  49)									_g16 = (_g16 + 1);
HXDLIN(  49)									int y2 = (_g16 - 1);
HXDLIN(  49)									{
HXLINE(  49)										int _g18 = 0;
HXDLIN(  49)										int _g19 = b4->width;
HXDLIN(  49)										while((_g18 < _g19)){
HXLINE(  49)											_g18 = (_g18 + 1);
HXDLIN(  49)											int x3 = (_g18 - 1);
HXDLIN(  49)											{
HXLINE(  49)												w2 = (w2 + 1);
HXDLIN(  49)												b4->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  49)											{
HXLINE(  49)												w2 = (w2 + 1);
HXDLIN(  49)												b4->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  49)											{
HXLINE(  49)												w2 = (w2 + 1);
HXDLIN(  49)												b4->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            											}
HXDLIN(  49)											{
HXLINE(  49)												w2 = (w2 + 1);
HXDLIN(  49)												b4->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  49)					_hx_tmp6 = b4;
            				}
            				break;
            				case (int)1: {
HXLINE(  49)					 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  49)					 ::iterMagic::ArrIntImg a5 = arrI1;
HXDLIN(  49)					{
HXLINE(  49)						a5->width = wid;
HXDLIN(  49)						a5->height = hi;
HXDLIN(  49)						a5->data = ::Array_obj< int >::__new(0);
HXDLIN(  49)						a5->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  49)						{
HXLINE(  49)							int _g20 = 0;
HXDLIN(  49)							int _g21 = a5->length;
HXDLIN(  49)							while((_g20 < _g21)){
HXLINE(  49)								_g20 = (_g20 + 1);
HXDLIN(  49)								int i6 = (_g20 - 1);
HXDLIN(  49)								a5->data[i6] = 0;
            							}
            						}
            					}
HXDLIN(  49)					_hx_tmp6 = a5;
            				}
            				break;
            				case (int)2: {
HXLINE(  49)					 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  49)					 ::iterMagic::U32ArrImg b5 = u32a1;
HXDLIN(  49)					{
HXLINE(  49)						b5->width = wid;
HXDLIN(  49)						b5->height = hi;
HXDLIN(  49)						b5->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  49)						int size1 = (b5->length * 4);
HXDLIN(  49)						b5->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  49)						{
HXLINE(  49)							int _g22 = 0;
HXDLIN(  49)							int _g23 = b5->length;
HXDLIN(  49)							while((_g22 < _g23)){
HXLINE(  49)								_g22 = (_g22 + 1);
HXDLIN(  49)								int i7 = (_g22 - 1);
HXDLIN(  49)								{
HXLINE(  49)									 ::haxe::io::ArrayBufferViewImpl this16 = b5->data;
HXDLIN(  49)									bool _hx_tmp7;
HXDLIN(  49)									if ((i7 >= 0)) {
HXLINE(  49)										_hx_tmp7 = (i7 < (this16->byteLength >> 2));
            									}
            									else {
HXLINE(  49)										_hx_tmp7 = false;
            									}
HXDLIN(  49)									if (_hx_tmp7) {
HXLINE(  49)										 ::haxe::io::Bytes _this1 = this16->bytes;
HXDLIN(  49)										int pos1 = ((i7 << 2) + this16->byteOffset);
HXDLIN(  49)										_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  49)										_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  49)										_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  49)										_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            									}
            								}
            							}
            						}
            					}
HXDLIN(  49)					_hx_tmp6 = b5;
            				}
            				break;
            				case (int)3: {
HXLINE(  49)					 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  49)					 ::iterMagic::VecIntImg v2 = vec1;
HXDLIN(  49)					{
HXLINE(  49)						v2->width = wid;
HXDLIN(  49)						v2->height = hi;
HXDLIN(  49)						v2->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  49)						v2->data = ::Array_obj< int >::__new(v2->length);
HXDLIN(  49)						{
HXLINE(  49)							int _g24 = 0;
HXDLIN(  49)							int _g25 = v2->length;
HXDLIN(  49)							while((_g24 < _g25)){
HXLINE(  49)								_g24 = (_g24 + 1);
HXDLIN(  49)								int i8 = (_g24 - 1);
HXDLIN(  49)								v2->data->__unsafe_set(i8,0);
            							}
            						}
            					}
HXDLIN(  49)					_hx_tmp6 = v2;
            				}
            				break;
            				case (int)4: {
HXLINE(  49)					 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  49)					 ::iterMagic::StackIntImg b6 = sInt1;
HXDLIN(  49)					{
HXLINE(  49)						b6->width = wid;
HXDLIN(  49)						b6->height = hi;
HXDLIN(  49)						b6->length = ::Std_obj::_hx_int(( (Float)((wid * hi)) ));
HXDLIN(  49)						b6->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  49)						{
HXLINE(  49)							int len3 = b6->length;
HXDLIN(  49)							 ::haxe::ds::GenericStack_Int d1 = b6->data;
HXDLIN(  49)							if (::hx::IsNull( d1->head )) {
HXLINE(  49)								int _g26 = 0;
HXDLIN(  49)								int _g27 = len3;
HXDLIN(  49)								while((_g26 < _g27)){
HXLINE(  49)									_g26 = (_g26 + 1);
HXDLIN(  49)									int i9 = (_g26 - 1);
HXDLIN(  49)									d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            								}
            							}
            							else {
HXLINE(  49)								int _g28 = 0;
HXDLIN(  49)								int _g29 = len3;
HXDLIN(  49)								while((_g28 < _g29)){
HXLINE(  49)									_g28 = (_g28 + 1);
HXDLIN(  49)									int i10 = (_g28 - 1);
HXDLIN(  49)									{
HXLINE(  49)										 ::haxe::ds::GenericCell_Int l1 = b6->data->head;
HXDLIN(  49)										 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  49)										{
HXLINE(  49)											int _g30 = 0;
HXDLIN(  49)											int _g31 = i10;
HXDLIN(  49)											while((_g30 < _g31)){
HXLINE(  49)												_g30 = (_g30 + 1);
HXDLIN(  49)												int i11 = (_g30 - 1);
HXLINE( 345)												prev1 = l1;
HXLINE( 346)												l1 = l1->next;
            											}
            										}
HXLINE(  49)										if (::hx::IsNull( prev1 )) {
HXLINE(  49)											b6->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  49)											l1 = null();
            										}
            										else {
HXLINE(  49)											prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  49)											l1 = null();
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  49)					_hx_tmp6 = b6;
            				}
            				break;
            			}
HXDLIN(  49)			this15->image = _hx_tmp6;
HXDLIN(  49)			this15->width = wid;
HXDLIN(  49)			this15->height = hi;
HXDLIN(  49)			this15->imageType = ( (int)(imageType1) );
HXDLIN(  49)			 ::pi_xy::ImageStruct nextImage1 = this15;
HXLINE(  50)			{
HXLINE(  50)				bool v3 = thisImage->transparent;
HXDLIN(  50)				nextImage1->transparent = v3;
            			}
HXLINE(  51)			{
HXLINE(  51)				 ::pi_xy::ImageStruct this17 = nextImage1;
HXDLIN(  51)				Float win_x = ( (Float)(0) );
HXDLIN(  51)				Float win_y = ( (Float)(0) );
HXDLIN(  51)				Float win_width = ( (Float)(thisImage->width) );
HXDLIN(  51)				Float win_height = ( (Float)(thisImage->height) );
HXDLIN(  51)				{
HXLINE(  51)					Float bu = ((Float)1.);
HXDLIN(  51)					Float bv = ((Float)0.);
HXDLIN(  51)					Float cu = ((Float)1.);
HXDLIN(  51)					Float cv = ((Float)1.);
HXDLIN(  51)					Float du = ((Float)0.);
HXDLIN(  51)					Float dv = ((Float)1.);
HXDLIN(  51)					Float au = ((Float)0.);
HXDLIN(  51)					Float av = ((Float)0.);
HXDLIN(  51)					Float bu1 = bu;
HXDLIN(  51)					Float bv1 = bv;
HXDLIN(  51)					bool hasUndo = false;
HXDLIN(  51)					Float temp = au;
HXLINE( 422)					au = bu1;
HXLINE( 423)					bu1 = temp;
HXLINE( 424)					temp = av;
HXLINE( 425)					av = bv1;
HXLINE( 426)					bv1 = temp;
HXLINE(  51)					Float bcx = w1;
HXDLIN(  51)					Float bcy = (( (Float)(0) ) - h);
HXDLIN(  51)					Float acx = ( (Float)(0) );
HXDLIN(  51)					Float acy = (( (Float)(0) ) - h);
HXDLIN(  51)					Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  51)					Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  51)					Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  51)					Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  51)					 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  51)					if ((0 > w1)) {
HXLINE(  51)						int ii_min = ::Math_obj::floor(w1);
HXDLIN(  51)						int ii_max = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  51)						xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            					}
            					else {
HXLINE(  51)						if ((w1 > 0)) {
HXLINE(  51)							int ii_min1 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  51)							int ii_max1 = ::Math_obj::ceil(w1);
HXDLIN(  51)							xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            						}
            						else {
HXLINE(  51)							int ii_min2 = ::Math_obj::floor(( (Float)(0) ));
HXDLIN(  51)							int ii_max2 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  51)							xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            						}
            					}
HXDLIN(  51)					 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  51)					if ((0 > h)) {
HXLINE(  51)						int min;
HXDLIN(  51)						if ((0 > h)) {
HXLINE(  51)							min = ::Math_obj::floor(h);
            						}
            						else {
HXLINE(  51)							min = ::Math_obj::ceil(( (Float)(0) ));
            						}
HXDLIN(  51)						int ii_min3 = min;
HXDLIN(  51)						int ii_max3 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  51)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            					}
            					else {
HXLINE(  51)						int ii_min4 = ::Math_obj::floor(( (Float)(0) ));
HXDLIN(  51)						int ii_max4 = ::Math_obj::ceil(h);
HXDLIN(  51)						yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            					}
HXDLIN(  51)					 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  51)					if (hasUndo) {
HXLINE(  51)						int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  51)						int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  51)						 ::Dynamic imageType2 = null();
HXDLIN(  51)						 ::pi_xy::ImageStruct this18 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  51)						if (::hx::IsNull( imageType2 )) {
HXLINE(  54)							imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE(  51)						::Dynamic undoImage1;
HXDLIN(  51)						switch((int)(( (int)(imageType2) ))){
            							case (int)0: {
HXLINE(  51)								 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  51)								 ::iterMagic::BytesImg b7 = byt2;
HXDLIN(  51)								{
HXLINE(  51)									b7->width = width;
HXDLIN(  51)									b7->height = height;
HXDLIN(  51)									b7->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  51)									b7->data = ::haxe::io::Bytes_obj::alloc((b7->length * 4));
HXDLIN(  51)									{
HXLINE(  51)										int len4 = b7->length;
HXDLIN(  51)										int w3 = 0;
HXDLIN(  51)										{
HXLINE(  51)											int _g32 = 0;
HXDLIN(  51)											int _g33 = b7->height;
HXDLIN(  51)											while((_g32 < _g33)){
HXLINE(  51)												_g32 = (_g32 + 1);
HXDLIN(  51)												int y3 = (_g32 - 1);
HXDLIN(  51)												{
HXLINE(  51)													int _g34 = 0;
HXDLIN(  51)													int _g35 = b7->width;
HXDLIN(  51)													while((_g34 < _g35)){
HXLINE(  51)														_g34 = (_g34 + 1);
HXDLIN(  51)														int x4 = (_g34 - 1);
HXDLIN(  51)														{
HXLINE(  51)															w3 = (w3 + 1);
HXDLIN(  51)															b7->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  51)														{
HXLINE(  51)															w3 = (w3 + 1);
HXDLIN(  51)															b7->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  51)														{
HXLINE(  51)															w3 = (w3 + 1);
HXDLIN(  51)															b7->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  51)														{
HXLINE(  51)															w3 = (w3 + 1);
HXDLIN(  51)															b7->data->b[(w3 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  51)								undoImage1 = b7;
            							}
            							break;
            							case (int)1: {
HXLINE(  51)								 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  51)								 ::iterMagic::ArrIntImg a6 = arrI2;
HXDLIN(  51)								{
HXLINE(  51)									a6->width = width;
HXDLIN(  51)									a6->height = height;
HXDLIN(  51)									a6->data = ::Array_obj< int >::__new(0);
HXDLIN(  51)									a6->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  51)									{
HXLINE(  51)										int _g36 = 0;
HXDLIN(  51)										int _g37 = a6->length;
HXDLIN(  51)										while((_g36 < _g37)){
HXLINE(  51)											_g36 = (_g36 + 1);
HXDLIN(  51)											int i12 = (_g36 - 1);
HXDLIN(  51)											a6->data[i12] = 0;
            										}
            									}
            								}
HXDLIN(  51)								undoImage1 = a6;
            							}
            							break;
            							case (int)2: {
HXLINE(  51)								 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  51)								 ::iterMagic::U32ArrImg b8 = u32a2;
HXDLIN(  51)								{
HXLINE(  51)									b8->width = width;
HXDLIN(  51)									b8->height = height;
HXDLIN(  51)									b8->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  51)									int size2 = (b8->length * 4);
HXDLIN(  51)									b8->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN(  51)									{
HXLINE(  51)										int _g38 = 0;
HXDLIN(  51)										int _g39 = b8->length;
HXDLIN(  51)										while((_g38 < _g39)){
HXLINE(  51)											_g38 = (_g38 + 1);
HXDLIN(  51)											int i13 = (_g38 - 1);
HXDLIN(  51)											{
HXLINE(  51)												 ::haxe::io::ArrayBufferViewImpl this19 = b8->data;
HXDLIN(  51)												bool undoImage2;
HXDLIN(  51)												if ((i13 >= 0)) {
HXLINE(  51)													undoImage2 = (i13 < (this19->byteLength >> 2));
            												}
            												else {
HXLINE(  51)													undoImage2 = false;
            												}
HXDLIN(  51)												if (undoImage2) {
HXLINE(  51)													 ::haxe::io::Bytes _this2 = this19->bytes;
HXDLIN(  51)													int pos2 = ((i13 << 2) + this19->byteOffset);
HXDLIN(  51)													_this2->b[pos2] = ( (unsigned char)(0) );
HXDLIN(  51)													_this2->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN(  51)													_this2->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN(  51)													_this2->b[(pos2 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN(  51)								undoImage1 = b8;
            							}
            							break;
            							case (int)3: {
HXLINE(  51)								 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  51)								 ::iterMagic::VecIntImg v4 = vec2;
HXDLIN(  51)								{
HXLINE(  51)									v4->width = width;
HXDLIN(  51)									v4->height = height;
HXDLIN(  51)									v4->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  51)									v4->data = ::Array_obj< int >::__new(v4->length);
HXDLIN(  51)									{
HXLINE(  51)										int _g40 = 0;
HXDLIN(  51)										int _g41 = v4->length;
HXDLIN(  51)										while((_g40 < _g41)){
HXLINE(  51)											_g40 = (_g40 + 1);
HXDLIN(  51)											int i14 = (_g40 - 1);
HXDLIN(  51)											v4->data->__unsafe_set(i14,0);
            										}
            									}
            								}
HXDLIN(  51)								undoImage1 = v4;
            							}
            							break;
            							case (int)4: {
HXLINE(  51)								 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  51)								 ::iterMagic::StackIntImg b9 = sInt2;
HXDLIN(  51)								{
HXLINE(  51)									b9->width = width;
HXDLIN(  51)									b9->height = height;
HXDLIN(  51)									b9->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  51)									b9->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  51)									{
HXLINE(  51)										int len5 = b9->length;
HXDLIN(  51)										 ::haxe::ds::GenericStack_Int d2 = b9->data;
HXDLIN(  51)										if (::hx::IsNull( d2->head )) {
HXLINE(  51)											int _g42 = 0;
HXDLIN(  51)											int _g43 = len5;
HXDLIN(  51)											while((_g42 < _g43)){
HXLINE(  51)												_g42 = (_g42 + 1);
HXDLIN(  51)												int i15 = (_g42 - 1);
HXDLIN(  51)												d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            											}
            										}
            										else {
HXLINE(  51)											int _g44 = 0;
HXDLIN(  51)											int _g45 = len5;
HXDLIN(  51)											while((_g44 < _g45)){
HXLINE(  51)												_g44 = (_g44 + 1);
HXDLIN(  51)												int i16 = (_g44 - 1);
HXDLIN(  51)												{
HXLINE(  51)													 ::haxe::ds::GenericCell_Int l2 = b9->data->head;
HXDLIN(  51)													 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN(  51)													{
HXLINE(  51)														int _g46 = 0;
HXDLIN(  51)														int _g47 = i16;
HXDLIN(  51)														while((_g46 < _g47)){
HXLINE(  51)															_g46 = (_g46 + 1);
HXDLIN(  51)															int i17 = (_g46 - 1);
HXLINE( 345)															prev2 = l2;
HXLINE( 346)															l2 = l2->next;
            														}
            													}
HXLINE(  51)													if (::hx::IsNull( prev2 )) {
HXLINE(  51)														b9->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  51)														l2 = null();
            													}
            													else {
HXLINE(  51)														prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  51)														l2 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  51)								undoImage1 = b9;
            							}
            							break;
            						}
HXDLIN(  51)						this18->image = undoImage1;
HXDLIN(  51)						this18->width = width;
HXDLIN(  51)						this18->height = height;
HXDLIN(  51)						this18->imageType = ( (int)(imageType2) );
HXDLIN(  51)						undoImage = this18;
HXDLIN(  51)						{
HXLINE(  51)							int rectLeft = xIter3->start;
HXDLIN(  51)							int rectTop = yIter3->start;
HXDLIN(  51)							int rectRight = xIter3->max;
HXDLIN(  51)							bool forceClear = false;
HXDLIN(  51)							{
HXLINE(  51)								int _g48 = rectTop;
HXDLIN(  51)								int _g49 = yIter3->max;
HXDLIN(  51)								while((_g48 < _g49)){
HXLINE(  51)									_g48 = (_g48 + 1);
HXDLIN(  51)									int dy = (_g48 - 1);
HXDLIN(  51)									{
HXLINE(  51)										int _g50 = rectLeft;
HXDLIN(  51)										int _g51 = rectRight;
HXDLIN(  51)										while((_g50 < _g51)){
HXLINE(  51)											_g50 = (_g50 + 1);
HXDLIN(  51)											int dx = (_g50 - 1);
HXDLIN(  51)											::Dynamic this20 = this17->image;
HXDLIN(  51)											int index2;
HXDLIN(  51)											if (this17->useVirtualPos) {
HXLINE(  51)												index2 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this17->virtualY) * ( (Float)(this17->width) )) + dx) - this17->virtualX));
            											}
            											else {
HXLINE(  51)												index2 = ::Std_obj::_hx_int(( (Float)(((dy * this17->width) + dx)) ));
            											}
HXDLIN(  51)											int c2 = ::iterMagic::Iimg_obj::get(this20,index2);
HXDLIN(  51)											int col;
HXDLIN(  51)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  51)												col = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            											}
            											else {
HXLINE(  51)												col = c2;
            											}
HXDLIN(  51)											bool _hx_tmp8;
HXDLIN(  51)											if (this17->useMask) {
HXLINE(  51)												_hx_tmp8 = ::hx::IsNotNull( this17->mask );
            											}
            											else {
HXLINE(  51)												_hx_tmp8 = false;
            											}
HXDLIN(  51)											if (_hx_tmp8) {
HXLINE(  51)												 ::pi_xy::ImageStruct this21 = this17->mask;
HXDLIN(  51)												::Dynamic this22 = this21->image;
HXDLIN(  51)												int index3;
HXDLIN(  51)												if (this21->useVirtualPos) {
HXLINE(  51)													index3 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this21->virtualY) * ( (Float)(this21->width) )) + dx) - this21->virtualX));
            												}
            												else {
HXLINE(  51)													index3 = ::Std_obj::_hx_int(( (Float)(((dy * this21->width) + dx)) ));
            												}
HXDLIN(  51)												int c3 = ::iterMagic::Iimg_obj::get(this22,index3);
HXDLIN(  51)												int v5;
HXDLIN(  51)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  51)													v5 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            												}
            												else {
HXLINE(  51)													v5 = c3;
            												}
HXDLIN(  51)												int maskPixel = v5;
HXDLIN(  51)												int this23 = col;
HXDLIN(  51)												if ((maskPixel == 0)) {
HXLINE(  51)													col = this23;
            												}
            												else {
HXLINE(  51)													Float m0;
HXDLIN(  51)													int this24 = ((maskPixel >> 24) & 255);
HXDLIN(  51)													if ((this24 == 0)) {
HXLINE(  51)														m0 = ((Float)0.);
            													}
            													else {
HXLINE(  51)														m0 = (( (Float)(this24) ) / ( (Float)(255) ));
            													}
HXDLIN(  51)													Float m1;
HXDLIN(  51)													int this25 = ((maskPixel >> 16) & 255);
HXDLIN(  51)													if ((this25 == 0)) {
HXLINE(  51)														m1 = ((Float)0.);
            													}
            													else {
HXLINE(  51)														m1 = (( (Float)(this25) ) / ( (Float)(255) ));
            													}
HXDLIN(  51)													Float m2;
HXDLIN(  51)													int this26 = ((maskPixel >> 8) & 255);
HXDLIN(  51)													if ((this26 == 0)) {
HXLINE(  51)														m2 = ((Float)0.);
            													}
            													else {
HXLINE(  51)														m2 = (( (Float)(this26) ) / ( (Float)(255) ));
            													}
HXDLIN(  51)													Float m3;
HXDLIN(  51)													int this27 = (maskPixel & 255);
HXDLIN(  51)													if ((this27 == 0)) {
HXLINE(  51)														m3 = ((Float)0.);
            													}
            													else {
HXLINE(  51)														m3 = (( (Float)(this27) ) / ( (Float)(255) ));
            													}
HXDLIN(  51)													int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this23 >> 24) & 255)) )));
HXDLIN(  51)													int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this23 >> 16) & 255)) )));
HXDLIN(  51)													int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this23 >> 8) & 255)) )));
HXDLIN(  51)													int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this23 & 255)) )));
HXDLIN(  51)													col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  51)											if ((col != 0)) {
HXLINE(  51)												int x5 = (dx - rectLeft);
HXDLIN(  51)												int y4 = (dy - rectTop);
HXDLIN(  51)												int c4 = col;
HXDLIN(  51)												bool _hx_tmp9;
HXDLIN(  51)												if ((((c4 >> 24) & 255) < 254)) {
HXLINE(  51)													_hx_tmp9 = undoImage->transparent;
            												}
            												else {
HXLINE(  51)													_hx_tmp9 = false;
            												}
HXDLIN(  51)												if (_hx_tmp9) {
HXLINE(  51)													int location1;
HXDLIN(  51)													if (undoImage->useVirtualPos) {
HXLINE(  51)														location1 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            													}
            													else {
HXLINE(  51)														location1 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage->width) + x5)) ));
            													}
HXDLIN(  51)													int this28 = ::iterMagic::Iimg_obj::get(undoImage->image,location1);
HXDLIN(  51)													int this29;
HXDLIN(  51)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  51)														this29 = ((((((this28 >> 24) & 255) << 24) | ((this28 & 255) << 16)) | (((this28 >> 8) & 255) << 8)) | ((this28 >> 16) & 255));
            													}
            													else {
HXLINE(  51)														this29 = this28;
            													}
HXDLIN(  51)													Float a11;
HXDLIN(  51)													int this30 = ((this29 >> 24) & 255);
HXDLIN(  51)													if ((this30 == 0)) {
HXLINE(  51)														a11 = ((Float)0.);
            													}
            													else {
HXLINE(  51)														a11 = (( (Float)(this30) ) / ( (Float)(255) ));
            													}
HXDLIN(  51)													Float r11;
HXDLIN(  51)													int this31 = ((this29 >> 16) & 255);
HXDLIN(  51)													if ((this31 == 0)) {
HXLINE(  51)														r11 = ((Float)0.);
            													}
            													else {
HXLINE(  51)														r11 = (( (Float)(this31) ) / ( (Float)(255) ));
            													}
HXDLIN(  51)													Float g11;
HXDLIN(  51)													int this32 = ((this29 >> 8) & 255);
HXDLIN(  51)													if ((this32 == 0)) {
HXLINE(  51)														g11 = ((Float)0.);
            													}
            													else {
HXLINE(  51)														g11 = (( (Float)(this32) ) / ( (Float)(255) ));
            													}
HXDLIN(  51)													Float b12;
HXDLIN(  51)													int this33 = (this29 & 255);
HXDLIN(  51)													if ((this33 == 0)) {
HXLINE(  51)														b12 = ((Float)0.);
            													}
            													else {
HXLINE(  51)														b12 = (( (Float)(this33) ) / ( (Float)(255) ));
            													}
HXDLIN(  51)													Float a21;
HXDLIN(  51)													int this34 = ((col >> 24) & 255);
HXDLIN(  51)													if ((this34 == 0)) {
HXLINE(  51)														a21 = ((Float)0.);
            													}
            													else {
HXLINE(  51)														a21 = (( (Float)(this34) ) / ( (Float)(255) ));
            													}
HXDLIN(  51)													Float r21;
HXDLIN(  51)													int this35 = ((col >> 16) & 255);
HXDLIN(  51)													if ((this35 == 0)) {
HXLINE(  51)														r21 = ((Float)0.);
            													}
            													else {
HXLINE(  51)														r21 = (( (Float)(this35) ) / ( (Float)(255) ));
            													}
HXDLIN(  51)													Float g21;
HXDLIN(  51)													int this36 = ((col >> 8) & 255);
HXDLIN(  51)													if ((this36 == 0)) {
HXLINE(  51)														g21 = ((Float)0.);
            													}
            													else {
HXLINE(  51)														g21 = (( (Float)(this36) ) / ( (Float)(255) ));
            													}
HXDLIN(  51)													Float b22;
HXDLIN(  51)													int this37 = (col & 255);
HXDLIN(  51)													if ((this37 == 0)) {
HXLINE(  51)														b22 = ((Float)0.);
            													}
            													else {
HXLINE(  51)														b22 = (( (Float)(this37) ) / ( (Float)(255) ));
            													}
HXDLIN(  51)													Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  51)													int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  51)													int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  51)													int b10 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  51)													int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  51)													int blended1 = ((((a7 << 24) | (r3 << 16)) | (g3 << 8)) | b10);
HXDLIN(  51)													{
HXLINE(  51)														int _hx_tmp10;
HXDLIN(  51)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  51)															_hx_tmp10 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            														}
            														else {
HXLINE(  51)															_hx_tmp10 = blended1;
            														}
HXDLIN(  51)														::iterMagic::Iimg_obj::set(undoImage->image,location1,_hx_tmp10);
            													}
            												}
            												else {
HXLINE(  51)													::Dynamic this38 = undoImage->image;
HXDLIN(  51)													int index4;
HXDLIN(  51)													if (undoImage->useVirtualPos) {
HXLINE(  51)														index4 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x5) - undoImage->virtualX));
            													}
            													else {
HXLINE(  51)														index4 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage->width) + x5)) ));
            													}
HXDLIN(  51)													int _hx_tmp11;
HXDLIN(  51)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  51)														_hx_tmp11 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            													}
            													else {
HXLINE(  51)														_hx_tmp11 = c4;
            													}
HXDLIN(  51)													::iterMagic::Iimg_obj::set(this38,index4,_hx_tmp11);
            												}
            											}
            											else {
HXLINE(  51)												if (forceClear) {
HXLINE(  51)													::Dynamic this39 = undoImage->image;
HXDLIN(  51)													int x6 = (dx - rectLeft);
HXDLIN(  51)													int y5 = (dy - rectTop);
HXDLIN(  51)													int index5;
HXDLIN(  51)													if (undoImage->useVirtualPos) {
HXLINE(  51)														index5 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x6) - undoImage->virtualX));
            													}
            													else {
HXLINE(  51)														index5 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage->width) + x6)) ));
            													}
HXDLIN(  51)													::iterMagic::Iimg_obj::set(this39,index5,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  51)					{
HXLINE(  51)						int _g_min = xIter3->start;
HXDLIN(  51)						int _g_max = xIter3->max;
HXDLIN(  51)						while((_g_min < _g_max)){
HXLINE(  51)							_g_min = (_g_min + 1);
HXDLIN(  51)							int px = (_g_min - 1);
HXDLIN(  51)							Float pcx = ( (Float)(px) );
HXDLIN(  51)							{
HXLINE(  51)								int _g_min1 = yIter3->start;
HXDLIN(  51)								int _g_max1 = yIter3->max;
HXDLIN(  51)								while((_g_min1 < _g_max1)){
HXLINE(  51)									_g_min1 = (_g_min1 + 1);
HXDLIN(  51)									int py = (_g_min1 - 1);
HXDLIN(  51)									Float pcy = (( (Float)(py) ) - h);
HXDLIN(  51)									Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  51)									Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  51)									Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  51)									Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  51)									Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  51)									bool _hx_tmp12;
HXDLIN(  51)									bool _hx_tmp13;
HXDLIN(  51)									if ((ratioA >= 0)) {
HXLINE(  51)										_hx_tmp13 = (ratioB >= 0);
            									}
            									else {
HXLINE(  51)										_hx_tmp13 = false;
            									}
HXDLIN(  51)									if (_hx_tmp13) {
HXLINE(  51)										_hx_tmp12 = (ratioC >= 0);
            									}
            									else {
HXLINE(  51)										_hx_tmp12 = false;
            									}
HXDLIN(  51)									if (_hx_tmp12) {
HXLINE(  51)										Float u = (((au * ratioA) + (bu1 * ratioB)) + (du * ratioC));
HXDLIN(  51)										Float v6 = (((av * ratioA) + (bv1 * ratioB)) + (dv * ratioC));
HXDLIN(  51)										int x7 = ::Std_obj::_hx_int(((u * win_width) + win_x));
HXDLIN(  51)										int y6 = ::Std_obj::_hx_int(((v6 * win_height) + win_y));
HXDLIN(  51)										::Dynamic this40 = thisImage->image;
HXDLIN(  51)										int index6;
HXDLIN(  51)										if (thisImage->useVirtualPos) {
HXLINE(  51)											index6 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - thisImage->virtualY) * ( (Float)(thisImage->width) )) + x7) - thisImage->virtualX));
            										}
            										else {
HXLINE(  51)											index6 = ::Std_obj::_hx_int(( (Float)(((y6 * thisImage->width) + x7)) ));
            										}
HXDLIN(  51)										int c5 = ::iterMagic::Iimg_obj::get(this40,index6);
HXDLIN(  51)										int col1;
HXDLIN(  51)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  51)											col1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            										}
            										else {
HXLINE(  51)											col1 = c5;
            										}
HXDLIN(  51)										{
HXLINE(  51)											int c6 = col1;
HXDLIN(  51)											bool _hx_tmp14;
HXDLIN(  51)											if ((((c6 >> 24) & 255) < 254)) {
HXLINE(  51)												_hx_tmp14 = this17->transparent;
            											}
            											else {
HXLINE(  51)												_hx_tmp14 = false;
            											}
HXDLIN(  51)											if (_hx_tmp14) {
HXLINE(  51)												int location2;
HXDLIN(  51)												if (this17->useVirtualPos) {
HXLINE(  51)													location2 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this17->virtualY) * ( (Float)(this17->width) )) + px) - this17->virtualX));
            												}
            												else {
HXLINE(  51)													location2 = ::Std_obj::_hx_int(( (Float)(((py * this17->width) + px)) ));
            												}
HXDLIN(  51)												int this41 = ::iterMagic::Iimg_obj::get(this17->image,location2);
HXDLIN(  51)												int this42;
HXDLIN(  51)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  51)													this42 = ((((((this41 >> 24) & 255) << 24) | ((this41 & 255) << 16)) | (((this41 >> 8) & 255) << 8)) | ((this41 >> 16) & 255));
            												}
            												else {
HXLINE(  51)													this42 = this41;
            												}
HXDLIN(  51)												Float a12;
HXDLIN(  51)												int this43 = ((this42 >> 24) & 255);
HXDLIN(  51)												if ((this43 == 0)) {
HXLINE(  51)													a12 = ((Float)0.);
            												}
            												else {
HXLINE(  51)													a12 = (( (Float)(this43) ) / ( (Float)(255) ));
            												}
HXDLIN(  51)												Float r12;
HXDLIN(  51)												int this44 = ((this42 >> 16) & 255);
HXDLIN(  51)												if ((this44 == 0)) {
HXLINE(  51)													r12 = ((Float)0.);
            												}
            												else {
HXLINE(  51)													r12 = (( (Float)(this44) ) / ( (Float)(255) ));
            												}
HXDLIN(  51)												Float g12;
HXDLIN(  51)												int this45 = ((this42 >> 8) & 255);
HXDLIN(  51)												if ((this45 == 0)) {
HXLINE(  51)													g12 = ((Float)0.);
            												}
            												else {
HXLINE(  51)													g12 = (( (Float)(this45) ) / ( (Float)(255) ));
            												}
HXDLIN(  51)												Float b13;
HXDLIN(  51)												int this46 = (this42 & 255);
HXDLIN(  51)												if ((this46 == 0)) {
HXLINE(  51)													b13 = ((Float)0.);
            												}
            												else {
HXLINE(  51)													b13 = (( (Float)(this46) ) / ( (Float)(255) ));
            												}
HXDLIN(  51)												Float a22;
HXDLIN(  51)												int this47 = ((col1 >> 24) & 255);
HXDLIN(  51)												if ((this47 == 0)) {
HXLINE(  51)													a22 = ((Float)0.);
            												}
            												else {
HXLINE(  51)													a22 = (( (Float)(this47) ) / ( (Float)(255) ));
            												}
HXDLIN(  51)												Float r22;
HXDLIN(  51)												int this48 = ((col1 >> 16) & 255);
HXDLIN(  51)												if ((this48 == 0)) {
HXLINE(  51)													r22 = ((Float)0.);
            												}
            												else {
HXLINE(  51)													r22 = (( (Float)(this48) ) / ( (Float)(255) ));
            												}
HXDLIN(  51)												Float g22;
HXDLIN(  51)												int this49 = ((col1 >> 8) & 255);
HXDLIN(  51)												if ((this49 == 0)) {
HXLINE(  51)													g22 = ((Float)0.);
            												}
            												else {
HXLINE(  51)													g22 = (( (Float)(this49) ) / ( (Float)(255) ));
            												}
HXDLIN(  51)												Float b23;
HXDLIN(  51)												int this50 = (col1 & 255);
HXDLIN(  51)												if ((this50 == 0)) {
HXLINE(  51)													b23 = ((Float)0.);
            												}
            												else {
HXLINE(  51)													b23 = (( (Float)(this50) ) / ( (Float)(255) ));
            												}
HXDLIN(  51)												Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  51)												int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  51)												int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  51)												int b14 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  51)												int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  51)												int blended2 = ((((a8 << 24) | (r4 << 16)) | (g4 << 8)) | b14);
HXDLIN(  51)												{
HXLINE(  51)													int _hx_tmp15;
HXDLIN(  51)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  51)														_hx_tmp15 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            													}
            													else {
HXLINE(  51)														_hx_tmp15 = blended2;
            													}
HXDLIN(  51)													::iterMagic::Iimg_obj::set(this17->image,location2,_hx_tmp15);
            												}
            											}
            											else {
HXLINE(  51)												::Dynamic this51 = this17->image;
HXDLIN(  51)												int index7;
HXDLIN(  51)												if (this17->useVirtualPos) {
HXLINE(  51)													index7 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this17->virtualY) * ( (Float)(this17->width) )) + px) - this17->virtualX));
            												}
            												else {
HXLINE(  51)													index7 = ::Std_obj::_hx_int(( (Float)(((py * this17->width) + px)) ));
            												}
HXDLIN(  51)												int _hx_tmp16;
HXDLIN(  51)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  51)													_hx_tmp16 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            												}
            												else {
HXLINE(  51)													_hx_tmp16 = c6;
            												}
HXDLIN(  51)												::iterMagic::Iimg_obj::set(this51,index7,_hx_tmp16);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  51)					 ::pi_xy::iter::IntIterStart v_yIter3;
HXDLIN(  51)					 ::pi_xy::iter::IntIterStart v_xIter3;
HXDLIN(  51)					int v_undoY;
HXDLIN(  51)					int v_undoX;
HXDLIN(  51)					Float v_ty;
HXDLIN(  51)					Float v_tx;
HXDLIN(  51)					Float v_t0;
HXDLIN(  51)					Float v_sy;
HXDLIN(  51)					Float v_sx;
HXDLIN(  51)					Float v_s0;
HXDLIN(  51)					Float v_A;
HXDLIN(  51)					 ::pi_xy::ImageStruct v_undoImage = null();
HXDLIN(  51)					Float bx = w1;
HXDLIN(  51)					Float by = ( (Float)(0) );
HXDLIN(  51)					Float cx = ( (Float)(0) );
HXDLIN(  51)					Float cy = h;
HXDLIN(  51)					bool adjustWinding = (((((( (Float)(0) ) * by) - (bx * ( (Float)(0) ))) + ((bx * cy) - (cx * by))) + ((cx * ( (Float)(0) )) - (( (Float)(0) ) * cy))) > 0);
HXDLIN(  51)					if (!(adjustWinding)) {
HXLINE(  51)						Float bx_ = bx;
HXDLIN(  51)						Float by_ = by;
HXLINE(  24)						bx = cx;
HXLINE(  25)						by = cy;
HXLINE(  26)						cx = bx_;
HXLINE(  27)						cy = by_;
            					}
HXLINE(  51)					Float v_ax = ( (Float)(0) );
HXDLIN(  51)					Float v_ay = ( (Float)(0) );
HXDLIN(  51)					Float v_bx = bx;
HXDLIN(  51)					Float v_by = by;
HXDLIN(  51)					Float v_cx = cx;
HXDLIN(  51)					Float v_cy = cy;
HXDLIN(  51)					bool v_preCalculated = true;
HXDLIN(  51)					{
HXLINE(  51)						v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN(  51)						v_sx = (v_cy - v_ay);
HXDLIN(  51)						v_sy = (v_ax - v_cx);
HXDLIN(  51)						v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN(  51)						v_tx = (v_ay - v_by);
HXDLIN(  51)						v_ty = (v_bx - v_ax);
HXDLIN(  51)						v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN(  51)						Float a9 = v_ax;
HXDLIN(  51)						Float b15 = v_bx;
HXDLIN(  51)						Float c7 = v_cx;
HXDLIN(  51)						if ((a9 > b15)) {
HXLINE(  51)							if ((a9 > c7)) {
HXLINE(  51)								int min1;
HXDLIN(  51)								if ((b15 > c7)) {
HXLINE(  51)									min1 = ::Math_obj::floor(c7);
            								}
            								else {
HXLINE(  51)									min1 = ::Math_obj::floor(b15);
            								}
HXDLIN(  51)								int ii_min5 = min1;
HXDLIN(  51)								int ii_max5 = ::Math_obj::ceil(a9);
HXDLIN(  51)								v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            							}
            							else {
HXLINE(  51)								int ii_min6 = ::Math_obj::floor(b15);
HXDLIN(  51)								int ii_max6 = ::Math_obj::ceil(c7);
HXDLIN(  51)								v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            							}
            						}
            						else {
HXLINE(  51)							if ((b15 > c7)) {
HXLINE(  51)								int min2;
HXDLIN(  51)								if ((a9 > c7)) {
HXLINE(  51)									min2 = ::Math_obj::floor(c7);
            								}
            								else {
HXLINE(  51)									min2 = ::Math_obj::ceil(a9);
            								}
HXDLIN(  51)								int ii_min7 = min2;
HXDLIN(  51)								int ii_max7 = ::Math_obj::ceil(b15);
HXDLIN(  51)								v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            							}
            							else {
HXLINE(  51)								int ii_min8 = ::Math_obj::floor(a9);
HXDLIN(  51)								int ii_max8 = ::Math_obj::ceil(c7);
HXDLIN(  51)								v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            							}
            						}
HXDLIN(  51)						Float a10 = v_ay;
HXDLIN(  51)						Float b16 = v_by;
HXDLIN(  51)						Float c8 = v_cy;
HXDLIN(  51)						if ((a10 > b16)) {
HXLINE(  51)							if ((a10 > c8)) {
HXLINE(  51)								int min3;
HXDLIN(  51)								if ((b16 > c8)) {
HXLINE(  51)									min3 = ::Math_obj::floor(c8);
            								}
            								else {
HXLINE(  51)									min3 = ::Math_obj::floor(b16);
            								}
HXDLIN(  51)								int ii_min9 = min3;
HXDLIN(  51)								int ii_max9 = ::Math_obj::ceil(a10);
HXDLIN(  51)								v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            							}
            							else {
HXLINE(  51)								int ii_min10 = ::Math_obj::floor(b16);
HXDLIN(  51)								int ii_max10 = ::Math_obj::ceil(c8);
HXDLIN(  51)								v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            							}
            						}
            						else {
HXLINE(  51)							if ((b16 > c8)) {
HXLINE(  51)								int min4;
HXDLIN(  51)								if ((a10 > c8)) {
HXLINE(  51)									min4 = ::Math_obj::floor(c8);
            								}
            								else {
HXLINE(  51)									min4 = ::Math_obj::ceil(a10);
            								}
HXDLIN(  51)								int ii_min11 = min4;
HXDLIN(  51)								int ii_max11 = ::Math_obj::ceil(b16);
HXDLIN(  51)								v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            							}
            							else {
HXLINE(  51)								int ii_min12 = ::Math_obj::floor(a10);
HXDLIN(  51)								int ii_max12 = ::Math_obj::ceil(c8);
HXDLIN(  51)								v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            							}
            						}
            					}
HXDLIN(  51)					if (hasUndo) {
HXLINE(  51)						v_undoImage = undoImage;
HXDLIN(  51)						v_undoX = xIter3->start;
HXDLIN(  51)						v_undoY = yIter3->start;
            					}
HXDLIN(  51)					Float au1 = bu;
HXDLIN(  51)					Float av1 = bv;
HXDLIN(  51)					Float bu2 = cu;
HXDLIN(  51)					Float bv2 = cv;
HXDLIN(  51)					bool hasUndo1 = false;
HXDLIN(  51)					Float temp1 = au1;
HXLINE( 422)					au1 = bu2;
HXLINE( 423)					bu2 = temp1;
HXLINE( 424)					temp1 = av1;
HXLINE( 425)					av1 = bv2;
HXLINE( 426)					bv2 = temp1;
HXLINE(  51)					Float bcx1 = w1;
HXDLIN(  51)					Float bcy1 = (h - h);
HXDLIN(  51)					Float acx1 = w1;
HXDLIN(  51)					Float acy1 = (( (Float)(0) ) - h);
HXDLIN(  51)					Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  51)					Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  51)					Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  51)					Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  51)					 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  51)					if ((w1 > w1)) {
HXLINE(  51)						if ((w1 > 0)) {
HXLINE(  51)							int min5;
HXDLIN(  51)							if ((w1 > 0)) {
HXLINE(  51)								min5 = ::Math_obj::floor(( (Float)(0) ));
            							}
            							else {
HXLINE(  51)								min5 = ::Math_obj::floor(w1);
            							}
HXDLIN(  51)							int ii_min13 = min5;
HXDLIN(  51)							int ii_max13 = ::Math_obj::ceil(w1);
HXDLIN(  51)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            						}
            						else {
HXLINE(  51)							int ii_min14 = ::Math_obj::floor(w1);
HXDLIN(  51)							int ii_max14 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  51)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            						}
            					}
            					else {
HXLINE(  51)						if ((w1 > 0)) {
HXLINE(  51)							int min6;
HXDLIN(  51)							if ((w1 > 0)) {
HXLINE(  51)								min6 = ::Math_obj::floor(( (Float)(0) ));
            							}
            							else {
HXLINE(  51)								min6 = ::Math_obj::ceil(w1);
            							}
HXDLIN(  51)							int ii_min15 = min6;
HXDLIN(  51)							int ii_max15 = ::Math_obj::ceil(w1);
HXDLIN(  51)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            						}
            						else {
HXLINE(  51)							int ii_min16 = ::Math_obj::floor(w1);
HXDLIN(  51)							int ii_max16 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  51)							xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            						}
            					}
HXDLIN(  51)					 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  51)					if ((0 > h)) {
HXLINE(  51)						if ((0 > h)) {
HXLINE(  51)							int min7;
HXDLIN(  51)							if ((h > h)) {
HXLINE(  51)								min7 = ::Math_obj::floor(h);
            							}
            							else {
HXLINE(  51)								min7 = ::Math_obj::floor(h);
            							}
HXDLIN(  51)							int ii_min17 = min7;
HXDLIN(  51)							int ii_max17 = ::Math_obj::ceil(( (Float)(0) ));
HXDLIN(  51)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            						}
            						else {
HXLINE(  51)							int ii_min18 = ::Math_obj::floor(h);
HXDLIN(  51)							int ii_max18 = ::Math_obj::ceil(h);
HXDLIN(  51)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            						}
            					}
            					else {
HXLINE(  51)						if ((h > h)) {
HXLINE(  51)							int min8;
HXDLIN(  51)							if ((0 > h)) {
HXLINE(  51)								min8 = ::Math_obj::floor(h);
            							}
            							else {
HXLINE(  51)								min8 = ::Math_obj::ceil(( (Float)(0) ));
            							}
HXDLIN(  51)							int ii_min19 = min8;
HXDLIN(  51)							int ii_max19 = ::Math_obj::ceil(h);
HXDLIN(  51)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            						}
            						else {
HXLINE(  51)							int ii_min20 = ::Math_obj::floor(( (Float)(0) ));
HXDLIN(  51)							int ii_max20 = ::Math_obj::ceil(h);
HXDLIN(  51)							yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min20,ii_max20);
            						}
            					}
HXDLIN(  51)					 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  51)					if (hasUndo1) {
HXLINE(  51)						int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  51)						int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  51)						 ::Dynamic imageType3 = null();
HXDLIN(  51)						 ::pi_xy::ImageStruct this52 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  51)						if (::hx::IsNull( imageType3 )) {
HXLINE(  54)							imageType3 = ::pi_xy::ImageStruct_obj::defaultType;
            						}
HXLINE(  51)						::Dynamic undoImage4;
HXDLIN(  51)						switch((int)(( (int)(imageType3) ))){
            							case (int)0: {
HXLINE(  51)								 ::iterMagic::BytesImg byt3 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  51)								 ::iterMagic::BytesImg b17 = byt3;
HXDLIN(  51)								{
HXLINE(  51)									b17->width = width1;
HXDLIN(  51)									b17->height = height1;
HXDLIN(  51)									b17->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  51)									b17->data = ::haxe::io::Bytes_obj::alloc((b17->length * 4));
HXDLIN(  51)									{
HXLINE(  51)										int len6 = b17->length;
HXDLIN(  51)										int w4 = 0;
HXDLIN(  51)										{
HXLINE(  51)											int _g52 = 0;
HXDLIN(  51)											int _g53 = b17->height;
HXDLIN(  51)											while((_g52 < _g53)){
HXLINE(  51)												_g52 = (_g52 + 1);
HXDLIN(  51)												int y7 = (_g52 - 1);
HXDLIN(  51)												{
HXLINE(  51)													int _g54 = 0;
HXDLIN(  51)													int _g55 = b17->width;
HXDLIN(  51)													while((_g54 < _g55)){
HXLINE(  51)														_g54 = (_g54 + 1);
HXDLIN(  51)														int x8 = (_g54 - 1);
HXDLIN(  51)														{
HXLINE(  51)															w4 = (w4 + 1);
HXDLIN(  51)															b17->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  51)														{
HXLINE(  51)															w4 = (w4 + 1);
HXDLIN(  51)															b17->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  51)														{
HXLINE(  51)															w4 = (w4 + 1);
HXDLIN(  51)															b17->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            														}
HXDLIN(  51)														{
HXLINE(  51)															w4 = (w4 + 1);
HXDLIN(  51)															b17->data->b[(w4 - 1)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  51)								undoImage4 = b17;
            							}
            							break;
            							case (int)1: {
HXLINE(  51)								 ::iterMagic::ArrIntImg arrI3 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  51)								 ::iterMagic::ArrIntImg a13 = arrI3;
HXDLIN(  51)								{
HXLINE(  51)									a13->width = width1;
HXDLIN(  51)									a13->height = height1;
HXDLIN(  51)									a13->data = ::Array_obj< int >::__new(0);
HXDLIN(  51)									a13->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  51)									{
HXLINE(  51)										int _g56 = 0;
HXDLIN(  51)										int _g57 = a13->length;
HXDLIN(  51)										while((_g56 < _g57)){
HXLINE(  51)											_g56 = (_g56 + 1);
HXDLIN(  51)											int i18 = (_g56 - 1);
HXDLIN(  51)											a13->data[i18] = 0;
            										}
            									}
            								}
HXDLIN(  51)								undoImage4 = a13;
            							}
            							break;
            							case (int)2: {
HXLINE(  51)								 ::iterMagic::U32ArrImg u32a3 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  51)								 ::iterMagic::U32ArrImg b18 = u32a3;
HXDLIN(  51)								{
HXLINE(  51)									b18->width = width1;
HXDLIN(  51)									b18->height = height1;
HXDLIN(  51)									b18->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  51)									int size3 = (b18->length * 4);
HXDLIN(  51)									b18->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size3),0,size3);
HXDLIN(  51)									{
HXLINE(  51)										int _g58 = 0;
HXDLIN(  51)										int _g59 = b18->length;
HXDLIN(  51)										while((_g58 < _g59)){
HXLINE(  51)											_g58 = (_g58 + 1);
HXDLIN(  51)											int i19 = (_g58 - 1);
HXDLIN(  51)											{
HXLINE(  51)												 ::haxe::io::ArrayBufferViewImpl this53 = b18->data;
HXDLIN(  51)												bool undoImage5;
HXDLIN(  51)												if ((i19 >= 0)) {
HXLINE(  51)													undoImage5 = (i19 < (this53->byteLength >> 2));
            												}
            												else {
HXLINE(  51)													undoImage5 = false;
            												}
HXDLIN(  51)												if (undoImage5) {
HXLINE(  51)													 ::haxe::io::Bytes _this3 = this53->bytes;
HXDLIN(  51)													int pos3 = ((i19 << 2) + this53->byteOffset);
HXDLIN(  51)													_this3->b[pos3] = ( (unsigned char)(0) );
HXDLIN(  51)													_this3->b[(pos3 + 1)] = ( (unsigned char)(0) );
HXDLIN(  51)													_this3->b[(pos3 + 2)] = ( (unsigned char)(0) );
HXDLIN(  51)													_this3->b[(pos3 + 3)] = ( (unsigned char)(0) );
            												}
            											}
            										}
            									}
            								}
HXDLIN(  51)								undoImage4 = b18;
            							}
            							break;
            							case (int)3: {
HXLINE(  51)								 ::iterMagic::VecIntImg vec3 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  51)								 ::iterMagic::VecIntImg v7 = vec3;
HXDLIN(  51)								{
HXLINE(  51)									v7->width = width1;
HXDLIN(  51)									v7->height = height1;
HXDLIN(  51)									v7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  51)									v7->data = ::Array_obj< int >::__new(v7->length);
HXDLIN(  51)									{
HXLINE(  51)										int _g60 = 0;
HXDLIN(  51)										int _g61 = v7->length;
HXDLIN(  51)										while((_g60 < _g61)){
HXLINE(  51)											_g60 = (_g60 + 1);
HXDLIN(  51)											int i20 = (_g60 - 1);
HXDLIN(  51)											v7->data->__unsafe_set(i20,0);
            										}
            									}
            								}
HXDLIN(  51)								undoImage4 = v7;
            							}
            							break;
            							case (int)4: {
HXLINE(  51)								 ::iterMagic::StackIntImg sInt3 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  51)								 ::iterMagic::StackIntImg b19 = sInt3;
HXDLIN(  51)								{
HXLINE(  51)									b19->width = width1;
HXDLIN(  51)									b19->height = height1;
HXDLIN(  51)									b19->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  51)									b19->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  51)									{
HXLINE(  51)										int len7 = b19->length;
HXDLIN(  51)										 ::haxe::ds::GenericStack_Int d3 = b19->data;
HXDLIN(  51)										if (::hx::IsNull( d3->head )) {
HXLINE(  51)											int _g62 = 0;
HXDLIN(  51)											int _g63 = len7;
HXDLIN(  51)											while((_g62 < _g63)){
HXLINE(  51)												_g62 = (_g62 + 1);
HXDLIN(  51)												int i21 = (_g62 - 1);
HXDLIN(  51)												d3->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d3->head);
            											}
            										}
            										else {
HXLINE(  51)											int _g64 = 0;
HXDLIN(  51)											int _g65 = len7;
HXDLIN(  51)											while((_g64 < _g65)){
HXLINE(  51)												_g64 = (_g64 + 1);
HXDLIN(  51)												int i22 = (_g64 - 1);
HXDLIN(  51)												{
HXLINE(  51)													 ::haxe::ds::GenericCell_Int l3 = b19->data->head;
HXDLIN(  51)													 ::haxe::ds::GenericCell_Int prev3 = null();
HXDLIN(  51)													{
HXLINE(  51)														int _g66 = 0;
HXDLIN(  51)														int _g67 = i22;
HXDLIN(  51)														while((_g66 < _g67)){
HXLINE(  51)															_g66 = (_g66 + 1);
HXDLIN(  51)															int i23 = (_g66 - 1);
HXLINE( 345)															prev3 = l3;
HXLINE( 346)															l3 = l3->next;
            														}
            													}
HXLINE(  51)													if (::hx::IsNull( prev3 )) {
HXLINE(  51)														b19->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  51)														l3 = null();
            													}
            													else {
HXLINE(  51)														prev3->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l3->next);
HXDLIN(  51)														l3 = null();
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  51)								undoImage4 = b19;
            							}
            							break;
            						}
HXDLIN(  51)						this52->image = undoImage4;
HXDLIN(  51)						this52->width = width1;
HXDLIN(  51)						this52->height = height1;
HXDLIN(  51)						this52->imageType = ( (int)(imageType3) );
HXDLIN(  51)						undoImage3 = this52;
HXDLIN(  51)						{
HXLINE(  51)							int rectLeft1 = xIter31->start;
HXDLIN(  51)							int rectTop1 = yIter31->start;
HXDLIN(  51)							int rectRight1 = xIter31->max;
HXDLIN(  51)							bool forceClear1 = false;
HXDLIN(  51)							{
HXLINE(  51)								int _g68 = rectTop1;
HXDLIN(  51)								int _g69 = yIter31->max;
HXDLIN(  51)								while((_g68 < _g69)){
HXLINE(  51)									_g68 = (_g68 + 1);
HXDLIN(  51)									int dy1 = (_g68 - 1);
HXDLIN(  51)									{
HXLINE(  51)										int _g70 = rectLeft1;
HXDLIN(  51)										int _g71 = rectRight1;
HXDLIN(  51)										while((_g70 < _g71)){
HXLINE(  51)											_g70 = (_g70 + 1);
HXDLIN(  51)											int dx1 = (_g70 - 1);
HXDLIN(  51)											::Dynamic this54 = this17->image;
HXDLIN(  51)											int index8;
HXDLIN(  51)											if (this17->useVirtualPos) {
HXLINE(  51)												index8 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this17->virtualY) * ( (Float)(this17->width) )) + dx1) - this17->virtualX));
            											}
            											else {
HXLINE(  51)												index8 = ::Std_obj::_hx_int(( (Float)(((dy1 * this17->width) + dx1)) ));
            											}
HXDLIN(  51)											int c9 = ::iterMagic::Iimg_obj::get(this54,index8);
HXDLIN(  51)											int col2;
HXDLIN(  51)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  51)												col2 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            											}
            											else {
HXLINE(  51)												col2 = c9;
            											}
HXDLIN(  51)											bool _hx_tmp17;
HXDLIN(  51)											if (this17->useMask) {
HXLINE(  51)												_hx_tmp17 = ::hx::IsNotNull( this17->mask );
            											}
            											else {
HXLINE(  51)												_hx_tmp17 = false;
            											}
HXDLIN(  51)											if (_hx_tmp17) {
HXLINE(  51)												 ::pi_xy::ImageStruct this55 = this17->mask;
HXDLIN(  51)												::Dynamic this56 = this55->image;
HXDLIN(  51)												int index9;
HXDLIN(  51)												if (this55->useVirtualPos) {
HXLINE(  51)													index9 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this55->virtualY) * ( (Float)(this55->width) )) + dx1) - this55->virtualX));
            												}
            												else {
HXLINE(  51)													index9 = ::Std_obj::_hx_int(( (Float)(((dy1 * this55->width) + dx1)) ));
            												}
HXDLIN(  51)												int c10 = ::iterMagic::Iimg_obj::get(this56,index9);
HXDLIN(  51)												int v8;
HXDLIN(  51)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  51)													v8 = ((((((c10 >> 24) & 255) << 24) | ((c10 & 255) << 16)) | (((c10 >> 8) & 255) << 8)) | ((c10 >> 16) & 255));
            												}
            												else {
HXLINE(  51)													v8 = c10;
            												}
HXDLIN(  51)												int maskPixel1 = v8;
HXDLIN(  51)												int this57 = col2;
HXDLIN(  51)												if ((maskPixel1 == 0)) {
HXLINE(  51)													col2 = this57;
            												}
            												else {
HXLINE(  51)													Float m01;
HXDLIN(  51)													int this58 = ((maskPixel1 >> 24) & 255);
HXDLIN(  51)													if ((this58 == 0)) {
HXLINE(  51)														m01 = ((Float)0.);
            													}
            													else {
HXLINE(  51)														m01 = (( (Float)(this58) ) / ( (Float)(255) ));
            													}
HXDLIN(  51)													Float m11;
HXDLIN(  51)													int this59 = ((maskPixel1 >> 16) & 255);
HXDLIN(  51)													if ((this59 == 0)) {
HXLINE(  51)														m11 = ((Float)0.);
            													}
            													else {
HXLINE(  51)														m11 = (( (Float)(this59) ) / ( (Float)(255) ));
            													}
HXDLIN(  51)													Float m21;
HXDLIN(  51)													int this60 = ((maskPixel1 >> 8) & 255);
HXDLIN(  51)													if ((this60 == 0)) {
HXLINE(  51)														m21 = ((Float)0.);
            													}
            													else {
HXLINE(  51)														m21 = (( (Float)(this60) ) / ( (Float)(255) ));
            													}
HXDLIN(  51)													Float m31;
HXDLIN(  51)													int this61 = (maskPixel1 & 255);
HXDLIN(  51)													if ((this61 == 0)) {
HXLINE(  51)														m31 = ((Float)0.);
            													}
            													else {
HXLINE(  51)														m31 = (( (Float)(this61) ) / ( (Float)(255) ));
            													}
HXDLIN(  51)													int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this57 >> 24) & 255)) )));
HXDLIN(  51)													int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this57 >> 16) & 255)) )));
HXDLIN(  51)													int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this57 >> 8) & 255)) )));
HXDLIN(  51)													int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this57 & 255)) )));
HXDLIN(  51)													col2 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            												}
            											}
HXDLIN(  51)											if ((col2 != 0)) {
HXLINE(  51)												int x9 = (dx1 - rectLeft1);
HXDLIN(  51)												int y8 = (dy1 - rectTop1);
HXDLIN(  51)												int c11 = col2;
HXDLIN(  51)												bool _hx_tmp18;
HXDLIN(  51)												if ((((c11 >> 24) & 255) < 254)) {
HXLINE(  51)													_hx_tmp18 = undoImage3->transparent;
            												}
            												else {
HXLINE(  51)													_hx_tmp18 = false;
            												}
HXDLIN(  51)												if (_hx_tmp18) {
HXLINE(  51)													int location3;
HXDLIN(  51)													if (undoImage3->useVirtualPos) {
HXLINE(  51)														location3 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x9) - undoImage3->virtualX));
            													}
            													else {
HXLINE(  51)														location3 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage3->width) + x9)) ));
            													}
HXDLIN(  51)													int this62 = ::iterMagic::Iimg_obj::get(undoImage3->image,location3);
HXDLIN(  51)													int this63;
HXDLIN(  51)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  51)														this63 = ((((((this62 >> 24) & 255) << 24) | ((this62 & 255) << 16)) | (((this62 >> 8) & 255) << 8)) | ((this62 >> 16) & 255));
            													}
            													else {
HXLINE(  51)														this63 = this62;
            													}
HXDLIN(  51)													Float a14;
HXDLIN(  51)													int this64 = ((this63 >> 24) & 255);
HXDLIN(  51)													if ((this64 == 0)) {
HXLINE(  51)														a14 = ((Float)0.);
            													}
            													else {
HXLINE(  51)														a14 = (( (Float)(this64) ) / ( (Float)(255) ));
            													}
HXDLIN(  51)													Float r13;
HXDLIN(  51)													int this65 = ((this63 >> 16) & 255);
HXDLIN(  51)													if ((this65 == 0)) {
HXLINE(  51)														r13 = ((Float)0.);
            													}
            													else {
HXLINE(  51)														r13 = (( (Float)(this65) ) / ( (Float)(255) ));
            													}
HXDLIN(  51)													Float g13;
HXDLIN(  51)													int this66 = ((this63 >> 8) & 255);
HXDLIN(  51)													if ((this66 == 0)) {
HXLINE(  51)														g13 = ((Float)0.);
            													}
            													else {
HXLINE(  51)														g13 = (( (Float)(this66) ) / ( (Float)(255) ));
            													}
HXDLIN(  51)													Float b110;
HXDLIN(  51)													int this67 = (this63 & 255);
HXDLIN(  51)													if ((this67 == 0)) {
HXLINE(  51)														b110 = ((Float)0.);
            													}
            													else {
HXLINE(  51)														b110 = (( (Float)(this67) ) / ( (Float)(255) ));
            													}
HXDLIN(  51)													Float a23;
HXDLIN(  51)													int this68 = ((col2 >> 24) & 255);
HXDLIN(  51)													if ((this68 == 0)) {
HXLINE(  51)														a23 = ((Float)0.);
            													}
            													else {
HXLINE(  51)														a23 = (( (Float)(this68) ) / ( (Float)(255) ));
            													}
HXDLIN(  51)													Float r23;
HXDLIN(  51)													int this69 = ((col2 >> 16) & 255);
HXDLIN(  51)													if ((this69 == 0)) {
HXLINE(  51)														r23 = ((Float)0.);
            													}
            													else {
HXLINE(  51)														r23 = (( (Float)(this69) ) / ( (Float)(255) ));
            													}
HXDLIN(  51)													Float g23;
HXDLIN(  51)													int this70 = ((col2 >> 8) & 255);
HXDLIN(  51)													if ((this70 == 0)) {
HXLINE(  51)														g23 = ((Float)0.);
            													}
            													else {
HXLINE(  51)														g23 = (( (Float)(this70) ) / ( (Float)(255) ));
            													}
HXDLIN(  51)													Float b24;
HXDLIN(  51)													int this71 = (col2 & 255);
HXDLIN(  51)													if ((this71 == 0)) {
HXLINE(  51)														b24 = ((Float)0.);
            													}
            													else {
HXLINE(  51)														b24 = (( (Float)(this71) ) / ( (Float)(255) ));
            													}
HXDLIN(  51)													Float a33 = (a14 * (( (Float)(1) ) - a23));
HXDLIN(  51)													int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  51)													int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  51)													int b20 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a33) + (b24 * a23))));
HXDLIN(  51)													int a15 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  51)													int blended3 = ((((a15 << 24) | (r5 << 16)) | (g5 << 8)) | b20);
HXDLIN(  51)													{
HXLINE(  51)														int _hx_tmp19;
HXDLIN(  51)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  51)															_hx_tmp19 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            														}
            														else {
HXLINE(  51)															_hx_tmp19 = blended3;
            														}
HXDLIN(  51)														::iterMagic::Iimg_obj::set(undoImage3->image,location3,_hx_tmp19);
            													}
            												}
            												else {
HXLINE(  51)													::Dynamic this72 = undoImage3->image;
HXDLIN(  51)													int index10;
HXDLIN(  51)													if (undoImage3->useVirtualPos) {
HXLINE(  51)														index10 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x9) - undoImage3->virtualX));
            													}
            													else {
HXLINE(  51)														index10 = ::Std_obj::_hx_int(( (Float)(((y8 * undoImage3->width) + x9)) ));
            													}
HXDLIN(  51)													int _hx_tmp20;
HXDLIN(  51)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  51)														_hx_tmp20 = ((((((c11 >> 24) & 255) << 24) | ((c11 & 255) << 16)) | (((c11 >> 8) & 255) << 8)) | ((c11 >> 16) & 255));
            													}
            													else {
HXLINE(  51)														_hx_tmp20 = c11;
            													}
HXDLIN(  51)													::iterMagic::Iimg_obj::set(this72,index10,_hx_tmp20);
            												}
            											}
            											else {
HXLINE(  51)												if (forceClear1) {
HXLINE(  51)													::Dynamic this73 = undoImage3->image;
HXDLIN(  51)													int x10 = (dx1 - rectLeft1);
HXDLIN(  51)													int y9 = (dy1 - rectTop1);
HXDLIN(  51)													int index11;
HXDLIN(  51)													if (undoImage3->useVirtualPos) {
HXLINE(  51)														index11 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x10) - undoImage3->virtualX));
            													}
            													else {
HXLINE(  51)														index11 = ::Std_obj::_hx_int(( (Float)(((y9 * undoImage3->width) + x10)) ));
            													}
HXDLIN(  51)													::iterMagic::Iimg_obj::set(this73,index11,0);
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  51)					{
HXLINE(  51)						int _g_min2 = xIter31->start;
HXDLIN(  51)						int _g_max2 = xIter31->max;
HXDLIN(  51)						while((_g_min2 < _g_max2)){
HXLINE(  51)							_g_min2 = (_g_min2 + 1);
HXDLIN(  51)							int px1 = (_g_min2 - 1);
HXDLIN(  51)							Float pcx1 = ( (Float)(px1) );
HXDLIN(  51)							{
HXLINE(  51)								int _g_min3 = yIter31->start;
HXDLIN(  51)								int _g_max3 = yIter31->max;
HXDLIN(  51)								while((_g_min3 < _g_max3)){
HXLINE(  51)									_g_min3 = (_g_min3 + 1);
HXDLIN(  51)									int py1 = (_g_min3 - 1);
HXDLIN(  51)									Float pcy1 = (( (Float)(py1) ) - h);
HXDLIN(  51)									Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN(  51)									Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN(  51)									Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN(  51)									Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN(  51)									Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN(  51)									bool _hx_tmp21;
HXDLIN(  51)									bool _hx_tmp22;
HXDLIN(  51)									if ((ratioA1 >= 0)) {
HXLINE(  51)										_hx_tmp22 = (ratioB1 >= 0);
            									}
            									else {
HXLINE(  51)										_hx_tmp22 = false;
            									}
HXDLIN(  51)									if (_hx_tmp22) {
HXLINE(  51)										_hx_tmp21 = (ratioC1 >= 0);
            									}
            									else {
HXLINE(  51)										_hx_tmp21 = false;
            									}
HXDLIN(  51)									if (_hx_tmp21) {
HXLINE(  51)										Float u1 = (((au1 * ratioA1) + (bu2 * ratioB1)) + (du * ratioC1));
HXDLIN(  51)										Float v9 = (((av1 * ratioA1) + (bv2 * ratioB1)) + (dv * ratioC1));
HXDLIN(  51)										int x11 = ::Std_obj::_hx_int(((u1 * win_width) + win_x));
HXDLIN(  51)										int y10 = ::Std_obj::_hx_int(((v9 * win_height) + win_y));
HXDLIN(  51)										::Dynamic this74 = thisImage->image;
HXDLIN(  51)										int index12;
HXDLIN(  51)										if (thisImage->useVirtualPos) {
HXLINE(  51)											index12 = ::Std_obj::_hx_int(((((( (Float)(y10) ) - thisImage->virtualY) * ( (Float)(thisImage->width) )) + x11) - thisImage->virtualX));
            										}
            										else {
HXLINE(  51)											index12 = ::Std_obj::_hx_int(( (Float)(((y10 * thisImage->width) + x11)) ));
            										}
HXDLIN(  51)										int c12 = ::iterMagic::Iimg_obj::get(this74,index12);
HXDLIN(  51)										int col3;
HXDLIN(  51)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  51)											col3 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            										}
            										else {
HXLINE(  51)											col3 = c12;
            										}
HXDLIN(  51)										{
HXLINE(  51)											int c13 = col3;
HXDLIN(  51)											bool _hx_tmp23;
HXDLIN(  51)											if ((((c13 >> 24) & 255) < 254)) {
HXLINE(  51)												_hx_tmp23 = this17->transparent;
            											}
            											else {
HXLINE(  51)												_hx_tmp23 = false;
            											}
HXDLIN(  51)											if (_hx_tmp23) {
HXLINE(  51)												int location4;
HXDLIN(  51)												if (this17->useVirtualPos) {
HXLINE(  51)													location4 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this17->virtualY) * ( (Float)(this17->width) )) + px1) - this17->virtualX));
            												}
            												else {
HXLINE(  51)													location4 = ::Std_obj::_hx_int(( (Float)(((py1 * this17->width) + px1)) ));
            												}
HXDLIN(  51)												int this75 = ::iterMagic::Iimg_obj::get(this17->image,location4);
HXDLIN(  51)												int this76;
HXDLIN(  51)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  51)													this76 = ((((((this75 >> 24) & 255) << 24) | ((this75 & 255) << 16)) | (((this75 >> 8) & 255) << 8)) | ((this75 >> 16) & 255));
            												}
            												else {
HXLINE(  51)													this76 = this75;
            												}
HXDLIN(  51)												Float a16;
HXDLIN(  51)												int this77 = ((this76 >> 24) & 255);
HXDLIN(  51)												if ((this77 == 0)) {
HXLINE(  51)													a16 = ((Float)0.);
            												}
            												else {
HXLINE(  51)													a16 = (( (Float)(this77) ) / ( (Float)(255) ));
            												}
HXDLIN(  51)												Float r14;
HXDLIN(  51)												int this78 = ((this76 >> 16) & 255);
HXDLIN(  51)												if ((this78 == 0)) {
HXLINE(  51)													r14 = ((Float)0.);
            												}
            												else {
HXLINE(  51)													r14 = (( (Float)(this78) ) / ( (Float)(255) ));
            												}
HXDLIN(  51)												Float g14;
HXDLIN(  51)												int this79 = ((this76 >> 8) & 255);
HXDLIN(  51)												if ((this79 == 0)) {
HXLINE(  51)													g14 = ((Float)0.);
            												}
            												else {
HXLINE(  51)													g14 = (( (Float)(this79) ) / ( (Float)(255) ));
            												}
HXDLIN(  51)												Float b111;
HXDLIN(  51)												int this80 = (this76 & 255);
HXDLIN(  51)												if ((this80 == 0)) {
HXLINE(  51)													b111 = ((Float)0.);
            												}
            												else {
HXLINE(  51)													b111 = (( (Float)(this80) ) / ( (Float)(255) ));
            												}
HXDLIN(  51)												Float a24;
HXDLIN(  51)												int this81 = ((col3 >> 24) & 255);
HXDLIN(  51)												if ((this81 == 0)) {
HXLINE(  51)													a24 = ((Float)0.);
            												}
            												else {
HXLINE(  51)													a24 = (( (Float)(this81) ) / ( (Float)(255) ));
            												}
HXDLIN(  51)												Float r24;
HXDLIN(  51)												int this82 = ((col3 >> 16) & 255);
HXDLIN(  51)												if ((this82 == 0)) {
HXLINE(  51)													r24 = ((Float)0.);
            												}
            												else {
HXLINE(  51)													r24 = (( (Float)(this82) ) / ( (Float)(255) ));
            												}
HXDLIN(  51)												Float g24;
HXDLIN(  51)												int this83 = ((col3 >> 8) & 255);
HXDLIN(  51)												if ((this83 == 0)) {
HXLINE(  51)													g24 = ((Float)0.);
            												}
            												else {
HXLINE(  51)													g24 = (( (Float)(this83) ) / ( (Float)(255) ));
            												}
HXDLIN(  51)												Float b25;
HXDLIN(  51)												int this84 = (col3 & 255);
HXDLIN(  51)												if ((this84 == 0)) {
HXLINE(  51)													b25 = ((Float)0.);
            												}
            												else {
HXLINE(  51)													b25 = (( (Float)(this84) ) / ( (Float)(255) ));
            												}
HXDLIN(  51)												Float a34 = (a16 * (( (Float)(1) ) - a24));
HXDLIN(  51)												int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN(  51)												int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN(  51)												int b26 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a34) + (b25 * a24))));
HXDLIN(  51)												int a17 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN(  51)												int blended4 = ((((a17 << 24) | (r6 << 16)) | (g6 << 8)) | b26);
HXDLIN(  51)												{
HXLINE(  51)													int _hx_tmp24;
HXDLIN(  51)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  51)														_hx_tmp24 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            													}
            													else {
HXLINE(  51)														_hx_tmp24 = blended4;
            													}
HXDLIN(  51)													::iterMagic::Iimg_obj::set(this17->image,location4,_hx_tmp24);
            												}
            											}
            											else {
HXLINE(  51)												::Dynamic this85 = this17->image;
HXDLIN(  51)												int index13;
HXDLIN(  51)												if (this17->useVirtualPos) {
HXLINE(  51)													index13 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this17->virtualY) * ( (Float)(this17->width) )) + px1) - this17->virtualX));
            												}
            												else {
HXLINE(  51)													index13 = ::Std_obj::_hx_int(( (Float)(((py1 * this17->width) + px1)) ));
            												}
HXDLIN(  51)												int _hx_tmp25;
HXDLIN(  51)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  51)													_hx_tmp25 = ((((((c13 >> 24) & 255) << 24) | ((c13 & 255) << 16)) | (((c13 >> 8) & 255) << 8)) | ((c13 >> 16) & 255));
            												}
            												else {
HXLINE(  51)													_hx_tmp25 = c13;
            												}
HXDLIN(  51)												::iterMagic::Iimg_obj::set(this85,index13,_hx_tmp25);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
HXDLIN(  51)					 ::pi_xy::iter::IntIterStart v_yIter31;
HXDLIN(  51)					 ::pi_xy::iter::IntIterStart v_xIter31;
HXDLIN(  51)					int v_undoY1;
HXDLIN(  51)					int v_undoX1;
HXDLIN(  51)					Float v_ty1;
HXDLIN(  51)					Float v_tx1;
HXDLIN(  51)					Float v_t01;
HXDLIN(  51)					Float v_sy1;
HXDLIN(  51)					Float v_sx1;
HXDLIN(  51)					Float v_s01;
HXDLIN(  51)					Float v_A1;
HXDLIN(  51)					Float ax = w1;
HXDLIN(  51)					 ::pi_xy::ImageStruct v_undoImage1 = null();
HXDLIN(  51)					Float bx1 = w1;
HXDLIN(  51)					Float by1 = h;
HXDLIN(  51)					Float cx1 = ( (Float)(0) );
HXDLIN(  51)					Float cy1 = h;
HXDLIN(  51)					bool adjustWinding1 = (((((ax * by1) - (bx1 * ( (Float)(0) ))) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ( (Float)(0) )) - (ax * cy1))) > 0);
HXDLIN(  51)					if (!(adjustWinding1)) {
HXLINE(  51)						Float bx_1 = bx1;
HXDLIN(  51)						Float by_1 = by1;
HXLINE(  24)						bx1 = cx1;
HXLINE(  25)						by1 = cy1;
HXLINE(  26)						cx1 = bx_1;
HXLINE(  27)						cy1 = by_1;
            					}
HXLINE(  51)					Float v_ax1 = ax;
HXDLIN(  51)					Float v_ay1 = ( (Float)(0) );
HXDLIN(  51)					Float v_bx1 = bx1;
HXDLIN(  51)					Float v_by1 = by1;
HXDLIN(  51)					Float v_cx1 = cx1;
HXDLIN(  51)					Float v_cy1 = cy1;
HXDLIN(  51)					bool v_preCalculated1 = true;
HXDLIN(  51)					{
HXLINE(  51)						v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN(  51)						v_sx1 = (v_cy1 - v_ay1);
HXDLIN(  51)						v_sy1 = (v_ax1 - v_cx1);
HXDLIN(  51)						v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN(  51)						v_tx1 = (v_ay1 - v_by1);
HXDLIN(  51)						v_ty1 = (v_bx1 - v_ax1);
HXDLIN(  51)						v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN(  51)						Float a18 = v_ax1;
HXDLIN(  51)						Float b27 = v_bx1;
HXDLIN(  51)						Float c14 = v_cx1;
HXDLIN(  51)						if ((a18 > b27)) {
HXLINE(  51)							if ((a18 > c14)) {
HXLINE(  51)								int min9;
HXDLIN(  51)								if ((b27 > c14)) {
HXLINE(  51)									min9 = ::Math_obj::floor(c14);
            								}
            								else {
HXLINE(  51)									min9 = ::Math_obj::floor(b27);
            								}
HXDLIN(  51)								int ii_min21 = min9;
HXDLIN(  51)								int ii_max21 = ::Math_obj::ceil(a18);
HXDLIN(  51)								v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min21,ii_max21);
            							}
            							else {
HXLINE(  51)								int ii_min22 = ::Math_obj::floor(b27);
HXDLIN(  51)								int ii_max22 = ::Math_obj::ceil(c14);
HXDLIN(  51)								v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min22,ii_max22);
            							}
            						}
            						else {
HXLINE(  51)							if ((b27 > c14)) {
HXLINE(  51)								int min10;
HXDLIN(  51)								if ((a18 > c14)) {
HXLINE(  51)									min10 = ::Math_obj::floor(c14);
            								}
            								else {
HXLINE(  51)									min10 = ::Math_obj::ceil(a18);
            								}
HXDLIN(  51)								int ii_min23 = min10;
HXDLIN(  51)								int ii_max23 = ::Math_obj::ceil(b27);
HXDLIN(  51)								v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min23,ii_max23);
            							}
            							else {
HXLINE(  51)								int ii_min24 = ::Math_obj::floor(a18);
HXDLIN(  51)								int ii_max24 = ::Math_obj::ceil(c14);
HXDLIN(  51)								v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min24,ii_max24);
            							}
            						}
HXDLIN(  51)						Float a19 = v_ay1;
HXDLIN(  51)						Float b28 = v_by1;
HXDLIN(  51)						Float c15 = v_cy1;
HXDLIN(  51)						if ((a19 > b28)) {
HXLINE(  51)							if ((a19 > c15)) {
HXLINE(  51)								int min11;
HXDLIN(  51)								if ((b28 > c15)) {
HXLINE(  51)									min11 = ::Math_obj::floor(c15);
            								}
            								else {
HXLINE(  51)									min11 = ::Math_obj::floor(b28);
            								}
HXDLIN(  51)								int ii_min25 = min11;
HXDLIN(  51)								int ii_max25 = ::Math_obj::ceil(a19);
HXDLIN(  51)								v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min25,ii_max25);
            							}
            							else {
HXLINE(  51)								int ii_min26 = ::Math_obj::floor(b28);
HXDLIN(  51)								int ii_max26 = ::Math_obj::ceil(c15);
HXDLIN(  51)								v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min26,ii_max26);
            							}
            						}
            						else {
HXLINE(  51)							if ((b28 > c15)) {
HXLINE(  51)								int min12;
HXDLIN(  51)								if ((a19 > c15)) {
HXLINE(  51)									min12 = ::Math_obj::floor(c15);
            								}
            								else {
HXLINE(  51)									min12 = ::Math_obj::ceil(a19);
            								}
HXDLIN(  51)								int ii_min27 = min12;
HXDLIN(  51)								int ii_max27 = ::Math_obj::ceil(b28);
HXDLIN(  51)								v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min27,ii_max27);
            							}
            							else {
HXLINE(  51)								int ii_min28 = ::Math_obj::floor(a19);
HXDLIN(  51)								int ii_max28 = ::Math_obj::ceil(c15);
HXDLIN(  51)								v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min28,ii_max28);
            							}
            						}
            					}
HXDLIN(  51)					if (hasUndo1) {
HXLINE(  51)						v_undoImage1 = undoImage3;
HXDLIN(  51)						v_undoX1 = xIter31->start;
HXDLIN(  51)						v_undoY1 = yIter31->start;
            					}
            				}
            			}
HXLINE(  52)			bool _hx_tmp26;
HXDLIN(  52)			if (::hx::IsNotNull( thisImage->mask )) {
HXLINE(  52)				_hx_tmp26 = includeMask;
            			}
            			else {
HXLINE(  52)				_hx_tmp26 = false;
            			}
HXDLIN(  52)			if (_hx_tmp26) {
HXLINE(  53)				 ::pi_xy::ImageStruct v10 = ::pi_xy::transformation::_ScaleImage::ScaleImage_Fields__obj::scalingXY(thisImage->mask,sx,sy,thisImage->mask->transparent,includeMask);
HXDLIN(  53)				nextImage1->useMask = true;
HXDLIN(  53)				nextImage1->mask = v10;
            			}
HXLINE(  55)			return nextImage1;
            		}
HXLINE(  42)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(ScaleImage_Fields__obj,scalingXY,return )


ScaleImage_Fields__obj::ScaleImage_Fields__obj()
{
}

bool ScaleImage_Fields__obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 9:
		if (HX_FIELD_EQ(inName,"scalingXY") ) { outValue = scalingXY_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"scaleUpInteger") ) { outValue = scaleUpInteger_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *ScaleImage_Fields__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *ScaleImage_Fields__obj_sStaticStorageInfo = 0;
#endif

::hx::Class ScaleImage_Fields__obj::__mClass;

static ::String ScaleImage_Fields__obj_sStaticFields[] = {
	HX_("scaleUpInteger",b9,c0,b2,86),
	HX_("scalingXY",08,1b,38,8f),
	::String(null())
};

void ScaleImage_Fields__obj::__register()
{
	ScaleImage_Fields__obj _hx_dummy;
	ScaleImage_Fields__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pi_xy.transformation._ScaleImage.ScaleImage_Fields_",d4,c1,3e,35);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &ScaleImage_Fields__obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(ScaleImage_Fields__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< ScaleImage_Fields__obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ScaleImage_Fields__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ScaleImage_Fields__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pi_xy
} // end namespace transformation
} // end namespace _ScaleImage
