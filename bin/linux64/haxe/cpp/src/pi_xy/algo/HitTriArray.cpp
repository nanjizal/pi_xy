// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_pi_xy_ImageStruct
#include <pi_xy/ImageStruct.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitTri
#include <pi_xy/algo/HitTri.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitTriArray
#include <pi_xy/algo/HitTriArray.h>
#endif
#ifndef INCLUDED_pi_xy_algo_IhitObj
#include <pi_xy/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pi_xy_algo_TriPoints_
#include <pi_xy/algo/TriPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_iter_IntIterStart
#include <pi_xy/iter/IntIterStart.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_5c086d48350fe697_8_new,"pi_xy.algo.HitTriArray","new",0xf275299f,"pi_xy.algo.HitTriArray.new","pi_xy/algo/HitTriArray.hx",8,0xea187311)
HX_LOCAL_STACK_FRAME(_hx_pos_5c086d48350fe697_20_calculateBounds,"pi_xy.algo.HitTriArray","calculateBounds",0x50e95c3a,"pi_xy.algo.HitTriArray.calculateBounds","pi_xy/algo/HitTriArray.hx",20,0xea187311)
HX_LOCAL_STACK_FRAME(_hx_pos_5c086d48350fe697_41_hit,"pi_xy.algo.HitTriArray","hit",0xf2709f92,"pi_xy.algo.HitTriArray.hit","pi_xy/algo/HitTriArray.hx",41,0xea187311)
namespace pi_xy{
namespace algo{

void HitTriArray_obj::__construct(::Array< ::Dynamic> triArr){
            	HX_STACKFRAME(&_hx_pos_5c086d48350fe697_8_new)
HXLINE(  15)		this->boundsCalculated = false;
HXLINE(  12)		this->undoImage = null();
HXLINE(  18)		this->triArr = triArr;
            	}

Dynamic HitTriArray_obj::__CreateEmpty() { return new HitTriArray_obj; }

void *HitTriArray_obj::_hx_vtable = 0;

Dynamic HitTriArray_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< HitTriArray_obj > _hx_result = new HitTriArray_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool HitTriArray_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x03d78a4b;
}

static ::pi_xy::algo::IhitObj_obj _hx_pi_xy_algo_HitTriArray__hx_pi_xy_algo_IhitObj= {
	( bool (::hx::Object::*)(Float,Float))&::pi_xy::algo::HitTriArray_obj::hit,
};

void *HitTriArray_obj::_hx_getInterface(int inHash) {
	switch(inHash) {
		case (int)0x6d20d5d3: return &_hx_pi_xy_algo_HitTriArray__hx_pi_xy_algo_IhitObj;
	}
	#ifdef HXCPP_SCRIPTABLE
	return super::_hx_getInterface(inHash);
	#else
	return 0;
	#endif
}

void HitTriArray_obj::calculateBounds(){
            	HX_GC_STACKFRAME(&_hx_pos_5c086d48350fe697_20_calculateBounds)
HXLINE(  21)		::Array< Float > pxMin = ::Array_obj< Float >::__new(0);
HXLINE(  22)		::Array< Float > pxMax = ::Array_obj< Float >::__new(0);
HXLINE(  23)		::Array< Float > pyMin = ::Array_obj< Float >::__new(0);
HXLINE(  24)		::Array< Float > pyMax = ::Array_obj< Float >::__new(0);
HXLINE(  25)		int count = 0;
HXLINE(  26)		 ::pi_xy::iter::IntIterStart iterBound;
HXLINE(  27)		{
HXLINE(  27)			int _g = 0;
HXDLIN(  27)			::Array< ::Dynamic> _g1 = this->triArr;
HXDLIN(  27)			while((_g < _g1->length)){
HXLINE(  27)				 ::pi_xy::algo::HitTri tri = _g1->__get(_g).StaticCast<  ::pi_xy::algo::HitTri >();
HXDLIN(  27)				_g = (_g + 1);
HXLINE(  28)				iterBound = tri->xIter3;
HXLINE(  29)				pxMin[count] = ( (Float)(iterBound->start) );
HXLINE(  30)				pxMax[count] = ( (Float)(iterBound->max) );
HXLINE(  31)				iterBound = tri->yIter3;
HXLINE(  32)				pxMin[count] = ( (Float)(iterBound->start) );
HXLINE(  33)				pxMax[count] = ( (Float)(iterBound->max) );
HXLINE(  34)				count = (count + 1);
            			}
            		}
HXLINE(  36)		int min = ::Math_obj::floor(pxMin->__get(0));
HXDLIN(  36)		int max = ::Math_obj::ceil(pxMax->__get(0));
HXDLIN(  36)		Float v = ((Float)0.);
HXDLIN(  36)		int _g2 = 1;
HXDLIN(  36)		int _g3 = pxMin->length;
HXDLIN(  36)		while((_g2 < _g3)){
HXLINE(  36)			_g2 = (_g2 + 1);
HXDLIN(  36)			int i = (_g2 - 1);
HXLINE(  57)			v = pxMin->__get(i);
HXLINE(  36)			if ((v < min)) {
HXLINE(  59)				min = ::Math_obj::floor(v);
            			}
HXLINE(  61)			v = pxMax->__get(i);
HXLINE(  36)			if ((v > max)) {
HXLINE(  63)				max = ::Math_obj::ceil(v);
            			}
            		}
HXLINE(  36)		int ii_min = min;
HXDLIN(  36)		int ii_max = max;
HXDLIN(  36)		this->xRange =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXLINE(  37)		int min1 = ::Math_obj::floor(pyMin->__get(0));
HXDLIN(  37)		int max1 = ::Math_obj::ceil(pyMax->__get(0));
HXDLIN(  37)		Float v1 = ((Float)0.);
HXDLIN(  37)		int _g4 = 1;
HXDLIN(  37)		int _g5 = pyMin->length;
HXDLIN(  37)		while((_g4 < _g5)){
HXLINE(  37)			_g4 = (_g4 + 1);
HXDLIN(  37)			int i1 = (_g4 - 1);
HXLINE(  57)			v1 = pyMin->__get(i1);
HXLINE(  37)			if ((v1 < min1)) {
HXLINE(  59)				min1 = ::Math_obj::floor(v1);
            			}
HXLINE(  61)			v1 = pyMax->__get(i1);
HXLINE(  37)			if ((v1 > max1)) {
HXLINE(  63)				max1 = ::Math_obj::ceil(v1);
            			}
            		}
HXLINE(  37)		int ii_min1 = min1;
HXDLIN(  37)		int ii_max1 = max1;
HXDLIN(  37)		this->yRange =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
HXLINE(  38)		this->boundsCalculated = true;
            	}


HX_DEFINE_DYNAMIC_FUNC0(HitTriArray_obj,calculateBounds,(void))

bool HitTriArray_obj::hit(Float x,Float y){
            	HX_GC_STACKFRAME(&_hx_pos_5c086d48350fe697_41_hit)
HXLINE(  42)		if (!(this->boundsCalculated)) {
HXLINE(  42)			::Array< Float > pxMin = ::Array_obj< Float >::__new(0);
HXDLIN(  42)			::Array< Float > pxMax = ::Array_obj< Float >::__new(0);
HXDLIN(  42)			::Array< Float > pyMin = ::Array_obj< Float >::__new(0);
HXDLIN(  42)			::Array< Float > pyMax = ::Array_obj< Float >::__new(0);
HXDLIN(  42)			int count = 0;
HXDLIN(  42)			 ::pi_xy::iter::IntIterStart iterBound;
HXDLIN(  42)			{
HXLINE(  42)				int _g = 0;
HXDLIN(  42)				::Array< ::Dynamic> _g1 = this->triArr;
HXDLIN(  42)				while((_g < _g1->length)){
HXLINE(  42)					 ::pi_xy::algo::HitTri tri = _g1->__get(_g).StaticCast<  ::pi_xy::algo::HitTri >();
HXDLIN(  42)					_g = (_g + 1);
HXLINE(  28)					iterBound = tri->xIter3;
HXLINE(  42)					pxMin[count] = ( (Float)(iterBound->start) );
HXDLIN(  42)					pxMax[count] = ( (Float)(iterBound->max) );
HXLINE(  31)					iterBound = tri->yIter3;
HXLINE(  42)					pxMin[count] = ( (Float)(iterBound->start) );
HXDLIN(  42)					pxMax[count] = ( (Float)(iterBound->max) );
HXDLIN(  42)					count = (count + 1);
            				}
            			}
HXDLIN(  42)			int min = ::Math_obj::floor(pxMin->__get(0));
HXDLIN(  42)			int max = ::Math_obj::ceil(pxMax->__get(0));
HXDLIN(  42)			Float v = ((Float)0.);
HXDLIN(  42)			int _g2 = 1;
HXDLIN(  42)			int _g3 = pxMin->length;
HXDLIN(  42)			while((_g2 < _g3)){
HXLINE(  42)				_g2 = (_g2 + 1);
HXDLIN(  42)				int i = (_g2 - 1);
HXLINE(  57)				v = pxMin->__get(i);
HXLINE(  42)				if ((v < min)) {
HXLINE(  59)					min = ::Math_obj::floor(v);
            				}
HXLINE(  61)				v = pxMax->__get(i);
HXLINE(  42)				if ((v > max)) {
HXLINE(  63)					max = ::Math_obj::ceil(v);
            				}
            			}
HXLINE(  42)			int ii_min = min;
HXDLIN(  42)			int ii_max = max;
HXDLIN(  42)			this->xRange =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  42)			int min1 = ::Math_obj::floor(pyMin->__get(0));
HXDLIN(  42)			int max1 = ::Math_obj::ceil(pyMax->__get(0));
HXDLIN(  42)			Float v1 = ((Float)0.);
HXDLIN(  42)			int _g4 = 1;
HXDLIN(  42)			int _g5 = pyMin->length;
HXDLIN(  42)			while((_g4 < _g5)){
HXLINE(  42)				_g4 = (_g4 + 1);
HXDLIN(  42)				int i1 = (_g4 - 1);
HXLINE(  57)				v1 = pyMin->__get(i1);
HXLINE(  42)				if ((v1 < min1)) {
HXLINE(  59)					min1 = ::Math_obj::floor(v1);
            				}
HXLINE(  61)				v1 = pyMax->__get(i1);
HXLINE(  42)				if ((v1 > max1)) {
HXLINE(  63)					max1 = ::Math_obj::ceil(v1);
            				}
            			}
HXLINE(  42)			int ii_min1 = min1;
HXDLIN(  42)			int ii_max1 = max1;
HXDLIN(  42)			this->yRange =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
HXDLIN(  42)			this->boundsCalculated = true;
            		}
HXLINE(  43)		bool _hx_tmp;
HXDLIN(  43)		 ::pi_xy::iter::IntIterStart this1 = this->xRange;
HXDLIN(  43)		bool _hx_tmp1;
HXDLIN(  43)		if ((x > (this1->start - 1))) {
HXLINE(  43)			_hx_tmp1 = (x < (this1->max + 1));
            		}
            		else {
HXLINE(  43)			_hx_tmp1 = false;
            		}
HXDLIN(  43)		if (_hx_tmp1) {
HXLINE(  43)			 ::pi_xy::iter::IntIterStart this2 = this->yRange;
HXDLIN(  43)			if ((y > (this2->start - 1))) {
HXLINE(  43)				_hx_tmp = (y < (this2->max + 1));
            			}
            			else {
HXLINE(  43)				_hx_tmp = false;
            			}
            		}
            		else {
HXLINE(  43)			_hx_tmp = false;
            		}
HXDLIN(  43)		if (_hx_tmp) {
HXLINE(  44)			bool out = false;
HXLINE(  45)			{
HXLINE(  45)				int _g6 = 0;
HXDLIN(  45)				::Array< ::Dynamic> _g7 = this->triArr;
HXDLIN(  45)				while((_g6 < _g7->length)){
HXLINE(  45)					 ::pi_xy::algo::HitTri tri1 = _g7->__get(_g6).StaticCast<  ::pi_xy::algo::HitTri >();
HXDLIN(  45)					_g6 = (_g6 + 1);
HXLINE(  46)					bool _hx_tmp2;
HXDLIN(  46)					bool _hx_tmp3;
HXDLIN(  46)					 ::pi_xy::iter::IntIterStart this3 = tri1->xIter3;
HXDLIN(  46)					bool _hx_tmp4;
HXDLIN(  46)					if ((x > (this3->start - 1))) {
HXLINE(  46)						_hx_tmp4 = (x < (this3->max + 1));
            					}
            					else {
HXLINE(  46)						_hx_tmp4 = false;
            					}
HXDLIN(  46)					if (_hx_tmp4) {
HXLINE(  46)						 ::pi_xy::iter::IntIterStart this4 = tri1->yIter3;
HXDLIN(  46)						if ((y > (this4->start - 1))) {
HXLINE(  46)							_hx_tmp3 = (y < (this4->max + 1));
            						}
            						else {
HXLINE(  46)							_hx_tmp3 = false;
            						}
            					}
            					else {
HXLINE(  46)						_hx_tmp3 = false;
            					}
HXDLIN(  46)					if (_hx_tmp3) {
HXLINE(  46)						Float s = ((tri1->s0 + (tri1->sx * x)) + (tri1->sy * y));
HXDLIN(  46)						Float t = ((tri1->t0 + (tri1->tx * x)) + (tri1->ty * y));
HXDLIN(  46)						bool _hx_tmp5;
HXDLIN(  46)						if (!((s <= 0))) {
HXLINE(  46)							_hx_tmp5 = (t <= 0);
            						}
            						else {
HXLINE(  46)							_hx_tmp5 = true;
            						}
HXDLIN(  46)						if (_hx_tmp5) {
HXLINE(  46)							_hx_tmp2 = false;
            						}
            						else {
HXLINE(  46)							if (((s + t) < tri1->A)) {
HXLINE(  46)								_hx_tmp2 = true;
            							}
            							else {
HXLINE(  46)								_hx_tmp2 = false;
            							}
            						}
            					}
            					else {
HXLINE(  46)						_hx_tmp2 = false;
            					}
HXDLIN(  46)					if (_hx_tmp2) {
HXLINE(  47)						out = true;
HXLINE(  48)						goto _hx_goto_8;
            					}
            				}
            				_hx_goto_8:;
            			}
HXLINE(  51)			return out;
            		}
            		else {
HXLINE(  53)			return false;
            		}
HXLINE(  43)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC2(HitTriArray_obj,hit,return )


::hx::ObjectPtr< HitTriArray_obj > HitTriArray_obj::__new(::Array< ::Dynamic> triArr) {
	::hx::ObjectPtr< HitTriArray_obj > __this = new HitTriArray_obj();
	__this->__construct(triArr);
	return __this;
}

::hx::ObjectPtr< HitTriArray_obj > HitTriArray_obj::__alloc(::hx::Ctx *_hx_ctx,::Array< ::Dynamic> triArr) {
	HitTriArray_obj *__this = (HitTriArray_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(HitTriArray_obj), true, "pi_xy.algo.HitTriArray"));
	*(void **)__this = HitTriArray_obj::_hx_vtable;
	__this->__construct(triArr);
	return __this;
}

HitTriArray_obj::HitTriArray_obj()
{
}

void HitTriArray_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(HitTriArray);
	HX_MARK_MEMBER_NAME(triArr,"triArr");
	HX_MARK_MEMBER_NAME(xRange,"xRange");
	HX_MARK_MEMBER_NAME(yRange,"yRange");
	HX_MARK_MEMBER_NAME(undoImage,"undoImage");
	HX_MARK_MEMBER_NAME(undoX,"undoX");
	HX_MARK_MEMBER_NAME(undoY,"undoY");
	HX_MARK_MEMBER_NAME(boundsCalculated,"boundsCalculated");
	HX_MARK_END_CLASS();
}

void HitTriArray_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(triArr,"triArr");
	HX_VISIT_MEMBER_NAME(xRange,"xRange");
	HX_VISIT_MEMBER_NAME(yRange,"yRange");
	HX_VISIT_MEMBER_NAME(undoImage,"undoImage");
	HX_VISIT_MEMBER_NAME(undoX,"undoX");
	HX_VISIT_MEMBER_NAME(undoY,"undoY");
	HX_VISIT_MEMBER_NAME(boundsCalculated,"boundsCalculated");
}

::hx::Val HitTriArray_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"hit") ) { return ::hx::Val( hit_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"undoX") ) { return ::hx::Val( undoX ); }
		if (HX_FIELD_EQ(inName,"undoY") ) { return ::hx::Val( undoY ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"triArr") ) { return ::hx::Val( triArr ); }
		if (HX_FIELD_EQ(inName,"xRange") ) { return ::hx::Val( xRange ); }
		if (HX_FIELD_EQ(inName,"yRange") ) { return ::hx::Val( yRange ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"undoImage") ) { return ::hx::Val( undoImage ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"calculateBounds") ) { return ::hx::Val( calculateBounds_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"boundsCalculated") ) { return ::hx::Val( boundsCalculated ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val HitTriArray_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"undoX") ) { undoX=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"undoY") ) { undoY=inValue.Cast< int >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"triArr") ) { triArr=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"xRange") ) { xRange=inValue.Cast<  ::pi_xy::iter::IntIterStart >(); return inValue; }
		if (HX_FIELD_EQ(inName,"yRange") ) { yRange=inValue.Cast<  ::pi_xy::iter::IntIterStart >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"undoImage") ) { undoImage=inValue.Cast<  ::pi_xy::ImageStruct >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"boundsCalculated") ) { boundsCalculated=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void HitTriArray_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("triArr",f6,19,ad,4a));
	outFields->push(HX_("xRange",25,62,20,72));
	outFields->push(HX_("yRange",84,be,7b,d8));
	outFields->push(HX_("undoImage",97,06,98,ec));
	outFields->push(HX_("undoX",b4,99,e3,a6));
	outFields->push(HX_("undoY",b5,99,e3,a6));
	outFields->push(HX_("boundsCalculated",13,33,b1,0c));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo HitTriArray_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(HitTriArray_obj,triArr),HX_("triArr",f6,19,ad,4a)},
	{::hx::fsObject /*  ::pi_xy::iter::IntIterStart */ ,(int)offsetof(HitTriArray_obj,xRange),HX_("xRange",25,62,20,72)},
	{::hx::fsObject /*  ::pi_xy::iter::IntIterStart */ ,(int)offsetof(HitTriArray_obj,yRange),HX_("yRange",84,be,7b,d8)},
	{::hx::fsObject /*  ::pi_xy::ImageStruct */ ,(int)offsetof(HitTriArray_obj,undoImage),HX_("undoImage",97,06,98,ec)},
	{::hx::fsInt,(int)offsetof(HitTriArray_obj,undoX),HX_("undoX",b4,99,e3,a6)},
	{::hx::fsInt,(int)offsetof(HitTriArray_obj,undoY),HX_("undoY",b5,99,e3,a6)},
	{::hx::fsBool,(int)offsetof(HitTriArray_obj,boundsCalculated),HX_("boundsCalculated",13,33,b1,0c)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *HitTriArray_obj_sStaticStorageInfo = 0;
#endif

static ::String HitTriArray_obj_sMemberFields[] = {
	HX_("triArr",f6,19,ad,4a),
	HX_("xRange",25,62,20,72),
	HX_("yRange",84,be,7b,d8),
	HX_("undoImage",97,06,98,ec),
	HX_("undoX",b4,99,e3,a6),
	HX_("undoY",b5,99,e3,a6),
	HX_("boundsCalculated",13,33,b1,0c),
	HX_("calculateBounds",7b,a0,47,1b),
	HX_("hit",53,46,4f,00),
	::String(null()) };

::hx::Class HitTriArray_obj::__mClass;

void HitTriArray_obj::__register()
{
	HitTriArray_obj _hx_dummy;
	HitTriArray_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pi_xy.algo.HitTriArray",2d,6e,e2,3d);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(HitTriArray_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< HitTriArray_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = HitTriArray_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = HitTriArray_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pi_xy
} // end namespace algo
