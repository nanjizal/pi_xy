// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_pi_xy_algo__CirclePixel_CirclePixel_Fields_
#include <pi_xy/algo/_CirclePixel/CirclePixel_Fields_.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_6a9002141fb85704_7_circleError,"pi_xy.algo._CirclePixel.CirclePixel_Fields_","circleError",0x6ed170e4,"pi_xy.algo._CirclePixel.CirclePixel_Fields_.circleError","pi_xy/algo/CirclePixel.hx",7,0xe79505bc)
HX_LOCAL_STACK_FRAME(_hx_pos_6a9002141fb85704_18_getSidesDivisible4,"pi_xy.algo._CirclePixel.CirclePixel_Fields_","getSidesDivisible4",0x4cd8be61,"pi_xy.algo._CirclePixel.CirclePixel_Fields_.getSidesDivisible4","pi_xy/algo/CirclePixel.hx",18,0xe79505bc)
namespace pi_xy{
namespace algo{
namespace _CirclePixel{

void CirclePixel_Fields__obj::__construct() { }

Dynamic CirclePixel_Fields__obj::__CreateEmpty() { return new CirclePixel_Fields__obj; }

void *CirclePixel_Fields__obj::_hx_vtable = 0;

Dynamic CirclePixel_Fields__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< CirclePixel_Fields__obj > _hx_result = new CirclePixel_Fields__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool CirclePixel_Fields__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x4dde40ac;
}

int CirclePixel_Fields__obj::circleError(Float radius, ::Dynamic __o_targetE, ::Dynamic __o_minN, ::Dynamic __o_maxN){
            		 ::Dynamic targetE = __o_targetE;
            		if (::hx::IsNull(__o_targetE)) targetE = ((Float)1.05);
            		 ::Dynamic minN = __o_minN;
            		if (::hx::IsNull(__o_minN)) minN = 12;
            		 ::Dynamic maxN = __o_maxN;
            		if (::hx::IsNull(__o_maxN)) maxN = 500;
            	HX_STACKFRAME(&_hx_pos_6a9002141fb85704_7_circleError)
HXLINE(   8)		int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / radius)))));
HXLINE(   9)		if (::hx::IsLess( result,minN )) {
HXLINE(  10)			return ( (int)(minN) );
            		}
            		else {
HXLINE(  11)			if (::hx::IsGreater( result,maxN )) {
HXLINE(  12)				return ( (int)(maxN) );
            			}
            			else {
HXLINE(  14)				return result;
            			}
            		}
HXLINE(   9)		return 0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(CirclePixel_Fields__obj,circleError,return )

int CirclePixel_Fields__obj::getSidesDivisible4(Float rx,Float ry,::hx::Null< Float >  __o_targetError){
            		Float targetError = __o_targetError.Default(((Float)1.05));
            	HX_STACKFRAME(&_hx_pos_6a9002141fb85704_18_getSidesDivisible4)
HXLINE(  19)		Float rSmall;
HXDLIN(  19)		if ((rx > ry)) {
HXLINE(  19)			rSmall = ry;
            		}
            		else {
HXLINE(  19)			rSmall = rx;
            		}
HXLINE(  20)		 ::Dynamic targetE = targetError;
HXDLIN(  20)		if (::hx::IsNull( targetE )) {
HXLINE(  20)			targetE = ((Float)1.05);
            		}
HXDLIN(  20)		int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN(  20)		int noSides;
HXDLIN(  20)		if ((result < 12)) {
HXLINE(  20)			noSides = 12;
            		}
            		else {
HXLINE(  20)			if ((result > 500)) {
HXLINE(  20)				noSides = 500;
            			}
            			else {
HXLINE(  20)				noSides = result;
            			}
            		}
HXLINE(  21)		return (::Math_obj::ceil((( (Float)(noSides) ) / ( (Float)(4) ))) * 4);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(CirclePixel_Fields__obj,getSidesDivisible4,return )


CirclePixel_Fields__obj::CirclePixel_Fields__obj()
{
}

bool CirclePixel_Fields__obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 11:
		if (HX_FIELD_EQ(inName,"circleError") ) { outValue = circleError_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"getSidesDivisible4") ) { outValue = getSidesDivisible4_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *CirclePixel_Fields__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *CirclePixel_Fields__obj_sStaticStorageInfo = 0;
#endif

::hx::Class CirclePixel_Fields__obj::__mClass;

static ::String CirclePixel_Fields__obj_sStaticFields[] = {
	HX_("circleError",98,4f,02,b6),
	HX_("getSidesDivisible4",2d,de,17,42),
	::String(null())
};

void CirclePixel_Fields__obj::__register()
{
	CirclePixel_Fields__obj _hx_dummy;
	CirclePixel_Fields__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pi_xy.algo._CirclePixel.CirclePixel_Fields_",ba,bf,6b,28);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &CirclePixel_Fields__obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(CirclePixel_Fields__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< CirclePixel_Fields__obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = CirclePixel_Fields__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = CirclePixel_Fields__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pi_xy
} // end namespace algo
} // end namespace _CirclePixel
