// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericCell_Int
#include <haxe/ds/GenericCell_Int.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericStack_Int
#include <haxe/ds/GenericStack_Int.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_iterMagic_ArrIntImg
#include <iterMagic/ArrIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_BytesImg
#include <iterMagic/BytesImg.h>
#endif
#ifndef INCLUDED_iterMagic_Iimg
#include <iterMagic/Iimg.h>
#endif
#ifndef INCLUDED_iterMagic_StackIntImg
#include <iterMagic/StackIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_U32ArrImg
#include <iterMagic/U32ArrImg.h>
#endif
#ifndef INCLUDED_iterMagic_VecIntImg
#include <iterMagic/VecIntImg.h>
#endif
#ifndef INCLUDED_pi_xy_ImageStruct
#include <pi_xy/ImageStruct.h>
#endif
#ifndef INCLUDED_pi_xy__Endian_Endian_Fields_
#include <pi_xy/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitTri
#include <pi_xy/algo/HitTri.h>
#endif
#ifndef INCLUDED_pi_xy_algo_IhitObj
#include <pi_xy/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pi_xy_algo_TriPoints_
#include <pi_xy/algo/TriPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_algo__QuadrantPixel_QuadrantPixel_Fields_
#include <pi_xy/algo/_QuadrantPixel/QuadrantPixel_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_iter_IntIterStart
#include <pi_xy/iter/IntIterStart.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_642238c1f1f2b651_15_solidQuadrant,"pi_xy.algo._QuadrantPixel.QuadrantPixel_Fields_","solidQuadrant",0xd97f183b,"pi_xy.algo._QuadrantPixel.QuadrantPixel_Fields_.solidQuadrant","pi_xy/algo/QuadrantPixel.hx",15,0x442a62a8)
HX_LOCAL_STACK_FRAME(_hx_pos_642238c1f1f2b651_62_tileSolidQuadrant,"pi_xy.algo._QuadrantPixel.QuadrantPixel_Fields_","tileSolidQuadrant",0xb899422d,"pi_xy.algo._QuadrantPixel.QuadrantPixel_Fields_.tileSolidQuadrant","pi_xy/algo/QuadrantPixel.hx",62,0x442a62a8)
namespace pi_xy{
namespace algo{
namespace _QuadrantPixel{

void QuadrantPixel_Fields__obj::__construct() { }

Dynamic QuadrantPixel_Fields__obj::__CreateEmpty() { return new QuadrantPixel_Fields__obj; }

void *QuadrantPixel_Fields__obj::_hx_vtable = 0;

Dynamic QuadrantPixel_Fields__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< QuadrantPixel_Fields__obj > _hx_result = new QuadrantPixel_Fields__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool QuadrantPixel_Fields__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x0433d42c;
}

void QuadrantPixel_Fields__obj::solidQuadrant( ::pi_xy::ImageStruct pixelimage,Float cx,Float cy,Float rx,Float ry,Float startAngle,int color, ::Dynamic phi, ::Dynamic __o_targetError){
            		 ::Dynamic targetError = __o_targetError;
            		if (::hx::IsNull(__o_targetError)) targetError = ((Float)1.05);
            	HX_GC_STACKFRAME(&_hx_pos_642238c1f1f2b651_15_solidQuadrant)
HXLINE(  16)		Float rSmall;
HXDLIN(  16)		if ((rx > ry)) {
HXLINE(  16)			rSmall = ry;
            		}
            		else {
HXLINE(  16)			rSmall = rx;
            		}
HXDLIN(  16)		 ::Dynamic targetE = ( (Float)(targetError) );
HXDLIN(  16)		if (::hx::IsNull( targetE )) {
HXLINE(  20)			targetE = ((Float)1.05);
            		}
HXLINE(  16)		int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN(  16)		int noSides;
HXDLIN(  16)		if ((result < 12)) {
HXLINE(  16)			noSides = 12;
            		}
            		else {
HXLINE(  16)			if ((result > 500)) {
HXLINE(  16)				noSides = 500;
            			}
            			else {
HXLINE(  16)				noSides = result;
            			}
            		}
HXDLIN(  16)		int sides = (::Math_obj::ceil((( (Float)(noSides) ) / ( (Float)(4) ))) * 4);
HXLINE(  17)		Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides) ));
HXLINE(  18)		Float omega = startAngle;
HXLINE(  19)		int quarter = ::Std_obj::_hx_int((( (Float)(sides) ) / ( (Float)(4) )));
HXLINE(  20)		Float lastX = ((Float)0.);
HXLINE(  21)		Float lastY = ((Float)0.);
HXLINE(  22)		if (::hx::IsNotEq( phi,0 )) {
HXLINE(  23)			lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) )))) + cx);
HXLINE(  24)			lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) )))) + cy);
            		}
            		else {
HXLINE(  26)			lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))));
HXLINE(  27)			lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))));
            		}
HXLINE(  29)		if (::hx::IsNotEq( phi,0 )) {
HXLINE(  30)			Float cphi = ::Math_obj::cos(( (Float)(phi) ));
HXLINE(  31)			Float sphi = ::Math_obj::sin(( (Float)(phi) ));
HXLINE(  32)			{
HXLINE(  32)				int _g = 0;
HXDLIN(  32)				int _g1 = (quarter + 1);
HXDLIN(  32)				while((_g < _g1)){
HXLINE(  32)					_g = (_g + 1);
HXDLIN(  32)					int i = (_g - 1);
HXLINE(  33)					Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega));
HXLINE(  34)					Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega));
HXLINE(  35)					Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXLINE(  36)					Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXLINE(  37)					{
HXLINE(  37)						 ::pi_xy::ImageStruct this1 = pixelimage;
HXDLIN(  37)						bool hasHit = false;
HXDLIN(  37)						bool hasUndo = false;
HXDLIN(  37)						{
HXLINE(  37)							Float bx = lastX;
HXDLIN(  37)							Float by = lastY;
HXDLIN(  37)							Float cx1 = nextX;
HXDLIN(  37)							Float cy1 = nextY;
HXDLIN(  37)							bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN(  37)							if (!(adjustWinding)) {
HXLINE(  37)								Float bx_ = bx;
HXDLIN(  37)								Float by_ = by;
HXLINE(  25)								bx = cx1;
HXLINE(  26)								by = cy1;
HXLINE(  27)								cx1 = bx_;
HXLINE(  28)								cy1 = by_;
            							}
HXLINE(  37)							{
HXLINE(  37)								Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN(  37)								Float sx = (cy1 - cy);
HXDLIN(  37)								Float sy = (cx - cx1);
HXDLIN(  37)								Float t0 = ((cx * by) - (cy * bx));
HXDLIN(  37)								Float tx = (cy - by);
HXDLIN(  37)								Float ty = (bx - cx);
HXDLIN(  37)								Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN(  37)								 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  37)								if ((cx > bx)) {
HXLINE(  37)									if ((cx > cx1)) {
HXLINE(  37)										int min;
HXDLIN(  37)										if ((bx > cx1)) {
HXLINE(  37)											min = ::Math_obj::floor(cx1);
            										}
            										else {
HXLINE(  37)											min = ::Math_obj::floor(bx);
            										}
HXDLIN(  37)										int ii_min = min;
HXDLIN(  37)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  37)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            									}
            									else {
HXLINE(  37)										int ii_min1 = ::Math_obj::floor(bx);
HXDLIN(  37)										int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN(  37)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            									}
            								}
            								else {
HXLINE(  37)									if ((bx > cx1)) {
HXLINE(  37)										int min1;
HXDLIN(  37)										if ((cx > cx1)) {
HXLINE(  37)											min1 = ::Math_obj::floor(cx1);
            										}
            										else {
HXLINE(  37)											min1 = ::Math_obj::ceil(cx);
            										}
HXDLIN(  37)										int ii_min2 = min1;
HXDLIN(  37)										int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN(  37)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            									}
            									else {
HXLINE(  37)										int ii_min3 = ::Math_obj::floor(cx);
HXDLIN(  37)										int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN(  37)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            									}
            								}
HXDLIN(  37)								 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  37)								if ((cy > by)) {
HXLINE(  37)									if ((cy > cy1)) {
HXLINE(  37)										int min2;
HXDLIN(  37)										if ((by > cy1)) {
HXLINE(  37)											min2 = ::Math_obj::floor(cy1);
            										}
            										else {
HXLINE(  37)											min2 = ::Math_obj::floor(by);
            										}
HXDLIN(  37)										int ii_min4 = min2;
HXDLIN(  37)										int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN(  37)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            									}
            									else {
HXLINE(  37)										int ii_min5 = ::Math_obj::floor(by);
HXDLIN(  37)										int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN(  37)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            									}
            								}
            								else {
HXLINE(  37)									if ((by > cy1)) {
HXLINE(  37)										int min3;
HXDLIN(  37)										if ((cy > cy1)) {
HXLINE(  37)											min3 = ::Math_obj::floor(cy1);
            										}
            										else {
HXLINE(  37)											min3 = ::Math_obj::ceil(cy);
            										}
HXDLIN(  37)										int ii_min6 = min3;
HXDLIN(  37)										int ii_max6 = ::Math_obj::ceil(by);
HXDLIN(  37)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            									}
            									else {
HXLINE(  37)										int ii_min7 = ::Math_obj::floor(cy);
HXDLIN(  37)										int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN(  37)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            									}
            								}
HXDLIN(  37)								 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  37)								if (hasUndo) {
HXLINE(  37)									int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  37)									int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  37)									 ::Dynamic imageType = null();
HXDLIN(  37)									 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  37)									if (::hx::IsNull( imageType )) {
HXLINE(  54)										imageType = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE(  37)									::Dynamic undoImage1;
HXDLIN(  37)									switch((int)(( (int)(imageType) ))){
            										case (int)0: {
HXLINE(  37)											 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  37)											 ::iterMagic::BytesImg b = byt;
HXDLIN(  37)											{
HXLINE(  37)												b->width = width;
HXDLIN(  37)												b->height = height;
HXDLIN(  37)												b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  37)												b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  37)												{
HXLINE(  37)													int len = b->length;
HXDLIN(  37)													int w = 0;
HXDLIN(  37)													{
HXLINE(  37)														int _g2 = 0;
HXDLIN(  37)														int _g3 = b->height;
HXDLIN(  37)														while((_g2 < _g3)){
HXLINE(  37)															_g2 = (_g2 + 1);
HXDLIN(  37)															int y = (_g2 - 1);
HXDLIN(  37)															{
HXLINE(  37)																int _g4 = 0;
HXDLIN(  37)																int _g5 = b->width;
HXDLIN(  37)																while((_g4 < _g5)){
HXLINE(  37)																	_g4 = (_g4 + 1);
HXDLIN(  37)																	int x = (_g4 - 1);
HXDLIN(  37)																	{
HXLINE(  37)																		w = (w + 1);
HXDLIN(  37)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  37)																	{
HXLINE(  37)																		w = (w + 1);
HXDLIN(  37)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  37)																	{
HXLINE(  37)																		w = (w + 1);
HXDLIN(  37)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  37)																	{
HXLINE(  37)																		w = (w + 1);
HXDLIN(  37)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  37)											undoImage1 = b;
            										}
            										break;
            										case (int)1: {
HXLINE(  37)											 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  37)											 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  37)											{
HXLINE(  37)												a->width = width;
HXDLIN(  37)												a->height = height;
HXDLIN(  37)												a->data = ::Array_obj< int >::__new(0);
HXDLIN(  37)												a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  37)												{
HXLINE(  37)													int _g6 = 0;
HXDLIN(  37)													int _g7 = a->length;
HXDLIN(  37)													while((_g6 < _g7)){
HXLINE(  37)														_g6 = (_g6 + 1);
HXDLIN(  37)														int i1 = (_g6 - 1);
HXDLIN(  37)														a->data[i1] = 0;
            													}
            												}
            											}
HXDLIN(  37)											undoImage1 = a;
            										}
            										break;
            										case (int)2: {
HXLINE(  37)											 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  37)											 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  37)											{
HXLINE(  37)												b1->width = width;
HXDLIN(  37)												b1->height = height;
HXDLIN(  37)												b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  37)												int size = (b1->length * 4);
HXDLIN(  37)												b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  37)												{
HXLINE(  37)													int _g8 = 0;
HXDLIN(  37)													int _g9 = b1->length;
HXDLIN(  37)													while((_g8 < _g9)){
HXLINE(  37)														_g8 = (_g8 + 1);
HXDLIN(  37)														int i2 = (_g8 - 1);
HXDLIN(  37)														{
HXLINE(  37)															 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  37)															bool undoImage2;
HXDLIN(  37)															if ((i2 >= 0)) {
HXLINE(  37)																undoImage2 = (i2 < (this3->byteLength >> 2));
            															}
            															else {
HXLINE(  37)																undoImage2 = false;
            															}
HXDLIN(  37)															if (undoImage2) {
HXLINE(  37)																 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  37)																int pos = ((i2 << 2) + this3->byteOffset);
HXDLIN(  37)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  37)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  37)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  37)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN(  37)											undoImage1 = b1;
            										}
            										break;
            										case (int)3: {
HXLINE(  37)											 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  37)											 ::iterMagic::VecIntImg v = vec;
HXDLIN(  37)											{
HXLINE(  37)												v->width = width;
HXDLIN(  37)												v->height = height;
HXDLIN(  37)												v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  37)												v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  37)												{
HXLINE(  37)													int _g10 = 0;
HXDLIN(  37)													int _g11 = v->length;
HXDLIN(  37)													while((_g10 < _g11)){
HXLINE(  37)														_g10 = (_g10 + 1);
HXDLIN(  37)														int i3 = (_g10 - 1);
HXDLIN(  37)														v->data->__unsafe_set(i3,0);
            													}
            												}
            											}
HXDLIN(  37)											undoImage1 = v;
            										}
            										break;
            										case (int)4: {
HXLINE(  37)											 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  37)											 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  37)											{
HXLINE(  37)												b2->width = width;
HXDLIN(  37)												b2->height = height;
HXDLIN(  37)												b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  37)												b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  37)												{
HXLINE(  37)													int len1 = b2->length;
HXDLIN(  37)													 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  37)													if (::hx::IsNull( d->head )) {
HXLINE(  37)														int _g12 = 0;
HXDLIN(  37)														int _g13 = len1;
HXDLIN(  37)														while((_g12 < _g13)){
HXLINE(  37)															_g12 = (_g12 + 1);
HXDLIN(  37)															int i4 = (_g12 - 1);
HXDLIN(  37)															d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            														}
            													}
            													else {
HXLINE(  37)														int _g14 = 0;
HXDLIN(  37)														int _g15 = len1;
HXDLIN(  37)														while((_g14 < _g15)){
HXLINE(  37)															_g14 = (_g14 + 1);
HXDLIN(  37)															int i5 = (_g14 - 1);
HXDLIN(  37)															{
HXLINE(  37)																 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  37)																 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  37)																{
HXLINE(  37)																	int _g16 = 0;
HXDLIN(  37)																	int _g17 = i5;
HXDLIN(  37)																	while((_g16 < _g17)){
HXLINE(  37)																		_g16 = (_g16 + 1);
HXDLIN(  37)																		int i6 = (_g16 - 1);
HXLINE( 345)																		prev = l;
HXLINE( 346)																		l = l->next;
            																	}
            																}
HXLINE(  37)																if (::hx::IsNull( prev )) {
HXLINE(  37)																	b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  37)																	l = null();
            																}
            																else {
HXLINE(  37)																	prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  37)																	l = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  37)											undoImage1 = b2;
            										}
            										break;
            									}
HXDLIN(  37)									this2->image = undoImage1;
HXDLIN(  37)									this2->width = width;
HXDLIN(  37)									this2->height = height;
HXDLIN(  37)									this2->imageType = ( (int)(imageType) );
HXDLIN(  37)									undoImage = this2;
HXDLIN(  37)									{
HXLINE(  37)										int rectLeft = xIter3->start;
HXDLIN(  37)										int rectTop = yIter3->start;
HXDLIN(  37)										int rectRight = xIter3->max;
HXDLIN(  37)										bool forceClear = false;
HXDLIN(  37)										{
HXLINE(  37)											int _g18 = rectTop;
HXDLIN(  37)											int _g19 = yIter3->max;
HXDLIN(  37)											while((_g18 < _g19)){
HXLINE(  37)												_g18 = (_g18 + 1);
HXDLIN(  37)												int dy = (_g18 - 1);
HXDLIN(  37)												{
HXLINE(  37)													int _g20 = rectLeft;
HXDLIN(  37)													int _g21 = rectRight;
HXDLIN(  37)													while((_g20 < _g21)){
HXLINE(  37)														_g20 = (_g20 + 1);
HXDLIN(  37)														int dx = (_g20 - 1);
HXDLIN(  37)														::Dynamic this4 = this1->image;
HXDLIN(  37)														int index;
HXDLIN(  37)														if (this1->useVirtualPos) {
HXLINE(  37)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE(  37)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN(  37)														int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN(  37)														int col;
HXDLIN(  37)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  37)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  37)															col = c;
            														}
HXDLIN(  37)														bool _hx_tmp;
HXDLIN(  37)														if (this1->useMask) {
HXLINE(  37)															_hx_tmp = ::hx::IsNotNull( this1->mask );
            														}
            														else {
HXLINE(  37)															_hx_tmp = false;
            														}
HXDLIN(  37)														if (_hx_tmp) {
HXLINE(  37)															 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN(  37)															::Dynamic this6 = this5->image;
HXDLIN(  37)															int index1;
HXDLIN(  37)															if (this5->useVirtualPos) {
HXLINE(  37)																index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx) - this5->virtualX));
            															}
            															else {
HXLINE(  37)																index1 = ::Std_obj::_hx_int(( (Float)(((dy * this5->width) + dx)) ));
            															}
HXDLIN(  37)															int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN(  37)															int v1;
HXDLIN(  37)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  37)																v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            															}
            															else {
HXLINE(  37)																v1 = c1;
            															}
HXDLIN(  37)															int maskPixel = v1;
HXDLIN(  37)															int this7 = col;
HXDLIN(  37)															if ((maskPixel == 0)) {
HXLINE(  37)																col = this7;
            															}
            															else {
HXLINE(  37)																Float m0;
HXDLIN(  37)																int this8 = ((maskPixel >> 24) & 255);
HXDLIN(  37)																if ((this8 == 0)) {
HXLINE(  37)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  37)																	m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  37)																Float m1;
HXDLIN(  37)																int this9 = ((maskPixel >> 16) & 255);
HXDLIN(  37)																if ((this9 == 0)) {
HXLINE(  37)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  37)																	m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  37)																Float m2;
HXDLIN(  37)																int this10 = ((maskPixel >> 8) & 255);
HXDLIN(  37)																if ((this10 == 0)) {
HXLINE(  37)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  37)																	m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  37)																Float m3;
HXDLIN(  37)																int this11 = (maskPixel & 255);
HXDLIN(  37)																if ((this11 == 0)) {
HXLINE(  37)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  37)																	m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  37)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN(  37)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN(  37)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN(  37)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN(  37)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  37)														if ((col != 0)) {
HXLINE(  37)															int x1 = (dx - rectLeft);
HXDLIN(  37)															int y1 = (dy - rectTop);
HXDLIN(  37)															int c2 = col;
HXDLIN(  37)															bool _hx_tmp1;
HXDLIN(  37)															if ((((c2 >> 24) & 255) < 254)) {
HXLINE(  37)																_hx_tmp1 = undoImage->transparent;
            															}
            															else {
HXLINE(  37)																_hx_tmp1 = false;
            															}
HXDLIN(  37)															if (_hx_tmp1) {
HXLINE(  37)																int location;
HXDLIN(  37)																if (undoImage->useVirtualPos) {
HXLINE(  37)																	location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXLINE(  37)																	location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN(  37)																int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN(  37)																int this13;
HXDLIN(  37)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  37)																	this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            																}
            																else {
HXLINE(  37)																	this13 = this12;
            																}
HXDLIN(  37)																Float a1;
HXDLIN(  37)																int this14 = ((this13 >> 24) & 255);
HXDLIN(  37)																if ((this14 == 0)) {
HXLINE(  37)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  37)																	a1 = (( (Float)(this14) ) / ( (Float)(255) ));
            																}
HXDLIN(  37)																Float r1;
HXDLIN(  37)																int this15 = ((this13 >> 16) & 255);
HXDLIN(  37)																if ((this15 == 0)) {
HXLINE(  37)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  37)																	r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																}
HXDLIN(  37)																Float g1;
HXDLIN(  37)																int this16 = ((this13 >> 8) & 255);
HXDLIN(  37)																if ((this16 == 0)) {
HXLINE(  37)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  37)																	g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																}
HXDLIN(  37)																Float b11;
HXDLIN(  37)																int this17 = (this13 & 255);
HXDLIN(  37)																if ((this17 == 0)) {
HXLINE(  37)																	b11 = ((Float)0.);
            																}
            																else {
HXLINE(  37)																	b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            																}
HXDLIN(  37)																Float a2;
HXDLIN(  37)																int this18 = ((col >> 24) & 255);
HXDLIN(  37)																if ((this18 == 0)) {
HXLINE(  37)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  37)																	a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            																}
HXDLIN(  37)																Float r2;
HXDLIN(  37)																int this19 = ((col >> 16) & 255);
HXDLIN(  37)																if ((this19 == 0)) {
HXLINE(  37)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  37)																	r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																}
HXDLIN(  37)																Float g2;
HXDLIN(  37)																int this20 = ((col >> 8) & 255);
HXDLIN(  37)																if ((this20 == 0)) {
HXLINE(  37)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  37)																	g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																}
HXDLIN(  37)																Float b21;
HXDLIN(  37)																int this21 = (col & 255);
HXDLIN(  37)																if ((this21 == 0)) {
HXLINE(  37)																	b21 = ((Float)0.);
            																}
            																else {
HXLINE(  37)																	b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            																}
HXDLIN(  37)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  37)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  37)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  37)																int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  37)																int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  37)																int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  37)																{
HXLINE(  37)																	int _hx_tmp2;
HXDLIN(  37)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  37)																		_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  37)																		_hx_tmp2 = blended;
            																	}
HXDLIN(  37)																	::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																}
            															}
            															else {
HXLINE(  37)																::Dynamic this22 = undoImage->image;
HXDLIN(  37)																int index2;
HXDLIN(  37)																if (undoImage->useVirtualPos) {
HXLINE(  37)																	index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXLINE(  37)																	index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN(  37)																int _hx_tmp3;
HXDLIN(  37)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  37)																	_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																}
            																else {
HXLINE(  37)																	_hx_tmp3 = c2;
            																}
HXDLIN(  37)																::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp3);
            															}
            														}
            														else {
HXLINE(  37)															if (forceClear) {
HXLINE(  37)																::Dynamic this23 = undoImage->image;
HXDLIN(  37)																int x2 = (dx - rectLeft);
HXDLIN(  37)																int y2 = (dy - rectTop);
HXDLIN(  37)																int index3;
HXDLIN(  37)																if (undoImage->useVirtualPos) {
HXLINE(  37)																	index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																}
            																else {
HXLINE(  37)																	index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																}
HXDLIN(  37)																::iterMagic::Iimg_obj::set(this23,index3,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  37)								bool found = false;
HXDLIN(  37)								Float s = ((Float)0.);
HXDLIN(  37)								Float t = ((Float)0.);
HXDLIN(  37)								Float sxx = ((Float)0.);
HXDLIN(  37)								Float txx = ((Float)0.);
HXDLIN(  37)								{
HXLINE(  37)									int _g_min = xIter3->start;
HXDLIN(  37)									int _g_max = xIter3->max;
HXDLIN(  37)									while((_g_min < _g_max)){
HXLINE(  37)										_g_min = (_g_min + 1);
HXDLIN(  37)										int x3 = (_g_min - 1);
HXLINE(  60)										sxx = (sx * ( (Float)(x3) ));
HXLINE(  61)										txx = (tx * ( (Float)(x3) ));
HXLINE(  62)										found = false;
HXLINE(  37)										{
HXLINE(  37)											int _g_min1 = yIter3->start;
HXDLIN(  37)											int _g_max1 = yIter3->max;
HXDLIN(  37)											while((_g_min1 < _g_max1)){
HXLINE(  37)												_g_min1 = (_g_min1 + 1);
HXDLIN(  37)												int y3 = (_g_min1 - 1);
HXLINE(  64)												s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE(  65)												t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE(  37)												bool _hx_tmp4;
HXDLIN(  37)												if (!((s <= 0))) {
HXLINE(  37)													_hx_tmp4 = (t <= 0);
            												}
            												else {
HXLINE(  37)													_hx_tmp4 = true;
            												}
HXDLIN(  37)												if (_hx_tmp4) {
HXLINE(  37)													if (found) {
HXLINE(  37)														goto _hx_goto_12;
            													}
            												}
            												else {
HXLINE(  37)													if (((s + t) < A)) {
HXLINE(  37)														{
HXLINE(  37)															int c3 = color;
HXDLIN(  37)															bool _hx_tmp5;
HXDLIN(  37)															if ((((c3 >> 24) & 255) < 254)) {
HXLINE(  37)																_hx_tmp5 = this1->transparent;
            															}
            															else {
HXLINE(  37)																_hx_tmp5 = false;
            															}
HXDLIN(  37)															if (_hx_tmp5) {
HXLINE(  37)																int location1;
HXDLIN(  37)																if (this1->useVirtualPos) {
HXLINE(  37)																	location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            																}
            																else {
HXLINE(  37)																	location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            																}
HXDLIN(  37)																int this24 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN(  37)																int this25;
HXDLIN(  37)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  37)																	this25 = ((((((this24 >> 24) & 255) << 24) | ((this24 & 255) << 16)) | (((this24 >> 8) & 255) << 8)) | ((this24 >> 16) & 255));
            																}
            																else {
HXLINE(  37)																	this25 = this24;
            																}
HXDLIN(  37)																Float a11;
HXDLIN(  37)																int this26 = ((this25 >> 24) & 255);
HXDLIN(  37)																if ((this26 == 0)) {
HXLINE(  37)																	a11 = ((Float)0.);
            																}
            																else {
HXLINE(  37)																	a11 = (( (Float)(this26) ) / ( (Float)(255) ));
            																}
HXDLIN(  37)																Float r11;
HXDLIN(  37)																int this27 = ((this25 >> 16) & 255);
HXDLIN(  37)																if ((this27 == 0)) {
HXLINE(  37)																	r11 = ((Float)0.);
            																}
            																else {
HXLINE(  37)																	r11 = (( (Float)(this27) ) / ( (Float)(255) ));
            																}
HXDLIN(  37)																Float g11;
HXDLIN(  37)																int this28 = ((this25 >> 8) & 255);
HXDLIN(  37)																if ((this28 == 0)) {
HXLINE(  37)																	g11 = ((Float)0.);
            																}
            																else {
HXLINE(  37)																	g11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																}
HXDLIN(  37)																Float b12;
HXDLIN(  37)																int this29 = (this25 & 255);
HXDLIN(  37)																if ((this29 == 0)) {
HXLINE(  37)																	b12 = ((Float)0.);
            																}
            																else {
HXLINE(  37)																	b12 = (( (Float)(this29) ) / ( (Float)(255) ));
            																}
HXDLIN(  37)																Float a21;
HXDLIN(  37)																int this30 = ((color >> 24) & 255);
HXDLIN(  37)																if ((this30 == 0)) {
HXLINE(  37)																	a21 = ((Float)0.);
            																}
            																else {
HXLINE(  37)																	a21 = (( (Float)(this30) ) / ( (Float)(255) ));
            																}
HXDLIN(  37)																Float r21;
HXDLIN(  37)																int this31 = ((color >> 16) & 255);
HXDLIN(  37)																if ((this31 == 0)) {
HXLINE(  37)																	r21 = ((Float)0.);
            																}
            																else {
HXLINE(  37)																	r21 = (( (Float)(this31) ) / ( (Float)(255) ));
            																}
HXDLIN(  37)																Float g21;
HXDLIN(  37)																int this32 = ((color >> 8) & 255);
HXDLIN(  37)																if ((this32 == 0)) {
HXLINE(  37)																	g21 = ((Float)0.);
            																}
            																else {
HXLINE(  37)																	g21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																}
HXDLIN(  37)																Float b22;
HXDLIN(  37)																int this33 = (color & 255);
HXDLIN(  37)																if ((this33 == 0)) {
HXLINE(  37)																	b22 = ((Float)0.);
            																}
            																else {
HXLINE(  37)																	b22 = (( (Float)(this33) ) / ( (Float)(255) ));
            																}
HXDLIN(  37)																Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  37)																int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  37)																int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  37)																int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  37)																int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  37)																int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  37)																{
HXLINE(  37)																	int _hx_tmp6;
HXDLIN(  37)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  37)																		_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																	}
            																	else {
HXLINE(  37)																		_hx_tmp6 = blended1;
            																	}
HXDLIN(  37)																	::iterMagic::Iimg_obj::set(this1->image,location1,_hx_tmp6);
            																}
            															}
            															else {
HXLINE(  37)																::Dynamic this34 = this1->image;
HXDLIN(  37)																int index4;
HXDLIN(  37)																if (this1->useVirtualPos) {
HXLINE(  37)																	index4 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            																}
            																else {
HXLINE(  37)																	index4 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            																}
HXDLIN(  37)																int _hx_tmp7;
HXDLIN(  37)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  37)																	_hx_tmp7 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            																}
            																else {
HXLINE(  37)																	_hx_tmp7 = c3;
            																}
HXDLIN(  37)																::iterMagic::Iimg_obj::set(this34,index4,_hx_tmp7);
            															}
            														}
HXLINE(  73)														found = true;
            													}
            													else {
HXLINE(  37)														if (found) {
HXLINE(  37)															goto _hx_goto_12;
            														}
            													}
            												}
            											}
            											_hx_goto_12:;
            										}
            									}
            								}
HXDLIN(  37)								if ((hasHit == true)) {
HXLINE(  37)									 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN(  37)									if (hasUndo) {
HXLINE(  37)										v2->undoImage = undoImage;
HXDLIN(  37)										v2->undoX = xIter3->start;
HXDLIN(  37)										v2->undoY = yIter3->start;
            									}
            								}
            							}
            						}
            					}
HXLINE(  38)					lastX = nextX;
HXLINE(  39)					lastY = nextY;
            				}
            			}
            		}
            		else {
HXLINE(  42)			int _g22 = 0;
HXDLIN(  42)			int _g23 = (quarter + 1);
HXDLIN(  42)			while((_g22 < _g23)){
HXLINE(  42)				_g22 = (_g22 + 1);
HXDLIN(  42)				int i7 = (_g22 - 1);
HXLINE(  43)				Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + ((Float)0.0001)) + omega))));
HXLINE(  44)				Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + ((Float)0.0001)) + omega))));
HXLINE(  45)				{
HXLINE(  45)					 ::pi_xy::ImageStruct this35 = pixelimage;
HXDLIN(  45)					bool hasHit1 = false;
HXDLIN(  45)					bool hasUndo1 = false;
HXDLIN(  45)					{
HXLINE(  45)						Float bx1 = lastX;
HXDLIN(  45)						Float by1 = lastY;
HXDLIN(  45)						Float cx2 = nextX1;
HXDLIN(  45)						Float cy2 = nextY1;
HXDLIN(  45)						bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN(  45)						if (!(adjustWinding1)) {
HXLINE(  45)							Float bx_1 = bx1;
HXDLIN(  45)							Float by_1 = by1;
HXLINE(  25)							bx1 = cx2;
HXLINE(  26)							by1 = cy2;
HXLINE(  27)							cx2 = bx_1;
HXLINE(  28)							cy2 = by_1;
            						}
HXLINE(  45)						{
HXLINE(  45)							Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN(  45)							Float sx1 = (cy2 - cy);
HXDLIN(  45)							Float sy1 = (cx - cx2);
HXDLIN(  45)							Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN(  45)							Float tx1 = (cy - by1);
HXDLIN(  45)							Float ty1 = (bx1 - cx);
HXDLIN(  45)							Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN(  45)							 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  45)							if ((cx > bx1)) {
HXLINE(  45)								if ((cx > cx2)) {
HXLINE(  45)									int min4;
HXDLIN(  45)									if ((bx1 > cx2)) {
HXLINE(  45)										min4 = ::Math_obj::floor(cx2);
            									}
            									else {
HXLINE(  45)										min4 = ::Math_obj::floor(bx1);
            									}
HXDLIN(  45)									int ii_min8 = min4;
HXDLIN(  45)									int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN(  45)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            								}
            								else {
HXLINE(  45)									int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN(  45)									int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN(  45)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            								}
            							}
            							else {
HXLINE(  45)								if ((bx1 > cx2)) {
HXLINE(  45)									int min5;
HXDLIN(  45)									if ((cx > cx2)) {
HXLINE(  45)										min5 = ::Math_obj::floor(cx2);
            									}
            									else {
HXLINE(  45)										min5 = ::Math_obj::ceil(cx);
            									}
HXDLIN(  45)									int ii_min10 = min5;
HXDLIN(  45)									int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN(  45)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            								}
            								else {
HXLINE(  45)									int ii_min11 = ::Math_obj::floor(cx);
HXDLIN(  45)									int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN(  45)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            								}
            							}
HXDLIN(  45)							 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  45)							if ((cy > by1)) {
HXLINE(  45)								if ((cy > cy2)) {
HXLINE(  45)									int min6;
HXDLIN(  45)									if ((by1 > cy2)) {
HXLINE(  45)										min6 = ::Math_obj::floor(cy2);
            									}
            									else {
HXLINE(  45)										min6 = ::Math_obj::floor(by1);
            									}
HXDLIN(  45)									int ii_min12 = min6;
HXDLIN(  45)									int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN(  45)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            								}
            								else {
HXLINE(  45)									int ii_min13 = ::Math_obj::floor(by1);
HXDLIN(  45)									int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN(  45)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            								}
            							}
            							else {
HXLINE(  45)								if ((by1 > cy2)) {
HXLINE(  45)									int min7;
HXDLIN(  45)									if ((cy > cy2)) {
HXLINE(  45)										min7 = ::Math_obj::floor(cy2);
            									}
            									else {
HXLINE(  45)										min7 = ::Math_obj::ceil(cy);
            									}
HXDLIN(  45)									int ii_min14 = min7;
HXDLIN(  45)									int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN(  45)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            								}
            								else {
HXLINE(  45)									int ii_min15 = ::Math_obj::floor(cy);
HXDLIN(  45)									int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN(  45)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            								}
            							}
HXDLIN(  45)							 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  45)							if (hasUndo1) {
HXLINE(  45)								int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  45)								int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  45)								 ::Dynamic imageType1 = null();
HXDLIN(  45)								 ::pi_xy::ImageStruct this36 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  45)								if (::hx::IsNull( imageType1 )) {
HXLINE(  54)									imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE(  45)								::Dynamic undoImage4;
HXDLIN(  45)								switch((int)(( (int)(imageType1) ))){
            									case (int)0: {
HXLINE(  45)										 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  45)										 ::iterMagic::BytesImg b5 = byt1;
HXDLIN(  45)										{
HXLINE(  45)											b5->width = width1;
HXDLIN(  45)											b5->height = height1;
HXDLIN(  45)											b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  45)											b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN(  45)											{
HXLINE(  45)												int len2 = b5->length;
HXDLIN(  45)												int w1 = 0;
HXDLIN(  45)												{
HXLINE(  45)													int _g24 = 0;
HXDLIN(  45)													int _g25 = b5->height;
HXDLIN(  45)													while((_g24 < _g25)){
HXLINE(  45)														_g24 = (_g24 + 1);
HXDLIN(  45)														int y4 = (_g24 - 1);
HXDLIN(  45)														{
HXLINE(  45)															int _g26 = 0;
HXDLIN(  45)															int _g27 = b5->width;
HXDLIN(  45)															while((_g26 < _g27)){
HXLINE(  45)																_g26 = (_g26 + 1);
HXDLIN(  45)																int x4 = (_g26 - 1);
HXDLIN(  45)																{
HXLINE(  45)																	w1 = (w1 + 1);
HXDLIN(  45)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  45)																{
HXLINE(  45)																	w1 = (w1 + 1);
HXDLIN(  45)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  45)																{
HXLINE(  45)																	w1 = (w1 + 1);
HXDLIN(  45)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  45)																{
HXLINE(  45)																	w1 = (w1 + 1);
HXDLIN(  45)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  45)										undoImage4 = b5;
            									}
            									break;
            									case (int)1: {
HXLINE(  45)										 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  45)										 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN(  45)										{
HXLINE(  45)											a6->width = width1;
HXDLIN(  45)											a6->height = height1;
HXDLIN(  45)											a6->data = ::Array_obj< int >::__new(0);
HXDLIN(  45)											a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  45)											{
HXLINE(  45)												int _g28 = 0;
HXDLIN(  45)												int _g29 = a6->length;
HXDLIN(  45)												while((_g28 < _g29)){
HXLINE(  45)													_g28 = (_g28 + 1);
HXDLIN(  45)													int i8 = (_g28 - 1);
HXDLIN(  45)													a6->data[i8] = 0;
            												}
            											}
            										}
HXDLIN(  45)										undoImage4 = a6;
            									}
            									break;
            									case (int)2: {
HXLINE(  45)										 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  45)										 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN(  45)										{
HXLINE(  45)											b6->width = width1;
HXDLIN(  45)											b6->height = height1;
HXDLIN(  45)											b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  45)											int size1 = (b6->length * 4);
HXDLIN(  45)											b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  45)											{
HXLINE(  45)												int _g30 = 0;
HXDLIN(  45)												int _g31 = b6->length;
HXDLIN(  45)												while((_g30 < _g31)){
HXLINE(  45)													_g30 = (_g30 + 1);
HXDLIN(  45)													int i9 = (_g30 - 1);
HXDLIN(  45)													{
HXLINE(  45)														 ::haxe::io::ArrayBufferViewImpl this37 = b6->data;
HXDLIN(  45)														bool undoImage5;
HXDLIN(  45)														if ((i9 >= 0)) {
HXLINE(  45)															undoImage5 = (i9 < (this37->byteLength >> 2));
            														}
            														else {
HXLINE(  45)															undoImage5 = false;
            														}
HXDLIN(  45)														if (undoImage5) {
HXLINE(  45)															 ::haxe::io::Bytes _this1 = this37->bytes;
HXDLIN(  45)															int pos1 = ((i9 << 2) + this37->byteOffset);
HXDLIN(  45)															_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  45)															_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  45)															_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  45)															_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN(  45)										undoImage4 = b6;
            									}
            									break;
            									case (int)3: {
HXLINE(  45)										 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  45)										 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN(  45)										{
HXLINE(  45)											v3->width = width1;
HXDLIN(  45)											v3->height = height1;
HXDLIN(  45)											v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  45)											v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN(  45)											{
HXLINE(  45)												int _g32 = 0;
HXDLIN(  45)												int _g33 = v3->length;
HXDLIN(  45)												while((_g32 < _g33)){
HXLINE(  45)													_g32 = (_g32 + 1);
HXDLIN(  45)													int i10 = (_g32 - 1);
HXDLIN(  45)													v3->data->__unsafe_set(i10,0);
            												}
            											}
            										}
HXDLIN(  45)										undoImage4 = v3;
            									}
            									break;
            									case (int)4: {
HXLINE(  45)										 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  45)										 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN(  45)										{
HXLINE(  45)											b7->width = width1;
HXDLIN(  45)											b7->height = height1;
HXDLIN(  45)											b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  45)											b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  45)											{
HXLINE(  45)												int len3 = b7->length;
HXDLIN(  45)												 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN(  45)												if (::hx::IsNull( d1->head )) {
HXLINE(  45)													int _g34 = 0;
HXDLIN(  45)													int _g35 = len3;
HXDLIN(  45)													while((_g34 < _g35)){
HXLINE(  45)														_g34 = (_g34 + 1);
HXDLIN(  45)														int i11 = (_g34 - 1);
HXDLIN(  45)														d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            													}
            												}
            												else {
HXLINE(  45)													int _g36 = 0;
HXDLIN(  45)													int _g37 = len3;
HXDLIN(  45)													while((_g36 < _g37)){
HXLINE(  45)														_g36 = (_g36 + 1);
HXDLIN(  45)														int i12 = (_g36 - 1);
HXDLIN(  45)														{
HXLINE(  45)															 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN(  45)															 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  45)															{
HXLINE(  45)																int _g38 = 0;
HXDLIN(  45)																int _g39 = i12;
HXDLIN(  45)																while((_g38 < _g39)){
HXLINE(  45)																	_g38 = (_g38 + 1);
HXDLIN(  45)																	int i13 = (_g38 - 1);
HXLINE( 345)																	prev1 = l1;
HXLINE( 346)																	l1 = l1->next;
            																}
            															}
HXLINE(  45)															if (::hx::IsNull( prev1 )) {
HXLINE(  45)																b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  45)																l1 = null();
            															}
            															else {
HXLINE(  45)																prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  45)																l1 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  45)										undoImage4 = b7;
            									}
            									break;
            								}
HXDLIN(  45)								this36->image = undoImage4;
HXDLIN(  45)								this36->width = width1;
HXDLIN(  45)								this36->height = height1;
HXDLIN(  45)								this36->imageType = ( (int)(imageType1) );
HXDLIN(  45)								undoImage3 = this36;
HXDLIN(  45)								{
HXLINE(  45)									int rectLeft1 = xIter31->start;
HXDLIN(  45)									int rectTop1 = yIter31->start;
HXDLIN(  45)									int rectRight1 = xIter31->max;
HXDLIN(  45)									bool forceClear1 = false;
HXDLIN(  45)									{
HXLINE(  45)										int _g40 = rectTop1;
HXDLIN(  45)										int _g41 = yIter31->max;
HXDLIN(  45)										while((_g40 < _g41)){
HXLINE(  45)											_g40 = (_g40 + 1);
HXDLIN(  45)											int dy1 = (_g40 - 1);
HXDLIN(  45)											{
HXLINE(  45)												int _g42 = rectLeft1;
HXDLIN(  45)												int _g43 = rectRight1;
HXDLIN(  45)												while((_g42 < _g43)){
HXLINE(  45)													_g42 = (_g42 + 1);
HXDLIN(  45)													int dx1 = (_g42 - 1);
HXDLIN(  45)													::Dynamic this38 = this35->image;
HXDLIN(  45)													int index5;
HXDLIN(  45)													if (this35->useVirtualPos) {
HXLINE(  45)														index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this35->virtualY) * ( (Float)(this35->width) )) + dx1) - this35->virtualX));
            													}
            													else {
HXLINE(  45)														index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this35->width) + dx1)) ));
            													}
HXDLIN(  45)													int c4 = ::iterMagic::Iimg_obj::get(this38,index5);
HXDLIN(  45)													int col1;
HXDLIN(  45)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  45)														col1 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            													}
            													else {
HXLINE(  45)														col1 = c4;
            													}
HXDLIN(  45)													bool _hx_tmp8;
HXDLIN(  45)													if (this35->useMask) {
HXLINE(  45)														_hx_tmp8 = ::hx::IsNotNull( this35->mask );
            													}
            													else {
HXLINE(  45)														_hx_tmp8 = false;
            													}
HXDLIN(  45)													if (_hx_tmp8) {
HXLINE(  45)														 ::pi_xy::ImageStruct this39 = this35->mask;
HXDLIN(  45)														::Dynamic this40 = this39->image;
HXDLIN(  45)														int index6;
HXDLIN(  45)														if (this39->useVirtualPos) {
HXLINE(  45)															index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this39->virtualY) * ( (Float)(this39->width) )) + dx1) - this39->virtualX));
            														}
            														else {
HXLINE(  45)															index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this39->width) + dx1)) ));
            														}
HXDLIN(  45)														int c5 = ::iterMagic::Iimg_obj::get(this40,index6);
HXDLIN(  45)														int v4;
HXDLIN(  45)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  45)															v4 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            														}
            														else {
HXLINE(  45)															v4 = c5;
            														}
HXDLIN(  45)														int maskPixel1 = v4;
HXDLIN(  45)														int this41 = col1;
HXDLIN(  45)														if ((maskPixel1 == 0)) {
HXLINE(  45)															col1 = this41;
            														}
            														else {
HXLINE(  45)															Float m01;
HXDLIN(  45)															int this42 = ((maskPixel1 >> 24) & 255);
HXDLIN(  45)															if ((this42 == 0)) {
HXLINE(  45)																m01 = ((Float)0.);
            															}
            															else {
HXLINE(  45)																m01 = (( (Float)(this42) ) / ( (Float)(255) ));
            															}
HXDLIN(  45)															Float m11;
HXDLIN(  45)															int this43 = ((maskPixel1 >> 16) & 255);
HXDLIN(  45)															if ((this43 == 0)) {
HXLINE(  45)																m11 = ((Float)0.);
            															}
            															else {
HXLINE(  45)																m11 = (( (Float)(this43) ) / ( (Float)(255) ));
            															}
HXDLIN(  45)															Float m21;
HXDLIN(  45)															int this44 = ((maskPixel1 >> 8) & 255);
HXDLIN(  45)															if ((this44 == 0)) {
HXLINE(  45)																m21 = ((Float)0.);
            															}
            															else {
HXLINE(  45)																m21 = (( (Float)(this44) ) / ( (Float)(255) ));
            															}
HXDLIN(  45)															Float m31;
HXDLIN(  45)															int this45 = (maskPixel1 & 255);
HXDLIN(  45)															if ((this45 == 0)) {
HXLINE(  45)																m31 = ((Float)0.);
            															}
            															else {
HXLINE(  45)																m31 = (( (Float)(this45) ) / ( (Float)(255) ));
            															}
HXDLIN(  45)															int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this41 >> 24) & 255)) )));
HXDLIN(  45)															int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this41 >> 16) & 255)) )));
HXDLIN(  45)															int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this41 >> 8) & 255)) )));
HXDLIN(  45)															int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this41 & 255)) )));
HXDLIN(  45)															col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  45)													if ((col1 != 0)) {
HXLINE(  45)														int x5 = (dx1 - rectLeft1);
HXDLIN(  45)														int y5 = (dy1 - rectTop1);
HXDLIN(  45)														int c6 = col1;
HXDLIN(  45)														bool _hx_tmp9;
HXDLIN(  45)														if ((((c6 >> 24) & 255) < 254)) {
HXLINE(  45)															_hx_tmp9 = undoImage3->transparent;
            														}
            														else {
HXLINE(  45)															_hx_tmp9 = false;
            														}
HXDLIN(  45)														if (_hx_tmp9) {
HXLINE(  45)															int location2;
HXDLIN(  45)															if (undoImage3->useVirtualPos) {
HXLINE(  45)																location2 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            															}
            															else {
HXLINE(  45)																location2 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            															}
HXDLIN(  45)															int this46 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN(  45)															int this47;
HXDLIN(  45)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  45)																this47 = ((((((this46 >> 24) & 255) << 24) | ((this46 & 255) << 16)) | (((this46 >> 8) & 255) << 8)) | ((this46 >> 16) & 255));
            															}
            															else {
HXLINE(  45)																this47 = this46;
            															}
HXDLIN(  45)															Float a12;
HXDLIN(  45)															int this48 = ((this47 >> 24) & 255);
HXDLIN(  45)															if ((this48 == 0)) {
HXLINE(  45)																a12 = ((Float)0.);
            															}
            															else {
HXLINE(  45)																a12 = (( (Float)(this48) ) / ( (Float)(255) ));
            															}
HXDLIN(  45)															Float r12;
HXDLIN(  45)															int this49 = ((this47 >> 16) & 255);
HXDLIN(  45)															if ((this49 == 0)) {
HXLINE(  45)																r12 = ((Float)0.);
            															}
            															else {
HXLINE(  45)																r12 = (( (Float)(this49) ) / ( (Float)(255) ));
            															}
HXDLIN(  45)															Float g12;
HXDLIN(  45)															int this50 = ((this47 >> 8) & 255);
HXDLIN(  45)															if ((this50 == 0)) {
HXLINE(  45)																g12 = ((Float)0.);
            															}
            															else {
HXLINE(  45)																g12 = (( (Float)(this50) ) / ( (Float)(255) ));
            															}
HXDLIN(  45)															Float b13;
HXDLIN(  45)															int this51 = (this47 & 255);
HXDLIN(  45)															if ((this51 == 0)) {
HXLINE(  45)																b13 = ((Float)0.);
            															}
            															else {
HXLINE(  45)																b13 = (( (Float)(this51) ) / ( (Float)(255) ));
            															}
HXDLIN(  45)															Float a22;
HXDLIN(  45)															int this52 = ((col1 >> 24) & 255);
HXDLIN(  45)															if ((this52 == 0)) {
HXLINE(  45)																a22 = ((Float)0.);
            															}
            															else {
HXLINE(  45)																a22 = (( (Float)(this52) ) / ( (Float)(255) ));
            															}
HXDLIN(  45)															Float r22;
HXDLIN(  45)															int this53 = ((col1 >> 16) & 255);
HXDLIN(  45)															if ((this53 == 0)) {
HXLINE(  45)																r22 = ((Float)0.);
            															}
            															else {
HXLINE(  45)																r22 = (( (Float)(this53) ) / ( (Float)(255) ));
            															}
HXDLIN(  45)															Float g22;
HXDLIN(  45)															int this54 = ((col1 >> 8) & 255);
HXDLIN(  45)															if ((this54 == 0)) {
HXLINE(  45)																g22 = ((Float)0.);
            															}
            															else {
HXLINE(  45)																g22 = (( (Float)(this54) ) / ( (Float)(255) ));
            															}
HXDLIN(  45)															Float b23;
HXDLIN(  45)															int this55 = (col1 & 255);
HXDLIN(  45)															if ((this55 == 0)) {
HXLINE(  45)																b23 = ((Float)0.);
            															}
            															else {
HXLINE(  45)																b23 = (( (Float)(this55) ) / ( (Float)(255) ));
            															}
HXDLIN(  45)															Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  45)															int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  45)															int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  45)															int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  45)															int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  45)															int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN(  45)															{
HXLINE(  45)																int _hx_tmp10;
HXDLIN(  45)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  45)																	_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																}
            																else {
HXLINE(  45)																	_hx_tmp10 = blended2;
            																}
HXDLIN(  45)																::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            															}
            														}
            														else {
HXLINE(  45)															::Dynamic this56 = undoImage3->image;
HXDLIN(  45)															int index7;
HXDLIN(  45)															if (undoImage3->useVirtualPos) {
HXLINE(  45)																index7 = ::Std_obj::_hx_int(((((( (Float)(y5) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x5) - undoImage3->virtualX));
            															}
            															else {
HXLINE(  45)																index7 = ::Std_obj::_hx_int(( (Float)(((y5 * undoImage3->width) + x5)) ));
            															}
HXDLIN(  45)															int _hx_tmp11;
HXDLIN(  45)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  45)																_hx_tmp11 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            															}
            															else {
HXLINE(  45)																_hx_tmp11 = c6;
            															}
HXDLIN(  45)															::iterMagic::Iimg_obj::set(this56,index7,_hx_tmp11);
            														}
            													}
            													else {
HXLINE(  45)														if (forceClear1) {
HXLINE(  45)															::Dynamic this57 = undoImage3->image;
HXDLIN(  45)															int x6 = (dx1 - rectLeft1);
HXDLIN(  45)															int y6 = (dy1 - rectTop1);
HXDLIN(  45)															int index8;
HXDLIN(  45)															if (undoImage3->useVirtualPos) {
HXLINE(  45)																index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            															}
            															else {
HXLINE(  45)																index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            															}
HXDLIN(  45)															::iterMagic::Iimg_obj::set(this57,index8,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  45)							bool found1 = false;
HXDLIN(  45)							Float s1 = ((Float)0.);
HXDLIN(  45)							Float t1 = ((Float)0.);
HXDLIN(  45)							Float sxx1 = ((Float)0.);
HXDLIN(  45)							Float txx1 = ((Float)0.);
HXDLIN(  45)							{
HXLINE(  45)								int _g_min2 = xIter31->start;
HXDLIN(  45)								int _g_max2 = xIter31->max;
HXDLIN(  45)								while((_g_min2 < _g_max2)){
HXLINE(  45)									_g_min2 = (_g_min2 + 1);
HXDLIN(  45)									int x7 = (_g_min2 - 1);
HXLINE(  60)									sxx1 = (sx1 * ( (Float)(x7) ));
HXLINE(  61)									txx1 = (tx1 * ( (Float)(x7) ));
HXLINE(  62)									found1 = false;
HXLINE(  45)									{
HXLINE(  45)										int _g_min3 = yIter31->start;
HXDLIN(  45)										int _g_max3 = yIter31->max;
HXDLIN(  45)										while((_g_min3 < _g_max3)){
HXLINE(  45)											_g_min3 = (_g_min3 + 1);
HXDLIN(  45)											int y7 = (_g_min3 - 1);
HXLINE(  64)											s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y7) )));
HXLINE(  65)											t1 = ((t01 + txx1) + (ty1 * ( (Float)(y7) )));
HXLINE(  45)											bool _hx_tmp12;
HXDLIN(  45)											if (!((s1 <= 0))) {
HXLINE(  45)												_hx_tmp12 = (t1 <= 0);
            											}
            											else {
HXLINE(  45)												_hx_tmp12 = true;
            											}
HXDLIN(  45)											if (_hx_tmp12) {
HXLINE(  45)												if (found1) {
HXLINE(  45)													goto _hx_goto_25;
            												}
            											}
            											else {
HXLINE(  45)												if (((s1 + t1) < A1)) {
HXLINE(  45)													{
HXLINE(  45)														int c7 = color;
HXDLIN(  45)														bool _hx_tmp13;
HXDLIN(  45)														if ((((c7 >> 24) & 255) < 254)) {
HXLINE(  45)															_hx_tmp13 = this35->transparent;
            														}
            														else {
HXLINE(  45)															_hx_tmp13 = false;
            														}
HXDLIN(  45)														if (_hx_tmp13) {
HXLINE(  45)															int location3;
HXDLIN(  45)															if (this35->useVirtualPos) {
HXLINE(  45)																location3 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this35->virtualY) * ( (Float)(this35->width) )) + x7) - this35->virtualX));
            															}
            															else {
HXLINE(  45)																location3 = ::Std_obj::_hx_int(( (Float)(((y7 * this35->width) + x7)) ));
            															}
HXDLIN(  45)															int this58 = ::iterMagic::Iimg_obj::get(this35->image,location3);
HXDLIN(  45)															int this59;
HXDLIN(  45)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  45)																this59 = ((((((this58 >> 24) & 255) << 24) | ((this58 & 255) << 16)) | (((this58 >> 8) & 255) << 8)) | ((this58 >> 16) & 255));
            															}
            															else {
HXLINE(  45)																this59 = this58;
            															}
HXDLIN(  45)															Float a13;
HXDLIN(  45)															int this60 = ((this59 >> 24) & 255);
HXDLIN(  45)															if ((this60 == 0)) {
HXLINE(  45)																a13 = ((Float)0.);
            															}
            															else {
HXLINE(  45)																a13 = (( (Float)(this60) ) / ( (Float)(255) ));
            															}
HXDLIN(  45)															Float r13;
HXDLIN(  45)															int this61 = ((this59 >> 16) & 255);
HXDLIN(  45)															if ((this61 == 0)) {
HXLINE(  45)																r13 = ((Float)0.);
            															}
            															else {
HXLINE(  45)																r13 = (( (Float)(this61) ) / ( (Float)(255) ));
            															}
HXDLIN(  45)															Float g13;
HXDLIN(  45)															int this62 = ((this59 >> 8) & 255);
HXDLIN(  45)															if ((this62 == 0)) {
HXLINE(  45)																g13 = ((Float)0.);
            															}
            															else {
HXLINE(  45)																g13 = (( (Float)(this62) ) / ( (Float)(255) ));
            															}
HXDLIN(  45)															Float b14;
HXDLIN(  45)															int this63 = (this59 & 255);
HXDLIN(  45)															if ((this63 == 0)) {
HXLINE(  45)																b14 = ((Float)0.);
            															}
            															else {
HXLINE(  45)																b14 = (( (Float)(this63) ) / ( (Float)(255) ));
            															}
HXDLIN(  45)															Float a23;
HXDLIN(  45)															int this64 = ((color >> 24) & 255);
HXDLIN(  45)															if ((this64 == 0)) {
HXLINE(  45)																a23 = ((Float)0.);
            															}
            															else {
HXLINE(  45)																a23 = (( (Float)(this64) ) / ( (Float)(255) ));
            															}
HXDLIN(  45)															Float r23;
HXDLIN(  45)															int this65 = ((color >> 16) & 255);
HXDLIN(  45)															if ((this65 == 0)) {
HXLINE(  45)																r23 = ((Float)0.);
            															}
            															else {
HXLINE(  45)																r23 = (( (Float)(this65) ) / ( (Float)(255) ));
            															}
HXDLIN(  45)															Float g23;
HXDLIN(  45)															int this66 = ((color >> 8) & 255);
HXDLIN(  45)															if ((this66 == 0)) {
HXLINE(  45)																g23 = ((Float)0.);
            															}
            															else {
HXLINE(  45)																g23 = (( (Float)(this66) ) / ( (Float)(255) ));
            															}
HXDLIN(  45)															Float b24;
HXDLIN(  45)															int this67 = (color & 255);
HXDLIN(  45)															if ((this67 == 0)) {
HXLINE(  45)																b24 = ((Float)0.);
            															}
            															else {
HXLINE(  45)																b24 = (( (Float)(this67) ) / ( (Float)(255) ));
            															}
HXDLIN(  45)															Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  45)															int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  45)															int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  45)															int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN(  45)															int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  45)															int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN(  45)															{
HXLINE(  45)																int _hx_tmp14;
HXDLIN(  45)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  45)																	_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																}
            																else {
HXLINE(  45)																	_hx_tmp14 = blended3;
            																}
HXDLIN(  45)																::iterMagic::Iimg_obj::set(this35->image,location3,_hx_tmp14);
            															}
            														}
            														else {
HXLINE(  45)															::Dynamic this68 = this35->image;
HXDLIN(  45)															int index9;
HXDLIN(  45)															if (this35->useVirtualPos) {
HXLINE(  45)																index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - this35->virtualY) * ( (Float)(this35->width) )) + x7) - this35->virtualX));
            															}
            															else {
HXLINE(  45)																index9 = ::Std_obj::_hx_int(( (Float)(((y7 * this35->width) + x7)) ));
            															}
HXDLIN(  45)															int _hx_tmp15;
HXDLIN(  45)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  45)																_hx_tmp15 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            															}
            															else {
HXLINE(  45)																_hx_tmp15 = c7;
            															}
HXDLIN(  45)															::iterMagic::Iimg_obj::set(this68,index9,_hx_tmp15);
            														}
            													}
HXLINE(  73)													found1 = true;
            												}
            												else {
HXLINE(  45)													if (found1) {
HXLINE(  45)														goto _hx_goto_25;
            													}
            												}
            											}
            										}
            										_hx_goto_25:;
            									}
            								}
            							}
HXDLIN(  45)							if ((hasHit1 == true)) {
HXLINE(  45)								 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN(  45)								if (hasUndo1) {
HXLINE(  45)									v5->undoImage = undoImage3;
HXDLIN(  45)									v5->undoX = xIter31->start;
HXDLIN(  45)									v5->undoY = yIter31->start;
            								}
            							}
            						}
            					}
            				}
HXLINE(  46)				lastX = nextX1;
HXLINE(  47)				lastY = nextY1;
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(QuadrantPixel_Fields__obj,solidQuadrant,(void))

void QuadrantPixel_Fields__obj::tileSolidQuadrant( ::pi_xy::ImageStruct pixelimage,Float cx,Float cy,Float rx,Float ry,Float startAngle, ::pi_xy::ImageStruct tileImage, ::Dynamic phi, ::Dynamic __o_targetError){
            		 ::Dynamic targetError = __o_targetError;
            		if (::hx::IsNull(__o_targetError)) targetError = ((Float)1.05);
            	HX_GC_STACKFRAME(&_hx_pos_642238c1f1f2b651_62_tileSolidQuadrant)
HXLINE(  63)		Float rSmall;
HXDLIN(  63)		if ((rx > ry)) {
HXLINE(  63)			rSmall = ry;
            		}
            		else {
HXLINE(  63)			rSmall = rx;
            		}
HXDLIN(  63)		 ::Dynamic targetE = ( (Float)(targetError) );
HXDLIN(  63)		if (::hx::IsNull( targetE )) {
HXLINE(  20)			targetE = ((Float)1.05);
            		}
HXLINE(  63)		int result = ::Math_obj::ceil((::Math_obj::PI / ::Math_obj::acos((( (Float)(1) ) - (( (Float)(targetE) ) / rSmall)))));
HXDLIN(  63)		int noSides;
HXDLIN(  63)		if ((result < 12)) {
HXLINE(  63)			noSides = 12;
            		}
            		else {
HXLINE(  63)			if ((result > 500)) {
HXLINE(  63)				noSides = 500;
            			}
            			else {
HXLINE(  63)				noSides = result;
            			}
            		}
HXDLIN(  63)		int sides = (::Math_obj::ceil((( (Float)(noSides) ) / ( (Float)(4) ))) * 4);
HXLINE(  64)		Float theta = ((( (Float)(2) ) * ::Math_obj::PI) / ( (Float)(sides) ));
HXLINE(  65)		Float omega = startAngle;
HXLINE(  66)		int quarter = ::Std_obj::_hx_int((( (Float)(sides) ) / ( (Float)(4) )));
HXLINE(  67)		Float lastX = ((Float)0.);
HXLINE(  68)		Float lastY = ((Float)0.);
HXLINE(  69)		if (::hx::IsNotEq( phi,0 )) {
HXLINE(  70)			lastX = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) ))) - ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) )))) + cx);
HXLINE(  71)			lastY = ((((rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::sin(( (Float)(phi) ))) + ((ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))) * ::Math_obj::cos(( (Float)(phi) )))) + cy);
            		}
            		else {
HXLINE(  73)			lastX = (cx + (rx * ::Math_obj::cos(((( (Float)(sides) ) * theta) + omega))));
HXLINE(  74)			lastY = (cy + (ry * ::Math_obj::sin(((( (Float)(sides) ) * theta) + omega))));
            		}
HXLINE(  76)		if (::hx::IsNotEq( phi,0 )) {
HXLINE(  77)			Float cphi = ::Math_obj::cos(( (Float)(phi) ));
HXLINE(  78)			Float sphi = ::Math_obj::sin(( (Float)(phi) ));
HXLINE(  79)			{
HXLINE(  79)				int _g = 0;
HXDLIN(  79)				int _g1 = (quarter + 1);
HXDLIN(  79)				while((_g < _g1)){
HXLINE(  79)					_g = (_g + 1);
HXDLIN(  79)					int i = (_g - 1);
HXLINE(  80)					Float stheta = ::Math_obj::sin((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega));
HXLINE(  81)					Float ctheta = ::Math_obj::cos((((( (Float)(i) ) * theta) + ((Float)0.0001)) + omega));
HXLINE(  82)					Float nextX = ((((rx * ctheta) * cphi) - ((ry * stheta) * sphi)) + cx);
HXLINE(  83)					Float nextY = ((((rx * ctheta) * sphi) + ((ry * stheta) * cphi)) + cy);
HXLINE(  84)					{
HXLINE(  84)						 ::pi_xy::ImageStruct this1 = pixelimage;
HXDLIN(  84)						bool hasHit = false;
HXDLIN(  84)						{
HXLINE(  84)							Float bx = lastX;
HXDLIN(  84)							Float by = lastY;
HXDLIN(  84)							Float cx1 = nextX;
HXDLIN(  84)							Float cy1 = nextY;
HXDLIN(  84)							bool adjustWinding = (((((cx * by) - (bx * cy)) + ((bx * cy1) - (cx1 * by))) + ((cx1 * cy) - (cx * cy1))) > 0);
HXDLIN(  84)							if (!(adjustWinding)) {
HXLINE(  84)								Float bx_ = bx;
HXDLIN(  84)								Float by_ = by;
HXLINE( 187)								bx = cx1;
HXLINE( 188)								by = cy1;
HXLINE( 189)								cx1 = bx_;
HXLINE( 190)								cy1 = by_;
            							}
HXLINE(  84)							{
HXLINE(  84)								bool hasUndo = false;
HXDLIN(  84)								Float s0 = ((cy * cx1) - (cx * cy1));
HXDLIN(  84)								Float sx = (cy1 - cy);
HXDLIN(  84)								Float sy = (cx - cx1);
HXDLIN(  84)								Float t0 = ((cx * by) - (cy * bx));
HXDLIN(  84)								Float tx = (cy - by);
HXDLIN(  84)								Float ty = (bx - cx);
HXDLIN(  84)								Float A = ((((-(by) * cx1) + (cy * (-(bx) + cx1))) + (cx * (by - cy1))) + (bx * cy1));
HXDLIN(  84)								 ::pi_xy::iter::IntIterStart xIter3;
HXDLIN(  84)								if ((cx > bx)) {
HXLINE(  84)									if ((cx > cx1)) {
HXLINE(  84)										int min;
HXDLIN(  84)										if ((bx > cx1)) {
HXLINE(  84)											min = ::Math_obj::floor(cx1);
            										}
            										else {
HXLINE(  84)											min = ::Math_obj::floor(bx);
            										}
HXDLIN(  84)										int ii_min = min;
HXDLIN(  84)										int ii_max = ::Math_obj::ceil(cx);
HXDLIN(  84)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
            									}
            									else {
HXLINE(  84)										int ii_min1 = ::Math_obj::floor(bx);
HXDLIN(  84)										int ii_max1 = ::Math_obj::ceil(cx1);
HXDLIN(  84)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
            									}
            								}
            								else {
HXLINE(  84)									if ((bx > cx1)) {
HXLINE(  84)										int min1;
HXDLIN(  84)										if ((cx > cx1)) {
HXLINE(  84)											min1 = ::Math_obj::floor(cx1);
            										}
            										else {
HXLINE(  84)											min1 = ::Math_obj::ceil(cx);
            										}
HXDLIN(  84)										int ii_min2 = min1;
HXDLIN(  84)										int ii_max2 = ::Math_obj::ceil(bx);
HXDLIN(  84)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            									}
            									else {
HXLINE(  84)										int ii_min3 = ::Math_obj::floor(cx);
HXDLIN(  84)										int ii_max3 = ::Math_obj::ceil(cx1);
HXDLIN(  84)										xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            									}
            								}
HXDLIN(  84)								 ::pi_xy::iter::IntIterStart yIter3;
HXDLIN(  84)								if ((cy > by)) {
HXLINE(  84)									if ((cy > cy1)) {
HXLINE(  84)										int min2;
HXDLIN(  84)										if ((by > cy1)) {
HXLINE(  84)											min2 = ::Math_obj::floor(cy1);
            										}
            										else {
HXLINE(  84)											min2 = ::Math_obj::floor(by);
            										}
HXDLIN(  84)										int ii_min4 = min2;
HXDLIN(  84)										int ii_max4 = ::Math_obj::ceil(cy);
HXDLIN(  84)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            									}
            									else {
HXLINE(  84)										int ii_min5 = ::Math_obj::floor(by);
HXDLIN(  84)										int ii_max5 = ::Math_obj::ceil(cy1);
HXDLIN(  84)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            									}
            								}
            								else {
HXLINE(  84)									if ((by > cy1)) {
HXLINE(  84)										int min3;
HXDLIN(  84)										if ((cy > cy1)) {
HXLINE(  84)											min3 = ::Math_obj::floor(cy1);
            										}
            										else {
HXLINE(  84)											min3 = ::Math_obj::ceil(cy);
            										}
HXDLIN(  84)										int ii_min6 = min3;
HXDLIN(  84)										int ii_max6 = ::Math_obj::ceil(by);
HXDLIN(  84)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            									}
            									else {
HXLINE(  84)										int ii_min7 = ::Math_obj::floor(cy);
HXDLIN(  84)										int ii_max7 = ::Math_obj::ceil(cy1);
HXDLIN(  84)										yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            									}
            								}
HXDLIN(  84)								 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  84)								if (hasUndo) {
HXLINE(  84)									int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  84)									int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  84)									 ::Dynamic imageType = null();
HXDLIN(  84)									 ::pi_xy::ImageStruct this2 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  84)									if (::hx::IsNull( imageType )) {
HXLINE(  54)										imageType = ::pi_xy::ImageStruct_obj::defaultType;
            									}
HXLINE(  84)									::Dynamic undoImage1;
HXDLIN(  84)									switch((int)(( (int)(imageType) ))){
            										case (int)0: {
HXLINE(  84)											 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  84)											 ::iterMagic::BytesImg b = byt;
HXDLIN(  84)											{
HXLINE(  84)												b->width = width;
HXDLIN(  84)												b->height = height;
HXDLIN(  84)												b->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  84)												b->data = ::haxe::io::Bytes_obj::alloc((b->length * 4));
HXDLIN(  84)												{
HXLINE(  84)													int len = b->length;
HXDLIN(  84)													int w = 0;
HXDLIN(  84)													{
HXLINE(  84)														int _g2 = 0;
HXDLIN(  84)														int _g3 = b->height;
HXDLIN(  84)														while((_g2 < _g3)){
HXLINE(  84)															_g2 = (_g2 + 1);
HXDLIN(  84)															int y = (_g2 - 1);
HXDLIN(  84)															{
HXLINE(  84)																int _g4 = 0;
HXDLIN(  84)																int _g5 = b->width;
HXDLIN(  84)																while((_g4 < _g5)){
HXLINE(  84)																	_g4 = (_g4 + 1);
HXDLIN(  84)																	int x = (_g4 - 1);
HXDLIN(  84)																	{
HXLINE(  84)																		w = (w + 1);
HXDLIN(  84)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  84)																	{
HXLINE(  84)																		w = (w + 1);
HXDLIN(  84)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  84)																	{
HXLINE(  84)																		w = (w + 1);
HXDLIN(  84)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
HXDLIN(  84)																	{
HXLINE(  84)																		w = (w + 1);
HXDLIN(  84)																		b->data->b[(w - 1)] = ( (unsigned char)(0) );
            																	}
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  84)											undoImage1 = b;
            										}
            										break;
            										case (int)1: {
HXLINE(  84)											 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  84)											 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(  84)											{
HXLINE(  84)												a->width = width;
HXDLIN(  84)												a->height = height;
HXDLIN(  84)												a->data = ::Array_obj< int >::__new(0);
HXDLIN(  84)												a->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  84)												{
HXLINE(  84)													int _g6 = 0;
HXDLIN(  84)													int _g7 = a->length;
HXDLIN(  84)													while((_g6 < _g7)){
HXLINE(  84)														_g6 = (_g6 + 1);
HXDLIN(  84)														int i1 = (_g6 - 1);
HXDLIN(  84)														a->data[i1] = 0;
            													}
            												}
            											}
HXDLIN(  84)											undoImage1 = a;
            										}
            										break;
            										case (int)2: {
HXLINE(  84)											 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  84)											 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(  84)											{
HXLINE(  84)												b1->width = width;
HXDLIN(  84)												b1->height = height;
HXDLIN(  84)												b1->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  84)												int size = (b1->length * 4);
HXDLIN(  84)												b1->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(  84)												{
HXLINE(  84)													int _g8 = 0;
HXDLIN(  84)													int _g9 = b1->length;
HXDLIN(  84)													while((_g8 < _g9)){
HXLINE(  84)														_g8 = (_g8 + 1);
HXDLIN(  84)														int i2 = (_g8 - 1);
HXDLIN(  84)														{
HXLINE(  84)															 ::haxe::io::ArrayBufferViewImpl this3 = b1->data;
HXDLIN(  84)															bool undoImage2;
HXDLIN(  84)															if ((i2 >= 0)) {
HXLINE(  84)																undoImage2 = (i2 < (this3->byteLength >> 2));
            															}
            															else {
HXLINE(  84)																undoImage2 = false;
            															}
HXDLIN(  84)															if (undoImage2) {
HXLINE(  84)																 ::haxe::io::Bytes _this = this3->bytes;
HXDLIN(  84)																int pos = ((i2 << 2) + this3->byteOffset);
HXDLIN(  84)																_this->b[pos] = ( (unsigned char)(0) );
HXDLIN(  84)																_this->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(  84)																_this->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(  84)																_this->b[(pos + 3)] = ( (unsigned char)(0) );
            															}
            														}
            													}
            												}
            											}
HXDLIN(  84)											undoImage1 = b1;
            										}
            										break;
            										case (int)3: {
HXLINE(  84)											 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  84)											 ::iterMagic::VecIntImg v = vec;
HXDLIN(  84)											{
HXLINE(  84)												v->width = width;
HXDLIN(  84)												v->height = height;
HXDLIN(  84)												v->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  84)												v->data = ::Array_obj< int >::__new(v->length);
HXDLIN(  84)												{
HXLINE(  84)													int _g10 = 0;
HXDLIN(  84)													int _g11 = v->length;
HXDLIN(  84)													while((_g10 < _g11)){
HXLINE(  84)														_g10 = (_g10 + 1);
HXDLIN(  84)														int i3 = (_g10 - 1);
HXDLIN(  84)														v->data->__unsafe_set(i3,0);
            													}
            												}
            											}
HXDLIN(  84)											undoImage1 = v;
            										}
            										break;
            										case (int)4: {
HXLINE(  84)											 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  84)											 ::iterMagic::StackIntImg b2 = sInt;
HXDLIN(  84)											{
HXLINE(  84)												b2->width = width;
HXDLIN(  84)												b2->height = height;
HXDLIN(  84)												b2->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  84)												b2->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  84)												{
HXLINE(  84)													int len1 = b2->length;
HXDLIN(  84)													 ::haxe::ds::GenericStack_Int d = b2->data;
HXDLIN(  84)													if (::hx::IsNull( d->head )) {
HXLINE(  84)														int _g12 = 0;
HXDLIN(  84)														int _g13 = len1;
HXDLIN(  84)														while((_g12 < _g13)){
HXLINE(  84)															_g12 = (_g12 + 1);
HXDLIN(  84)															int i4 = (_g12 - 1);
HXDLIN(  84)															d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            														}
            													}
            													else {
HXLINE(  84)														int _g14 = 0;
HXDLIN(  84)														int _g15 = len1;
HXDLIN(  84)														while((_g14 < _g15)){
HXLINE(  84)															_g14 = (_g14 + 1);
HXDLIN(  84)															int i5 = (_g14 - 1);
HXDLIN(  84)															{
HXLINE(  84)																 ::haxe::ds::GenericCell_Int l = b2->data->head;
HXDLIN(  84)																 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(  84)																{
HXLINE(  84)																	int _g16 = 0;
HXDLIN(  84)																	int _g17 = i5;
HXDLIN(  84)																	while((_g16 < _g17)){
HXLINE(  84)																		_g16 = (_g16 + 1);
HXDLIN(  84)																		int i6 = (_g16 - 1);
HXLINE( 345)																		prev = l;
HXLINE( 346)																		l = l->next;
            																	}
            																}
HXLINE(  84)																if (::hx::IsNull( prev )) {
HXLINE(  84)																	b2->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  84)																	l = null();
            																}
            																else {
HXLINE(  84)																	prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(  84)																	l = null();
            																}
            															}
            														}
            													}
            												}
            											}
HXDLIN(  84)											undoImage1 = b2;
            										}
            										break;
            									}
HXDLIN(  84)									this2->image = undoImage1;
HXDLIN(  84)									this2->width = width;
HXDLIN(  84)									this2->height = height;
HXDLIN(  84)									this2->imageType = ( (int)(imageType) );
HXDLIN(  84)									undoImage = this2;
HXDLIN(  84)									{
HXLINE(  84)										int rectLeft = xIter3->start;
HXDLIN(  84)										int rectTop = yIter3->start;
HXDLIN(  84)										int rectRight = xIter3->max;
HXDLIN(  84)										bool forceClear = false;
HXDLIN(  84)										{
HXLINE(  84)											int _g18 = rectTop;
HXDLIN(  84)											int _g19 = yIter3->max;
HXDLIN(  84)											while((_g18 < _g19)){
HXLINE(  84)												_g18 = (_g18 + 1);
HXDLIN(  84)												int dy = (_g18 - 1);
HXDLIN(  84)												{
HXLINE(  84)													int _g20 = rectLeft;
HXDLIN(  84)													int _g21 = rectRight;
HXDLIN(  84)													while((_g20 < _g21)){
HXLINE(  84)														_g20 = (_g20 + 1);
HXDLIN(  84)														int dx = (_g20 - 1);
HXDLIN(  84)														::Dynamic this4 = this1->image;
HXDLIN(  84)														int index;
HXDLIN(  84)														if (this1->useVirtualPos) {
HXLINE(  84)															index = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this1->virtualY) * ( (Float)(this1->width) )) + dx) - this1->virtualX));
            														}
            														else {
HXLINE(  84)															index = ::Std_obj::_hx_int(( (Float)(((dy * this1->width) + dx)) ));
            														}
HXDLIN(  84)														int c = ::iterMagic::Iimg_obj::get(this4,index);
HXDLIN(  84)														int col;
HXDLIN(  84)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)															col = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            														}
            														else {
HXLINE(  84)															col = c;
            														}
HXDLIN(  84)														bool _hx_tmp;
HXDLIN(  84)														if (this1->useMask) {
HXLINE(  84)															_hx_tmp = ::hx::IsNotNull( this1->mask );
            														}
            														else {
HXLINE(  84)															_hx_tmp = false;
            														}
HXDLIN(  84)														if (_hx_tmp) {
HXLINE(  84)															 ::pi_xy::ImageStruct this5 = this1->mask;
HXDLIN(  84)															::Dynamic this6 = this5->image;
HXDLIN(  84)															int index1;
HXDLIN(  84)															if (this5->useVirtualPos) {
HXLINE(  84)																index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this5->virtualY) * ( (Float)(this5->width) )) + dx) - this5->virtualX));
            															}
            															else {
HXLINE(  84)																index1 = ::Std_obj::_hx_int(( (Float)(((dy * this5->width) + dx)) ));
            															}
HXDLIN(  84)															int c1 = ::iterMagic::Iimg_obj::get(this6,index1);
HXDLIN(  84)															int v1;
HXDLIN(  84)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																v1 = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            															}
            															else {
HXLINE(  84)																v1 = c1;
            															}
HXDLIN(  84)															int maskPixel = v1;
HXDLIN(  84)															int this7 = col;
HXDLIN(  84)															if ((maskPixel == 0)) {
HXLINE(  84)																col = this7;
            															}
            															else {
HXLINE(  84)																Float m0;
HXDLIN(  84)																int this8 = ((maskPixel >> 24) & 255);
HXDLIN(  84)																if ((this8 == 0)) {
HXLINE(  84)																	m0 = ((Float)0.);
            																}
            																else {
HXLINE(  84)																	m0 = (( (Float)(this8) ) / ( (Float)(255) ));
            																}
HXDLIN(  84)																Float m1;
HXDLIN(  84)																int this9 = ((maskPixel >> 16) & 255);
HXDLIN(  84)																if ((this9 == 0)) {
HXLINE(  84)																	m1 = ((Float)0.);
            																}
            																else {
HXLINE(  84)																	m1 = (( (Float)(this9) ) / ( (Float)(255) ));
            																}
HXDLIN(  84)																Float m2;
HXDLIN(  84)																int this10 = ((maskPixel >> 8) & 255);
HXDLIN(  84)																if ((this10 == 0)) {
HXLINE(  84)																	m2 = ((Float)0.);
            																}
            																else {
HXLINE(  84)																	m2 = (( (Float)(this10) ) / ( (Float)(255) ));
            																}
HXDLIN(  84)																Float m3;
HXDLIN(  84)																int this11 = (maskPixel & 255);
HXDLIN(  84)																if ((this11 == 0)) {
HXLINE(  84)																	m3 = ((Float)0.);
            																}
            																else {
HXLINE(  84)																	m3 = (( (Float)(this11) ) / ( (Float)(255) ));
            																}
HXDLIN(  84)																int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this7 >> 24) & 255)) )));
HXDLIN(  84)																int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this7 >> 16) & 255)) )));
HXDLIN(  84)																int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this7 >> 8) & 255)) )));
HXDLIN(  84)																int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this7 & 255)) )));
HXDLIN(  84)																col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            															}
            														}
HXDLIN(  84)														if ((col != 0)) {
HXLINE(  84)															int x1 = (dx - rectLeft);
HXDLIN(  84)															int y1 = (dy - rectTop);
HXDLIN(  84)															int c2 = col;
HXDLIN(  84)															bool _hx_tmp1;
HXDLIN(  84)															if ((((c2 >> 24) & 255) < 254)) {
HXLINE(  84)																_hx_tmp1 = undoImage->transparent;
            															}
            															else {
HXLINE(  84)																_hx_tmp1 = false;
            															}
HXDLIN(  84)															if (_hx_tmp1) {
HXLINE(  84)																int location;
HXDLIN(  84)																if (undoImage->useVirtualPos) {
HXLINE(  84)																	location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXLINE(  84)																	location = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN(  84)																int this12 = ::iterMagic::Iimg_obj::get(undoImage->image,location);
HXDLIN(  84)																int this13;
HXDLIN(  84)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																	this13 = ((((((this12 >> 24) & 255) << 24) | ((this12 & 255) << 16)) | (((this12 >> 8) & 255) << 8)) | ((this12 >> 16) & 255));
            																}
            																else {
HXLINE(  84)																	this13 = this12;
            																}
HXDLIN(  84)																Float a1;
HXDLIN(  84)																int this14 = ((this13 >> 24) & 255);
HXDLIN(  84)																if ((this14 == 0)) {
HXLINE(  84)																	a1 = ((Float)0.);
            																}
            																else {
HXLINE(  84)																	a1 = (( (Float)(this14) ) / ( (Float)(255) ));
            																}
HXDLIN(  84)																Float r1;
HXDLIN(  84)																int this15 = ((this13 >> 16) & 255);
HXDLIN(  84)																if ((this15 == 0)) {
HXLINE(  84)																	r1 = ((Float)0.);
            																}
            																else {
HXLINE(  84)																	r1 = (( (Float)(this15) ) / ( (Float)(255) ));
            																}
HXDLIN(  84)																Float g1;
HXDLIN(  84)																int this16 = ((this13 >> 8) & 255);
HXDLIN(  84)																if ((this16 == 0)) {
HXLINE(  84)																	g1 = ((Float)0.);
            																}
            																else {
HXLINE(  84)																	g1 = (( (Float)(this16) ) / ( (Float)(255) ));
            																}
HXDLIN(  84)																Float b11;
HXDLIN(  84)																int this17 = (this13 & 255);
HXDLIN(  84)																if ((this17 == 0)) {
HXLINE(  84)																	b11 = ((Float)0.);
            																}
            																else {
HXLINE(  84)																	b11 = (( (Float)(this17) ) / ( (Float)(255) ));
            																}
HXDLIN(  84)																Float a2;
HXDLIN(  84)																int this18 = ((col >> 24) & 255);
HXDLIN(  84)																if ((this18 == 0)) {
HXLINE(  84)																	a2 = ((Float)0.);
            																}
            																else {
HXLINE(  84)																	a2 = (( (Float)(this18) ) / ( (Float)(255) ));
            																}
HXDLIN(  84)																Float r2;
HXDLIN(  84)																int this19 = ((col >> 16) & 255);
HXDLIN(  84)																if ((this19 == 0)) {
HXLINE(  84)																	r2 = ((Float)0.);
            																}
            																else {
HXLINE(  84)																	r2 = (( (Float)(this19) ) / ( (Float)(255) ));
            																}
HXDLIN(  84)																Float g2;
HXDLIN(  84)																int this20 = ((col >> 8) & 255);
HXDLIN(  84)																if ((this20 == 0)) {
HXLINE(  84)																	g2 = ((Float)0.);
            																}
            																else {
HXLINE(  84)																	g2 = (( (Float)(this20) ) / ( (Float)(255) ));
            																}
HXDLIN(  84)																Float b21;
HXDLIN(  84)																int this21 = (col & 255);
HXDLIN(  84)																if ((this21 == 0)) {
HXLINE(  84)																	b21 = ((Float)0.);
            																}
            																else {
HXLINE(  84)																	b21 = (( (Float)(this21) ) / ( (Float)(255) ));
            																}
HXDLIN(  84)																Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  84)																int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  84)																int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  84)																int b3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  84)																int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  84)																int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b3);
HXDLIN(  84)																{
HXLINE(  84)																	int _hx_tmp2;
HXDLIN(  84)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																		_hx_tmp2 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            																	}
            																	else {
HXLINE(  84)																		_hx_tmp2 = blended;
            																	}
HXDLIN(  84)																	::iterMagic::Iimg_obj::set(undoImage->image,location,_hx_tmp2);
            																}
            															}
            															else {
HXLINE(  84)																::Dynamic this22 = undoImage->image;
HXDLIN(  84)																int index2;
HXDLIN(  84)																if (undoImage->useVirtualPos) {
HXLINE(  84)																	index2 = ::Std_obj::_hx_int(((((( (Float)(y1) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x1) - undoImage->virtualX));
            																}
            																else {
HXLINE(  84)																	index2 = ::Std_obj::_hx_int(( (Float)(((y1 * undoImage->width) + x1)) ));
            																}
HXDLIN(  84)																int _hx_tmp3;
HXDLIN(  84)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																	_hx_tmp3 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            																}
            																else {
HXLINE(  84)																	_hx_tmp3 = c2;
            																}
HXDLIN(  84)																::iterMagic::Iimg_obj::set(this22,index2,_hx_tmp3);
            															}
            														}
            														else {
HXLINE(  84)															if (forceClear) {
HXLINE(  84)																::Dynamic this23 = undoImage->image;
HXDLIN(  84)																int x2 = (dx - rectLeft);
HXDLIN(  84)																int y2 = (dy - rectTop);
HXDLIN(  84)																int index3;
HXDLIN(  84)																if (undoImage->useVirtualPos) {
HXLINE(  84)																	index3 = ::Std_obj::_hx_int(((((( (Float)(y2) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x2) - undoImage->virtualX));
            																}
            																else {
HXLINE(  84)																	index3 = ::Std_obj::_hx_int(( (Float)(((y2 * undoImage->width) + x2)) ));
            																}
HXDLIN(  84)																::iterMagic::Iimg_obj::set(this23,index3,0);
            															}
            														}
            													}
            												}
            											}
            										}
            									}
            								}
HXDLIN(  84)								bool foundY = false;
HXDLIN(  84)								Float s = ((Float)0.);
HXDLIN(  84)								Float t = ((Float)0.);
HXDLIN(  84)								Float sxx = ((Float)0.);
HXDLIN(  84)								Float txx = ((Float)0.);
HXDLIN(  84)								{
HXLINE(  84)									int _g_min = xIter3->start;
HXDLIN(  84)									int _g_max = xIter3->max;
HXDLIN(  84)									while((_g_min < _g_max)){
HXLINE(  84)										_g_min = (_g_min + 1);
HXDLIN(  84)										int x3 = (_g_min - 1);
HXLINE( 222)										sxx = (sx * ( (Float)(x3) ));
HXLINE( 223)										txx = (tx * ( (Float)(x3) ));
HXLINE( 224)										foundY = false;
HXLINE(  84)										{
HXLINE(  84)											int _g_min1 = yIter3->start;
HXDLIN(  84)											int _g_max1 = yIter3->max;
HXDLIN(  84)											while((_g_min1 < _g_max1)){
HXLINE(  84)												_g_min1 = (_g_min1 + 1);
HXDLIN(  84)												int y3 = (_g_min1 - 1);
HXLINE( 226)												s = ((s0 + sxx) + (sy * ( (Float)(y3) )));
HXLINE( 227)												t = ((t0 + txx) + (ty * ( (Float)(y3) )));
HXLINE(  84)												bool _hx_tmp4;
HXDLIN(  84)												if (!((s <= 0))) {
HXLINE(  84)													_hx_tmp4 = (t <= 0);
            												}
            												else {
HXLINE(  84)													_hx_tmp4 = true;
            												}
HXDLIN(  84)												if (_hx_tmp4) {
HXLINE(  84)													if (foundY) {
HXLINE(  84)														goto _hx_goto_39;
            													}
            												}
            												else {
HXLINE(  84)													if (((s + t) < A)) {
HXLINE(  84)														int x4 = ::hx::Mod(x3,tileImage->width);
HXDLIN(  84)														int y4 = ::hx::Mod(y3,tileImage->height);
HXDLIN(  84)														::Dynamic this24 = tileImage->image;
HXDLIN(  84)														int index4;
HXDLIN(  84)														if (tileImage->useVirtualPos) {
HXLINE(  84)															index4 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x4) - tileImage->virtualX));
            														}
            														else {
HXLINE(  84)															index4 = ::Std_obj::_hx_int(( (Float)(((y4 * tileImage->width) + x4)) ));
            														}
HXDLIN(  84)														int c3 = ::iterMagic::Iimg_obj::get(this24,index4);
HXDLIN(  84)														int color;
HXDLIN(  84)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)															color = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            														}
            														else {
HXLINE(  84)															color = c3;
            														}
HXDLIN(  84)														{
HXLINE(  84)															int c4 = color;
HXDLIN(  84)															bool _hx_tmp5;
HXDLIN(  84)															if ((((c4 >> 24) & 255) < 254)) {
HXLINE(  84)																_hx_tmp5 = this1->transparent;
            															}
            															else {
HXLINE(  84)																_hx_tmp5 = false;
            															}
HXDLIN(  84)															if (_hx_tmp5) {
HXLINE(  84)																int location1;
HXDLIN(  84)																if (this1->useVirtualPos) {
HXLINE(  84)																	location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            																}
            																else {
HXLINE(  84)																	location1 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            																}
HXDLIN(  84)																int this25 = ::iterMagic::Iimg_obj::get(this1->image,location1);
HXDLIN(  84)																int this26;
HXDLIN(  84)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																	this26 = ((((((this25 >> 24) & 255) << 24) | ((this25 & 255) << 16)) | (((this25 >> 8) & 255) << 8)) | ((this25 >> 16) & 255));
            																}
            																else {
HXLINE(  84)																	this26 = this25;
            																}
HXDLIN(  84)																Float a11;
HXDLIN(  84)																int this27 = ((this26 >> 24) & 255);
HXDLIN(  84)																if ((this27 == 0)) {
HXLINE(  84)																	a11 = ((Float)0.);
            																}
            																else {
HXLINE(  84)																	a11 = (( (Float)(this27) ) / ( (Float)(255) ));
            																}
HXDLIN(  84)																Float r11;
HXDLIN(  84)																int this28 = ((this26 >> 16) & 255);
HXDLIN(  84)																if ((this28 == 0)) {
HXLINE(  84)																	r11 = ((Float)0.);
            																}
            																else {
HXLINE(  84)																	r11 = (( (Float)(this28) ) / ( (Float)(255) ));
            																}
HXDLIN(  84)																Float g11;
HXDLIN(  84)																int this29 = ((this26 >> 8) & 255);
HXDLIN(  84)																if ((this29 == 0)) {
HXLINE(  84)																	g11 = ((Float)0.);
            																}
            																else {
HXLINE(  84)																	g11 = (( (Float)(this29) ) / ( (Float)(255) ));
            																}
HXDLIN(  84)																Float b12;
HXDLIN(  84)																int this30 = (this26 & 255);
HXDLIN(  84)																if ((this30 == 0)) {
HXLINE(  84)																	b12 = ((Float)0.);
            																}
            																else {
HXLINE(  84)																	b12 = (( (Float)(this30) ) / ( (Float)(255) ));
            																}
HXDLIN(  84)																Float a21;
HXDLIN(  84)																int this31 = ((color >> 24) & 255);
HXDLIN(  84)																if ((this31 == 0)) {
HXLINE(  84)																	a21 = ((Float)0.);
            																}
            																else {
HXLINE(  84)																	a21 = (( (Float)(this31) ) / ( (Float)(255) ));
            																}
HXDLIN(  84)																Float r21;
HXDLIN(  84)																int this32 = ((color >> 16) & 255);
HXDLIN(  84)																if ((this32 == 0)) {
HXLINE(  84)																	r21 = ((Float)0.);
            																}
            																else {
HXLINE(  84)																	r21 = (( (Float)(this32) ) / ( (Float)(255) ));
            																}
HXDLIN(  84)																Float g21;
HXDLIN(  84)																int this33 = ((color >> 8) & 255);
HXDLIN(  84)																if ((this33 == 0)) {
HXLINE(  84)																	g21 = ((Float)0.);
            																}
            																else {
HXLINE(  84)																	g21 = (( (Float)(this33) ) / ( (Float)(255) ));
            																}
HXDLIN(  84)																Float b22;
HXDLIN(  84)																int this34 = (color & 255);
HXDLIN(  84)																if ((this34 == 0)) {
HXLINE(  84)																	b22 = ((Float)0.);
            																}
            																else {
HXLINE(  84)																	b22 = (( (Float)(this34) ) / ( (Float)(255) ));
            																}
HXDLIN(  84)																Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  84)																int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  84)																int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  84)																int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  84)																int a5 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  84)																int blended1 = ((((a5 << 24) | (r3 << 16)) | (g3 << 8)) | b4);
HXDLIN(  84)																{
HXLINE(  84)																	int _hx_tmp6;
HXDLIN(  84)																	if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																		_hx_tmp6 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            																	}
            																	else {
HXLINE(  84)																		_hx_tmp6 = blended1;
            																	}
HXDLIN(  84)																	::iterMagic::Iimg_obj::set(this1->image,location1,_hx_tmp6);
            																}
            															}
            															else {
HXLINE(  84)																::Dynamic this35 = this1->image;
HXDLIN(  84)																int index5;
HXDLIN(  84)																if (this1->useVirtualPos) {
HXLINE(  84)																	index5 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - this1->virtualY) * ( (Float)(this1->width) )) + x3) - this1->virtualX));
            																}
            																else {
HXLINE(  84)																	index5 = ::Std_obj::_hx_int(( (Float)(((y3 * this1->width) + x3)) ));
            																}
HXDLIN(  84)																int _hx_tmp7;
HXDLIN(  84)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  84)																	_hx_tmp7 = ((((((c4 >> 24) & 255) << 24) | ((c4 & 255) << 16)) | (((c4 >> 8) & 255) << 8)) | ((c4 >> 16) & 255));
            																}
            																else {
HXLINE(  84)																	_hx_tmp7 = c4;
            																}
HXDLIN(  84)																::iterMagic::Iimg_obj::set(this35,index5,_hx_tmp7);
            															}
            														}
HXLINE( 236)														foundY = true;
            													}
            													else {
HXLINE(  84)														if (foundY) {
HXLINE(  84)															goto _hx_goto_39;
            														}
            													}
            												}
            											}
            											_hx_goto_39:;
            										}
            									}
            								}
HXDLIN(  84)								if ((hasHit == false)) {
HXLINE(  84)									 ::pi_xy::algo::HitTri v2 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx,by,cx1,cy1,true);
HXDLIN(  84)									if (hasUndo) {
HXLINE(  84)										v2->undoImage = undoImage;
HXDLIN(  84)										v2->undoX = xIter3->start;
HXDLIN(  84)										v2->undoY = yIter3->start;
            									}
            								}
            							}
            						}
            					}
HXLINE(  85)					lastX = nextX;
HXLINE(  86)					lastY = nextY;
            				}
            			}
            		}
            		else {
HXLINE(  89)			int _g22 = 0;
HXDLIN(  89)			int _g23 = (quarter + 1);
HXDLIN(  89)			while((_g22 < _g23)){
HXLINE(  89)				_g22 = (_g22 + 1);
HXDLIN(  89)				int i7 = (_g22 - 1);
HXLINE(  90)				Float nextX1 = (cx + (rx * ::Math_obj::cos((((( (Float)(i7) ) * theta) + ((Float)0.0001)) + omega))));
HXLINE(  91)				Float nextY1 = (cy + (ry * ::Math_obj::sin((((( (Float)(i7) ) * theta) + ((Float)0.0001)) + omega))));
HXLINE(  92)				{
HXLINE(  92)					 ::pi_xy::ImageStruct this36 = pixelimage;
HXDLIN(  92)					bool hasHit1 = false;
HXDLIN(  92)					{
HXLINE(  92)						Float bx1 = lastX;
HXDLIN(  92)						Float by1 = lastY;
HXDLIN(  92)						Float cx2 = nextX1;
HXDLIN(  92)						Float cy2 = nextY1;
HXDLIN(  92)						bool adjustWinding1 = (((((cx * by1) - (bx1 * cy)) + ((bx1 * cy2) - (cx2 * by1))) + ((cx2 * cy) - (cx * cy2))) > 0);
HXDLIN(  92)						if (!(adjustWinding1)) {
HXLINE(  92)							Float bx_1 = bx1;
HXDLIN(  92)							Float by_1 = by1;
HXLINE( 187)							bx1 = cx2;
HXLINE( 188)							by1 = cy2;
HXLINE( 189)							cx2 = bx_1;
HXLINE( 190)							cy2 = by_1;
            						}
HXLINE(  92)						{
HXLINE(  92)							bool hasUndo1 = false;
HXDLIN(  92)							Float s01 = ((cy * cx2) - (cx * cy2));
HXDLIN(  92)							Float sx1 = (cy2 - cy);
HXDLIN(  92)							Float sy1 = (cx - cx2);
HXDLIN(  92)							Float t01 = ((cx * by1) - (cy * bx1));
HXDLIN(  92)							Float tx1 = (cy - by1);
HXDLIN(  92)							Float ty1 = (bx1 - cx);
HXDLIN(  92)							Float A1 = ((((-(by1) * cx2) + (cy * (-(bx1) + cx2))) + (cx * (by1 - cy2))) + (bx1 * cy2));
HXDLIN(  92)							 ::pi_xy::iter::IntIterStart xIter31;
HXDLIN(  92)							if ((cx > bx1)) {
HXLINE(  92)								if ((cx > cx2)) {
HXLINE(  92)									int min4;
HXDLIN(  92)									if ((bx1 > cx2)) {
HXLINE(  92)										min4 = ::Math_obj::floor(cx2);
            									}
            									else {
HXLINE(  92)										min4 = ::Math_obj::floor(bx1);
            									}
HXDLIN(  92)									int ii_min8 = min4;
HXDLIN(  92)									int ii_max8 = ::Math_obj::ceil(cx);
HXDLIN(  92)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            								}
            								else {
HXLINE(  92)									int ii_min9 = ::Math_obj::floor(bx1);
HXDLIN(  92)									int ii_max9 = ::Math_obj::ceil(cx2);
HXDLIN(  92)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            								}
            							}
            							else {
HXLINE(  92)								if ((bx1 > cx2)) {
HXLINE(  92)									int min5;
HXDLIN(  92)									if ((cx > cx2)) {
HXLINE(  92)										min5 = ::Math_obj::floor(cx2);
            									}
            									else {
HXLINE(  92)										min5 = ::Math_obj::ceil(cx);
            									}
HXDLIN(  92)									int ii_min10 = min5;
HXDLIN(  92)									int ii_max10 = ::Math_obj::ceil(bx1);
HXDLIN(  92)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
            								}
            								else {
HXLINE(  92)									int ii_min11 = ::Math_obj::floor(cx);
HXDLIN(  92)									int ii_max11 = ::Math_obj::ceil(cx2);
HXDLIN(  92)									xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
            								}
            							}
HXDLIN(  92)							 ::pi_xy::iter::IntIterStart yIter31;
HXDLIN(  92)							if ((cy > by1)) {
HXLINE(  92)								if ((cy > cy2)) {
HXLINE(  92)									int min6;
HXDLIN(  92)									if ((by1 > cy2)) {
HXLINE(  92)										min6 = ::Math_obj::floor(cy2);
            									}
            									else {
HXLINE(  92)										min6 = ::Math_obj::floor(by1);
            									}
HXDLIN(  92)									int ii_min12 = min6;
HXDLIN(  92)									int ii_max12 = ::Math_obj::ceil(cy);
HXDLIN(  92)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            								}
            								else {
HXLINE(  92)									int ii_min13 = ::Math_obj::floor(by1);
HXDLIN(  92)									int ii_max13 = ::Math_obj::ceil(cy2);
HXDLIN(  92)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            								}
            							}
            							else {
HXLINE(  92)								if ((by1 > cy2)) {
HXLINE(  92)									int min7;
HXDLIN(  92)									if ((cy > cy2)) {
HXLINE(  92)										min7 = ::Math_obj::floor(cy2);
            									}
            									else {
HXLINE(  92)										min7 = ::Math_obj::ceil(cy);
            									}
HXDLIN(  92)									int ii_min14 = min7;
HXDLIN(  92)									int ii_max14 = ::Math_obj::ceil(by1);
HXDLIN(  92)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            								}
            								else {
HXLINE(  92)									int ii_min15 = ::Math_obj::floor(cy);
HXDLIN(  92)									int ii_max15 = ::Math_obj::ceil(cy2);
HXDLIN(  92)									yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            								}
            							}
HXDLIN(  92)							 ::pi_xy::ImageStruct undoImage3 = null();
HXDLIN(  92)							if (hasUndo1) {
HXLINE(  92)								int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  92)								int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  92)								 ::Dynamic imageType1 = null();
HXDLIN(  92)								 ::pi_xy::ImageStruct this37 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  92)								if (::hx::IsNull( imageType1 )) {
HXLINE(  54)									imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            								}
HXLINE(  92)								::Dynamic undoImage4;
HXDLIN(  92)								switch((int)(( (int)(imageType1) ))){
            									case (int)0: {
HXLINE(  92)										 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  92)										 ::iterMagic::BytesImg b5 = byt1;
HXDLIN(  92)										{
HXLINE(  92)											b5->width = width1;
HXDLIN(  92)											b5->height = height1;
HXDLIN(  92)											b5->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  92)											b5->data = ::haxe::io::Bytes_obj::alloc((b5->length * 4));
HXDLIN(  92)											{
HXLINE(  92)												int len2 = b5->length;
HXDLIN(  92)												int w1 = 0;
HXDLIN(  92)												{
HXLINE(  92)													int _g24 = 0;
HXDLIN(  92)													int _g25 = b5->height;
HXDLIN(  92)													while((_g24 < _g25)){
HXLINE(  92)														_g24 = (_g24 + 1);
HXDLIN(  92)														int y5 = (_g24 - 1);
HXDLIN(  92)														{
HXLINE(  92)															int _g26 = 0;
HXDLIN(  92)															int _g27 = b5->width;
HXDLIN(  92)															while((_g26 < _g27)){
HXLINE(  92)																_g26 = (_g26 + 1);
HXDLIN(  92)																int x5 = (_g26 - 1);
HXDLIN(  92)																{
HXLINE(  92)																	w1 = (w1 + 1);
HXDLIN(  92)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  92)																{
HXLINE(  92)																	w1 = (w1 + 1);
HXDLIN(  92)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  92)																{
HXLINE(  92)																	w1 = (w1 + 1);
HXDLIN(  92)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
HXDLIN(  92)																{
HXLINE(  92)																	w1 = (w1 + 1);
HXDLIN(  92)																	b5->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            																}
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  92)										undoImage4 = b5;
            									}
            									break;
            									case (int)1: {
HXLINE(  92)										 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  92)										 ::iterMagic::ArrIntImg a6 = arrI1;
HXDLIN(  92)										{
HXLINE(  92)											a6->width = width1;
HXDLIN(  92)											a6->height = height1;
HXDLIN(  92)											a6->data = ::Array_obj< int >::__new(0);
HXDLIN(  92)											a6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  92)											{
HXLINE(  92)												int _g28 = 0;
HXDLIN(  92)												int _g29 = a6->length;
HXDLIN(  92)												while((_g28 < _g29)){
HXLINE(  92)													_g28 = (_g28 + 1);
HXDLIN(  92)													int i8 = (_g28 - 1);
HXDLIN(  92)													a6->data[i8] = 0;
            												}
            											}
            										}
HXDLIN(  92)										undoImage4 = a6;
            									}
            									break;
            									case (int)2: {
HXLINE(  92)										 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  92)										 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN(  92)										{
HXLINE(  92)											b6->width = width1;
HXDLIN(  92)											b6->height = height1;
HXDLIN(  92)											b6->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  92)											int size1 = (b6->length * 4);
HXDLIN(  92)											b6->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  92)											{
HXLINE(  92)												int _g30 = 0;
HXDLIN(  92)												int _g31 = b6->length;
HXDLIN(  92)												while((_g30 < _g31)){
HXLINE(  92)													_g30 = (_g30 + 1);
HXDLIN(  92)													int i9 = (_g30 - 1);
HXDLIN(  92)													{
HXLINE(  92)														 ::haxe::io::ArrayBufferViewImpl this38 = b6->data;
HXDLIN(  92)														bool undoImage5;
HXDLIN(  92)														if ((i9 >= 0)) {
HXLINE(  92)															undoImage5 = (i9 < (this38->byteLength >> 2));
            														}
            														else {
HXLINE(  92)															undoImage5 = false;
            														}
HXDLIN(  92)														if (undoImage5) {
HXLINE(  92)															 ::haxe::io::Bytes _this1 = this38->bytes;
HXDLIN(  92)															int pos1 = ((i9 << 2) + this38->byteOffset);
HXDLIN(  92)															_this1->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  92)															_this1->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  92)															_this1->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  92)															_this1->b[(pos1 + 3)] = ( (unsigned char)(0) );
            														}
            													}
            												}
            											}
            										}
HXDLIN(  92)										undoImage4 = b6;
            									}
            									break;
            									case (int)3: {
HXLINE(  92)										 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  92)										 ::iterMagic::VecIntImg v3 = vec1;
HXDLIN(  92)										{
HXLINE(  92)											v3->width = width1;
HXDLIN(  92)											v3->height = height1;
HXDLIN(  92)											v3->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  92)											v3->data = ::Array_obj< int >::__new(v3->length);
HXDLIN(  92)											{
HXLINE(  92)												int _g32 = 0;
HXDLIN(  92)												int _g33 = v3->length;
HXDLIN(  92)												while((_g32 < _g33)){
HXLINE(  92)													_g32 = (_g32 + 1);
HXDLIN(  92)													int i10 = (_g32 - 1);
HXDLIN(  92)													v3->data->__unsafe_set(i10,0);
            												}
            											}
            										}
HXDLIN(  92)										undoImage4 = v3;
            									}
            									break;
            									case (int)4: {
HXLINE(  92)										 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  92)										 ::iterMagic::StackIntImg b7 = sInt1;
HXDLIN(  92)										{
HXLINE(  92)											b7->width = width1;
HXDLIN(  92)											b7->height = height1;
HXDLIN(  92)											b7->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  92)											b7->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  92)											{
HXLINE(  92)												int len3 = b7->length;
HXDLIN(  92)												 ::haxe::ds::GenericStack_Int d1 = b7->data;
HXDLIN(  92)												if (::hx::IsNull( d1->head )) {
HXLINE(  92)													int _g34 = 0;
HXDLIN(  92)													int _g35 = len3;
HXDLIN(  92)													while((_g34 < _g35)){
HXLINE(  92)														_g34 = (_g34 + 1);
HXDLIN(  92)														int i11 = (_g34 - 1);
HXDLIN(  92)														d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            													}
            												}
            												else {
HXLINE(  92)													int _g36 = 0;
HXDLIN(  92)													int _g37 = len3;
HXDLIN(  92)													while((_g36 < _g37)){
HXLINE(  92)														_g36 = (_g36 + 1);
HXDLIN(  92)														int i12 = (_g36 - 1);
HXDLIN(  92)														{
HXLINE(  92)															 ::haxe::ds::GenericCell_Int l1 = b7->data->head;
HXDLIN(  92)															 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  92)															{
HXLINE(  92)																int _g38 = 0;
HXDLIN(  92)																int _g39 = i12;
HXDLIN(  92)																while((_g38 < _g39)){
HXLINE(  92)																	_g38 = (_g38 + 1);
HXDLIN(  92)																	int i13 = (_g38 - 1);
HXLINE( 345)																	prev1 = l1;
HXLINE( 346)																	l1 = l1->next;
            																}
            															}
HXLINE(  92)															if (::hx::IsNull( prev1 )) {
HXLINE(  92)																b7->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  92)																l1 = null();
            															}
            															else {
HXLINE(  92)																prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  92)																l1 = null();
            															}
            														}
            													}
            												}
            											}
            										}
HXDLIN(  92)										undoImage4 = b7;
            									}
            									break;
            								}
HXDLIN(  92)								this37->image = undoImage4;
HXDLIN(  92)								this37->width = width1;
HXDLIN(  92)								this37->height = height1;
HXDLIN(  92)								this37->imageType = ( (int)(imageType1) );
HXDLIN(  92)								undoImage3 = this37;
HXDLIN(  92)								{
HXLINE(  92)									int rectLeft1 = xIter31->start;
HXDLIN(  92)									int rectTop1 = yIter31->start;
HXDLIN(  92)									int rectRight1 = xIter31->max;
HXDLIN(  92)									bool forceClear1 = false;
HXDLIN(  92)									{
HXLINE(  92)										int _g40 = rectTop1;
HXDLIN(  92)										int _g41 = yIter31->max;
HXDLIN(  92)										while((_g40 < _g41)){
HXLINE(  92)											_g40 = (_g40 + 1);
HXDLIN(  92)											int dy1 = (_g40 - 1);
HXDLIN(  92)											{
HXLINE(  92)												int _g42 = rectLeft1;
HXDLIN(  92)												int _g43 = rectRight1;
HXDLIN(  92)												while((_g42 < _g43)){
HXLINE(  92)													_g42 = (_g42 + 1);
HXDLIN(  92)													int dx1 = (_g42 - 1);
HXDLIN(  92)													::Dynamic this39 = this36->image;
HXDLIN(  92)													int index6;
HXDLIN(  92)													if (this36->useVirtualPos) {
HXLINE(  92)														index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this36->virtualY) * ( (Float)(this36->width) )) + dx1) - this36->virtualX));
            													}
            													else {
HXLINE(  92)														index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this36->width) + dx1)) ));
            													}
HXDLIN(  92)													int c5 = ::iterMagic::Iimg_obj::get(this39,index6);
HXDLIN(  92)													int col1;
HXDLIN(  92)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)														col1 = ((((((c5 >> 24) & 255) << 24) | ((c5 & 255) << 16)) | (((c5 >> 8) & 255) << 8)) | ((c5 >> 16) & 255));
            													}
            													else {
HXLINE(  92)														col1 = c5;
            													}
HXDLIN(  92)													bool _hx_tmp8;
HXDLIN(  92)													if (this36->useMask) {
HXLINE(  92)														_hx_tmp8 = ::hx::IsNotNull( this36->mask );
            													}
            													else {
HXLINE(  92)														_hx_tmp8 = false;
            													}
HXDLIN(  92)													if (_hx_tmp8) {
HXLINE(  92)														 ::pi_xy::ImageStruct this40 = this36->mask;
HXDLIN(  92)														::Dynamic this41 = this40->image;
HXDLIN(  92)														int index7;
HXDLIN(  92)														if (this40->useVirtualPos) {
HXLINE(  92)															index7 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this40->virtualY) * ( (Float)(this40->width) )) + dx1) - this40->virtualX));
            														}
            														else {
HXLINE(  92)															index7 = ::Std_obj::_hx_int(( (Float)(((dy1 * this40->width) + dx1)) ));
            														}
HXDLIN(  92)														int c6 = ::iterMagic::Iimg_obj::get(this41,index7);
HXDLIN(  92)														int v4;
HXDLIN(  92)														if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)															v4 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            														}
            														else {
HXLINE(  92)															v4 = c6;
            														}
HXDLIN(  92)														int maskPixel1 = v4;
HXDLIN(  92)														int this42 = col1;
HXDLIN(  92)														if ((maskPixel1 == 0)) {
HXLINE(  92)															col1 = this42;
            														}
            														else {
HXLINE(  92)															Float m01;
HXDLIN(  92)															int this43 = ((maskPixel1 >> 24) & 255);
HXDLIN(  92)															if ((this43 == 0)) {
HXLINE(  92)																m01 = ((Float)0.);
            															}
            															else {
HXLINE(  92)																m01 = (( (Float)(this43) ) / ( (Float)(255) ));
            															}
HXDLIN(  92)															Float m11;
HXDLIN(  92)															int this44 = ((maskPixel1 >> 16) & 255);
HXDLIN(  92)															if ((this44 == 0)) {
HXLINE(  92)																m11 = ((Float)0.);
            															}
            															else {
HXLINE(  92)																m11 = (( (Float)(this44) ) / ( (Float)(255) ));
            															}
HXDLIN(  92)															Float m21;
HXDLIN(  92)															int this45 = ((maskPixel1 >> 8) & 255);
HXDLIN(  92)															if ((this45 == 0)) {
HXLINE(  92)																m21 = ((Float)0.);
            															}
            															else {
HXLINE(  92)																m21 = (( (Float)(this45) ) / ( (Float)(255) ));
            															}
HXDLIN(  92)															Float m31;
HXDLIN(  92)															int this46 = (maskPixel1 & 255);
HXDLIN(  92)															if ((this46 == 0)) {
HXLINE(  92)																m31 = ((Float)0.);
            															}
            															else {
HXLINE(  92)																m31 = (( (Float)(this46) ) / ( (Float)(255) ));
            															}
HXDLIN(  92)															int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this42 >> 24) & 255)) )));
HXDLIN(  92)															int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this42 >> 16) & 255)) )));
HXDLIN(  92)															int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this42 >> 8) & 255)) )));
HXDLIN(  92)															int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this42 & 255)) )));
HXDLIN(  92)															col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            														}
            													}
HXDLIN(  92)													if ((col1 != 0)) {
HXLINE(  92)														int x6 = (dx1 - rectLeft1);
HXDLIN(  92)														int y6 = (dy1 - rectTop1);
HXDLIN(  92)														int c7 = col1;
HXDLIN(  92)														bool _hx_tmp9;
HXDLIN(  92)														if ((((c7 >> 24) & 255) < 254)) {
HXLINE(  92)															_hx_tmp9 = undoImage3->transparent;
            														}
            														else {
HXLINE(  92)															_hx_tmp9 = false;
            														}
HXDLIN(  92)														if (_hx_tmp9) {
HXLINE(  92)															int location2;
HXDLIN(  92)															if (undoImage3->useVirtualPos) {
HXLINE(  92)																location2 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            															}
            															else {
HXLINE(  92)																location2 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            															}
HXDLIN(  92)															int this47 = ::iterMagic::Iimg_obj::get(undoImage3->image,location2);
HXDLIN(  92)															int this48;
HXDLIN(  92)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)																this48 = ((((((this47 >> 24) & 255) << 24) | ((this47 & 255) << 16)) | (((this47 >> 8) & 255) << 8)) | ((this47 >> 16) & 255));
            															}
            															else {
HXLINE(  92)																this48 = this47;
            															}
HXDLIN(  92)															Float a12;
HXDLIN(  92)															int this49 = ((this48 >> 24) & 255);
HXDLIN(  92)															if ((this49 == 0)) {
HXLINE(  92)																a12 = ((Float)0.);
            															}
            															else {
HXLINE(  92)																a12 = (( (Float)(this49) ) / ( (Float)(255) ));
            															}
HXDLIN(  92)															Float r12;
HXDLIN(  92)															int this50 = ((this48 >> 16) & 255);
HXDLIN(  92)															if ((this50 == 0)) {
HXLINE(  92)																r12 = ((Float)0.);
            															}
            															else {
HXLINE(  92)																r12 = (( (Float)(this50) ) / ( (Float)(255) ));
            															}
HXDLIN(  92)															Float g12;
HXDLIN(  92)															int this51 = ((this48 >> 8) & 255);
HXDLIN(  92)															if ((this51 == 0)) {
HXLINE(  92)																g12 = ((Float)0.);
            															}
            															else {
HXLINE(  92)																g12 = (( (Float)(this51) ) / ( (Float)(255) ));
            															}
HXDLIN(  92)															Float b13;
HXDLIN(  92)															int this52 = (this48 & 255);
HXDLIN(  92)															if ((this52 == 0)) {
HXLINE(  92)																b13 = ((Float)0.);
            															}
            															else {
HXLINE(  92)																b13 = (( (Float)(this52) ) / ( (Float)(255) ));
            															}
HXDLIN(  92)															Float a22;
HXDLIN(  92)															int this53 = ((col1 >> 24) & 255);
HXDLIN(  92)															if ((this53 == 0)) {
HXLINE(  92)																a22 = ((Float)0.);
            															}
            															else {
HXLINE(  92)																a22 = (( (Float)(this53) ) / ( (Float)(255) ));
            															}
HXDLIN(  92)															Float r22;
HXDLIN(  92)															int this54 = ((col1 >> 16) & 255);
HXDLIN(  92)															if ((this54 == 0)) {
HXLINE(  92)																r22 = ((Float)0.);
            															}
            															else {
HXLINE(  92)																r22 = (( (Float)(this54) ) / ( (Float)(255) ));
            															}
HXDLIN(  92)															Float g22;
HXDLIN(  92)															int this55 = ((col1 >> 8) & 255);
HXDLIN(  92)															if ((this55 == 0)) {
HXLINE(  92)																g22 = ((Float)0.);
            															}
            															else {
HXLINE(  92)																g22 = (( (Float)(this55) ) / ( (Float)(255) ));
            															}
HXDLIN(  92)															Float b23;
HXDLIN(  92)															int this56 = (col1 & 255);
HXDLIN(  92)															if ((this56 == 0)) {
HXLINE(  92)																b23 = ((Float)0.);
            															}
            															else {
HXLINE(  92)																b23 = (( (Float)(this56) ) / ( (Float)(255) ));
            															}
HXDLIN(  92)															Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  92)															int r4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  92)															int g4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  92)															int b8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  92)															int a7 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  92)															int blended2 = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b8);
HXDLIN(  92)															{
HXLINE(  92)																int _hx_tmp10;
HXDLIN(  92)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)																	_hx_tmp10 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            																}
            																else {
HXLINE(  92)																	_hx_tmp10 = blended2;
            																}
HXDLIN(  92)																::iterMagic::Iimg_obj::set(undoImage3->image,location2,_hx_tmp10);
            															}
            														}
            														else {
HXLINE(  92)															::Dynamic this57 = undoImage3->image;
HXDLIN(  92)															int index8;
HXDLIN(  92)															if (undoImage3->useVirtualPos) {
HXLINE(  92)																index8 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x6) - undoImage3->virtualX));
            															}
            															else {
HXLINE(  92)																index8 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage3->width) + x6)) ));
            															}
HXDLIN(  92)															int _hx_tmp11;
HXDLIN(  92)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)																_hx_tmp11 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            															}
            															else {
HXLINE(  92)																_hx_tmp11 = c7;
            															}
HXDLIN(  92)															::iterMagic::Iimg_obj::set(this57,index8,_hx_tmp11);
            														}
            													}
            													else {
HXLINE(  92)														if (forceClear1) {
HXLINE(  92)															::Dynamic this58 = undoImage3->image;
HXDLIN(  92)															int x7 = (dx1 - rectLeft1);
HXDLIN(  92)															int y7 = (dy1 - rectTop1);
HXDLIN(  92)															int index9;
HXDLIN(  92)															if (undoImage3->useVirtualPos) {
HXLINE(  92)																index9 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage3->virtualY) * ( (Float)(undoImage3->width) )) + x7) - undoImage3->virtualX));
            															}
            															else {
HXLINE(  92)																index9 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage3->width) + x7)) ));
            															}
HXDLIN(  92)															::iterMagic::Iimg_obj::set(this58,index9,0);
            														}
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  92)							bool foundY1 = false;
HXDLIN(  92)							Float s1 = ((Float)0.);
HXDLIN(  92)							Float t1 = ((Float)0.);
HXDLIN(  92)							Float sxx1 = ((Float)0.);
HXDLIN(  92)							Float txx1 = ((Float)0.);
HXDLIN(  92)							{
HXLINE(  92)								int _g_min2 = xIter31->start;
HXDLIN(  92)								int _g_max2 = xIter31->max;
HXDLIN(  92)								while((_g_min2 < _g_max2)){
HXLINE(  92)									_g_min2 = (_g_min2 + 1);
HXDLIN(  92)									int x8 = (_g_min2 - 1);
HXLINE( 222)									sxx1 = (sx1 * ( (Float)(x8) ));
HXLINE( 223)									txx1 = (tx1 * ( (Float)(x8) ));
HXLINE( 224)									foundY1 = false;
HXLINE(  92)									{
HXLINE(  92)										int _g_min3 = yIter31->start;
HXDLIN(  92)										int _g_max3 = yIter31->max;
HXDLIN(  92)										while((_g_min3 < _g_max3)){
HXLINE(  92)											_g_min3 = (_g_min3 + 1);
HXDLIN(  92)											int y8 = (_g_min3 - 1);
HXLINE( 226)											s1 = ((s01 + sxx1) + (sy1 * ( (Float)(y8) )));
HXLINE( 227)											t1 = ((t01 + txx1) + (ty1 * ( (Float)(y8) )));
HXLINE(  92)											bool _hx_tmp12;
HXDLIN(  92)											if (!((s1 <= 0))) {
HXLINE(  92)												_hx_tmp12 = (t1 <= 0);
            											}
            											else {
HXLINE(  92)												_hx_tmp12 = true;
            											}
HXDLIN(  92)											if (_hx_tmp12) {
HXLINE(  92)												if (foundY1) {
HXLINE(  92)													goto _hx_goto_52;
            												}
            											}
            											else {
HXLINE(  92)												if (((s1 + t1) < A1)) {
HXLINE(  92)													int x9 = ::hx::Mod(x8,tileImage->width);
HXDLIN(  92)													int y9 = ::hx::Mod(y8,tileImage->height);
HXDLIN(  92)													::Dynamic this59 = tileImage->image;
HXDLIN(  92)													int index10;
HXDLIN(  92)													if (tileImage->useVirtualPos) {
HXLINE(  92)														index10 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - tileImage->virtualY) * ( (Float)(tileImage->width) )) + x9) - tileImage->virtualX));
            													}
            													else {
HXLINE(  92)														index10 = ::Std_obj::_hx_int(( (Float)(((y9 * tileImage->width) + x9)) ));
            													}
HXDLIN(  92)													int c8 = ::iterMagic::Iimg_obj::get(this59,index10);
HXDLIN(  92)													int color1;
HXDLIN(  92)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)														color1 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            													}
            													else {
HXLINE(  92)														color1 = c8;
            													}
HXDLIN(  92)													{
HXLINE(  92)														int c9 = color1;
HXDLIN(  92)														bool _hx_tmp13;
HXDLIN(  92)														if ((((c9 >> 24) & 255) < 254)) {
HXLINE(  92)															_hx_tmp13 = this36->transparent;
            														}
            														else {
HXLINE(  92)															_hx_tmp13 = false;
            														}
HXDLIN(  92)														if (_hx_tmp13) {
HXLINE(  92)															int location3;
HXDLIN(  92)															if (this36->useVirtualPos) {
HXLINE(  92)																location3 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - this36->virtualY) * ( (Float)(this36->width) )) + x8) - this36->virtualX));
            															}
            															else {
HXLINE(  92)																location3 = ::Std_obj::_hx_int(( (Float)(((y8 * this36->width) + x8)) ));
            															}
HXDLIN(  92)															int this60 = ::iterMagic::Iimg_obj::get(this36->image,location3);
HXDLIN(  92)															int this61;
HXDLIN(  92)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)																this61 = ((((((this60 >> 24) & 255) << 24) | ((this60 & 255) << 16)) | (((this60 >> 8) & 255) << 8)) | ((this60 >> 16) & 255));
            															}
            															else {
HXLINE(  92)																this61 = this60;
            															}
HXDLIN(  92)															Float a13;
HXDLIN(  92)															int this62 = ((this61 >> 24) & 255);
HXDLIN(  92)															if ((this62 == 0)) {
HXLINE(  92)																a13 = ((Float)0.);
            															}
            															else {
HXLINE(  92)																a13 = (( (Float)(this62) ) / ( (Float)(255) ));
            															}
HXDLIN(  92)															Float r13;
HXDLIN(  92)															int this63 = ((this61 >> 16) & 255);
HXDLIN(  92)															if ((this63 == 0)) {
HXLINE(  92)																r13 = ((Float)0.);
            															}
            															else {
HXLINE(  92)																r13 = (( (Float)(this63) ) / ( (Float)(255) ));
            															}
HXDLIN(  92)															Float g13;
HXDLIN(  92)															int this64 = ((this61 >> 8) & 255);
HXDLIN(  92)															if ((this64 == 0)) {
HXLINE(  92)																g13 = ((Float)0.);
            															}
            															else {
HXLINE(  92)																g13 = (( (Float)(this64) ) / ( (Float)(255) ));
            															}
HXDLIN(  92)															Float b14;
HXDLIN(  92)															int this65 = (this61 & 255);
HXDLIN(  92)															if ((this65 == 0)) {
HXLINE(  92)																b14 = ((Float)0.);
            															}
            															else {
HXLINE(  92)																b14 = (( (Float)(this65) ) / ( (Float)(255) ));
            															}
HXDLIN(  92)															Float a23;
HXDLIN(  92)															int this66 = ((color1 >> 24) & 255);
HXDLIN(  92)															if ((this66 == 0)) {
HXLINE(  92)																a23 = ((Float)0.);
            															}
            															else {
HXLINE(  92)																a23 = (( (Float)(this66) ) / ( (Float)(255) ));
            															}
HXDLIN(  92)															Float r23;
HXDLIN(  92)															int this67 = ((color1 >> 16) & 255);
HXDLIN(  92)															if ((this67 == 0)) {
HXLINE(  92)																r23 = ((Float)0.);
            															}
            															else {
HXLINE(  92)																r23 = (( (Float)(this67) ) / ( (Float)(255) ));
            															}
HXDLIN(  92)															Float g23;
HXDLIN(  92)															int this68 = ((color1 >> 8) & 255);
HXDLIN(  92)															if ((this68 == 0)) {
HXLINE(  92)																g23 = ((Float)0.);
            															}
            															else {
HXLINE(  92)																g23 = (( (Float)(this68) ) / ( (Float)(255) ));
            															}
HXDLIN(  92)															Float b24;
HXDLIN(  92)															int this69 = (color1 & 255);
HXDLIN(  92)															if ((this69 == 0)) {
HXLINE(  92)																b24 = ((Float)0.);
            															}
            															else {
HXLINE(  92)																b24 = (( (Float)(this69) ) / ( (Float)(255) ));
            															}
HXDLIN(  92)															Float a33 = (a13 * (( (Float)(1) ) - a23));
HXDLIN(  92)															int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  92)															int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  92)															int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b14 * a33) + (b24 * a23))));
HXDLIN(  92)															int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  92)															int blended3 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b9);
HXDLIN(  92)															{
HXLINE(  92)																int _hx_tmp14;
HXDLIN(  92)																if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)																	_hx_tmp14 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            																}
            																else {
HXLINE(  92)																	_hx_tmp14 = blended3;
            																}
HXDLIN(  92)																::iterMagic::Iimg_obj::set(this36->image,location3,_hx_tmp14);
            															}
            														}
            														else {
HXLINE(  92)															::Dynamic this70 = this36->image;
HXDLIN(  92)															int index11;
HXDLIN(  92)															if (this36->useVirtualPos) {
HXLINE(  92)																index11 = ::Std_obj::_hx_int(((((( (Float)(y8) ) - this36->virtualY) * ( (Float)(this36->width) )) + x8) - this36->virtualX));
            															}
            															else {
HXLINE(  92)																index11 = ::Std_obj::_hx_int(( (Float)(((y8 * this36->width) + x8)) ));
            															}
HXDLIN(  92)															int _hx_tmp15;
HXDLIN(  92)															if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  92)																_hx_tmp15 = ((((((c9 >> 24) & 255) << 24) | ((c9 & 255) << 16)) | (((c9 >> 8) & 255) << 8)) | ((c9 >> 16) & 255));
            															}
            															else {
HXLINE(  92)																_hx_tmp15 = c9;
            															}
HXDLIN(  92)															::iterMagic::Iimg_obj::set(this70,index11,_hx_tmp15);
            														}
            													}
HXLINE( 236)													foundY1 = true;
            												}
            												else {
HXLINE(  92)													if (foundY1) {
HXLINE(  92)														goto _hx_goto_52;
            													}
            												}
            											}
            										}
            										_hx_goto_52:;
            									}
            								}
            							}
HXDLIN(  92)							if ((hasHit1 == false)) {
HXLINE(  92)								 ::pi_xy::algo::HitTri v5 =  ::pi_xy::algo::HitTri_obj::__alloc( HX_CTX ,cx,cy,bx1,by1,cx2,cy2,true);
HXDLIN(  92)								if (hasUndo1) {
HXLINE(  92)									v5->undoImage = undoImage3;
HXDLIN(  92)									v5->undoX = xIter31->start;
HXDLIN(  92)									v5->undoY = yIter31->start;
            								}
            							}
            						}
            					}
            				}
HXLINE(  93)				lastX = nextX1;
HXLINE(  94)				lastY = nextY1;
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(QuadrantPixel_Fields__obj,tileSolidQuadrant,(void))


QuadrantPixel_Fields__obj::QuadrantPixel_Fields__obj()
{
}

bool QuadrantPixel_Fields__obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 13:
		if (HX_FIELD_EQ(inName,"solidQuadrant") ) { outValue = solidQuadrant_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"tileSolidQuadrant") ) { outValue = tileSolidQuadrant_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *QuadrantPixel_Fields__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *QuadrantPixel_Fields__obj_sStaticStorageInfo = 0;
#endif

::hx::Class QuadrantPixel_Fields__obj::__mClass;

static ::String QuadrantPixel_Fields__obj_sStaticFields[] = {
	HX_("solidQuadrant",47,09,c0,3c),
	HX_("tileSolidQuadrant",39,a9,75,36),
	::String(null())
};

void QuadrantPixel_Fields__obj::__register()
{
	QuadrantPixel_Fields__obj _hx_dummy;
	QuadrantPixel_Fields__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pi_xy.algo._QuadrantPixel.QuadrantPixel_Fields_",62,ec,41,92);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &QuadrantPixel_Fields__obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(QuadrantPixel_Fields__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< QuadrantPixel_Fields__obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = QuadrantPixel_Fields__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = QuadrantPixel_Fields__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pi_xy
} // end namespace algo
} // end namespace _QuadrantPixel
